/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: 
	22	11/05/97	leeber	Build 107 V4.50.03 B003 02/19/98 cjl Freeze of code for beta release.
	21	11/05/97	leeber	Build 107 V4.50.02 B002 01/30/98 BATS 546, 549, 558, 561, 557, 553 & 566 fixed and NUMEROUS build/kitting/archiving process files have been updated, UK and ML adds were done for 32 and 16 bit. 01/30/98 cjl
	20	11/05/97	leeber	Build 107 V4.50.01 B001 01/22/98 First try at V4.5 release (A32 V2.10.01). Several bugs found. 01/22/98 cjl
	19	11/05/97	leeber	Build 106 V4.41.13 R012 12/05/97 NWSNOAA freeze R012 Final Delivery. 12/09/97 cjl
	18	11/05/97	leeber	Build 106 V4.41.12 R011 12/05/97 SMIT/ACCESS32, mak/dsp 4 Alpha, NWS beta2+, UNIX,  and SAPI speed improvements. 12/05/97 cjl
	17	11/05/97	leeber	Build 106 V4.41.11 R010 11/21/97 Beta2 NWSNOAA and SAPI Updates. 11/21/97 cjl
	16	11/05/97	leeber	SNAPSHOT106  V4.41 R010 11/17/97 NWSNOAA Beta2 Trail Code, tested (16 & 32 bit) 11/17/97 cjl
	15	11/05/97	leeber	BATS 470, 510, 345, 486, 509, 499 & 500, NWSNOAA beta2 delivery (female voices), UK addes and updates (NO NEW MAK files). 11/12/97 cjl
	14	10/23/97	leeber	Build 106 V4.41.08 R009 10/31/97 NWSNOAA Beta1 Code Release, tested (16 & 32 bit) 10/31/97 cjl
	13	10/23/97	leeber	NWS\NOAA and UK code updates, tested for ENGLISH_US (16 & 32 bit), NWSNOAA and SPANISH (16 & 32 bit). There is a known date problem with non-NWSNOAA code. 10/31/97 cjl
	12	10/21/97	leeber	SNAPSHOT (Pre-R009 that will include buildable NWS/NOAA and code ONLY English UK). Also represents latest working (verified) ML for Intel/Windows and Alpha UNIX ONLY. Alpha NT has a build bug. 10/27/97 cjl
	11	10/21/97	leeber	CODE MARK POINT (Pre-R009 that will include buildable NWS/NOAA and code ONLY English UK). Also represents latest working (verified) ML for Intel/Windows and Alpha UNIX ONLY. Alpha NT has a build bug. 10/27/97 cjl
	10	10/21/97	leeber	BATS# 470, 475, 487 & 490; Fix Alpha builds of sample apps and DLLs; Fix failed startup exit error message; UNIX updates to doc files ($LOG problem). 10/22/97 cjl
	9	09/30/97	leeber	Build 106 V4.41.00 R008 10/01/97 Update for V4.41 with UNIX. 10/01/97 cjl
	8	09/30/97	leeber	Updated UNIX files; 10/01/97 cjl
	7	09/29/97	leeber	Working UNIX code check-in. 09/29/97 cjl
	6	05/16/97	leeber	Build 104 V4.40.43 R007 08/18/97; Static Builds, Help files, BATS 124, 147, 152, 223, 257, 270, 283, 298, 314, 340, 348, 351, 364, 384, 388, 390, 395, 396, 405, 409-412, 416, 422, 438 & 441. 08/18/97 cjl FREEZE
	5	05/16/97	leeber	Preliminary Code Freeze; Missing docs, hlp and tuning files; otherwisw complete. cjl BUILD 104 V4.40.40 R007 x8/07/97
	4	05/16/97	leeber	Build 104 V4.40.38 B006 _6/25/97 Typning Mode w/assistve32 SDK, Re_Freeze after system crash. 6/25/97 cjl
	3	05/16/97	leeber	Build 104 V4.40.38 B006 06/25/97 Typning Mode w/assistve32 SDK. 6/25/97 cjl
	2	05/16/97	leeber	This is "BUILD 104 V4.40.37 B006H 06/20/97" and contans the special typing_mode build for Henter Joyce. 6/20/97 cjl
	1	05/16/97	simoneau	Initial Version
$LOG problem). 10/22/97 cjl
	9	09/30/97	leeber	Build 106 V4.41.00 R008 10/01/97 Update for V4.41 with UNIX. 10/01/97 cjl
	8	09/30/97	leeber	Updated UNIX files; 10/01/97 cjl
	7	09/29/97	leeber	Working UNIX code check-in. 09/29/97 cjl
	6	05/16/97	leeber	Build 104 V4.40.43 R007 08/18/97; Static Builds, Help files, BATS 124, 147, 152, 223, 257, 270, 283, 298, 314, 340, 348, 351, 364, 384, 388, 390, 395, 396, 405, 409-412, 416, 422, 438 & 441. 08/18/97 cjl FREEZE
	5	05/16/97	leeber	Preliminary Code Freeze; Missing docs, hlp and tuning files; otherwisw complete. cjl BUILD 104 V4.40.40 R007 x8/07/97
	4	05/16/97	leeber	Build 104 V4.40.38 B006 _6/25/97 Typning Mode w/assistve32 SDK, Re_Freeze after system crash. 6/25/97 cjl
	3	05/16/97	leeber	Build 104 V4.40.38 B006 06/25/97 Typning Mode w/assistve32 SDK. 6/25/97 cjl
	2	05/16/97	leeber	This is "BUILD 104 V4.40.37 B006H 06/20/97" and contans the special typing_mode build for Henter Joyce. 6/20/97 cjl
	1	05/16/97	simoneau	Initial Version
$LOG problem). 10/22/97 cjl
	9	09/30/97	leeber	Build 106 V4.41.00 R008 10/01/97 Update for V4.41 with UNIX. 10/01/97 cjl
	8	09/30/97	leeber	Updated UNIX files; 10/01/97 cjl
	7	09/29/97	leeber	Working UNIX code check-in. 09/29/97 cjl
	6	05/16/97	leeber	Build 104 V4.40.43 R007 08/18/97; Static Builds, Help files, BATS 124, 147, 152, 223, 257, 270, 283, 298, 314, 340, 348, 351, 364, 384, 388, 390, 395, 396, 405, 409-412, 416, 422, 438 & 441. 08/18/97 cjl FREEZE
	5	05/16/97	leeber	Preliminary Code Freeze; Missing docs, hlp and tuning files; otherwisw complete. cjl BUILD 104 V4.40.40 R007 x8/07/97
	4	05/16/97	leeber	Build 104 V4.40.38 B006 _6/25/97 Typning Mode w/assistve32 SDK, Re_Freeze after system crash. 6/25/97 cjl
	3	05/16/97	leeber	Build 104 V4.40.38 B006 06/25/97 Typning Mode w/assistve32 SDK. 6/25/97 cjl
	2	05/16/97	leeber	This is "BUILD 104 V4.40.37 B006H 06/20/97" and contans the special typing_mode build for Henter Joyce. 6/20/97 cjl
	1	05/16/97	simoneau	Initial Version
$LOG problem). 10/22/97 cjl
	9	09/30/97	leeber	Build 106 V4.41.00 R008 10/01/97 Update for V4.41 with UNIX. 10/01/97 cjl
	8	09/30/97	leeber	Updated UNIX files; 10/01/97 cjl
	7	09/29/97	leeber	Working UNIX code check-in. 09/29/97 cjl
	6	05/16/97	leeber	Build 104 V4.40.43 R007 08/18/97; Static Builds, Help files, BATS 124, 147, 152, 223, 257, 270, 283, 298, 314, 340, 348, 351, 364, 384, 388, 390, 395, 396, 405, 409-412, 416, 422, 438 & 441. 08/18/97 cjl FREEZE
	5	05/16/97	leeber	Preliminary Code Freeze; Missing docs, hlp and tuning files; otherwisw complete. cjl BUILD 104 V4.40.40 R007 x8/07/97
	4	05/16/97	leeber	Build 104 V4.40.38 B006 _6/25/97 Typning Mode w/assistve32 SDK, Re_Freeze after system crash. 6/25/97 cjl
	3	05/16/97	leeber	Build 104 V4.40.38 B006 06/25/97 Typning Mode w/assistve32 SDK. 6/25/97 cjl
	2	05/16/97	leeber	This is "BUILD 104 V4.40.37 B006H 06/20/97" and contans the special typing_mode build for Henter Joyce. 6/20/97 cjl
	1	05/16/97	simoneau	Initial Version
$LOG problem). 10/22/97 cjl
	9	09/30/97	leeber	Build 106 V4.41.00 R008 10/01/97 Update for V4.41 with UNIX. 10/01/97 cjl
	8	09/30/97	leeber	Updated UNIX files; 10/01/97 cjl
	7	09/29/97	leeber	Working UNIX code check-in. 09/29/97 cjl
	6	05/16/97	leeber	Build 104 V4.40.43 R007 08/18/97; Static Builds, Help files, BATS 124, 147, 152, 223, 257, 270, 283, 298, 314, 340, 348, 351, 364, 384, 388, 390, 395, 396, 405, 409-412, 416, 422, 438 & 441. 08/18/97 cjl FREEZE
	5	05/16/97	leeber	Preliminary Code Freeze; Missing docs, hlp and tuning files; otherwisw complete. cjl BUILD 104 V4.40.40 R007 x8/07/97
	4	05/16/97	leeber	Build 104 V4.40.38 B006 _6/25/97 Typning Mode w/assistve32 SDK, Re_Freeze after system crash. 6/25/97 cjl
	3	05/16/97	leeber	Build 104 V4.40.38 B006 06/25/97 Typning Mode w/assistve32 SDK. 6/25/97 cjl
	2	05/16/97	leeber	This is "BUILD 104 V4.40.37 B006H 06/20/97" and contans the special typing_mode build for Henter Joyce. 6/20/97 cjl
	1	05/16/97	simoneau	Initial Version
$LOG problem). 10/22/97 cjl
	9	09/30/97	leeber	Build 106 V4.41.00 R008 10/01/97 Update for V4.41 with UNIX. 10/01/97 cjl
	8	09/30/97	leeber	Updated UNIX files; 10/01/97 cjl
	7	09/29/97	leeber	Working UNIX code check-in. 09/29/97 cjl
	6	05/16/97	leeber	Build 104 V4.40.43 R007 08/18/97; Static Builds, Help files, BATS 124, 147, 152, 223, 257, 270, 283, 298, 314, 340, 348, 351, 364, 384, 388, 390, 395, 396, 405, 409-412, 416, 422, 438 & 441. 08/18/97 cjl FREEZE
	5	05/16/97	leeber	Preliminary Code Freeze; Missing docs, hlp and tuning files; otherwisw complete. cjl BUILD 104 V4.40.40 R007 x8/07/97
	4	05/16/97	leeber	Build 104 V4.40.38 B006 _6/25/97 Typning Mode w/assistve32 SDK, Re_Freeze after system crash. 6/25/97 cjl
	3	05/16/97	leeber	Build 104 V4.40.38 B006 06/25/97 Typning Mode w/assistve32 SDK. 6/25/97 cjl
	2	05/16/97	leeber	This is "BUILD 104 V4.40.37 B006H 06/20/97" and contans the special typing_mode build for Henter Joyce. 6/20/97 cjl
	1	05/16/97	simoneau	Initial Version
$LOG problem). 10/22/97 cjl
	9	09/30/97	leeber	Build 106 V4.41.00 R008 10/01/97 Update for V4.41 with UNIX. 10/01/97 cjl
	8	09/30/97	leeber	Updated UNIX files; 10/01/97 cjl
	7	09/29/97	leeber	Working UNIX code check-in. 09/29/97 cjl
	6	05/16/97	leeber	Build 104 V4.40.43 R007 08/18/97; Static Builds, Help files, BATS 124, 147, 152, 223, 257, 270, 283, 298, 314, 340, 348, 351, 364, 384, 388, 390, 395, 396, 405, 409-412, 416, 422, 438 & 441. 08/18/97 cjl FREEZE
	5	05/16/97	leeber	Preliminary Code Freeze; Missing docs, hlp and tuning files; otherwisw complete. cjl BUILD 104 V4.40.40 R007 x8/07/97
	4	05/16/97	leeber	Build 104 V4.40.38 B006 _6/25/97 Typning Mode w/assistve32 SDK, Re_Freeze after system crash. 6/25/97 cjl
	3	05/16/97	leeber	Build 104 V4.40.38 B006 06/25/97 Typning Mode w/assistve32 SDK. 6/25/97 cjl
	2	05/16/97	leeber	This is "BUILD 104 V4.40.37 B006H 06/20/97" and contans the special typing_mode build for Henter Joyce. 6/20/97 cjl
	1	05/16/97	simoneau	Initial Version
$LOG problem). 10/22/97 cjl
	9	09/30/97	leeber	Build 106 V4.41.00 R008 10/01/97 Update for V4.41 with UNIX. 10/01/97 cjl
	8	09/30/97	leeber	Updated UNIX files; 10/01/97 cjl
	7	09/29/97	leeber	Working UNIX code check-in. 09/29/97 cjl
	6	05/16/97	leeber	Build 104 V4.40.43 R007 08/18/97; Static Builds, Help files, BATS 124, 147, 152, 223, 257, 270, 283, 298, 314, 340, 348, 351, 364, 384, 388, 390, 395, 396, 405, 409-412, 416, 422, 438 & 441. 08/18/97 cjl FREEZE
	5	05/16/97	leeber	Preliminary Code Freeze; Missing docs, hlp and tuning files; otherwisw complete. cjl BUILD 104 V4.40.40 R007 x8/07/97
	4	05/16/97	leeber	Build 104 V4.40.38 B006 _6/25/97 Typning Mode w/assistve32 SDK, Re_Freeze after system crash. 6/25/97 cjl
	3	05/16/97	leeber	Build 104 V4.40.38 B006 06/25/97 Typning Mode w/assistve32 SDK. 6/25/97 cjl
	2	05/16/97	leeber	This is "BUILD 104 V4.40.37 B006H 06/20/97" and contans the special typing_mode build for Henter Joyce. 6/20/97 cjl
	1	05/16/97	simoneau	Initial Version
$LOG problem). 10/22/97 cjl
	9	09/30/97	leeber	Build 106 V4.41.00 R008 10/01/97 Update for V4.41 with UNIX. 10/01/97 cjl
	8	09/30/97	leeber	Updated UNIX files; 10/01/97 cjl
	7	09/29/97	leeber	Working UNIX code check-in. 09/29/97 cjl
	6	05/16/97	leeber	Build 104 V4.40.43 R007 08/18/97; Static Builds, Help files, BATS 124, 147, 152, 223, 257, 270, 283, 298, 314, 340, 348, 351, 364, 384, 388, 390, 395, 396, 405, 409-412, 416, 422, 438 & 441. 08/18/97 cjl FREEZE
	5	05/16/97	leeber	Preliminary Code Freeze; Missing docs, hlp and tuning files; otherwisw complete. cjl BUILD 104 V4.40.40 R007 x8/07/97
	4	05/16/97	leeber	Build 104 V4.40.38 B006 _6/25/97 Typning Mode w/assistve32 SDK, Re_Freeze after system crash. 6/25/97 cjl
	3	05/16/97	leeber	Build 104 V4.40.38 B006 06/25/97 Typning Mode w/assistve32 SDK. 6/25/97 cjl
	2	05/16/97	leeber	This is "BUILD 104 V4.40.37 B006H 06/20/97" and contans the special typing_mode build for Henter Joyce. 6/20/97 cjl
	1	05/16/97	simoneau	Initial Version
$LOG problem). 10/22/97 cjl
	9	09/30/97	leeber	Build 106 V4.41.00 R008 10/01/97 Update for V4.41 with UNIX. 10/01/97 cjl
	8	09/30/97	leeber	Updated UNIX files; 10/01/97 cjl
	7	09/29/97	leeber	Working UNIX code check-in. 09/29/97 cjl
	6	05/16/97	leeber	Build 104 V4.40.43 R007 08/18/97; Static Builds, Help files, BATS 124, 147, 152, 223, 257, 270, 283, 298, 314, 340, 348, 351, 364, 384, 388, 390, 395, 396, 405, 409-412, 416, 422, 438 & 441. 08/18/97 cjl FREEZE
	5	05/16/97	leeber	Preliminary Code Freeze; Missing docs, hlp and tuning files; otherwisw complete. cjl BUILD 104 V4.40.40 R007 x8/07/97
	4	05/16/97	leeber	Build 104 V4.40.38 B006 _6/25/97 Typning Mode w/assistve32 SDK, Re_Freeze after system crash. 6/25/97 cjl
	3	05/16/97	leeber	Build 104 V4.40.38 B006 06/25/97 Typning Mode w/assistve32 SDK. 6/25/97 cjl
	2	05/16/97	leeber	This is "BUILD 104 V4.40.37 B006H 06/20/97" and contans the special typing_mode build for Henter Joyce. 6/20/97 cjl
	1	05/16/97	simoneau	Initial Version
$LOG problem). 10/22/97 cjl
	9	09/30/97	leeber	Build 106 V4.41.00 R008 10/01/97 Update for V4.41 with UNIX. 10/01/97 cjl
	8	09/30/97	leeber	Updated UNIX files; 10/01/97 cjl
	7	09/29/97	leeber	Working UNIX code check-in. 09/29/97 cjl
	6	05/16/97	leeber	Build 104 V4.40.43 R007 08/18/97; Static Builds, Help files, BATS 124, 147, 152, 223, 257, 270, 283, 298, 314, 340, 348, 351, 364, 384, 388, 390, 395, 396, 405, 409-412, 416, 422, 438 & 441. 08/18/97 cjl FREEZE
	5	05/16/97	leeber	Preliminary Code Freeze; Missing docs, hlp and tuning files; otherwisw complete. cjl BUILD 104 V4.40.40 R007 x8/07/97
	4	05/16/97	leeber	Build 104 V4.40.38 B006 _6/25/97 Typning Mode w/assistve32 SDK, Re_Freeze after system crash. 6/25/97 cjl
	3	05/16/97	leeber	Build 104 V4.40.38 B006 06/25/97 Typning Mode w/assistve32 SDK. 6/25/97 cjl
	2	05/16/97	leeber	This is "BUILD 104 V4.40.37 B006H 06/20/97" and contans the special typing_mode build for Henter Joyce. 6/20/97 cjl
	1	05/16/97	simoneau	Initial Version
$
 * Revision 1.1.2.30  1997/04/28  17:00:00  Ginger Lin
 *      Changed cmd_def.h to cm_def.h and cminst.h to cm_data.h
 *      lts_init() to ls_util_lts_init()
 *      phinst.h to ph_def.h
 *      [1997/04/28  17:00:00  Ginger Lin]
 *
 * Revision 1.1.2.29  1997/01/29  16:06:33  Darrell_Stam
 * 	Changed the function prototype/definition for StartDecTalkSystemThread
 * 	so it uses the more generic HTHREAD_T instead of HANDLE.
 * 	[1997/01/29  16:06:17  Darrell_Stam]
 *
 * Revision 1.1.2.28  1996/11/19  12:22:36  Cathy_Page
 * 	Added WAVERR_BADFORMAT as return value to TextToSpeechStartupEx().
 * 	Now returns MMSYSERR_NOTENABLED when licens pak does not exist.
 * 	Cleanup pKsd_t in TextToSpeechStartupEx().
 * 	[1996/11/19  12:20:43  Cathy_Page]
 * 
 * Revision 1.1.2.27  1996/10/31  12:53:55  Cathy_Page
 * 	Initialized pcsBufferPipe in TextToSpeechStartupEx
 * 	[1996/10/31  12:47:31  Cathy_Page]
 * 
 * Revision 1.1.2.26  1996/10/18  12:14:55  Cathy_Page
 * 	Added lmf error checking.
 * 	Added ReturnRemainingBuffers and DrainPipes routines.
 * 	Ported over NT's fixes for TextToSpeechReset function.
 * 	Added in bInReset and pcsBufferPipe to fix code changes from NT
 * 	[1996/10/18  12:06:49  Cathy_Page]
 * 
 * Revision 1.1.2.25  1996/10/01  17:14:46  Cathy_Page
 * 	Initialized uiID_*_Message fields with TTS_MSG_* constants
 * 	[1996/10/01  17:13:28  Cathy_Page]
 * 
 * Revision 1.1.2.24  1996/09/30  12:03:23  Cathy_Page
 * 	Removed debug print statements
 * 	Added in the freeing of hTextInQueueEvent event handle
 * 	[1996/09/30  12:02:34  Cathy_Page]
 * 
 * Revision 1.1.2.23  1996/09/25  13:43:48  Cathy_Page
 * 	Created from V4.3 NT code
 * 	[1996/09/25  13:41:44  Cathy_Page]
 * 
 * $EndLog$
 */
/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  COPYRIGHT NOTICE                                                  */
/*                                                                    */
/*  Copyright (c) Digital Equipment Corporation, 1993                 */
/*  All Rights reserved. Unpublished rights reserved under the        */
/*  copyright laws of the United States. Copyright is claimed in      */
/*  the computer program and user interface thereof.                  */
/*                                                                    */
/*  The software contained on this media is proprietary to and        */
/*  embodies the confidential technology of Digital Equipment         */
/*  Corporation. Possession, use, duplication or dissemination of     */
/*  the software and media is authorized only pursuant to a valid     */
/*  written license from Digital Equipment Corporation.               */
/*                                                                    */
/*  The name of Digital Equipment Corporation may not be used to      */
/*  endorse or promote products derived from this software without    */
/*  specific prior written permission. All other rights reserved.     */
/*                                                                    */
/*  THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR      */
/*  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, IMPLIED        */
/*  WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS        */
/*  FOR A PARTICULAR PURPOSE.                                         */
/*  Digital assumes no responsibility AT ALL for the use or           */
/*  reliability of this software.                                     */
/*                                                                    */
/*                                                                    */
/* +----------------------------------------------------------------+ */
/* | USE, DUPLICATION OR DISCLOSURE BY THE U.S. GOVERNMENT IS       | */
/* | SUBJECT TO RESTRICTIONS AS SET FORTH IN SUBPARAGRAPH (c)       | */
/* | DFARS 252.227-7013, OR IN FAR 52.227-14 ALT. II, AS APPLICABLE.| */
/* |                                                                | */
/* +----------------------------------------------------------------+ */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Text-To-Speech API                                                */
/*  Author: Bill Hallahan                                             */
/*  Date: July 6, 1993                                                */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This file contains all of the API function for             */
/*    Text-To-Speech using DECtalk under the Windows NT operating     */
/*    system.                                                         */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/
/* revision history
 * 21Apr96              ...GL           add language pipe code
 *                                                                    */
/**********************************************************************/




/**********************************************************************/
/*  Include files.                                                    */
/**********************************************************************/

#include "opthread.h"
#include <stdio.h>
#include <stdlib.h>    /* MVP: For the routine atol() */
#include <string.h>
#include <malloc.h>
#ifndef __linux__
#include <mmsystem.h>
#endif
#include <sys/types.h>
#include "port.h"
#include "defs.h"
#include "esc.h"
#include "kernel.h"
#include "cmd.h"
#include "samprate.h"
#include "tts.h"
#include "cm_def.h"
#include "cm_data.h"

// tek 05aug96 changes to allow freeing the PH thread data..
#include "ph_def.h"

void FreePHInstanceData(void *); // tek 05aug96 this is a broken prototype
/* tek 03sep96 pull buffer flush into a separate routine.. */
void ReturnRemainingBuffers( LPTTS_HANDLE_T phTTS );
void DrainPipes(LPTTS_HANDLE_T phTTS); //tek 04sep96

/**********************************************************************/
/*  Symbol definitions.                                               */
/**********************************************************************/

#ifdef ENGLISH_US
#define CUSTR_STR_VERSION "US"
#endif
#ifdef ENGLISH_UK
#define CUSTR_STR_VERSION "UK"
#endif
#ifdef GERMAN
#define CUSTR_STR_VERSION "GR"
#endif
#ifdef SPANISH
#ifdef LATIN_AMERICAN
#define CUSTR_STR_VERSION "LA"
#else
#define CUSTR_STR_VERSION "SP"
#endif
#endif



#define  MIN_SPEAKING_RATE   75
#define  MAX_SPEAKING_RATE  600

#define  CMD_PIPE_LENGTH          64
#define  LTS_PIPE_LENGTH         128
#define  PH_PIPE_LENGTH          256
#define  VTM_PIPE_LENGTH       16384
#define  SYNC_PIPE_LENGTH        256
#define  BUFFER_PIPE_LENGTH      256
#define  MAX_TEXT_WRITE_LENGTH    16                      

/**********************************************************************/
/*  Window Messages.                                                  */
/**********************************************************************/

#define  ID_TTS_Queue_Text      WM_USER + 0
#define  ID_TTS_Destroy         WM_USER + 1

/**********************************************************************/
/*  External function declarations.                                   */
/**********************************************************************/
OP_THREAD_ROUTINE(cmd_main, LPTTS_HANDLE_T phTTS);

OP_THREAD_ROUTINE(lts_main, LPTTS_HANDLE_T phTTS);
                                 
OP_THREAD_ROUTINE(ph_main, LPTTS_HANDLE_T phTTS);    

OP_THREAD_ROUTINE(vtm_main, LPTTS_HANDLE_T phTTS);

OP_THREAD_ROUTINE(sync_main, LPTTS_HANDLE_T phTTS);

extern MMRESULT load_dictionary( HWND,
				 void **,
				 unsigned int *,
				 char *,
				 BOOL,
				 BOOL );

extern void unload_dictionary( void **, unsigned int * );

extern void SetSampleRate( LPTTS_HANDLE_T, unsigned int );

extern void cmd_init( LPTTS_HANDLE_T ,BOOL );

/* MVP : Function to free CMD thread specific memory allocations */
extern void FreeCMDThreadMemory(PCMD_T pCmd_t);

extern void ls_util_lts_init( PVOID );

extern void phinit( LPTTS_HANDLE_T , BOOL );

extern void InitializeVTM( LPTTS_HANDLE_T );

extern void free_index( PKSD_T);

extern unsigned int kernel_disable( PKSD_T pKsd_t );

extern void kernel_enable( PKSD_T pKsd_t, unsigned int );

/**********************************************************************/
/*  Function prototypes.                                              */
/**********************************************************************/

static LPTTS_BUFFER_T GetBuffer( LPTTS_HANDLE_T );

static void DeleteTextToSpeechObjects( LPTTS_HANDLE_T );
/* Function prototype for SetSpeaker now will have LPTTS_HANDLE_T arg for MI : MVP */
static void SetSpeaker( LPTTS_HANDLE_T,SPEAKER_T );

static OP_THREAD_ROUTINE(TextToSpeechThreadMain, LPTTS_HANDLE_T phTTS);

static HWND InitTextToSpeechWindow( LPTTS_HANDLE_T );

static void Process_TTS_Message( LPTTS_HANDLE_T, LPARAM );

static void WaitForTextQueuingToComplete( LPTTS_HANDLE_T, BOOL );

static unsigned char LinearToMuLaw( short );

static void FixMemoryLockup( LPTTS_HANDLE_T phTTS );

static MMRESULT WaitForEmptyPipes( LPTTS_HANDLE_T, DWORD, BOOL );
/*MVP : generic Dectalk system thread create function */

#ifdef 0
typedef unsigned int ( __stdcall * start_address )(void *);
#endif

static int StartDecTalkSystemThread(LPTTS_HANDLE_T phTTS, HTHREAD_T *ppDecTalkThread,
									BOOL bMalloc, OP_THREAD_ROUTINE(ThreadFunction, LPTTS_HANDLE_T phTTS));

unsigned int PlayAudioCallbackRoutine( HPLAY_AUDIO_T pPlayAudio,
					   ATYPE_T aInstance,
									   ATYPE_T aMessage,
									   ATYPE_T aItem_1 );
VOID DefaultTTSCallbackRoutine(LONG lParam1,
							   LONG lParam2,
							   DWORD dwInstanceParam,
							   UINT uiMsg);

/**********************************************************************/
/*  Global variables.                                                 */
/**********************************************************************/

/*extern short uiCurrentSpeaker;*/    /* MVP MI */        

/*extern short last_voice;    */      /* MVP MI */

/*extern short sprate;        */      /* MVP MI */

/*The below line was commented out for MI : MVP
struct share_data kernel_data, *kernel_share = &kernel_data;
*/

/* The below line was commented out for MI :MVP*/
/*LPTTS_HANDLE_T phTTSglobal = NULL;*/

/*********************************************************************/
/* MVP : GLOBALS Added to load main dictionary only ONCE for all     */
/* instances                                                         */
  int                       gnInstanceCounter = 0;
  int far                   *gpufdic          = NULL;
  S32                       gufdic_entries     = 0;
/*********************************************************************/
#ifndef __linux__
#define LICENSES
#endif

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechStartupEx                                     */
/*  Author: Bill Hallahan                                             */
/*  Date: April 13, 1993                                              */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*    DECtalk initialization function.                                */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*                                                                    */
/*    pphTTS              A pointer to a pointer to a structure of    */
/*                        type TTS_HANDLE_T. This function allocates  */
/*                        memory for the structure.                   */
/*                                                                    */
/*    uiDeviceNumber      An unsigned integer which is the wave out   */
/*                        device ID number. WAVE_MAPPER may be used   */
/*                        here if the device ID number is unknown.    */
/*                                                                    */
/*    dwDeviceOptions     A DWORD which specifies how the wave output */
/*                        device is managed. It may be a combination  */
/*                        of the following values:                    */
/*                                                                    */
/*       value                 performance characteristic             */
/*                                                                    */
/*  OWN_AUDIO_DEVICE      The wave output device will be opened upon  */
/*                        return from this function. No other process */
/*                        may allocate the wave output device until   */
/*                        the CloseAudio() function is called. If     */
/*                        there are no wave output devices in the     */
/*                        system then MMSYSERR_NOTSUPPORTED will be   */
/*                        returned and the Text-To-Speech system will */
/*                        not be started.                             */
/*                                                                    */
/*                        If OWN_AUDIO_DEVICE is NOT specified then   */
/*                        the wave output device will be opened       */
/*                        sometime after audio is queued by the       */
/*                        TextToSpeechSpeak() function. The wave      */
/*                        output device will be held as long as       */
/*                        sufficient audio samples are queued.        */
/*                        Otherwise the device will be released.      */
/*                                                                    */
/*  REPORT_OPEN_ERROR     If an attempt is made to open the wave      */
/*                        output device while another process owns    */
/*                        it, then an error message will be sent to   */
/*                        the window procedure which corresponds to   */
/*                        the window handle which is passed to this   */
/*                        function.                                   */
/*                                                                    */
/*  DO_NOT_USE_AUDIO_DEVICE  The Text-To-Speech system may only be    */
/*                           used to write wave files, write speech   */
/*                           samples to memory, or log phonemes. No   */
/*                           error will be returned if a wave output  */
/*                           device is not present.                   */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a status code of type MMRESULT.           */
/*    This value is zero if initialization was successful.            */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_NODRIVER      No wave out device driver present        */
/*    MMSYSERR_BADDEVICEID   Device ID out of range                   */
/*    MMSYSERR_NOMEM         Unable to allocate memory                */
/*    MMSYSERR_ERROR         Dictionary not found                     */
/*    MMSYSERR_INVALPARAM    Invalid param for th eload dictionary    */
/*    WAVERR_BADFORMAT       A wave device exists, but does not have  */
/*                           the required format.                     */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

#define  STARTUP_LOOP_WAIT_TIME   50
#define  MAX_STARTUP_WAIT_COUNT  200

MMRESULT TextToSpeechStartupEx( LPTTS_HANDLE_T * pphTTS,
				  UINT uiDeviceNumber,
				  DWORD dwDeviceOptions,
				  VOID (*DtCallbackRoutine)(LONG,LONG,DWORD,UINT),
				  LONG dwTTSInstanceParameter)
{
  MMRESULT mmStatus;
  UINT i;
  int  productIndex; /* Index into product license list */

#ifdef OLEDECTALK
  LPAUDIO_HANDLE_T pPlayAudio;
#else
  HPLAY_AUDIO_T pPlayAudio;         //New audio Integration
#endif

#ifndef OLEDECTALK
  LPWAVEFORMATEX pWaveFormat;
#endif
  LPTTS_HANDLE_T phTTS;
  int nReturnCode;           /*MVP : a variable to hold the return value of this API*/

  P_PIPE cmd_pipe = NULL_PIPE;
  P_PIPE lts_pipe = NULL_PIPE;
  P_PIPE ph_pipe  = NULL_PIPE;
  P_PIPE vtm_pipe = NULL_PIPE;
  P_PIPE sync_pipe = NULL_PIPE;
  /* Define a variable for kernel_share_data to allocate after dynamically :MVP
  */
  PKSD_T pKsd_t = NULL;

/* MGS put licensing back in */

#ifdef LICENSES
#ifdef WIN32
#define MAX_INSTANCES_EXCEEDED  (MMSYSERR_ALLOCATED) // tek 29jul96
if (!AddLicenseRef())
        {
        return MAX_INSTANCES_EXCEEDED;
        }
#else
  /* Check for a valid license */
  mmStatus = CheckLicenses();
  if (mmStatus)
  {
      if (mmStatus == LIC_NO_MORE_UNITS)
        return (MMSYSERR_ALLOCATED);
      else
        if (mmStatus == LIC_NO_PAK)
          return (MMSYSERR_NOTENABLED);
        else
          return (MMSYSERR_ERROR);
  }
#endif
#endif

  /********************************************************************/
  /*  Set default parameters.                                         */
  /********************************************************************/
  /* 
   * Allocate kernel_share_data structure to make unique for each instance MVP
   */
  if((pKsd_t = (PKSD_T) calloc(1,sizeof(KSD_T))) == NULL)
	  return( MMSYSERR_NOMEM );

  /* GL 10/23/1997 initialize the dictionary entry */
  for (i=0; i < MAX_languages; ++i)
  {
	pKsd_t->adic[i] = 0;
	pKsd_t->udic[i] = 0;
	pKsd_t->fdic[i] = 0;
	pKsd_t->adic_entries[i] = 0;
	pKsd_t->udic_entries[i] = 0;
	pKsd_t->fdic_entries[i] = 0;
  }

  pKsd_t->cmd_flush = FALSE;
  pKsd_t->spc_flush = FALSE;
  pKsd_t->halting = FALSE;
  pKsd_t->logflag  = 0;

/* GL 04/21/1997 set defaulted Spanish to Latin */
#ifdef LATIN_AMERICAN
  pKsd_t->modeflag = MODE_CITATION | MODE_LATIN;
#else
  pKsd_t->modeflag = MODE_CITATION;
#endif //LATIN_AMERICAN
  pKsd_t->sayflag = SAY_CLAUSE;
  pKsd_t->pronflag = 0;
  pKsd_t->wbreak = FALSE;
  pKsd_t->text_flush = FALSE;
  pKsd_t->async_change = FALSE;
  pKsd_t->SamplePeriod = 9.07029478458E-5 ;  /* Initialize sample period */
  pKsd_t->spc_pkt_save = NULL_SPC_PACKET;
  pKsd_t->loaded_languages = NULL;           //MVP:05/10/96 Fixed an exception(When DECtalk runs on a machine without audio card)
  /********************************************************************/
  /*  Create the TTS handle.                                          */
  /********************************************************************/

  phTTS = (LPTTS_HANDLE_T )calloc(1,sizeof(TTS_HANDLE_T));

  if ( phTTS == NULL )
  {
	free(pKsd_t);			// tek 23sep96 plug memory leak
	pKsd_t = NULL;
	return( MMSYSERR_NOMEM );
  }
  phTTS->dwDeviceOptions = dwDeviceOptions;
  phTTS->hWnd = (HWND)dwTTSInstanceParameter;  //Backward compatibilty for TextToSpeechStartupEx
  phTTS->uiCurrentMsgNumber = 1;
  phTTS->uiLastTextMsgNumber = 0;
  phTTS->uiFlushMsgNumber = 0;
  phTTS->uiTextThreadExit = FALSE;
  phTTS->dwQueuedSampleCount = 0;
  phTTS->uiQueuedCharacterCount = 0;
  phTTS->dwOutputState = STATE_OUTPUT_NULL;
  phTTS->bEnableErrorMessage = TRUE;
  phTTS->bInReset = FALSE;
  phTTS->bMemoryReset = FALSE;
  /* Initialize new element "pKernelShareData" for MI :MVP */
  phTTS->pKernelShareData = pKsd_t;
  phTTS->uiID_Error_Message = TTS_MSG_STATUS;
  phTTS->uiID_Index_Message = TTS_MSG_INDEX_MARK;
  phTTS->uiID_Buffer_Message = TTS_MSG_BUFFER;
  /********************************************************************/
  /*  Initialize all of the handle objects to NULL.                   */
  /********************************************************************/

  phTTS->pAudioHandle = NULL;
  phTTS->hSyncEvent = NULL;
  phTTS->hNotEmptyingVtmPipeEvent = NULL;
  phTTS->hTextInQueueEvent = NULL;
  phTTS->pcsLogFile = NULL;
  phTTS->pcsQueuedCharacterCount = NULL;
  phTTS->pcsFlushMsgNumber = NULL;
  phTTS->pcsLastQueuedTextMsgNumber = NULL;
  phTTS->pcsQueuedSampleCount = NULL;
  phTTS->pcsTextMsgList = NULL;
  phTTS->pcsMemoryBuffer = NULL;
  phTTS->pcsBufferPipe = NULL;

  phTTS->hThread_TXT = NULL;
  phTTS->hThread_CMD = NULL;
  phTTS->hThread_LTS = NULL;
  phTTS->hThread_PH = NULL;
  phTTS->hThread_VTM = NULL;
  phTTS->hThread_SYNC = NULL;
  /*************************************************************************/
  /*  Initialize all of the Thread specific data structure pointers to NULL*/
  /*  Murthy Parakala : for multiple instances                             */
  /*************************************************************************/
  phTTS->pCMDThreadData = NULL;            /*CMD Thread */
  phTTS->pLTSThreadData = NULL;            /*LTS Thread */ 
  phTTS->pVTMThreadData = NULL;            /*VTM Thread */
  phTTS->pPHThreadData = NULL;             /*PH  Thread */
  phTTS->hMallocSuccessEvent = NULL;   /* Event handle for successful memory allocations*/
  
  /*****************************************************************/
  /*  Initialize Instance specific CallbackFunction,Instance parameter
  /*  MVP : 05/08/96
  /*****************************************************************/
  phTTS->DtCallbackRoutine = DtCallbackRoutine;
  phTTS->dwTTSInstanceParameter = dwTTSInstanceParameter;
  phTTS->pcsCallback = NULL;
  /********************************************************************/
  /*  Create the queued sample count critical section.                */
  /********************************************************************/

  phTTS->pcsQueuedSampleCount = OP_CreateMutex();

  if ( phTTS->pcsQueuedSampleCount == NULL )
  {
	DeleteTextToSpeechObjects( phTTS );
	return( MMSYSERR_NOMEM );
  }

  /********************************************************************/
  /*  Create the 'Buffer Pipe' mutex.                                 */
  /********************************************************************/

  phTTS->pcsBufferPipe = OP_CreateMutex();

  if ( phTTS->pcsBufferPipe == NULL )
  {
	DeleteTextToSpeechObjects( phTTS );
	return( MMSYSERR_NOMEM );
  }

  /********************************************************************/
  /*  Create the 'Text List' mutex.                                   */
  /********************************************************************/

  phTTS->pcsTextMsgList = OP_CreateMutex();

  if ( phTTS->pcsTextMsgList == NULL )
  {
	DeleteTextToSpeechObjects( phTTS );
	return( MMSYSERR_NOMEM );
  }

  /********************************************************************/
  /*  Create the last queued text message number critical section.    */
  /********************************************************************/

  phTTS->pcsLastQueuedTextMsgNumber = OP_CreateMutex();

  if ( phTTS->pcsLastQueuedTextMsgNumber == NULL )
  {
	DeleteTextToSpeechObjects( phTTS );
	return( MMSYSERR_NOMEM );
  }

  /********************************************************************/
  /*  Create the flush message number critical section.               */
  /********************************************************************/

  phTTS->pcsFlushMsgNumber = OP_CreateMutex();

  if ( phTTS->pcsFlushMsgNumber == NULL )
  {
	DeleteTextToSpeechObjects( phTTS );
	return( MMSYSERR_NOMEM );
  }

  /********************************************************************/
  /*  Create the queued character count critical section.             */
  /********************************************************************/

  phTTS->pcsQueuedCharacterCount = OP_CreateMutex();

  if ( phTTS->pcsQueuedCharacterCount == NULL )
  {
	DeleteTextToSpeechObjects( phTTS );
	return( MMSYSERR_NOMEM );
  }

  /********************************************************************/
  /*  Create the log file critical section.                           */
  /********************************************************************/

  phTTS->pcsLogFile = OP_CreateMutex();

  if ( phTTS->pcsLogFile == NULL )
  {
	DeleteTextToSpeechObjects( phTTS );
	return( MMSYSERR_NOMEM );
  }

  /********************************************************************/
  /*  Create a "Sync" event. The initial state is not signaled.       */
  /********************************************************************/

  phTTS->hSyncEvent = OP_CreateEvent( TRUE, FALSE );

  if ( phTTS->hSyncEvent == NULL )
  {
	DeleteTextToSpeechObjects( phTTS );
	return( MMSYSERR_NOMEM );
  }

  /********************************************************************/
  /*  Create a "Text in Queue" event. The initial state is not signaled.*/
  /********************************************************************/

  phTTS->hTextInQueueEvent = OP_CreateEvent( TRUE, FALSE );

  if ( phTTS->hTextInQueueEvent == NULL )
  {
	DeleteTextToSpeechObjects( phTTS );
	return( MMSYSERR_NOMEM );
  }

  /********************************************************************/
  /*  Create a "Not Emptying Vtm Pipe" event. The initial state is    */
  /*  signaled.                                                       */
  /********************************************************************/

  phTTS->hNotEmptyingVtmPipeEvent = OP_CreateEvent( TRUE, TRUE );

  if ( phTTS->hNotEmptyingVtmPipeEvent == NULL )
  {
	DeleteTextToSpeechObjects( phTTS );
	return( MMSYSERR_NOMEM );
  }

  /*******************************************************************/
  /*  Create the TTS callback mutex.                                 */
  /*******************************************************************/

   if ( DtCallbackRoutine != NULL )
   {
	  phTTS->pcsCallback = OP_CreateMutex();

	  if ( phTTS->pcsCallback == NULL )
	  {
		 DeleteTextToSpeechObjects( phTTS );

		 return MMSYSERR_NOMEM;
	  }
   }


  /********************************************************************************/
  /*  MVP :Create a "Successful Memory Allocation " event.                        */
  /*  The event configuration is non-inheritable,AUTO RESET,not signaled, Unnamed */
  /********************************************************************************/

  phTTS->hMallocSuccessEvent = OP_CreateEvent( FALSE, FALSE );

  if ( phTTS->hMallocSuccessEvent == NULL )
  {
	DeleteTextToSpeechObjects( phTTS );
	return( MMSYSERR_NOMEM );
  }

  /********************************************************************/
  /*  Initialize the inter-thread communication pipes.                */
  /********************************************************************/

  cmd_pipe = create_pipe( BYTE_PIPE, CMD_PIPE_LENGTH );

  if ( cmd_pipe == NULL )
  {
	DeleteTextToSpeechObjects( phTTS );
	return( MMSYSERR_NOMEM );
  }

  lts_pipe = create_pipe( WORD_PIPE, LTS_PIPE_LENGTH );

  if ( lts_pipe == NULL )
  {
	DeleteTextToSpeechObjects( phTTS );
	return( MMSYSERR_NOMEM );
  }

  ph_pipe = create_pipe( WORD_PIPE, PH_PIPE_LENGTH );

  if ( ph_pipe == NULL )
  {
	DeleteTextToSpeechObjects( phTTS );
	return( MMSYSERR_NOMEM );
  }

  vtm_pipe = create_pipe( WORD_PIPE, VTM_PIPE_LENGTH );

  if ( vtm_pipe == NULL )
  {
	DeleteTextToSpeechObjects( phTTS );
	return( MMSYSERR_NOMEM );
  }

  sync_pipe = create_pipe( DWORD_PIPE, SYNC_PIPE_LENGTH );

  if ( sync_pipe == NULL )
  {
	DeleteTextToSpeechObjects( phTTS );
	return( MMSYSERR_NOMEM );
  }

  /********************************************************************/
  /*  Set default pipe parameters.                                    */
  /********************************************************************/
  /* Comment out the below line for MI : MVP */
  /*
  kernel_share = &kernel_data;
  */

  for ( i = 0; i < MAX_languages; i++ )
  {
	pKsd_t->lang_lts[i] = NULL_PIPE;
	pKsd_t->lang_ph[i]  = NULL_PIPE;
	pKsd_t->lang_ready[i] = 0;
  }

  /* GL 04/21/1997 add code to support the local language pipe */
  pKsd_t->lang_lts[0] = lts_pipe;
  pKsd_t->lang_ph[0] = ph_pipe;

  pKsd_t->lts_pipe = pKsd_t->lang_lts[0];
  pKsd_t->ph_pipe = pKsd_t->lang_ph[0];

  pKsd_t->cmd_pipe = cmd_pipe;
  pKsd_t->vtm_pipe = vtm_pipe;
  pKsd_t->sync_pipe = sync_pipe;

  /*
     GL 12/11/1996, set up the language flag pKsd_t->lang_curr
     this flag will be used in CMD and phlog.c to pick up the language
     depended code
   */
#ifdef ENGLISH_US
  pKsd_t->lang_lts[LANG_english] = lts_pipe;
  pKsd_t->lang_ph[LANG_english] = ph_pipe;

  pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_english];
  pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_english];
  pKsd_t->lang_curr = LANG_english;
#endif //ENGLISH_US
#ifdef ENGLISH_UK
  pKsd_t->lang_lts[LANG_british] = lts_pipe;
  pKsd_t->lang_ph[LANG_british] = ph_pipe;

  pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_british];
  pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_british];
  pKsd_t->lang_curr = LANG_british;
#endif //ENGLISH_UK
#ifdef SPANISH
  pKsd_t->lang_lts[LANG_spanish] = lts_pipe;
  pKsd_t->lang_ph[LANG_spanish] = ph_pipe;

  pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_spanish];
  pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_spanish];

  pKsd_t->lang_curr = LANG_spanish;
#endif //SPANISH
#ifdef GERMAN
  pKsd_t->lang_lts[LANG_german] = lts_pipe;
  pKsd_t->lang_ph[LANG_german] = ph_pipe;

  pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_german];
  pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_german];
  pKsd_t->lang_curr = LANG_german;
#endif //GERMAN
#ifdef FRENCH
  pKsd_t->lang_lts[LANG_french] = lts_pipe;
  pKsd_t->lang_ph[LANG_french] = ph_pipe;

  pKsd_t->lts_pipe = pKsd_t->lang_lts[LANG_french];
  pKsd_t->ph_pipe = pKsd_t->lang_ph[LANG_french];
  pKsd_t->lang_curr = LANG_french;
#endif //FRENCH

  /********************************************************************/
  /*  Initialize the audio driver.                                    */
  /********************************************************************/

  if (( dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )
  {
	/********************************************************************/
	/*  Allocate memory for the local WAVEFORMATEX structure.           */
	/********************************************************************/
#ifndef OLEDECTALK
	pWaveFormat = (LPWAVEFORMATEX)malloc(sizeof(WAVEFORMATEX));

	if ( pWaveFormat == NULL )
	{
	  DeleteTextToSpeechObjects( phTTS );
	  return( MMSYSERR_NOMEM );
	}

	/********************************************************************/
	/*  Fill in all the required fields of the WAVEFORMATEX structure.  */
	/********************************************************************/

	pWaveFormat->wFormatTag = WAVE_FORMAT_PCM;
	pWaveFormat->nSamplesPerSec = PC_SAMPLE_RATE;
	pWaveFormat->nChannels = 1;
	pWaveFormat->wBitsPerSample = 16;

	/********************************************************************/
	/*  Open the audio device.                                          */
	/********************************************************************/
	mmStatus = PA_CreatePlayHandle( &pPlayAudio,
									uiDeviceNumber,
									pWaveFormat,
									dwDeviceOptions,
									PlayAudioCallbackRoutine,
									(ATYPE_T)phTTS);
	free( pWaveFormat );
#else
	/*******************************************************/
	/* Initialize the DECtalk audio system for OLE-DECTALK */
	/*******************************************************/
	mmStatus = InitializeDECtalkAudio((HWND)dwTTSInstanceParameter,&pPlayAudio);
#endif    

	if ( mmStatus )
	{
	DeleteTextToSpeechObjects( phTTS );

	if ( mmStatus == MMSYSERR_ERROR )
			return( MMSYSERR_NODRIVER );
	else
			return( mmStatus );
	}

	phTTS->pAudioHandle = pPlayAudio;
	phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
  }

  /********************************************************************/
  /*  Start the Synchronization thread.                               */
  /********************************************************************/
  if((StartDecTalkSystemThread(phTTS, &(phTTS->hThread_SYNC),
		FALSE, sync_main))== MMSYSERR_NOMEM)
	return(MMSYSERR_NOMEM);  


  /********************************************************************/
  /*  Start the Vocal Tract Model thread.                             */
  /********************************************************************/
  if((StartDecTalkSystemThread(phTTS, &(phTTS->hThread_VTM),
		TRUE, vtm_main))== MMSYSERR_NOMEM)
	return(MMSYSERR_NOMEM);  

  /********************************************************************/
  /*  Start the Phonetic processing thread.                           */
  /********************************************************************/
  if((StartDecTalkSystemThread(phTTS, &(phTTS->hThread_PH),
		TRUE, ph_main))== MMSYSERR_NOMEM)
	return(MMSYSERR_NOMEM);  

  /********************************************************************/
  /*  Start the Letter To Sound thread.                               */
  /********************************************************************/
  nReturnCode = StartDecTalkSystemThread(phTTS, &(phTTS->hThread_LTS),
				TRUE, lts_main);
  if(nReturnCode == MMSYSERR_NOMEM ||
	 nReturnCode == MMSYSERR_INVALPARAM ||
	 nReturnCode == MMSYSERR_ERROR )
	return(nReturnCode);

  /********************************************************************/
  /*  Start the Command thread.                                       */
  /********************************************************************/
  if((StartDecTalkSystemThread(phTTS, &(phTTS->hThread_CMD),
		TRUE, cmd_main))== MMSYSERR_NOMEM)
	return(MMSYSERR_NOMEM);  
  
  /********************************************************************/
  /*  Start the Text Queueing thread.                                 */
  /********************************************************************/
  phTTS->hTextToSpeechWnd = NULL;

  nReturnCode = StartDecTalkSystemThread(phTTS, &(phTTS->hThread_TXT),
				TRUE, TextToSpeechThreadMain);
  if(nReturnCode == MMSYSERR_NOMEM ||
	 nReturnCode == MMSYSERR_ERROR)
	return(nReturnCode);  

#ifdef OLD
  phTTS->hThread_TXT = CreateThread( NULL,
					 0,
			 (LPTHREAD_START_ROUTINE)TextToSpeechThreadMain,
					 (LPVOID)phTTS,
					 0,
					 &ID_Thread_TXT );

  /********************************************************************/
  /*  Wait here until the LTS thread loads the dictionary.            */
  /********************************************************************/
  /* GL 11/05/1997  for BATS#510 */
  for ( i = 0; pKsd_t->fdic_entries[pKsd_t->lang_curr] == 0; i++ )
  {
	OP_Sleep( STARTUP_LOOP_WAIT_TIME );

	if ( i > MAX_STARTUP_WAIT_COUNT )
	{                                                            
	  DeleteTextToSpeechObjects( phTTS );                        
	  return( MMSYSERR_ERROR );
	}
  }

  /********************************************************************/
  /*  If the dictionary length was set to 0xFFFFFFFF then the         */
  /*  dictionary file was not found. Return an error.                 */
  /********************************************************************/
  /* GL 11/05/1997  for BATS#510 */
  if ( pKsd_t->fdic_entries[pKsd_t->lang_curr] == 0xFFFFFFFF )
	return( MMSYSERR_ERROR );

  /********************************************************************/
  /*  Wait here until the Text-To-Speech main thread initializes the  */
  /*  Text-To-Speech window handle.                                   */
  /********************************************************************/

  for ( i = 0; phTTS->hTextToSpeechWnd == NULL; i++ )
  {
	OP_Sleep( STARTUP_LOOP_WAIT_TIME );

	if ( i > MAX_STARTUP_WAIT_COUNT )
	{
	  DeleteTextToSpeechObjects( phTTS );
	  return( MMSYSERR_NOMEM );
	}
  }

  if ( phTTS->hThread_TXT == NULL )
  {
	DeleteTextToSpeechObjects( phTTS );
	return( MMSYSERR_NOMEM );
  }

#endif


  /********************************************************************/
  /*  MVP:06/19/96 Initialize the TextToSpeech handle the function        */
  /*  returns through pphTTS argument.                                */
  /********************************************************************/

  *pphTTS = phTTS;
  
  /******************************************************************/
  /*  Put the system into a known state.                            */
  /******************************************************************/

  TextToSpeechReset( phTTS, TRUE );

  //MVP: Increment InstanceCounter on successful creation of a speech object.
  gnInstanceCounter++;
#ifdef DECTALKBETA430        //MVP:04/09/96 A message will be spoken for Beta releases.
  TextToSpeechSpeak(phTTS, "DECtalk beta S D K version 4.30t is running. For evaluation only. ", TTS_NORMAL);
#endif

  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechStartup                                     */
/*  Author: Bill Hallahan                                             */
/*  Date: April 13, 1993                                              */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*    DECtalk initialization function.                                */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*                                                                    */
/*    pphTTS              A pointer to a pointer to a structure of    */
/*                        type TTS_HANDLE_T. This function allocates  */
/*                        memory for the structure.                   */
/*                                                                    */
/*    uiDeviceNumber      An unsigned integer which is the wave out   */
/*                        device ID number. WAVE_MAPPER may be used   */
/*                        here if the device ID number is unknown.    */
/*                                                                    */
/*    dwDeviceOptions     A DWORD which specifies how the wave output */
/*                        device is managed. It may be a combination  */
/*                        of the following values:                    */
/*                                                                    */
/*       value                 performance characteristic             */
/*                                                                    */
/*  OWN_AUDIO_DEVICE      The wave output device will be opened upon  */
/*                        return from this function. No other process */
/*                        may allocate the wave output device until   */
/*                        the CloseAudio() function is called. If     */
/*                        there are no wave output devices in the     */
/*                        system then MMSYSERR_NOTSUPPORTED will be   */
/*                        returned and the Text-To-Speech system will */
/*                        not be started.                             */
/*                                                                    */
/*                        If OWN_AUDIO_DEVICE is NOT specified then   */
/*                        the wave output device will be opened       */
/*                        sometime after audio is queued by the       */
/*                        TextToSpeechSpeak() function. The wave      */
/*                        output device will be held as long as       */
/*                        sufficient audio samples are queued.        */
/*                        Otherwise the device will be released.      */
/*                                                                    */
/*  REPORT_OPEN_ERROR     If an attempt is made to open the wave      */
/*                        output device while another process owns    */
/*                        it, then an error message will be sent to   */
/*                        the window procedure which corresponds to   */
/*                        the window handle which is passed to this   */
/*                        function.                                   */
/*                                                                    */
/*  DO_NOT_USE_AUDIO_DEVICE  The Text-To-Speech system may only be    */
/*                           used to write wave files, write speech   */
/*                           samples to memory, or log phonemes. No   */
/*                           error will be returned if a wave output  */
/*                           device is not present.                   */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a status code of type MMRESULT.           */
/*    This value is zero if initialization was successful.            */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_NODRIVER      No wave out device driver present        */
/*    MMSYSERR_BADDEVICEID   Device ID out of range                   */
/*    MMSYSERR_NOMEM         Unable to allocate memory                */
/*    MMSYSERR_ERROR         Dictionary not found                     */
/*    MMSYSERR_INVALPARAM    Invalid param for th eload dictionary    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

#ifndef WIN32

MMRESULT TextToSpeechStartup( LPTTS_HANDLE_T * pphTTS,
			     UINT uiDeviceNumber,
			     DWORD dwDeviceOptions,
			     VOID (*DtCallbackRoutine)(LONG,LONG,DWORD,UINT),
			     LONG dwTTSInstanceParameter)
{
  

  return(TextToSpeechStartupEx(pphTTS,
			       uiDeviceNumber,
			       dwDeviceOptions,
			       DtCallbackRoutine,	
			       dwTTSInstanceParameter));
}
#else
  
MMRESULT TextToSpeechStartup( HWND hWnd,
							  LPTTS_HANDLE_T * pphTTS,
							  UINT uiDeviceNumber,
							  DWORD dwDeviceOptions )
{
	
	return(TextToSpeechStartupEx(pphTTS,
								 uiDeviceNumber,
								 dwDeviceOptions,
								 DefaultTTSCallbackRoutine,
								 (LONG)hWnd));
	/********************************************************************/
	/*  Get the DECtalk error message.                                  */
	/********************************************************************/
	
	phTTS->uiID_Error_Message =
	  RegisterWindowMessage("DECtalkErrorMessage");
	
	if ( phTTS->uiID_Error_Message == 0 )
	{
	    DeleteTextToSpeechObjects( phTTS );
	    return( MMSYSERR_NOMEM );
	}
	
	/********************************************************************/
	/*  Get the DECtalk index mark message.                             */
	/********************************************************************/
	
	phTTS->uiID_Index_Message =
	  RegisterWindowMessage("DECtalkIndexMessage");
	
	if ( phTTS->uiID_Index_Message == 0 )
	{
	    DeleteTextToSpeechObjects( phTTS );
	    return( MMSYSERR_NOMEM );
	}
	
	/********************************************************************/
	/*  Get the DECtalk buffer message.                                 */
	/********************************************************************/
	
	phTTS->uiID_Buffer_Message =
	  RegisterWindowMessage("DECtalkBufferMessage");
	
	if ( phTTS->uiID_Buffer_Message == 0 )
	{
	    DeleteTextToSpeechObjects( phTTS );
	    return( MMSYSERR_NOMEM );
	}
}


VOID DefaultTTSCallbackRoutine(LONG lParam1,
							   LONG lParam2,
							   DWORD dwInstanceParam,
							   UINT uiMsg)
{
	switch( lParam1 )
	{
	case TTS_AUDIO_PLAY_START:
	case TTS_AUDIO_PLAY_STOP:
	case ERROR_OPENING_WAVE_OUTPUT_DEVICE:
	case ERROR_IN_AUDIO_WRITE:
	case ERROR_GETTING_DEVICE_CAPABILITIES:
	
	  PostMessage((HWND)dwInstanceParam,uiMsg,lParam1,lParam2);
	  break;

	default:
	  // tek 19aug96 must this be a post?
	  PostMessage((HWND)dwInstanceParam,uiMsg,lParam1,lParam2);
	  break;
	}
}

#endif

/**********************************************************************/
/*      Function : StartDecTalkSystemThread                           */
/*      Author   : Murthy Parakala                                    */
/*      Date     : October 19, 1995                                   */
/*                                                                    */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*    Generic startup routine to initiate DecTalk system threads.     */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS               A pointer to a Text-To-Speech handle.       */
/*    ppDecTalkThread     A pointer to DectalkThread handle           */
/*    bMalloc             A flag to indicate whether dynamic memory   */
/*                        allocations are present in thread function  */
/*                        or not. TRUE - present; FALSE -no           */
/*    ThreadFunction      Thread start function                       */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_NOMEM         Insufficient memory .                    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/
 
static int StartDecTalkSystemThread(LPTTS_HANDLE_T phTTS, HTHREAD_T *ppDecTalkThread,
									BOOL bMalloc, OP_THREAD_ROUTINE(ThreadFunction, LPTTS_HANDLE_T phTTS))
{
	UINT IDThread;
	DWORD cNumObjects =2;
#ifdef 0
	HANDLE WaitObjArray[2];
	ULONG exit_code ;
#endif
	/*typedef int ( * _stdcall Stdstart_address ) (void *);*/
	
	*ppDecTalkThread = OP_CreateThread(0,
					   (void *)ThreadFunction,             
					   (void *)phTTS);
#ifdef 0
	*ppDecTalkThread = (HANDLE) _beginthreadex(NULL,
								0,
								ThreadFunction,             
								(void *)phTTS,                                   
								0,
								&IDThread
								);
#endif

	if ( *ppDecTalkThread == NULL )
	{
		DeleteTextToSpeechObjects( phTTS );
		return( MMSYSERR_NOMEM );
	}

	if(bMalloc == FALSE)          /* No dynamic memory allocations within thread main function */
		return MMSYSERR_NOERROR;  /*No errors */

#ifdef 0
	WaitObjArray[0] = *ppDecTalkThread;
	WaitObjArray[1] = phTTS->hMallocSuccessEvent;

	WaitForMultipleObjects(cNumObjects,WaitObjArray,FALSE,OP_INFINITE); 
	
	GetExitCodeThread(*ppDecTalkThread,&exit_code);
#endif
	OP_WaitForEvent( phTTS->hMallocSuccessEvent, OP_INFINITE );
	
#ifdef 0
	if(exit_code == MMSYSERR_NOMEM ||
	   exit_code == MMSYSERR_INVALPARAM ||
	   exit_code == MMSYSERR_ERROR )
	{
		DeleteTextToSpeechObjects( phTTS );
		return(exit_code);
	}
	
	return MMSYSERR_NOERROR;    /*No errors */

#endif
	if (phTTS->uiThreadError != MMSYSERR_NOERROR)
	  DeleteTextToSpeechObjects( phTTS );
	
	return (phTTS->uiThreadError);
}


/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechShutdown                                    */
/*  Author: Bill Hallahan                                             */
/*  Date: April 13, 1993                                              */
/*                                                                    */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*    Text To Speech Shutdown.                                        */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS    A pointer to a Text-To-Speech handle.                  */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

#define  TIMEOUT_INTERVAL_IN_MSEC  1000

MMRESULT TextToSpeechShutdown( LPTTS_HANDLE_T phTTS )
{
  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );

  /********************************************************************/
  /*  If the last item in the TextToSpeechStartup() function was      */
  /*  initialized then reset the the Text-To-Speech system.           */
  /********************************************************************/

  /* The if statement is not reqd as phTTSglobal is going to be oboselete for MI :MVP */
  /*if ( phTTSglobal != NULL )*/
	if(phTTS != NULL)
	TextToSpeechReset( phTTS, TRUE );

  /********************************************************************/
  /*  Delete any objects created by the TextToSpeechInMemory().       */
  /*  function.                                                       */
  /********************************************************************/

  if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )
	TextToSpeechCloseInMemory( phTTS );

  /********************************************************************/
  /*  Delete all objects created in the TextToSpeechStartup()         */
  /*  function.                                                       */
  /********************************************************************/

  DeleteTextToSpeechObjects( phTTS );

  gnInstanceCounter--;     /* MVP: Decrement the instance counter */

  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: DeleteTextToSpeechObjects                               */
/*  Author: Bill Hallahan                                             */
/*  Date: April 13, 1993                                              */
/*                                                                    */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*    Delete all objects created in the TextToSpeechStartup()         */
/*    function.                                                       */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS    A pointer to a Text-To-Speech handle.                  */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

static void DeleteTextToSpeechObjects( LPTTS_HANDLE_T phTTS )
{
  /* Added the following 2 varaibles for MI :MVP */
  PKSD_T pKsd_t = phTTS->pKernelShareData;
  PVOID pCmd_t = phTTS->pCMDThreadData;
  DWORD dwDump[3] = { 0x0b, 0x0b, 0x0b };  /*MVP not a static variable,is a const*/
  WORD wDump[3] = { 0x0b, 0x0b, 0x0b };    /*MVP not a static variable,is a const*/
  char cDump[3] = { 0x0b, 0x0b, 0x0b };    /*MVP not a static variable,is a const*/
  THREAD_STATUS_T ThreadStatus;

  /********************************************************************/
  /*  Terminate all threads.                                          */
  /********************************************************************/

  if ( pKsd_t->sync_pipe != NULL )
  {
	/******************************************************************/
	/*  Shut down the SYNC thread.                                    */
	/******************************************************************/

	if ( phTTS->hThread_SYNC != NULL )
	{
	  exit_pipe( pKsd_t->sync_pipe );
	  write_pipe( pKsd_t->sync_pipe, dwDump, 3 );

	  OP_WaitForThreadTermination( phTTS->hThread_SYNC,
				      &ThreadStatus,
				      TIMEOUT_INTERVAL_IN_MSEC );
	}

	/******************************************************************/
	/*  Shut down the VTM thread.                                     */
	/******************************************************************/

	if ( phTTS->hThread_VTM != NULL )
	{
	  exit_pipe( pKsd_t->vtm_pipe );
	  write_pipe( pKsd_t->vtm_pipe, wDump, 3 );
	  
	  /*MVP Free the allocated memory in LTS thread activity */
	  if(phTTS->pVTMThreadData)
          {
			free(phTTS->pVTMThreadData);
			phTTS->pVTMThreadData = NULL;
	  }


	  OP_WaitForThreadTermination( phTTS->hThread_VTM,
				      &ThreadStatus,
				      TIMEOUT_INTERVAL_IN_MSEC );
	}

	/******************************************************************/
	/*  Shut down the PH thread.                                      */
	/******************************************************************/

	if ( phTTS->hThread_PH != NULL )
	{
	  exit_pipe( pKsd_t->ph_pipe );
	  write_pipe( pKsd_t->ph_pipe, wDump, 3 );
	  /*MVP Free the allocated memory in PH thread activity */
	  if(phTTS->pPHThreadData)
			FreePHInstanceData(phTTS->pPHThreadData); /*04aug96 */
	  phTTS->pPHThreadData = NULL;

	  OP_WaitForThreadTermination( phTTS->hThread_PH,
				      &ThreadStatus,
				      TIMEOUT_INTERVAL_IN_MSEC );
	}

	/******************************************************************/
	/*  Shut down the LTS thread.                                     */
	/******************************************************************/

	if ( phTTS->hThread_LTS != NULL )
	{
	  exit_pipe( pKsd_t->lts_pipe );
	  write_pipe( pKsd_t->lts_pipe, wDump, 3 );
	  /*MVP Free the allocated memory in LTS thread activity */
	  if(phTTS->pLTSThreadData)
			free(phTTS->pLTSThreadData);
	  phTTS->pLTSThreadData = NULL;
	  
	  OP_WaitForThreadTermination( phTTS->hThread_LTS,
				      &ThreadStatus,
				      TIMEOUT_INTERVAL_IN_MSEC );
	}

	/******************************************************************/
	/*  Shut down the CMD thread.                                     */
	/******************************************************************/

	if ( phTTS->hThread_CMD != NULL )
	{
	exit_pipe( pKsd_t->cmd_pipe );
	write_pipe( pKsd_t->cmd_pipe, cDump, 3 );
	/*MVP Free the allocated memory in CMD thread activity */
	if(pCmd_t)
		FreeCMDThreadMemory(pCmd_t);
	phTTS->pCMDThreadData = pCmd_t = NULL;

	OP_SetEvent( phTTS->hSyncEvent );

	OP_WaitForThreadTermination( phTTS->hThread_CMD,
				    &ThreadStatus,
				    TIMEOUT_INTERVAL_IN_MSEC );
	}
  }

  /********************************************************************/
  /*  Shutdown the Audio thread                                       */
  /********************************************************************/

  if ( phTTS->pAudioHandle != NULL )
	PA_DestroyPlayHandle( phTTS->pAudioHandle );

  /********************************************************************/
  /*  Terminate the Text-To-Speech thread.                            */
  /********************************************************************/

  if ( phTTS->hThread_TXT != NULL )
  {
#ifdef 0
	SendMessage( phTTS->hTextToSpeechWnd,
		 ID_TTS_Destroy,
		 0L,
		 0L );

	OP_WaitForThreadTermination( phTTS->hThread_TXT,
				    &ThreadStatus,
				    TIMEOUT_INTERVAL_IN_MSEC );
#endif
	phTTS->uiTextThreadExit = TRUE;
	OP_SetEvent(phTTS->hTextInQueueEvent);
	OP_WaitForThreadTermination(phTTS->hThread_TXT, 
				    &ThreadStatus, 
				    OP_INFINITE);
	phTTS->hThread_TXT = NULL;
	
  }

  /********************************************************************/
  /*  Free the handle to the "Not Emptying Vtm Pipe" event.           */
  /********************************************************************/

  if ( phTTS->hNotEmptyingVtmPipeEvent != NULL )
  {
	OP_DestroyEvent( phTTS->hNotEmptyingVtmPipeEvent );
  }

  /********************************************************************/
  /*  Free the handle to the "Sync" event.                            */
  /********************************************************************/

  if ( phTTS->hSyncEvent != NULL )
  {
	OP_DestroyEvent( phTTS->hSyncEvent );
  }

  /********************************************************************/
  /*  Free the handle to the "TextInQueue" event.                     */
  /********************************************************************/

  if ( phTTS->hTextInQueueEvent != NULL )
  {
	OP_DestroyEvent( phTTS->hTextInQueueEvent );
	phTTS->hTextInQueueEvent = NULL;
  }

  /********************************************************************/
  /*  Free the handle to the "Successful Memory alloacation" event.   */
  /********************************************************************/

  if (phTTS->hMallocSuccessEvent != NULL)
  {
	OP_DestroyEvent(phTTS->hMallocSuccessEvent);
	phTTS->hMallocSuccessEvent = NULL;
  }

  /********************************************************************/
  /*  Free the handle to the "TTS Callback Mutex .                    */
  /********************************************************************/

  if (phTTS->pcsCallback != NULL)
  {
	OP_DestroyMutex(phTTS->pcsCallback);
	phTTS->pcsCallback = NULL;
  }

  /********************************************************************/
  /*  Delete the log file critical section.                           */
  /********************************************************************/

  if ( phTTS->pcsLogFile != NULL )
  {
	OP_DestroyMutex( phTTS->pcsLogFile );
  }

  /********************************************************************/
  /*  Delete the queued character count critical section.             */
  /********************************************************************/

  if ( phTTS->pcsQueuedCharacterCount != NULL )
  {
	OP_DestroyMutex( phTTS->pcsQueuedCharacterCount );
  }

  /********************************************************************/
  /*  Delete the flush message number critical section.               */
  /********************************************************************/

  if ( phTTS->pcsFlushMsgNumber != NULL )
  {
	OP_DestroyMutex( phTTS->pcsFlushMsgNumber );
  }

  /********************************************************************/
  /*  Delete the Buffer Pipe mutex.                                   */
  /********************************************************************/

  if ( phTTS->pcsBufferPipe != NULL )
  {
	OP_DestroyMutex( phTTS->pcsBufferPipe );
  }

  /********************************************************************/
  /*  Delete the Text Msg mutex.                                      */
  /********************************************************************/

  if ( phTTS->pcsTextMsgList != NULL )
  {
	OP_DestroyMutex( phTTS->pcsTextMsgList );
  }

  /********************************************************************/
  /*  Delete the last queued text message number critical section.    */
  /********************************************************************/

  if ( phTTS->pcsLastQueuedTextMsgNumber != NULL )
  {
	OP_DestroyMutex( phTTS->pcsLastQueuedTextMsgNumber );
  }

  /********************************************************************/
  /*  Delete the queued sample count critical section.                */
  /********************************************************************/

  if ( phTTS->pcsQueuedSampleCount != NULL )
  {
	OP_DestroyMutex( phTTS->pcsQueuedSampleCount );
  }

  /********************************************************************/
  /*  Free the dictionary memory.                                     */
  /********************************************************************/
  /*MVP : Unload dictionary when no other instance of DECtalk speech  */
  /*      object is running                                           */
  
  if(!gnInstanceCounter)        
  {
		/* GL 11/05/1997  for BATS#510 */
		if ( pKsd_t->fdic_entries[pKsd_t->lang_curr] != 0 )
		{
			unload_dictionary((void **)&(pKsd_t->fdic[pKsd_t->lang_curr]),
			(unsigned int *)&(pKsd_t->fdic_entries[pKsd_t->lang_curr]));
			gpufdic = NULL;
			gufdic_entries = 0;
		}
  }

  /********************************************************************/
  /*  Free the user dictionary memory.                                */
  /********************************************************************/
  /* GL 11/05/1997  for BATS#510 */
  if ( pKsd_t->udic_entries[pKsd_t->lang_curr] != 0 )
  {
	unload_dictionary((void **)&pKsd_t->udic[pKsd_t->lang_curr],
			  (unsigned int *)&pKsd_t->udic_entries[pKsd_t->lang_curr] );
  }

  /********************************************************************/
  /*  Destroy all the pipes.                                          */
  /********************************************************************/
  /* tek 30aug96 be kind; NULL the pointers when done.. */
  if ( pKsd_t->sync_pipe != NULL )
  {
	destroy_pipe( pKsd_t->sync_pipe );
	pKsd_t->sync_pipe = NULL;
  }

  if ( pKsd_t->vtm_pipe != NULL )
  {
	destroy_pipe( pKsd_t->vtm_pipe );
	pKsd_t->vtm_pipe = NULL;
  }

  if ( pKsd_t->ph_pipe != NULL )
  {
	destroy_pipe( pKsd_t->ph_pipe );
	pKsd_t->ph_pipe = NULL;
  }

  if ( pKsd_t->lts_pipe != NULL )
  {
	destroy_pipe( pKsd_t->lts_pipe );
	pKsd_t->lts_pipe = NULL;
  }

  if ( pKsd_t->cmd_pipe != NULL )
  {
	destroy_pipe( pKsd_t->cmd_pipe );
	pKsd_t->cmd_pipe = NULL;
  }
  
  /********************************************************************/
  /* Free the "loaded_languages" element of Kernel_share_data structure*/
  /* This element have been allocated in Kernel sub-system in usa_init*/
  /* function. MVP MI                                                 */
  /********************************************************************/
  if(pKsd_t->loaded_languages != NULL)  
  {
	free(pKsd_t->loaded_languages);
	pKsd_t->loaded_languages = NULL;
  }

  /********************************************************************/
  /* Free the kernel_share_data element in TTS structure for MI :MVP  */
  /********************************************************************/
  if(phTTS->pKernelShareData != NULL)
  {
		free(phTTS->pKernelShareData);
		phTTS->pKernelShareData = NULL;
  }
			  
  /********************************************************************/
  /*  Free the TTS handle structure.                                  */
  /********************************************************************/

  free( phTTS );
  phTTS=NULL;

  return;
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechSpeak                                       */
/*  Author: Bill Hallahan                                             */
/*  Date: July 8, 1993                                                */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This function queues a null terminated string to the       */
/*    Text-To-Speech system.                                          */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS         A pointer to a Text-To-Speech handle.             */
/*                                                                    */
/*    szTextString  A pointer to a null terminated string.            */
/*                                                                    */
/*    dwFlags       A DWORD which specifies if the text is to be      */
/*                  pushed through the Text-To-Speech system even if  */
/*                  if it is not on a clause boundary. It may be set  */
/*                  to one of the follwing constants:                 */
/*                                                                    */
/*                                                                    */
/*                  TTS_NORMAL (equals 0L)  Insert characters in the  */
/*                                          text queue.               */
/*                                                                    */
/*                  TTS_FORCE  (equals 1)   Insert characters in the  */
/*                                          text queue and append the */
/*                                          character token to force  */
/*                                          all previously queued     */
/*                                          text to be output.        */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_NOMEM         Unable to allocate memory.               */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT TextToSpeechSpeak( LPTTS_HANDLE_T phTTS,
				LPSTR pszTextString,
				DWORD dwFlags )
{
  char proc_name[]="TextToSpeechSpeak";
  int uiTextLength = 0;
  unsigned char * pText;
  LPTEXT_MSG_T pTextMsg;
  LPTEXT_MSG_T pNextTextMsg;
  static char cForce = (char)((PFASCII<<PSFONT)+0xb);
  const char cForce2 = (char)(SYNC);

#ifdef TTSDBG
  printf("%s\n",proc_name);
#endif

  /********************************************************************/
  /*  Return error if NULL handle.                                    */
  /********************************************************************/
  if (phTTS == NULL)
     return( MMSYSERR_INVALHANDLE );

  /********************************************************************/
  /*  Allocate the memory locked Text Message structure.              */
  /********************************************************************/

  pTextMsg = (TEXT_MSG_T *)malloc(sizeof(TEXT_MSG_T));

  if ( pTextMsg == NULL )
    return( MMSYSERR_NOMEM );

  pTextMsg->pLink = NULL;

  /********************************************************************/
  /*  Adjust string length for force character.                       */
  /********************************************************************/

  uiTextLength = strlen(pszTextString);

  if( dwFlags & TTS_FORCE )
  {
    uiTextLength++;
  }

  /********************************************************************/
  /*  If the text length is zero then exit with success.              */
  /********************************************************************/

  if ( uiTextLength == 0 )
  {
    free( pTextMsg );
    return MMSYSERR_NOERROR;
  }
  
  /********************************************************************/
  /*  Allocate the memory locked pipe text buffer. Allocate 1 extra   */
  /*  location in case the force character is appended to the text    */
  /*  string.                                                         */
  /********************************************************************/

  pText = malloc(( uiTextLength + 1 ) * sizeof( char ) );

  if ( pText == NULL )
  { 
    free( pTextMsg );
    return( MMSYSERR_NOMEM );
  } 

  /********************************************************************/
  /*  The memory pointed to by pTextMsg and text is                   */
  /*  deallocated in the Text-To-Speech text thread and it            */
  /*  should not be used after the call to the function.              */
  /********************************************************************/

  strcpy( pText, pszTextString );

  /********************************************************************/
  /*  Conditionally append the force character to the text.           */
  /********************************************************************/

  if( dwFlags & TTS_FORCE )
  {
    pText[uiTextLength-1] = cForce;
  }

  pTextMsg->pText = pText;
  pTextMsg->uiLength = uiTextLength;

  /********************************************************************/
  /*  Increment the queued character count.                           */
  /********************************************************************/

  OP_LockMutex( phTTS->pcsQueuedCharacterCount );
  phTTS->uiQueuedCharacterCount += uiTextLength;
  OP_UnlockMutex( phTTS->pcsQueuedCharacterCount );

  /********************************************************************/
  /*  Add the text message to the text-message linked list.           */
  /********************************************************************/

  OP_LockMutex( phTTS->pcsTextMsgList );

  /********************************************************************/
  /*  Put the Text Message at the end of the linked list.             */
  /********************************************************************/

  if ( phTTS->pTextMsgList == NULL )
  {
    phTTS->pTextMsgList = pTextMsg;
  }
  else
  {
    pNextTextMsg = phTTS->pTextMsgList;

    while ( pNextTextMsg->pLink != NULL )
    {
      pNextTextMsg = pNextTextMsg->pLink;
    }

    pNextTextMsg->pLink = pTextMsg;
  }

  /********************************************************************/
  /*  Set the Text In Queue event.                                    */
  /********************************************************************/

  OP_SetEvent( phTTS->hTextInQueueEvent );

  /********************************************************************/
  /*  Unlock the text-message linked list.                            */
  /********************************************************************/

  OP_UnlockMutex( phTTS->pcsTextMsgList );

  return( MMSYSERR_NOERROR );
}

#ifdef 0
  UINT i;
  UINT uiLength;
  unsigned char * pTextBuffer;
  TEXT_MSG_T * pTextMsg;
  const char cForce = (char)((PFASCII<<PSFONT)+0xb);

  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );

  /********************************************************************/
  /*  Allocate the Text Message structure.                            */
  /********************************************************************/

  pTextMsg = (TEXT_MSG_T *)malloc(sizeof(TEXT_MSG_T));

  if ( pTextMsg == NULL )
	return( MMSYSERR_NOMEM );

  /********************************************************************/
  /*  Get the character string length.                                */
  /********************************************************************/

  uiLength = strlen( pszTextString );

  /********************************************************************/
  /*  Allocate the pipe text buffer. Allocate 1 extra location in     */
  /*  case the force character is appended to the text string.        */
  /* now allocate 2 extra for the two forcing chars.. tex 16aug96     */
  /********************************************************************/

  pTextBuffer = (unsigned char *)malloc(( uiLength + 2 ) * sizeof(char));

  if ( pTextBuffer == NULL )
  {
	free( pTextMsg );
	return( MMSYSERR_NOMEM );
  }

  /********************************************************************/
  /*  The memory pointed to by pTextMsg and pTextBuffer is            */
  /*  deallocated in the Text To Speech thread window procedure and   */
  /*  should not be used after the call to the SendMessage()          */
  /*  function.                                                       */
  /********************************************************************/

  for ( i = 0; i < uiLength; i++ )
	pTextBuffer[i] = pszTextString[i];

  /********************************************************************/
  /*  Conditionally append the force character to the text.           */
  /********************************************************************/

  if ( dwFlags & TTS_FORCE )
  {
	pTextBuffer[uiLength] = cForce;
	uiLength++;
	pTextBuffer[uiLength] = cForce2;
	uiLength++;
  }

  /********************************************************************/
  /*  Set up the Text Message structure.                              */
  /*  The message number is used in the Text-To-Speech thread to      */
  /*  to throw away window messages which are received after          */
  /*  TextToSpeechReset() is called.                                  */
  /********************************************************************/

  pTextMsg->pText = pTextBuffer;
  pTextMsg->uiLength = uiLength;
  pTextMsg->uiMsgNumber = phTTS->uiCurrentMsgNumber;
  phTTS->uiCurrentMsgNumber++;

  /********************************************************************/
  /*  Save this message number in the Text-To-Speech handle for       */
  /*  the TextToSpeechSync() function.                                */
  /********************************************************************/

  phTTS->uiLastTextMsgNumber = pTextMsg->uiMsgNumber;

  /********************************************************************/
  /*  Accumulate the queued character count.                          */
  /********************************************************************/

  OP_LockMutex( phTTS->pcsQueuedCharacterCount );
  phTTS->uiQueuedCharacterCount += uiLength;
  OP_UnlockMutex( phTTS->pcsQueuedCharacterCount );

  /********************************************************************/
  /*  Send the structure pointed to by pTextMsg to the text thread.   */
  /********************************************************************/

  PostMessage( phTTS->hTextToSpeechWnd,
		   ID_TTS_Queue_Text,
		   0L,
		   (LPARAM)pTextMsg );

  /********************************************************************/
  /*  Re-enable error messages in the audio thread. The audio thread  */
  /*  disables the audio error handler after sending a message. This  */
  /*  is done to ensure that the application only receives at most    */
  /*  only one error message per call to the TextToSpeechSpeak()      */
  /*  function. Otherwise a message would be sent each time the audio */
  /*  thread was unable to open the audio device.                     */
  /********************************************************************/

  if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )
  {
#ifndef OLEDECTALK
//  EnableAudioErrorMessage( phTTS->pAudioHandle );
#endif
  }

  return( MMSYSERR_NOERROR );
}
#endif

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechPause                                       */
/*  Author: Bill Hallahan                                             */
/*  Date: July 8, 1993                                                */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*    Pause Text-To-Speech                                            */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS    A pointer to a Text-To-Speech handle.                  */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_INVALHANDLE   The specified device handle is invalid   */
/*                           (The system is NOT speaking), or         */
/*                           the Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT TextToSpeechPause( LPTTS_HANDLE_T phTTS )
{
  MMRESULT mmStatus;

  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
  {
	mmStatus = MMSYSERR_INVALHANDLE;
  }
  else
  {
#ifndef OLEDECTALK
	mmStatus = PA_Pause( phTTS->pAudioHandle );
#endif
  }
  return( mmStatus );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechResume                                      */
/*  Author: Bill Hallahan                                             */
/*  Date: July 8, 1993                                                */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*    Resume Text-To-Speech                                           */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS    A pointer to a Text-To-Speech handle.                  */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_INVALHANDLE   The specified device handle is invalid   */
/*                           (The system is NOT speaking), or         */
/*                           the Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT TextToSpeechResume( LPTTS_HANDLE_T phTTS )
{
  MMRESULT mmStatus;

  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
  {
	mmStatus = MMSYSERR_INVALHANDLE;
  }
  else
  {
#ifndef OLEDECTALK
	mmStatus = PA_Resume( phTTS->pAudioHandle );
#endif
  }
  return( mmStatus );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechOpenWaveOutFile                             */
/*  Author: Bill Hallahan                                             */
/*  Date: July 8, 1993                                                */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         The TextToSpeechOpenWaveFile() function creates a wave     */
/*    file. After calling the TextToSpeechOpenWaveOutFile() function, */
/*    all subsequent calls to the TextToSpeechSpeak() function cause  */
/*    the audio to be written to the specified file until the         */
/*    TextToSpeechCloseWaveFile() function is called.                 */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS          A pointer to a Text-To-Speech handle.            */
/*                                                                    */
/*    pszFileName    A pointer of type char * which points to a null  */
/*                   terminated filename.                             */
/*                                                                    */
/*    dwFormat       An identifier which determines the wave file     */
/*                   audio sample format. It may be one of the        */
/*                   following constants which are defined in include */
/*                   file mmsystem.h and include file ttsapi.h:       */
/*                                                                    */
/*                     WAVE_FORMAT_1M08    11.025 KHz., Mono,  8-Bit  */
/*                     WAVE_FORMAT_1M16    11.025 KHz., Mono, 16-Bit  */
/*                     WAVE_FORMAT_08M08    8 KHz., Mono, 8-Bit u-law */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_INVALPARAM    An invalid parameter was passed.         */
/*                           (An illegal wave output format value.)   */
/*    MMSYSERR_NOMEM         Unable to allocate memory                */
/*    MMSYSERR_ALLOCATED     A wave output file is already open.      */
/*    MMSYSERR_ERROR         Unable to open the wave output file or   */
/*                           unable to write to the wave output file. */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT TextToSpeechOpenWaveOutFile( LPTTS_HANDLE_T phTTS,
					  char pszFileName[],
					  DWORD dwFormat )
{
  MMRESULT mmStatus;
  WAVE_FILE_HDR_T * pWaveFileHdr;

  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );

  /********************************************************************/
  /*  If a file is already open, then don't try to open another one.  */
  /*  If not in NULL output state or AUDIO Output state then return   */
  /*  an error.                                                       */
  /********************************************************************/

  if (( phTTS->dwOutputState != STATE_OUTPUT_AUDIO )
	&& ( phTTS->dwOutputState != STATE_OUTPUT_NULL ))
	return( MMSYSERR_ALLOCATED );

  /********************************************************************/
  /*  Wait until all previous calls to the TextToSpeechSpeak()        */
  /*  function have completed.                                        */
  /********************************************************************/

  mmStatus = TextToSpeechSync( phTTS );

  if ( mmStatus )
	return( mmStatus );

  /********************************************************************/
  /*  Create the header for the output file                           */
  /********************************************************************/

  pWaveFileHdr = (WAVE_FILE_HDR_T *) malloc( sizeof(WAVE_FILE_HDR_T));

  if ( pWaveFileHdr == NULL )
	return( MMSYSERR_NOMEM );
  
  /* MVP: Initialize the Wave_File_header's common elements for all waveformats.*/
  /*{ "RIFF", 0, "WAVEfmt ", 16, 1, 1, 11025, 11025, 1, 8, "data", 0 };*/
  pWaveFileHdr->psRiff[0] = 'R';
  pWaveFileHdr->psRiff[1] = 'I';
  pWaveFileHdr->psRiff[2] = 'F';
  pWaveFileHdr->psRiff[3] = 'F';
  pWaveFileHdr->dwRiffChunkSize = 0;
  pWaveFileHdr->psWaveFmt[0] = 'W';
  pWaveFileHdr->psWaveFmt[1] = 'A';
  pWaveFileHdr->psWaveFmt[2] = 'V';
  pWaveFileHdr->psWaveFmt[3] = 'E';
  pWaveFileHdr->psWaveFmt[4] = 'f';
  pWaveFileHdr->psWaveFmt[5] = 'm';
  pWaveFileHdr->psWaveFmt[6] = 't';
  pWaveFileHdr->psWaveFmt[7] = ' ';
  pWaveFileHdr->dwWaveChunkSize = 16;
  pWaveFileHdr->wNumberOfChannels = 1;
  pWaveFileHdr->psData[0] = 'd';
  pWaveFileHdr->psData[1] = 'a';
  pWaveFileHdr->psData[2] = 't';
  pWaveFileHdr->psData[3] = 'a';
  pWaveFileHdr->dwDataChunkSize = 0;

  /********************************************************************/
  /*  If the dwFormat value is invalid then return an error.          */
  /********************************************************************/

  switch( dwFormat )
  {
  case WAVE_FORMAT_1M16:

	pWaveFileHdr->wFormatTag = WAVE_FORMAT_PCM;
	pWaveFileHdr->dwSamplesPerSecond = PC_SAMPLE_RATE;
	pWaveFileHdr->dwAvgBytesPerSecond = PC_SAMPLE_RATE + PC_SAMPLE_RATE;
	pWaveFileHdr->wNumberBlockAlign = 2;
	pWaveFileHdr->wBitsPerSample = 16;

	SetSampleRate( phTTS, PC_SAMPLE_RATE );

	break;

  case WAVE_FORMAT_1M08:

	pWaveFileHdr->wFormatTag = WAVE_FORMAT_PCM;
	pWaveFileHdr->dwSamplesPerSecond = PC_SAMPLE_RATE;
	pWaveFileHdr->dwAvgBytesPerSecond = PC_SAMPLE_RATE;
	pWaveFileHdr->wNumberBlockAlign = 1;
	pWaveFileHdr->wBitsPerSample = 8;

	SetSampleRate( phTTS, PC_SAMPLE_RATE );

	break;

  case WAVE_FORMAT_08M08:

	pWaveFileHdr->wFormatTag = WAVE_FORMAT_MULAW;
	pWaveFileHdr->dwSamplesPerSecond = MULAW_SAMPLE_RATE;
	pWaveFileHdr->dwAvgBytesPerSecond = MULAW_SAMPLE_RATE;
	pWaveFileHdr->wNumberBlockAlign = 1;
	pWaveFileHdr->wBitsPerSample = 8;

	SetSampleRate( phTTS, MULAW_SAMPLE_RATE );

	break;

  default:

	free( pWaveFileHdr );
	return( MMSYSERR_INVALPARAM );
  }

  phTTS->dwFormat = dwFormat;

  /********************************************************************/
  /*  Open the wave output file.                                      */
  /********************************************************************/

  if (( phTTS->pWaveFile = fopen( pszFileName, "wb" )) == NULL )
  {
	free( pWaveFileHdr );
	return( MMSYSERR_ERROR );
  }

  /********************************************************************/
  /*  Write the header to the output file.                            */
  /********************************************************************/

  if ( 1 != fwrite( pWaveFileHdr,
					  sizeof( WAVE_FILE_HDR_T ),
					  1,
					  phTTS->pWaveFile ))
  {
	free( pWaveFileHdr );
	return( MMSYSERR_ERROR );
  }

  /********************************************************************/
  /*  Initialize the file sample count.                               */
  /********************************************************************/

  phTTS->dwFileSampleCount = 0;
  phTTS->pWaveFileHdr = pWaveFileHdr;
  phTTS->dwOutputState = STATE_OUTPUT_WAVE_FILE;

  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechCloseWaveOutFile                            */
/*  Author: Bill Hallahan                                             */
/*  Date: July 8, 1993                                                */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*    Close the Text-To-Speech Wave File.                             */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS    A pointer to a Text-To-Speech handle.                  */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_ERROR         Failure to wait for pending speech.      */
/*                             OR                                     */
/*                           Unable to update the wave output file    */
/*                           header.                                  */
/*                             OR                                     */
/*                           Unable to close the wave output file.    */
/*                             OR                                     */
/*                           No wave output file is open.             */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT TextToSpeechCloseWaveOutFile( LPTTS_HANDLE_T phTTS )
{
  DWORD dwLengthInBytes;
  FILE * pWaveFile;
  WAVE_FILE_HDR_T * pWaveFileHdr;
  MMRESULT mmStatus;

  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );

  /********************************************************************/
  /*  If a file is not open, then exit.                               */
  /********************************************************************/

  if ( phTTS->dwOutputState != STATE_OUTPUT_WAVE_FILE )
	return( MMSYSERR_ERROR );

  /********************************************************************/
  /*  Wait until all previous calls to the TextToSpeechSpeak()        */
  /*  function have completed.                                        */
  /********************************************************************/

  mmStatus = TextToSpeechSync( phTTS );
  
  if ( mmStatus )
	mmStatus = MMSYSERR_ERROR;
  else
	mmStatus = MMSYSERR_NOERROR;

  /********************************************************************/
  /*  Set the sample rate to the default value in case the sample     */
  /*  was changed.                                                    */
  /********************************************************************/

  SetSampleRate( phTTS, PC_SAMPLE_RATE );

  /********************************************************************/
  /*  Update the wave header riff chunk and data chunk lengths.       */
  /********************************************************************/

  switch( phTTS->dwFormat )
  {
  case WAVE_FORMAT_1M16:

	dwLengthInBytes = (DWORD)phTTS->dwFileSampleCount << 1;
	break;

  case WAVE_FORMAT_1M08:
  case WAVE_FORMAT_08M08:

	dwLengthInBytes = (DWORD)phTTS->dwFileSampleCount;
	break;

  default:

	/******************************************************************/
	/*  It should be impossible to get here so this error message is  */
	/*  not documented.                                               */
	/******************************************************************/

	return( MMSYSERR_INVALPARAM );
  }

  pWaveFileHdr = (WAVE_FILE_HDR_T *)phTTS->pWaveFileHdr;

  pWaveFileHdr->dwDataChunkSize = dwLengthInBytes;

  pWaveFileHdr->dwRiffChunkSize =
	pWaveFileHdr->dwDataChunkSize + RIFF_HEADER_OFFSET;

  /********************************************************************/
  /*  Seek to the top of the file to write the updated wave header.   */
  /********************************************************************/

  pWaveFile = (FILE *)phTTS->pWaveFile;

  if ( fseek( pWaveFile, 0L, SEEK_SET ))
  {
	free( pWaveFileHdr );
	return( MMSYSERR_ERROR );
  }

  /********************************************************************/
  /*  Write the header to the output file.                            */
  /********************************************************************/

  if ( 1 != fwrite( pWaveFileHdr,
					  sizeof(WAVE_FILE_HDR_T ),
					  1,
					  phTTS->pWaveFile ))
  {
	free( pWaveFileHdr );
	return( MMSYSERR_ERROR );
  }

  /********************************************************************/
  /*  Free the wave file header.                                      */
  /********************************************************************/

  free( pWaveFileHdr );

  /********************************************************************/
  /*  Set the system output state to audio if it is enabled.          */
  /********************************************************************/

  if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )
	phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
  else
	phTTS->dwOutputState = STATE_OUTPUT_NULL;

  /********************************************************************/
  /*  Close the wave file.                                            */
  /********************************************************************/

  if ( fclose( pWaveFile ))
	return( MMSYSERR_ERROR );
  
  return( mmStatus );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechGetStatus                                   */
/*  Author: Bill Hallahan                                             */
/*  Date: July 8, 1993                                                */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         The TextToSpeechGetStatus() function returns selected      */
/*    status information about the Text-To-Speech system.             */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS              A pointer to a Text-To-Speech handle.        */
/*                                                                    */
/*    dwIdentifierArray  An array of values of type DWORD which       */
/*                       contain identifiers that specify the status  */
/*                       values to return in array dwStatusArray[].   */
/*                       These values may be one of the following     */
/*                       constants.                                   */
/*                                                                    */
/*                                                                    */
/*      constant               status return value                    */
/*                                                                    */
/*  INPUT_CHARACTER_COUNT     Returns count of characters in the      */
/*                            Text-To-Speech input queue              */
/*                                                                    */
/*  STATUS_SPEAKING       The status value will be TRUE if there are  */
/*                        audio samples playing and FALSE if there is */
/*                        NO audio playing.                           */
/*                                                                    */
/*  WAVE_OUT_DEVICE_ID    The current wave out device ID is returned. */
/*                        This is only required if WAVE_MAPPER is     */
/*                        specified as the device ID in the           */
/*                        TextToSpeechStartup() function.             */
/*                                                                    */
/*                                                                    */
/*    dwStatusArray      An array of type DWORD which will contain    */
/*                       the status values corresponding to each of   */
/*                       the identifiers in array dwIdentifierArray[].*/
/*                                                                    */
/*    dwNumberOfStatusValues  The number of status values being       */
/*                            requested.                              */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_INVALPARAM    An invalid parameter was passed.         */
/*    MMSYSERR_ERROR         Error obtaining status value.            */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/*    A status value of 0xFFFFFFFF is returned in array pdwStatus[]   */
/*    if the corresponding passed parameter dwIdentifier is invalid.  */
/*    This function will then return a non-zero MMRESULT value. Note  */
/*    that 0xFFFFFFFF may be a legitimate status value and will not   */
/*    necessarily indicate an error in all cases.                     */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

#define  MAXIMUM_STATUS_VALUES  3

MMRESULT TextToSpeechGetStatus( LPTTS_HANDLE_T phTTS,
				DWORD dwIdentifierArray[],
				DWORD dwStatusArray[],
				DWORD dwNumberOfStatusValues )
{
  UINT i;
#ifndef OLEDECTALK
  DWORD dwIdentifier[1];
#endif
  DWORD dwAudioStatus[1];
  MMRESULT mmStatus =0;
  MMRESULT mmStatusReturn;

  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );

  /********************************************************************/
  /*  Range test the number of status values requested.               */
  /********************************************************************/

  if (( dwNumberOfStatusValues == 0 )
	|| ( dwNumberOfStatusValues > MAXIMUM_STATUS_VALUES ))
	return( MMSYSERR_INVALPARAM );

  mmStatusReturn = MMSYSERR_NOERROR;

  /********************************************************************/
  /*  Loop and fill in array dwStatusArray[].                             */
  /********************************************************************/

  for ( i = 0; i < dwNumberOfStatusValues; i++ )
  {
	switch( dwIdentifierArray[i] )
	{
	case INPUT_CHARACTER_COUNT:

	  OP_LockMutex( phTTS->pcsQueuedCharacterCount );
	  dwStatusArray[i] = phTTS->uiQueuedCharacterCount;
	  OP_UnlockMutex( phTTS->pcsQueuedCharacterCount );

	  break;

	case STATUS_SPEAKING:

	  if ( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE )
	  {
	dwStatusArray[i] = 0xFFFFFFFF;
	mmStatusReturn = MMSYSERR_ERROR;
	  }
	  else
	  {
#ifndef OLEDECTALK
	dwIdentifier[0] = PA_DEVICE_PLAYING;

	mmStatus = PA_Status( phTTS->pAudioHandle,
				dwIdentifier,
				dwAudioStatus,
				1 );
#endif
	if ( mmStatus )
	{
	  dwStatusArray[i] = 0xFFFFFFFF;
	  mmStatusReturn = MMSYSERR_ERROR;
	}
	else
	{
	  dwStatusArray[i] = dwAudioStatus[0];
	}
	  }
	  break;

	case WAVE_OUT_DEVICE_ID:

	  if ( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE )
	  {
	dwStatusArray[i] = 0xFFFFFFFF;
	mmStatusReturn = MMSYSERR_ERROR;
	  }
	  else
	  {
#ifndef OLEDECTALK
	dwIdentifier[0] = PA_DEVICE_ID;

	mmStatus = PA_Status( phTTS->pAudioHandle,
				dwIdentifier,
				dwAudioStatus,
				1 );
#endif
	if ( mmStatus )
	{
	  dwStatusArray[i] = 0xFFFFFFFF;
	  mmStatusReturn = MMSYSERR_ERROR;
	}
	else
	{
	  dwStatusArray[i] = dwAudioStatus[0];
	}
	  }
	  break;

	default:

	  dwStatusArray[i] = 0xFFFFFFFF;
	  mmStatusReturn = MMSYSERR_INVALPARAM;
	  break;
	}
  }
  return( mmStatusReturn );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechReset                                       */
/*  Author: Bill Hallahan                                             */
/*  Date: July 8, 1993                                                */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         The TextToSpeechReset() function cancels all audio output  */
/*    and deletes any text from the Text-To-Speech systems text       */
/*    queue. All pending index marks are discarded.                   */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS    A pointer to a Text-To-Speech handle.                  */
/*                                                                    */
/*    bReset   If bReset is FALSE then the Text-To-Speech system      */
/*             will not change mode when the reset occured. If bReset */
/*             is TRUE then the speaking mode will be MODE_CITATION,  */
/*             an open wave file will be closed, and the system will  */
/*             be returned to the startup state.                      */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_NOMEM         Unable to allocate memory.               */
/*    MMSYSERR_ERROR         Unable to flush the system.              */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
/* tek 19aug96 in the memory case: there appears to be a potential    */
/* deadlock in this; if you process buffer messages in the same thread*/
/* you call this from, we may get stuck waiting for a buffer that we  */
/* can't tell the caller to return to us because we have his thread   */
/* tied up.                                                           */
/* So, on entry, make sure we have a buffer available; empty that     */
/* buffer locally so that subsequent output calls won't block.        */
/**********************************************************************/




#define  MAXIMUM_RESET_WAIT_TIME_IN_MSEC  10000
#define  SEND_BUFFER_WAIT_TIME               20

MMRESULT TextToSpeechReset( LPTTS_HANDLE_T phTTS, BOOL bReset )
{
  MMRESULT mmStatus;
  /* Added a varaible to get handle of instance specific Kernel_share_data for MI:MVP */
  PKSD_T pKsd_t;
  LPTTS_BUFFER_T pTTS_Buffer;

  /********************************************************************/
  /*   Set the InReset flag                                           */
  /********************************************************************/
  phTTS->bInReset = TRUE;

  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
  { 
        phTTS->bInReset = FALSE;
	return( MMSYSERR_INVALHANDLE );
  }

  /********************************************************************/
  /*  Set the halting flag. This will cause the CMD, LTS, PH, VTM,    */
  /*  and SYNC threads to all discard input data and flush the pipes. */
  /********************************************************************/
  /* Get the current instance kernel_share_data : MVP */
  pKsd_t = phTTS->pKernelShareData;

  pKsd_t->halting = TRUE;

  pKsd_t->cmd_flush=CMD_flush_toss;

  /* tek 04sep96   drain the lts and ph pipes, just like on the */
  /* hardware platforms.. */

  DrainPipes(phTTS);

  /********************************************************************/
  /*  Perform an audio reset to immediately stop audio from playing   */
  /*  and to make sure the VTM thread is not blocked.                 */
  /********************************************************************/


  if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )
  {
	PA_Reset( phTTS->pAudioHandle );
  }

  // tek 19aug96 the same anti-block issue for the memory case..
if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )
  {		
	// tek 29aug96 always send back the user's buffers.Do it
	// now and git them out of the way.
	ReturnRemainingBuffers(phTTS);
	// we could have gotten stuck behind a buffer dump that happened
	// "just after" the message to the calling loop that got us here;
	// so, we have to queue up a dummy buffer to make sure we 
	// survive the get_pipe call..
	if((pKsd_t->buffer_pipe != NULL) && (pipe_count( pKsd_t->buffer_pipe) < 1) )
		TextToSpeechAddBuffer(phTTS, NULL); //GetBuffer knows how to handle nulls

    OP_LockMutex(phTTS->pcsMemoryBuffer);
  	// if we have an active output buffer, clear it.
	if ( (pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer) != NULL)
	  {

		pTTS_Buffer->dwBufferLength = 0;
		pTTS_Buffer->dwNumberOfPhonemeChanges = 0;
		pTTS_Buffer->dwNumberOfIndexMarks = 0;


	  } // was not a null buffer
	OP_UnlockMutex(phTTS->pcsMemoryBuffer);
  }

  /********************************************************************/
  /*  Stop the Text To Speech thread if it is queueing text.          */
  /*  The Text-To-Speech thread will queue no text if the message     */
  /*  number is less than phTTS->uiFlushMsgNumber.                    */
  /********************************************************************/
  OP_LockMutex( phTTS->pcsFlushMsgNumber );
  phTTS->uiFlushMsgNumber = phTTS->uiCurrentMsgNumber;
  OP_UnlockMutex( phTTS->pcsFlushMsgNumber );

  phTTS->uiCurrentMsgNumber++;

  // tek 19aug96 we now need to force speech, so that everybody
  // along the way gets cleared out. We do it here, so that the
  // above setting of FlushMsgNumber will allow this force to
  // go through.
  TextToSpeechSpeak( phTTS, "", TTS_FORCE );

  /********************************************************************/
  /*  Wait for the Text thread to complete all text queueing.         */
  /********************************************************************/
  WaitForTextQueuingToComplete( phTTS, TRUE );
 

  /********************************************************************/
  /*  Clear the halting flag.                                         */
  /********************************************************************/

  pKsd_t->halting = FALSE;

  /********************************************************************/
  /*  If the output state is memory then return all buffers to the    */
  /*  application.  WIH 3/28/95 Changed order for proper reset.       */
  /********************************************************************/

  if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )
  {
	/******************************************************************/
	/*  If there is nothing to reset then return.                     */
	/******************************************************************/

	if (( pipe_count( pKsd_t->cmd_pipe ) == 0 )
	  && ( pipe_count( pKsd_t->lts_pipe ) == 0 )
	  && ( pipe_count( pKsd_t->ph_pipe ) == 0 )
	  && ( pipe_count( pKsd_t->vtm_pipe ) == 0 )
	  && ( pipe_count( pKsd_t->buffer_pipe) == 0))
	{
      // tek 22aug96 by now, the cmd parser should be well oiled. Let it go*/
      pKsd_t->cmd_flush = FALSE;
      phTTS->bInReset = FALSE;
	if (pipe_count( phTTS->pKernelShareData->buffer_pipe ))
	{
		return(MMSYSERR_NOERROR);
	}
	else
	    return( MMSYSERR_NOERROR );
	}

	/******************************************************************/
	/*  If the previous reset has not completed then just flush the   */
	/*  pipes and exit.                                               */
	/******************************************************************/

	if ( phTTS->bMemoryReset )
	{
	  // reset the sync event so that we can use it to see when 
	  // this stuff gets through
	  OP_ResetEvent(phTTS->hSyncEvent);

	  TextToSpeechSpeak( phTTS, "", TTS_FORCE );
	  TextToSpeechSpeak( phTTS, "", TTS_FORCE );
	  TextToSpeechSpeak( phTTS, "", TTS_FORCE );
	  TextToSpeechSpeak( phTTS, "", TTS_FORCE );

	  /****************************************************************/
	  /*  Wait until the VTM thread is about to send a buffer.        */
	  /****************************************************************/
	   // tek 19aug96 this is probably a bad way to do it; it's 
	  // better to wait for the sync even that we get from those
	  // forces going through..
	  OP_WaitForEvent(phTTS->hSyncEvent, OP_INFINITE);
//		  while ( ! phTTS->bSendingBuffer )
//	  {
//	Sleep( SEND_BUFFER_WAIT_TIME );
//	  }

	  /****************************************************************/
	  /*  Empty all of the Text-To-Speech pipes.                      */
	  /****************************************************************/

	  pKsd_t->halting = TRUE;

	  mmStatus = WaitForEmptyPipes( phTTS,
					MAXIMUM_RESET_WAIT_TIME_IN_MSEC,
					TRUE );
	  pKsd_t->halting = FALSE;
	  // tek 29aug96 I'm not clear about the state of cmd_flush
	  // at this point. I don't know if I can clear it, because
	  // I *think* we're nested. But, I'll do it anyway.
      pKsd_t->cmd_flush = FALSE;

          phTTS->bInReset = FALSE;
	  return( mmStatus );
	}

	phTTS->bMemoryReset = TRUE;
  }

  /********************************************************************/
  /*  At this point there may still be a clause stuck in ph. Force    */
  /*  the clause out.                                                 */
  /********************************************************************/


  /********************************************************************/
  /*  Set the halting flag. This will cause the CMD, LTS, PH, VTM,    */
  /*  and SYNC threads to all discard input data and flush the pipes. */
  /********************************************************************/
  //tek 22aug96
  pKsd_t->halting = TRUE;


  TextToSpeechSpeak( phTTS, "", TTS_FORCE );
  TextToSpeechSpeak( phTTS, "", TTS_FORCE );
  TextToSpeechSpeak( phTTS, "", TTS_FORCE );
  TextToSpeechSpeak( phTTS, "", TTS_FORCE );

  /********************************************************************/
  /*  Wait for the Text thread to complete all text queueing.         */
  /********************************************************************/
  // tek 22aug96
  WaitForTextQueuingToComplete( phTTS, TRUE );

  // tek 22aug96 by now, the cmd parser should be well oiled. Let it go*/
  pKsd_t->cmd_flush = FALSE;

  /********************************************************************/
  /*  Perform an second audio reset to immediately stop audio from    */
  /*  playing and to make sure the VTM thread is not blocked.         */
  /********************************************************************/

  if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )
  {
	PA_Reset( phTTS->pAudioHandle );
  }

 // tek 19aug96 anti-block for the memory case.. 
if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )
  {
	if (pipe_count( phTTS->pKernelShareData->buffer_pipe ) < 1)
		TextToSpeechAddBuffer(phTTS, NULL); //deadlock avoidance
    OP_LockMutex(phTTS->pcsMemoryBuffer);
  	// if we have an active output buffer, clear it.
	if ( (pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer) != NULL)
	  {

		pTTS_Buffer->dwBufferLength = 0;
		pTTS_Buffer->dwNumberOfPhonemeChanges = 0;
		pTTS_Buffer->dwNumberOfIndexMarks = 0;


	  } // was not a null buffer
	OP_UnlockMutex(phTTS->pcsMemoryBuffer);
  }

  /********************************************************************/
  /*  Maximize the queued sample count to release the                 */
  /*  WaitForAudioSampleToPlay() function (in file sync.c).           */
  /********************************************************************/

  OP_LockMutex( phTTS->pcsQueuedSampleCount );
  phTTS->dwQueuedSampleCount = 4294967295;
  OP_UnlockMutex( phTTS->pcsQueuedSampleCount );

  /********************************************************************/
  /*  Empty all of the Text-To-Speech pipes.                          */
  /********************************************************************/

  mmStatus = WaitForEmptyPipes( phTTS,
				MAXIMUM_RESET_WAIT_TIME_IN_MSEC,
				TRUE );

  /********************************************************************/
  /*  Initialize the VTM, PH, LTS, and CMD threads.                   */
  /********************************************************************/

  if ( phTTS->dwOutputState != STATE_OUTPUT_MEMORY )
  {
	InitializeVTM(phTTS);
  };


  phinit( phTTS, bReset );


  ls_util_lts_init(phTTS->pLTSThreadData);

  
  cmd_init( phTTS,bReset );



  pKsd_t->halting = FALSE;
  // tek 22aug96 we still need to do a LAST_VOICE to make sure the VTM */
  // is in a nice state..
  {
	unsigned short LastVoice=LAST_VOICE;
	write_pipe( pKsd_t->lts_pipe, &LastVoice, 1 );
  }

  /********************************************************************/
  /*  Perform a third audio reset to make sure the audio queue is     */
  /*  empty after the pipes were emptied.                             */
  /********************************************************************/

  if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )
  {
	PA_Reset( phTTS->pAudioHandle );
  }
 // tek 19aug96 anti-block for the memory case.. 
 if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )
  {	
	if (pipe_count( phTTS->pKernelShareData->buffer_pipe ) < 2)
		TextToSpeechAddBuffer(phTTS, NULL); // deadlock avoidance
    OP_LockMutex(phTTS->pcsMemoryBuffer);
  	// if we have an active output buffer, clear it.
	if ( (pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer) != NULL)
	  {

		pTTS_Buffer->dwBufferLength = 0;
		pTTS_Buffer->dwNumberOfPhonemeChanges = 0;
		pTTS_Buffer->dwNumberOfIndexMarks = 0;


	  } // was not a null buffer
	OP_UnlockMutex(phTTS->pcsMemoryBuffer);
  }

  /********************************************************************/
  /*  Empty all of the Text-To-Speech pipes.                          */
  /********************************************************************/
  //tek 22aug96
  mmStatus = WaitForEmptyPipes( phTTS,
				MAXIMUM_RESET_WAIT_TIME_IN_MSEC,
				TRUE );

  /********************************************************************/
  /*  Zero the queued sample count (used for index marks and sync).   */
  /********************************************************************/



  OP_LockMutex( phTTS->pcsQueuedSampleCount );
  phTTS->dwQueuedSampleCount = 0;
  OP_UnlockMutex( phTTS->pcsQueuedSampleCount );


  /********************************************************************/
  /*  Conditionally reset the state of the Text-To-Speech system.     */
  /********************************************************************/


  if ( bReset )
  {
	switch( phTTS->dwOutputState )
	{
	case STATE_OUTPUT_MEMORY:

	  TextToSpeechCloseInMemory( phTTS );
	  break;

	case STATE_OUTPUT_WAVE_FILE:

	  TextToSpeechCloseWaveOutFile( phTTS );
	  break;

	case STATE_OUTPUT_LOG_FILE:

	  TextToSpeechCloseLogFile( phTTS );
	  break;

	default:
	  break;
	}

	/******************************************************************/
	/*  Initialize the Text-To-Speech system state variables.         */
	/******************************************************************/

	pKsd_t->cmd_flush = FALSE;
	pKsd_t->spc_flush = FALSE;
	pKsd_t->logflag  = 0;
/* GL 04/21/1997 set defaulted Spanish to Latin */
#ifdef LATIN_AMERICAN
  pKsd_t->modeflag = MODE_CITATION | MODE_LATIN;
#else
  pKsd_t->modeflag = MODE_CITATION;
#endif //LATIN_AMERICAN
	pKsd_t->sayflag = SAY_CLAUSE;
	pKsd_t->pronflag = 0;
	pKsd_t->wbreak = FALSE;
	pKsd_t->text_flush = FALSE;
	pKsd_t->async_change = FALSE;
  }

  /********************************************************************/
  /*  Free all allocated index mark memory.                           */
  /********************************************************************/


  free_index(pKsd_t);

  /********************************************************************/
  /*  Enable error messages.                                          */
  /********************************************************************/

  phTTS->bEnableErrorMessage = TRUE;

  if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )
  {
	ReturnRemainingBuffers(phTTS);	 //tek 03sep96 make sure..
	// tek somehow in here, Q2Mem could have snagged a buffer and
	// if so, we have to get rid of it..get
  }

  if ((pKsd_t->buffer_pipe != NULL) && pipe_count(pKsd_t->buffer_pipe ) )
  {
	  ReturnRemainingBuffers(phTTS);
  }

  if (phTTS->pTTS_Buffer != NULL)
	  SendBuffer(phTTS); // tek 04sep96 get rid of current
// tek 29aug96 if we got this far, we know that we
// can clear out MemoryReset.. normally SendBuf() would, 
// but we've moved teh one that actually returns the buffers 
// back in time.. 
// tek 03sep96 now SendBuffer doesn't ever clear MemoryReset..
	phTTS->bMemoryReset = FALSE;

  phTTS->bInReset = FALSE;

  if ( mmStatus )
	return( MMSYSERR_ERROR );

  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: WaitForTextQueuingToComplete                            */
/*  Author: Bill Hallahan                                             */
/*  Date: November 19, 1993                                           */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This function will return when all messages posted by      */
/*    the TextToSpeechSpeak() function have complteted.               */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS    A pointer to a Text-To-Speech handle.                  */
/*                                                                    */
/*    bReset   A boolean which is set to true if the queued text is   */
/*             discarded.                                             */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    none.                                                           */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

#define TEXT_QUEUE_WAIT_TIME  30
#define TEXT_LOCKUP_COUNT      2

static void WaitForTextQueuingToComplete( LPTTS_HANDLE_T phTTS,
										  BOOL bReset )
{
  int iLockupCount;

  /********************************************************************/
  /*  Wait for the Text-To-Speech thread to complete text queueing.   */
  /*  up to all messages numbered uiLastTextMessageNumber.            */
  /********************************************************************/

  iLockupCount = 0;

  while ( TRUE )
  {
	OP_LockMutex( phTTS->pcsLastQueuedTextMsgNumber );

	if ( phTTS->uiLastQueuedTextMsgNumber < phTTS->uiLastTextMsgNumber )
	{
	  OP_UnlockMutex( phTTS->pcsLastQueuedTextMsgNumber );

	  /****************************************************************/
	  /*  Set the sync event in case the cmd thread is blocked in the */
	  /*  cmd_sync() function.                                        */
	  /****************************************************************/

	  if ( bReset )
	  {
		OP_SetEvent( phTTS->hSyncEvent );

		/**************************************************************/
		/*  Perform an audio reset to immediately stop audio from     */
		/*  playing and to make sure the VTM thread is not blocked.   */
		/**************************************************************/

		if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )
		{
		  PA_Reset( phTTS->pAudioHandle );
		}
	  }

	  /****************************************************************/
	  /*  Go to sleep while the text queue empties.                   */
	  /****************************************************************/

	  OP_Sleep( TEXT_QUEUE_WAIT_TIME );

	  if (( phTTS->dwOutputState == STATE_OUTPUT_MEMORY ) && ( bReset ))
	  {
		iLockupCount++;

		if ( iLockupCount > TEXT_LOCKUP_COUNT )
		{
		  FixMemoryLockup( phTTS );

		  iLockupCount = 0;
		}
	  }
	}
	else
	{
	  OP_UnlockMutex( phTTS->pcsLastQueuedTextMsgNumber );
	  break;
	}
  }
  return;
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechSync                                        */
/*  Author: Bill Hallahan                                             */
/*  Date: July 8, 1993                                                */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         The TextToSpeechSync() function will block until all       */
/*    previously queued text has been spoken. This function will      */
/*    automatically resume audio if the Text-To-Speech system has     */
/*    been paused by the TextToSpeechPause() function.                */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS    A pointer to a Text-To-Speech handle.                  */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion.            */
/*    MMSYSERR_ERROR         Unable to complete queued text.          */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

#define  MAXIMUM_SYNC_WAIT_TIME_IN_MSEC  0xFFFFFFFF

MMRESULT TextToSpeechSync( LPTTS_HANDLE_T phTTS )
{
  MMRESULT mmStatus = MMSYSERR_NOERROR;

  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );

  /********************************************************************/
  /*  Resume if the text to speech system has been paused or this     */
  /*  function will block here forever.                               */
  /********************************************************************/
#ifndef OLEDECTALK
  if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )
	PA_Resume( phTTS->pAudioHandle );
#endif
  /********************************************************************/
  /*  Wait for the Text thread to complete all text queueing.         */
  /********************************************************************/

  WaitForTextQueuingToComplete( phTTS, FALSE );

  /********************************************************************/
  /*  Now that all the text is queued, make sure that it is purged.   */
  /*  Four TTS_FORCE characters are used because of the way the       */
  /*  WaitForEmptyPipes() function performs the wait.                 */
  /********************************************************************/

  TextToSpeechSpeak( phTTS, "", TTS_FORCE );
  TextToSpeechSpeak( phTTS, "", TTS_FORCE );
  TextToSpeechSpeak( phTTS, "", TTS_FORCE );
  TextToSpeechSpeak( phTTS, "", TTS_FORCE );

  /********************************************************************/
  /*  Now wait for all of the Text-To-Speech pipes to empty.          */
  /********************************************************************/

  mmStatus = WaitForEmptyPipes( phTTS,
				MAXIMUM_SYNC_WAIT_TIME_IN_MSEC,
				FALSE );

  if ( mmStatus )
	return( MMSYSERR_ERROR );

  /********************************************************************/
  /*  Now that the pipes are all empty, wait for the audio to         */
  /*  complete.                                                       */
  /********************************************************************/

  if( ( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )
  {
	if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )
	{
#ifndef OLEDECTALK
	  mmStatus = PA_WaitForPlayToComplete( phTTS->pAudioHandle );
#endif
	  if ( mmStatus )
	return( MMSYSERR_ERROR );
	}
  }
  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechGetRate                                     */
/*  Author: Bill Hallahan                                             */
/*  Date: July 8, 1993                                                */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         The TextToSpeechGetRate() function gets the Text-To-Speech */
/*    systems current speaking rate setting.                          */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS    A pointer to a Text-To-Speech handle.                  */
/*                                                                    */
/*    pdwRate  A pointer to a DWORD which will return the current     */
/*             Text-To-Speech speaking rate in words per minute.      */
/*             This will be a value from 75 to 600.                   */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT TextToSpeechGetRate( LPTTS_HANDLE_T phTTS,
				  LPDWORD pdwRate )
{
  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );

  *pdwRate = (DWORD) phTTS->pKernelShareData->sprate ;

  /********************************************************************/
  /*  The following range test should never fail, so the error return */
  /*  is undocumented.                                                */
  /********************************************************************/

  if (( *pdwRate < MIN_SPEAKING_RATE ) || ( *pdwRate > MAX_SPEAKING_RATE ))
	return( MMSYSERR_ERROR );

  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechSetRate                                     */
/*  Author: Bill Hallahan                                             */
/*  Date: July 8, 1993                                                */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         The TextToSpeechSetRate() function sets the Text-To-Speech */
/*    speaking rate.                                                  */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS    A pointer to a Text-To-Speech handle.                  */
/*                                                                    */
/*    uiRate   A DWORD which contains the speaking rate in words per  */
/*             minute. This must be a value between 75 and 600.       */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_INVALPARAM    An invalid parameter was passed.         */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT TextToSpeechSetRate( LPTTS_HANDLE_T phTTS,
				  DWORD dwRate )
{
  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );

  /********************************************************************/
  /*  Range test the speaking rate.                                   */
  /********************************************************************/

  if (( dwRate < MIN_SPEAKING_RATE ) || ( dwRate > MAX_SPEAKING_RATE ))
	return( MMSYSERR_INVALPARAM );

  phTTS->pKernelShareData->sprate = (short)dwRate;

  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechGetSpeaker                                  */
/*  Author: Bill Hallahan                                             */
/*  Date: July 8, 1993                                                */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         The TextToSpeechGetSpeaker() function gets the voice of    */
/*    the speaker the Text-To-Speech system is currently using.       */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS     A pointer to a Text-To-Speech handle.                 */
/*                                                                    */
/*    pSpeaker  A pointer of type LPSPEAKER_T which will return the   */
/*              value of the current speaker.                         */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT TextToSpeechGetSpeaker( LPTTS_HANDLE_T phTTS,
				 LPSPEAKER_T pSpeaker )
{
  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );
  /* Also initialized new element in KSD for MI : MVP */
  *pSpeaker = (SPEAKER_T)(phTTS->pKernelShareData->uiCurrentSpeaker);

  /********************************************************************/
  /*  The following range test should never fail, so the error return */
  /*  is undocumented.                                                */
  /********************************************************************/

  if ( *pSpeaker > WENDY + 1 )
	return( MMSYSERR_ERROR );

  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechSetSpeaker                                  */
/*  Author: Bill Hallahan                                             */
/*  Date: July 8, 1993                                                */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         The TextToSpeechSetSpeaker() function sets voice of the    */
/*    speaker the Text-To-Speech system will use.                     */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS    A pointer to a Text-To-Speech handle.                  */
/*                                                                    */
/*    Speaker  A value of type SPEAKER_T which contains the speaking  */
/*             voice to use.                                          */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_INVALPARAM    An invalid parameter was passed.         */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT TextToSpeechSetSpeaker( LPTTS_HANDLE_T phTTS,
				 SPEAKER_T Speaker )
{
  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );

  /********************************************************************/
  /*  Range test the speaker voice.                                   */
  /********************************************************************/

  if (( Speaker < PAUL ) || ( Speaker > WENDY ))
	return( MMSYSERR_INVALPARAM );

  /********************************************************************/
  /*  Set voice change flag for phmain.c in the PH thread.            */
  /********************************************************************/

  SetSpeaker( phTTS , Speaker );

  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechGetLanguage                                 */
/*  Author: Bill Hallahan                                             */
/*  Date: July 22, 1993                                               */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         The TextToSpeechGetLanguage() function gets the language   */
/*    that the Text-To-Speech system is currently using.              */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS      A pointer to a Text-To-Speech handle.                */
/*                                                                    */
/*    pLanguage  A pointer of type LPLANGUAGE_T which will return     */
/*               the value of the current language.                   */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT TextToSpeechGetLanguage( LPTTS_HANDLE_T phTTS,
				  LPLANGUAGE_T pLanguage )
{
  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );

  *pLanguage = TTS_AMERICAN_ENGLISH;

  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechSetLanguage                                 */
/*  Author: Bill Hallahan                                             */
/*  Date: July 8, 1993                                                */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         The TextToSpeechSetLanguage() function sets the language   */
/*    that the Text-To-Speech system will use. The text to be spoken  */
/*    should be in the selected language.                             */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS     A pointer to a Text-To-Speech handle.                 */
/*                                                                    */
/*    Language  A value of type LANGUAGE_T which contains the         */
/*              language to use.                                      */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_INVALPARAM    An invalid parameter was passed.         */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT TextToSpeechSetLanguage( LPTTS_HANDLE_T phTTS,
				  LANGUAGE_T Language )
{
  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );

  if ( Language != TTS_AMERICAN_ENGLISH )
	return( MMSYSERR_INVALPARAM );

  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechGetCaps                                     */
/*  Author: Bill Hallahan                                             */
/*  Date: July 8, 1993                                                */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         The TextToSpeechGetCaps() function fills in a structure of */
/*    type TTS_CAPS_T. On return, this function will contain the      */
/*    capabilities of the Text-To-Speech system.                      */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTScaps  A pointer to a structure of type TTS_CAPS_T. The     */
/*               caller must have allocated space for this structure  */
/*               before calling this function.                        */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_ERROR         The pointer to the TTS_CAPS_T structure  */
/*                           was invalid.                             */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

LANGUAGE_PARAMS_T LanguageParamsArray[1];

MMRESULT TextToSpeechGetCaps( LPTTS_CAPS_T pTTScaps )
{
  if ( pTTScaps == NULL )
	return( MMSYSERR_ERROR );

  LanguageParamsArray[0].dwLanguage = TTS_AMERICAN_ENGLISH;
  LanguageParamsArray[0].dwLanguageAttributes = PROPER_NAME_PRONUNCIATION;

  pTTScaps->dwNumberOfLanguages = 1;
  pTTScaps->lpLanguageParamsArray = LanguageParamsArray;
  pTTScaps->dwSampleRate = 11025;
  pTTScaps->dwMinimumSpeakingRate = MIN_SPEAKING_RATE;
  pTTScaps->dwMaximumSpeakingRate = MAX_SPEAKING_RATE;
  pTTScaps->dwNumberOfPredefinedSpeakers = WENDY + 1;
  pTTScaps->dwCharacterSet = TTS_ASCII;
  pTTScaps->Version = 421;

  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechLoadUserDictionary                          */
/*  Author: Bill Hallahan                                             */
/*  Date: September 13, 1993                                          */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         The TextToSpeechLoadUserDictionary() function will load a  */
/*    user dictionary. If a user dictionary is already loaded then it */
/*    must be unloaded by the TextToSpeechUnloadUserDictionary()      */
/*    function before the new dictionary can be loaded.               */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS       A pointer to a Text-To-Speech handle.               */
/*                                                                    */
/*    szFileName  A pointer to a null terminated string which         */
/*                contains the dictionary name.                       */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion.            */
/*    MMSYSERR_NOMEM         Cannot allocate memory for Dictionary.   */
/*    MMSYSERR_INVALPARAM    Dictionary file not found.               */
/*                           (invalid dictionary file name.)          */
/*    MMSYSERR_ERROR         Illegal dictionary format,               */
/*                           or a dictionary is already loaded.       */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT TextToSpeechLoadUserDictionary( LPTTS_HANDLE_T phTTS,
					 LPSTR szFileName )
{
  // Added a local varaible to get the handle of current kernel_share_data handle :MVP
  PKSD_T pKsd_t;

  // Initialize with the pointer stored in phTTS :MVP */
  pKsd_t = phTTS->pKernelShareData ;
  

  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/
  
  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );

  /********************************************************************/
  /*  Return error if a user dictionary is already loaded.            */
  /********************************************************************/
  /* Changed KS to pKsd_t :MVP */
  /* GL 11/05/1997  for BATS#510 */
  if ( pKsd_t->udic_entries[pKsd_t->lang_curr] != 0 )
	return( MMSYSERR_ERROR );

  /********************************************************************/
  /*  Load the user dictionary.                                       */
  /********************************************************************/
  /* GL 11/05/1997  for BATS#510 */
  return( load_dictionary( phTTS->hWnd,
			   (void **)&(pKsd_t->udic[pKsd_t->lang_curr]),
			   (unsigned int *)&(pKsd_t->udic_entries[pKsd_t->lang_curr]),
			   szFileName,
			   TRUE,
			   FALSE ));
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechUnloadUserDictionary                        */
/*  Author: Bill Hallahan                                             */
/*  Date: July 22, 1993                                               */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         The TextToSpeechUnLoadUserDictionary() function will       */
/*    unload the currently loaded user dictionary.                    */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS      A pointer to a Text-To-Speech handle.                */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT TextToSpeechUnloadUserDictionary( LPTTS_HANDLE_T phTTS )
{
  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );

  /* GL 11/05/1997  for BATS#510 */
  unload_dictionary((void **)&(phTTS->pKernelShareData->udic[phTTS->pKernelShareData->lang_curr]),
			(unsigned int *)&(phTTS->pKernelShareData->udic_entries[phTTS->pKernelShareData->lang_curr]));

  return( MMSYSERR_NOERROR );
/*	UNREFERENCED_PARAMETER( phTTS ); */
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechOpenInMemory                                */
/*  Author: Bill Hallahan                                             */
/*  Date: September 27, 1993                                          */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         The TextToSpeechInMemory() function will cause all speech  */
/*    speech samples created by the Text-To-Speech system to be       */
/*    places in user supplied shared memory buffers. These buffers    */
/*    are supplied to the system by the TextToSpeechAddBuffer()       */
/*    function.                                                       */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS                 A pointer to a Text-To-Speech handle.     */
/*                                                                    */
/*    dwFormat       An identifier which determines the wave file     */
/*                   audio sample format. It may be one of the        */
/*                   following constants which are defined in include */
/*                   file mmsystem.h and include file ttsapi.h:       */
/*                                                                    */
/*                     WAVE_FORMAT_1M08    11.025 KHz., Mono,  8-Bit  */
/*                     WAVE_FORMAT_1M16    11.025 KHz., Mono, 16-Bit  */
/*                     WAVE_FORMAT_08M08    8 KHz., Mono, 8-Bit u-law */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_INVALPARAM    An invalid parameter was passed.         */
/*                           (An illegal output format value.)        */
/*    MMSYSERR_NOMEM         Unable to allocate memory                */
/*    MMSYSERR_ERROR         Illeagal output state.                   */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT TextToSpeechOpenInMemory( LPTTS_HANDLE_T phTTS,
				   DWORD dwFormat )
{
  P_PIPE buffer_pipe = NULL_PIPE;
  MMRESULT mmStatus;

  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );

  /********************************************************************/
  /*  If not in NULL output state or AUDIO Output state then return   */
  /*  an error.                                                       */
  /********************************************************************/

  if (( phTTS->dwOutputState != STATE_OUTPUT_AUDIO )
	&& ( phTTS->dwOutputState != STATE_OUTPUT_NULL ))
	return( MMSYSERR_ERROR );

  /********************************************************************/
  /*  Wait until all previous calls to the TextToSpeechSpeak()        */
  /*  function have completed.                                        */
  /********************************************************************/

  mmStatus = TextToSpeechSync( phTTS );

  if ( mmStatus )
	return( mmStatus );

  /********************************************************************/
  /*  If the dwFormat value is invalid then return an error.          */
  /********************************************************************/

  switch( dwFormat )
  {
  case WAVE_FORMAT_1M16:

	SetSampleRate( phTTS, PC_SAMPLE_RATE );

	break;

  case WAVE_FORMAT_1M08:

	SetSampleRate( phTTS, PC_SAMPLE_RATE );

	break;

  case WAVE_FORMAT_08M08:

	SetSampleRate( phTTS, MULAW_SAMPLE_RATE );

	break;

  default:

	return( MMSYSERR_INVALPARAM );
  }

  phTTS->dwFormat = dwFormat;

  /********************************************************************/
  /*  Create a pipe to send the buffer addresses to the VTM thread.   */
  /********************************************************************/

  buffer_pipe = create_pipe( VOID_PTR_PIPE, BUFFER_PIPE_LENGTH );

  if ( buffer_pipe == NULL )
  {
	return( MMSYSERR_NOMEM );
  }
  
  phTTS->pKernelShareData->buffer_pipe = buffer_pipe;

  /********************************************************************/
  /*  Create the memory buffer critical section.                      */
  /********************************************************************/

  phTTS->pcsMemoryBuffer = OP_CreateMutex();

  if ( phTTS->pcsMemoryBuffer == NULL )
  {
	DeleteTextToSpeechObjects( phTTS );
	return( MMSYSERR_NOMEM );
  }

  /********************************************************************/
  /*  Initialize the handle objects for memory output.                */
  /********************************************************************/

  phTTS->pTTS_Buffer = NULL;

  phTTS->dwOutputState = STATE_OUTPUT_MEMORY;

  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechCloseInMemory                               */
/*  Author: Bill Hallahan                                             */
/*  Date: September 28, 1993                                          */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         The TextToSpeechCloseInMemory() function will return the   */
/*    Text-To-Speech system to it's normal state. Speech samples will */
/*    be routed to the audio device (if audio output was enabled at   */
/*    startup).                                                       */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS      A pointer to a Text-To-Speech handle.                */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_ERROR         Output to memory not enabled             */
/*                           or unable to create a system object.     */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT TextToSpeechCloseInMemory( LPTTS_HANDLE_T phTTS )
{
  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );

  /********************************************************************/
  /*  If not in MEMORY output state then return an error.             */
  /********************************************************************/

  if ( phTTS->dwOutputState != STATE_OUTPUT_MEMORY )
	return( MMSYSERR_ERROR );

  /********************************************************************/
  /*  Halt the system and flush all data.                             */
  /********************************************************************/

  TextToSpeechSync( phTTS );

  /********************************************************************/
  /*  Delete the memory buffer critical section.                      */
  /********************************************************************/

  if ( phTTS->pcsMemoryBuffer != NULL )
  {
	OP_DestroyMutex( phTTS->pcsMemoryBuffer );
  }

  /********************************************************************/
  /*  Delete the memory buffer pipe.                                  */
  /********************************************************************/

  destroy_pipe( phTTS->pKernelShareData->buffer_pipe );
  // tek 30aug96 null the pointer.
  phTTS->pKernelShareData->buffer_pipe = NULL;

  /********************************************************************/
  /*  Set the system output state to audio if it is enabled.          */
  /********************************************************************/

  phTTS->pTTS_Buffer = NULL;

  if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )
	phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
  else
	phTTS->dwOutputState = STATE_OUTPUT_NULL;

  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechAddBuffer                                   */
/*  Author: Bill Hallahan                                             */
/*  Date: September 30, 1993                                          */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This function will add a buffer to the memory list.        */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS          A pointer to a structure of type TTS_HANDLE_T.   */
/*                                                                    */
/*    pTTS_Buffer    A pointer to a TTS_BUFFER_T structure.           */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_INVALPARAM    Invalid parameter.                       */
/*    MMSYSERR_ERROR         Output to memory not enabled             */
/*                           or unable to create a system object.     */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT TextToSpeechAddBuffer( LPTTS_HANDLE_T phTTS,
				LPTTS_BUFFER_T pTTS_Buffer )
{
  LPTTS_BUFFER_T pPipeArray[1];
  unsigned int uiI;
  char szTemp[256]="";

  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );

  /********************************************************************/
  /*  If not in MEMORY output state then return an error.             */
  /********************************************************************/

  if ( phTTS->dwOutputState != STATE_OUTPUT_MEMORY )
	return( MMSYSERR_ERROR );

  /********************************************************************/
  /*  Send the wave header to the VTM thread.                         */
  /********************************************************************/

  pPipeArray[0] = pTTS_Buffer;

  // tek 03sep96 add some debugging info here..
  OP_LockMutex( phTTS->pcsBufferPipe);
  write_pipe( phTTS->pKernelShareData->buffer_pipe, pPipeArray, 1);
  uiI = pipe_count( phTTS->pKernelShareData->buffer_pipe );
  OP_UnlockMutex( phTTS->pcsBufferPipe );
  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechReturnBuffer                                */
/*  Author: Bill Hallahan                                             */
/*  Date: September 30, 1993                                          */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This function will cause the current buffer to be returned */
/*    even if it not yet full. The buffer may in fact be empty. The   */
/*    dwLength field of the WAVEHDR structure will contain the number */
/*    of samples in the buffer.                                       */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS           A pointer to a structure of type TTS_HANDLE_T.  */
/*                                                                    */
/*    ppTTS_Buffer    A pointer to a LPTTS_BUFFER_T pointer.          */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_INVALPARAM    Invalid parameter.                       */
/*    MMSYSERR_ERROR         Output to memory not enabled             */
/*                           or unable to create a system object.     */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT TextToSpeechReturnBuffer( LPTTS_HANDLE_T phTTS,
				   LPTTS_BUFFER_T * ppTTS_Buffer )
{
  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );

  /********************************************************************/
  /*  If not in MEMORY output state then return an error.             */
  /********************************************************************/

  if ( phTTS->dwOutputState != STATE_OUTPUT_MEMORY )
	return( MMSYSERR_ERROR );

  /********************************************************************/
  /*  Return the last buffer to the application.                      */
  /*  Block if the buffer is busy.                                    */
  /********************************************************************/

  OP_LockMutex( phTTS->pcsMemoryBuffer );

  *ppTTS_Buffer = (LPTTS_BUFFER_T)phTTS->pTTS_Buffer;
  phTTS->pTTS_Buffer = NULL;

  /********************************************************************/
  /*  Release the buffer.                                             */
  /********************************************************************/

  OP_UnlockMutex( phTTS->pcsMemoryBuffer );

  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechOpenLogFile                                 */
/*  Author: Bill Hallahan                                             */
/*  Date: October 12, 1993                                            */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         The TextToSpeechOpenLogFile() function creates a file      */
/*    which contains either text, phonemes, or syllables. The         */
/*    phonemes and syllables are written using the arpabet alphabet.  */
/*    After calling this function, all subsequent calls to the        */
/*    TextToSpeechSpeak() function cause the log data to be written   */
/*    to specified file until the TextToSpeechCloseLogFile() function */
/*    is called.                                                      */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS          A pointer to a Text-To-Speech handle.            */
/*                                                                    */
/*    pszFileName    A pointer of type char * which points to a null  */
/*                   terminated filename.                             */
/*                                                                    */
/*    dwFlags        A DWORD which specified the type of output. It   */
/*                   may contain one or more of the following         */
/*                   constans:                                        */
/*                                                                    */
/*       value                       Operation                        */
/*                                                                    */
/*    LOG_PHONEMES           Log phonemes                             */
/*    LOG_NAME_TYPES         Log name types to console                */
/*    LOG_FORM_TYPES         Log name form classes to console         */
/*    LOG_SYLLABLES          Log name syllable structure              */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_INVALPARAM    An invalid parameter was passed.         */
/*    MMSYSERR_NOMEM         Unable to allocate memory                */
/*    MMSYSERR_ALLOCATED     A log file is already open.              */
/*    MMSYSERR_ERROR         Unable to open the output file           */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT TextToSpeechOpenLogFile( LPTTS_HANDLE_T phTTS,
				  char pszFileName[],
				  DWORD dwFlags )
{
  MMRESULT mmStatus;

  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );

  /********************************************************************/
  /*  If a file is already open, then don't try to open another one.  */
  /********************************************************************/

  OP_LockMutex( phTTS->pcsLogFile );

  if ( phTTS->dwOutputState == STATE_OUTPUT_LOG_FILE )
  {
	OP_UnlockMutex( phTTS->pcsLogFile );
	return( MMSYSERR_ALLOCATED );
  }

  /********************************************************************/
  /*  If not in NULL output state or AUDIO Output state then return   */
  /*  an error.                                                       */
  /********************************************************************/

  if (( phTTS->dwOutputState != STATE_OUTPUT_AUDIO )
	&& ( phTTS->dwOutputState != STATE_OUTPUT_NULL ))
  {
	OP_UnlockMutex( phTTS->pcsLogFile );
	return( MMSYSERR_ERROR );
  }

  /********************************************************************/
  /*  Make sure the arguments are valid.                              */
  /********************************************************************/

  if ( dwFlags & ~( LOG_TEXT | LOG_PHONEMES | LOG_SYLLABLES ))
  {
	OP_UnlockMutex( phTTS->pcsLogFile );
	return( MMSYSERR_INVALPARAM );
  }

  /********************************************************************/
  /*  Wait until all previous calls to the TextToSpeechSpeak()        */
  /*  function have completed.                                        */
  /********************************************************************/

  mmStatus = TextToSpeechSync( phTTS );

  if ( mmStatus )
  {
	OP_UnlockMutex( phTTS->pcsLogFile );
	return( mmStatus );
  }

  /********************************************************************/
  /*  Open the log file.                                              */
  /********************************************************************/

  if (( phTTS->pLogFile = fopen( pszFileName, "w" )) == NULL )
  {
	OP_UnlockMutex( phTTS->pcsLogFile );
	return( MMSYSERR_ERROR );
  }

  /********************************************************************/
  /*  Set the log file control variables.                             */
  /********************************************************************/

  phTTS->pKernelShareData->logflag = dwFlags;
  phTTS->dwOutputState = STATE_OUTPUT_LOG_FILE;

  OP_UnlockMutex( phTTS->pcsLogFile );

  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechCloseLogFile                                */
/*  Author: Bill Hallahan                                             */
/*  Date: OCtober 12, 1993                                            */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*    This function closes the log file opened by the                 */
/*    TextToSpeechOpenLogFile() function.                             */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS    A pointer to a Text-To-Speech handle.                  */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*    The return value will be one of the following constants.        */
/*                                                                    */
/*    MMSYSERR_NOERROR = 0   Normal successful completion             */
/*    MMSYSERR_ERROR         Failure to wait for pending speech,      */
/*                           or Unable to close the output file,      */
/*                           or No output file is open.               */
/*    MMSYSERR_INVALHANDLE   The Text-To-Speech handle is invalid.    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT TextToSpeechCloseLogFile( LPTTS_HANDLE_T phTTS )
{
  MMRESULT mmStatus;

  /********************************************************************/
  /*  Return error if invalid handle.                                 */
  /********************************************************************/

  if ( IsBadWritePtr( phTTS, sizeof(phTTS)))
	return( MMSYSERR_INVALHANDLE );

  /********************************************************************/
  /*  If a file is not open, then exit.                               */
  /********************************************************************/

  OP_LockMutex( phTTS->pcsLogFile );

  if ( phTTS->dwOutputState != STATE_OUTPUT_LOG_FILE )
  {
	OP_UnlockMutex( phTTS->pcsLogFile );
	return( MMSYSERR_ERROR );
  }

  /********************************************************************/
  /*  Wait until all previous calls to the TextToSpeechSpeak()        */
  /*  function have completed.                                        */
  /********************************************************************/

  mmStatus = TextToSpeechSync( phTTS );

  if ( mmStatus )
	mmStatus = MMSYSERR_ERROR;
  else
	mmStatus = MMSYSERR_NOERROR;

  /********************************************************************/
  /*  Disable writing to the log file.                                */
  /********************************************************************/

  phTTS->pKernelShareData->logflag = 0;

  /********************************************************************/
  /*  Set the system output state to audio if it is enabled.          */
  /********************************************************************/

  if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )
	phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
  else
	phTTS->dwOutputState = STATE_OUTPUT_NULL;

  /********************************************************************/
  /*  Close the log file.                                             */
  /********************************************************************/

  if ( fclose( phTTS->pLogFile ))
	mmStatus = MMSYSERR_ERROR;

  OP_UnlockMutex( phTTS->pcsLogFile );

  return( mmStatus );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: QueueToMemory                                           */
/*  Author: Bill Hallahan                                             */
/*  Date: September 28, 1993                                          */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This function queues a buffer of samples to application    */
/*    provided  buffers in shared memory. This function will block    */
/*    until there is enough buffer space avaiable. This function is   */
/*    called by the driver for the vocal tract model in file          */
/*    vtmiont.c.                                                      */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS              A pointer to a structure of type             */
/*                       TTS_HANDLE_T.                                */
/*                                                                    */
/*    pSamples           A pointer (of type LPSAMPLE_T) to a buffer   */
/*                       which contains samples (of type SAMPLE_T).   */
/*                                                                    */
/*                                                                    */
/*    dwNumberOfSamples  A DWORD which is equal to the number of 16   */
/*                       bit samples to be queued which are in the    */
/*                       buffer pointed to by "pSamples".             */
/*  Output:                                                           */
/*                                                                    */
/*    None.                                                           */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

void QueueToMemory( LPTTS_HANDLE_T phTTS,
			LPSAMPLE_T pSamples,
			DWORD dwNumberOfSamples )
{
  unsigned int i;                        /*MVP : Not a static */
  DWORD dwBytesLeft;             /*MVP : Not a static */
  DWORD dwWordsLeft;             /*MVP : Not a static */
  unsigned char * pBuffer;       /*MVP : Not a static */
  short * pShort;
  LPTTS_BUFFER_T pTTS_Buffer;/*MVP : Not a static */

  /********************************************************************/
  /*  Loop until all samples have been moved into buffers.            */
  /********************************************************************/

  while( dwNumberOfSamples )
  {
	/******************************************************************/
	/*  Block if the TextToSpeechReturnBuffer() function is returning */
	/*  the current buffer.                                           */
	/******************************************************************/

	OP_LockMutex( phTTS->pcsMemoryBuffer );

	/******************************************************************/
	/*  If a new Text-To-Speech buffer is needed then get one from    */
	/*  the application. Block if one is not available.               */
	/******************************************************************/

	if ( (phTTS->pTTS_Buffer == NULL )
		&& !(phTTS->bMemoryReset) 
		&& !(phTTS->pKernelShareData->halting) )
	{
	phTTS->pTTS_Buffer = GetBuffer( phTTS );
	}

	/******************************************************************/
	/*  Move as many samples as possible into the buffer.             */
	/*  Get the current buffer pointer and the number of bytes left   */
	/*  in the buffer.                                                */
	/******************************************************************/

	pTTS_Buffer = (LPTTS_BUFFER_T)phTTS->pTTS_Buffer;

	/******************************************************************/
	/*  NULL buffers sent by reset to fix hang. WIH 3/27/95           */
	/******************************************************************/

	/* tek 19aug96 Also, we should bail out here if we're doing a     */
	/* reset.                                                         */
	if ( (pTTS_Buffer == NULL))
	{ // tek I think we have to do a leaveCS here.. 
	  OP_UnlockMutex( phTTS->pcsMemoryBuffer );
	  return;
	}

	if (phTTS->bMemoryReset)
	{ // tek I think we have to do a leaveCS here.. 
	  OP_UnlockMutex( phTTS->pcsMemoryBuffer );
	  SendBuffer(phTTS); //tek 03sep96
	  return;
	}	

	if  (phTTS->pKernelShareData->halting)
	{ // tek I think we have to do a leaveCS here.. 
	  OP_UnlockMutex( phTTS->pcsMemoryBuffer );
	  SendBuffer(phTTS); //tek 03sep96
	  return;
	}

	pBuffer = (unsigned char *) pTTS_Buffer->lpData + pTTS_Buffer->dwBufferLength;
  
	dwBytesLeft =
	  pTTS_Buffer->dwMaximumBufferLength - pTTS_Buffer->dwBufferLength;

	/******************************************************************/
	/*  Put the samples into the buffer in the proper format.         */
	/******************************************************************/

	switch( phTTS->dwFormat )
	{
	/******************************************************************/
	/*  Output 16 bit samples.                                        */
	/******************************************************************/

	case WAVE_FORMAT_1M16:

	  dwWordsLeft = dwBytesLeft >> 1;
	  pShort = (short *)pBuffer;      

	  if ( dwNumberOfSamples >= dwWordsLeft )
	  {
	for ( i = 0; i < dwWordsLeft; i++ )
	  *pShort++ = *pSamples++;

	pTTS_Buffer->dwBufferLength += dwWordsLeft << 1;
	dwNumberOfSamples = dwNumberOfSamples - dwWordsLeft;
	  }
	  else
	  {
	for ( i = 0; i < dwNumberOfSamples; i++ )
	  *pShort++ = *pSamples++;

	pTTS_Buffer->dwBufferLength += dwNumberOfSamples << 1;
	dwNumberOfSamples = 0;
	  }

	  break;

	/******************************************************************/
	/*  Output 8 bit samples.                                         */
	/******************************************************************/

	case WAVE_FORMAT_1M08:

	  if ( dwNumberOfSamples >= dwBytesLeft )
	  {
	for ( i = 0; i < dwBytesLeft; i++ )
	  *pBuffer++ = ((unsigned char)((*pSamples++) >> 8)) ^ 0x80;

	pTTS_Buffer->dwBufferLength += dwBytesLeft;
	dwNumberOfSamples = dwNumberOfSamples - dwBytesLeft;
	  }
	  else
	  {
	for ( i = 0; i < dwNumberOfSamples; i++ )
	  *pBuffer++ = ((unsigned char)((*pSamples++) >> 8)) ^ 0x80;

	pTTS_Buffer->dwBufferLength += dwNumberOfSamples;
	dwNumberOfSamples = 0;
	  }

	  break;

	/******************************************************************/
	/*  Output 8 bit mu-law samples.                                  */
	/******************************************************************/

	case WAVE_FORMAT_08M08:

	  if ( dwNumberOfSamples >= dwBytesLeft )
	  {
	for ( i = 0; i < dwBytesLeft; i++ )
	  *pBuffer++ = LinearToMuLaw( *pSamples++ );

	pTTS_Buffer->dwBufferLength += dwBytesLeft;
	dwNumberOfSamples = dwNumberOfSamples - dwBytesLeft;
	  }
	  else
	  {
	for ( i = 0; i < dwNumberOfSamples; i++ )
	  *pBuffer++ = LinearToMuLaw( *pSamples++ );

	pTTS_Buffer->dwBufferLength += dwNumberOfSamples;
	dwNumberOfSamples = 0;
	  }

	  break;

	default:

	  break;
	}

	/******************************************************************/
	/*  The buffer is full. Return it to the application.             */
	/******************************************************************/

	if ( pTTS_Buffer->dwBufferLength >= pTTS_Buffer->dwMaximumBufferLength )
	{
	  /****************************************************************/
	  /*  Release the buffer.                                         */
	  /****************************************************************/

	  OP_UnlockMutex( phTTS->pcsMemoryBuffer );

	  SendBuffer( phTTS );
	}
	else
	{
	  OP_UnlockMutex( phTTS->pcsMemoryBuffer );

	  /****************************************************************/
	  /*  tek 19aug96 if halting, release the buffer.                 */
	  /****************************************************************/
	if (phTTS->pKernelShareData-> halting)
		SendBuffer(phTTS);

	}
  }
  return;
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: GetBuffer                                               */
/*  Author: Bill Hallahan                                             */
/*  Date: November 30, 1993                                           */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This function will get an application provided buffer.     */
/*    The buffer address will be copied into the pTTS_Buffer element  */
/*    of the Text-To-Speech handle phTTS.                             */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS              A pointer to a structure of type             */
/*                       TTS_HANDLE_T.                                */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    A pointer to a structure of type TTS_HANDLE_T.                  */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

static LPTTS_BUFFER_T GetBuffer( LPTTS_HANDLE_T phTTS )
{
  LPTTS_BUFFER_T pTTS_BufferArray[1];  /*MVP : Not a static */
  LPTTS_BUFFER_T pTTS_Buffer;              /*MVP : Not a static */
  read_pipe( phTTS->pKernelShareData->buffer_pipe, &pTTS_BufferArray[0], 1 );

  pTTS_Buffer = pTTS_BufferArray[0];

  if ( pTTS_Buffer != NULL )
  {
	pTTS_Buffer->dwBufferLength = 0;
	pTTS_Buffer->dwNumberOfPhonemeChanges = 0;
	pTTS_Buffer->dwNumberOfIndexMarks = 0;

	if ( phTTS->dwFormat == WAVE_FORMAT_1M16 )
	  pTTS_Buffer->dwMaximumBufferLength &= 0xFFFFFFFE;
  }
  return( pTTS_Buffer );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: SendBuffer                                              */
/*  Author: Bill Hallahan                                             */
/*  Date: October 1, 1993                                             */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This function returns the current buffer to the            */
/*    application.                                                    */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS              A pointer to a structure of type             */
/*                       TTS_HANDLE_T.                                */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    None.                                                           */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

void SendBuffer( LPTTS_HANDLE_T phTTS )
{
   LPTTS_BUFFER_T pTTS_Buffer;              /*MVP : Not a static */

  if ( (! phTTS->bMemoryReset)
	  && (! phTTS->pKernelShareData->halting))
  {
	if ( phTTS->pTTS_Buffer != NULL )
	{
	  pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer;

	  /****************************************************************/
	  /*  NULL buffers sent by reset to fix hang. WIH 3/27/95         */
	  /****************************************************************/

	  if ( pTTS_Buffer != NULL )
	  {


	  /****************************************************************/
	  /*  It is possible to get here with nothing in the buffer if    */
	  /*  a force caused the buffer to be returned. Check the buffer  */
	  /*  to see if it has any sections full.                         */
	  /****************************************************************/

	  if (( pTTS_Buffer->dwBufferLength > 0 )
	 || ( pTTS_Buffer->dwNumberOfIndexMarks > 0 )
	 || ( pTTS_Buffer->dwNumberOfPhonemeChanges > 0 ))
	  {
	phTTS->bSendingBuffer = TRUE;
	/*
	SendMessage( phTTS->hWnd,
			 phTTS->uiID_Buffer_Message,
			 0,
			 (LPARAM)phTTS->pTTS_Buffer );
	*/
	//MVP: Replaced above SendMessage with Report_TTS_status :New Audio code
	Report_TTS_Status(phTTS,phTTS->uiID_Buffer_Message,0,(LPARAM)phTTS->pTTS_Buffer);
	
	phTTS->bSendingBuffer = FALSE;

	OP_WaitForEvent( phTTS->hNotEmptyingVtmPipeEvent, OP_INFINITE );

	phTTS->pTTS_Buffer = NULL;
	  }
	  }
	}
  }
  else
  {
	/******************************************************************/
	/*  Send the current buffer back.                                 */
	/******************************************************************/

	if ( phTTS->pTTS_Buffer != NULL )
	{
	  pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer;

	  /****************************************************************/
	  /*  NULL buffers sent by reset to fix hang. WIH 3/27/95         */
	  /*  This is needed in spite of previous "if" statement because  */
	  /*  the app is multip-threaded.                                 */
	  /****************************************************************/

	  if ( pTTS_Buffer != NULL )
	  {
	phTTS->bSendingBuffer = TRUE;
	/*
	SendMessage( phTTS->hWnd,
			 phTTS->uiID_Buffer_Message,
			 0,
			 (LPARAM)pTTS_Buffer );
	*/
	//MVP: Replaced above SendMessage with Report_TTS_status :New Audio code
	Report_TTS_Status(phTTS,phTTS->uiID_Buffer_Message,0,(LPARAM)pTTS_Buffer);
	phTTS->pTTS_Buffer = NULL;	  //tek 03sep96

	phTTS->bSendingBuffer = FALSE;

	OP_WaitForEvent( phTTS->hNotEmptyingVtmPipeEvent, OP_INFINITE );
	  }
	}

	// tek 03sep96 moved the return of remaining buffers out to 
	// a separate routine.
	ReturnRemainingBuffers(phTTS);


// tek 29aug96 if we're in a flusg, put in another null buffer.. 
    if (phTTS->pKernelShareData->halting )
		TextToSpeechAddBuffer(phTTS, NULL); // a dummy buffer.
	/******************************************************************/
	/*  Empty the VTM pipe in case there is still any data in it      */
	/******************************************************************/

	InitializeVTM(phTTS);

	//phTTS->pTTS_Buffer = NULL;
	//tek 03sep96 we can't clear this flag here, because  vtm writes
	// that sneak in at the 'right' time could prematurely clear it.
	//phTTS->bMemoryReset = FALSE;

	OP_SetEvent( phTTS->hNotEmptyingVtmPipeEvent );
  }
  return;
}

//tek 03sep96
// created this routine (once a part of SendBuffer) to correctly
// return the remaining buffers and to allow the buffer pipe
// to be flushed during a reset without problems of collisions
// with the VTM thread. 
void ReturnRemainingBuffers( LPTTS_HANDLE_T phTTS )

{
  LPTTS_BUFFER_T pPipeArray[1];        /*MVP : Not a static */
  LPTTS_BUFFER_T pTTS_Buffer;              /*MVP : Not a static */

    /******************************************************************/
	/*  Send all the remaining buffers back.                          */
	/******************************************************************/

	// tek 03sep96 we need to lock the pipe to make sure nothing arrives
    // while we're dumping.. 

    OP_LockMutex(phTTS->pcsBufferPipe);
	while (pipe_count( phTTS->pKernelShareData->buffer_pipe ) ) 
	{
	  read_pipe( phTTS->pKernelShareData->buffer_pipe, &pPipeArray, 1 );
	  OP_UnlockMutex(phTTS->pcsBufferPipe);
	  pTTS_Buffer = pPipeArray[0];

	  if ( pTTS_Buffer != NULL )
	  {
	pTTS_Buffer->dwBufferLength = 0;
	pTTS_Buffer->dwNumberOfPhonemeChanges = 0;
	pTTS_Buffer->dwNumberOfIndexMarks = 0;

	phTTS->bSendingBuffer = TRUE;
	/*
	SendMessage( phTTS->hWnd,
			 phTTS->uiID_Buffer_Message,
			 0,
			 (LPARAM)pTTS_Buffer );
	*/
	//MVP: Replaced above SendMessage with Report_TTS_status :New Audio code
	Report_TTS_Status(phTTS,phTTS->uiID_Buffer_Message,0,(LPARAM)pTTS_Buffer);

	phTTS->bSendingBuffer = FALSE;

	OP_WaitForEvent( phTTS->hNotEmptyingVtmPipeEvent, OP_INFINITE );
	  }
	// relock the pipe to atomically get a count and a buffer.
    OP_LockMutex(phTTS->pcsBufferPipe);
	}
OP_UnlockMutex(phTTS->pcsBufferPipe);
} // ReturnRemainingBuffers()

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: PutIndexMarkInBuffer                                    */
/*  Author: Bill Hallahan                                             */
/*  Date: October 1, 1993                                             */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This function puts an index mark in the buffer structure   */
/*    which is used whenever the Text-To-Speech system is buffering   */
/*    speech samples in memory.                                       */
/*                                                                    */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS              A pointer to a structure of type             */
/*                       TTS_HANDLE_T.                                */
/*                                                                    */
/*    dwIndexValue       A DWORD which equals the index mark value.   */
/*                                                                    */
/*    dwSampleNumber     A DWORD which equals the current sample      */
/*                       number.                                      */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    None.                                                           */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

void PutIndexMarkInBuffer( LPTTS_HANDLE_T phTTS,
			   DWORD dwIndexValue,
			   DWORD dwSampleNumber )
{
  UINT uiIndex;                                                      /*MVP : Not a static */
  /*static LPTTS_BUFFER_T pPipeArray[1];*/               /*MVP : Never Used   */
  LPTTS_BUFFER_T pTTS_Buffer;                                    /*MVP : Not a static */
  static LPTTS_INDEX_T pIndexArray;                              /*MVP : Not a static */

  /********************************************************************/
  /*   If current in the Reset code, no need to continue              */
  /********************************************************************/
  if ( phTTS->bInReset )
	return;

  /********************************************************************/
  /*  Block if the TextToSpeechReturnBuffer() function is returning   */
  /*  the current buffer.                                             */
  /********************************************************************/

  OP_LockMutex( phTTS->pcsMemoryBuffer );

  /********************************************************************/
  /*  If a new Text-To-Speech buffer is needed then get one from      */
  /*  the application. Block if one is not available.                 */
  /********************************************************************/

  if ( phTTS->pTTS_Buffer == NULL )
  {
	phTTS->pTTS_Buffer = GetBuffer( phTTS );
  }

  pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer;

  /********************************************************************/
  /*  NULL buffers sent by reset to fix hang. WIH 3/27/95             */
  /********************************************************************/

  if ( pTTS_Buffer == NULL )
  {
	OP_UnlockMutex( phTTS->pcsMemoryBuffer );
	return;
  }

  /********************************************************************/
  /*  Put the index mark into the current buffer.                     */
  /********************************************************************/

  pIndexArray = pTTS_Buffer->lpIndexArray;

  if ( pIndexArray != NULL )
  {
	uiIndex = pTTS_Buffer->dwNumberOfIndexMarks;

	if ( pTTS_Buffer->dwMaximumNumberOfIndexMarks > 0 )
	{
	  (pIndexArray+uiIndex)->dwIndexValue = dwIndexValue;
	  (pIndexArray+uiIndex)->dwIndexSampleNumber = dwSampleNumber;
	  pTTS_Buffer->dwNumberOfIndexMarks++;
	}

	/******************************************************************/
	/*  If the index mark array is full then return it to the         */
	/*  application.                                                  */
	/******************************************************************/

	if ( pTTS_Buffer->dwNumberOfIndexMarks
	   >= pTTS_Buffer->dwMaximumNumberOfIndexMarks )
	{
	  /****************************************************************/
	  /*  Release the buffer.                                         */
	  /****************************************************************/

	  OP_UnlockMutex( phTTS->pcsMemoryBuffer );

	  SendBuffer( phTTS );
	}
	else
	{
	  /****************************************************************/
	  /*  Release the buffer.                                         */
	  /****************************************************************/

	  OP_UnlockMutex( phTTS->pcsMemoryBuffer );
	}
  }
  else
  {
	/******************************************************************/
	/*  Release the buffer.                                           */
	/******************************************************************/

	OP_UnlockMutex( phTTS->pcsMemoryBuffer );
  }
  return;
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: PutPhonemeInBuffer                                      */
/*  Author: Bill Hallahan                                             */
/*  Date: October 1, 1993                                             */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This function puts phoneme data in the buffer structure    */
/*    which is used whenever the Text-To-Speech system is buffering   */
/*    speech samples in memory.                                       */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS              A pointer to a structure of type             */
/*                       TTS_HANDLE_T.                                */
/*                                                                    */
/*    dwIndexValue       A DWORD which equals the index mark value.   */
/*                                                                    */
/*    dwSampleNumber     A DWORD which equals the current sample      */
/*                       number.                                      */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    None.                                                           */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

void PutPhonemeInBuffer( LPTTS_HANDLE_T phTTS,
			 DWORD dwPhoneme,
			 DWORD dwPhonemeDuration,
			 DWORD dwSampleNumber )
{
  UINT uiIndex;                                                     /* MVP : Not a static */
  /*static LPTTS_BUFFER_T pPipeArray[1];*/  /* MVP : Never Used   */
  LPTTS_BUFFER_T pTTS_Buffer;                           /* MVP : Not a static */
  LPTTS_PHONEME_T pPhonemeArray;                        /* MVP : Not a static */

  /********************************************************************/
  /*   If current in the Reset code, no need to continue              */
  /********************************************************************/
  if ( phTTS->bInReset )
	return;

  /********************************************************************/
  /*  Block if the TextToSpeechReturnBuffer() function is returning   */
  /*  the current buffer.                                             */
  /********************************************************************/
  OP_LockMutex( phTTS->pcsMemoryBuffer );

  /********************************************************************/
  /*  If a new Text-To-Speech buffer is needed then get one from      */
  /*  the application. Block if one is not available.                 */
  /********************************************************************/

  if ( phTTS->pTTS_Buffer == NULL )
  {
	phTTS->pTTS_Buffer = GetBuffer( phTTS );
  }

  /********************************************************************/
  /*  Put the index mark into the current buffer.                     */
  /********************************************************************/

  pTTS_Buffer = (LPTTS_BUFFER_T) phTTS->pTTS_Buffer;

  /********************************************************************/
  /*  NULL buffers sent by reset to fix hang. WIH 3/27/95             */
  /********************************************************************/

  if ( pTTS_Buffer == NULL )
  {
	OP_UnlockMutex( phTTS->pcsMemoryBuffer );
	return;
  }

  pPhonemeArray = pTTS_Buffer->lpPhonemeArray;

  if ( pPhonemeArray != NULL )
  {
	uiIndex = pTTS_Buffer->dwNumberOfPhonemeChanges;

	if ( pTTS_Buffer->dwMaximumNumberOfPhonemeChanges > 0 )
	{
	  (pPhonemeArray+uiIndex)->dwPhoneme = dwPhoneme;
	  (pPhonemeArray+uiIndex)->dwPhonemeSampleNumber = dwSampleNumber;
	  (pPhonemeArray+uiIndex)->dwPhonemeDuration = dwPhonemeDuration;
	  pTTS_Buffer->dwNumberOfPhonemeChanges++;
	}

	/******************************************************************/
	/*  If the phoneme array is full then return it to the            */
	/*  application.                                                  */
	/******************************************************************/

	if ( pTTS_Buffer->dwNumberOfPhonemeChanges
	   >= pTTS_Buffer->dwMaximumNumberOfPhonemeChanges )
	{
	  /****************************************************************/
	  /*  Release the buffer.                                         */
	  /****************************************************************/

	  OP_UnlockMutex( phTTS->pcsMemoryBuffer );

	  SendBuffer( phTTS );
	}
	else
	{
	  /****************************************************************/
	  /*  Release the buffer.                                         */
	  /****************************************************************/

	  OP_UnlockMutex( phTTS->pcsMemoryBuffer );
	}
  }
  else
  {
	/******************************************************************/
	/*  Release the buffer.                                           */
	/******************************************************************/

	OP_UnlockMutex( phTTS->pcsMemoryBuffer );
  }
  return;
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: SetSpeaker                                              */
/*  Author: Bill Hallahan                                             */
/*  Date: July 8, 1993                                                */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         The SetSpeaker() function sets voice of the speaker that   */
/*    the Text-To-Speech system will use.                             */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    Speaker  A value of type SPEAKER_T which contains the speaking  */
/*             voice to use.                                          */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    The speaker is set asynchronously.                              */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

static void SetSpeaker( LPTTS_HANDLE_T phTTS, SPEAKER_T Speaker )
{
  /********************************************************************/
  /*  Set voice change flag for phmain.c in the PH thread.            */
  /********************************************************************/
  PKSD_T pKsd_t = phTTS->pKernelShareData;

  pKsd_t->async_voice = Speaker;
  pKsd_t->last_voice = (short)Speaker;
  pKsd_t->async_change |= ASYNC_voice;

}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Thread Main: TextToSpeechThreadMain                               */
/*  Author: Bill Hallahan                                             */
/*  Date: April 14, 1993                                              */
/*                                                                    */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This is the message processing loop for the Text-To-Speech */
/*    window procedure. The Text To Speech window procedure processes */
/*    all messages which pertain to the wave output device.           */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

static OP_THREAD_ROUTINE(TextToSpeechThreadMain, LPTTS_HANDLE_T phTTS)
{
  PKSD_T pKsd_t = phTTS->pKernelShareData;
  PVOID pCmd_t = phTTS->pCMDThreadData;
  unsigned int uiCurrentTextLength;
  unsigned int uiLength;
  unsigned char *pText;
  char FlushString[1];
  TEXT_MSG_T * pTextMsg;
  TEXT_MSG_T * pNextTextMsg;
  int nbw = 0;
  int nbytes = 0;
  int i = 0;

  /* Initialize thread error field to no error */
  phTTS->uiThreadError = MMSYSERR_NOERROR;

  /* 
   * CP: Set the event, even if malloc eerror occurred. User
   * will look at uiThreadError for actual error code.
   */
  OP_SetEvent(phTTS->hMallocSuccessEvent);

  while( ! phTTS->uiTextThreadExit )
  {
    /******************************************************************/
    /*  Wait until the TextToSpeechSpeak() function queues some text. */
    /******************************************************************/

    OP_WaitForEvent( phTTS->hTextInQueueEvent, OP_INFINITE );

    /********************************************************************/
    /*  Get the next text message from the top of the linked list.      */
    /********************************************************************/

    OP_LockMutex( phTTS->pcsTextMsgList );

    pTextMsg = phTTS->pTextMsgList;

    /********************************************************************/
    /*  It should not be possible to get here with the text list empty  */
    /*  but this check can't hurt.                                      */
    /********************************************************************/
    
    if ( pTextMsg != NULL )
    {	
      pNextTextMsg = pTextMsg->pLink;
      pText = pTextMsg->pText;
      uiCurrentTextLength = pTextMsg->uiLength;
      phTTS->pTextMsgList = pNextTextMsg;
    }
    else
    {
      uiCurrentTextLength = 0;
    }
    
    if ( phTTS->pTextMsgList == NULL )
    {
      OP_ResetEvent( phTTS->hTextInQueueEvent );
    }

    OP_UnlockMutex( phTTS->pcsTextMsgList );

    /********************************************************************/
    /*  Increment the queued character count.                           */
    /********************************************************************/

    if ( uiCurrentTextLength != 0 )
    {
      /******************************************************************/
      /*  Queue the text unless a TextToSpeechReset() forces an abort   */
      /*  by setting the ppTTS->pKernelShareData->halting flag.         */
      /*  Write the text in 4096 byte chunks                            */
      /******************************************************************/

      uiLength = uiCurrentTextLength;
      
      while (( uiLength > MAX_TEXT_WRITE_LENGTH ) && ( ! (pKsd_t->halting )))
      {
#ifdef 0
        nbytes =
	  uiLength > MAX_TEXT_WRITE_LENGTH ? MAX_TEXT_WRITE_LENGTH : uiLength;
#endif
        write_pipe( pKsd_t->cmd_pipe, pText, MAX_TEXT_WRITE_LENGTH );
        uiLength -= MAX_TEXT_WRITE_LENGTH;
        pText += MAX_TEXT_WRITE_LENGTH;
#ifdef 0
        if ( nbw != nbytes )
          break;
#endif
      }

      if (( uiLength > 0 ) && ( ! (pKsd_t->halting )))
        write_pipe( pKsd_t->cmd_pipe, pText, uiLength );
      
      if ( pTextMsg->pText != NULL )
        free( pTextMsg->pText );
      
      if ( pTextMsg != NULL )
        free( pTextMsg );
    }
    
    /********************************************************************/
    /*  Decrement the queued character count.                           */
    /********************************************************************/

    OP_LockMutex( phTTS->pcsQueuedCharacterCount );
    phTTS->uiQueuedCharacterCount -= uiCurrentTextLength;
    OP_UnlockMutex( phTTS->pcsQueuedCharacterCount );
  }

  /********************************************************************/
  /*  Exit the thread.                                                */
  /********************************************************************/

  OP_ExitThread( 0 );
  
  OP_THREAD_RETURN;
}

#ifdef 0
static OP_THREAD_ROUTINE(TextToSpeechThreadMain, LPTTS_HANDLE_T phTTS)
{
  MSG msg;

  /* Initialize thread error field to no error */
  phTTS->uiThreadError = MMSYSERR_NOERROR;

  /********************************************************************/
  /*  Create the TextToSpeech window.                                 */
  /********************************************************************/

  phTTS->hTextToSpeechWnd = InitTextToSpeechWindow( phTTS );

  if(phTTS->hTextToSpeechWnd == NULL)
        phTTS->uiThreadError = MMSYSERR_ERROR;
  /* 
   * CP: Set the event, even if malloc eerror occurred. User
   * will look at uiThreadError for actual error code.
   */
  OP_SetEvent(phTTS->hMallocSuccessEvent);
  if (phTTS->uiThreadError != MMSYSERR_NOERROR)
  {
      OP_ExitThread(phTTS->uiThreadError);
      OP_THREAD_RETURN;
  }
  while( GetMessage( &msg,
			   phTTS->hTextToSpeechWnd,
			   0L,
			   ID_TTS_Destroy ))
	  DispatchMessage( &msg );

  OP_ExitThread(MMSYSERR_NOERROR);
  OP_THREAD_RETURN;
#ifdef 0
  _endthreadex(msg.wParam);
  return( FALSE );
#endif
}
#endif

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechErrorHandler                                */
/*  Author: Bill Hallahan                                             */
/*  Date: July 8, 1993                                                */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This function sends a message to the window procedure      */
/*    corresponding to the handle passed to the                       */
/*    TextToSpeechStartup() function.                                 */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    hWnd           A handle to the parent window.                   */
/*                                                                    */
/*    uiErrorCode    An application defined error code.               */
/*                                                                    */
/*    mmStatus       An error code of type MMRESULT.                  */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    None.                                                           */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

void TextToSpeechErrorHandler( LPTTS_HANDLE_T phTTS,
				   UINT uiErrorCode,
				   MMRESULT mmStatus )
{
  if ( phTTS->bEnableErrorMessage )
  {
	phTTS->bEnableErrorMessage = FALSE;
	/*
	SendMessage( phTTS->hWnd,
		 phTTS->uiID_Error_Message,
		 (WPARAM)uiErrorCode,
		 (LPARAM)mmStatus );
	*/
	//MVP: Replaced above SendMessage with Report_TTS_status :New Audio code:
	Report_TTS_Status(phTTS,phTTS->uiID_Error_Message,(WPARAM)uiErrorCode,(LPARAM)mmStatus);

  }
  return;
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: TextToSpeechGetHandle                                   */
/*  Author: Bill Hallahan                                             */
/*  Date: July 8, 1993                                                */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This function gets the handle to the TextToSpeech system   */
/*    which created during the call to the TextToSpeechStarup()       */
/*    function.                                                       */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    None                                                            */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a a pointer to the Text-To-Speech handle. */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/
/* This fucntion will become obsolete for MI : MVP  */
#if 0
LPTTS_HANDLE_T TextToSpeechGetHandle()
{
  /*return( phTTSglobal );*/
}
#endif
/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: WriteAudioToFile                                        */
/*  Author: Bill Hallahan                                             */
/*  Date: July 21, 1993                                               */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*    This function writes audio samples to the wave output file.     */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS    A pointer to a Text-To-Speech handle.                  */
/*                                                                    */
/*    pBuffer       A pointer (of type LPSAMPLE_T) to a buffer which  */
/*                  contains samples (of type SAMPLE_T).              */
/*                                                                    */
/*                                                                    */
/*    uiLength      The number of audio sample in the buffer.         */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

MMRESULT WriteAudioToFile( LPTTS_HANDLE_T phTTS,
			   LPSAMPLE_T pBuffer,
			   UINT uiLength )
{
  UINT i;
  unsigned char * pByteDest;
  LPSAMPLE_T pSource;
  size_t Size;

  /********************************************************************/
  /*  Convert the 16 bit samples to the desired output format.        */
  /********************************************************************/

  switch( phTTS->dwFormat )
  {
  case WAVE_FORMAT_1M16:

	Size = sizeof( short );

	break;

  case WAVE_FORMAT_1M08:

	pSource = pBuffer;
	pByteDest = (unsigned char *)pBuffer;

	for ( i = 0; i < uiLength; i++ )
	  *pByteDest++ = ((unsigned char)((*pSource++) >> 8)) ^ 0x80;

	Size = sizeof( unsigned char );

	break;

  case WAVE_FORMAT_08M08:

	pSource = pBuffer;
	pByteDest = (unsigned char *)pBuffer;

	for ( i = 0; i < uiLength; i++ )
	  *pByteDest++ = LinearToMuLaw( *pSource++ );

	Size = sizeof( unsigned char );

	break;

  default:

	return( MMSYSERR_INVALHANDLE );
  }

  /********************************************************************/
  /*  Write the audio samples to the output file.                     */
  /********************************************************************/

  if ( uiLength != fwrite( pBuffer,
			   Size,
			   (size_t)uiLength,
			   phTTS->pWaveFile ))
	return( MMSYSERR_ERROR );

  phTTS->dwFileSampleCount += uiLength;

  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: LinearToMuLaw.c                                         */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*    This routine converts from linear to ulaw.                      */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    wSample       A signed 16 bit linear sample                     */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type unsigned char which is    */
/*    an 8 bit ulaw sample.                                           */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/*  Turn on the trap as per the MIL-STD                               */
/*  Turn off the trap for telephone applications.                     */
/**********************************************************************/

/* #define ZEROTRAP */

/**********************************************************************/
/*  Define the add-in bias for 16 bit samples                         */
/**********************************************************************/

#define  MULAW_BIAS         0x84
#define  MULAW_CLIP_LEVEL  32635

static unsigned char LinearToMuLaw( short wSample )
{
  static short wExponentLut[256] = { 0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,
					 4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
					 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
					 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
					 6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
					 6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
					 6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
					 6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
					 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
					 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
					 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
					 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
					 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
					 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
					 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
					 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7 };
  short wSign;
  short wExponent;
  short wMantissa;
  unsigned char cMuLawByte;

  /********************************************************************/
  /*  Get the sample into sign-magnitude.                             */
  /*  First save the sign.                                            */
  /********************************************************************/

  wSign = ( wSample >> 8 ) & 0x80;

  /********************************************************************/
  /*  Get magnitude.                                                  */
  /********************************************************************/

  if ( wSign != 0 )
	wSample = - wSample;

  /********************************************************************/
  /*  Clip the magnitude.                                             */
  /********************************************************************/

  if ( wSample > MULAW_CLIP_LEVEL )
	wSample = MULAW_CLIP_LEVEL;

  /********************************************************************/
  /*  Convert from 16 bit linear to mu-law.                           */
  /********************************************************************/

  wSample = wSample + MULAW_BIAS;
  wExponent = wExponentLut[ ( wSample >> 7 ) & 0xFF ];
  wMantissa = ( wSample >> ( wExponent + 3 ) ) & 0x0F;
  cMuLawByte = ~ ( wSign | ( wExponent << 4 ) | wMantissa );

  /********************************************************************/
  /*  Optional CCITT trap                                             */
  /********************************************************************/

#ifdef ZEROTRAP
  if ( cMuLawByte == 0 )
	cMuLawByte = 0x02;
#endif

  return( cMuLawByte );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: WaitForLtsFlush                                         */
/*  Author: Bill Hallahan                                             */
/*  Date: July 24, 1993                                               */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*    This function blocks until the inter-thread pipe queues from    */
/*    the lts pipe to the sync pipe are flushed. The TEXT and CMD     */
/*    pipes are ignored. This is used to flush pipes from the CMD     */
/*    thread. If a timeout value is exceeded then this function will  */
/*    return an error status value.                                   */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS             A pointer to a Text-To-Speech handle.         */
/*                                                                    */
/*    dwWaitTimeInMsec  A DWORD which contains the amount of time to  */
/*                      wait for all pipes to empty before returning  */
/*                      an error.                                     */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

#define  WAIT_PIPE_SLEEP_TIME    50
#define  WAIT_PIPE_ABORT_COUNT   300

MMRESULT WaitForLtsFlush( LPTTS_HANDLE_T phTTS,
			  DWORD dwWaitTimeInMsec )
{
  BOOL bPipesNotEmpty;
  UINT uiSyncCount;
  UINT uiVtmCount;
  UINT uiPhCount;
  UINT uiLtsCount;
  DWORD dwTotalTimeInMsec;
  /* Added a varaible to get current instance Kernel_Share_Data 
   * and initialize from phTTS structure
   */
  PKSD_T pKsd_t = NULL;

  pKsd_t = phTTS->pKernelShareData;

  /********************************************************************/
  /*  Wait for all the pipes to empty.                                */
  /*  If the pipes are not empty then sleep for 100 msec. and check   */
  /*  them again.                                                     */
  /********************************************************************/

  dwTotalTimeInMsec = 0;
  bPipesNotEmpty = TRUE;

  while ( bPipesNotEmpty )
  {
	bPipesNotEmpty = FALSE;

	uiSyncCount = pipe_count( pKsd_t->sync_pipe );
	uiVtmCount = pipe_count( pKsd_t->vtm_pipe );
	uiPhCount = pipe_count( pKsd_t->ph_pipe );
	uiLtsCount = pipe_count( pKsd_t->lts_pipe );

	if  (( uiSyncCount != 0 )
	 || ( uiVtmCount != 0 )
	 || ( uiPhCount != 0 )
	 || ( uiLtsCount != 0 ))
	  bPipesNotEmpty = TRUE;

	/******************************************************************/
	/*  If bPipesNotEmpty is still FALSE here then the pipes are      */
	/*  probably empty. It is possible that there is still data in    */
	/*  the pipes, but that it moved out of a pipe we are about to    */
	/*  check into a pipe we have we just checked. We now check the   */
	/*  pipes in the reverse order.                                   */
	/******************************************************************/

	if ( ! bPipesNotEmpty )
	{
/*
	  kernel_disable(pKsd_t);
*/
	  uiLtsCount = pipe_count( pKsd_t->lts_pipe );
	  uiPhCount = pipe_count( pKsd_t->ph_pipe );
	  uiVtmCount = pipe_count( pKsd_t->vtm_pipe );
	  uiSyncCount = pipe_count( pKsd_t->sync_pipe );
/*
	  kernel_enable( pKsd_t, uiDummy );
*/
	  if  (( uiSyncCount != 0 )
	|| ( uiVtmCount != 0 )
	|| ( uiPhCount != 0 )
	|| ( uiLtsCount != 0 ))
	bPipesNotEmpty = TRUE;
	  else
	bPipesNotEmpty = FALSE;
	}

	/******************************************************************/
	/*  Go to sleep for WAIT_PIPE_SLEEP_TIME msec.                    */
	/******************************************************************/

	if ( bPipesNotEmpty )
	{
	  OP_Sleep( WAIT_PIPE_SLEEP_TIME );

	  dwTotalTimeInMsec += WAIT_PIPE_SLEEP_TIME;

	  if ( dwTotalTimeInMsec > dwWaitTimeInMsec )
	  {
	return( MMSYSERR_ERROR );
	  }
	}
  }
  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: FixMemoryLockup                                         */
/*  Author: Bill Hallahan                                             */
/*  Date: April 7, 1995                                               */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*    This function tests to see if the TTS pipes are near full and   */
/*    the VTM thread is trying to report a buffer back to the         */
/*    application using SendMessage(). If this lockup is detected     */
/*    then the VTM pipe is emptied here.                              */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS             A pointer to a Text-To-Speech handle.         */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    None.                                                           */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

#define  MEMORY_LOCKUP_SLEEP_TIME    20
#define  MEMORY_LOCKUP_COUNT          2

static void FixMemoryLockup( LPTTS_HANDLE_T phTTS )
{
  BOOL bPipesNotChanging;
  UINT uiLockedUpCount;
  UINT uiVtmCount;
  UINT uiPhCount;
  UINT uiLtsCount;
  UINT uiCmdCount;
  UINT uiOldVtmCount;
  UINT uiOldPhCount;
  UINT uiOldLtsCount;
  UINT uiOldCmdCount;
  /* Added a varaible to get current instance Kernel_Share_Data 
   * and initialize from phTTS structure
   */
  PKSD_T pKsd_t = NULL;

  pKsd_t = phTTS->pKernelShareData;

  /********************************************************************/
  /*  Wait for all the pipes to change.                               */
  /*  If the pipes are not changing then go to sleep                  */
  /********************************************************************/

  OP_SetEvent( phTTS->hSyncEvent );

  uiVtmCount = pipe_count( pKsd_t->vtm_pipe );
  uiPhCount = pipe_count( pKsd_t->ph_pipe );
  uiLtsCount = pipe_count( pKsd_t->lts_pipe );
  uiCmdCount = pipe_count( pKsd_t->cmd_pipe );

  uiOldVtmCount = uiVtmCount;
  uiOldPhCount = uiPhCount;
  uiOldLtsCount = uiLtsCount;
  uiOldCmdCount = uiCmdCount;

  uiLockedUpCount = 0;
  bPipesNotChanging = TRUE;

  if (
		    (uiVtmCount) || (uiPhCount) 
		 || (uiLtsCount) || (uiCmdCount) 
		)
  { 
	while ( bPipesNotChanging )
    {
	OP_Sleep( MEMORY_LOCKUP_SLEEP_TIME );

	uiVtmCount = pipe_count( pKsd_t->vtm_pipe );
	uiPhCount = pipe_count( pKsd_t->ph_pipe );
	uiLtsCount = pipe_count( pKsd_t->lts_pipe );
	uiCmdCount = pipe_count( pKsd_t->cmd_pipe );

	/******************************************************************/
	/*  Are any of the the pipes changing ?                           */
	/******************************************************************/

	if (
		(
		    (uiVtmCount) || (uiPhCount) 
		 || (uiLtsCount) || (uiCmdCount) 
		)
	  &&
		(   ( uiVtmCount == uiOldVtmCount )
	     && ( uiPhCount == uiOldPhCount )
	     && ( uiLtsCount == uiOldLtsCount )
	     && ( uiCmdCount == uiOldCmdCount )
		 )
	   )
	{
	  bPipesNotChanging = TRUE;
	  // tek 29aug96make sure we didn't somehow end up with no place
	  // to go..
	  if((pKsd_t->buffer_pipe != NULL) && (pipe_count( pKsd_t->buffer_pipe) < 2) )
		  TextToSpeechAddBuffer(phTTS, NULL);
	  uiLockedUpCount++;

	  if ( uiLockedUpCount > MEMORY_LOCKUP_COUNT )
	  {
	/**************************************************************/
	/*  Test to see if the vtm thread is blocked by a call to     */
	/*  SendMessage().                                            */
	/**************************************************************/

	OP_ResetEvent( phTTS->hNotEmptyingVtmPipeEvent );

	if ( phTTS->bSendingBuffer )
	{
	  EmptyVtmPipe(phTTS->pKernelShareData);
	}

	OP_SetEvent( phTTS->hNotEmptyingVtmPipeEvent );
	  }

	  uiOldVtmCount = uiVtmCount;
	  uiOldPhCount = uiPhCount;
	  uiOldLtsCount = uiLtsCount;
	  uiOldCmdCount = uiCmdCount;
	}
	else
	{
	  bPipesNotChanging = FALSE;
	}
  }
 } // if pipes not empty

  return;
}

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: WaitForEmptyPipes                                       */
/*  Author: Bill Hallahan                                             */
/*  Date: July 24, 1993                                               */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*    This function blocks until the inter-thread pipe queues in the  */
/*    Text-To-Speech system are empty. If a timeout value is exceeded */
/*    then this function will return an error status value.           */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*    phTTS             A pointer to a Text-To-Speech handle.         */
/*                                                                    */
/*    dwWaitTimeInMsec  A DWORD which contains the amount of time to  */
/*                      wait for all pipes to empty before returning  */
/*                      an error.                                     */
/*                                                                    */
/*    bReset            A boolean which will set the hSyncEvent if    */
/*                      set to TRUE. This would be done by function   */
/*                      TextToSpeechReset() but not by function       */
/*                      TextToSpeechSync().                           */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function returns a value of type MMRESULT.                 */
/*    The value will be zero if the function is successful.           */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

//tek 03sep96 change timeouts

static MMRESULT WaitForEmptyPipes( LPTTS_HANDLE_T phTTS,
				   DWORD dwWaitTimeInMsec,
				   BOOL bReset )
{
  BOOL bPipesNotEmpty;
  UINT uiLockedUpCount;
  UINT uiSyncCount;
  UINT uiVtmCount;
  UINT uiPhCount;
  UINT uiLtsCount;
  UINT uiCmdCount;
  UINT uiOldSyncCount;
  UINT uiOldVtmCount;
  UINT uiOldPhCount;
  UINT uiOldLtsCount;
  UINT uiOldCmdCount;
  DWORD dwTotalTimeInMsec;
  /* Added a varaible to get current instance Kernel_Share_Data 
   * and initialize from phTTS structure
   */
  PKSD_T pKsd_t = NULL;

  pKsd_t = phTTS->pKernelShareData;

  /********************************************************************/
  /*  Wait for all the pipes to empty.                                */
  /*  If the pipes are not empty then sleep for 100 msec. and check   */
  /*  them again.                                                     */
  /********************************************************************/

  dwTotalTimeInMsec = 0;

  uiOldSyncCount = 0xFFFFFFFF;
  uiOldVtmCount = 0xFFFFFFFF;
  uiOldPhCount = 0xFFFFFFFF;
  uiOldLtsCount = 0xFFFFFFFF;
  uiOldCmdCount = 0xFFFFFFFF;
  uiLockedUpCount = 0;
  bPipesNotEmpty = TRUE;

  while ( bPipesNotEmpty )
  {
	bPipesNotEmpty = FALSE;

	if ( bReset )
	  OP_SetEvent( phTTS->hSyncEvent );

	uiSyncCount = pipe_count( pKsd_t->sync_pipe );
	uiVtmCount = pipe_count( pKsd_t->vtm_pipe );
	uiPhCount = pipe_count( pKsd_t->ph_pipe );
	uiLtsCount = pipe_count( pKsd_t->lts_pipe );
	uiCmdCount = pipe_count( pKsd_t->cmd_pipe );

	if  (( uiSyncCount != 0 )
	 || ( uiVtmCount != 0 )
	 || ( uiPhCount != 0 )
	 || ( uiLtsCount != 0 )
	 || ( uiCmdCount != 0 ))
	  bPipesNotEmpty = TRUE;

	/******************************************************************/
	/*  If bPipesNotEmpty is still FALSE here then the pipes are      */
	/*  probably empty. It is possible that there is still data in    */
	/*  the pipes, but that it moved out of a pipe we are about to    */
	/*  check into a pipe we have we just checked. We now check the   */
	/*  pipes in the reverse order.                                   */
	/******************************************************************/

	if ( ! bPipesNotEmpty )
	{
/*
	  kernel_disable(pKsd_t);
*/
	  uiCmdCount = pipe_count( pKsd_t->cmd_pipe );
	  uiLtsCount = pipe_count( pKsd_t->lts_pipe );
	  uiPhCount = pipe_count( pKsd_t->ph_pipe );
	  uiVtmCount = pipe_count( pKsd_t->vtm_pipe );
	  uiSyncCount = pipe_count( pKsd_t->sync_pipe );
/*
	  kernel_enable( pKsd_t, uiDummy );
*/
	  if  (( uiSyncCount != 0 )
	|| ( uiVtmCount != 0 )
	|| ( uiPhCount != 0 )
	|| ( uiLtsCount != 0 )
	|| ( uiCmdCount != 0 ))
	bPipesNotEmpty = TRUE;
	  else
	bPipesNotEmpty = FALSE;
	}

	/******************************************************************/
	/*  Go to sleep for WAIT_PIPE_SLEEP_TIME msec.                    */
	/******************************************************************/

	if ( bPipesNotEmpty )
	{
	  // tek 29aug96make sure we didn't somehow end up with no place
	  // to go.
	  if((pKsd_t->buffer_pipe  != NULL) && (pipe_count( pKsd_t->buffer_pipe) < 1) )
		  TextToSpeechAddBuffer(phTTS, NULL);

	  OP_Sleep( WAIT_PIPE_SLEEP_TIME );

	  dwTotalTimeInMsec += WAIT_PIPE_SLEEP_TIME;

	  if ( dwTotalTimeInMsec > dwWaitTimeInMsec )
	  {
	return( MMSYSERR_ERROR );
	  }
	}

	/******************************************************************/
	/*  If this is a reset then check to see if nothing is happening. */
	/*  If any of the threads block then the pipe state may not       */
	/*  change.                                                       */
	/******************************************************************/

	if  (( bReset )
	  && ( uiSyncCount && (uiSyncCount == uiOldSyncCount) )
	  && ( uiVtmCount && (uiVtmCount == uiOldVtmCount) )
	  && ( uiPhCount && (uiPhCount == uiOldPhCount) )
	  && ( uiLtsCount && (uiLtsCount == uiOldLtsCount) )
	  && ( uiCmdCount && (uiCmdCount == uiOldCmdCount) ))
	{
	  /****************************************************************/
	  /*  Perform an audio reset to immediately stop audio from       */
	  /*  playing and to make sure the VTM thread is not blocked.     */
	  /****************************************************************/

	  if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )
	  {
	PA_Reset( phTTS->pAudioHandle );
	  }

	  uiLockedUpCount++;

	  /****************************************************************/
	  /*  Fix hang when using speech-to-memory. WIH 4/6/95            */
	  /****************************************************************/

	  if ( phTTS->dwOutputState == STATE_OUTPUT_MEMORY )
	  {
	FixMemoryLockup( phTTS );
	  }
	}
	else
	{
	  uiLockedUpCount = 0;
	}

	uiOldSyncCount = uiSyncCount;
	uiOldVtmCount = uiVtmCount;
	uiOldPhCount = uiPhCount;
	uiOldLtsCount = uiLtsCount;
	uiOldCmdCount = uiCmdCount;

	if ( uiLockedUpCount >= WAIT_PIPE_ABORT_COUNT )
	  return( MMSYSERR_ERROR );
  }
  return( MMSYSERR_NOERROR );
}

/**********************************************************************/
/**********************************************************************/
/*  "Play Audio" Callback Routine.                                    */
/**********************************************************************/
/**********************************************************************/

unsigned int PlayAudioCallbackRoutine( HPLAY_AUDIO_T pPlayAudio,
									   ATYPE_T aInstance,
									   ATYPE_T aMessage,
									   ATYPE_T aParam )
{
  // get the dectalk error mesage ID.. 
  UINT uiID_Error_Msg;

  /********************************************************************/
  /*  Get the DECtalk error message.                                  */
  /********************************************************************/
  uiID_Error_Msg = ((LPTTS_HANDLE_T)aInstance)->uiID_Error_Message;
  
  switch ( aMessage )
  {
 
  case PA_PLAY_START:

	Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
					   uiID_Error_Msg,
					   TTS_AUDIO_PLAY_START,
					   MMSYSERR_NOERROR );
	break;

  case PA_PLAY_STOP:

	Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
					   uiID_Error_Msg,
					   TTS_AUDIO_PLAY_STOP,
					   MMSYSERR_NOERROR );
	break;

  case PA_DEVICE_OPEN_FAILURE:

	if (((LPTTS_HANDLE_T)aInstance)->dwDeviceOptions & REPORT_OPEN_ERROR )
	{
	  Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
						 uiID_Error_Msg,
						 ERROR_OPENING_WAVE_OUTPUT_DEVICE,
						 aParam );
	}
	break;

  case PA_WRITE_ERROR:

	Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
					   uiID_Error_Msg,
					   ERROR_IN_AUDIO_WRITE,
					   aParam );
	break;

  case PA_GET_CAPS_ERROR:

	Report_TTS_Status((LPTTS_HANDLE_T)aInstance,
					   uiID_Error_Msg,
					   ERROR_GETTING_DEVICE_CAPABILITIES,
					   aParam );
	break;

  default:

	break;
  }

  return FALSE;
}


/**********************************************************************/
/**********************************************************************/
/*  Function: Report_TTS_Status                                       */
/*  Author: Bill Hallahan                                             */
/*  Date: December 26, 1995                                           */
/**********************************************************************/
/**********************************************************************/

void Report_TTS_Status( LPTTS_HANDLE_T phTTS,
						UINT uiMsg,
						long lParam1,
						long lParam2 )
{
  if (phTTS->DtCallbackRoutine != NULL)
  {
	OP_LockMutex( phTTS->pcsCallback );
	(*phTTS->DtCallbackRoutine)( lParam1,
					 lParam2,
					 phTTS->dwTTSInstanceParameter,
					 uiMsg);
	
	OP_UnlockMutex( phTTS->pcsCallback );
  }

  return;
}

void DrainPipes(LPTTS_HANDLE_T phTTS)
{
 // empty the CMD, LTS and PH pipes..
	SWFlushPipe(phTTS->pKernelShareData->cmd_pipe);
	SWFlushPipe(phTTS->pKernelShareData->lts_pipe);
 	SWFlushPipe(phTTS->pKernelShareData->ph_pipe);

}


unsigned int TextToSpeechVersion(LPSTR* VersionStr)
{
	//removed unsigned form next line 11/12/96 cjl
	static char   DECtalk_Version_String[50];

	sprintf(DECtalk_Version_String,"%s %s",DTALK_STR_VERSION, CUSTR_STR_VERSION);
	if (VersionStr != NULL) *VersionStr = DECtalk_Version_String;
	return (DTALK_MAJ_VERSION << 24) + (DTALK_MIN_VERSION << 16) + (DLL_MAJ_VERSION << 8) + DLL_MIN_VERSION;
}

void TextToSpeechControlPanel(LPTTS_HANDLE_T ttsHandle)
{
#ifdef DTALK50
        if (ttsHandle == NULL)  return;
        CPShow(ttsHandle->CPanelThread);
#else
        /* This function not supported in 4.4 */
#endif
        return;
}

unsigned int TextToSpeechGetLastError(LPTTS_HANDLE_T phTTS) {
        return phTTS->LastError;
}

void TextToSpeechTyping(LPTTS_HANDLE_T phTTS, char key) {
	return;
}

unsigned int TextToSpeechReserved1(unsigned char voice, unsigned char var, unsigned char mode) {
    return FALSE;
}

void TextToSpeechReserved2(void) {
        return;
}

void TextToSpeechReserved3(void) {
        return;
}

DWORD TextToSpeechVersionEx(LPVERSION_INFO *ver) {
        static char DECtalk_Language_String[50];
        static char DECtalk_Version_String[50];

        sprintf(DECtalk_Version_String,"%s %s",DTALK_STR_VERSION, CUSTR_STR_VERSION);
        sprintf(DECtalk_Language_String, "ER: Error");
#ifdef ENGLISH_US
        sprintf(DECtalk_Language_String, "US: American English");
#endif
#ifdef SPANISH
#ifdef LATIN_AMERICAN
        sprintf(DECtalk_Language_String, "LA: Latin American Spanish");
#else
        sprintf(DECtalk_Language_String, "SP: Castillian Spanish");
#endif
#endif
#ifdef GERMAN
        sprintf(DECtalk_Language_String, "GR: German");
#endif
#ifdef FRENCH
        sprintf(DECtalk_Language_String, "FR: French");
#endif
#ifdef SWAHILI
        sprintf(DECtalk_Language_String, "SW: Swahili");
#endif
#ifdef ENGLISH_UK
        sprintf(DECtalk_Language_String, "UK: British English");
#endif

        if ((*ver = malloc(sizeof(VERSION_INFO))) == NULL)      return 0;
        (*ver)->StructSize = sizeof(VERSION_INFO);
        (*ver)->StructVersion = VERSION_STRUCT_VER;
        (*ver)->DLLVersion = (DLL_MAJ_VERSION << 8) + DLL_MIN_VERSION;
        (*ver)->DTalkVersion = (DTALK_DBG_VERSION << 15) + (DTALK_MAJ_VERSION << 8) + DTALK_MIN_VERSION;
        (*ver)->VerString = DECtalk_Version_String;
        (*ver)->Language = DECtalk_Language_String;
        (*ver)->Features = TextToSpeechGetFeatures();
        return (sizeof(VERSION_INFO));
}


/* ML add-ons (Always returns failures) */
unsigned int TextToSpeechStartLang(char *lang) {
        return TTS_NOT_SUPPORTED;
}

BOOL TextToSpeechSelectLang(LPTTS_HANDLE_T tts, unsigned int id) {
        return FALSE;
}

BOOL TextToSpeechCloseLang(char *lang) {
        return FALSE;
}

MMRESULT TextToSpeechGetFeatures(void) {
        unsigned long int feats;

#ifdef ACCESS32
        feats = TTS_FEATS_TYPINGMODE;
#else
        feats = 0;
#endif
        return feats;
}


