	TITLE	D:\work\Product\dapi\src\Cmd\cmd_wav.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_wMulawTable
_DATA	SEGMENT
_wMulawTable DW	08284H
	DW	08684H
	DW	08a84H
	DW	08e84H
	DW	09284H
	DW	09684H
	DW	09a84H
	DW	09e84H
	DW	0a284H
	DW	0a684H
	DW	0aa84H
	DW	0ae84H
	DW	0b284H
	DW	0b684H
	DW	0ba84H
	DW	0be84H
	DW	0c184H
	DW	0c384H
	DW	0c584H
	DW	0c784H
	DW	0c984H
	DW	0cb84H
	DW	0cd84H
	DW	0cf84H
	DW	0d184H
	DW	0d384H
	DW	0d584H
	DW	0d784H
	DW	0d984H
	DW	0db84H
	DW	0dd84H
	DW	0df84H
	DW	0e104H
	DW	0e204H
	DW	0e304H
	DW	0e404H
	DW	0e504H
	DW	0e604H
	DW	0e704H
	DW	0e804H
	DW	0e904H
	DW	0ea04H
	DW	0eb04H
	DW	0ec04H
	DW	0ed04H
	DW	0ee04H
	DW	0ef04H
	DW	0f004H
	DW	0f0c4H
	DW	0f144H
	DW	0f1c4H
	DW	0f244H
	DW	0f2c4H
	DW	0f344H
	DW	0f3c4H
	DW	0f444H
	DW	0f4c4H
	DW	0f544H
	DW	0f5c4H
	DW	0f644H
	DW	0f6c4H
	DW	0f744H
	DW	0f7c4H
	DW	0f844H
	DW	0f8a4H
	DW	0f8e4H
	DW	0f924H
	DW	0f964H
	DW	0f9a4H
	DW	0f9e4H
	DW	0fa24H
	DW	0fa64H
	DW	0faa4H
	DW	0fae4H
	DW	0fb24H
	DW	0fb64H
	DW	0fba4H
	DW	0fbe4H
	DW	0fc24H
	DW	0fc64H
	DW	0fc94H
	DW	0fcb4H
	DW	0fcd4H
	DW	0fcf4H
	DW	0fd14H
	DW	0fd34H
	DW	0fd54H
	DW	0fd74H
	DW	0fd94H
	DW	0fdb4H
	DW	0fdd4H
	DW	0fdf4H
	DW	0fe14H
	DW	0fe34H
	DW	0fe54H
	DW	0fe74H
	DW	0fe8cH
	DW	0fe9cH
	DW	0feacH
	DW	0febcH
	DW	0feccH
	DW	0fedcH
	DW	0feecH
	DW	0fefcH
	DW	0ff0cH
	DW	0ff1cH
	DW	0ff2cH
	DW	0ff3cH
	DW	0ff4cH
	DW	0ff5cH
	DW	0ff6cH
	DW	0ff7cH
	DW	0ff88H
	DW	0ff90H
	DW	0ff98H
	DW	0ffa0H
	DW	0ffa8H
	DW	0ffb0H
	DW	0ffb8H
	DW	0ffc0H
	DW	0ffc8H
	DW	0ffd0H
	DW	0ffd8H
	DW	0ffe0H
	DW	0ffe8H
	DW	0fff0H
	DW	0fff8H
	DW	00H
	DW	07d7cH
	DW	0797cH
	DW	0757cH
	DW	0717cH
	DW	06d7cH
	DW	0697cH
	DW	0657cH
	DW	0617cH
	DW	05d7cH
	DW	0597cH
	DW	0557cH
	DW	0517cH
	DW	04d7cH
	DW	0497cH
	DW	0457cH
	DW	0417cH
	DW	03e7cH
	DW	03c7cH
	DW	03a7cH
	DW	0387cH
	DW	0367cH
	DW	0347cH
	DW	0327cH
	DW	0307cH
	DW	02e7cH
	DW	02c7cH
	DW	02a7cH
	DW	0287cH
	DW	0267cH
	DW	0247cH
	DW	0227cH
	DW	0207cH
	DW	01efcH
	DW	01dfcH
	DW	01cfcH
	DW	01bfcH
	DW	01afcH
	DW	019fcH
	DW	018fcH
	DW	017fcH
	DW	016fcH
	DW	015fcH
	DW	014fcH
	DW	013fcH
	DW	012fcH
	DW	011fcH
	DW	010fcH
	DW	0ffcH
	DW	0f3cH
	DW	0ebcH
	DW	0e3cH
	DW	0dbcH
	DW	0d3cH
	DW	0cbcH
	DW	0c3cH
	DW	0bbcH
	DW	0b3cH
	DW	0abcH
	DW	0a3cH
	DW	09bcH
	DW	093cH
	DW	08bcH
	DW	083cH
	DW	07bcH
	DW	075cH
	DW	071cH
	DW	06dcH
	DW	069cH
	DW	065cH
	DW	061cH
	DW	05dcH
	DW	059cH
	DW	055cH
	DW	051cH
	DW	04dcH
	DW	049cH
	DW	045cH
	DW	041cH
	DW	03dcH
	DW	039cH
	DW	036cH
	DW	034cH
	DW	032cH
	DW	030cH
	DW	02ecH
	DW	02ccH
	DW	02acH
	DW	028cH
	DW	026cH
	DW	024cH
	DW	022cH
	DW	020cH
	DW	01ecH
	DW	01ccH
	DW	01acH
	DW	018cH
	DW	0174H
	DW	0164H
	DW	0154H
	DW	0144H
	DW	0134H
	DW	0124H
	DW	0114H
	DW	0104H
	DW	0f4H
	DW	0e4H
	DW	0d4H
	DW	0c4H
	DW	0b4H
	DW	0a4H
	DW	094H
	DW	084H
	DW	078H
	DW	070H
	DW	068H
	DW	060H
	DW	058H
	DW	050H
	DW	048H
	DW	040H
	DW	038H
	DW	030H
	DW	028H
	DW	020H
	DW	018H
	DW	010H
	DW	08H
	DW	00H
_DATA	ENDS
PUBLIC	_cm_cmd_play
EXTRN	_TextToSpeechErrorHandler:NEAR
EXTRN	_WaitForLtsFlush:NEAR
EXTRN	__imp__free:NEAR
EXTRN	__imp__malloc:NEAR
EXTRN	__imp__Sleep@4:NEAR
EXTRN	_cm_cmd_sync:NEAR
EXTRN	_PA_Queue:NEAR
EXTRN	_PA_Reset:NEAR
EXTRN	_PA_GetFormat:NEAR
EXTRN	_PA_SetFormat:NEAR
EXTRN	_PA_WaitForPlayToComplete:NEAR
EXTRN	__imp__mmioClose@8:NEAR
EXTRN	__imp__mmioRead@12:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_iError$ = -12
_uiBlockAlign$ = -32
_uiReadSize$ = -8
_bMulawFlag$ = -24
_bNotDone$ = -20
_pWaveFormat$ = 8
_pOldWaveFormat$ = -4
_hMmio$ = -16
_pKsd_t$ = -28
_pCmd_t$ = -16
_cm_cmd_play PROC NEAR

; 160  : {

  00000	83 ec 20	 sub	 esp, 32			; 00000020H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi

; 161  : 
; 162  : #ifndef UNDER_CE
; 163  : 
; 164  :   int i;
; 165  :   int iLength;
; 166  :   int iError;
; 167  :   unsigned int uiBlockAlign;
; 168  :   short * pWord;
; 169  :   unsigned char * pByte;
; 170  :   char * lpData;
; 171  :   UINT uiReadSize;
; 172  :   BOOL bMulawFlag;
; 173  :   BOOL bNotDone;
; 174  :   MMRESULT mmStatus;
; 175  :   LPWAVEFORMATEX pWaveFormat;
; 176  :   LPWAVEFORMATEX pOldWaveFormat;
; 177  :   HMMIO hMmio = (int)NULL;
; 178  : #endif
; 179  :   PKSD_T pKsd_t = phTTS->pKernelShareData;

  00006	8b 74 24 30	 mov	 esi, DWORD PTR _phTTS$[esp+40]

; 180  :   PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 181  :   /*
; 182  :   LPTTS_HANDLE_T phTTS;
; 183  :   */
; 184  : 
; 185  :   /********************************************************************/
; 186  :   /*  Initialize local variables.                                     */
; 187  :   /********************************************************************/
; 188  : #ifdef UNDER_CE
; 189  :     wchar_t string[128]={0x00};
; 190  : 	wchar_t instring[128]={0x00};
; 191  : #endif
; 192  : 
; 193  : #ifndef UNDER_CE
; 194  :   bMulawFlag = FALSE;

  0000a	33 ed		 xor	 ebp, ebp
  0000c	57		 push	 edi
  0000d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00010	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00013	89 44 24 14	 mov	 DWORD PTR _pKsd_t$[esp+48], eax

; 195  :   pWaveFormat = NULL;
; 196  :   pOldWaveFormat = NULL;
; 197  : #endif
; 198  : 
; 199  :   /********************************************************************/
; 200  :   /*  Get the text to speech handle.                                  */
; 201  :   /********************************************************************/
; 202  : 
; 203  :   /*phTTS = TextToSpeechGetHandle();*/
; 204  : 
; 205  :   /********************************************************************/
; 206  :   /*  If using the audio device in speech to audio device mode then   */
; 207  :   /*  play the wave file.                                             */
; 208  :   /********************************************************************/
; 209  :   /********************************************************************/
; 210  :   /*  Wait for audio to complete.  if WINDOWS CE use  sndPlaySound()  */
; 211  :   /********************************************************************/
; 212  : 
; 213  : #ifdef UNDER_CE
; 214  : 
; 215  : 	WaitForLtsFlush( phTTS, 0xFFFFFFFF );
; 216  : 	PA_WaitForPlayToComplete( phTTS->pAudioHandle );
; 217  : 
; 218  : 
; 219  : 	MultiByteToWideChar(CP_ACP,0,pCmd_t->pString[0],strlen(pCmd_t->pString[0]),&string,sizeof(string));
; 220  : 
; 221  : 
; 222  : 	wcscpy(instring,TEXT("\\"));
; 223  : 	wcscat(instring,string);
; 224  : 
; 225  : 
; 226  : 	if (sndPlaySound(&instring,SND_ASYNC))
; 227  : 	{
; 228  : 	return(CMD_success);
; 229  : 	}
; 230  : 	else
; 231  : 	{
; 232  : 	return(CMD_unable_to_open_file);
; 233  : 	}
; 234  : #endif
; 235  : 
; 236  : 
; 237  : #ifndef UNDER_CE
; 238  : 
; 239  :   if ( phTTS->dwOutputState == STATE_OUTPUT_AUDIO )

  00017	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  0001d	3b c5		 cmp	 eax, ebp
  0001f	89 4c 24 20	 mov	 DWORD PTR _pCmd_t$[esp+48], ecx
  00023	89 6c 24 18	 mov	 DWORD PTR _bMulawFlag$[esp+48], ebp
  00027	89 6c 24 34	 mov	 DWORD PTR _pWaveFormat$[esp+44], ebp
  0002b	0f 85 3f 03 00
	00		 jne	 $L71312

; 240  :   {
; 241  : 	/******************************************************************/
; 242  : 	/*  Wait for all previously queued text to be processed.          */
; 243  : 	/******************************************************************/
; 244  : 
; 245  : 	if( cm_cmd_sync(phTTS) == CMD_flushing )

  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 _cm_cmd_sync
  00037	83 c4 04	 add	 esp, 4
  0003a	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0003d	75 23		 jne	 SHORT $L71313

; 246  : 	{
; 247  : /* GL 04/21/1997  add this for OSF build */
; 248  : #ifdef WIN32
; 249  : 	mmioClose( hMmio, 0 );

  0003f	55		 push	 ebp
  00040	55		 push	 ebp
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mmioClose@8

; 250  : #endif
; 251  : #ifdef __osf__ 
; 252  : 	  DTK_MMIO_CLOSE( hMmio, 0 );
; 253  : #endif
; 254  : #ifdef __linux__ 
; 255  : 	  DTK_MMIO_CLOSE( hMmio, 0 );
; 256  : #endif
; 257  : 	  free( pWaveFormat );

  00047	8b 54 24 34	 mov	 edx, DWORD PTR _pWaveFormat$[esp+44]
  0004b	52		 push	 edx
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00052	83 c4 04	 add	 esp, 4

; 258  : 	  return(CMD_flushing);

  00055	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5d		 pop	 ebp
  0005d	5b		 pop	 ebx

; 610  : 
; 611  : #endif
; 612  : }

  0005e	83 c4 20	 add	 esp, 32			; 00000020H
  00061	c3		 ret	 0
$L71313:

; 259  : 	}
; 260  : 
; 261  : 	/******************************************************************/
; 262  : 	/*  Allocate the audio play buffer.                               */
; 263  : 	/*  Make it twice as big as the read to leave room to convert     */
; 264  : 	/*  8 bit mulaw samples to 16 bit samples.                        */
; 265  : 	/******************************************************************/
; 266  : 
; 267  : 	lpData = (char *)malloc( 2 * PLAY_READ_BUFFER_SIZE * sizeof(char));

  00062	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__malloc
  00068	68 00 40 00 00	 push	 16384			; 00004000H
  0006d	ff d7		 call	 edi
  0006f	8b d8		 mov	 ebx, eax
  00071	83 c4 04	 add	 esp, 4

; 268  : 
; 269  : 	if ( lpData == NULL )

  00074	3b dd		 cmp	 ebx, ebp
  00076	75 19		 jne	 SHORT $L71317

; 270  : 	{
; 271  : 	  TextToSpeechErrorHandler( phTTS,
; 272  : 								0,
; 273  : 								MMSYSERR_NOMEM );

  00078	6a 07		 push	 7
  0007a	55		 push	 ebp
  0007b	56		 push	 esi
  0007c	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH

; 274  : 	  return( CMD_out_of_memory );

  00084	b8 06 00 00 00	 mov	 eax, 6
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5d		 pop	 ebp
  0008c	5b		 pop	 ebx

; 610  : 
; 611  : #endif
; 612  : }

  0008d	83 c4 20	 add	 esp, 32			; 00000020H
  00090	c3		 ret	 0
$L71317:

; 275  : 	}
; 276  : 
; 277  : 	/******************************************************************/
; 278  : 	/*  Wait for audio to complete.                                   */
; 279  : 	/******************************************************************/
; 280  : 
; 281  : 	WaitForLtsFlush( phTTS, 0xFFFFFFFF );

  00091	6a ff		 push	 -1
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 _WaitForLtsFlush

; 282  : 	PA_WaitForPlayToComplete( phTTS->pAudioHandle );

  00099	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _PA_WaitForPlayToComplete

; 283  : 	/******************************************************************/
; 284  : 	/*  Allocate a WAVEFORMATEX structure used to save the current    */
; 285  : 	/*  audio state. The size of this structure would normally be     */
; 286  : 	/*  the size of the maximum WAVEFORMATEX structure supported      */
; 287  : 	/*  by the audio compression manager. This size may be determined */
; 288  : 	/*  by a call to the acmMetric() function. This is not necessary  */
; 289  : 	/*  here because we know that DECtalk is using WAVE_FORMAT_PCM.   */
; 290  : 	/******************************************************************/
; 291  : 
; 292  : 	pOldWaveFormat = (LPWAVEFORMATEX)malloc(sizeof(WAVEFORMATEX));

  000a5	6a 12		 push	 18			; 00000012H
  000a7	ff d7		 call	 edi
  000a9	8b e8		 mov	 ebp, eax
  000ab	83 c4 10	 add	 esp, 16			; 00000010H

; 293  : 
; 294  : 	if ( pOldWaveFormat == NULL )

  000ae	85 ed		 test	 ebp, ebp
  000b0	89 6c 24 2c	 mov	 DWORD PTR _pOldWaveFormat$[esp+48], ebp
  000b4	75 29		 jne	 SHORT $L71321

; 295  : 	{
; 296  : 	  free( pWaveFormat );

  000b6	8b 4c 24 34	 mov	 ecx, DWORD PTR _pWaveFormat$[esp+44]
  000ba	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
  000c0	51		 push	 ecx
  000c1	ff d7		 call	 edi

; 297  : 	  free( lpData );

  000c3	53		 push	 ebx
  000c4	ff d7		 call	 edi

; 298  : 	  TextToSpeechErrorHandler( phTTS,
; 299  : 								0,
; 300  : 								MMSYSERR_NOMEM );

  000c6	6a 07		 push	 7
  000c8	55		 push	 ebp
  000c9	56		 push	 esi
  000ca	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  000cf	83 c4 14	 add	 esp, 20			; 00000014H

; 301  : 	  return( CMD_out_of_memory );

  000d2	b8 06 00 00 00	 mov	 eax, 6
  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	5d		 pop	 ebp
  000da	5b		 pop	 ebx

; 610  : 
; 611  : #endif
; 612  : }

  000db	83 c4 20	 add	 esp, 32			; 00000020H
  000de	c3		 ret	 0
$L71321:

; 302  : 	}
; 303  : 
; 304  : 	/******************************************************************/
; 305  : 	/*  Open the wave file.                                           */
; 306  : 	/*  The pWaveFormat structure is allocated and filled in by the   */
; 307  : 	/*  wave_file_open() function. It is freed at the end of          */
; 308  : 	/*  the cmd_wav() function (this function).                       */
; 309  : 	/******************************************************************/
; 310  : 
; 311  : 	hMmio = wave_file_open( pCmd_t->pString[0], &pWaveFormat, &iError, phTTS );

  000df	8b 4c 24 20	 mov	 ecx, DWORD PTR _pCmd_t$[esp+48]
  000e3	8d 54 24 24	 lea	 edx, DWORD PTR _iError$[esp+48]
  000e7	56		 push	 esi
  000e8	52		 push	 edx
  000e9	8b 91 80 02 00
	00		 mov	 edx, DWORD PTR [ecx+640]
  000ef	8d 44 24 3c	 lea	 eax, DWORD PTR _pWaveFormat$[esp+52]
  000f3	50		 push	 eax
  000f4	52		 push	 edx
  000f5	e8 00 00 00 00	 call	 _wave_file_open
  000fa	8b f8		 mov	 edi, eax
  000fc	83 c4 10	 add	 esp, 16			; 00000010H

; 312  : 
; 313  : #ifndef ERRORCHECK
; 314  : 	if ( hMmio == NULL )

  000ff	85 ff		 test	 edi, edi
  00101	89 7c 24 20	 mov	 DWORD PTR _hMmio$[esp+48], edi
  00105	75 22		 jne	 SHORT $L71323

; 315  : 	{
; 316  : 	  free( pOldWaveFormat );

  00107	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__free
  0010d	55		 push	 ebp
  0010e	ff d6		 call	 esi

; 317  : 	  free( pWaveFormat );

  00110	8b 44 24 38	 mov	 eax, DWORD PTR _pWaveFormat$[esp+48]
  00114	50		 push	 eax
  00115	ff d6		 call	 esi

; 318  : 		  free( lpData );

  00117	53		 push	 ebx
  00118	ff d6		 call	 esi

; 319  : 	  return( iError );

  0011a	8b 44 24 30	 mov	 eax, DWORD PTR _iError$[esp+60]
  0011e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00121	5f		 pop	 edi
  00122	5e		 pop	 esi
  00123	5d		 pop	 ebp
  00124	5b		 pop	 ebx

; 610  : 
; 611  : #endif
; 612  : }

  00125	83 c4 20	 add	 esp, 32			; 00000020H
  00128	c3		 ret	 0
$L71323:

; 320  : 	}
; 321  : #endif
; 322  : 
; 323  : 	/******************************************************************/
; 324  : 	/*  If the audio sample format is mulaw then open the device for  */
; 325  : 	/*  16 bit PCM and convert the mulaw data to 16 bit data.         */
; 326  : 	/******************************************************************/
; 327  : 
; 328  : 	if ( pWaveFormat->wFormatTag == WAVE_FORMAT_MULAW )

  00129	8b 44 24 34	 mov	 eax, DWORD PTR _pWaveFormat$[esp+44]
  0012d	66 83 38 07	 cmp	 WORD PTR [eax], 7
  00131	75 2b		 jne	 SHORT $L71324

; 329  : 	{
; 330  : 	  bMulawFlag = TRUE;
; 331  : 	  pWaveFormat->wFormatTag = WAVE_FORMAT_PCM;

  00133	66 c7 00 01 00	 mov	 WORD PTR [eax], 1

; 332  : 	  pWaveFormat->nAvgBytesPerSec = pWaveFormat->nAvgBytesPerSec << 1;

  00138	8b 44 24 34	 mov	 eax, DWORD PTR _pWaveFormat$[esp+44]
  0013c	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _bMulawFlag$[esp+48], 1
  00144	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00147	d1 e2		 shl	 edx, 1
  00149	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 333  : 	  pWaveFormat->nBlockAlign = pWaveFormat->nBlockAlign << 1;

  0014c	8b 44 24 34	 mov	 eax, DWORD PTR _pWaveFormat$[esp+44]
  00150	66 d1 60 0c	 shl	 WORD PTR [eax+12], 1

; 334  : 	  pWaveFormat->wBitsPerSample = 16;

  00154	8b 4c 24 34	 mov	 ecx, DWORD PTR _pWaveFormat$[esp+44]
  00158	66 c7 41 0e 10
	00		 mov	 WORD PTR [ecx+14], 16	; 00000010H
$L71324:

; 335  : 	}
; 336  : 
; 337  : 	/******************************************************************/
; 338  : 	/*  Set up the audio device for the current wave data.            */
; 339  : 	/*  First get the current audio parameters.                       */
; 340  : 	/******************************************************************/
; 341  : 	
; 342  : 	PA_GetFormat( phTTS->pAudioHandle, pOldWaveFormat );

  0015e	8b 96 d8 00 00
	00		 mov	 edx, DWORD PTR [esi+216]
  00164	55		 push	 ebp
  00165	52		 push	 edx
  00166	e8 00 00 00 00	 call	 _PA_GetFormat

; 343  : 	
; 344  : 	/******************************************************************/
; 345  : 	/*  Set the audio parameters.                                     */
; 346  : 	/*  If OWN_AUDIO_DEVICE is specified then the format of the wave  */
; 347  : 	/*  file data must match the format that DECtalk is currently     */
; 348  : 	/*  using. The SetAudioParams() function performs this test       */
; 349  : 	/*  automatically and returns an error status in this case.       */
; 350  : 	/******************************************************************/
; 351  : 	
; 352  : 	while (( mmStatus = PA_SetFormat( phTTS->pAudioHandle,
; 353  : 										pWaveFormat ))
; 354  : 	  == MMSYSERR_ALLOCATED )

  0016b	8b 44 24 3c	 mov	 eax, DWORD PTR _pWaveFormat$[esp+52]
  0016f	8b 8e d8 00 00
	00		 mov	 ecx, DWORD PTR [esi+216]
  00175	50		 push	 eax
  00176	51		 push	 ecx
  00177	e8 00 00 00 00	 call	 _PA_SetFormat
  0017c	83 c4 10	 add	 esp, 16			; 00000010H
  0017f	83 f8 04	 cmp	 eax, 4
  00182	75 24		 jne	 SHORT $L71327
$L71326:

; 355  : 
; 356  : 	{
; 357  : /* GL 04/21/1997  add this for OSF build */
; 358  : #ifdef WIN32
; 359  : 	  Sleep( SET_AUDIO_PARAMS_SLEEP_TIME );

  00184	68 c8 00 00 00	 push	 200			; 000000c8H
  00189	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  0018f	8b 54 24 34	 mov	 edx, DWORD PTR _pWaveFormat$[esp+44]
  00193	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  00199	52		 push	 edx
  0019a	50		 push	 eax
  0019b	e8 00 00 00 00	 call	 _PA_SetFormat
  001a0	83 c4 08	 add	 esp, 8
  001a3	83 f8 04	 cmp	 eax, 4
  001a6	74 dc		 je	 SHORT $L71326
$L71327:

; 360  : #endif
; 361  : #ifdef __osf__
; 362  : 	  OP_Sleep( SET_AUDIO_PARAMS_SLEEP_TIME );
; 363  : #endif
; 364  : #ifdef __linux__
; 365  : 	  OP_Sleep( SET_AUDIO_PARAMS_SLEEP_TIME );
; 366  : #endif
; 367  : 	}
; 368  : 	
; 369  : 	if ( mmStatus )

  001a8	85 c0		 test	 eax, eax
  001aa	74 19		 je	 SHORT $L71328

; 370  : 	{
; 371  : 	  /****************************************************************/
; 372  : 	  /*  An error occured while setting the audio parameters.        */
; 373  : 	  /*  Shutdown and exit with error status.                        */
; 374  : 	  /****************************************************************/
; 375  : 
; 376  : /* GL 04/21/1997  add this for OSF build */
; 377  : #ifdef WIN32
; 378  : 	  mmioClose( hMmio, 0 );

  001ac	6a 00		 push	 0
  001ae	57		 push	 edi
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mmioClose@8

; 379  : #endif
; 380  : #ifdef __osf__
; 381  : 	  DTK_MMIO_CLOSE( hMmio, 0 );
; 382  : #endif
; 383  : #ifdef __linux__
; 384  : 	  DTK_MMIO_CLOSE( hMmio, 0 );
; 385  : #endif
; 386  : 	  free( pOldWaveFormat );

  001b5	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
  001bb	55		 push	 ebp
  001bc	ff d7		 call	 edi

; 387  : 	  free( pWaveFormat );

  001be	8b 4c 24 38	 mov	 ecx, DWORD PTR _pWaveFormat$[esp+48]
  001c2	51		 push	 ecx

; 388  : 	  free( lpData );
; 389  : 
; 390  : 	  /****************************************************************/
; 391  : 	  /*  Report that the audio format cannot be supported.           */
; 392  : 	  /****************************************************************/
; 393  : 
; 394  : 	  TextToSpeechErrorHandler( phTTS,
; 395  : 								ERROR_UNSUPPORTED_WAVE_AUDIO_FORMAT,
; 396  : 								MMSYSERR_ERROR );
; 397  : 	  return( CMD_unsupported_audio_format );

  001c3	eb 37		 jmp	 SHORT $L71454
$L71328:

; 398  : 	}
; 399  : 
; 400  : 	/******************************************************************/
; 401  : 	/*  Queue blocks that are a multiple of the block alignment.      */
; 402  : 	/******************************************************************/
; 403  : 
; 404  : 	uiReadSize = PLAY_READ_BUFFER_SIZE;
; 405  : 
; 406  : 	if ( pWaveFormat->nBlockAlign != 0 )

  001c5	8b 54 24 34	 mov	 edx, DWORD PTR _pWaveFormat$[esp+44]
  001c9	66 8b 42 0c	 mov	 ax, WORD PTR [edx+12]
  001cd	66 85 c0	 test	 ax, ax
  001d0	74 49		 je	 SHORT $L71329

; 407  : 	{
; 408  : 	  uiBlockAlign = pWaveFormat->nBlockAlign;

  001d2	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001d7	8b c8		 mov	 ecx, eax

; 413  : 	}
; 414  : 
; 415  : 	/******************************************************************/
; 416  : 	/*  If the block alignment is too large then exit.                */
; 417  : 	/******************************************************************/
; 418  : 
; 419  : 	if ( uiBlockAlign > uiReadSize )

  001d9	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H
  001df	89 4c 24 10	 mov	 DWORD PTR _uiBlockAlign$[esp+48], ecx
  001e3	76 42		 jbe	 SHORT $L71331

; 420  : 	{
; 421  : 	  /****************************************************************/
; 422  : 	  /*  An error occured while setting the audio parameters.        */
; 423  : 	  /*  Shutdown and exit with error status.                        */
; 424  : 	  /****************************************************************/
; 425  : 
; 426  : /* GL 04/21/1997  add this for OSF build */
; 427  : #ifdef WIN32
; 428  : 	  mmioClose( hMmio, 0 );

  001e5	6a 00		 push	 0
  001e7	57		 push	 edi
  001e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mmioClose@8

; 429  : #endif
; 430  : #ifdef __osf__
; 431  : 	  DTK_MMIO_CLOSE( hMmio, 0 );
; 432  : #endif
; 433  : #ifdef __linux__
; 434  : 	  DTK_MMIO_CLOSE( hMmio, 0 );
; 435  : #endif
; 436  : 	  free( pOldWaveFormat );

  001ee	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
  001f4	55		 push	 ebp
  001f5	ff d7		 call	 edi

; 437  : 	  free( pWaveFormat );

  001f7	8b 44 24 38	 mov	 eax, DWORD PTR _pWaveFormat$[esp+48]
  001fb	50		 push	 eax
$L71454:
  001fc	ff d7		 call	 edi

; 438  : 	  free( lpData );

  001fe	53		 push	 ebx
  001ff	ff d7		 call	 edi

; 439  : 
; 440  : 	  /****************************************************************/
; 441  : 	  /*  Report that the audio format cannot be supported.           */
; 442  : 	  /****************************************************************/
; 443  : 
; 444  : 	  TextToSpeechErrorHandler( phTTS,
; 445  : 								ERROR_UNSUPPORTED_WAVE_AUDIO_FORMAT,
; 446  : 								MMSYSERR_ERROR );

  00201	6a 01		 push	 1
  00203	6a 0a		 push	 10			; 0000000aH
  00205	56		 push	 esi
  00206	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  0020b	83 c4 18	 add	 esp, 24			; 00000018H

; 447  : 	  return( CMD_unsupported_audio_format );

  0020e	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00213	5f		 pop	 edi
  00214	5e		 pop	 esi
  00215	5d		 pop	 ebp
  00216	5b		 pop	 ebx

; 610  : 
; 611  : #endif
; 612  : }

  00217	83 c4 20	 add	 esp, 32			; 00000020H
  0021a	c3		 ret	 0
$L71329:

; 409  : 	}
; 410  : 	else
; 411  : 	{
; 412  : 	  uiBlockAlign = 1;

  0021b	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _uiBlockAlign$[esp+48], 1

; 413  : 	}
; 414  : 
; 415  : 	/******************************************************************/
; 416  : 	/*  If the block alignment is too large then exit.                */
; 417  : 	/******************************************************************/
; 418  : 
; 419  : 	if ( uiBlockAlign > uiReadSize )

  00223	8b 4c 24 10	 mov	 ecx, DWORD PTR _uiBlockAlign$[esp+48]
$L71331:

; 448  : 	}
; 449  : 	
; 450  : 	uiReadSize = uiReadSize / uiBlockAlign;

  00227	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H
  0022c	33 d2		 xor	 edx, edx
  0022e	f7 f1		 div	 ecx

; 451  : 	uiReadSize = uiReadSize * uiBlockAlign;
; 452  : 
; 453  : 	/******************************************************************/
; 454  : 	/*  Loop and play all the wave data.                              */
; 455  : 	/******************************************************************/
; 456  : 
; 457  : 	bNotDone = TRUE;

  00230	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _bNotDone$[esp+48], 1
  00238	8b e8		 mov	 ebp, eax
  0023a	0f af e9	 imul	 ebp, ecx
  0023d	89 6c 24 28	 mov	 DWORD PTR _uiReadSize$[esp+48], ebp
$L71333:

; 460  : 	{
; 461  : 	  /****************************************************************/
; 462  : 	  /*  Read in a buffer of audio samples.                          */
; 463  : 	  /****************************************************************/
; 464  : 
; 465  : /* GL 04/21/1997  add this for OSF build */
; 466  : #ifdef WIN32
; 467  : 	  iLength = mmioRead( hMmio, lpData, uiReadSize );

  00241	8b 4c 24 20	 mov	 ecx, DWORD PTR _hMmio$[esp+48]
  00245	55		 push	 ebp
  00246	53		 push	 ebx
  00247	51		 push	 ecx
  00248	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mmioRead@12

; 468  : #endif
; 469  : #if defined (__osf__) || defined (__linux__)
; 470  : 	  iLength = DTK_MMIO_READ( hMmio, lpData, (LONG)uiReadSize );
; 471  : #endif
; 472  : 	  /****************************************************************/
; 473  : 	  /*  If End Of File then clear the bNotDone flag.                */
; 474  : 	  /****************************************************************/
; 475  : 
; 476  : 	  if (( iLength != (int)uiReadSize ) || ( pKsd_t->halting ))

  0024e	3b c5		 cmp	 eax, ebp
  00250	75 0e		 jne	 SHORT $L71337
  00252	8b 54 24 14	 mov	 edx, DWORD PTR _pKsd_t$[esp+48]
  00256	8b 8a 34 03 00
	00		 mov	 ecx, DWORD PTR [edx+820]
  0025c	85 c9		 test	 ecx, ecx
  0025e	74 13		 je	 SHORT $L71336
$L71337:

; 477  : 	  {
; 478  : 		bNotDone = FALSE;
; 479  : 
; 480  : 		/**************************************************************/
; 481  : 		/*  Queue blocks that are a multiple of the block alignment.  */
; 482  : 		/*  Discard any extra audio samples on the last block.        */
; 483  : 		/**************************************************************/
; 484  : 
; 485  : 		iLength = iLength / uiBlockAlign;

  00260	8b 4c 24 10	 mov	 ecx, DWORD PTR _uiBlockAlign$[esp+48]
  00264	33 d2		 xor	 edx, edx
  00266	f7 f1		 div	 ecx
  00268	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _bNotDone$[esp+48], 0

; 486  : 		iLength = iLength * uiBlockAlign;

  00270	0f af c1	 imul	 eax, ecx
$L71336:

; 487  : 	  }
; 488  : 
; 489  : 	  /****************************************************************/
; 490  : 	  /*  Play any data that was read.                                */
; 491  : 	  /****************************************************************/
; 492  : 
; 493  : 	  if (( iLength > 0 ) && ( ! pKsd_t->halting ))

  00273	85 c0		 test	 eax, eax
  00275	7e 54		 jle	 SHORT $L71338
  00277	8b 4c 24 14	 mov	 ecx, DWORD PTR _pKsd_t$[esp+48]
  0027b	8b 91 34 03 00
	00		 mov	 edx, DWORD PTR [ecx+820]
  00281	85 d2		 test	 edx, edx
  00283	75 46		 jne	 SHORT $L71338

; 494  : 	  {
; 495  : 		/**************************************************************/
; 496  : 		/*  If necessary, convert mulaw data to 16 bit samples.       */
; 497  : 		/**************************************************************/
; 498  : 
; 499  : 		if ( bMulawFlag )

  00285	8b 4c 24 18	 mov	 ecx, DWORD PTR _bMulawFlag$[esp+48]
  00289	85 c9		 test	 ecx, ecx
  0028b	74 2b		 je	 SHORT $L71339

; 503  : 		  pByte = lpData;
; 504  : 		  pByte += ( iLength - 1 );
; 505  : 
; 506  : 		  for ( i = 0; i < iLength; i++ )

  0028d	85 c0		 test	 eax, eax
  0028f	8d 4c 43 fe	 lea	 ecx, DWORD PTR [ebx+eax*2-2]
  00293	8d 7c 18 ff	 lea	 edi, DWORD PTR [eax+ebx-1]
  00297	7e 1d		 jle	 SHORT $L71343

; 500  : 		{
; 501  : 		  pWord = (short *)lpData;
; 502  : 		  pWord += ( iLength - 1 );

  00299	8b e8		 mov	 ebp, eax
$L71341:

; 507  : 		  {
; 508  : 			*pWord-- = wMulawTable[(unsigned int)(*pByte--)];

  0029b	33 d2		 xor	 edx, edx
  0029d	83 e9 02	 sub	 ecx, 2
  002a0	8a 17		 mov	 dl, BYTE PTR [edi]
  002a2	4f		 dec	 edi
  002a3	4d		 dec	 ebp
  002a4	66 8b 14 55 00
	00 00 00	 mov	 dx, WORD PTR _wMulawTable[edx*2]
  002ac	66 89 51 02	 mov	 WORD PTR [ecx+2], dx
  002b0	75 e9		 jne	 SHORT $L71341

; 503  : 		  pByte = lpData;
; 504  : 		  pByte += ( iLength - 1 );
; 505  : 
; 506  : 		  for ( i = 0; i < iLength; i++ )

  002b2	8b 6c 24 28	 mov	 ebp, DWORD PTR _uiReadSize$[esp+48]
$L71343:

; 509  : 		  }
; 510  : 
; 511  : 		  /************************************************************/
; 512  : 		  /*  Double the length since the 8 bit u-law samples have    */
; 513  : 		  /*  been converted to 16 bit samples.                       */
; 514  : 		  /************************************************************/
; 515  : 
; 516  : 		  iLength = iLength << 1;

  002b6	d1 e0		 shl	 eax, 1
$L71339:

; 517  : 		}
; 518  : 
; 519  : 		/**************************************************************/
; 520  : 		/*  Queue the audio samples.                                  */
; 521  : 		/**************************************************************/
; 522  : 
; 523  : 		PA_Queue( phTTS->pAudioHandle, lpData, iLength );

  002b8	50		 push	 eax
  002b9	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  002bf	53		 push	 ebx
  002c0	50		 push	 eax
  002c1	e8 00 00 00 00	 call	 _PA_Queue
  002c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 524  : 	  }
; 525  : 	  else if ( iLength == -1 )

  002c9	eb 05		 jmp	 SHORT $L71346
$L71338:
  002cb	83 f8 ff	 cmp	 eax, -1
  002ce	74 0d		 je	 SHORT $L71450
$L71346:

; 458  : 
; 459  : 	while ( bNotDone )

  002d0	8b 44 24 1c	 mov	 eax, DWORD PTR _bNotDone$[esp+48]
  002d4	85 c0		 test	 eax, eax
  002d6	74 12		 je	 SHORT $L71334
  002d8	e9 64 ff ff ff	 jmp	 $L71333
$L71450:

; 526  : 	  {
; 527  : 		/**************************************************************/
; 528  : 		/*  An error occured while reading the wave file.             */
; 529  : 		/**************************************************************/
; 530  : 
; 531  : 		bNotDone = FALSE;
; 532  : 
; 533  : 		TextToSpeechErrorHandler( phTTS,
; 534  : 								  ERROR_READING_WAVE_FILE,
; 535  : 								  MMSYSERR_ERROR );

  002dd	6a 01		 push	 1
  002df	6a 0b		 push	 11			; 0000000bH
  002e1	56		 push	 esi
  002e2	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  002e7	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71334:

; 536  : 	  }
; 537  : 	}
; 538  : 
; 539  : 	/******************************************************************/
; 540  : 	/*  Close the wave file.                                          */
; 541  : 	/******************************************************************/
; 542  : 
; 543  : /* GL 04/21/1997  add this for OSF build */
; 544  : #ifdef WIN32
; 545  : 	mmioClose( hMmio, 0 );

  002ea	8b 4c 24 20	 mov	 ecx, DWORD PTR _hMmio$[esp+48]
  002ee	6a 00		 push	 0
  002f0	51		 push	 ecx
  002f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mmioClose@8

; 546  : #endif
; 547  : #ifdef __osf__
; 548  : 	DTK_MMIO_CLOSE( hMmio, 0 );
; 549  : #endif
; 550  : #ifdef __linux__
; 551  : 	DTK_MMIO_CLOSE( hMmio, 0 );
; 552  : #endif
; 553  : 	/******************************************************************/
; 554  : 	/*  Wait for audio to complete.                                   */
; 555  : 	/******************************************************************/
; 556  : 	PA_WaitForPlayToComplete( phTTS->pAudioHandle );

  002f7	8b 96 d8 00 00
	00		 mov	 edx, DWORD PTR [esi+216]
  002fd	52		 push	 edx
  002fe	e8 00 00 00 00	 call	 _PA_WaitForPlayToComplete

; 557  : 	/******************************************************************/
; 558  : 	/*  Reset the queued sample count to zero. Note: that Critical    */
; 559  : 	/*  Sections are not necessary here because the VTM and Audio     */
; 560  : 	/*  threads are now blocked.                                      */
; 561  : 	/******************************************************************/
; 562  : 
; 563  : 	phTTS->dwQueuedSampleCount = 0;
; 564  : 
; 565  : 	/******************************************************************/
; 566  : 	/*  Reset the audio subsystem. This is done to return the         */
; 567  : 	/*  audio position base to zero. The position is maintained even  */
; 568  : 	/*  when the audio device is closed and re-opened.                */
; 569  : 	/******************************************************************/
; 570  : 
; 571  : 	PA_Reset( phTTS->pAudioHandle );

  00303	8b 86 d8 00 00
	00		 mov	 eax, DWORD PTR [esi+216]
  00309	c7 86 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+128], 0
  00313	50		 push	 eax
  00314	e8 00 00 00 00	 call	 _PA_Reset

; 572  : 
; 573  : 	/******************************************************************/
; 574  : 	/*  Return the audio system to the default state.                 */
; 575  : 	/*  The only thing that can cause this call to the                */
; 576  : 	/*  SetAudioParams() function to fail is the audio device being   */
; 577  : 	/*  taken by another process. In this case, the Text-To-Speech    */
; 578  : 	/*  system will wait until the audio device is free, before       */
; 579  : 	/*  returning because the correct number of channels and the      */
; 580  : 	/*  correct sample rate MUST be set here.                         */
; 581  : 	/******************************************************************/
; 582  : 	
; 583  : 	while ( PA_SetFormat( phTTS->pAudioHandle, pOldWaveFormat ))

  00319	8b 7c 24 34	 mov	 edi, DWORD PTR _pOldWaveFormat$[esp+56]
  0031d	8b 8e d8 00 00
	00		 mov	 ecx, DWORD PTR [esi+216]
  00323	57		 push	 edi
  00324	51		 push	 ecx
  00325	e8 00 00 00 00	 call	 _PA_SetFormat
  0032a	83 c4 10	 add	 esp, 16			; 00000010H
  0032d	85 c0		 test	 eax, eax
  0032f	74 1f		 je	 SHORT $L71349
$L71348:

; 584  : 	{
; 585  : /* GL 04/21/1997  add this for OSF build */
; 586  : #ifdef WIN32
; 587  : 	  Sleep( SET_AUDIO_PARAMS_SLEEP_TIME );

  00331	68 c8 00 00 00	 push	 200			; 000000c8H
  00336	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  0033c	8b 96 d8 00 00
	00		 mov	 edx, DWORD PTR [esi+216]
  00342	57		 push	 edi
  00343	52		 push	 edx
  00344	e8 00 00 00 00	 call	 _PA_SetFormat
  00349	83 c4 08	 add	 esp, 8
  0034c	85 c0		 test	 eax, eax
  0034e	75 e1		 jne	 SHORT $L71348
$L71349:

; 588  : #endif
; 589  : #ifdef __osf__
; 590  : 	  OP_Sleep( SET_AUDIO_PARAMS_SLEEP_TIME );
; 591  : #endif
; 592  : #ifdef __linux__
; 593  : 	  OP_Sleep( SET_AUDIO_PARAMS_SLEEP_TIME );
; 594  : #endif
; 595  : 	}
; 596  : 	
; 597  : 	/******************************************************************/
; 598  : 	/*  Free the PCMWAVEFORMAT structures and the audio play buffer.  */
; 599  : 	/******************************************************************/
; 600  : 
; 601  : 	free( pOldWaveFormat );

  00350	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__free
  00356	57		 push	 edi
  00357	ff d6		 call	 esi

; 602  : 
; 603  : 	if ( pWaveFormat != NULL )

  00359	8b 44 24 38	 mov	 eax, DWORD PTR _pWaveFormat$[esp+48]
  0035d	83 c4 04	 add	 esp, 4
  00360	85 c0		 test	 eax, eax
  00362	74 06		 je	 SHORT $L71351

; 604  : 	  free( pWaveFormat );

  00364	50		 push	 eax
  00365	ff d6		 call	 esi
  00367	83 c4 04	 add	 esp, 4
$L71351:

; 605  : 
; 606  : 	free( lpData );

  0036a	53		 push	 ebx
  0036b	ff d6		 call	 esi
  0036d	83 c4 04	 add	 esp, 4
$L71312:
  00370	5f		 pop	 edi
  00371	5e		 pop	 esi
  00372	5d		 pop	 ebp

; 607  :   }
; 608  : 
; 609  :   return(CMD_success);

  00373	33 c0		 xor	 eax, eax
  00375	5b		 pop	 ebx

; 610  : 
; 611  : #endif
; 612  : }

  00376	83 c4 20	 add	 esp, 32			; 00000020H
  00379	c3		 ret	 0
_cm_cmd_play ENDP
_TEXT	ENDS
EXTRN	__imp__mmioDescend@16:NEAR
EXTRN	__imp__mmioAscend@12:NEAR
EXTRN	__imp__mmioOpenA@12:NEAR
_TEXT	SEGMENT
_file_name$ = 8
_ppWaveFormat$ = 12
_piError$ = 16
_phTTS$ = 20
_ckInRIFF$ = -20
_ckIn$ = -40
_wave_file_open PROC NEAR

; 631  :   MMCKINFO ckInRIFF;  /* chunk info for input RIFF chunk */
; 632  :   MMCKINFO ckIn;      /* info for a chunk in input file  */
; 633  :   HMMIO hmmioIn;
; 634  :   LPWAVEFORMATEX pWaveFormat;
; 635  :   DWORD dwSize;
; 636  : 
; 637  :   /********************************************************************/
; 638  :   /*  Attempt to open file using MM I/O routines - return on failure. */
; 639  :   /********************************************************************/
; 640  : 
; 641  :   *piError = 0;
; 642  : 
; 643  : #ifdef WIN32
; 644  :   hmmioIn = mmioOpen( file_name, NULL, MMIO_READ );

  00380	8b 44 24 04	 mov	 eax, DWORD PTR _file_name$[esp-4]
  00384	83 ec 28	 sub	 esp, 40			; 00000028H
  00387	53		 push	 ebx
  00388	55		 push	 ebp
  00389	56		 push	 esi
  0038a	57		 push	 edi
  0038b	8b 7c 24 44	 mov	 edi, DWORD PTR _piError$[esp+52]
  0038f	6a 00		 push	 0
  00391	6a 00		 push	 0
  00393	50		 push	 eax
  00394	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0039a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mmioOpenA@12
  003a0	8b f0		 mov	 esi, eax

; 645  : #endif
; 646  : 
; 647  : #ifdef __osf__
; 648  :   hmmioIn = DTK_MMIO_OPEN( file_name, NULL, MMIO_READ );
; 649  : #endif
; 650  : #ifdef __linux__
; 651  :   hmmioIn = DTK_MMIO_OPEN( file_name, NULL, MMIO_READ );
; 652  : #endif
; 653  : 
; 654  : #ifndef ERRORCHECK
; 655  :   if ( hmmioIn == NULL )

  003a2	85 f6		 test	 esi, esi
  003a4	75 21		 jne	 SHORT $L71368

; 656  :   {
; 657  : 	TextToSpeechErrorHandler( phTTS,
; 658  : 							  ERROR_OPENING_WAVE_FILE,
; 659  : 							  MMSYSERR_ERROR );

  003a6	8b 4c 24 48	 mov	 ecx, DWORD PTR _phTTS$[esp+52]
  003aa	6a 01		 push	 1
  003ac	6a 07		 push	 7
  003ae	51		 push	 ecx
  003af	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  003b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 660  : 
; 661  : 	*piError = CMD_unable_to_open_file;

  003b7	c7 07 07 00 00
	00		 mov	 DWORD PTR [edi], 7

; 720  : 	return( (int)NULL );

  003bd	33 c0		 xor	 eax, eax
  003bf	5f		 pop	 edi
  003c0	5e		 pop	 esi
  003c1	5d		 pop	 ebp
  003c2	5b		 pop	 ebx

; 886  : }

  003c3	83 c4 28	 add	 esp, 40			; 00000028H
  003c6	c3		 ret	 0
$L71368:

; 662  : 	return( hmmioIn );
; 663  :   }
; 664  : #endif
; 665  : 
; 666  :   /********************************************************************/
; 667  :   /*  Descend the input file into the 'RIFF' chunk.                   */
; 668  :   /********************************************************************/
; 669  : 
; 670  : #ifdef WIN32
; 671  :   if ( mmioDescend(hmmioIn, &ckInRIFF, NULL, 0 ) != 0 )

  003c7	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__mmioDescend@16
  003cd	6a 00		 push	 0
  003cf	8d 54 24 28	 lea	 edx, DWORD PTR _ckInRIFF$[esp+60]
  003d3	6a 00		 push	 0
  003d5	52		 push	 edx
  003d6	56		 push	 esi
  003d7	ff d5		 call	 ebp
  003d9	85 c0		 test	 eax, eax

; 672  :   {
; 673  : 	mmioClose(hmmioIn, 0 );
; 674  : #endif
; 675  : /* GL 04/21/1997  change this for OSF build */
; 676  : #ifdef __osf__
; 677  :   if ( DTK_MMIO_DESCEND(hmmioIn, &ckInRIFF, NULL, 0 ) != 0 )
; 678  :   {
; 679  :         DTK_MMIO_CLOSE(hmmioIn, 0 );
; 680  : #endif
; 681  : #ifdef __linux__
; 682  :   if ( DTK_MMIO_DESCEND(hmmioIn, &ckInRIFF, NULL, 0 ) != 0 )
; 683  :   {
; 684  :         DTK_MMIO_CLOSE(hmmioIn, 0 );
; 685  : #endif
; 686  : 	TextToSpeechErrorHandler( phTTS,
; 687  : 							  ERROR_BAD_WAVE_FILE_FORMAT,
; 688  : 							  MMSYSERR_ERROR );
; 689  : 	*piError = CMD_bad_wave_file_format;
; 690  : 	return( (int)NULL );

  003db	0f 85 e4 00 00
	00		 jne	 $L71390

; 691  :   }
; 692  :   
; 693  :   /********************************************************************/
; 694  :   /*  Make sure the input file is a WAVE file.                        */
; 695  :   /********************************************************************/
; 696  : 
; 697  : #ifdef WIN32
; 698  :   if (( ckInRIFF.ckid != FOURCC_RIFF )
; 699  :    || ( ckInRIFF.fccType != mmioFOURCC( 'W', 'A', 'V', 'E' )))

  003e1	81 7c 24 24 52
	49 46 46	 cmp	 DWORD PTR _ckInRIFF$[esp+56], 1179011410 ; 46464952H
  003e9	0f 85 d6 00 00
	00		 jne	 $L71390
  003ef	81 7c 24 2c 57
	41 56 45	 cmp	 DWORD PTR _ckInRIFF$[esp+64], 1163280727 ; 45564157H
  003f7	0f 85 c8 00 00
	00		 jne	 $L71390

; 721  :   }
; 722  : 
; 723  :   /********************************************************************/
; 724  :   /*  Search the input file for for the 'fmt ' chunk.                 */
; 725  :   /********************************************************************/
; 726  : #ifdef WIN32
; 727  :   ckIn.ckid = mmioFOURCC( 'f', 'm', 't', ' ' );
; 728  :   if ( mmioDescend( hmmioIn, &ckIn, &ckInRIFF, MMIO_FINDCHUNK ) != 0 )

  003fd	8d 4c 24 24	 lea	 ecx, DWORD PTR _ckInRIFF$[esp+56]
  00401	6a 10		 push	 16			; 00000010H
  00403	8d 54 24 14	 lea	 edx, DWORD PTR _ckIn$[esp+60]
  00407	51		 push	 ecx
  00408	52		 push	 edx
  00409	56		 push	 esi
  0040a	c7 44 24 20 66
	6d 74 20	 mov	 DWORD PTR _ckIn$[esp+72], 544501094 ; 20746d66H
  00412	ff d5		 call	 ebp
  00414	85 c0		 test	 eax, eax

; 729  :   {
; 730  : 	mmioClose( hmmioIn, 0 );
; 731  : #endif
; 732  : /* GL 04/21/1997  change this for OSF build */
; 733  : #ifdef __osf__
; 734  :   ckIn.ckid = DTK_MMIO_FOURCC( 'f', 'm', 't', ' ' );
; 735  :   if ( DTK_MMIO_DESCEND( hmmioIn, &ckIn, &ckInRIFF, MMIO_FINDCHUNK ) != 0 )
; 736  :   {
; 737  :     DTK_MMIO_CLOSE( hmmioIn, 0 );
; 738  : #endif
; 739  : #ifdef __linux__
; 740  :   ckIn.ckid = DTK_MMIO_FOURCC( 'f', 'm', 't', ' ' );
; 741  :   if ( DTK_MMIO_DESCEND( hmmioIn, &ckIn, &ckInRIFF, MMIO_FINDCHUNK ) != 0 )
; 742  :   {
; 743  :     DTK_MMIO_CLOSE( hmmioIn, 0 );
; 744  : #endif
; 745  : 	TextToSpeechErrorHandler( phTTS,
; 746  : 							  ERROR_BAD_WAVE_FILE_FORMAT,
; 747  : 							  MMSYSERR_ERROR );
; 748  : 	*piError = CMD_bad_wave_file_format;
; 749  : 	return( (int)NULL );

  00416	0f 85 a9 00 00
	00		 jne	 $L71390

; 750  :   }
; 751  : 
; 752  :   
; 753  :   /********************************************************************/
; 754  :   /*  Get the size of the 'fmt ' chunk.                               */
; 755  :   /********************************************************************/
; 756  : 
; 757  :   dwSize = ckIn.cksize;

  0041c	8b 5c 24 14	 mov	 ebx, DWORD PTR _ckIn$[esp+60]

; 758  : 
; 759  :   if ( dwSize < sizeof(WAVEFORMATEX))

  00420	83 fb 12	 cmp	 ebx, 18			; 00000012H
  00423	73 05		 jae	 SHORT $L71405

; 760  : 	dwSize = sizeof(WAVEFORMATEX);

  00425	bb 12 00 00 00	 mov	 ebx, 18			; 00000012H
$L71405:

; 761  : 
; 762  :   /********************************************************************/
; 763  :   /*  Allocate a WAVEFORMATEX structure.                              */
; 764  :   /********************************************************************/
; 765  : 
; 766  :   pWaveFormat = (LPWAVEFORMATEX)malloc((size_t)dwSize);

  0042a	53		 push	 ebx
  0042b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00431	83 c4 04	 add	 esp, 4

; 767  : 
; 768  :   if ( pWaveFormat == NULL )

  00434	85 c0		 test	 eax, eax
  00436	75 29		 jne	 SHORT $L71410

; 769  :   {
; 770  : 
; 771  : #ifdef WIN32
; 772  : 	mmioClose(hmmioIn, 0 );

  00438	50		 push	 eax
  00439	56		 push	 esi
  0043a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mmioClose@8

; 773  : #endif
; 774  : 
; 775  : /* GL 04/21/1997  change this for OSF build */
; 776  : #ifdef __osf__
; 777  : 	    DTK_MMIO_CLOSE(hmmioIn, 0 );
; 778  : #endif
; 779  : #ifdef __linux__
; 780  : 	    DTK_MMIO_CLOSE(hmmioIn, 0 );
; 781  : #endif
; 782  : 
; 783  : 	TextToSpeechErrorHandler( phTTS,
; 784  : 							  0,
; 785  : 							  MMSYSERR_NOMEM );

  00440	8b 4c 24 48	 mov	 ecx, DWORD PTR _phTTS$[esp+52]
  00444	6a 07		 push	 7
  00446	6a 00		 push	 0
  00448	51		 push	 ecx
  00449	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  0044e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 786  : 	*piError = CMD_out_of_memory;

  00451	c7 07 06 00 00
	00		 mov	 DWORD PTR [edi], 6
  00457	33 c0		 xor	 eax, eax
  00459	5f		 pop	 edi
  0045a	5e		 pop	 esi
  0045b	5d		 pop	 ebp
  0045c	5b		 pop	 ebx

; 886  : }

  0045d	83 c4 28	 add	 esp, 40			; 00000028H
  00460	c3		 ret	 0
$L71410:

; 787  : 	return( (int)NULL );
; 788  :   }
; 789  : 
; 790  :   *ppWaveFormat = pWaveFormat;

  00461	8b 54 24 40	 mov	 edx, DWORD PTR _ppWaveFormat$[esp+52]

; 791  : 
; 792  :   /********************************************************************/
; 793  :   /*  Read 'fmt ' chunk into <WaveFormat>.                            */
; 794  :   /********************************************************************/
; 795  : 
; 796  : #ifdef WIN32
; 797  :   if ( dwSize != (DWORD)mmioRead( hmmioIn,
; 798  : 								  (HPSTR)&pWaveFormat->wFormatTag,
; 799  : 								  dwSize ))

  00465	53		 push	 ebx
  00466	50		 push	 eax
  00467	56		 push	 esi
  00468	89 02		 mov	 DWORD PTR [edx], eax
  0046a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mmioRead@12
  00470	3b d8		 cmp	 ebx, eax

; 800  :   {
; 801  : 	mmioClose(hmmioIn, 0 );

  00472	6a 00		 push	 0

; 802  : #endif
; 803  : /* GL 04/21/1997  add this for OSF build */
; 804  : #ifdef __osf__
; 805  :   if ( dwSize != (DWORD) DTK_MMIO_READ( hmmioIn,
; 806  : 								  (HPSTR)&pWaveFormat->wFormatTag,
; 807  : 								  dwSize ))
; 808  :   {
; 809  :         DTK_MMIO_CLOSE(hmmioIn, 0 );
; 810  : #endif
; 811  : #ifdef __linux__
; 812  :   if ( dwSize != (DWORD) DTK_MMIO_READ( hmmioIn,
; 813  : 								  (HPSTR)&pWaveFormat->wFormatTag,
; 814  : 								  dwSize ))
; 815  :   {
; 816  :         DTK_MMIO_CLOSE(hmmioIn, 0 );
; 817  : #endif
; 818  : 	TextToSpeechErrorHandler( phTTS,
; 819  : 							  ERROR_BAD_WAVE_FILE_FORMAT,
; 820  : 							  MMSYSERR_ERROR );
; 821  : 	*piError = CMD_bad_wave_file_format;
; 822  : 	return( (int)NULL );

  00474	75 51		 jne	 SHORT $L71457

; 823  :   }
; 824  : 
; 825  : 
; 826  :   /********************************************************************/
; 827  :   /*  Ascend the input file out of the 'fmt ' chunk.                  */
; 828  :   /********************************************************************/
; 829  : #ifdef WIN32
; 830  :   if ( mmioAscend(hmmioIn, &ckIn, 0 ) != 0 )

  00476	8d 4c 24 14	 lea	 ecx, DWORD PTR _ckIn$[esp+60]
  0047a	51		 push	 ecx
  0047b	56		 push	 esi
  0047c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mmioAscend@12
  00482	85 c0		 test	 eax, eax

; 831  :   {
; 832  : 	mmioClose(hmmioIn, 0 );
; 833  : #endif
; 834  : /* GL 04/21/1997  add this for OSF build */
; 835  : #ifdef __osf__
; 836  :   if ( DTK_MMIO_ASCEND(hmmioIn, &ckIn, 0 ) != 0 )
; 837  :   {
; 838  :     DTK_MMIO_CLOSE(hmmioIn, 0 );
; 839  : #endif
; 840  : #ifdef __linux__
; 841  :   if ( DTK_MMIO_ASCEND(hmmioIn, &ckIn, 0 ) != 0 )
; 842  :   {
; 843  :     DTK_MMIO_CLOSE(hmmioIn, 0 );
; 844  : #endif
; 845  : 	TextToSpeechErrorHandler( phTTS,
; 846  : 							  ERROR_BAD_WAVE_FILE_FORMAT,
; 847  : 							  MMSYSERR_ERROR );
; 848  : 	*piError = CMD_bad_wave_file_format;
; 849  : 	return( (int)NULL );

  00484	75 1b		 jne	 SHORT $L71459

; 850  :   }
; 851  : 
; 852  : 
; 853  : 
; 854  :   /********************************************************************/
; 855  :   /*  Search the input file for for the 'data' chunk & leave file     */
; 856  :   /*  positioned there for when we start reading audio data.          */
; 857  :   /********************************************************************/
; 858  : #ifdef WIN32
; 859  :   ckIn.ckid = mmioFOURCC( 'd', 'a', 't', 'a' );
; 860  :   if ( mmioDescend( hmmioIn, &ckIn, &ckInRIFF, MMIO_FINDCHUNK ) != 0 )

  00486	8d 44 24 24	 lea	 eax, DWORD PTR _ckInRIFF$[esp+56]
  0048a	6a 10		 push	 16			; 00000010H
  0048c	8d 4c 24 14	 lea	 ecx, DWORD PTR _ckIn$[esp+60]
  00490	50		 push	 eax
  00491	51		 push	 ecx
  00492	56		 push	 esi
  00493	c7 44 24 20 64
	61 74 61	 mov	 DWORD PTR _ckIn$[esp+72], 1635017060 ; 61746164H
  0049b	ff d5		 call	 ebp
  0049d	85 c0		 test	 eax, eax
  0049f	74 14		 je	 SHORT $L71429
$L71459:

; 861  :   {
; 862  : 	mmioClose(hmmioIn, 0 );

  004a1	6a 00		 push	 0
  004a3	56		 push	 esi
  004a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mmioClose@8

; 863  : #endif
; 864  : /* GL 04/21/1997  add this for OSF build */
; 865  : #ifdef __osf__
; 866  :   ckIn.ckid = DTK_MMIO_FOURCC( 'd', 'a', 't', 'a' );
; 867  :   if ( DTK_MMIO_DESCEND( hmmioIn, &ckIn, &ckInRIFF, MMIO_FINDCHUNK ) != 0 )
; 868  :   {
; 869  :     DTK_MMIO_CLOSE(hmmioIn, 0 );
; 870  : #endif
; 871  : #ifdef __linux__
; 872  :   ckIn.ckid = DTK_MMIO_FOURCC( 'd', 'a', 't', 'a' );
; 873  :   if ( DTK_MMIO_DESCEND( hmmioIn, &ckIn, &ckInRIFF, MMIO_FINDCHUNK ) != 0 )
; 874  :   {
; 875  :     DTK_MMIO_CLOSE(hmmioIn, 0 );
; 876  : #endif
; 877  : 	TextToSpeechErrorHandler( phTTS,
; 878  : 							  ERROR_BAD_WAVE_FILE_FORMAT,
; 879  : 							  MMSYSERR_ERROR );

  004aa	8b 54 24 48	 mov	 edx, DWORD PTR _phTTS$[esp+52]
  004ae	6a 01		 push	 1
  004b0	6a 08		 push	 8
  004b2	52		 push	 edx

; 880  : 	*piError = CMD_bad_wave_file_format;
; 881  : 	return( (int)NULL );

  004b3	eb 22		 jmp	 SHORT $L71458
$L71429:

; 882  :   }
; 883  : 
; 884  :   *piError = 0;

  004b5	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 885  :   return( hmmioIn );

  004bb	8b c6		 mov	 eax, esi
  004bd	5f		 pop	 edi
  004be	5e		 pop	 esi
  004bf	5d		 pop	 ebp
  004c0	5b		 pop	 ebx

; 886  : }

  004c1	83 c4 28	 add	 esp, 40			; 00000028H
  004c4	c3		 ret	 0
$L71390:

; 700  :   {
; 701  : 	mmioClose(hmmioIn, 0 );

  004c5	6a 00		 push	 0
$L71457:
  004c7	56		 push	 esi
  004c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mmioClose@8

; 702  : #endif
; 703  : /* GL 04/21/1997  change this for OSF build */
; 704  : #ifdef __osf__
; 705  :   if (( ckInRIFF.ckid != FOURCC_RIFF )
; 706  :    || ( ckInRIFF.fccType != DTK_MMIO_FOURCC( 'W', 'A', 'V', 'E' )))
; 707  :   {
; 708  :     DTK_MMIO_CLOSE(hmmioIn, 0 );
; 709  : #endif
; 710  : #ifdef __linux__
; 711  :   if (( ckInRIFF.ckid != FOURCC_RIFF )
; 712  :    || ( ckInRIFF.fccType != DTK_MMIO_FOURCC( 'W', 'A', 'V', 'E' )))
; 713  :   {
; 714  :     DTK_MMIO_CLOSE(hmmioIn, 0 );
; 715  : #endif
; 716  : 	TextToSpeechErrorHandler( phTTS,
; 717  : 							  ERROR_BAD_WAVE_FILE_FORMAT,
; 718  : 							  MMSYSERR_ERROR );

  004ce	8b 44 24 48	 mov	 eax, DWORD PTR _phTTS$[esp+52]
  004d2	6a 01		 push	 1
  004d4	6a 08		 push	 8
  004d6	50		 push	 eax
$L71458:
  004d7	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  004dc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 719  : 	*piError = CMD_bad_wave_file_format;

  004df	c7 07 08 00 00
	00		 mov	 DWORD PTR [edi], 8

; 720  : 	return( (int)NULL );

  004e5	33 c0		 xor	 eax, eax
  004e7	5f		 pop	 edi
  004e8	5e		 pop	 esi
  004e9	5d		 pop	 ebp
  004ea	5b		 pop	 ebx

; 886  : }

  004eb	83 c4 28	 add	 esp, 40			; 00000028H
  004ee	c3		 ret	 0
_wave_file_open ENDP
_TEXT	ENDS
END
