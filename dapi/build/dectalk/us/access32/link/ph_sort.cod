	TITLE	D:\work\Product\dapi\src\Ph\ph_sort.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _phone_feature
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_durdic
CONST	SEGMENT
_durdic	DW	0cH
	DW	06fH
	DW	01e1fH
	DW	067H
	DW	01e02H
	DW	01e30H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	055H
	DW	00H
	DW	0ffffH
	DW	0cH
	DW	06fH
	DW	01e1bH
	DW	067H
	DW	01e06H
	DW	01e2fH
	DW	00H
	DW	00H
	DW	00H
	DW	03cH
	DW	0a0H
	DW	00H
	DW	0ffffH
	DW	0cH
	DW	06fH
	DW	01e29H
	DW	067H
	DW	01e02H
	DW	01e2fH
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	041H
	DW	00H
	DW	0ffffH
	DW	0aH
	DW	06fH
	DW	067H
	DW	01e04H
	DW	01e20H
	DW	00H
	DW	00H
	DW	00H
	DW	050H
	DW	046H
	DW	0ffffH
	DW	0aH
	DW	06fH
	DW	067H
	DW	01e05H
	DW	01e30H
	DW	00H
	DW	00H
	DW	00H
	DW	06eH
	DW	00H
	DW	0ffffH
	DW	0cH
	DW	06fH
	DW	01e18H
	DW	067H
	DW	01e0aH
	DW	01e20H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	082H
	DW	00H
	DW	0ffffH
	DW	0eH
	DW	06fH
	DW	01e18H
	DW	067H
	DW	01e09H
	DW	01e20H
	DW	01e29H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	050H
	DW	00H
	DW	00H
	DW	0ffffH
	DW	0cH
	DW	06fH
	DW	01e20H
	DW	067H
	DW	01e04H
	DW	01e26H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	04a6H
	DW	00H
	DW	0ffffH
	DW	0cH
	DW	06fH
	DW	067H
	DW	01e01H
	DW	01e26H
	DW	01e24H
	DW	00H
	DW	00H
	DW	00H
	DW	08eH
	DW	00H
	DW	00H
	DW	0ffffH
	DW	0eH
	DW	06fH
	DW	01e2dH
	DW	01e1aH
	DW	067H
	DW	01e06H
	DW	01e30H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	08cH
	DW	00H
	DW	0ffffH
	DW	00H
CONST	ENDS
PUBLIC	_phcluster
_TEXT	SEGMENT
_f$ = 8
_s$ = 12
_phcluster PROC NEAR

; 154  : 	switch (f)
; 155  : 	{

  00000	0f bf 44 24 04	 movsx	 eax, WORD PTR _f$[esp-4]
  00005	05 db e1 ff ff	 add	 eax, -7717		; ffffe1dbH
  0000a	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  0000d	0f 87 2e 01 00
	00		 ja	 $L71443
  00013	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L71838[eax*4]
$L71446:

; 156  : 	case USP_P:
; 157  : 		if ((s == USP_LL) || (s == USP_R))

  0001a	66 8b 44 24 08	 mov	 ax, WORD PTR _s$[esp-4]
  0001f	66 3d 1b 1e	 cmp	 ax, 7707		; 00001e1bH
  00023	74 0a		 je	 SHORT $L71448
  00025	66 3d 1a 1e	 cmp	 ax, 7706		; 00001e1aH
  00029	0f 85 12 01 00
	00		 jne	 $L71443
$L71448:

; 158  : 			return (CLUSTER_TRYS);

  0002f	66 b8 02 00	 mov	 ax, 2

; 201  : }

  00033	c3		 ret	 0
$L71449:

; 159  : 		break;
; 160  : 	case USP_B:
; 161  : 		if ((s == USP_LL) || (s == USP_R))

  00034	66 8b 44 24 08	 mov	 ax, WORD PTR _s$[esp-4]
  00039	66 3d 1b 1e	 cmp	 ax, 7707		; 00001e1bH
  0003d	74 0a		 je	 SHORT $L71451
  0003f	66 3d 1a 1e	 cmp	 ax, 7706		; 00001e1aH
  00043	0f 85 f8 00 00
	00		 jne	 $L71443
$L71451:

; 162  : 			return (CLUSTER);

  00049	66 b8 01 00	 mov	 ax, 1

; 201  : }

  0004d	c3		 ret	 0
$L71452:

; 163  : 		break;
; 164  : 	case USP_F:
; 165  : 		if (s == USP_R)

  0004e	66 8b 44 24 08	 mov	 ax, WORD PTR _s$[esp-4]
  00053	66 3d 1a 1e	 cmp	 ax, 7706		; 00001e1aH
  00057	75 05		 jne	 SHORT $L71453

; 166  : 			return (CLUSTER_TRYS);

  00059	66 b8 02 00	 mov	 ax, 2

; 201  : }

  0005d	c3		 ret	 0
$L71453:

; 167  : 		if (s == USP_LL)

  0005e	66 3d 1b 1e	 cmp	 ax, 7707		; 00001e1bH
  00062	0f 85 d9 00 00
	00		 jne	 $L71443

; 168  : 			return (CLUSTER);

  00068	66 b8 01 00	 mov	 ax, 1

; 201  : }

  0006c	c3		 ret	 0
$L71455:

; 169  : 		break;
; 170  : 	case USP_T:
; 171  : 		if (s == USP_R)

  0006d	66 8b 44 24 08	 mov	 ax, WORD PTR _s$[esp-4]
  00072	66 3d 1a 1e	 cmp	 ax, 7706		; 00001e1aH
  00076	75 50		 jne	 SHORT $L71456

; 172  : 			return (CLUSTER_TRYS);

  00078	66 b8 02 00	 mov	 ax, 2

; 201  : }

  0007c	c3		 ret	 0
$L71458:

; 173  : 		if (s == USP_W)
; 174  : 			return (CLUSTER);
; 175  : 		break;
; 176  : 	case USP_D:
; 177  : 	case USP_TH:
; 178  : 		if ((s == USP_R) || (s == USP_W))

  0007d	66 8b 44 24 08	 mov	 ax, WORD PTR _s$[esp-4]
  00082	66 3d 1a 1e	 cmp	 ax, 7706		; 00001e1aH
  00086	74 46		 je	 SHORT $L71460
  00088	66 3d 18 1e	 cmp	 ax, 7704		; 00001e18H
  0008c	0f 85 af 00 00
	00		 jne	 $L71443

; 179  : 			return (CLUSTER);

  00092	66 b8 01 00	 mov	 ax, 1

; 201  : }

  00096	c3		 ret	 0
$L71461:

; 180  : 		break;
; 181  : 	case USP_K:
; 182  : 		if ((s == USP_R) || (s == USP_LL) || (s == USP_W))

  00097	66 8b 44 24 08	 mov	 ax, WORD PTR _s$[esp-4]
  0009c	66 3d 1a 1e	 cmp	 ax, 7706		; 00001e1aH
  000a0	74 10		 je	 SHORT $L71463
  000a2	66 3d 1b 1e	 cmp	 ax, 7707		; 00001e1bH
  000a6	74 0a		 je	 SHORT $L71463
  000a8	66 3d 18 1e	 cmp	 ax, 7704		; 00001e18H
  000ac	0f 85 8f 00 00
	00		 jne	 $L71443
$L71463:

; 183  : 			return (CLUSTER_TRYS);

  000b2	66 b8 02 00	 mov	 ax, 2

; 201  : }

  000b6	c3		 ret	 0
$L71464:

; 184  : 		break;
; 185  : 	case USP_G:
; 186  : 		if ((s == USP_R) || (s == USP_LL) || (s == USP_W))

  000b7	66 8b 44 24 08	 mov	 ax, WORD PTR _s$[esp-4]
  000bc	66 3d 1a 1e	 cmp	 ax, 7706		; 00001e1aH
  000c0	74 0c		 je	 SHORT $L71460
  000c2	66 3d 1b 1e	 cmp	 ax, 7707		; 00001e1bH
  000c6	74 06		 je	 SHORT $L71460
$L71456:
  000c8	66 3d 18 1e	 cmp	 ax, 7704		; 00001e18H
  000cc	75 73		 jne	 SHORT $L71443
$L71460:

; 187  : 			return (CLUSTER);

  000ce	66 b8 01 00	 mov	 ax, 1

; 201  : }

  000d2	c3		 ret	 0
$L71467:

; 188  : 		break;
; 189  : 	case USP_S:
; 190  : 		if ((s == USP_W) || (s == USP_LL) || (s == USP_P) || (s == USP_T)
; 191  : 			|| (s == USP_K) || (s == USP_M) || (s == USP_N) || (s == USP_F))

  000d3	66 8b 44 24 08	 mov	 ax, WORD PTR _s$[esp-4]
  000d8	66 3d 18 1e	 cmp	 ax, 7704		; 00001e18H
  000dc	74 2a		 je	 SHORT $L71469
  000de	66 3d 1b 1e	 cmp	 ax, 7707		; 00001e1bH
  000e2	74 24		 je	 SHORT $L71469
  000e4	66 3d 2d 1e	 cmp	 ax, 7725		; 00001e2dH
  000e8	74 1e		 je	 SHORT $L71469
  000ea	66 3d 2f 1e	 cmp	 ax, 7727		; 00001e2fH
  000ee	74 18		 je	 SHORT $L71469
  000f0	66 3d 31 1e	 cmp	 ax, 7729		; 00001e31H
  000f4	74 12		 je	 SHORT $L71469
  000f6	66 3d 1f 1e	 cmp	 ax, 7711		; 00001e1fH
  000fa	74 0c		 je	 SHORT $L71469
  000fc	66 3d 20 1e	 cmp	 ax, 7712		; 00001e20H
  00100	74 06		 je	 SHORT $L71469
  00102	66 3d 25 1e	 cmp	 ax, 7717		; 00001e25H
  00106	75 39		 jne	 SHORT $L71443
$L71469:

; 192  : 			return (CLUSTER);

  00108	66 b8 01 00	 mov	 ax, 1

; 201  : }

  0010c	c3		 ret	 0
$L71470:

; 193  : 		break;
; 194  : 	case USP_SH:
; 195  : 		if ((s == USP_W) || (s == USP_LL) || (s == USP_P) || (s == USP_T)
; 196  : 			|| (s == USP_R) || (s == USP_M) || (s == USP_N))

  0010d	66 8b 44 24 08	 mov	 ax, WORD PTR _s$[esp-4]
  00112	66 3d 18 1e	 cmp	 ax, 7704		; 00001e18H
  00116	74 24		 je	 SHORT $L71472
  00118	66 3d 1b 1e	 cmp	 ax, 7707		; 00001e1bH
  0011c	74 1e		 je	 SHORT $L71472
  0011e	66 3d 2d 1e	 cmp	 ax, 7725		; 00001e2dH
  00122	74 18		 je	 SHORT $L71472
  00124	66 3d 2f 1e	 cmp	 ax, 7727		; 00001e2fH
  00128	74 12		 je	 SHORT $L71472
  0012a	66 3d 1a 1e	 cmp	 ax, 7706		; 00001e1aH
  0012e	74 0c		 je	 SHORT $L71472
  00130	66 3d 1f 1e	 cmp	 ax, 7711		; 00001e1fH
  00134	74 06		 je	 SHORT $L71472
  00136	66 3d 20 1e	 cmp	 ax, 7712		; 00001e20H
  0013a	75 05		 jne	 SHORT $L71443
$L71472:

; 197  : 			return (CLUSTER);

  0013c	66 b8 01 00	 mov	 ax, 1

; 201  : }

  00140	c3		 ret	 0
$L71443:

; 198  : 		break;
; 199  : 	}
; 200  : 	return (NOCLUSTER);

  00141	66 33 c0	 xor	 ax, ax

; 201  : }

  00144	c3		 ret	 0
  00145	8d 49 00	 npad	 3
$L71838:
  00148	00 00 00 00	 DD	 $L71452
  0014c	00 00 00 00	 DD	 $L71443
  00150	00 00 00 00	 DD	 $L71458
  00154	00 00 00 00	 DD	 $L71443
  00158	00 00 00 00	 DD	 $L71467
  0015c	00 00 00 00	 DD	 $L71443
  00160	00 00 00 00	 DD	 $L71470
  00164	00 00 00 00	 DD	 $L71443
  00168	00 00 00 00	 DD	 $L71446
  0016c	00 00 00 00	 DD	 $L71449
  00170	00 00 00 00	 DD	 $L71455
  00174	00 00 00 00	 DD	 $L71458
  00178	00 00 00 00	 DD	 $L71461
  0017c	00 00 00 00	 DD	 $L71464
_phcluster ENDP
_TEXT	ENDS
PUBLIC	_phsort
PUBLIC	_durlookup
EXTRN	_all_featb:BYTE
EXTRN	_adjust_index:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pKsd_t$ = -20
_snphonetot$ = -4
_n$ = -40
_curr_dur$ = -36
_compound_destress$ = -32
_curr_f0$ = -28
_curr_in_sym$ = -16
_word_init_sw$ = -24
_in_rhyme$ = -12
_mf0$ = -8
_nstartphrase$ = -24
_phsort	PROC NEAR

; 370  : {

  00180	83 ec 28	 sub	 esp, 40			; 00000028H

; 371  : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;

  00183	8b 44 24 2c	 mov	 eax, DWORD PTR _phTTS$[esp+36]
  00187	53		 push	 ebx
  00188	55		 push	 ebp
  00189	56		 push	 esi

; 372  : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  0018a	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  0018d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 373  : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;
; 374  : 
; 375  : 	short                   snphonetot = 0;		/* MVP 03/19/96 changed to short from unsigned int */
; 376  : 	short  *durlookup(PDPH_T pDph_t,short *symbol , short table[]);
; 377  : 	short                   n = 0, curr_dur = 0, compound_destress = 0, curr_f0 = 0;	/* MVP : Made local */

  00190	33 db		 xor	 ebx, ebx
  00192	57		 push	 edi
  00193	8b ae 10 2c 00
	00		 mov	 ebp, DWORD PTR [esi+11280]
  00199	89 5c 24 10	 mov	 DWORD PTR _n$[esp+56], ebx
  0019d	89 5c 24 14	 mov	 DWORD PTR _curr_dur$[esp+56], ebx
  001a1	89 5c 24 1c	 mov	 DWORD PTR _curr_f0$[esp+56], ebx

; 378  : 	short                   curr_in_phone =0, curr_in_sym = 0, word_init_sw = 0, in_rhyme = 0, m, mf0, nstresses;		/* MVP : made local */
; 379  : 	short                   nstartphrase = 0;
; 380  : #ifdef ENGLISH_UK
; 381  :  	short Ge_ma_found_r=0;
; 382  : #endif
; 383  : 
; 384  : #if defined ENGLISHphrasestuff || defined GERMAN
; 385  : 	short	nextvowel=0;
; 386  : 	short   nextthing=0;
; 387  : #endif
; 388  : 	short *cp;
; 389  : 	short tmp=0;
; 390  : 
; 391  : #ifndef ENGLISH_US
; 392  : 	short				ntmp=0; 
; 393  : #endif
; 394  : 
; 395  : #ifdef ENGLISH_UK
; 396  : 	short 	ntmpr=0;
; 397  : #endif
; 398  : 
; 399  : #ifdef SPANISH
; 400  : 		short				phrase_after_quote = 0;
; 401  : 		short               nsyll;	   /* Nbr. syllables       */
; 402  : 		short               syllclass; /* Set if open syllable */
; 403  : 		U32               iscoda;	   /* Set after nucleus    */
; 404  : 		short               wordstress;/* TRUE if any stress   */
; 405  : 		pDph_t->special_phrase=0;
; 406  : 		pDph_t->specdur = 0;
; 407  : #endif 
; 408  : 
; 409  : #ifdef GERMAN
; 410  : 		SENT_PARS			*pp;
; 411  : 		
; 412  : 	pDph_t->Word_has_stress =0;
; 413  : 	pDph_t->number_fsyls  = 0;
; 414  : #endif
; 415  : 	//eab 10/087/00 The used to be one less but now in english at least it's changed and I need to modify
; 416  : 	//the initaliazation and check for all languages...
; 417  : 
; 418  : #ifdef SPANISH
; 419  : 	pDph_t->number_words=-1; // but alas Spanish has word- boundaries of number words plus 1
; 420  : #else
; 421  : 	pDph_t->number_words=0; /* eab init there is one less word boundary than number of 

  001a5	66 89 9e 2e 20
	00 00		 mov	 WORD PTR [esi+8238], bx

; 422  : 							words*/
; 423  : #endif
; 424  : 
; 425  : 	pDphsettar->did_del = 0;

  001ac	89 5d 1c	 mov	 DWORD PTR [ebp+28], ebx

; 426  : 
; 427  : #ifdef GERMAN
; 428  : 	/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 429  : 	/* clear parsing structure, even if syntax() isn't called        */
; 430  : 	/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 431  : 
; 432  : 	for (pp = pDph_t->pars; pp <= &pDph_t->pars[pDph_t->nsymbtot]; pp++)
; 433  : 	{
; 434  : 		pp->phopoint = 0;
; 435  : 		pp->wordclass = 0;
; 436  : 		pp->bouflag = 0;
; 437  : 	}
; 438  : 	/* for */
; 439  : #endif
; 440  : #ifdef ENGLISHphrasestuff /*2/12/99 eab new code first very specific for find " that" and a hat fall to the previous
; 441  : 						word and stress the word following the that as starters
; 442  : 						search ahead this code is messsy for now but it is just a test */
; 443  : 
; 444  : 						for (n = 0; n < pDph_t->nsymbtot; n++)
; 445  : 						{
; 446  : 							if((pDph_t->symbols[n] ) == WBOUND)
; 447  : 							
; 448  : 							if ((pDph_t->symbols[n -3] == USP_DH) && (pDph_t->symbols[n - 2] == USP_AE)
; 449  : 								&& (pDph_t->symbols[n - 1] == USP_T))
; 450  : 							{
; 451  : 								//insertphone (phTTS,nextvowel-3 , HAT_FALL);
; 452  : 										
; 453  : 								for (nextvowel = n+1; nextvowel < pDph_t->nsymbtot; nextvowel++)
; 454  : 								{
; 455  : 									if (phone_feature(pDph_t,  pDph_t->symbols[nextvowel]) & FVOWEL)
; 456  : 									{
; 457  : 										/* don't stress a helper verb following that*/
; 458  : 										if(!(pDph_t->wordclass[pDph_t->nsymbtot] & FC_FUNC
; 459  : 											&& pDph_t->wordclass[pDph_t->nsymbtot] & FC_VERB))
; 460  : 											//insertphone (phTTS,nextvowel , S2);
; 461  : 
; 462  : 
; 463  : 										break;
; 464  : 									}
; 465  : 								}
; 466  : 							}
; 467  : 						}
; 468  : #endif
; 469  : 
; 470  : 
; 471  : 
; 472  : 	pDph_t->f0mode = NORMAL;
; 473  : 
; 474  : #ifdef SPANISH
; 475  : 	pDph_t->emphasisflag = FALSE; 
; 476  : #endif
; 477  : 	pDph_t->cbsymbol = 0;
; 478  : 	
; 479  : 
; 480  : 	/* Main loop 1: Clean up input string re mis-orderings & extra boundaries */
; 481  : 	pDph_t->nphonetot = 0;
; 482  : 	nstresses = 0;
; 483  : 	nstartphrase = 0; 
; 484  : 	/*  due to different people stuffing the pipe a word boundary is not always sent before the first word
; 485  : 	of a claue so insert it if needed eab 8/26/00 */
; 486  : 	if(pDph_t->nsymbtot >2 && pDph_t->symbols[1] !=111)

  001af	66 83 be 82 17
	00 00 02	 cmp	 WORD PTR [esi+6018], 2
  001b7	89 4c 24 24	 mov	 DWORD PTR _pKsd_t$[esp+56], ecx
  001bb	89 5c 24 18	 mov	 DWORD PTR _compound_destress$[esp+56], ebx
  001bf	66 c7 86 9c 17
	00 00 01 00	 mov	 WORD PTR [esi+6044], 1
  001c8	66 89 9e 9e 17
	00 00		 mov	 WORD PTR [esi+6046], bx
  001cf	66 89 9e 98 17
	00 00		 mov	 WORD PTR [esi+6040], bx
  001d6	89 5c 24 20	 mov	 DWORD PTR _nstartphrase$[esp+56], ebx
  001da	7e 17		 jle	 SHORT $L71602
  001dc	66 83 be 28 15
	00 00 6f	 cmp	 WORD PTR [esi+5416], 111 ; 0000006fH
  001e4	74 0d		 je	 SHORT $L71602

; 487  : 		insertphone (phTTS,(1),( 111));

  001e6	6a 6f		 push	 111			; 0000006fH
  001e8	6a 01		 push	 1
  001ea	50		 push	 eax
  001eb	e8 00 00 00 00	 call	 _insertphone
  001f0	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71602:

; 488  : 
; 489  : 	
; 490  : #ifdef GERMAN
; 491  : 
; 492  : 	
; 493  : 	for (n = 0; n < pDph_t->nsymbtot; n++)
; 494  : 	{
; 495  : 		if (((pDph_t->symbols[n] ) == S1 ||
; 496  : 			  (pDph_t->symbols[n]) == S2 ||
; 497  : 			  (pDph_t->symbols[n]) == S3)
; 498  : 			 && !(phone_feature( pDph_t,  pDph_t->symbols[n + 1]) & FVOWEL))
; 499  : 		{
; 500  : 			/* BATS 711 Slight improvement in loop performance start at n+2 not n */
; 501  : 			for (nextvowel = n+2; nextvowel < pDph_t->nsymbtot; nextvowel++)
; 502  : 			{
; 503  : 				if (phone_feature( pDph_t,  pDph_t->symbols[nextvowel]) & FVOWEL)
; 504  : 				{
; 505  : 					tmp = pDph_t->symbols[n];
; 506  : 					for (ntmp = n; ntmp < (nextvowel - 1); ntmp++)
; 507  : 					{
; 508  : 						pDph_t->symbols[ntmp]  = pDph_t->symbols[ntmp + 1];
; 509  : 					}
; 510  : 					pDph_t->symbols[nextvowel - 1] = tmp;
; 511  : 					n = nextvowel;	   /* done to this point so jump ahead */
; 512  : 					break;
; 513  : 				}
; 514  : 			}
; 515  : 		}
; 516  : 	}
; 517  : 
; 518  : #endif /* #ifdef GERMAN */
; 519  : 
; 520  : 
; 521  : 	for (n = 0; n < pDph_t->nsymbtot; n++)

  001f3	33 c9		 xor	 ecx, ecx
  001f5	89 4c 24 10	 mov	 DWORD PTR _n$[esp+56], ecx
  001f9	66 39 9e 82 17
	00 00		 cmp	 WORD PTR [esi+6018], bx
  00200	0f 8e c6 03 00
	00		 jle	 $L71605
$L71603:

; 522  : 	{
; 523  : 		if (pDphsettar->did_del)

  00206	8b 45 1c	 mov	 eax, DWORD PTR [ebp+28]
  00209	85 c0		 test	 eax, eax
  0020b	74 10		 je	 SHORT $L71606

; 524  : 		{
; 525  : 			n--;					   /* delete was done so back up one to process shifted phoneme eab */

  0020d	49		 dec	 ecx
  0020e	89 4c 24 10	 mov	 DWORD PTR _n$[esp+56], ecx

; 526  : 			pDphsettar->did_del = 0;

  00212	c7 45 1c 00 00
	00 00		 mov	 DWORD PTR [ebp+28], 0
  00219	8b 4c 24 10	 mov	 ecx, DWORD PTR _n$[esp+56]
$L71606:

; 527  : 			/* del_cnt++; *//* MVP : Value is never used */
; 528  : 		}
; 529  : 
; 530  : #ifdef GERMAN
; 531  : 						
; 532  : 						
; 533  : 						if((n > 1)&& (pDph_t->symbols[n] ) >= WBOUND
; 534  : 							&& (pDph_t->symbols[n]  <= RELSTART ))
; 535  : 							
; 536  : 							//if (phone_feature(pDph_t, pDph_t->symbols[n-1]) & FSONOR)		/* RSM */
; 537  : 							//{																/* RSM */
; 538  : 								for (nextthing = n+1; nextthing < pDph_t->nsymbtot; nextthing++)
; 539  : 								{	
; 540  : 									if ( (pDph_t->symbols[nextthing] & PVALUE) < 100)
; 541  : 									{
; 542  : 										// y wbound y where y==y then we need a glottal stop to indicate wbound
; 543  : 										// or if followed by a sonorant
; 544  : 										//if((pDph_t->symbols[n-1] == pDph_t->symbols[nextthing])						/* RSM */
; 545  : 										//	||( (pDph_t->symbols[n-1] == GRP_R || pDph_t->symbols[n-1] == GRP_RR) &&	/* RSM */
; 546  : 										//	(phone_feature(pDph_t,pDph_t->symbols[nextthing])&FSONOR )))				/* RSM */
; 547  : 										if((pDph_t->symbols[n-1] == pDph_t->symbols[nextthing])						/* RSM */
; 548  : 											||	(phone_feature(pDph_t,pDph_t->symbols[n-1])&FVOICD ) &&
; 549  : 											(phone_feature(pDph_t,pDph_t->symbols[nextthing])&FVOICD))
; 550  : 										{
; 551  : 											insertphone (phTTS, (short) (n+1), GRP_Q);	
; 552  : 										}
; 553  : 										break;
; 554  : 										
; 555  : 									}
; 556  : 									
; 557  : 								//} /* RSM */
; 558  : 							}
; 559  : 							
; 560  : 
; 561  : #endif
; 562  : 
; 563  : #ifdef GERMAN //eab feb needs to be verified but no one available. saw in norbert gewaschen
; 564  : 			if( pDph_t->symbols[n] == GRP_S && pDph_t->symbols[n+1] == GRP_CH)
; 565  : 			{
; 566  : 				pDph_t->symbols[n + 1] = GRP_S;
; 567  : 			}
; 568  : 
; 569  : 
; 570  : 			if( pDph_t->symbols[n] == GRP_TS && pDph_t->symbols[n+1] == GRP_S)
; 571  : 			{
; 572  : 				delete_symbol (phTTS, n);
; 573  : 			}
; 574  : 
; 575  : #endif
; 576  : 
; 577  : 
; 578  : 
; 579  : #ifdef GERMAN
; 580  : // Solution of trilled R not allows Ng to function properly so I removed substitution this is better
; 581  : 		//eab 6/9/98
; 582  : 				/*EAB 3/25/98 try using p+ f to imitate pf*/
; 583  : 		if ((pDph_t->symbols[n] ) == GRP_PF)
; 584  : 			
; 585  : 			{
; 586  : 				pDph_t->symbols[n]  = ( GRP_P);
; 587  : 				insertphone (phTTS, (short)(n+1), ( GRP_F)); // NAL warning removal
; 588  : 					/* 12/10/1996 EDB */
; 589  : 				n++;
; 590  : 			}
; 591  : 				/* eab 3/120/98 Make final S much longer by inserting another S
; 592  : 		 if word final position in a stressed word 7/28/98 appears to have too much affect
; 593  : 		 I thought it one was suppose to be shortened-out until interact review with oliver*/
; 594  : 		if (pDph_t->symbols[n] == WBOUND )
; 595  : 		{
; 596  : 
; 597  : 			if( pDph_t->symbols[n-1] == GRP_S && pDph_t->Word_has_stress == 1)
; 598  : 			{
; 599  : 			/*	insertphone (phTTS, (n-1), S);*/
; 600  : 				n++;
; 601  : 			}
; 602  : 			pDph_t->Word_has_stress = 0; //clear word stress flag eab 3/27/98
; 603  : 			pDph_t->number_fsyls  = 0; //clear numberfylls eab 4/2/98
; 604  : 		}					
; 605  : 
; 606  : 			
; 607  : 		
; 608  : 		/* eab 11/95 and add glotal bewteen vowels in a word */
; 609  : 		/* redo code later for clealiness 12/16/96 out*/
; 610  : 		if(n >0)
; 611  : 		{
; 612  : 		if (phone_feature( pDph_t,  pDph_t->symbols[n - 1]) & FVOWEL)
; 613  : 		{
; 614  : 			ntmp = n;
; 615  : 			/* step past any non-phonemes such as stress */
; 616  : 			while ((pDph_t->symbols[tmp] & PVALUE) > 100 && ntmp < pDph_t->nsymbtot)
; 617  : 			{
; 618  : 				ntmp++;
; 619  : 			}
; 620  : 			
; 621  : 		}
; 622  : 		} //n>0
; 623  : #endif /* #ifdef GERMAN */
; 624  : 		
; 625  : 	
; 626  : #ifdef SPANISH_SP
; 627  : 		/* kludge we need to have a word boundary at the begiining to make things
; 628  : 		coding more straight forward n=0 is becuase of no inital wbound.*/
; 629  : 		if (pDph_t->symbols[n] == WBOUND || n==0)
; 630  : 		{
; 631  : 			/* allophonic rule for grapheme Y->e 
; 632  : 			before an I as in Y india pronounced e india */
; 633  : 			if((pDph_t->symbols[n+1] == SPP_I)
; 634  : 				&& (pDph_t->symbols[n+2] == WBOUND))
; 635  : 			{
; 636  : 			/*then look ahead to see if the 
; 637  : 			  next real phoneme is the vowel SPP_I*/
; 638  : 				ntmp = n+2;
; 639  : 			/* step past any non-phonemes such as stress*/
; 640  : 				while ( ((pDph_t->symbols[tmp] & PVALUE) > 100 ||
; 641  : 					(pDph_t->symbols[tmp] & PVALUE)==SPP_Q )
; 642  : 					&& ntmp < pDph_t->nsymbtot)
; 643  : 				{
; 644  : 					ntmp++;
; 645  : 				}
; 646  : 				/* Is next thing a the vowel*/
; 647  : 				if ((pDph_t->symbols[tmp] /*& PVALUE*/) == SPP_I)	
; 648  : 				{
; 649  : 					pDph_t->symbols[n+1]=SPP_E;
; 650  : 				}
; 651  : 			}
; 652  : 			/* allophonic rule for "or" O->e
; 653  : 			before an I as in Y india pronounced e india*/
; 654  : 			if((pDph_t->symbols[n+2] == SPP_O)
; 655  : 			 && (pDph_t->symbols[n+3] == WBOUND))
; 656  : 			{
; 657  : 			/* then look ahead to see if the next real phoneme is the vowel SPP_I*/
; 658  : 				ntmp = n+3;
; 659  : 			/* step past any non-phonemes such as stress */
; 660  : 				while ( ((pDph_t->symbols[tmp] & PVALUE) > 100 ||
; 661  : 					(pDph_t->symbols[tmp]) == SPP_Q )
; 662  : 					&& ntmp < pDph_t->nsymbtot)
; 663  : 				{
; 664  : 					ntmp++;
; 665  : 				}
; 666  : 			    /* Is next thing SPP_O */
; 667  : 				if ((pDph_t->symbols[tmp]) == SPP_O)		
; 668  : 				{
; 669  : 					pDph_t->symbols[n+2]=SPP_U;
; 670  : 				}
; 671  : 			}
; 672  : 				
; 673  : 			
; 674  : #ifdef BOOK_SAYS_DIFFERENT
; 675  : 			// from previous input perhaps a castillion/latin difference or
; 676  : 			// maybe anna was wrong/anglicanixzed
; 677  : 		    /* 12/27/96 EAB insert a glotal stop bewteen s#s V#s and s#v and 
; 678  : 			   Juan would like it with sonor #sonor  */
; 679  : 			if(pDph_t->symbols[n-1] == SPP_S || pDph_t->symbols[n-1] == SPP_TH)
; 680  : 			{
; 681  : 				ntmp = n;
; 682  : 				/* step past any non-phonemes such as stress */
; 683  : 				while((pDph_t->symbols[ntmp] & PVALUE) > 100 && ntmp < pDph_t->nsymbtot)
; 684  : 				{
; 685  : 					ntmp++;
; 686  : 				}
; 687  : 				/* If next thing an S use sil instead of  a voiced
; 688  : 				glotal stop*/
; 689  : 				if((pDph_t->symbols[ntmp] ) == SPP_S || (pDph_t->symbols[ntmp] ) == SPP_TH)
; 690  : 				{
; 691  : 					insertphone(phTTS, n, GEN_SIL);
; 692  : 					n=ntmp;
; 693  : 				}
; 694  : 
; 695  : 				/* Is next thing a vowel*/
; 696  : 				else if (phone_feature( pDph_t,  (pDph_t->symbols[tmp] & PVALUE)] & FVOWEL	)
; 697  : 				{
; 698  : 					if((pDph_t->wordclass[n] & 0x020))
; 699  : 						insertphone (phTTS, n, SPP_Q);
; 700  : 					/* BATS 677 Found another spot it was doing it wrong
; 701  : 					EAB 5/18/98 */
; 702  : 					if(!(pDph_t->wordclass[n-1] & 0x00800000)
; 703  : 						&& !(pDph_t->wordclass[n+1] & 0x00800000))
; 704  : 					{
; 705  : 						insertphone (phTTS, n, SPP_Q);
; 706  : 					/* 12/10/1996 EDB */
; 707  : 					n=ntmp;
; 708  : 					}
; 709  : 				}
; 710  : 			}
; 711  : 				else if(phone_feature( pDph_t,  pDph_t->symbols[n-1]] & FSONOR)
; 712  : 			{
; 713  : 				ntmp = n;
; 714  : 				/* step past any non-phonemes such as stress */
; 715  : 				while ((pDph_t->symbols[tmp] & PVALUE) > 100 && ntmp < pDph_t->nsymbtot)
; 716  : 				{
; 717  : 					ntmp++;
; 718  : 				}
; 719  : 				/* Is next thing an s or a vowel i.e. vowel wbound vowel gets a glotal also 
; 720  : 				BATS 677 EAB 5/18/98 */
; 721  : 				if (phone_feature( pDph_t,  (pDph_t->symbols[tmp] & PVALUE)] & FSONOR
; 722  : 					|| 	(pDph_t->symbols[tmp]) == SPP_S || (pDph_t->symbols[tmp]) == SPP_TH)
; 723  : 				{
; 724  : 					/*last phoneme of word equals next phoneme so glotal stop it*/
; 725  : 					if(pDph_t->symbols[n-1]==(pDph_t->symbols[tmp] & PVALUE))
; 726  : 					{
; 727  : 						insertphone (phTTS, n, SPP_Q);
; 728  : 					}
; 729  : 			/* BATS 674 Should be inserting a glotal stop not silence eab 5/13/98*/
; 730  : 			/* now trying to refine so that we don't put in tooo many glotal stops
; 731  : 			but we must be careful because we can cause confusion eab 8/7/98 */
; 732  : 					
; 733  : 
; 734  : 			/* BATS 677 Found another spot it was doing it wrong
; 735  : 			EAB 5/18/98 EAB Found a behavior problem because N+1 can be end
; 736  : 			marker with no silence at the end yet */
; 737  : 
; 738  : 					else if(n>0 && !(pDph_t->wordclass[n-1] & 0x00800000))
; 739  : 					{
; 740  : 						if((pDph_t->symbols[n+1]& PVALUE) != GEN_SIL  )
; 741  : 							if( !((pDph_t->symbols[n+1]& PVALUE) >= 115
; 742  : 								&& (pDph_t->symbols[n+1]& PVALUE) <= 118))
; 743  : 							insertphone (phTTS, n, SPP_Q);
; 744  : 
; 745  : 					/* 12/10/1996 EDB */
; 746  : 					}
; 747  : 					n=ntmp;
; 748  : 				}
; 749  : 			}
; 750  : #endif
; 751  : 							
; 752  : 		}
; 753  : #endif // SPANSIH_SP
; 754  : 		
; 755  : #ifdef SPANISH_LA
; 756  : 		/* kludge we need to have a word boundary at the begiining to make things
; 757  : 		coding more straight forward n=0 is becuase of no inital wbound.*/
; 758  : 		if (pDph_t->symbols[n] == WBOUND || n==0)
; 759  : 		{
; 760  : 			/* allophonic rule for grapheme Y->e 
; 761  : 			before an I as in Y india pronounced e india */
; 762  : 			if((pDph_t->symbols[n+1] == LAP_I)
; 763  : 				&& (pDph_t->symbols[n+2] == WBOUND))
; 764  : 			{
; 765  : 			/*then look ahead to see if the 
; 766  : 			  next real phoneme is the vowel LAP_I*/
; 767  : 				ntmp = n+2;
; 768  : 			/* step past any non-phonemes such as stress*/
; 769  : 				while ( ((pDph_t->symbols[tmp] & PVALUE) > 100 ||
; 770  : 					(pDph_t->symbols[tmp])==LAP_Q )
; 771  : 					&& ntmp < pDph_t->nsymbtot)
; 772  : 				{
; 773  : 					ntmp++;
; 774  : 				}
; 775  : 				/* Is next thing a the vowel*/
; 776  : 				if ((pDph_t->symbols[tmp]) == LAP_I)		
; 777  : 				{
; 778  : 					pDph_t->symbols[n+1]=LAP_E;
; 779  : 				}
; 780  : 			}
; 781  : 			/* allophonic rule for "or" O->e
; 782  : 			before an I as in Y india pronounced e india*/
; 783  : 			if((pDph_t->symbols[n+2] == LAP_O)
; 784  : 			 && (pDph_t->symbols[n+3] == WBOUND))
; 785  : 			{
; 786  : 			/* then look ahead to see if the next real phoneme is the vowel LAP_I*/
; 787  : 				ntmp = n+3;
; 788  : 			/* step past any non-phonemes such as stress */
; 789  : 				while ( ((pDph_t->symbols[tmp] & PVALUE) > 100 ||
; 790  : 					(pDph_t->symbols[tmp]) == LAP_Q )
; 791  : 					&& ntmp < pDph_t->nsymbtot)
; 792  : 				{
; 793  : 					ntmp++;
; 794  : 				}
; 795  : 			    /* Is next thing LAP_O */
; 796  : 				if ((pDph_t->symbols[tmp]) == LAP_O)		
; 797  : 				{
; 798  : 					pDph_t->symbols[n+2]=LAP_U;
; 799  : 				}
; 800  : 			}
; 801  : 				
; 802  : 			
; 803  : #ifdef BOOK_SAYS_DIFFERENT
; 804  : 			// from previous input perhaps a castillion/latin difference or
; 805  : 			// maybe anna was wrong/anglicanixzed
; 806  : 		    /* 12/27/96 EAB insert a glotal stop bewteen s#s V#s and s#v and 
; 807  : 			   Juan would like it with sonor #sonor  */
; 808  : 			if(pDph_t->symbols[n-1] == LAP_S || pDph_t->symbols[n-1] == LAP_TH)
; 809  : 			{
; 810  : 				ntmp = n;
; 811  : 				/* step past any non-phonemes such as stress */
; 812  : 				while((pDph_t->symbols[tmp] & PVALUE) > 100 && ntmp < pDph_t->nsymbtot)
; 813  : 				{
; 814  : 					ntmp++;
; 815  : 				}
; 816  : 				/* If next thing an S use sil instead of  a voiced
; 817  : 				glotal stop*/
; 818  : 				if((pDph_t->symbols[tmp]) == LAP_S || (pDph_t->symbols[tmp]) == LAP_TH)
; 819  : 				{
; 820  : 					insertphone(phTTS, n, GEN_SIL);
; 821  : 					n=ntmp;
; 822  : 				}
; 823  : 
; 824  : 				/* Is next thing a vowel*/
; 825  : 				else if (phone_feature( pDph_t,  (pDph_t->symbols[tmp] & PVALUE)] & FVOWEL	)
; 826  : 				{
; 827  : 					if((pDph_t->wordclass[n] & 0x020))
; 828  : 						insertphone (phTTS, n, LAP_Q);
; 829  : 					/* BATS 677 Found another spot it was doing it wrong
; 830  : 					EAB 5/18/98 */
; 831  : 					if(!(pDph_t->wordclass[n-1] & 0x00800000)
; 832  : 						&& !(pDph_t->wordclass[n+1] & 0x00800000))
; 833  : 					{
; 834  : 						insertphone (phTTS, n, LAP_Q);
; 835  : 					/* 12/10/1996 EDB */
; 836  : 					n=ntmp;
; 837  : 					}
; 838  : 				}
; 839  : 			}
; 840  : 				else if(phone_feature( pDph_t,  pDph_t->symbols[n-1]] & FSONOR)
; 841  : 			{
; 842  : 				ntmp = n;
; 843  : 				/* step past any non-phonemes such as stress */
; 844  : 				while ((pDph_t->symbols[tmp] & PVALUE) > 100 && ntmp < pDph_t->nsymbtot)
; 845  : 				{
; 846  : 					ntmp++;
; 847  : 				}
; 848  : 				/* Is next thing an s or a vowel i.e. vowel wbound vowel gets a glotal also 
; 849  : 				BATS 677 EAB 5/18/98 */
; 850  : 				if (phone_feature( pDph_t,  (pDph_t->symbols[tmp] & PVALUE)] & FSONOR
; 851  : 					|| 	(pDph_t->symbols[tmp]) == LAP_S || (pDph_t->symbols[tmp]) == LAP_TH)
; 852  : 				{
; 853  : 					/*last phoneme of word equals next phoneme so glotal stop it*/
; 854  : 					if(pDph_t->symbols[n-1]==(pDph_t->symbols[tmp] & PVALUE))
; 855  : 					{
; 856  : 						insertphone (phTTS, n, LAP_Q);
; 857  : 					}
; 858  : 			/* BATS 674 Should be inserting a glotal stop not silence eab 5/13/98*/
; 859  : 			/* now trying to refine so that we don't put in tooo many glotal stops
; 860  : 			but we must be careful because we can cause confusion eab 8/7/98 */
; 861  : 					
; 862  : 
; 863  : 			/* BATS 677 Found another spot it was doing it wrong
; 864  : 			EAB 5/18/98 EAB Found a behavior problem because N+1 can be end
; 865  : 			marker with no silence at the end yet */
; 866  : 
; 867  : 					else if(n>0 && !(pDph_t->wordclass[n-1] & 0x00800000))
; 868  : 					{
; 869  : 						if(pDph_t->symbols[n+1] & PVALUE) != GEN_SIL  )
; 870  : 							if( !((pDph_t->symbols[n+1] & PVALUE) >= 115
; 871  : 								&& (pDph_t->symbols[n+1]& PVALUE) <= 118))
; 872  : 							insertphone (phTTS, n, LAP_Q);
; 873  : 
; 874  : 					/* 12/10/1996 EDB */
; 875  : 					}
; 876  : 					n=ntmp;
; 877  : 				}
; 878  : 			}
; 879  : #endif
; 880  : 							
; 881  : 		}
; 882  : #endif// SPANISH_LA
; 883  : 
; 884  : #ifdef GERMAN
; 885  : 
; 886  : 		/* code to insert a secondary stress in a polysyllabic or compound word on the second +syl after
; 887  :            a stress*/
; 888  : 		if(pDph_t->Word_has_stress == 1)
; 889  : 		{
; 890  : 			if ((phone_feature( pDph_t,  pDph_t->symbols[n]) & FSYLL)IS_PLUS)
; 891  : 			{
; 892  : 				pDph_t->number_fsyls++;
; 893  : 				if(pDph_t->number_fsyls == 4)
; 894  : 				{
; 895  : 					insertphone (phTTS, n, S2);
; 896  : 	
; 897  : 				}
; 898  : 			}
; 899  : 		}
; 900  : 
; 901  : 
; 902  : 		if (pDph_t->symbols[n] == S1 )
; 903  : 		{
; 904  : 				pDph_t->Word_has_stress =1; // eab 3/37 /98 set word stress marker
; 905  : 		
; 906  : 				if(compound_destress)
; 907  : 				{
; 908  : 					/* xxx new code to do compound destress correctly eab 8/94 */
; 909  : 					pDph_t->symbols[n] = S2;
; 910  : 					compound_destress = FALSE;
; 911  : 				}
; 912  : 		}
; 913  : 
; 914  : 
; 915  : 
; 916  : #endif
; 917  : 		
; 918  : 
; 919  : #ifdef ENGLISH_UK
; 920  : 		/* linking r rule 12/3/97 eab*/
; 921  : 		if ((pDph_t->symbols[n] ) == LINKRWORD)
; 922  : 		{
; 923  : 		/*EAB This is new code to tell when to drop the final R. The LINKRWORD tells us
; 924  : 			that it's a candididate for liason but we need to look at the ending because it could
; 925  : 			have s suffix. If it does end in R and the next word doesn't begin with a vowel we can
; 926  : 			drop it*/
; 927  : 			Ge_ma_found_r=0;
; 928  : 			ntmp=n+1;
; 929  : 			while ((pDph_t->symbols[ntmp] & PVALUE) <= MBOUND )
; 930  : 				{
; 931  : 					if((pDph_t->symbols[ntmp] ) == UKP_R )
; 932  : 					{
; 933  : 						//we move up through the word and didn't find an "R" even though
; 934  : 						//there should be by verture of linkrword
; 935  : 						//This is a dictioary or letter to sound error conition so punt
; 936  : 						// EAB 1/19/99  BATS 855
; 937  : 						Ge_ma_found_r=1;
; 938  : 						ntmpr=ntmp;
; 939  : 					}
; 940  : 					ntmp++;
; 941  : 				}
; 942  : 
; 943  : 				ntmp++; //move pointer to "thing follwoing r				
; 944  : 				if(Ge_ma_found_r==1) //protection code it souhld always find a n R
; 945  : 				{
; 946  : 					//move pointer to next valid phoneme
; 947  : 					while ((pDph_t->symbols[ntmp] & PVALUE) >= 100 && ntmp <= (pDph_t->nsymbtot-2))
; 948  : 					{
; 949  : 						ntmp++;
; 950  : 					}
; 951  : 		
; 952  : 				// BATS 590*/
; 953  : 		
; 954  : 					//If next thing a vowel don't delete it 
; 955  : 					// BATS 590 if it is the suffex ED (ix d) 
; 956  : 					// or S (z phoneme) then don't delete the r 
; 957  : 
; 958  : 					//This thing (BATS 590) doesn't make sense and we don't understand
; 959  : 					//exactly what it should be doing so ginger and I have eliminated
; 960  : 					//it. It wasn't firing because in these case the lts wasn't sending 
; 961  : 					//nor the r the ix d suffix  anyway
; 962  : 	
; 963  : 				//The pDph_t->symbols[ntmp] > 100 is becuase featb is yeilding a negative
; 964  : 				// number insetad of zero like it should (featb out of phedit not correct
; 965  : 				
; 966  : 				if ((pDph_t->symbols[ntmp] & PVALUE) > 100 || !(phone_feature( pDph_t,  pDph_t->symbols[ntmp ]) & FVOWEL))
; 967  : 				{
; 968  : 
; 969  : 					delete_symbol (phTTS, ntmpr);
; 970  : 				}
; 971  : 					
; 972  : 
; 973  : 				}
; 974  : 				
; 975  : 			}
; 976  : 		
; 977  : 			
; 978  : #endif
; 979  : 		
; 980  : #if defined ENGLISH || defined SPANISH 
; 981  : 
; 982  : 		/* xxx new code to do compound destress correctly eab 8/94 */
; 983  : 		if (pDph_t->symbols[n] == HYPHEN)

  0021d	0f bf d1	 movsx	 edx, cx
  00220	8d 84 56 26 15
	00 00		 lea	 eax, DWORD PTR [esi+edx*2+5414]
  00227	66 8b 94 56 26
	15 00 00	 mov	 dx, WORD PTR [esi+edx*2+5414]
  0022f	66 83 fa 6e	 cmp	 dx, 110			; 0000006eH
  00233	75 08		 jne	 SHORT $L71607

; 984  : 		{
; 985  : 			compound_destress = TRUE;

  00235	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _compound_destress$[esp+56], 1
$L71607:

; 986  : 		}
; 987  : 
; 988  : 		if (pDph_t->symbols[n] == S1 && compound_destress)

  0023d	66 83 fa 67	 cmp	 dx, 103			; 00000067H
  00241	75 19		 jne	 SHORT $L71608
  00243	66 83 7c 24 18
	00		 cmp	 WORD PTR _compound_destress$[esp+56], 0
  00249	74 11		 je	 SHORT $L71608

; 989  : 			/* xxx new code to do compound destress correctly eab 8/94 */
; 990  : 		{
; 991  : 			pDph_t->symbols[n] = S2;

  0024b	66 c7 00 66 00	 mov	 WORD PTR [eax], 102	; 00000066H

; 992  : 			compound_destress = FALSE;

  00250	8b 4c 24 10	 mov	 ecx, DWORD PTR _n$[esp+56]
  00254	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _compound_destress$[esp+56], 0
$L71608:

; 993  : 		}
; 994  : 
; 995  : 		if (pDph_t->symbols[n] == SPECIALWORD)

  0025c	0f bf c1	 movsx	 eax, cx
  0025f	66 83 bc 46 26
	15 00 00 78	 cmp	 WORD PTR [esi+eax*2+5414], 120 ; 00000078H
  00268	75 12		 jne	 SHORT $L71609

; 996  : 		{
; 997  : #ifdef SPANISH
; 998  : 			if (phrase_after_quote)
; 999  : 			{
; 1000 : 				pDph_t->special_phrase = 1;
; 1001 : 			}
; 1002 : 			phrase_after_quote = 0;
; 1003 : #endif
; 1004 : 			delete_symbol (phTTS, n);

  0026a	51		 push	 ecx
  0026b	8b 4c 24 40	 mov	 ecx, DWORD PTR _phTTS$[esp+56]
  0026f	51		 push	 ecx
  00270	e8 00 00 00 00	 call	 _delete_symbol
  00275	8b 4c 24 18	 mov	 ecx, DWORD PTR _n$[esp+64]
  00279	83 c4 08	 add	 esp, 8
$L71609:

; 1005 : 		}
; 1006 : 
; 1007 : #ifdef SPANISH
; 1008 : 		/* EAB I known this code is ugly but it's to recognize that the i
; 1009 : 		in numbers generated but the number routines is the functor i  and
; 1010 : 		the wordclass info has to be marked 
; 1011 : 		eab 9/4/98 is really wb-i-wb with not stress mark it a functor */
; 1012 : 
; 1013 : #ifdef SPANISH_SP
; 1014 : 		if((pDph_t->symbols[n]) == SPP_I)
; 1015 : #endif
; 1016 : #ifdef SPANISH_LA
; 1017 : 		if((pDph_t->symbols[n]) == LAP_I)
; 1018 : #endif
; 1019 : 		{
; 1020 : 			if ((pDph_t->symbols[n - 1] & PVALUE) == WBOUND
; 1021 : 				&& (pDph_t->symbols[n + 1] & PVALUE)== WBOUND)
; 1022 : 			{
; 1023 : 				pDph_t->wordclass[n] |= 0x00800000;
; 1024 : 			}
; 1025 : 		}
; 1026 : 		/* Move identiical phones seperated by 
; 1027 : 		a wbound code to PH_timing so we can control duration*/
; 1028 : 	
; 1029 : 
; 1030 : 
; 1031 : #endif	// SPANISH
; 1032 : 		if (pKsd_t->halting)

  0027c	8b 54 24 24	 mov	 edx, DWORD PTR _pKsd_t$[esp+56]
  00280	8b 82 34 03 00
	00		 mov	 eax, DWORD PTR [edx+820]
  00286	85 c0		 test	 eax, eax
  00288	0f 85 4a 08 00
	00		 jne	 $L71863

; 1033 : 			return (FALSE);
; 1034 : #ifdef DEBUGIND
; 1035 : 		printf ("(pDph_t->symbols[n] & PVALUE) =	%d n=%d \n", (pDph_t->symbols[n] & PVALUE), n);
; 1036 : #endif                
; 1037 : #endif /* #if defined ENGLISH || defined SPANISH */
; 1038 : 		/* Check for user F0 commands in input string for this clause     */
; 1039 : 
; 1040 : 		/* RULES for input of a user f0 command                   */
; 1041 : 		/* 1. If no f0 commands in input, set f0mode = NORMAL     */
; 1042 : 		/* 2. If explicit [/] or [\] phonemes in input,           */
; 1043 : 		/* set f0mode = HAT_LOCATIONS_SPECIFIED           		  */
; 1044 : 		/* 3. If first f0 command is attached to phoneme and has  */
; 1045 : 		/* value <= 37, set f0mode = SINGING                      */
; 1046 : 		/* 4. If first f0 command is attached to phoneme and has  */
; 1047 : 		/* value > 37, set f0mode = PHONE_TARGETS_SPECIFIED       */
; 1048 : 		/* 5. If first f0 command is attached to non-phoneme ['], */
; 1049 : 		/* [/], or [\], set f0mode = HAT_F0_SIZES_SPECIFIED       */
; 1050 : 		/* NOTE cases are mutually exclusive except 2&5 so all    */
; 1051 : 		/* f0 commands must be of same category within clause 	  */
; 1052 : 
; 1053 : 		/* RULES for interpretation of user f0 commands           */
; 1054 : 		/* SINGING:  e.g. [a<500,22>].                            */
; 1055 : 		/* If duration attached to phoneme, convert to frames     */
; 1056 : 		/* If note number attached to phoneme, convert to Hz      */
; 1057 : 		/* Go to new note linearly in freq over 160 ms, start     */
; 1058 : 		/* at begin time of phoneme.                              */
; 1059 : 		/* Add vibratto of +/-1.8 Hz, at 6.5 Hz repetition rate   */
; 1060 : 		/* PHONE_TARGETS_SPECIFIED:  e.g. [a<,125>]               */
; 1061 : 		/* If duration attached to phoneme, convert to frames     */
; 1062 : 		/* If f0 target attached to phoneme, convert to Hz        */
; 1063 : 		/* Go to new f0 target linearly in freq over duration     */
; 1064 : 		/* of phoneme, start at beginning of phoneme              */
; 1065 : 		/* All Hz values are absolute, there is no spdef scaling  */
; 1066 : 		/* HAT_LOCATIONS_SPECIFIED:  e.g. [/'ab\a]                */
; 1067 : 		/* Example: hat rise on first stressed vowel (as is       */
; 1068 : 		/* usual in DECtalk), but fall on final unstressed V      */
; 1069 : 		/* Usual practice of Dectalk determining hat locations    */
; 1070 : 		/* is totally disabled, rises and falls occur only on     */
; 1071 : 		/* phone following the rise or fall symbol.               */
; 1072 : 		/* Phone following rise and/or fall must be +syllabic     */
; 1073 : 		/* or PHSORT will produce garbage                 		  */
; 1074 : 		/* Rise and fall pDph_t->symbols must alternate,          */
; 1075 : 		/* first is rise    									  */
; 1076 : 		/* If syllable will have rise, stress pulse, & fall, it   */
; 1077 : 		/* is best to specify them in that order, i.e. [/'\a] 	  */
; 1078 : 		/* HAT_F0_SIZES_SPECIFIED:  e.g. [/'<,12>\<,40>a]         */
; 1079 : 		/* Example: use normal hat rise, 12 Hz stress impulse,    */
; 1080 : 		/* and 40 Hz hat fall, times of events are normal 		  */
; 1081 : 		/* Disable prediction of where to insert hat rises &      */
; 1082 : 		/* falls if there are [/] and [\] pDph_t->symbols         */
; 1083 : 		/* present, or     										  */
; 1084 : 		/* if ['] has an attached user f0 command         		  */
; 1085 : 		/* Override computed values for hat rise, fall, and       */
; 1086 : 		/* stress pulses if a user-specified f0 command is        */
; 1087 : 		/* attached to [/], [\], or [']                   		  */
; 1088 : 		/* Continue to add continuation rises at commas and       */
; 1089 : 		/* add question intonation by rule                        */
; 1090 : 		/* If duration attached, it is time of f0 event onset     */
; 1091 : 		/* relative to onset of next phone (can be negative)      */
; 1092 : 		/* F0 targets attached to [/] are step rises, attached    */
; 1093 : 		/* to [\] are step falls, and attached to ['] are 		  */
; 1094 : 		/* stress impulses; amount is given in nominal Hz 		  */
; 1095 : 		/* All Hz values are subjected to spdef scalings  		  */
; 1096 : 		/* No more than one rise, one stress pulse and one fall   */
; 1097 : 		/* allowed on each vowel, in that order           		  */
; 1098 : 		if (((pDph_t->symbols[n]& PVALUE) >= HAT_RISE) && ((pDph_t->symbols[n] & PVALUE)<= HAT_RF))

  0028e	0f bf c1	 movsx	 eax, cx
  00291	66 8b 84 46 26
	15 00 00	 mov	 ax, WORD PTR [esi+eax*2+5414]
  00299	66 25 ff 00	 and	 ax, 255			; 000000ffH
  0029d	66 3d 69 00	 cmp	 ax, 105			; 00000069H
  002a1	7c 1d		 jl	 SHORT $L71612
  002a3	66 3d 6b 00	 cmp	 ax, 107			; 0000006bH
  002a7	7f 17		 jg	 SHORT $L71612

; 1099 : 		{
; 1100 : 			if (pDph_t->f0mode == NORMAL)

  002a9	66 83 be 9c 17
	00 00 01	 cmp	 WORD PTR [esi+6044], 1
  002b1	75 0d		 jne	 SHORT $L71612

; 1101 : 			{
; 1102 : 				pDph_t->f0mode = HAT_LOCATIONS_SPECIFIED;

  002b3	66 c7 86 9c 17
	00 00 02 00	 mov	 WORD PTR [esi+6044], 2
  002bc	8b 4c 24 10	 mov	 ecx, DWORD PTR _n$[esp+56]
$L71612:

; 1103 : 			}
; 1104 : 		}
; 1105 : 
; 1106 : 		/* Clause-final function word (preceded by [(]) should be stressed */
; 1107 : 		if (pDph_t->symbols[n] == PPSTART)

  002c0	0f bf d1	 movsx	 edx, cx
  002c3	66 83 bc 56 26
	15 00 00 70	 cmp	 WORD PTR [esi+edx*2+5414], 112 ; 00000070H
  002cc	0f 85 24 01 00
	00		 jne	 $L71625

; 1108 : 		{
; 1109 : 			/* Examine input for next bound, see if cbound or greater */
; 1110 : 			m = n + 1;

  002d2	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]

; 1111 : 			while (m < pDph_t->nsymbtot)

  002d5	66 3b be 82 17
	00 00		 cmp	 di, WORD PTR [esi+6018]
  002dc	0f 8d 14 01 00
	00		 jge	 $L71625
$L71615:

; 1112 : 			{
; 1113 : 				if (is_wboundary ( (short)(pDph_t->symbols[m] & PVALUE) ) )

  002e2	0f bf c7	 movsx	 eax, di
  002e5	8a 8c 46 26 15
	00 00		 mov	 cl, BYTE PTR [esi+eax*2+5414]
  002ec	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002f2	51		 push	 ecx
  002f3	e8 00 00 00 00	 call	 _is_wboundary
  002f8	83 c4 04	 add	 esp, 4
  002fb	85 c0		 test	 eax, eax
  002fd	75 0f		 jne	 SHORT $L71861

; 1174 : 						}
; 1175 : 					}
; 1176 : #endif /* #if defined ENGLISH || defined GERMAN */
; 1177 : #ifdef SPANISH
; 1178 : 					if ((pDph_t->symbols[m] & PVALUE) >= COMMA)
; 1179 : 					{
; 1180 : 						pDph_t->symbols[n]= S2;	   /* Replace [(] by [`]  */
; 1181 : 					}
; 1182 : 					/* Should be an insert instead   */
; 1183 : #endif /* #ifdef SPANISH */
; 1184 : 					break;
; 1185 : 				}
; 1186 : 
; 1187 : 				m++;

  002ff	47		 inc	 edi
  00300	66 3b be 82 17
	00 00		 cmp	 di, WORD PTR [esi+6018]
  00307	7c d9		 jl	 SHORT $L71615

; 1361 : /*#endif*/
; 1362 : 		if (pKsd_t->halting)

  00309	e9 e4 00 00 00	 jmp	 $L71872
$L71861:

; 1114 : 				{
; 1115 : #if defined ENGLISH || defined GERMAN
; 1116 : 					if (((pDph_t->symbols[m] & PVALUE) >= COMMA)
; 1117 : #ifdef ENGLISH
; 1118 : 						|| (((pDph_t->symbols[m] & PVALUE) == PPSTART) && (pDph_t->symbols[m + 1] != USP_W)))

  0030e	0f bf c7	 movsx	 eax, di
  00311	66 8b 8c 46 26
	15 00 00	 mov	 cx, WORD PTR [esi+eax*2+5414]
  00319	66 81 e1 ff 00	 and	 cx, 255			; 000000ffH
  0031e	66 83 f9 73	 cmp	 cx, 115			; 00000073H
  00322	7d 1a		 jge	 SHORT $L71620
  00324	66 83 f9 70	 cmp	 cx, 112			; 00000070H
  00328	0f 85 c4 00 00
	00		 jne	 $L71872
  0032e	66 81 bc 46 28
	15 00 00 18 1e	 cmp	 WORD PTR [esi+eax*2+5416], 7704 ; 00001e18H
  00338	0f 84 b4 00 00
	00		 je	 $L71872
$L71620:

; 1119 : #endif
; 1120 : #ifdef GERMAN
; 1121 : 						|| (((pDph_t->symbols[m] & PVALUE) == PPSTART)))
; 1122 : #endif
; 1123 : #ifdef FRENCH
; 1124 : 						|| (((pDph_t->symbols[m] & PVALUE) == PPSTART) && (pDph_t->symbols[m + 1] != US_W)))
; 1125 : #endif
; 1126 : 					{
; 1127 : 						pDph_t->symbols[n] = WBOUND;	/* Replace [(] by [ ] */

  0033e	0f bf 54 24 10	 movsx	 edx, WORD PTR _n$[esp+56]
  00343	66 c7 84 56 26
	15 00 00 6f 00	 mov	 WORD PTR [esi+edx*2+5414], 111 ; 0000006fH

; 1128 : 						/* Raise PPSTART to VPSTART to set off verbal particle */
; 1129 : 						if ((pDph_t->symbols[m] & PVALUE) == PPSTART)

  0034d	8a 8c 46 26 15
	00 00		 mov	 cl, BYTE PTR [esi+eax*2+5414]
  00354	80 f9 70	 cmp	 cl, 112			; 00000070H
  00357	75 0a		 jne	 SHORT $L71621

; 1130 : 						{
; 1131 : 							pDph_t->symbols[m]  = VPSTART;

  00359	66 c7 84 46 26
	15 00 00 71 00	 mov	 WORD PTR [esi+eax*2+5414], 113 ; 00000071H
$L71621:

; 1132 : 						}
; 1133 : 						/* Unreduce the vowel in "for, to, into" */
; 1134 : #ifdef ENGLISH_US
; 1135 : 						if ((pDph_t->symbols[n + 1] == USP_F) && (pDph_t->symbols[n + 2] == USP_RR))

  00363	8b 54 24 10	 mov	 edx, DWORD PTR _n$[esp+56]
  00367	0f bf ca	 movsx	 ecx, dx
  0036a	66 81 bc 4e 28
	15 00 00 25 1e	 cmp	 WORD PTR [esi+ecx*2+5416], 7717 ; 00001e25H
  00374	75 1a		 jne	 SHORT $L71622
  00376	66 81 bc 4e 2a
	15 00 00 0f 1e	 cmp	 WORD PTR [esi+ecx*2+5418], 7695 ; 00001e0fH
  00380	75 0e		 jne	 SHORT $L71622

; 1136 : 						{
; 1137 : 							pDph_t->symbols[n + 2] = USP_OR;

  00382	66 c7 84 4e 2a
	15 00 00 16 1e	 mov	 WORD PTR [esi+ecx*2+5418], 7702 ; 00001e16H
  0038c	8b 54 24 10	 mov	 edx, DWORD PTR _n$[esp+56]
$L71622:

; 1138 : 						}
; 1139 : 						if ((pDph_t->symbols[m - 2] == USP_T) && (pDph_t->symbols[m - 1] == USP_UH))

  00390	66 81 bc 46 22
	15 00 00 2f 1e	 cmp	 WORD PTR [esi+eax*2+5410], 7727 ; 00001e2fH
  0039a	75 1d		 jne	 SHORT $L71623
  0039c	66 81 bc 46 24
	15 00 00 0d 1e	 cmp	 WORD PTR [esi+eax*2+5412], 7693 ; 00001e0dH
  003a6	75 11		 jne	 SHORT $L71623

; 1140 : 						{
; 1141 : 							pDph_t->symbols[n + 2] = USP_UW;

  003a8	0f bf c2	 movsx	 eax, dx
  003ab	66 c7 84 46 2a
	15 00 00 0e 1e	 mov	 WORD PTR [esi+eax*2+5418], 7694 ; 00001e0eH
  003b5	8b 54 24 10	 mov	 edx, DWORD PTR _n$[esp+56]
$L71623:

; 1142 : 						}
; 1143 : #endif
; 1144 : #ifdef ENGLISH_UK
; 1145 : 						if ((pDph_t->symbols[n + 1] == UKP_F) && (pDph_t->symbols[n + 2] == UKP_RR))
; 1146 : 						{
; 1147 : 							pDph_t->symbols[n + 2] = UKP_OR;
; 1148 : 						}
; 1149 : 						if ((pDph_t->symbols[m - 2] == UKP_T) && (pDph_t->symbols[m - 1] == UKP_UH))
; 1150 : 						{
; 1151 : 							pDph_t->symbols[n + 2] = UKP_UW;
; 1152 : 						}
; 1153 : #endif
; 1154 : #ifdef FRENCH
; 1155 : 						if ((pDph_t->symbols[n + 1] == USP_F) && (pDph_t->symbols[n + 2] == USP_RR))
; 1156 : 						{
; 1157 : 							pDph_t->symbols[n + 2] = USP_OR;
; 1158 : 						}
; 1159 : 						if ((pDph_t->symbols[m - 2] == USP_T) && (pDph_t->symbols[m - 1] == USP_UH))
; 1160 : 						{
; 1161 : 							pDph_t->symbols[n + 2] = USP_UW;
; 1162 : 						}
; 1163 : #endif
; 1164 : 
; 1165 : 						/* Promote init secondary stress, or find V to stress */
; 1166 : 						if (pDph_t->symbols[n + 1] == S2)

  003b9	0f bf ca	 movsx	 ecx, dx
  003bc	66 83 bc 4e 28
	15 00 00 66	 cmp	 WORD PTR [esi+ecx*2+5416], 102 ; 00000066H
  003c5	8d 84 4e 28 15
	00 00		 lea	 eax, DWORD PTR [esi+ecx*2+5416]
  003cc	75 07		 jne	 SHORT $L71624

; 1167 : 						{
; 1168 : 							pDph_t->symbols[n + 1] = S1;	/* Replace [`] by ['] */

  003ce	66 c7 00 67 00	 mov	 WORD PTR [eax], 103	; 00000067H

; 1169 : 						}
; 1170 : 						else

  003d3	eb 1d		 jmp	 SHORT $L71872
$L71624:

; 1171 : 						{
; 1172 : 							insertphone (phTTS, (short)(n + 1), S1);		/* Insert dangling ['] */

  003d5	8b 7c 24 3c	 mov	 edi, DWORD PTR _phTTS$[esp+52]
  003d9	42		 inc	 edx
  003da	6a 67		 push	 103			; 00000067H
  003dc	52		 push	 edx
  003dd	57		 push	 edi
  003de	e8 00 00 00 00	 call	 _insertphone

; 1173 : 							move_stdangle (phTTS, (short)(n + 1) );	/* Move to right place */

  003e3	8b 54 24 1c	 mov	 edx, DWORD PTR _n$[esp+68]
  003e7	42		 inc	 edx
  003e8	52		 push	 edx
  003e9	57		 push	 edi
  003ea	e8 00 00 00 00	 call	 _move_stdangle
  003ef	83 c4 14	 add	 esp, 20			; 00000014H
$L71872:

; 1169 : 						}
; 1170 : 						else

  003f2	8b 4c 24 10	 mov	 ecx, DWORD PTR _n$[esp+56]
$L71625:

; 1188 : 			}
; 1189 : 		}
; 1190 : 
; 1191 : 		/* Look for dangling stress mark (i.e. not followed by +SYLL) */
; 1192 : #ifdef GERMAN
; 1193 : 		if (((pDph_t->symbols[n]& PVALUE) >= S3) && ((pDph_t->symbols[n]& PVALUE) <= HAT_RF))
; 1194 : #endif
; 1195 : #if defined ENGLISH || defined SPANISH 
; 1196 : 		if (((pDph_t->symbols[n]& PVALUE) >= S2) && ((pDph_t->symbols[n]& PVALUE) <= SEMPH))

  003f6	0f bf c1	 movsx	 eax, cx
  003f9	66 8b 94 46 26
	15 00 00	 mov	 dx, WORD PTR [esi+eax*2+5414]
  00401	8b c2		 mov	 eax, edx
  00403	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00408	66 3d 66 00	 cmp	 ax, 102			; 00000066H
  0040c	0f 8c 95 00 00
	00		 jl	 $stzapped$71634
  00412	66 3d 68 00	 cmp	 ax, 104			; 00000068H
  00416	0f 8f 8b 00 00
	00		 jg	 $stzapped$71634

; 1197 : #endif
; 1198 : 		{
; 1199 : 			/* if ((pDph_t->symbols[n] == S1) || (pDph_t->symbols[n] == SEMPH)) */ /* english */
; 1200 : 			if (pDph_t->symbols[n] != S2)		/* these are the same */		   /* spanish */

  0041c	66 83 fa 66	 cmp	 dx, 102			; 00000066H
  00420	74 01		 je	 SHORT $L71629

; 1201 : 			{
; 1202 : 				nstresses++;		   /* Count # stresses to this point */

  00422	43		 inc	 ebx
$L71629:

; 1203 : 			}
; 1204 : 			/* Examine following input for next segment, see if syllabic */
; 1205 : 			m = n + 1;

  00423	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]

; 1206 : 			while (((pDph_t->symbols[m] & PVALUE) >= MAX_PHONES) && (m < pDph_t->nsymbtot))

  00426	0f bf c2	 movsx	 eax, dx
  00429	66 8b 84 46 26
	15 00 00	 mov	 ax, WORD PTR [esi+eax*2+5414]
  00431	66 25 ff 00	 and	 ax, 255			; 000000ffH
  00435	66 3d 63 00	 cmp	 ax, 99			; 00000063H
  00439	7c 38		 jl	 SHORT $L71632
  0043b	66 8b be 82 17
	00 00		 mov	 di, WORD PTR [esi+6018]
$L71631:
  00442	66 3b d7	 cmp	 dx, di
  00445	7d 2c		 jge	 SHORT $L71632

; 1207 : 			{
; 1208 : #ifdef ENGLISH
; 1209 : 				if ((pDph_t->symbols[m] & PVALUE) > WBOUND && (pDph_t->symbols[m] & PVALUE) < NEW_PARAGRAPH
; 1210 : 					&& (pDph_t->symbols[m] & PVALUE) != HYPHEN /* xxx for auto compunds */ )

  00447	66 3d 6f 00	 cmp	 ax, 111			; 0000006fH
  0044b	7e 10		 jle	 SHORT $L71633
  0044d	66 3d 77 00	 cmp	 ax, 119			; 00000077H
  00451	7d 0a		 jge	 SHORT $L71633
  00453	66 3d 6e 00	 cmp	 ax, 110			; 0000006eH
  00457	0f 85 51 02 00
	00		 jne	 $L71862
$L71633:

; 1223 : 				}
; 1224 : 				m++;

  0045d	42		 inc	 edx
  0045e	0f bf c2	 movsx	 eax, dx
  00461	66 8b 84 46 26
	15 00 00	 mov	 ax, WORD PTR [esi+eax*2+5414]
  00469	66 25 ff 00	 and	 ax, 255			; 000000ffH
  0046d	66 3d 63 00	 cmp	 ax, 99			; 00000063H
  00471	7d cf		 jge	 SHORT $L71631
$L71632:

; 1225 : 			}
; 1226 : #ifndef GERMAN
; 1227 : 			if ((phone_feature( pDph_t,  pDph_t->symbols[m]) & FSYLL) IS_MINUS)

  00473	0f bf d2	 movsx	 edx, dx
  00476	0f bf 84 56 26
	15 00 00	 movsx	 eax, WORD PTR [esi+edx*2+5414]
  0047e	8b d0		 mov	 edx, eax
  00480	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00485	c1 fa 08	 sar	 edx, 8
  00488	8b 14 95 00 00
	00 00		 mov	 edx, DWORD PTR _all_featb[edx*4]
  0048f	f6 04 42 01	 test	 BYTE PTR [edx+eax*2], 1
  00493	75 12		 jne	 SHORT $stzapped$71634

; 1228 : 			{
; 1229 : 				move_stdangle (phTTS, n);

  00495	8b 44 24 3c	 mov	 eax, DWORD PTR _phTTS$[esp+52]
  00499	51		 push	 ecx
  0049a	50		 push	 eax
  0049b	e8 00 00 00 00	 call	 _move_stdangle
$L71889:
  004a0	8b 4c 24 18	 mov	 ecx, DWORD PTR _n$[esp+64]
  004a4	83 c4 08	 add	 esp, 8
$stzapped$71634:

; 1230 : 			}
; 1231 : #endif
; 1232 : 		}
; 1233 : 	  stzapped:
; 1234 : 
; 1235 : #if defined ENGLISH || defined GERMAN || defined FRENCH
; 1236 : 		/* Remove weaker of two boundary pDph_t->symbols in a row */
; 1237 : 		if (((pDph_t->symbols[n] & PVALUE) >= SBOUND) && ((pDph_t->symbols[n] & PVALUE) <= EXCLAIM))

  004a7	0f bf d1	 movsx	 edx, cx
  004aa	66 8b 84 56 26
	15 00 00	 mov	 ax, WORD PTR [esi+edx*2+5414]
  004b2	66 25 ff 00	 and	 ax, 255			; 000000ffH
  004b6	66 3d 6c 00	 cmp	 ax, 108			; 0000006cH
  004ba	7c 40		 jl	 SHORT $L71638
  004bc	66 3d 76 00	 cmp	 ax, 118			; 00000076H
  004c0	7f 3a		 jg	 SHORT $L71638

; 1238 : 		{
; 1239 : /* for (m=n+1; m<pDph_t->nsymbtot; m++) out-goofs up when trying to do all at once { */
; 1240 : #ifdef ENGLISH
; 1241 : 			m = n + 1;

  004c2	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]

; 1242 : 			if (m < pDph_t->nsymbtot)

  004c5	66 3b 96 82 17
	00 00		 cmp	 dx, WORD PTR [esi+6018]
  004cc	7d 2e		 jge	 SHORT $L71638

; 1243 : 			{
; 1244 : 				/* if ((pDph_t->symbols[m] & PVALUE) < TOT_ALLOPHONES)    break; */
; 1245 : 				if (((pDph_t->symbols[m] & PVALUE) >= SBOUND) && ((pDph_t->symbols[m] & PVALUE) <= EXCLAIM))

  004ce	0f bf c2	 movsx	 eax, dx
  004d1	66 8b 84 46 26
	15 00 00	 mov	 ax, WORD PTR [esi+eax*2+5414]
  004d9	66 25 ff 00	 and	 ax, 255			; 000000ffH
  004dd	66 3d 6c 00	 cmp	 ax, 108			; 0000006cH
  004e1	7c 19		 jl	 SHORT $L71638
  004e3	66 3d 76 00	 cmp	 ax, 118			; 00000076H
  004e7	7f 13		 jg	 SHORT $L71638

; 1246 : 				{
; 1247 : 					zap_weaker_bound (phTTS, n, m);

  004e9	52		 push	 edx
  004ea	51		 push	 ecx
  004eb	8b 4c 24 44	 mov	 ecx, DWORD PTR _phTTS$[esp+60]
  004ef	51		 push	 ecx
  004f0	e8 00 00 00 00	 call	 _zap_weaker_bound
  004f5	8b 4c 24 1c	 mov	 ecx, DWORD PTR _n$[esp+68]
  004f9	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71638:

; 1248 : 				}
; 1249 : 			}
; 1250 : #endif
; 1251 : #ifdef GERMAN
; 1252 : 			for (m = n + 1; m < pDph_t->nsymbtot; m++)
; 1253 : 			{
; 1254 : 				if ((pDph_t->symbols[m] & PVALUE) < GR_TOT_ALLOPHONES)
; 1255 : 					break;
; 1256 : 				if (((pDph_t->symbols[m] & PVALUE) >= SBOUND) && ((pDph_t->symbols[m] & PVALUE) <= EXCLAIM))
; 1257 : 				{
; 1258 : 					zap_weaker_bound (phTTS, n, m);
; 1259 : 				}
; 1260 : 			}
; 1261 : #endif
; 1262 : 		}
; 1263 : 			/* Replace weak boundaries by stronger ones at slow rates */
; 1264 : 		// EAB Caused bug in slow talk, this is too late to add a comma
; 1265 : 		// besides the new method of slowtalk is better.
; 1266 : 		
; 1267 : 		if (pKsd_t->sprate <= 140)

  004fc	8b 54 24 24	 mov	 edx, DWORD PTR _pKsd_t$[esp+56]
  00500	66 81 ba e6 03
	00 00 8c 00	 cmp	 WORD PTR [edx+998], 140	; 0000008cH
  00509	7f 1e		 jg	 SHORT $L71640

; 1268 : 		{
; 1269 : 			if (pDph_t->symbols[n] == PPSTART)

  0050b	0f bf c1	 movsx	 eax, cx
  0050e	66 83 bc 46 26
	15 00 00 70	 cmp	 WORD PTR [esi+eax*2+5414], 112 ; 00000070H
  00517	8d 84 46 26 15
	00 00		 lea	 eax, DWORD PTR [esi+eax*2+5414]
  0051e	75 09		 jne	 SHORT $L71640

; 1270 : 			{
; 1271 : 				pDph_t->symbols[n] = VPSTART;

  00520	66 c7 00 71 00	 mov	 WORD PTR [eax], 113	; 00000071H
  00525	8b 4c 24 10	 mov	 ecx, DWORD PTR _n$[esp+56]
$L71640:

; 1272 : 			}
; 1273 : 		}
; 1274 : 
; 1275 : #endif	/* #if defined ENGLISH || defined GERMAN*/
; 1276 : 
; 1277 : 		/* Every breath group must have at least one 1-stress */
; 1278 : 		if (((pDph_t->symbols[n]& PVALUE) >= COMMA) && ((pDph_t->symbols[n]& PVALUE) <= EXCLAIM))

  00529	0f bf d1	 movsx	 edx, cx
  0052c	66 8b 84 56 26
	15 00 00	 mov	 ax, WORD PTR [esi+edx*2+5414]
  00534	66 25 ff 00	 and	 ax, 255			; 000000ffH
  00538	66 3d 73 00	 cmp	 ax, 115			; 00000073H
  0053c	7c 2b		 jl	 SHORT $L71642
  0053e	66 3d 76 00	 cmp	 ax, 118			; 00000076H
  00542	7f 25		 jg	 SHORT $L71642

; 1279 : 		{
; 1280 : 
; 1281 : 			if ((n > 0) && (nstresses == 0))

  00544	66 85 c9	 test	 cx, cx
  00547	7e 20		 jle	 SHORT $L71642
  00549	66 85 db	 test	 bx, bx
  0054c	75 1b		 jne	 SHORT $L71642

; 1282 : 			{
; 1283 : 				find_syll_to_stress (phTTS, &n, nstartphrase);	/* MVP : was n and n was static */

  0054e	8b 44 24 20	 mov	 eax, DWORD PTR _nstartphrase$[esp+56]
  00552	8b 54 24 3c	 mov	 edx, DWORD PTR _phTTS$[esp+52]
  00556	8d 4c 24 10	 lea	 ecx, DWORD PTR _n$[esp+56]
  0055a	50		 push	 eax
  0055b	51		 push	 ecx
  0055c	52		 push	 edx
  0055d	e8 00 00 00 00	 call	 _find_syll_to_stress
  00562	8b 4c 24 1c	 mov	 ecx, DWORD PTR _n$[esp+68]
  00566	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71642:

; 1284 : #ifdef SPANISH
; 1285 : 				nstresses = 1;
; 1286 : #endif			
; 1287 : 			}
; 1288 : 		}
; 1289 : #if defined ENGLISH || defined GERMAN
; 1290 : 		/* Reset to new phrase if encounter [ } , . ? ! ] */
; 1291 : 		/* 
; 1292 : 		 * NOTE: Phoneme RELSTART = [}] not currently defined.  When it is, 
; 1293 : 		 * all words in FUNWRD1.DIC that introduce relative clauses, such as
; 1294 : 		 * "when, that, which" should have [}] symbol appended to front. 
; 1295 : 		 */
; 1296 : 		if (((pDph_t->symbols[n] & PVALUE) >= RELSTART) && ((pDph_t->symbols[n] & PVALUE) <= EXCLAIM))

  00569	0f bf c1	 movsx	 eax, cx
  0056c	66 8b 84 46 26
	15 00 00	 mov	 ax, WORD PTR [esi+eax*2+5414]
  00574	66 25 ff 00	 and	 ax, 255			; 000000ffH
  00578	66 3d 72 00	 cmp	 ax, 114			; 00000072H
  0057c	7c 0c		 jl	 SHORT $L71643
  0057e	66 3d 76 00	 cmp	 ax, 118			; 00000076H
  00582	7f 1a		 jg	 SHORT $L71644

; 1297 : 		{
; 1298 : 			nstresses = 0;

  00584	33 db		 xor	 ebx, ebx

; 1299 : 			nstartphrase = n;

  00586	89 4c 24 20	 mov	 DWORD PTR _nstartphrase$[esp+56], ecx
$L71643:

; 1300 : 		}
; 1301 : #endif
; 1302 : 		/* Exclamation point raises last stress of sentence to emphasis */
; 1303 : 		if ((pDph_t->symbols[n] & PVALUE) == EXCLAIM)

  0058a	66 3d 76 00	 cmp	 ax, 118			; 00000076H
  0058e	75 0e		 jne	 SHORT $L71644

; 1304 : 		{
; 1305 : 			raise_last_stress (pDph_t, n);

  00590	51		 push	 ecx
  00591	56		 push	 esi
  00592	e8 00 00 00 00	 call	 _raise_last_stress
  00597	8b 4c 24 18	 mov	 ecx, DWORD PTR _n$[esp+64]
  0059b	83 c4 08	 add	 esp, 8
$L71644:

; 1306 : 		}
; 1307 : 		/* Set varaible to indicate a question sentence */
; 1308 : 		if ((pDph_t->symbols[n] & PVALUE) == QUEST)

  0059e	0f bf d1	 movsx	 edx, cx
  005a1	80 bc 56 26 15
	00 00 75	 cmp	 BYTE PTR [esi+edx*2+5414], 117 ; 00000075H
  005a9	75 0d		 jne	 SHORT $L71604

; 1309 : 		{
; 1310 : 			pDph_t->cbsymbol = TRUE;

  005ab	66 c7 86 9e 17
	00 00 01 00	 mov	 WORD PTR [esi+6046], 1
  005b4	8b 4c 24 10	 mov	 ecx, DWORD PTR _n$[esp+56]
$L71604:
  005b8	41		 inc	 ecx
  005b9	89 4c 24 10	 mov	 DWORD PTR _n$[esp+56], ecx
  005bd	66 3b 8e 82 17
	00 00		 cmp	 cx, WORD PTR [esi+6018]
  005c4	0f 8c 3c fc ff
	ff		 jl	 $L71603

; 1361 : /*#endif*/
; 1362 : 		if (pKsd_t->halting)

  005ca	33 db		 xor	 ebx, ebx
$L71605:

; 1311 : 		}
; 1312 : 	}
; 1313 : 
; 1314 : #ifdef SPANISH
; 1315 : 	spanish_allophonics (phTTS);
; 1316 : #endif
; 1317 : 
; 1318 : 	/* Main loop 2: for each input symbol, pass to output array or turn into */
; 1319 : 	/* a feature value */
; 1320 : 
; 1321 : 	mf0 = 0;

  005cc	89 5c 24 30	 mov	 DWORD PTR _mf0$[esp+56], ebx

; 1322 : 	pDph_t->nphonetot = 0;

  005d0	66 89 9e 98 17
	00 00		 mov	 WORD PTR [esi+6040], bx

; 1323 : 	word_init_sw = FALSE;
; 1324 : 	in_rhyme = FALSE;
; 1325 : 	pDph_t->newparagsw = FALSE;

  005d7	c6 86 9a 17 00
	00 00		 mov	 BYTE PTR [esi+6042], 0

; 1326 : 
; 1327 : #ifdef SPANISH
; 1328 : 	nsyll = 0;						   /* Monosyllabic for now          */
; 1329 : 	syllclass = 0;					   /* Assume closed syllable     	*/
; 1330 : 	iscoda = 0;						   /* Haven't seen vowel yet        */
; 1331 : 	wordstress = 0;					   /* Word isn't stressed           */
; 1332 : 	compound_destress = FALSE;
; 1333 : #endif
; 1334 : 	
; 1335 : #ifdef GERMAN
; 1336 : 	/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 1337 : 	/* initialization of german variables                					  */
; 1338 : 	/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 1339 : 	pDph_t->hat_seen = 0;
; 1340 : 	pDph_t->wordcount = 1;
; 1341 : 
; 1342 : 
; 1343 : #ifdef OBSLETE_CODE
; 1344 : 	/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 1345 : 	/* do syntactical check if no hat markers were seen      				  */
; 1346 : 	/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 1347 : 	if (pDph_t->f0mode == NORMAL)
; 1348 : 	{
; 1349 : 		german_syntax (pDph_t);
; 1350 : 	}
; 1351 : 	compound_destress = FALSE;
; 1352 : #endif
; 1353 : #endif        
; 1354 : 
; 1355 : 	for (n = 0; n < pDph_t->nsymbtot; n++)

  005de	89 5c 24 10	 mov	 DWORD PTR _n$[esp+56], ebx
  005e2	66 39 9e 82 17
	00 00		 cmp	 WORD PTR [esi+6018], bx
  005e9	89 5c 24 20	 mov	 DWORD PTR _word_init_sw$[esp+56], ebx
  005ed	89 5c 24 2c	 mov	 DWORD PTR _in_rhyme$[esp+56], ebx
  005f1	0f 8e d4 04 00
	00		 jle	 $L71648
$L71646:

; 1356 : 	{
; 1357 : 
; 1358 : 	/* GL 03/27/1997 BATS#270 fix German index delay problem(fixed by Ed bruckert) */
; 1359 : /*#if defined (ENGLISH) || defined (SPANISH)*/
; 1360 : 		snphonetot = pDph_t->nphonetot;

  005f7	66 8b 86 98 17
	00 00		 mov	 ax, WORD PTR [esi+6040]

; 1361 : /*#endif*/
; 1362 : 		if (pKsd_t->halting)

  005fe	8b 4c 24 24	 mov	 ecx, DWORD PTR _pKsd_t$[esp+56]
  00602	66 89 44 24 34	 mov	 WORD PTR _snphonetot$[esp+56], ax
  00607	8b 81 34 03 00
	00		 mov	 eax, DWORD PTR [ecx+820]
  0060d	85 c0		 test	 eax, eax
  0060f	0f 85 c3 04 00
	00		 jne	 $L71863

; 1364 : 
; 1365 : 		curr_in_phone = pDph_t->symbols[n];

  00615	0f bf 44 24 10	 movsx	 eax, WORD PTR _n$[esp+56]

; 1366 : 		curr_in_sym = pDph_t->symbols[n] & PVALUE;	/* Precompute useful variable */
; 1367 : 
; 1368 : 		curr_dur = pDph_t->user_durs[n];	/* User-specified dur if non-zero */

  0061a	8b 8e 84 17 00
	00		 mov	 ecx, DWORD PTR [esi+6020]

; 1369 : 		pDph_t->user_durs[n] = 0;

  00620	33 ed		 xor	 ebp, ebp
  00622	66 8b 9c 46 26
	15 00 00	 mov	 bx, WORD PTR [esi+eax*2+5414]
  0062a	8a d3		 mov	 dl, bl
  0062c	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00632	8b fa		 mov	 edi, edx
  00634	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  00638	89 54 24 14	 mov	 DWORD PTR _curr_dur$[esp+56], edx
  0063c	8b 8e 84 17 00
	00		 mov	 ecx, DWORD PTR [esi+6020]
  00642	89 7c 24 28	 mov	 DWORD PTR _curr_in_sym$[esp+56], edi
  00646	66 89 2c 41	 mov	 WORD PTR [ecx+eax*2], bp

; 1370 : 
; 1371 : 		curr_f0 = pDph_t->user_f0[n];  /* User-specified f0 if non-zero  */

  0064a	8b 96 88 17 00
	00		 mov	 edx, DWORD PTR [esi+6024]
  00650	0f bf 44 24 10	 movsx	 eax, WORD PTR _n$[esp+56]
  00655	d1 e0		 shl	 eax, 1
  00657	66 8b 0c 10	 mov	 cx, WORD PTR [eax+edx]
  0065b	89 4c 24 1c	 mov	 DWORD PTR _curr_f0$[esp+56], ecx

; 1372 : 		pDph_t->user_f0[n] = 0;

  0065f	8b 96 88 17 00
	00		 mov	 edx, DWORD PTR [esi+6024]

; 1373 : 
; 1374 : 		/* Check to see if user-specified f0 hats/stress-pulses */
; 1375 : #ifndef FRENCH
; 1376 : 		interp_user_f0 (pDph_t, &curr_dur, &curr_f0, curr_in_sym, &mf0);

  00665	8d 4c 24 1c	 lea	 ecx, DWORD PTR _curr_f0$[esp+56]
  00669	66 89 2c 10	 mov	 WORD PTR [eax+edx], bp
  0066d	8d 44 24 30	 lea	 eax, DWORD PTR _mf0$[esp+56]
  00671	50		 push	 eax
  00672	57		 push	 edi
  00673	8d 54 24 1c	 lea	 edx, DWORD PTR _curr_dur$[esp+64]
  00677	51		 push	 ecx
  00678	52		 push	 edx
  00679	56		 push	 esi
  0067a	e8 00 00 00 00	 call	 _interp_user_f0

; 1377 : #endif
; 1378 : 		/* Switch on the current input symbol */
; 1379 : 				
; 1380 : 		/* added wordclass info for AD */
; 1381 : #if (defined ENGLISH) || (defined GERMAN)
; 1382 : 		if(pDph_t->wordclass[n] & FC_NOUN)

  0067f	0f bf 44 24 24	 movsx	 eax, WORD PTR _n$[esp+76]
  00684	83 c4 14	 add	 esp, 20			; 00000014H
  00687	8b 84 86 08 10
	00 00		 mov	 eax, DWORD PTR [esi+eax*4+4104]
  0068e	f6 c4 04	 test	 ah, 4
  00691	74 2c		 je	 SHORT $L71650

; 1383 : 		{
; 1384 : 			add_feature (pDph_t,  F_NOUN, NEXTPHONE);

  00693	66 8b 8e 98 17
	00 00		 mov	 cx, WORD PTR [esi+6040]
  0069a	51		 push	 ecx
  0069b	68 00 00 08 00	 push	 524288			; 00080000H
  006a0	56		 push	 esi
  006a1	e8 00 00 00 00	 call	 _add_feature
  006a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1385 : 			//printf("FOUND a NOUN %d\n",pDph_t->wordclass[n] & FC_NOUN);
; 1386 : 		}
; 1387 : 		else if(pDph_t->wordclass[n] & FC_ADJ )

  006a9	e9 cd 00 00 00	 jmp	 $L71656
$L71862:

; 1211 : #endif
; 1212 : #if defined SPANISH || defined GERMAN 
; 1213 : 				if ((pDph_t->symbols[m] & PVALUE) >= SBOUND)
; 1214 : #endif
; 1215 : #ifdef FRENCH
; 1216 : 				if ((pDph_t->symbols[m] & PVALUE) > WBOUND && (pDph_t->symbols[m] & PVALUE) < NEW_PARAGRAPH
; 1217 : 					&& (pDph_t->symbols[m] & PVALUE) != HYPHEN /* xxx for auto compunds */ )
; 1218 : #endif
; 1219 : 				{
; 1220 : 					nstresses--;
; 1221 : 					delete_symbol (phTTS, n);	/* Ignore stress at end of */

  006ae	51		 push	 ecx
  006af	8b 4c 24 40	 mov	 ecx, DWORD PTR _phTTS$[esp+56]
  006b3	51		 push	 ecx
  006b4	4b		 dec	 ebx
  006b5	e8 00 00 00 00	 call	 _delete_symbol

; 1222 : 					goto stzapped;	   /* syllable or word     */

  006ba	e9 e1 fd ff ff	 jmp	 $L71889
$L71650:

; 1385 : 			//printf("FOUND a NOUN %d\n",pDph_t->wordclass[n] & FC_NOUN);
; 1386 : 		}
; 1387 : 		else if(pDph_t->wordclass[n] & FC_ADJ )

  006bf	a8 01		 test	 al, 1
  006c1	74 1b		 je	 SHORT $L71652

; 1388 : 		{
; 1389 : 			add_feature (pDph_t,  F_ADJ, NEXTPHONE);

  006c3	66 8b 96 98 17
	00 00		 mov	 dx, WORD PTR [esi+6040]
  006ca	52		 push	 edx
  006cb	68 00 00 10 00	 push	 1048576			; 00100000H
  006d0	56		 push	 esi
  006d1	e8 00 00 00 00	 call	 _add_feature
  006d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 : 		//	printf("FOUND an ADJ \n",pDph_t->wordclass[n] & FC_NOUN);
; 1391 : 		}
; 1392 : 		else if(pDph_t->wordclass[n] & FC_VERB

  006d9	e9 9d 00 00 00	 jmp	 $L71656
$L71652:

; 1393 : 			|| pDph_t->wordclass[n] & FC_ED)

  006de	a9 00 00 02 00	 test	 eax, 131072		; 00020000H
  006e3	75 08		 jne	 SHORT $L71655
  006e5	a8 80		 test	 al, 128			; 00000080H
  006e7	0f 84 8e 00 00
	00		 je	 $L71656
$L71655:

; 1394 : 			/* eab and ed word is a verb 9/31/98 */
; 1395 : 		{
; 1396 : 			//printf("FOUND a VERB %d\n",pDph_t->wordclass[n] & FC_VERB);
; 1397 : 			//pDph_t->number_verbs++;
; 1398 : 			add_feature (pDph_t,  F_VERB, pDph_t->nphonetot);

  006ed	66 8b 86 98 17
	00 00		 mov	 ax, WORD PTR [esi+6040]
  006f4	50		 push	 eax
  006f5	68 00 00 20 00	 push	 2097152			; 00200000H
  006fa	56		 push	 esi
  006fb	e8 00 00 00 00	 call	 _add_feature
  00700	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1399 : 			if(pDph_t->promote_helper_verb)

  00703	66 39 ae e4 14
	00 00		 cmp	 WORD PTR [esi+5348], bp
  0070a	74 6f		 je	 SHORT $L71656

; 1400 : 			{
; 1401 : 				for (m = n ; m <= pDph_t->nsymbtot; m++)

  0070c	8b 54 24 10	 mov	 edx, DWORD PTR _n$[esp+56]
  00710	66 8b be 82 17
	00 00		 mov	 di, WORD PTR [esi+6018]
  00717	66 3b d7	 cmp	 dx, di
  0071a	8b ca		 mov	 ecx, edx
  0071c	7f 3e		 jg	 SHORT $L71659
$L71657:

; 1402 : 					{
; 1403 : 					if(phone_feature( pDph_t,  pDph_t->symbols[m]) & FVOWEL)

  0071e	0f bf c1	 movsx	 eax, cx
  00721	0f bf 84 46 26
	15 00 00	 movsx	 eax, WORD PTR [esi+eax*2+5414]
  00729	8b d8		 mov	 ebx, eax
  0072b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00730	c1 fb 08	 sar	 ebx, 8
  00733	8b 1c 9d 00 00
	00 00		 mov	 ebx, DWORD PTR _all_featb[ebx*4]
  0073a	f6 04 43 04	 test	 BYTE PTR [ebx+eax*2], 4
  0073e	75 08		 jne	 SHORT $L71864
  00740	41		 inc	 ecx
  00741	66 3b cf	 cmp	 cx, di
  00744	7e d8		 jle	 SHORT $L71657

; 1361 : /*#endif*/
; 1362 : 		if (pKsd_t->halting)

  00746	eb 14		 jmp	 SHORT $L71659
$L71864:

; 1404 : 					{
; 1405 : #ifdef GERMAN		
; 1406 : 						insertphone (phTTS, m, S2);
; 1407 : #else
; 1408 : 						insertphone (phTTS, m, S2);					

  00748	6a 66		 push	 102			; 00000066H
  0074a	51		 push	 ecx
  0074b	8b 4c 24 44	 mov	 ecx, DWORD PTR _phTTS$[esp+60]
  0074f	51		 push	 ecx
  00750	e8 00 00 00 00	 call	 _insertphone
  00755	8b 54 24 1c	 mov	 edx, DWORD PTR _n$[esp+68]
  00759	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71659:

; 1409 : #endif
; 1410 : 						break;
; 1411 : 					}
; 1412 : 					}
; 1413 : 				curr_in_phone = pDph_t->symbols[n];

  0075c	0f bf d2	 movsx	 edx, dx
  0075f	66 8b 9c 56 26
	15 00 00	 mov	 bx, WORD PTR [esi+edx*2+5414]

; 1414 : 				curr_in_sym = pDph_t->symbols[n] & PVALUE;	/* Precompute useful variable */
; 1415 : 
; 1416 : 				pDph_t->promote_helper_verb=0;

  00767	66 89 ae e4 14
	00 00		 mov	 WORD PTR [esi+5348], bp
  0076e	8a c3		 mov	 al, bl
  00770	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00775	8b f8		 mov	 edi, eax
  00777	89 7c 24 28	 mov	 DWORD PTR _curr_in_sym$[esp+56], edi
$L71656:

; 1417 : 			}
; 1418 : 
; 1419 : 		}
; 1420 : 		if(pDph_t->wordclass[n] & FC_FUNC)

  0077b	0f bf 4c 24 10	 movsx	 ecx, WORD PTR _n$[esp+56]
  00780	f7 84 8e 08 10
	00 00 00 00 80
	00		 test	 DWORD PTR [esi+ecx*4+4104], 8388608 ; 00800000H
  0078b	74 16		 je	 SHORT $L71661

; 1421 : 		{
; 1422 : 			add_feature (pDph_t,  F_FUNC, pDph_t->nphonetot);

  0078d	66 8b 96 98 17
	00 00		 mov	 dx, WORD PTR [esi+6040]
  00794	52		 push	 edx
  00795	68 00 00 40 00	 push	 4194304			; 00400000H
  0079a	56		 push	 esi
  0079b	e8 00 00 00 00	 call	 _add_feature
  007a0	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71661:

; 1423 : 		} 
; 1424 : 
; 1425 : 
; 1426 : 
; 1427 : #endif //remove
; 1428 : 
; 1429 : 		if ( (cp = durlookup(pDph_t, &pDph_t->symbols[n], (short *)&durdic[0])) != NULL)

  007a3	0f bf 44 24 10	 movsx	 eax, WORD PTR _n$[esp+56]
  007a8	68 00 00 00 00	 push	 OFFSET FLAT:_durdic
  007ad	8d 8c 46 26 15
	00 00		 lea	 ecx, DWORD PTR [esi+eax*2+5414]
  007b4	51		 push	 ecx
  007b5	56		 push	 esi
  007b6	e8 00 00 00 00	 call	 _durlookup
  007bb	83 c4 0c	 add	 esp, 12			; 0000000cH
  007be	3b c5		 cmp	 eax, ebp
  007c0	74 35		 je	 SHORT $L71667

; 1430 : 		{	
; 1431 : 			tmp=n;

  007c2	8b 54 24 10	 mov	 edx, DWORD PTR _n$[esp+56]
$L71665:

; 1432 : 			do{
; 1433 : 			if(*cp != 0 && tmp == 0)

  007c6	66 8b 08	 mov	 cx, WORD PTR [eax]
  007c9	66 3b cd	 cmp	 cx, bp
  007cc	74 0b		 je	 SHORT $L71668
  007ce	66 3b d5	 cmp	 dx, bp
  007d1	75 06		 jne	 SHORT $L71668

; 1434 : 			{
; 1435 : 				curr_dur=*cp;

  007d3	89 4c 24 14	 mov	 DWORD PTR _curr_dur$[esp+56], ecx

; 1436 : 			}
; 1437 : 			else

  007d7	eb 14		 jmp	 SHORT $L71669
$L71668:

; 1438 : 			{
; 1439 : 				pDph_t->user_durs[tmp]=*cp;

  007d9	8b ae 84 17 00
	00		 mov	 ebp, DWORD PTR [esi+6020]
  007df	0f bf fa	 movsx	 edi, dx
  007e2	66 89 4c 7d 00	 mov	 WORD PTR [ebp+edi*2], cx
  007e7	8b 7c 24 28	 mov	 edi, DWORD PTR _curr_in_sym$[esp+56]
  007eb	33 ed		 xor	 ebp, ebp
$L71669:

; 1440 : 			}
; 1441 : 			tmp++;
; 1442 : 			cp++;

  007ed	83 c0 02	 add	 eax, 2
  007f0	42		 inc	 edx

; 1443 : 			}
; 1444 : 			while (*cp != -1);

  007f1	66 83 38 ff	 cmp	 WORD PTR [eax], -1
  007f5	75 cf		 jne	 SHORT $L71665
$L71667:

; 1445 : 		}
; 1446 : 		
; 1447 : 
; 1448 : 
; 1449 : 				
; 1450 : 		if (curr_in_sym < MAX_PHONES)

  007f7	66 83 ff 63	 cmp	 di, 99			; 00000063H
  007fb	0f 8d ba 00 00
	00		 jge	 $L71670

; 1451 : 		{							   /* A real phoneme */
; 1452 : 			make_phone (pDph_t, curr_in_phone, n, curr_dur, curr_f0);		/* eab try handling stuff in make */

  00801	8b 54 24 1c	 mov	 edx, DWORD PTR _curr_f0$[esp+56]
  00805	8b 44 24 14	 mov	 eax, DWORD PTR _curr_dur$[esp+56]
  00809	8b 4c 24 10	 mov	 ecx, DWORD PTR _n$[esp+56]
  0080d	52		 push	 edx
  0080e	50		 push	 eax
  0080f	51		 push	 ecx
  00810	53		 push	 ebx
  00811	56		 push	 esi
  00812	e8 00 00 00 00	 call	 _make_phone

; 1453 : 
; 1454 : #ifdef SPANISH
; 1455 : 			if (word_init_sw)
; 1456 : 			{
; 1457 : 				nsyll = countsyll (pDph_t, n); 	/* Get nbr of syllables     */
; 1458 : 				syllclass = 0;		   			/* Setup for new syll   */
; 1459 : 				iscoda = 0;			   			/* Haven't seen vowel   */
; 1460 : 				wordstress = getwordstress (pDph_t,n);
; 1461 : 				if ((phone_feature( pDph_t,  curr_in_phone) & FSYLL) IS_MINUS)
; 1462 : 				{
; 1463 : 					add_feature (pDph_t, FWINITC, (short)(CURRPHONE) ); // NAL warning removal
; 1464 : 
; 1465 : 				}
; 1466 : 				word_init_sw = FALSE;
; 1467 : 			}
; 1468 : #endif
; 1469 : 
; 1470 : 			/* If syllabic, look ahead to see initial/medial/final syll */
; 1471 : 			if ((phone_feature( pDph_t,  curr_in_phone) & FSYLL) IS_PLUS)

  00817	0f bf c3	 movsx	 eax, bx
  0081a	8b d0		 mov	 edx, eax
  0081c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00821	c1 fa 08	 sar	 edx, 8
  00824	83 c4 14	 add	 esp, 20			; 00000014H
  00827	8b 0c 95 00 00
	00 00		 mov	 ecx, DWORD PTR _all_featb[edx*4]
  0082e	f6 04 41 01	 test	 BYTE PTR [ecx+eax*2], 1
  00832	74 31		 je	 SHORT $L71671

; 1472 : 			{
; 1473 : 				in_rhyme = TRUE;
; 1474 : #if defined (ENGLISH) || defined (GERMAN) 
; 1475 : 				word_init_sw = FALSE;
; 1476 : 				init_med_final (phTTS, n);

  00834	8b 54 24 10	 mov	 edx, DWORD PTR _n$[esp+56]
  00838	8b 7c 24 3c	 mov	 edi, DWORD PTR _phTTS$[esp+52]
  0083c	52		 push	 edx
  0083d	57		 push	 edi
  0083e	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR _in_rhyme$[esp+64], 1
  00846	89 6c 24 28	 mov	 DWORD PTR _word_init_sw$[esp+64], ebp
  0084a	e8 00 00 00 00	 call	 _init_med_final

; 1507 : 			{
; 1508 : 				get_next_bound_type (phTTS, n);

  0084f	8b 44 24 18	 mov	 eax, DWORD PTR _n$[esp+64]
  00853	83 c4 08	 add	 esp, 8
  00856	50		 push	 eax
  00857	57		 push	 edi
  00858	e8 00 00 00 00	 call	 _get_next_bound_type
  0085d	83 c4 08	 add	 esp, 8

; 1509 : 			}
; 1510 : 		}
; 1511 : 		else

  00860	e9 2b 02 00 00	 jmp	 $L71700
$L71671:

; 1477 : #endif
; 1478 : 
; 1479 : #ifdef SPANISH
; 1480 : 				if (iscoda == 0)
; 1481 : 				{
; 1482 : 					syllclass = getsyllclass (pDph_t, (short)(n + 1)); // NAL warning removal
; 1483 : 					iscoda = FCODA;
; 1484 : 				}
; 1485 : 				add_feature (pDph_t, nsyll + syllclass + wordstress, (short)(CURRPHONE) ); // NAL warning removal
; 1486 : #endif
; 1487 : 			}
; 1488 : 			/* Assign stress feature to consonants */
; 1489 : 			else
; 1490 : 			{
; 1491 : 				get_stress_of_conson (phTTS, n, compound_destress);

  00865	8b 44 24 18	 mov	 eax, DWORD PTR _compound_destress$[esp+56]
  00869	8b 4c 24 10	 mov	 ecx, DWORD PTR _n$[esp+56]
  0086d	8b 7c 24 3c	 mov	 edi, DWORD PTR _phTTS$[esp+52]
  00871	50		 push	 eax
  00872	51		 push	 ecx
  00873	57		 push	 edi
  00874	e8 00 00 00 00	 call	 _get_stress_of_conson

; 1492 : #ifdef SPANISH
; 1493 : 				/* Do we need to set "wordstress" here? */
; 1494 : 				add_feature (pDph_t,nsyll + syllclass + iscoda, (short)(CURRPHONE) ); // NAL warning removal
; 1495 : #endif
; 1496 : 			}
; 1497 : 			/* Assign word-initial feature to consonant(s) */
; 1498 : #if defined ENGLISH || defined GERMAN 
; 1499 : 			if (word_init_sw == TRUE)

  00879	bb 01 00 00 00	 mov	 ebx, 1
  0087e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00881	66 39 5c 24 20	 cmp	 WORD PTR _word_init_sw$[esp+56], bx
  00886	75 15		 jne	 SHORT $L71673

; 1500 : 			{
; 1501 : 				add_feature (pDph_t, FWINITC, (short)(CURRPHONE)); // NAL warning removal

  00888	66 8b 96 98 17
	00 00		 mov	 dx, WORD PTR [esi+6040]
  0088f	66 4a		 dec	 dx
  00891	52		 push	 edx
  00892	6a 04		 push	 4
  00894	56		 push	 esi
  00895	e8 00 00 00 00	 call	 _add_feature
  0089a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71673:

; 1502 : 			}
; 1503 : #endif // efined ENGLISH || defined GERMAN
; 1504 : 
; 1505 : 			/* Assign boundary type to segments of rhyme */
; 1506 : 			if (in_rhyme == TRUE)

  0089d	66 39 5c 24 2c	 cmp	 WORD PTR _in_rhyme$[esp+56], bx
  008a2	0f 85 e8 01 00
	00		 jne	 $L71700

; 1507 : 			{
; 1508 : 				get_next_bound_type (phTTS, n);

  008a8	8b 44 24 10	 mov	 eax, DWORD PTR _n$[esp+56]
  008ac	50		 push	 eax
  008ad	57		 push	 edi
  008ae	e8 00 00 00 00	 call	 _get_next_bound_type
  008b3	83 c4 08	 add	 esp, 8

; 1509 : 			}
; 1510 : 		}
; 1511 : 		else

  008b6	e9 d5 01 00 00	 jmp	 $L71700
$L71670:

; 1512 : 		{							   /* A non-phoneme */
; 1513 : 			switch (curr_in_sym)
; 1514 : 			{

  008bb	0f bf c7	 movsx	 eax, di
  008be	83 c0 9c	 add	 eax, -100		; ffffff9cH
  008c1	83 f8 13	 cmp	 eax, 19			; 00000013H
  008c4	0f 87 c6 01 00
	00		 ja	 $L71700
  008ca	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L71894[eax*4]
$L71681:

; 1515 : /* Per Oliver this code allows for vowels before double consonants to have a faster duration
; 1516 : 	BATS 709	EAB 7/2/98*/
; 1517 : 
; 1518 : #ifdef GERMAN
; 1519 : 			case DOUBLCONS:
; 1520 : 
; 1521 : 				add_feature (pDph_t, FDOUBLECONS, NEXTPHONE);
; 1522 : 				break;
; 1523 : #endif
; 1524 : 
; 1525 : 			case S1:
; 1526 : 
; 1527 : 				
; 1528 : #ifdef GERMAN
; 1529 : 				pDph_t->Word_has_stress =1; // eab 3/37 /98 set word stress marker 
; 1530 : 				if (compound_destress == TRUE)
; 1531 : 				{
; 1532 : 					add_feature (pDph_t, FSTRESS_2, NEXTPHONE);
; 1533 : 				}
; 1534 : 				else
; 1535 : 				{
; 1536 : #endif
; 1537 : 					add_feature (pDph_t, FSTRESS_1, NEXTPHONE);

  008d1	66 8b 8e 98 17
	00 00		 mov	 cx, WORD PTR [esi+6040]
  008d8	51		 push	 ecx
  008d9	6a 01		 push	 1
  008db	56		 push	 esi
  008dc	e8 00 00 00 00	 call	 _add_feature
  008e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1538 : #ifdef GERMAN
; 1539 : 				}
; 1540 : #endif
; 1541 : #ifdef MSDBG8
; 1542 : 				printf ("add_feature(FSTRESS_1,NEXTPHONE)\n");
; 1543 : #endif
; 1544 : 		 		break;

  008e4	e9 a7 01 00 00	 jmp	 $L71700
$L71682:

; 1545 : 			case S2:
; 1546 : #ifdef GERMAN
; 1547 : 				if (compound_destress == FALSE)
; 1548 : 				{
; 1549 : 					// add_feature (pDph_t, FSTRESS_2, n + 1 /* NEXTPHONE */ );
; 1550 : 					add_feature (pDph_t, FSTRESS_2,  NEXTPHONE );
; 1551 : 				}
; 1552 : #endif
; 1553 : #if defined (ENGLISH) || defined (SPANISH)
; 1554 : 				add_feature (pDph_t, FSTRESS_2, NEXTPHONE);

  008e9	66 8b 96 98 17
	00 00		 mov	 dx, WORD PTR [esi+6040]
  008f0	52		 push	 edx
  008f1	6a 02		 push	 2
  008f3	56		 push	 esi
  008f4	e8 00 00 00 00	 call	 _add_feature
  008f9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1555 : #endif
; 1556 : #ifdef MSDBG8
; 1557 : 					printf ("add_feature(FSTRESS_2,NEXTPHONE)\n");
; 1558 : #endif
; 1559 : 				break;

  008fc	e9 8f 01 00 00	 jmp	 $L71700
$L71683:

; 1560 : #ifdef SPANISH
; 1561 : 			case S3:
; 1562 : 				/* 
; 1563 : 				 * This is being used in the spanish as a marker for ", which causes 
; 1564 : 				 * the next clause to be treated differently didn't use feature
; 1565 : 				 * bits because there is now room for S3 
; 1566 : 				 */
; 1567 : 				phrase_after_quote = 1;
; 1568 : 
; 1569 : 				break;
; 1570 : #endif
; 1571 : #ifdef GERMAN
; 1572 : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 1573 : 				/* add tertiary stress for german DECtalk                				  */
; 1574 : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 1575 : 			case S3:
; 1576 : 				if (compound_destress == FALSE)
; 1577 : 				{
; 1578 : 					// add_feature (pDph_t, FSTRESS_3, n + 1  /* NEXTPHONE */ );
; 1579 : 					add_feature (pDph_t, FSTRESS_2, NEXTPHONE  );
; 1580 : 				}
; 1581 : 				break;
; 1582 : #endif
; 1583 : 			case SEMPH:
; 1584 : 				
; 1585 : 				add_feature (pDph_t, FEMPHASIS, NEXTPHONE);

  00901	66 8b 86 98 17
	00 00		 mov	 ax, WORD PTR [esi+6040]
  00908	50		 push	 eax
  00909	6a 03		 push	 3
  0090b	56		 push	 esi
  0090c	e8 00 00 00 00	 call	 _add_feature
  00911	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1586 : 
; 1587 : #ifdef MSDBG8
; 1588 : 
; 1589 : 				printf ("add_feature(FEMPHASIS,NEXTPHONE\n");
; 1590 : 
; 1591 : #endif
; 1592 : #ifdef SPANISH
; 1593 : 				pDph_t->emphasisflag = TRUE; /* Reduce other f0 gestures */
; 1594 : #endif
; 1595 : 				break;

  00914	e9 77 01 00 00	 jmp	 $L71700
$L71685:

; 1596 : 			case HYPHEN:
; 1597 : 
; 1598 : #ifdef SPANISH
; 1599 : /* compound_destress = TRUE;         break; 6/94 eab for spanish this is not correct this is an english rule per tony */
; 1600 : 				compound_destress = FALSE;
; 1601 : 			case MBOUND:
; 1602 : 
; 1603 : 			case SBOUND:
; 1604 : /* printf("\n at syl at %d ",n); */
; 1605 : 
; 1606 : 				add_feature (pDph_t, FISBOUND, (short)(CURRPHONE) ); // NAL warning removal
; 1607 : 				add_feature (pDph_t, FSBOUND, (short)(CURRPHONE) ); // NAL warning removal
; 1608 : 				iscoda = 0;
; 1609 : 				syllclass = 0;
; 1610 : #endif
; 1611 : #ifdef GERMAN
; 1612 : 				compound_destress = TRUE;
; 1613 : #endif
; 1614 : 				break;
; 1615 : 
; 1616 : 
; 1617 : #ifdef GERMAN
; 1618 : 			case COMMA:
; 1619 : 				pDph_t->clausetype = COMMACLAUSE;
; 1620 : 				pDph_t->clausenumber++;
; 1621 : 					pDph_t->dcommacnt++;
; 1622 : 				if(pDph_t->dcommacnt > 1 || pDph_t->number_words > 4)
; 1623 : 				{
; 1624 : 					pDph_t->clausetype = DECLARATIVE;
; 1625 : 				}
; 1626 : 			
; 1627 : 				
; 1628 : 
; 1629 : 				make_phone (pDph_t, GEN_SIL, n, curr_dur, curr_f0);
; 1630 : 				word_init_sw = TRUE;
; 1631 : 				compound_destress = FALSE;
; 1632 : 				break;				
; 1633 : 			case PERIOD:
; 1634 : 				pDph_t->clausetype = DECLARATIVE;
; 1635 : 				pDph_t->clausenumber=0;
; 1636 : 				add_feature (pDph_t, FSENTENDS, NEXTPHONE);
; 1637 : 				make_phone (pDph_t, GEN_SIL, n, curr_dur, curr_f0);
; 1638 : 				word_init_sw = TRUE;
; 1639 : 				compound_destress = FALSE;
; 1640 : 				break;
; 1641 : 			
; 1642 : 			case EXCLAIM:
; 1643 : 				pDph_t->clausetype = EXCLAIMCLAUSE;
; 1644 : 				pDph_t->clausenumber=0;
; 1645 : 				add_feature (pDph_t, FSENTENDS, NEXTPHONE);
; 1646 : 				make_phone (pDph_t, GEN_SIL, n, curr_dur, curr_f0);
; 1647 : 				word_init_sw = TRUE;
; 1648 : 				compound_destress = FALSE;
; 1649 : 				break;
; 1650 : 			
; 1651 : 					
; 1652 : 			case QUEST:          			
; 1653 : 				pDph_t->clausetype = QUESTION;
; 1654 : 				pDph_t->clausenumber=0;
; 1655 : 				add_feature (pDph_t, FSENTENDS, NEXTPHONE);
; 1656 : 				make_phone (pDph_t, GEN_SIL, n, curr_dur, curr_f0);
; 1657 : 				word_init_sw = TRUE;
; 1658 : 				compound_destress = FALSE;
; 1659 : 				break;
; 1660 : 			
; 1661 : 				
; 1662 : #endif
; 1663 : 
; 1664 : 				make_phone (pDph_t, GEN_SIL, n, curr_dur, curr_f0);
; 1665 : 			case WBOUND:
; 1666 : 
; 1667 : 				pDph_t->number_words++; /* EAB Let's count  up the number of words*/
; 1668 : 					/* eab AT slow speaking rate insert a glottal stop that later 
; 1669 : 				gets it's timing adjusted and voicing reduced*/
; 1670 : 				
; 1671 : 			
; 1672 : 					/* eab AT slow speaking rate insert a glottal stop that later 
; 1673 : 				gets it's timing adjusted and voicing reduced*/
; 1674 : 
; 1675 : 				if(pKsd_t->sprate <115)

  00919	8b 4c 24 24	 mov	 ecx, DWORD PTR _pKsd_t$[esp+56]
  0091d	66 ff 86 2e 20
	00 00		 inc	 WORD PTR [esi+8238]
  00924	66 83 b9 e6 03
	00 00 73	 cmp	 WORD PTR [ecx+998], 115	; 00000073H
  0092c	7d 18		 jge	 SHORT $L71686

; 1676 : 					insertphone (phTTS, (short) (n+1), USP_Q);

  0092e	8b 54 24 10	 mov	 edx, DWORD PTR _n$[esp+56]
  00932	8b 44 24 3c	 mov	 eax, DWORD PTR _phTTS$[esp+52]
  00936	42		 inc	 edx
  00937	68 35 1e 00 00	 push	 7733			; 00001e35H
  0093c	52		 push	 edx
  0093d	50		 push	 eax
  0093e	e8 00 00 00 00	 call	 _insertphone
  00943	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71686:

; 1677 : 
; 1678 : 
; 1679 : 				
; 1680 : 
; 1681 : #ifdef SPANISH
; 1682 : /* printf("at boun  %d \n ",n); */
; 1683 : 				if (n > 1)
; 1684 : 				{
; 1685 : 					add_feature (pDph_t, FISBOUND, (short)(CURRPHONE) ); // NAL warning removal
; 1686 : 				}
; 1687 : #endif
; 1688 : 			case PPSTART:
; 1689 : 			case VPSTART:
; 1690 : 			case RELSTART:
; 1691 : #ifdef ENGLISH
; 1692 : 				if (pDph_t->symbols[n + 1] == HYPHEN)

  00946	0f bf 4c 24 10	 movsx	 ecx, WORD PTR _n$[esp+56]
  0094b	66 83 bc 4e 28
	15 00 00 6e	 cmp	 WORD PTR [esi+ecx*2+5416], 110 ; 0000006eH
  00954	0f 84 36 01 00
	00		 je	 $L71700

; 1693 : 				{
; 1694 : 					break;			   /* xxx here to allow compound noun insert */
; 1695 : 				}
; 1696 : #endif
; 1697 : 
; 1698 : 				word_init_sw = TRUE;

  0095a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR _word_init_sw$[esp+56], 1

; 1699 : #ifdef SPANISH
; 1700 : 				nsyll = 0;
; 1701 : 				compound_destress = FALSE;
; 1702 : #endif    
; 1703 : #ifdef GERMAN
; 1704 : 				word_init_sw = TRUE;
; 1705 : 				compound_destress = FALSE;
; 1706 : #endif
; 1707 : 				break;

  00962	e9 29 01 00 00	 jmp	 $L71700
$L71690:

; 1708 : #if defined ENGLISH || defined SPANISH
; 1709 : 				case COMMA:
; 1710 : 				pDph_t->clausetype = COMMACLAUSE;
; 1711 : 				pDph_t->clausenumber++;

  00967	66 ff 86 ec 14
	00 00		 inc	 WORD PTR [esi+5356]

; 1712 : 					pDph_t->dcommacnt++;

  0096e	66 ff 86 f2 14
	00 00		 inc	 WORD PTR [esi+5362]
  00975	b8 01 00 00 00	 mov	 eax, 1

; 1713 : 				if(pDph_t->dcommacnt > 1 || pDph_t->number_words > 4)

  0097a	66 39 86 f2 14
	00 00		 cmp	 WORD PTR [esi+5362], ax
  00981	66 89 86 e6 03
	00 00		 mov	 WORD PTR [esi+998], ax
  00988	7f 0a		 jg	 SHORT $L71692
  0098a	66 83 be 2e 20
	00 00 04	 cmp	 WORD PTR [esi+8238], 4
  00992	7e 07		 jle	 SHORT $L71691
$L71692:

; 1714 : 				{
; 1715 : 					pDph_t->clausetype = DECLARATIVE;

  00994	66 89 ae e6 03
	00 00		 mov	 WORD PTR [esi+998], bp
$L71691:

; 1716 : 				}
; 1717 : #ifdef SPANISH
; 1718 : 				if (n > 1)
; 1719 : 				{
; 1720 : 					add_feature (pDph_t,FISBOUND, (short)(CURRPHONE) ); // NAL warning removal
; 1721 : 				}
; 1722 :             	nsyll=0;
; 1723 : #endif
; 1724 : 				make_phone (pDph_t, GEN_SIL, n, curr_dur, curr_f0);

  0099b	8b 54 24 1c	 mov	 edx, DWORD PTR _curr_f0$[esp+56]
  0099f	8b 44 24 14	 mov	 eax, DWORD PTR _curr_dur$[esp+56]
  009a3	8b 4c 24 10	 mov	 ecx, DWORD PTR _n$[esp+56]
  009a7	52		 push	 edx
  009a8	50		 push	 eax
  009a9	51		 push	 ecx

; 1725 : 				word_init_sw = TRUE;
; 1726 : 				compound_destress = FALSE;
; 1727 : 				break;

  009aa	eb 79		 jmp	 SHORT $L71893
$L71693:

; 1728 : 			case PERIOD:
; 1729 : 			pDph_t->clausetype = DECLARATIVE;
; 1730 : 			add_feature (pDph_t, FSENTENDS, NEXTPHONE);

  009ac	66 8b 96 98 17
	00 00		 mov	 dx, WORD PTR [esi+6040]
  009b3	66 89 ae e6 03
	00 00		 mov	 WORD PTR [esi+998], bp
  009ba	52		 push	 edx
  009bb	68 00 01 00 00	 push	 256			; 00000100H
  009c0	56		 push	 esi
  009c1	e8 00 00 00 00	 call	 _add_feature

; 1731 : 			pDph_t->clausenumber=0;

  009c6	66 89 ae ec 14
	00 00		 mov	 WORD PTR [esi+5356], bp

; 1732 : #ifdef SPANISH
; 1733 : 				if (n > 1)
; 1734 : 				{
; 1735 : 					add_feature (pDph_t,FISBOUND, (short)(CURRPHONE) ); // NAL warning removal
; 1736 : 				}
; 1737 :             	nsyll=0;
; 1738 : #endif
; 1739 : 				make_phone (pDph_t, GEN_SIL, n, curr_dur, curr_f0);

  009cd	8b 44 24 28	 mov	 eax, DWORD PTR _curr_f0$[esp+68]
  009d1	8b 4c 24 20	 mov	 ecx, DWORD PTR _curr_dur$[esp+68]
  009d5	8b 54 24 1c	 mov	 edx, DWORD PTR _n$[esp+68]
  009d9	50		 push	 eax
  009da	51		 push	 ecx
  009db	52		 push	 edx
  009dc	68 00 1e 00 00	 push	 7680			; 00001e00H
  009e1	56		 push	 esi
  009e2	e8 00 00 00 00	 call	 _make_phone
  009e7	83 c4 20	 add	 esp, 32			; 00000020H

; 1769 : 				word_init_sw = TRUE;

  009ea	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR _word_init_sw$[esp+56], 1

; 1770 : 				compound_destress = FALSE;

  009f2	89 6c 24 18	 mov	 DWORD PTR _compound_destress$[esp+56], ebp

; 1771 : 				break;

  009f6	e9 95 00 00 00	 jmp	 $L71700
$L71694:

; 1740 : 				word_init_sw = TRUE;
; 1741 : 				compound_destress = FALSE;
; 1742 : 				break;
; 1743 : 			case EXCLAIM:
; 1744 : 			pDph_t->clausetype = EXCLAIMCLAUSE;

  009fb	66 c7 86 e6 03
	00 00 02 00	 mov	 WORD PTR [esi+998], 2

; 1745 : 			pDph_t->clausenumber=0;
; 1746 : #ifdef SPANISH
; 1747 : 				if (n > 1)
; 1748 : 				{
; 1749 : 					add_feature (pDph_t,FISBOUND, (short)(CURRPHONE) ); // NAL warning removal
; 1750 : 				}
; 1751 :             	nsyll=0;
; 1752 : #endif
; 1753 : 				make_phone (pDph_t, GEN_SIL, n, curr_dur, curr_f0);
; 1754 : 				word_init_sw = TRUE;
; 1755 : 				compound_destress = FALSE;
; 1756 : 				break;

  00a04	eb 09		 jmp	 SHORT $L71891
$L71695:

; 1757 : 				
; 1758 : 			case QUEST:          			
; 1759 : 			pDph_t->clausetype = QUESTION;

  00a06	66 c7 86 e6 03
	00 00 03 00	 mov	 WORD PTR [esi+998], 3
$L71891:

; 1760 : 			pDph_t->clausenumber=0;

  00a0f	66 89 ae ec 14
	00 00		 mov	 WORD PTR [esi+5356], bp

; 1761 : #ifdef SPANISH
; 1762 : 				if (n > 1)
; 1763 : 				{
; 1764 : 					add_feature (pDph_t,FISBOUND, (short)(CURRPHONE) ); // NAL warning removal
; 1765 : 				}
; 1766 :             	nsyll=0;
; 1767 : #endif
; 1768 : 				make_phone (pDph_t, GEN_SIL, n, curr_dur, curr_f0);

  00a16	8b 44 24 1c	 mov	 eax, DWORD PTR _curr_f0$[esp+56]
  00a1a	8b 4c 24 14	 mov	 ecx, DWORD PTR _curr_dur$[esp+56]
  00a1e	8b 54 24 10	 mov	 edx, DWORD PTR _n$[esp+56]
  00a22	50		 push	 eax
  00a23	51		 push	 ecx
  00a24	52		 push	 edx
$L71893:
  00a25	68 00 1e 00 00	 push	 7680			; 00001e00H
  00a2a	56		 push	 esi
  00a2b	e8 00 00 00 00	 call	 _make_phone
  00a30	83 c4 14	 add	 esp, 20			; 00000014H

; 1769 : 				word_init_sw = TRUE;

  00a33	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR _word_init_sw$[esp+56], 1

; 1770 : 				compound_destress = FALSE;

  00a3b	89 6c 24 18	 mov	 DWORD PTR _compound_destress$[esp+56], ebp

; 1771 : 				break;

  00a3f	eb 4f		 jmp	 SHORT $L71700
$L71696:

; 1772 : 
; 1773 : #endif      /* #if defined ENGLISH || defined SPANISH */
; 1774 : 			case HAT_RISE:
; 1775 : #ifdef GERMAN
; 1776 : 				pDph_t->hat_seen++;
; 1777 : 				add_feature (pDph_t, FHAT_BEGINS, NEXTPHONE );
; 1778 : #endif
; 1779 : #if defined ENGLISH || defined SPANISH
; 1780 : 				add_feature (pDph_t, FHAT_BEGINS, NEXTPHONE);

  00a41	66 8b 86 98 17
	00 00		 mov	 ax, WORD PTR [esi+6040]
  00a48	50		 push	 eax
  00a49	68 00 02 00 00	 push	 512			; 00000200H
  00a4e	56		 push	 esi
  00a4f	e8 00 00 00 00	 call	 _add_feature
  00a54	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1781 : #endif
; 1782 : #ifdef MSDBG8
; 1783 : 				printf ("add_feature(FHAT_BEGINS,NEXTPHONE)\n");
; 1784 : #endif
; 1785 : 				break;

  00a57	eb 37		 jmp	 SHORT $L71700
$L71697:

; 1786 : 			case HAT_FALL:
; 1787 : #ifdef GERMAN
; 1788 : 				pDph_t->hat_seen++;
; 1789 : #endif
; 1790 : 				add_feature (pDph_t, FHAT_ENDS, NEXTPHONE);

  00a59	66 8b 8e 98 17
	00 00		 mov	 cx, WORD PTR [esi+6040]
  00a60	51		 push	 ecx
  00a61	68 00 04 00 00	 push	 1024			; 00000400H
  00a66	56		 push	 esi
  00a67	e8 00 00 00 00	 call	 _add_feature
  00a6c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1791 : #ifdef MSDBG8
; 1792 : 				printf ("add_feature(FHAT_ENDS,NEXTPHONE)\n");
; 1793 : #endif
; 1794 : 				break;

  00a6f	eb 1f		 jmp	 SHORT $L71700
$L71698:

; 1795 : #ifdef GERMAN
; 1796 : 			case HAT_RF:
; 1797 : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 1798 : 				/* german DECtalk uses also HAT_RF                   					  */
; 1799 : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 1800 : 				pDph_t->hat_seen++;
; 1801 : 				add_feature (pDph_t, FHAT_ROOF, NEXTPHONE);
; 1802 : 				break;
; 1803 : #endif
; 1804 : 			case BLOCK_RULES:
; 1805 : 				add_feature (pDph_t, FBLOCK, NEXTPHONE);

  00a71	66 8b 96 98 17
	00 00		 mov	 dx, WORD PTR [esi+6040]
  00a78	52		 push	 edx
  00a79	68 00 20 00 00	 push	 8192			; 00002000H
  00a7e	56		 push	 esi
  00a7f	e8 00 00 00 00	 call	 _add_feature
  00a84	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1806 : #ifdef MSDBG8
; 1807 : 				printf ("add_feature(FBLOCK,NEXTPHONE)\n");
; 1808 : #endif
; 1809 : 				break;

  00a87	eb 07		 jmp	 SHORT $L71700
$L71699:

; 1810 : 			case NEW_PARAGRAPH:
; 1811 : #ifdef SPANISH
; 1812 : 				pDph_t->nf0ev = -2;			   /* Force f0 to power-up value  */
; 1813 : #endif
; 1814 : 				pDph_t->newparagsw = TRUE;

  00a89	c6 86 9a 17 00
	00 01		 mov	 BYTE PTR [esi+6042], 1
$L71700:

; 1815 : 				break;
; 1816 : 			default:
; 1817 : 				break;
; 1818 : 			}
; 1819 : 		}
; 1820 : 		if ((pDph_t->nphonetot == snphonetot))	/* eab */

  00a90	66 8b 44 24 34	 mov	 ax, WORD PTR _snphonetot$[esp+56]
  00a95	66 39 86 98 17
	00 00		 cmp	 WORD PTR [esi+6040], ax
  00a9c	75 17		 jne	 SHORT $L71647

; 1821 : 		{
; 1822 : #ifdef MSDOS
; 1823 : 			adjust_index ((n + 1), -1, 0);	/* eab n+1 to bind forward */
; 1824 : #else
; 1825 : 			adjust_index (pKsd_t, (n + 1), -1, 0);	/* eab n+1 to bind forward */

  00a9e	0f bf 4c 24 10	 movsx	 ecx, WORD PTR _n$[esp+56]
  00aa3	8b 54 24 24	 mov	 edx, DWORD PTR _pKsd_t$[esp+56]
  00aa7	55		 push	 ebp
  00aa8	41		 inc	 ecx
  00aa9	6a ff		 push	 -1
  00aab	51		 push	 ecx
  00aac	52		 push	 edx
  00aad	e8 00 00 00 00	 call	 _adjust_index
  00ab2	83 c4 10	 add	 esp, 16			; 00000010H
$L71647:
  00ab5	8b 44 24 10	 mov	 eax, DWORD PTR _n$[esp+56]
  00ab9	40		 inc	 eax
  00aba	89 44 24 10	 mov	 DWORD PTR _n$[esp+56], eax
  00abe	66 3b 86 82 17
	00 00		 cmp	 ax, WORD PTR [esi+6018]
  00ac5	0f 8c 2c fb ff
	ff		 jl	 $L71646
$L71648:
  00acb	5f		 pop	 edi
  00acc	5e		 pop	 esi
  00acd	5d		 pop	 ebp

; 1826 : #endif
; 1827 : #ifdef DEBUGIND
; 1828 : 
; 1829 : 			printf ("adj -1 on %d %d \n", curr_in_sym, (n + 1));
; 1830 : #endif
; 1831 : 		}
; 1832 : 	}
; 1833 : 	return (TRUE);

  00ace	b8 01 00 00 00	 mov	 eax, 1
  00ad3	5b		 pop	 ebx

; 1834 : }	// pbsort()

  00ad4	83 c4 28	 add	 esp, 40			; 00000028H
  00ad7	c3		 ret	 0
$L71863:
  00ad8	5f		 pop	 edi
  00ad9	5e		 pop	 esi
  00ada	5d		 pop	 ebp

; 1363 : 			return (FALSE);

  00adb	33 c0		 xor	 eax, eax
  00add	5b		 pop	 ebx

; 1834 : }	// pbsort()

  00ade	83 c4 28	 add	 esp, 40			; 00000028H
  00ae1	c3		 ret	 0
  00ae2	8b ff		 npad	 2
$L71894:
  00ae4	00 00 00 00	 DD	 $L71698
  00ae8	00 00 00 00	 DD	 $L71700
  00aec	00 00 00 00	 DD	 $L71682
  00af0	00 00 00 00	 DD	 $L71681
  00af4	00 00 00 00	 DD	 $L71683
  00af8	00 00 00 00	 DD	 $L71696
  00afc	00 00 00 00	 DD	 $L71697
  00b00	00 00 00 00	 DD	 $L71700
  00b04	00 00 00 00	 DD	 $L71700
  00b08	00 00 00 00	 DD	 $L71700
  00b0c	00 00 00 00	 DD	 $L71700
  00b10	00 00 00 00	 DD	 $L71685
  00b14	00 00 00 00	 DD	 $L71686
  00b18	00 00 00 00	 DD	 $L71686
  00b1c	00 00 00 00	 DD	 $L71686
  00b20	00 00 00 00	 DD	 $L71690
  00b24	00 00 00 00	 DD	 $L71693
  00b28	00 00 00 00	 DD	 $L71695
  00b2c	00 00 00 00	 DD	 $L71694
  00b30	00 00 00 00	 DD	 $L71699
_phsort	ENDP
_phTTS$ = 8
_msym$ = 12
_get_stress_of_conson PROC NEAR

; 72   : 	//PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 73   : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  00b40	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00b44	53		 push	 ebx

; 74   : 	
; 75   : 	short                   m, mcl = 0, cl = 0, sy = 0, stresslevel = 0;
; 76   : /* GL 04/21/1997  change this for the OSF build */
; 77   : 	extern short            phcluster (short f, short s);
; 78   : 
; 79   : 	stresslevel = FNOSTRESS;
; 80   : 	for (m = msym + 1; m < pDph_t->nsymbtot; m++)

  00b45	8b 5c 24 0c	 mov	 ebx, DWORD PTR _msym$[esp]
  00b49	55		 push	 ebp
  00b4a	8b 68 18	 mov	 ebp, DWORD PTR [eax+24]
  00b4d	56		 push	 esi
  00b4e	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  00b51	57		 push	 edi
  00b52	66 8b 95 82 17
	00 00		 mov	 dx, WORD PTR [ebp+6018]
  00b59	66 3b ca	 cmp	 cx, dx
  00b5c	0f 8d ff 00 00
	00		 jge	 $L71433
$L71419:

; 81   : 	{
; 82   : 		sy = pDph_t->symbols[m];

  00b62	0f bf c1	 movsx	 eax, cx
  00b65	66 8b b4 45 26
	15 00 00	 mov	 si, WORD PTR [ebp+eax*2+5414]

; 83   : 		/* Search forward from present consonant for nonconsonant */
; 84   : 		if ((sy == S1) || (sy == S2) || (sy == SEMPH))

  00b6d	66 83 fe 67	 cmp	 si, 103			; 00000067H
  00b71	74 45		 je	 SHORT $L71423
  00b73	66 83 fe 66	 cmp	 si, 102			; 00000066H
  00b77	74 3f		 je	 SHORT $L71423
  00b79	66 83 fe 68	 cmp	 si, 104			; 00000068H
  00b7d	74 39		 je	 SHORT $L71423

; 120  : #ifdef MSDBG8
; 121  : 				printf ("add_feature(FEMPHASIS, CURRPHONE)\n");
; 122  : #endif
; 123  : 			}
; 124  : 			return;
; 125  : 		}
; 126  : 		if ((phone_feature(pDph_t, sy) & FSYLL) IS_PLUS)

  00b7f	0f bf c6	 movsx	 eax, si
  00b82	8b f8		 mov	 edi, eax
  00b84	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00b89	c1 ff 08	 sar	 edi, 8
  00b8c	8b 3c bd 00 00
	00 00		 mov	 edi, DWORD PTR _all_featb[edi*4]
  00b93	f6 04 47 01	 test	 BYTE PTR [edi+eax*2], 1
  00b97	0f 85 c4 00 00
	00		 jne	 $L71433

; 127  : 		{
; 128  : 			return;					   /* No stress before vowel */
; 129  : 		}
; 130  : 		if ((sy >= SBOUND) && (sy <= EXCLAIM))

  00b9d	66 83 fe 6c	 cmp	 si, 108			; 0000006cH
  00ba1	7c 0a		 jl	 SHORT $L71420
  00ba3	66 83 fe 76	 cmp	 si, 118			; 00000076H
  00ba7	0f 8e b4 00 00
	00		 jle	 $L71433
$L71420:

; 74   : 	
; 75   : 	short                   m, mcl = 0, cl = 0, sy = 0, stresslevel = 0;
; 76   : /* GL 04/21/1997  change this for the OSF build */
; 77   : 	extern short            phcluster (short f, short s);
; 78   : 
; 79   : 	stresslevel = FNOSTRESS;
; 80   : 	for (m = msym + 1; m < pDph_t->nsymbtot; m++)

  00bad	41		 inc	 ecx
  00bae	66 3b ca	 cmp	 cx, dx
  00bb1	7c af		 jl	 SHORT $L71419
  00bb3	5f		 pop	 edi
  00bb4	5e		 pop	 esi
  00bb5	5d		 pop	 ebp
  00bb6	5b		 pop	 ebx

; 131  : 		{
; 132  : 			return;					   /* No vowel before syllable ends */
; 133  : 		}
; 134  : 	}
; 135  : }

  00bb7	c3		 ret	 0
$L71423:

; 85   : 		{
; 86   : 			/* Number of consonants in potential legal cluster */
; 87   : 			mcl = m - msym;

  00bb8	8b f9		 mov	 edi, ecx
  00bba	2b fb		 sub	 edi, ebx

; 88   : 			/* 1st of more than 3 consonants in a row is not member of cluster */
; 89   : 			if (mcl > 3)

  00bbc	66 83 ff 03	 cmp	 di, 3
  00bc0	0f 8f 9b 00 00
	00		 jg	 $L71433

; 90   : 				return;
; 91   : 			/* One consonant is always stressable */
; 92   : 			if (mcl != 1)

  00bc6	66 83 ff 01	 cmp	 di, 1
  00bca	74 3a		 je	 SHORT $L71427

; 93   : 			{
; 94   : 				/* See if pair of consonants next to vowel is legal cluster */
; 95   : 				cl = phcluster (pDph_t->symbols[m - 2], pDph_t->symbols[m - 1]);

  00bcc	0f bf d9	 movsx	 ebx, cx
  00bcf	66 8b 8c 5d 24
	15 00 00	 mov	 cx, WORD PTR [ebp+ebx*2+5412]
  00bd7	66 8b 94 5d 22
	15 00 00	 mov	 dx, WORD PTR [ebp+ebx*2+5410]
  00bdf	51		 push	 ecx
  00be0	52		 push	 edx
  00be1	e8 00 00 00 00	 call	 _phcluster
  00be6	83 c4 08	 add	 esp, 8

; 96   : 				if (cl == NOCLUSTER)

  00be9	66 85 c0	 test	 ax, ax
  00bec	74 73		 je	 SHORT $L71433

; 97   : 					return;
; 98   : 				/* See if triple of consonants next to vowel is legal cluster */
; 99   : 				if ((mcl == 3)
; 100  : 					&& ((cl != CLUSTER_TRYS) || (pDph_t->symbols[m - 3] != USP_S)))

  00bee	66 83 ff 03	 cmp	 di, 3
  00bf2	75 12		 jne	 SHORT $L71427
  00bf4	66 3d 02 00	 cmp	 ax, 2
  00bf8	75 67		 jne	 SHORT $L71433
  00bfa	66 81 bc 5d 20
	15 00 00 29 1e	 cmp	 WORD PTR [ebp+ebx*2+5408], 7721 ; 00001e29H

; 101  : 					return;

  00c04	75 5b		 jne	 SHORT $L71433
$L71427:

; 102  : 			}
; 103  : 			if (sy == S1)

  00c06	66 83 fe 67	 cmp	 si, 103			; 00000067H
  00c0a	75 1a		 jne	 SHORT $L71429

; 104  : 			{
; 105  : 				add_feature (pDph_t, FSTRESS_1, (short)(CURRPHONE) ); // NAL warning removal

  00c0c	66 8b 85 98 17
	00 00		 mov	 ax, WORD PTR [ebp+6040]
  00c13	66 48		 dec	 ax
  00c15	50		 push	 eax
  00c16	6a 01		 push	 1

; 118  : 			{
; 119  : 				add_feature (pDph_t, FEMPHASIS, (short)(CURRPHONE) ); // NAL warning removal

  00c18	55		 push	 ebp
  00c19	e8 00 00 00 00	 call	 _add_feature
  00c1e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c21	5f		 pop	 edi
  00c22	5e		 pop	 esi
  00c23	5d		 pop	 ebp
  00c24	5b		 pop	 ebx

; 131  : 		{
; 132  : 			return;					   /* No vowel before syllable ends */
; 133  : 		}
; 134  : 	}
; 135  : }

  00c25	c3		 ret	 0
$L71429:

; 106  : #ifdef MSDBG8
; 107  : 				printf ("add_feature(FSTRESS_1,CURRPHONE)\n");
; 108  : #endif
; 109  : 			}
; 110  : 			if (sy == S2)

  00c26	66 83 fe 66	 cmp	 si, 102			; 00000066H
  00c2a	75 1a		 jne	 SHORT $L71431

; 111  : 			{
; 112  : 				add_feature (pDph_t, FSTRESS_2, (short)(CURRPHONE) ); // NAL warning removal

  00c2c	66 8b 8d 98 17
	00 00		 mov	 cx, WORD PTR [ebp+6040]
  00c33	66 49		 dec	 cx
  00c35	51		 push	 ecx
  00c36	6a 02		 push	 2

; 118  : 			{
; 119  : 				add_feature (pDph_t, FEMPHASIS, (short)(CURRPHONE) ); // NAL warning removal

  00c38	55		 push	 ebp
  00c39	e8 00 00 00 00	 call	 _add_feature
  00c3e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c41	5f		 pop	 edi
  00c42	5e		 pop	 esi
  00c43	5d		 pop	 ebp
  00c44	5b		 pop	 ebx

; 131  : 		{
; 132  : 			return;					   /* No vowel before syllable ends */
; 133  : 		}
; 134  : 	}
; 135  : }

  00c45	c3		 ret	 0
$L71431:

; 113  : #ifdef MSDBG8
; 114  : 				printf ("add_feature(FSTRESS_2, CURRPHONE)\n");
; 115  : #endif
; 116  : 			}
; 117  : 			if (sy == SEMPH)

  00c46	66 83 fe 68	 cmp	 si, 104			; 00000068H
  00c4a	75 15		 jne	 SHORT $L71433

; 118  : 			{
; 119  : 				add_feature (pDph_t, FEMPHASIS, (short)(CURRPHONE) ); // NAL warning removal

  00c4c	66 8b 95 98 17
	00 00		 mov	 dx, WORD PTR [ebp+6040]
  00c53	66 4a		 dec	 dx
  00c55	52		 push	 edx
  00c56	6a 03		 push	 3
  00c58	55		 push	 ebp
  00c59	e8 00 00 00 00	 call	 _add_feature
  00c5e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71433:
  00c61	5f		 pop	 edi
  00c62	5e		 pop	 esi
  00c63	5d		 pop	 ebp
  00c64	5b		 pop	 ebx

; 131  : 		{
; 132  : 			return;					   /* No vowel before syllable ends */
; 133  : 		}
; 134  : 	}
; 135  : }

  00c65	c3		 ret	 0
_get_stress_of_conson ENDP
_phTTS$ = 8
_msym$ = 12
_init_med_final PROC NEAR

; 59   : 	
; 60   : 	//PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 61   : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  00c70	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00c74	53		 push	 ebx
  00c75	55		 push	 ebp
  00c76	56		 push	 esi
  00c77	8b 50 18	 mov	 edx, DWORD PTR [eax+24]

; 62   : 	//PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;	
; 63   : 	short m, sylltype;
; 64   : 
; 65   : 	sylltype = FMONOSYL;			   /* Assume curr word is monosyllabic */

  00c7a	33 f6		 xor	 esi, esi
  00c7c	57		 push	 edi

; 66   : 
; 67   : 	/* Examine output string to see if any sylls at beginning of word */
; 68   : 	for (m = CURRPHONE - 1; m > 0; m--)

  00c7d	66 8b 9a 98 17
	00 00		 mov	 bx, WORD PTR [edx+6040]
  00c84	8d 4b fe	 lea	 ecx, DWORD PTR [ebx-2]
  00c87	66 85 c9	 test	 cx, cx
  00c8a	7e 45		 jle	 SHORT $L71925

; 69   : 	{
; 70   : 		if ((pDph_t->sentstruc[m] & FBOUNDARY) >= FWBNEXT)

  00c8c	8b ba 94 17 00
	00		 mov	 edi, DWORD PTR [edx+6036]
$L71483:
  00c92	0f bf c1	 movsx	 eax, cx
  00c95	8b 2c 87	 mov	 ebp, DWORD PTR [edi+eax*4]
  00c98	81 e5 e0 01 00
	00		 and	 ebp, 480		; 000001e0H
  00c9e	83 fd 60	 cmp	 ebp, 96			; 00000060H
  00ca1	73 2e		 jae	 SHORT $L71925

; 71   : 		{
; 72   : 			break;					   /* Beginning of word found */
; 73   : 		}
; 74   : 		else if ((phone_feature(pDph_t,pDph_t->phonemes[m]) & FSYLL) IS_PLUS)

  00ca3	8b aa 90 17 00
	00		 mov	 ebp, DWORD PTR [edx+6032]
  00ca9	0f bf 44 45 00	 movsx	 eax, WORD PTR [ebp+eax*2]
  00cae	8b e8		 mov	 ebp, eax
  00cb0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00cb5	c1 fd 08	 sar	 ebp, 8
  00cb8	8b 2c ad 00 00
	00 00		 mov	 ebp, DWORD PTR _all_featb[ebp*4]
  00cbf	f6 44 45 00 01	 test	 BYTE PTR [ebp+eax*2], 1
  00cc4	74 05		 je	 SHORT $L71484

; 75   : 		{
; 76   : 			sylltype = FFINALSYL;	   /* Syll exists before this one */

  00cc6	be 18 00 00 00	 mov	 esi, 24			; 00000018H
$L71484:

; 66   : 
; 67   : 	/* Examine output string to see if any sylls at beginning of word */
; 68   : 	for (m = CURRPHONE - 1; m > 0; m--)

  00ccb	49		 dec	 ecx
  00ccc	66 85 c9	 test	 cx, cx
  00ccf	7f c1		 jg	 SHORT $L71483
$L71925:

; 77   : 		}
; 78   : 	}
; 79   : 	/* Examine input string to see if any sylls in remainder of word */
; 80   : 	for (m = msym + 1; m < pDph_t->nsymbtot; m++)

  00cd1	8b 4c 24 18	 mov	 ecx, DWORD PTR _msym$[esp+12]
  00cd5	66 8b ba 82 17
	00 00		 mov	 di, WORD PTR [edx+6018]
  00cdc	41		 inc	 ecx
  00cdd	66 3b cf	 cmp	 cx, di
  00ce0	7d 68		 jge	 SHORT $L71493
$L71489:

; 81   : 	{
; 82   : 		if ((pDph_t->symbols[m]  >= WBOUND)
; 83   : 			&& (pDph_t->symbols[m] <= EXCLAIM))

  00ce2	0f bf c1	 movsx	 eax, cx
  00ce5	66 8b 84 42 26
	15 00 00	 mov	 ax, WORD PTR [edx+eax*2+5414]
  00ced	66 3d 6f 00	 cmp	 ax, 111			; 0000006fH
  00cf1	7c 06		 jl	 SHORT $L71492
  00cf3	66 3d 76 00	 cmp	 ax, 118			; 00000076H
  00cf7	7e 3d		 jle	 SHORT $L71926
$L71492:

; 88   : #ifdef MSDBG8
; 89   : 				printf ("add_feature(sylltype,CURRPHONE) sylltype=%d\n", sylltype);
; 90   : #endif
; 91   : 			}
; 92   : 			return;
; 93   : 		}
; 94   : 		else if ((phone_feature(pDph_t,pDph_t->symbols[m]) & FSYLL) IS_PLUS)

  00cf9	0f bf c0	 movsx	 eax, ax
  00cfc	8b e8		 mov	 ebp, eax
  00cfe	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00d03	c1 fd 08	 sar	 ebp, 8
  00d06	8b 2c ad 00 00
	00 00		 mov	 ebp, DWORD PTR _all_featb[ebp*4]
  00d0d	f6 44 45 00 01	 test	 BYTE PTR [ebp+eax*2], 1
  00d12	74 17		 je	 SHORT $L71490

; 95   : 		{
; 96   : 			if (sylltype == FFINALSYL)

  00d14	66 83 fe 18	 cmp	 si, 24			; 00000018H
  00d18	75 07		 jne	 SHORT $L71497

; 97   : 			{
; 98   : 				sylltype = FMEDIALSYL; /* Syll exists before & after */

  00d1a	be 10 00 00 00	 mov	 esi, 16			; 00000010H

; 99   : 			}
; 100  : 			if (sylltype == FMONOSYL)

  00d1f	eb 0a		 jmp	 SHORT $L71490
$L71497:
  00d21	66 85 f6	 test	 si, si
  00d24	75 05		 jne	 SHORT $L71490

; 101  : 			{
; 102  : 				sylltype = FFIRSTSYL;  /* Syll exists after only */

  00d26	be 08 00 00 00	 mov	 esi, 8
$L71490:

; 77   : 		}
; 78   : 	}
; 79   : 	/* Examine input string to see if any sylls in remainder of word */
; 80   : 	for (m = msym + 1; m < pDph_t->nsymbtot; m++)

  00d2b	41		 inc	 ecx
  00d2c	66 3b cf	 cmp	 cx, di
  00d2f	7c b1		 jl	 SHORT $L71489
  00d31	5f		 pop	 edi
  00d32	5e		 pop	 esi
  00d33	5d		 pop	 ebp
  00d34	5b		 pop	 ebx

; 103  : 			}
; 104  : 		}
; 105  : 	}
; 106  : 
; 107  : }

  00d35	c3		 ret	 0
$L71926:

; 84   : 		{							   /* Look for next boundary */
; 85   : 			if (sylltype != FMONOSYL)

  00d36	66 85 f6	 test	 si, si
  00d39	74 0f		 je	 SHORT $L71493

; 86   : 			{
; 87   : 				add_feature (pDph_t, sylltype, (short)(CURRPHONE) ); // NAL warning removal

  00d3b	0f bf ce	 movsx	 ecx, si
  00d3e	4b		 dec	 ebx
  00d3f	53		 push	 ebx
  00d40	51		 push	 ecx
  00d41	52		 push	 edx
  00d42	e8 00 00 00 00	 call	 _add_feature
  00d47	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71493:
  00d4a	5f		 pop	 edi
  00d4b	5e		 pop	 esi
  00d4c	5d		 pop	 ebp
  00d4d	5b		 pop	 ebx

; 103  : 			}
; 104  : 		}
; 105  : 	}
; 106  : 
; 107  : }

  00d4e	c3		 ret	 0
_init_med_final ENDP
_phTTS$ = 8
_locend$ = 12
_nstartphrase$ = 16
_find_syll_to_stress PROC NEAR

; 127  : 	short                   m, locbeg = 0;	// MVP: Initialized 
; 128  : 
; 129  : 	//PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 130  : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  00d50	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00d54	53		 push	 ebx
  00d55	55		 push	 ebp
  00d56	56		 push	 esi
  00d57	8b 50 18	 mov	 edx, DWORD PTR [eax+24]

; 131  : 
; 132  : #ifndef  GERMAN
; 133  : 	/* Try to promote a secondary stress to primary, working from back */
; 134  : 	for (m = *locend - 1; m >= nstartphrase; m--)

  00d5a	8b 44 24 14	 mov	 eax, DWORD PTR _locend$[esp+8]
  00d5e	57		 push	 edi
  00d5f	66 8b 7c 24 1c	 mov	 di, WORD PTR _nstartphrase$[esp+12]
  00d64	66 8b 18	 mov	 bx, WORD PTR [eax]
  00d67	33 c9		 xor	 ecx, ecx
  00d69	8d 73 ff	 lea	 esi, DWORD PTR [ebx-1]
  00d6c	8b c6		 mov	 eax, esi
  00d6e	66 3b c7	 cmp	 ax, di
  00d71	7c 14		 jl	 SHORT $L71511
$L71509:

; 135  : 	{
; 136  :   /* eab 4/21/98 This code is wierd in that in German we don't want to do this
; 137  : 	and English never has really had secondary stress until Tony added it to the dictionary which was
; 138  : 	way after this code was writeen by Dennis*/
; 139  : 		if (pDph_t->symbols[m] == S2)

  00d73	0f bf e8	 movsx	 ebp, ax
  00d76	66 83 bc 6a 26
	15 00 00 66	 cmp	 WORD PTR [edx+ebp*2+5414], 102 ; 00000066H
  00d7f	74 27		 je	 SHORT $L71940
  00d81	48		 dec	 eax
  00d82	66 3b c7	 cmp	 ax, di
  00d85	7d ec		 jge	 SHORT $L71509
$L71511:

; 142  : 			return;
; 143  : 		}
; 144  : 	}
; 145  : #endif
; 146  : 	/* Else try to find a vowel to stress in last word */
; 147  : 	for (m = *locend - 1; m >= nstartphrase; m--)

  00d87	8b c6		 mov	 eax, esi
  00d89	66 3b c7	 cmp	 ax, di
  00d8c	7c 2e		 jl	 SHORT $L71515
  00d8e	be 6f 00 00 00	 mov	 esi, 111		; 0000006fH
$L71513:

; 148  : 	{
; 149  : 		if (pDph_t->symbols[m] >= WBOUND)

  00d93	0f bf e8	 movsx	 ebp, ax
  00d96	66 39 b4 6a 26
	15 00 00	 cmp	 WORD PTR [edx+ebp*2+5414], si
  00d9e	7d 1a		 jge	 SHORT $L71941
  00da0	48		 dec	 eax
  00da1	66 3b c7	 cmp	 ax, di
  00da4	7d ed		 jge	 SHORT $L71513

; 157  : 	{
; 158  : 		if ((phone_feature(pDph_t,pDph_t->symbols[m]) & FSYLL) IS_PLUS)

  00da6	eb 14		 jmp	 SHORT $L71515
$L71940:

; 140  : 		{
; 141  : 			pDph_t->symbols[m] = S1;

  00da8	0f bf c8	 movsx	 ecx, ax
  00dab	5f		 pop	 edi
  00dac	5e		 pop	 esi
  00dad	5d		 pop	 ebp
  00dae	66 c7 84 4a 26
	15 00 00 67 00	 mov	 WORD PTR [edx+ecx*2+5414], 103 ; 00000067H
  00db8	5b		 pop	 ebx

; 163  : 			return;
; 164  : 		}
; 165  : 	}
; 166  : 	/* Else give up, clause contains no primary stresses */
; 167  : 
; 168  : }

  00db9	c3		 ret	 0
$L71941:

; 150  : 		{
; 151  : 
; 152  : 			locbeg = m;

  00dba	8b c8		 mov	 ecx, eax
$L71515:

; 153  : 			break;
; 154  : 		}
; 155  : 	}
; 156  : 	for (m = locbeg; m < *locend; m++)

  00dbc	66 3b cb	 cmp	 cx, bx
  00dbf	7d 44		 jge	 SHORT $L71519
$L71517:

; 157  : 	{
; 158  : 		if ((phone_feature(pDph_t,pDph_t->symbols[m]) & FSYLL) IS_PLUS)

  00dc1	0f bf c1	 movsx	 eax, cx
  00dc4	0f bf 84 42 26
	15 00 00	 movsx	 eax, WORD PTR [edx+eax*2+5414]
  00dcc	8b f0		 mov	 esi, eax
  00dce	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00dd3	c1 fe 08	 sar	 esi, 8
  00dd6	8b 34 b5 00 00
	00 00		 mov	 esi, DWORD PTR _all_featb[esi*4]
  00ddd	f6 04 46 01	 test	 BYTE PTR [esi+eax*2], 1
  00de1	75 0b		 jne	 SHORT $L71942
  00de3	41		 inc	 ecx
  00de4	66 3b cb	 cmp	 cx, bx
  00de7	7c d8		 jl	 SHORT $L71517
  00de9	5f		 pop	 edi
  00dea	5e		 pop	 esi
  00deb	5d		 pop	 ebp
  00dec	5b		 pop	 ebx

; 163  : 			return;
; 164  : 		}
; 165  : 	}
; 166  : 	/* Else give up, clause contains no primary stresses */
; 167  : 
; 168  : }

  00ded	c3		 ret	 0
$L71942:

; 159  : 		{
; 160  : 
; 161  : 			insertphone (phTTS, m, S1);		/* Insert S1 at location m */

  00dee	6a 67		 push	 103			; 00000067H
  00df0	51		 push	 ecx
  00df1	8b 4c 24 1c	 mov	 ecx, DWORD PTR _phTTS$[esp+20]
  00df5	51		 push	 ecx
  00df6	e8 00 00 00 00	 call	 _insertphone

; 162  : 			(*locend)++;			   /* Move pointer in calling loop *//* MVP : was n++ and n was static */

  00dfb	8b 44 24 24	 mov	 eax, DWORD PTR _locend$[esp+24]
  00dff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e02	66 ff 00	 inc	 WORD PTR [eax]
$L71519:
  00e05	5f		 pop	 edi
  00e06	5e		 pop	 esi
  00e07	5d		 pop	 ebp
  00e08	5b		 pop	 ebx

; 163  : 			return;
; 164  : 		}
; 165  : 	}
; 166  : 	/* Else give up, clause contains no primary stresses */
; 167  : 
; 168  : }

  00e09	c3		 ret	 0
_find_syll_to_stress ENDP
_TEXT	ENDS
EXTRN	_bounftab:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_msym$ = 12
_get_next_bound_type PROC NEAR

; 189  : 	//PKSD_T  pKsd_t = phTTS->pKernelShareData;
; 190  : 	PDPH_T  pDph_t = phTTS->pPHThreadData;

  00e10	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]

; 191  : 	extern short bounftab[];		/* MVP : defined in PHROM.C (a Look up table) */
; 192  : 	short        m;
; 193  : 
; 194  : 	for (m = msym + 1; m < pDph_t->nsymbtot; m++)

  00e14	8b 4c 24 08	 mov	 ecx, DWORD PTR _msym$[esp-4]
  00e18	56		 push	 esi
  00e19	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  00e1c	57		 push	 edi
  00e1d	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00e20	66 8b be 82 17
	00 00		 mov	 di, WORD PTR [esi+6018]
  00e27	66 3b d7	 cmp	 dx, di
  00e2a	7d 68		 jge	 SHORT $L71954
$L71529:

; 195  : 	{
; 196  : 		if (((pDph_t->symbols[m] & PVALUE) >= SBOUND)
; 197  : 			&& ((pDph_t->symbols[m]& PVALUE) <= EXCLAIM))

  00e2c	0f bf c2	 movsx	 eax, dx
  00e2f	66 8b 8c 46 26
	15 00 00	 mov	 cx, WORD PTR [esi+eax*2+5414]
  00e37	8b c1		 mov	 eax, ecx
  00e39	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00e3e	66 3d 6c 00	 cmp	 ax, 108			; 0000006cH
  00e42	7c 06		 jl	 SHORT $L71532
  00e44	66 3d 76 00	 cmp	 ax, 118			; 00000076H
  00e48	7e 23		 jle	 SHORT $L71953
$L71532:

; 200  : #ifdef MSDBG8
; 201  : 			printf ("add_feature(bounftab[symbols[m] - SBOUND], CURRPHONE) bounftab[%d]=%d\n", pDph_t->symbols[m] - SBOUND, bounftab[pDph_t->symbols[m] - SBOUND]);
; 202  : #endif
; 203  : 			return;
; 204  : 		}
; 205  : 		else if (((phone_feature(pDph_t,pDph_t->symbols[m])) & FSYLL) IS_PLUS)

  00e4a	0f bf c1	 movsx	 eax, cx
  00e4d	8b c8		 mov	 ecx, eax
  00e4f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00e54	c1 f9 08	 sar	 ecx, 8
  00e57	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _all_featb[ecx*4]
  00e5e	f6 04 41 01	 test	 BYTE PTR [ecx+eax*2], 1
  00e62	75 30		 jne	 SHORT $L71954
  00e64	42		 inc	 edx
  00e65	66 3b d7	 cmp	 dx, di
  00e68	7c c2		 jl	 SHORT $L71529
  00e6a	5f		 pop	 edi
  00e6b	5e		 pop	 esi

; 206  : 		{
; 207  : 			return;					   /* Abort if see vowel first */
; 208  : 		}
; 209  : 	}
; 210  : 
; 211  : }

  00e6c	c3		 ret	 0
$L71953:

; 198  : 		{							   /* Look for next boundary */
; 199  : 			add_feature (pDph_t, bounftab[pDph_t->symbols[m] - SBOUND], (short)(CURRPHONE) ); // NAL warning removal

  00e6d	66 8b 86 98 17
	00 00		 mov	 ax, WORD PTR [esi+6040]
  00e74	0f bf ca	 movsx	 ecx, dx
  00e77	66 48		 dec	 ax
  00e79	0f bf 94 4e 26
	15 00 00	 movsx	 edx, WORD PTR [esi+ecx*2+5414]
  00e81	50		 push	 eax
  00e82	0f bf 04 55 28
	ff ff ff	 movsx	 eax, WORD PTR _bounftab[edx*2-216]
  00e8a	50		 push	 eax
  00e8b	56		 push	 esi
  00e8c	e8 00 00 00 00	 call	 _add_feature
  00e91	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71954:
  00e94	5f		 pop	 edi
  00e95	5e		 pop	 esi

; 206  : 		{
; 207  : 			return;					   /* Abort if see vowel first */
; 208  : 		}
; 209  : 	}
; 210  : 
; 211  : }

  00e96	c3		 ret	 0
_get_next_bound_type ENDP
_phTTS$ = 8
_msym$ = 12
_stdangle$ = 12
_move_stdangle PROC NEAR

; 231  : 	short   m, stdangle, durdangle, f0dangle;
; 232  : 	//PKSD_T  pKsd_t = phTTS->pKernelShareData;
; 233  : 	PDPH_T  pDph_t = phTTS->pPHThreadData;

  00ea0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00ea4	53		 push	 ebx

; 234  : 
; 235  : 	stdangle = pDph_t->symbols[msym]& PVALUE;

  00ea5	8b 5c 24 0c	 mov	 ebx, DWORD PTR _msym$[esp]
  00ea9	55		 push	 ebp
  00eaa	56		 push	 esi
  00eab	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  00eae	0f bf c3	 movsx	 eax, bx

; 236  : 	durdangle = pDph_t->user_durs[msym];

  00eb1	8b 96 84 17 00
	00		 mov	 edx, DWORD PTR [esi+6020]
  00eb7	57		 push	 edi
  00eb8	8a 8c 46 26 15
	00 00		 mov	 cl, BYTE PTR [esi+eax*2+5414]
  00ebf	66 8b 2c 42	 mov	 bp, WORD PTR [edx+eax*2]
  00ec3	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH

; 237  : 	f0dangle = pDph_t->user_durs[msym];
; 238  : 
; 239  : 	/* 1. If emphasis, replace strongest stress in current word */
; 240  : 	if (stdangle == SEMPH)

  00ec9	66 83 f9 68	 cmp	 cx, 104			; 00000068H
  00ecd	89 4c 24 18	 mov	 DWORD PTR _stdangle$[esp+12], ecx
  00ed1	0f 85 dd 00 00
	00		 jne	 $L71969

; 241  : 	{
; 242  : 		for (m = msym + 1; m < pDph_t->nsymbtot; m++)

  00ed7	8d 7b 01	 lea	 edi, DWORD PTR [ebx+1]
  00eda	66 3b be 82 17
	00 00		 cmp	 di, WORD PTR [esi+6018]
  00ee1	7d 28		 jge	 SHORT $L71967
$L71547:

; 243  : 		{
; 244  : 			if (pDph_t->symbols[m] == S1)

  00ee3	0f bf c7	 movsx	 eax, di
  00ee6	66 8b 84 46 26
	15 00 00	 mov	 ax, WORD PTR [esi+eax*2+5414]
  00eee	66 3d 67 00	 cmp	 ax, 103			; 00000067H
  00ef2	74 58		 je	 SHORT $L71966

; 250  : #ifdef DEBUGIND
; 251  : 
; 252  : 				printf ("delete rule 2\n");
; 253  : #endif
; 254  : 
; 255  : 				return;
; 256  : 			}
; 257  : 			if (is_wboundary (pDph_t->symbols[m]))

  00ef4	50		 push	 eax
  00ef5	e8 00 00 00 00	 call	 _is_wboundary
  00efa	83 c4 04	 add	 esp, 4
  00efd	85 c0		 test	 eax, eax
  00eff	75 0a		 jne	 SHORT $L71967
  00f01	47		 inc	 edi
  00f02	66 3b be 82 17
	00 00		 cmp	 di, WORD PTR [esi+6018]
  00f09	7c d8		 jl	 SHORT $L71547
$L71967:

; 258  : 			{
; 259  : 				break;	/* No longer current word, give up S1 search */
; 260  : 			}
; 261  : 		}
; 262  : 	    for (m = msym + 1; m < pDph_t->nsymbtot; m++)

  00f0b	8d 7b 01	 lea	 edi, DWORD PTR [ebx+1]
  00f0e	66 3b be 82 17
	00 00		 cmp	 di, WORD PTR [esi+6018]
  00f15	0f 8d d7 00 00
	00		 jge	 $L71971
$L71552:

; 263  : 		{
; 264  : 			if (pDph_t->symbols[m] == S2)

  00f1b	0f bf cf	 movsx	 ecx, di
  00f1e	66 8b 84 4e 26
	15 00 00	 mov	 ax, WORD PTR [esi+ecx*2+5414]
  00f26	66 3d 66 00	 cmp	 ax, 102			; 00000066H
  00f2a	74 54		 je	 SHORT $L71968

; 270  : #ifdef DEBUGIND
; 271  : 
; 272  : 				printf ("delete rule S2\n");
; 273  : #endif
; 274  : 
; 275  : 				return;
; 276  : 			}
; 277  : 			if (is_wboundary (pDph_t->symbols[m]))

  00f2c	50		 push	 eax
  00f2d	e8 00 00 00 00	 call	 _is_wboundary
  00f32	83 c4 04	 add	 esp, 4
  00f35	85 c0		 test	 eax, eax
  00f37	0f 85 b5 00 00
	00		 jne	 $L71971
  00f3d	47		 inc	 edi
  00f3e	66 3b be 82 17
	00 00		 cmp	 di, WORD PTR [esi+6018]
  00f45	7c d4		 jl	 SHORT $L71552

; 336  : 			return;
; 337  : 		}
; 338  : 		else if ((phone_feature(pDph_t, pDph_t->symbols[m]) & FSYLL) IS_PLUS)

  00f47	e9 a6 00 00 00	 jmp	 $L71971
$L71966:

; 245  : 			{
; 246  : 				pDph_t->symbols[m] = SEMPH;

  00f4c	0f bf c7	 movsx	 eax, di

; 247  : 				pDph_t->user_durs[m] = durdangle;
; 248  : 				pDph_t->user_f0[m] = f0dangle;
; 249  : 				delete_symbol (phTTS, msym);

  00f4f	53		 push	 ebx
  00f50	66 c7 84 46 26
	15 00 00 68 00	 mov	 WORD PTR [esi+eax*2+5414], 104 ; 00000068H
  00f5a	8b 8e 84 17 00
	00		 mov	 ecx, DWORD PTR [esi+6020]
  00f60	66 89 2c 41	 mov	 WORD PTR [ecx+eax*2], bp
  00f64	8b 96 88 17 00
	00		 mov	 edx, DWORD PTR [esi+6024]
  00f6a	66 89 2c 42	 mov	 WORD PTR [edx+eax*2], bp
  00f6e	8b 44 24 18	 mov	 eax, DWORD PTR _phTTS$[esp+16]
  00f72	50		 push	 eax
  00f73	e8 00 00 00 00	 call	 _delete_symbol
  00f78	83 c4 08	 add	 esp, 8
  00f7b	5f		 pop	 edi
  00f7c	5e		 pop	 esi
  00f7d	5d		 pop	 ebp
  00f7e	5b		 pop	 ebx

; 350  : 		}
; 351  : 	}
; 352  : }

  00f7f	c3		 ret	 0
$L71968:

; 265  : 			{
; 266  : 				pDph_t->symbols[m] = SEMPH;

  00f80	0f bf c7	 movsx	 eax, di

; 267  : 				pDph_t->user_durs[m] = durdangle;
; 268  : 				pDph_t->user_f0[m] = f0dangle;
; 269  : 				delete_symbol (phTTS, msym);

  00f83	53		 push	 ebx
  00f84	66 c7 84 46 26
	15 00 00 68 00	 mov	 WORD PTR [esi+eax*2+5414], 104 ; 00000068H
  00f8e	8b 96 84 17 00
	00		 mov	 edx, DWORD PTR [esi+6020]
  00f94	66 89 2c 42	 mov	 WORD PTR [edx+eax*2], bp
  00f98	8b 8e 88 17 00
	00		 mov	 ecx, DWORD PTR [esi+6024]
  00f9e	8b 54 24 18	 mov	 edx, DWORD PTR _phTTS$[esp+16]
  00fa2	52		 push	 edx
  00fa3	66 89 2c 41	 mov	 WORD PTR [ecx+eax*2], bp
  00fa7	e8 00 00 00 00	 call	 _delete_symbol
  00fac	83 c4 08	 add	 esp, 8
  00faf	5f		 pop	 edi
  00fb0	5e		 pop	 esi
  00fb1	5d		 pop	 ebp
  00fb2	5b		 pop	 ebx

; 350  : 		}
; 351  : 	}
; 352  : }

  00fb3	c3		 ret	 0
$L71969:

; 278  : 			{
; 279  : 				break;	/* No longer current word, give up S2 search */
; 280  : 			}
; 281  : 		}
; 282  : 	}
; 283  : 	/* 2. If primary stress, replace the first secondary stress encountered */
; 284  : 	/* in word; if none, attach to first vowel in word via step 3 below.    */
; 285  : 	if (stdangle == S1)

  00fb4	66 83 f9 67	 cmp	 cx, 103			; 00000067H
  00fb8	75 38		 jne	 SHORT $L71971

; 286  : 	{
; 287  : 		for (m = msym + 1; m < pDph_t->nsymbtot; m++)

  00fba	8d 7b 01	 lea	 edi, DWORD PTR [ebx+1]
  00fbd	66 3b be 82 17
	00 00		 cmp	 di, WORD PTR [esi+6018]
  00fc4	7d 2c		 jge	 SHORT $L71971
$L71558:

; 288  : 		{
; 289  : 			if (pDph_t->symbols[m] == S2)

  00fc6	0f bf c7	 movsx	 eax, di
  00fc9	66 8b 84 46 26
	15 00 00	 mov	 ax, WORD PTR [esi+eax*2+5414]
  00fd1	66 3d 66 00	 cmp	 ax, 102			; 00000066H
  00fd5	0f 84 bd 00 00
	00		 je	 $L71970

; 300  : 				return;
; 301  : 			}
; 302  : 			if (is_wboundary (pDph_t->symbols[m]))

  00fdb	50		 push	 eax
  00fdc	e8 00 00 00 00	 call	 _is_wboundary
  00fe1	83 c4 04	 add	 esp, 4
  00fe4	85 c0		 test	 eax, eax
  00fe6	75 0a		 jne	 SHORT $L71971
  00fe8	47		 inc	 edi
  00fe9	66 3b be 82 17
	00 00		 cmp	 di, WORD PTR [esi+6018]
  00ff0	7c d4		 jl	 SHORT $L71558
$L71971:

; 303  : 			{
; 304  : 				break;	/* No longer current word, give up S2 search */
; 305  : 			}
; 306  : 		}
; 307  : 	}
; 308  : 	/* 3. Attach to first vowel encountered, use stronger of two stresses if */
; 309  : 	/* another stress encountered before vowel encountered */
; 310  : 	for (m = msym + 1; m < pDph_t->nsymbtot; m++)

  00ff2	43		 inc	 ebx
  00ff3	66 3b 9e 82 17
	00 00		 cmp	 bx, WORD PTR [esi+6018]
  00ffa	0f 8d 3b 01 00
	00		 jge	 $L71565
$L71563:

; 311  : 	{
; 312  : 		if (is_wboundary (pDph_t->symbols[m]))

  01000	0f bf fb	 movsx	 edi, bx
  01003	66 8b 8c 7e 26
	15 00 00	 mov	 cx, WORD PTR [esi+edi*2+5414]
  0100b	51		 push	 ecx
  0100c	e8 00 00 00 00	 call	 _is_wboundary
  01011	83 c4 04	 add	 esp, 4
  01014	85 c0		 test	 eax, eax
  01016	0f 85 e5 00 00
	00		 jne	 $L71972

; 313  : 		{
; 314  : #ifdef DEBUGIND
; 315  : 
; 316  : 			printf ("delete rule 5\n");
; 317  : #endif
; 318  : 
; 319  : 			delete_symbol (phTTS, (short)(m - 1) ); // NAL warning removal
; 320  : 			return;
; 321  : 		}
; 322  : 		if (((pDph_t->symbols[m]& PVALUE) >= S2) && ((pDph_t->symbols[m]& PVALUE) <= SEMPH))

  0101c	66 8b 84 7e 26
	15 00 00	 mov	 ax, WORD PTR [esi+edi*2+5414]
  01024	8b c8		 mov	 ecx, eax
  01026	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0102c	66 83 f9 66	 cmp	 cx, 102			; 00000066H
  01030	7c 0a		 jl	 SHORT $L71568
  01032	66 83 f9 68	 cmp	 cx, 104			; 00000068H
  01036	0f 8e 90 00 00
	00		 jle	 $L71973
$L71568:

; 336  : 			return;
; 337  : 		}
; 338  : 		else if ((phone_feature(pDph_t, pDph_t->symbols[m]) & FSYLL) IS_PLUS)

  0103c	0f bf c8	 movsx	 ecx, ax
  0103f	8b d1		 mov	 edx, ecx
  01041	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  01047	c1 fa 08	 sar	 edx, 8
  0104a	8b 14 95 00 00
	00 00		 mov	 edx, DWORD PTR _all_featb[edx*4]
  01051	f6 04 4a 01	 test	 BYTE PTR [edx+ecx*2], 1
  01055	0f 85 ba 00 00
	00		 jne	 $L71974

; 343  : 			return;
; 344  : 		}
; 345  : 		else
; 346  : 		{
; 347  : 			pDph_t->symbols[m - 1] = pDph_t->symbols[m];	/* Move symbol backward one */

  0105b	66 89 84 7e 24
	15 00 00	 mov	 WORD PTR [esi+edi*2+5412], ax

; 348  : 			pDph_t->user_durs[m - 1] = pDph_t->user_durs[m];

  01063	8b 86 84 17 00
	00		 mov	 eax, DWORD PTR [esi+6020]
  01069	43		 inc	 ebx
  0106a	66 8b 0c 78	 mov	 cx, WORD PTR [eax+edi*2]
  0106e	8d 04 78	 lea	 eax, DWORD PTR [eax+edi*2]
  01071	66 89 48 fe	 mov	 WORD PTR [eax-2], cx

; 349  : 			pDph_t->user_f0[m - 1] = pDph_t->user_f0[m];

  01075	8b 96 88 17 00
	00		 mov	 edx, DWORD PTR [esi+6024]
  0107b	66 8b 0c 7a	 mov	 cx, WORD PTR [edx+edi*2]
  0107f	8d 04 7a	 lea	 eax, DWORD PTR [edx+edi*2]
  01082	66 89 48 fe	 mov	 WORD PTR [eax-2], cx
  01086	66 3b 9e 82 17
	00 00		 cmp	 bx, WORD PTR [esi+6018]
  0108d	0f 8c 6d ff ff
	ff		 jl	 $L71563
  01093	5f		 pop	 edi
  01094	5e		 pop	 esi
  01095	5d		 pop	 ebp
  01096	5b		 pop	 ebx

; 350  : 		}
; 351  : 	}
; 352  : }

  01097	c3		 ret	 0
$L71970:

; 290  : 			{
; 291  : 				pDph_t->symbols[m] = S1;

  01098	0f bf c7	 movsx	 eax, di

; 292  : 				pDph_t->user_durs[m] = durdangle;
; 293  : 				pDph_t->user_f0[m] = f0dangle;
; 294  : #ifdef DEBUGIND
; 295  : 
; 296  : 				printf ("delete rule 4\n");
; 297  : #endif
; 298  : 
; 299  : 				delete_symbol (phTTS, msym);

  0109b	53		 push	 ebx
  0109c	66 c7 84 46 26
	15 00 00 67 00	 mov	 WORD PTR [esi+eax*2+5414], 103 ; 00000067H
  010a6	8b 8e 84 17 00
	00		 mov	 ecx, DWORD PTR [esi+6020]
  010ac	66 89 2c 41	 mov	 WORD PTR [ecx+eax*2], bp
  010b0	8b 96 88 17 00
	00		 mov	 edx, DWORD PTR [esi+6024]
  010b6	66 89 2c 42	 mov	 WORD PTR [edx+eax*2], bp
  010ba	8b 44 24 18	 mov	 eax, DWORD PTR _phTTS$[esp+16]
  010be	50		 push	 eax
  010bf	e8 00 00 00 00	 call	 _delete_symbol
  010c4	83 c4 08	 add	 esp, 8
  010c7	5f		 pop	 edi
  010c8	5e		 pop	 esi
  010c9	5d		 pop	 ebp
  010ca	5b		 pop	 ebx

; 350  : 		}
; 351  : 	}
; 352  : }

  010cb	c3		 ret	 0
$L71973:

; 323  : 		{
; 324  : 			if ((pDph_t->symbols[m]& PVALUE) < stdangle)

  010cc	8b 7c 24 18	 mov	 edi, DWORD PTR _stdangle$[esp+12]
  010d0	0f bf c3	 movsx	 eax, bx
  010d3	8a 8c 46 26 15
	00 00		 mov	 cl, BYTE PTR [esi+eax*2+5414]
  010da	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  010e0	66 3b cf	 cmp	 cx, di
  010e3	7d 1c		 jge	 SHORT $L71972

; 325  : 			{
; 326  : 				pDph_t->symbols[m] = stdangle;

  010e5	66 89 bc 46 26
	15 00 00	 mov	 WORD PTR [esi+eax*2+5414], di

; 327  : 				pDph_t->user_durs[m] = durdangle;

  010ed	8b 96 84 17 00
	00		 mov	 edx, DWORD PTR [esi+6020]
  010f3	66 89 2c 42	 mov	 WORD PTR [edx+eax*2], bp

; 328  : 				pDph_t->user_f0[m] = f0dangle;

  010f7	8b 8e 88 17 00
	00		 mov	 ecx, DWORD PTR [esi+6024]
  010fd	66 89 2c 41	 mov	 WORD PTR [ecx+eax*2], bp
$L71972:

; 329  : 			}
; 330  : #ifdef DEBUGIND
; 331  : 
; 332  : 			printf ("delete rule 6\n");
; 333  : #endif
; 334  : 
; 335  : 			delete_symbol (phTTS, (short)(m - 1) ); // NAL warning removal

  01101	8b 54 24 14	 mov	 edx, DWORD PTR _phTTS$[esp+12]
  01105	4b		 dec	 ebx
  01106	53		 push	 ebx
  01107	52		 push	 edx
  01108	e8 00 00 00 00	 call	 _delete_symbol
  0110d	83 c4 08	 add	 esp, 8
  01110	5f		 pop	 edi
  01111	5e		 pop	 esi
  01112	5d		 pop	 ebp
  01113	5b		 pop	 ebx

; 350  : 		}
; 351  : 	}
; 352  : }

  01114	c3		 ret	 0
$L71974:

; 339  : 		{
; 340  : 			pDph_t->symbols[m - 1] = stdangle;	/* Found syllabic, put stress here */

  01115	66 8b 4c 24 18	 mov	 cx, WORD PTR _stdangle$[esp+12]
  0111a	0f bf c3	 movsx	 eax, bx
  0111d	66 89 8c 46 24
	15 00 00	 mov	 WORD PTR [esi+eax*2+5412], cx

; 341  : 			pDph_t->user_durs[m - 1] = durdangle;

  01125	8b 96 84 17 00
	00		 mov	 edx, DWORD PTR [esi+6020]
  0112b	66 89 6c 42 fe	 mov	 WORD PTR [edx+eax*2-2], bp

; 342  : 			pDph_t->user_f0[m - 1] = f0dangle;

  01130	8b 8e 88 17 00
	00		 mov	 ecx, DWORD PTR [esi+6024]
  01136	66 89 6c 41 fe	 mov	 WORD PTR [ecx+eax*2-2], bp
$L71565:
  0113b	5f		 pop	 edi
  0113c	5e		 pop	 esi
  0113d	5d		 pop	 ebp
  0113e	5b		 pop	 ebx

; 350  : 		}
; 351  : 	}
; 352  : }

  0113f	c3		 ret	 0
_move_stdangle ENDP
_pDph_t$ = 8
_psCurr_dur$ = 12
_psCurr_f0$ = 16
_curr_in_sym$ = 20
_psMf0$ = 24
_interp_user_f0 PROC NEAR

; 1857 : 	/* If attached to a 1-stress symbol, dur,f0 mean stress-impulse commands */
; 1858 : #if defined ENGLISH || defined GERMAN || defined FRENCH
; 1859 : 	if (((curr_in_sym == S1) || (curr_in_sym == SEMPH)
; 1860 : 		|| (curr_in_sym == HAT_RISE) || (curr_in_sym == HAT_FALL))
; 1861 : 		&& (pDph_t->f0mode != PHONE_TARGETS_SPECIFIED)
; 1862 : 		&& (pDph_t->f0mode != SINGING))

  01140	8b 54 24 04	 mov	 edx, DWORD PTR _pDph_t$[esp-4]
  01144	53		 push	 ebx
  01145	66 8b 5c 24 14	 mov	 bx, WORD PTR _curr_in_sym$[esp]
  0114a	56		 push	 esi
  0114b	66 83 fb 67	 cmp	 bx, 103			; 00000067H
  0114f	74 16		 je	 SHORT $L71714
  01151	66 83 fb 68	 cmp	 bx, 104			; 00000068H
  01155	74 10		 je	 SHORT $L71714
  01157	66 83 fb 69	 cmp	 bx, 105			; 00000069H
  0115b	74 0a		 je	 SHORT $L71714
  0115d	66 83 fb 6a	 cmp	 bx, 106			; 0000006aH
  01161	0f 85 a7 00 00
	00		 jne	 $L71713
$L71714:
  01167	66 8b b2 9c 17
	00 00		 mov	 si, WORD PTR [edx+6044]
  0116e	66 83 fe 05	 cmp	 si, 5
  01172	0f 84 96 00 00
	00		 je	 $L71713
  01178	66 83 fe 04	 cmp	 si, 4
  0117c	0f 84 8c 00 00
	00		 je	 $L71713

; 1863 : #endif
; 1864 : #ifdef SPANISH
; 1865 : 	if (((curr_in_sym == S1) || (curr_in_sym == SEMPH)
; 1866 : 		|| (curr_in_sym == HAT_RISE) || (curr_in_sym == HAT_FALL))
; 1867 : 		&& ((pDph_t->f0mode != PHONE_TARGETS_SPECIFIED)
; 1868 : 		&& (pDph_t->f0mode != SINGING)))
; 1869 : #endif
; 1870 : 	{
; 1871 : 		if ((*psCurr_f0 != 0) || (pDph_t->f0mode == HAT_F0_SIZES_SPECIFIED))

  01182	8b 44 24 14	 mov	 eax, DWORD PTR _psCurr_f0$[esp+4]
  01186	57		 push	 edi
  01187	8b 7c 24 20	 mov	 edi, DWORD PTR _psMf0$[esp+8]
  0118b	66 8b 08	 mov	 cx, WORD PTR [eax]
  0118e	66 85 c9	 test	 cx, cx
  01191	75 06		 jne	 SHORT $L71716
  01193	66 83 fe 03	 cmp	 si, 3
  01197	75 6e		 jne	 SHORT $L71715
$L71716:

; 1872 : 		{
; 1873 : 			/* Truncate f0 gestures that are unreasonable */
; 1874 : 			if (*psCurr_f0 < 0)

  01199	66 85 c9	 test	 cx, cx
  0119c	7d 05		 jge	 SHORT $L71717

; 1875 : 				*psCurr_f0 = -(*psCurr_f0);

  0119e	f7 d9		 neg	 ecx
  011a0	66 89 08	 mov	 WORD PTR [eax], cx
$L71717:

; 1876 : 			if (*psCurr_f0 > 199)

  011a3	66 81 38 c7 00	 cmp	 WORD PTR [eax], 199	; 000000c7H
  011a8	7e 05		 jle	 SHORT $L71718

; 1877 : 				*psCurr_f0 = 199;	   /* Should be about 50 */

  011aa	66 c7 00 c7 00	 mov	 WORD PTR [eax], 199	; 000000c7H
$L71718:

; 1878 : 			/* Attach flags to identify what kind of f0 gesture */
; 1879 : 			if (curr_in_sym == HAT_RISE)

  011af	66 83 fb 69	 cmp	 bx, 105			; 00000069H
  011b3	75 07		 jne	 SHORT $L71719

; 1880 : 				*psCurr_f0 += 200;

  011b5	66 81 00 c8 00	 add	 WORD PTR [eax], 200	; 000000c8H

; 1881 : 			else if (curr_in_sym == HAT_FALL)

  011ba	eb 12		 jmp	 SHORT $L71722
$L71719:
  011bc	66 83 fb 6a	 cmp	 bx, 106			; 0000006aH
  011c0	75 07		 jne	 SHORT $L71721

; 1882 : 				*psCurr_f0 += 400;

  011c2	66 81 00 90 01	 add	 WORD PTR [eax], 400	; 00000190H

; 1883 : 			else

  011c7	eb 05		 jmp	 SHORT $L71722
$L71721:

; 1884 : 				*psCurr_f0 += 1000;

  011c9	66 81 00 e8 03	 add	 WORD PTR [eax], 1000	; 000003e8H
$L71722:

; 1885 : 			pDph_t->user_f0[*psMf0] = *psCurr_f0;

  011ce	0f bf 0f	 movsx	 ecx, WORD PTR [edi]
  011d1	8b b2 88 17 00
	00		 mov	 esi, DWORD PTR [edx+6024]
  011d7	66 8b 18	 mov	 bx, WORD PTR [eax]
  011da	55		 push	 ebp
  011db	66 89 1c 4e	 mov	 WORD PTR [esi+ecx*2], bx

; 1886 : 			pDph_t->user_offset[*psMf0] = *psCurr_dur;

  011df	8b 4c 24 18	 mov	 ecx, DWORD PTR _psCurr_dur$[esp+12]
  011e3	0f bf 37	 movsx	 esi, WORD PTR [edi]
  011e6	8b 9a 8c 17 00
	00		 mov	 ebx, DWORD PTR [edx+6028]
  011ec	66 8b 29	 mov	 bp, WORD PTR [ecx]
  011ef	66 89 2c 73	 mov	 WORD PTR [ebx+esi*2], bp

; 1887 : 			*psCurr_dur = 0;

  011f3	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0

; 1888 : 			*psCurr_f0 = 0;

  011f8	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 1889 : 			pDph_t->f0mode = HAT_F0_SIZES_SPECIFIED;

  011fd	66 c7 82 9c 17
	00 00 03 00	 mov	 WORD PTR [edx+6044], 3
  01206	5d		 pop	 ebp
$L71715:

; 1890 : 		}
; 1891 : 		/* mf0 counts # of HAT_RISE, HAT_FALL, S1, & SEMPH pDph_t->symbols */
; 1892 : 		(*psMf0)++;

  01207	66 ff 07	 inc	 WORD PTR [edi]
  0120a	5f		 pop	 edi
  0120b	5e		 pop	 esi
  0120c	5b		 pop	 ebx

; 1930 : 		}
; 1931 : 	}
; 1932 : }

  0120d	c3		 ret	 0
$L71713:

; 1893 : 	}
; 1894 : 	/* Otherwise, they are note commands for singing, or f0 targets for segs */
; 1895 : 	else if (*psCurr_f0 != 0)

  0120e	8b 74 24 14	 mov	 esi, DWORD PTR _psCurr_f0$[esp+4]
  01212	66 8b 0e	 mov	 cx, WORD PTR [esi]
  01215	66 85 c9	 test	 cx, cx
  01218	74 56		 je	 SHORT $L71730

; 1896 : 	{
; 1897 : 		if (pDph_t->f0mode != HAT_F0_SIZES_SPECIFIED)

  0121a	66 8b 82 9c 17
	00 00		 mov	 ax, WORD PTR [edx+6044]
  01221	66 3d 03 00	 cmp	 ax, 3
  01225	74 3b		 je	 SHORT $L71725

; 1898 : 		{
; 1899 : 			if ((pDph_t->f0mode != PHONE_TARGETS_SPECIFIED)
; 1900 : 				&& (*psCurr_f0 <= 37))

  01227	66 3d 05 00	 cmp	 ax, 5
  0122b	74 12		 je	 SHORT $L71726
  0122d	66 83 f9 25	 cmp	 cx, 37			; 00000025H
  01231	7f 0c		 jg	 SHORT $L71726
  01233	5e		 pop	 esi

; 1901 : 			{
; 1902 : 				pDph_t->f0mode = SINGING;

  01234	66 c7 82 9c 17
	00 00 04 00	 mov	 WORD PTR [edx+6044], 4
  0123d	5b		 pop	 ebx

; 1930 : 		}
; 1931 : 	}
; 1932 : }

  0123e	c3		 ret	 0
$L71726:

; 1903 : 			}
; 1904 : 			else if (pDph_t->f0mode != SINGING)

  0123f	66 3d 04 00	 cmp	 ax, 4
  01243	74 0c		 je	 SHORT $L71728
  01245	5e		 pop	 esi

; 1905 : 			{
; 1906 : 				pDph_t->f0mode = PHONE_TARGETS_SPECIFIED;

  01246	66 c7 82 9c 17
	00 00 05 00	 mov	 WORD PTR [edx+6044], 5
  0124f	5b		 pop	 ebx

; 1930 : 		}
; 1931 : 	}
; 1932 : }

  01250	c3		 ret	 0
$L71728:

; 1907 : 			}
; 1908 : 			else
; 1909 : 			{
; 1910 : 
; 1911 : #ifdef DEBUG_USER_PROSODICS
; 1912 : 				printf (
; 1913 : 						   "ERROR in PHSORT: f0 commands for singing and phoneme-targets intermixed\n");
; 1914 : #endif
; 1915 : 
; 1916 : 				*psCurr_dur = 0;

  01251	8b 54 24 10	 mov	 edx, DWORD PTR _psCurr_dur$[esp+4]
  01255	66 c7 02 00 00	 mov	 WORD PTR [edx], 0

; 1929 : 			*psCurr_f0 = 0;

  0125a	66 c7 06 00 00	 mov	 WORD PTR [esi], 0
  0125f	5e		 pop	 esi
  01260	5b		 pop	 ebx

; 1930 : 		}
; 1931 : 	}
; 1932 : }

  01261	c3		 ret	 0
$L71725:

; 1917 : 				*psCurr_f0 = 0;
; 1918 : 			}
; 1919 : 		}
; 1920 : 		else
; 1921 : 		{
; 1922 : 
; 1923 : #ifdef DEBUG_USER_PROSODICS
; 1924 : 			printf (
; 1925 : 					   "ERROR in PHSORT: f0 commands for phonemes and stress/hat pDph_t->symbols intermixed\n");
; 1926 : #endif
; 1927 : 
; 1928 : 			*psCurr_dur = 0;

  01262	8b 44 24 10	 mov	 eax, DWORD PTR _psCurr_dur$[esp+4]
  01266	66 c7 00 00 00	 mov	 WORD PTR [eax], 0

; 1929 : 			*psCurr_f0 = 0;

  0126b	66 c7 06 00 00	 mov	 WORD PTR [esi], 0
$L71730:
  01270	5e		 pop	 esi
  01271	5b		 pop	 ebx

; 1930 : 		}
; 1931 : 	}
; 1932 : }

  01272	c3		 ret	 0
_interp_user_f0 ENDP
_symb$ = 8
_is_wboundary PROC NEAR

; 1953 : 	if ((symb >= WBOUND) && (symb <= EXCLAIM))

  01280	66 8b 44 24 04	 mov	 ax, WORD PTR _symb$[esp-4]
  01285	66 3d 6f 00	 cmp	 ax, 111			; 0000006fH
  01289	7c 0c		 jl	 SHORT $L71734
  0128b	66 3d 76 00	 cmp	 ax, 118			; 00000076H
  0128f	7f 06		 jg	 SHORT $L71734

; 1954 : 	{
; 1955 : 		return (TRUE);

  01291	b8 01 00 00 00	 mov	 eax, 1

; 1958 : }

  01296	c3		 ret	 0
$L71734:

; 1956 : 	}
; 1957 : 	return (FALSE);

  01297	33 c0		 xor	 eax, eax

; 1958 : }

  01299	c3		 ret	 0
_is_wboundary ENDP
_phTTS$ = 8
_loc$ = 12
_fone$ = 16
_pKsd_t$ = 8
_insertphone PROC NEAR

; 1977 : 	short                   m;
; 1978 : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;

  012a0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  012a4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 1979 : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  012a7	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  012aa	89 4c 24 04	 mov	 DWORD PTR _pKsd_t$[esp-4], ecx

; 1980 : 
; 1981 : 	if (pDph_t->nsymbtot >= NPHON_MAX)

  012ae	66 8b 88 82 17
	00 00		 mov	 cx, WORD PTR [eax+6018]
  012b5	66 81 f9 2c 01	 cmp	 cx, 300			; 0000012cH
  012ba	0f 8d 9c 00 00
	00		 jge	 $L71749
  012c0	53		 push	 ebx

; 1982 : 		return;						   /* No room, do nothing */
; 1983 : 	for (m = pDph_t->nsymbtot; m > loc; m--)

  012c1	66 8b 5c 24 0c	 mov	 bx, WORD PTR _loc$[esp]
  012c6	66 3b cb	 cmp	 cx, bx
  012c9	56		 push	 esi
  012ca	7e 46		 jle	 SHORT $L71748
  012cc	55		 push	 ebp
  012cd	57		 push	 edi
  012ce	0f bf f1	 movsx	 esi, cx
  012d1	0f bf fb	 movsx	 edi, bx
  012d4	8d 0c 36	 lea	 ecx, DWORD PTR [esi+esi]
  012d7	8d 94 70 26 15
	00 00		 lea	 edx, DWORD PTR [eax+esi*2+5414]
  012de	2b f7		 sub	 esi, edi
  012e0	8b fe		 mov	 edi, esi
$L71746:

; 1984 : 	{
; 1985 : 		pDph_t->symbols[m]  = pDph_t->symbols[m - 1];

  012e2	66 8b 72 fe	 mov	 si, WORD PTR [edx-2]
  012e6	66 89 32	 mov	 WORD PTR [edx], si

; 1986 : 		pDph_t->user_durs[m] = pDph_t->user_durs[m - 1];	/* Push down */

  012e9	8b b0 84 17 00
	00		 mov	 esi, DWORD PTR [eax+6020]
  012ef	03 f1		 add	 esi, ecx
  012f1	83 ea 02	 sub	 edx, 2
  012f4	66 8b 6e fe	 mov	 bp, WORD PTR [esi-2]
  012f8	66 89 2e	 mov	 WORD PTR [esi], bp

; 1987 : 		pDph_t->user_f0[m] = pDph_t->user_f0[m - 1];	/* user dur/f0 */

  012fb	8b b0 88 17 00
	00		 mov	 esi, DWORD PTR [eax+6024]
  01301	03 f1		 add	 esi, ecx
  01303	83 e9 02	 sub	 ecx, 2
  01306	4f		 dec	 edi
  01307	66 8b 6e fe	 mov	 bp, WORD PTR [esi-2]
  0130b	66 89 2e	 mov	 WORD PTR [esi], bp
  0130e	75 d2		 jne	 SHORT $L71746
  01310	5f		 pop	 edi
  01311	5d		 pop	 ebp
$L71748:

; 1988 : 	}
; 1989 : 	pDph_t->symbols[loc] = fone;

  01312	66 8b 54 24 14	 mov	 dx, WORD PTR _fone$[esp+4]
  01317	0f bf cb	 movsx	 ecx, bx
  0131a	66 89 94 48 26
	15 00 00	 mov	 WORD PTR [eax+ecx*2+5414], dx

; 1990 : #ifdef SPANISH
; 1991 : 	if(pDph_t->specdur >0)
; 1992 : 	{
; 1993 : 		pDph_t->user_durs[loc] = pDph_t->specdur;
; 1994 : 		pDph_t->specdur=0;
; 1995 : 	}
; 1996 : 	else
; 1997 : #endif
; 1998 : 		pDph_t->user_durs[loc] = 0;

  01322	8b b0 84 17 00
	00		 mov	 esi, DWORD PTR [eax+6020]
  01328	66 c7 04 4e 00
	00		 mov	 WORD PTR [esi+ecx*2], 0

; 1999 : 	pDph_t->user_f0[loc] = 0;

  0132e	8b b0 88 17 00
	00		 mov	 esi, DWORD PTR [eax+6024]
  01334	66 c7 04 4e 00
	00		 mov	 WORD PTR [esi+ecx*2], 0

; 2000 : 	pDph_t->nsymbtot++;

  0133a	66 ff 80 82 17
	00 00		 inc	 WORD PTR [eax+6018]
  01341	5e		 pop	 esi

; 2001 : 	if (fone != S1) {				/* KSB - Fixed for index marks */

  01342	66 83 fa 67	 cmp	 dx, 103			; 00000067H
  01346	5b		 pop	 ebx
  01347	74 13		 je	 SHORT $L71749

; 2002 : #ifdef MSDOS
; 2003 : 		adjust_index ((loc + 1), 1, 0);
; 2004 : #else
; 2005 : 		adjust_index (pKsd_t, (loc + 1), 1, 0);

  01349	8b 54 24 04	 mov	 edx, DWORD PTR _pKsd_t$[esp-4]
  0134d	6a 00		 push	 0
  0134f	41		 inc	 ecx
  01350	6a 01		 push	 1
  01352	51		 push	 ecx
  01353	52		 push	 edx
  01354	e8 00 00 00 00	 call	 _adjust_index
  01359	83 c4 10	 add	 esp, 16			; 00000010H
$L71749:

; 2006 : #endif
; 2007 : 	}
; 2008 : #ifdef DEBUGIND
; 2009 : 	printf ("loc %d pDph_t->nsymbtot %d \n", loc, pDph_t->nsymbtot);
; 2010 : 	printf ("adj +1 inserting %d \n", fone);
; 2011 : #endif
; 2012 : 	return;
; 2013 : }

  0135c	c3		 ret	 0
_insertphone ENDP
_pDph_t$ = 8
_msym$ = 12
_raise_last_stress PROC NEAR

; 2030 : 	short m;
; 2031 : 
; 2032 : 	for (m = msym - 1; m > 0; m--)

  01360	8b 44 24 08	 mov	 eax, DWORD PTR _msym$[esp-4]
  01364	48		 dec	 eax
  01365	56		 push	 esi
  01366	66 85 c0	 test	 ax, ax
  01369	7e 27		 jle	 SHORT $L71758
  0136b	8b 4c 24 08	 mov	 ecx, DWORD PTR _pDph_t$[esp]
  0136f	b2 67		 mov	 dl, 103			; 00000067H
$L71756:

; 2033 : 	{
; 2034 : 		if ((pDph_t->symbols[m] & PVALUE) == S1)

  01371	0f bf f0	 movsx	 esi, ax
  01374	38 94 71 26 15
	00 00		 cmp	 BYTE PTR [ecx+esi*2+5414], dl
  0137b	74 08		 je	 SHORT $L71991
  0137d	48		 dec	 eax
  0137e	66 85 c0	 test	 ax, ax
  01381	7f ee		 jg	 SHORT $L71756
  01383	5e		 pop	 esi

; 2037 : 			return;
; 2038 : 		}
; 2039 : 	}
; 2040 : }

  01384	c3		 ret	 0
$L71991:

; 2035 : 		{
; 2036 : 			pDph_t->symbols[m] = SEMPH;

  01385	0f bf d0	 movsx	 edx, ax
  01388	66 c7 84 51 26
	15 00 00 68 00	 mov	 WORD PTR [ecx+edx*2+5414], 104 ; 00000068H
$L71758:
  01392	5e		 pop	 esi

; 2037 : 			return;
; 2038 : 		}
; 2039 : 	}
; 2040 : }

  01393	c3		 ret	 0
_raise_last_stress ENDP
_phTTS$ = 8
_msym1$ = 12
_msym2$ = 16
_zap_weaker_bound PROC NEAR

; 2059 : 	/* short m; *//* MVP :Unreferenced variable */
; 2060 : 	//PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 2061 : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  013a0	8b 54 24 04	 mov	 edx, DWORD PTR _phTTS$[esp-4]
  013a4	53		 push	 ebx
  013a5	56		 push	 esi

; 2062 : 
; 2063 : 	if (pDph_t->symbols[msym1] < pDph_t->symbols[msym2])

  013a6	8b 74 24 10	 mov	 esi, DWORD PTR _msym1$[esp+4]
  013aa	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  013ad	57		 push	 edi
  013ae	8b 7c 24 18	 mov	 edi, DWORD PTR _msym2$[esp+8]
  013b2	0f bf ce	 movsx	 ecx, si
  013b5	0f bf df	 movsx	 ebx, di
  013b8	66 8b 8c 48 26
	15 00 00	 mov	 cx, WORD PTR [eax+ecx*2+5414]
  013c0	66 8b 84 58 26
	15 00 00	 mov	 ax, WORD PTR [eax+ebx*2+5414]
  013c8	66 3b c8	 cmp	 cx, ax
  013cb	7d 14		 jge	 SHORT $L71768

; 2064 : 	{
; 2065 : #ifdef GERMAN
; 2066 : 		pDph_t->symbols[msym1] = pDph_t->symbols[msym2];	/* Boundarys can't have */
; 2067 : #endif
; 2068 : #if defined ENGLISH || defined SPANISH || defined FRENCH
; 2069 : 		/* pDph_t->symbols[msym1] = pDph_t->symbols[msym2];    Boundarys can't have */
; 2070 : 		if (pDph_t->symbols[msym1] != HYPHEN)

  013cd	66 83 f9 6e	 cmp	 cx, 110			; 0000006eH
  013d1	74 1e		 je	 SHORT $L71770

; 2071 : 			delete_symbol (phTTS, msym1);

  013d3	56		 push	 esi

; 2078 : #endif
; 2079 : 		delete_symbol (phTTS, msym2);

  013d4	52		 push	 edx
  013d5	e8 00 00 00 00	 call	 _delete_symbol
  013da	83 c4 08	 add	 esp, 8
  013dd	5f		 pop	 edi
  013de	5e		 pop	 esi
  013df	5b		 pop	 ebx

; 2080 : }

  013e0	c3		 ret	 0
$L71768:

; 2072 : 		return;
; 2073 : #endif
; 2074 : 	}
; 2075 : 	/* user durs or f0 */
; 2076 : #if defined ENGLISH || defined SPANISH || defined FRENCH
; 2077 : 	if (pDph_t->symbols[msym2] != HYPHEN)

  013e1	66 3d 6e 00	 cmp	 ax, 110			; 0000006eH
  013e5	74 0a		 je	 SHORT $L71770

; 2078 : #endif
; 2079 : 		delete_symbol (phTTS, msym2);

  013e7	57		 push	 edi
  013e8	52		 push	 edx
  013e9	e8 00 00 00 00	 call	 _delete_symbol
  013ee	83 c4 08	 add	 esp, 8
$L71770:
  013f1	5f		 pop	 edi
  013f2	5e		 pop	 esi
  013f3	5b		 pop	 ebx

; 2080 : }

  013f4	c3		 ret	 0
_zap_weaker_bound ENDP
_phTTS$ = 8
_msym$ = 12
_delete_symbol PROC NEAR

; 2097 : 	short                   m;
; 2098 : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;

  01400	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  01404	53		 push	 ebx
  01405	57		 push	 edi

; 2099 : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;
; 2100 : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;
; 2101 : 
; 2102 : #ifdef DEBUGIND
; 2103 : 	printf ("adj -1 del sym %d at %d \n ", pDph_t->symbols[msym], msym);
; 2104 : #endif
; 2105 : 	pDph_t->nsymbtot--;
; 2106 : 	pDphsettar->did_del = 1;
; 2107 : 	for (m = msym; m < pDph_t->nsymbtot; m++)

  01406	8b 7c 24 10	 mov	 edi, DWORD PTR _msym$[esp+4]
  0140a	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]
  0140d	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  01410	8b d7		 mov	 edx, edi
  01412	8b 88 10 2c 00
	00		 mov	 ecx, DWORD PTR [eax+11280]
  01418	66 ff 88 82 17
	00 00		 dec	 WORD PTR [eax+6018]
  0141f	c7 41 1c 01 00
	00 00		 mov	 DWORD PTR [ecx+28], 1
  01426	66 3b b8 82 17
	00 00		 cmp	 di, WORD PTR [eax+6018]
  0142d	7d 3f		 jge	 SHORT $L71782
  0142f	55		 push	 ebp
  01430	56		 push	 esi
$L71780:

; 2108 : 	{
; 2109 : 		pDph_t->symbols[m] = pDph_t->symbols[m + 1];

  01431	0f bf ca	 movsx	 ecx, dx
  01434	42		 inc	 edx
  01435	66 8b b4 48 28
	15 00 00	 mov	 si, WORD PTR [eax+ecx*2+5416]
  0143d	66 89 b4 48 26
	15 00 00	 mov	 WORD PTR [eax+ecx*2+5414], si

; 2110 : 		pDph_t->user_durs[m] = pDph_t->user_durs[m + 1];	/* If deleted sym has dur or */

  01445	8b b0 84 17 00
	00		 mov	 esi, DWORD PTR [eax+6020]
  0144b	66 8b 6c 4e 02	 mov	 bp, WORD PTR [esi+ecx*2+2]
  01450	66 89 2c 4e	 mov	 WORD PTR [esi+ecx*2], bp

; 2111 : 		pDph_t->user_f0[m] = pDph_t->user_f0[m + 1];	/* f0, it will be lost */

  01454	8b b0 88 17 00
	00		 mov	 esi, DWORD PTR [eax+6024]
  0145a	66 8b 6c 4e 02	 mov	 bp, WORD PTR [esi+ecx*2+2]
  0145f	66 89 2c 4e	 mov	 WORD PTR [esi+ecx*2], bp
  01463	66 3b 90 82 17
	00 00		 cmp	 dx, WORD PTR [eax+6018]
  0146a	7c c5		 jl	 SHORT $L71780
  0146c	5e		 pop	 esi
  0146d	5d		 pop	 ebp
$L71782:

; 2112 : 	}
; 2113 : #ifdef DEBUGIND
; 2114 : 
; 2115 : 	WAIT_PRINT;
; 2116 : 	printf ("\n sym num %d   ", msym);
; 2117 : 	printf ("now %d  \n\n ", pDph_t->symbols[msym]);
; 2118 : 	SIGNAL_PRINT;
; 2119 : #endif
; 2120 : #ifdef MSDOS
; 2121 : 	adjust_index (msym + 1, -1, 1);
; 2122 : #else
; 2123 : 	adjust_index (pKsd_t, msym + 1, -1, 1);

  0146e	0f bf d7	 movsx	 edx, di
  01471	6a 01		 push	 1
  01473	42		 inc	 edx
  01474	6a ff		 push	 -1
  01476	52		 push	 edx
  01477	53		 push	 ebx
  01478	e8 00 00 00 00	 call	 _adjust_index
  0147d	83 c4 10	 add	 esp, 16			; 00000010H
  01480	5f		 pop	 edi
  01481	5b		 pop	 ebx

; 2124 : 	/* 
; 2125 : 	 * plus one because index may be pointing at this
; 2126 : 	 * very one in which case it promotes forward (i.e. stays the same) 
; 2127 : 	 */
; 2128 : #endif
; 2129 : }

  01482	c3		 ret	 0
_delete_symbol ENDP
_symbol$ = 12
_table$ = 16
_durlookup PROC NEAR

; 2137 : 	short *lp;
; 2138 : 	/* GL 03/20/1998, BATS#633  use "unsigned char" instead of "char" */
; 2139 : 	short  	*cp;
; 2140 : 	short  	*tp;
; 2141 : 	int   	len;
; 2142 : 
; 2143 : 	tp = &table[0];                 /* Start at the start.  */
; 2144 : 	while ((len = *tp++) != 0) 

  01490	8b 44 24 0c	 mov	 eax, DWORD PTR _table$[esp-4]
  01494	53		 push	 ebx
  01495	55		 push	 ebp
  01496	56		 push	 esi
  01497	0f bf 18	 movsx	 ebx, WORD PTR [eax]
  0149a	57		 push	 edi
  0149b	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
  0149e	85 db		 test	 ebx, ebx
  014a0	74 3f		 je	 SHORT $L71796

; 2145 : 	{            					/* 0 => end of table.   */
; 2146 : 		lp = symbol;              
; 2147 : 		cp = tp;                    /* Start of text.       */
; 2148 : 		for (;;) 
; 2149 : 		{
; 2150 : 			if (*lp != *cp++)         /* Lose match process   */

  014a2	8b 44 24 18	 mov	 eax, DWORD PTR _symbol$[esp+12]
  014a6	66 8b 28	 mov	 bp, WORD PTR [eax]
$L71795:
  014a9	66 3b 2f	 cmp	 bp, WORD PTR [edi]
  014ac	8b 54 24 18	 mov	 edx, DWORD PTR _symbol$[esp+12]
  014b0	8d 77 02	 lea	 esi, DWORD PTR [edi+2]
  014b3	75 1f		 jne	 SHORT $L72001
  014b5	8b c5		 mov	 eax, ebp
$L71798:

; 2151 : 				break;
; 2152 : 			if (*lp == GEN_SIL)         /* Input string end reached   */

  014b7	66 3d 00 1e	 cmp	 ax, 7680		; 00001e00H
  014bb	74 17		 je	 SHORT $L72001

; 2153 : 				break;
; 2154 : 			if (*cp == EOS)           /* Win.                 */

  014bd	66 8b 0e	 mov	 cx, WORD PTR [esi]
  014c0	66 85 c9	 test	 cx, cx
  014c3	74 23		 je	 SHORT $L72003
  014c5	66 8b 42 02	 mov	 ax, WORD PTR [edx+2]

; 2157 :             }
; 2158 : 			++lp;

  014c9	83 c2 02	 add	 edx, 2
  014cc	83 c6 02	 add	 esi, 2
  014cf	66 3b c1	 cmp	 ax, cx
  014d2	74 e3		 je	 SHORT $L71798
$L72001:

; 2159 : 		   
; 2160 : 		}
; 2161 : 		tp += len;                  /* Next.                */

  014d4	8d 3c 5f	 lea	 edi, DWORD PTR [edi+ebx*2]
  014d7	0f bf 1f	 movsx	 ebx, WORD PTR [edi]
  014da	83 c7 02	 add	 edi, 2
  014dd	85 db		 test	 ebx, ebx
  014df	75 c8		 jne	 SHORT $L71795
$L71796:
  014e1	5f		 pop	 edi
  014e2	5e		 pop	 esi
  014e3	5d		 pop	 ebp

; 2162 : 	}
; 2163 : 	return (NULL);

  014e4	33 c0		 xor	 eax, eax
  014e6	5b		 pop	 ebx

; 2164 : }

  014e7	c3		 ret	 0
$L72003:

; 2155 :             {
; 2156 :                  return (++cp);    	/* Return phonemes.     */

  014e8	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  014eb	5f		 pop	 edi
  014ec	5e		 pop	 esi
  014ed	5d		 pop	 ebp
  014ee	5b		 pop	 ebx

; 2164 : }

  014ef	c3		 ret	 0
_durlookup ENDP
_pDph_t$ = 8
_phoname$ = 12
_n$ = 16
_curr_dur$ = 20
_curr_f0$ = 24
_make_phone PROC NEAR

; 2187 : //helpme
; 2188 :  //phoname &= PVALUE;
; 2189 : #ifdef GERMAN_Boiler// plate safety nonsense we shouldn't need to check
; 2190 : 	if ((phoname < 0) || (phoname >= GRP_TOT_ALLOPHONES))
; 2191 : 	{
; 2192 : 		return;						   /* Ignore this phoneme */
; 2193 : 	}
; 2194 : #endif
; 2195 : 	if (pDph_t->nphonetot > n)

  014f0	8b 44 24 04	 mov	 eax, DWORD PTR _pDph_t$[esp-4]
  014f4	66 8b 88 98 17
	00 00		 mov	 cx, WORD PTR [eax+6040]
  014fb	66 3b 4c 24 0c	 cmp	 cx, WORD PTR _n$[esp-4]
  01500	7f 60		 jg	 SHORT $L71817

; 2196 : 	{
; 2197 : 
; 2198 : 		return;
; 2199 : 	}
; 2200 : 	/* Put phoneme away */
; 2201 : 	pDph_t->phonemes[pDph_t->nphonetot] = phoname;

  01502	8b 90 90 17 00
	00		 mov	 edx, DWORD PTR [eax+6032]
  01508	56		 push	 esi
  01509	66 8b 74 24 0c	 mov	 si, WORD PTR _phoname$[esp]
  0150e	0f bf c9	 movsx	 ecx, cx
  01511	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si

; 2202 : 	pDph_t->user_durs[pDph_t->nphonetot] = curr_dur;	/* Move user-specified dur */

  01515	8b 90 84 17 00
	00		 mov	 edx, DWORD PTR [eax+6020]
  0151b	0f bf 88 98 17
	00 00		 movsx	 ecx, WORD PTR [eax+6040]
  01522	66 8b 74 24 14	 mov	 si, WORD PTR _curr_dur$[esp]
  01527	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si

; 2203 : 	if (pDph_t->f0mode != HAT_F0_SIZES_SPECIFIED)

  0152b	66 83 b8 9c 17
	00 00 03	 cmp	 WORD PTR [eax+6044], 3
  01533	74 16		 je	 SHORT $L71816

; 2204 : 	{
; 2205 : 		pDph_t->user_f0[pDph_t->nphonetot] = curr_f0;	/* Move user-specified f0 */

  01535	0f bf 88 98 17
	00 00		 movsx	 ecx, WORD PTR [eax+6040]
  0153c	8b 90 88 17 00
	00		 mov	 edx, DWORD PTR [eax+6024]
  01542	66 8b 74 24 18	 mov	 si, WORD PTR _curr_f0$[esp]
  01547	66 89 34 4a	 mov	 WORD PTR [edx+ecx*2], si
$L71816:

; 2206 : 	}
; 2207 : 
; 2208 : #ifdef DEBUG_USER_PROSODICS
; 2209 : 	if (curr_dur != 0)
; 2210 : 	{
; 2211 : 		printf ("\tFound user_dur[%s] = %3d ms in PHSORT\n",
; 2212 : 				phprint (phoname), curr_dur);
; 2213 : 	}
; 2214 : 	if (curr_f0 != 0)
; 2215 : 	{
; 2216 : 		printf ("\tFound  pDph_t->user_f0[%s] = %3d Hz in PHSORT, pDph_t->f0mode = %d\n",
; 2217 : 				phprint (phoname), curr_f0, pDph_t->f0mode);
; 2218 : 	}
; 2219 : #endif
; 2220 : 
; 2221 : 	/* tag this index */
; 2222 : 
; 2223 : 	/* set_index_phone(n,nphonetot); */
; 2224 : 	/* See if there is room for next phoneme */
; 2225 : 	if (pDph_t->nphonetot < NPHON_MAX)

  0154b	66 8b 88 98 17
	00 00		 mov	 cx, WORD PTR [eax+6040]
  01552	5e		 pop	 esi
  01553	66 81 f9 2c 01	 cmp	 cx, 300			; 0000012cH
  01558	7d 08		 jge	 SHORT $L71817

; 2226 : 		pDph_t->nphonetot++;

  0155a	41		 inc	 ecx
  0155b	66 89 88 98 17
	00 00		 mov	 WORD PTR [eax+6040], cx
$L71817:

; 2227 : #ifdef DEBUGIND
; 2228 : 
; 2229 : 	printf ("tot= %d phoname=%d \n ", pDph_t->nphonetot, phoname);
; 2230 : #endif
; 2231 : }

  01562	c3		 ret	 0
_make_phone ENDP
_pDph_t$ = 8
_feaname$ = 12
_location$ = 16
_add_feature PROC NEAR

; 2250 : 	if ((location < 0) || (location >= NPHON_MAX))

  01570	66 8b 44 24 0c	 mov	 ax, WORD PTR _location$[esp-4]
  01575	66 85 c0	 test	 ax, ax
  01578	7c 28		 jl	 SHORT $L71828
  0157a	66 3d 2c 01	 cmp	 ax, 300			; 0000012cH
  0157e	7d 22		 jge	 SHORT $L71828

; 2251 : 	{
; 2252 : 		return;
; 2253 : 	}
; 2254 : #ifdef ENGLISH	
; 2255 : 	if ((feaname <= 0) || (feaname > FMAXIMUM))

  01580	8b 4c 24 08	 mov	 ecx, DWORD PTR _feaname$[esp-4]
  01584	85 c9		 test	 ecx, ecx
  01586	7e 1a		 jle	 SHORT $L71828
  01588	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  0158e	7f 12		 jg	 SHORT $L71828

; 2256 : 	{
; 2257 : 		return;
; 2258 : 	}                                          
; 2259 : #endif
; 2260 : #ifdef GERMAN
; 2261 : #ifdef CKFEAT
; 2262 : 	if ((feaname <= 0) || (feaname > FMAXIMUM))
; 2263 : 	{
; 2264 : 		return;
; 2265 : 	}                                          
; 2266 : #endif
; 2267 : #endif
; 2268 : #ifdef FRENCH
; 2269 : 	if ((feaname <= 0) || (feaname > FMAXIMUM))
; 2270 : 	{
; 2271 : 		return;
; 2272 : 	}                                          
; 2273 : #endif
; 2274 : 	/* Do it */
; 2275 : 	pDph_t->sentstruc[location] |= feaname;

  01590	8b 54 24 04	 mov	 edx, DWORD PTR _pDph_t$[esp-4]
  01594	0f bf c0	 movsx	 eax, ax
  01597	8b 92 94 17 00
	00		 mov	 edx, DWORD PTR [edx+6036]
  0159d	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  015a0	09 08		 or	 DWORD PTR [eax], ecx
$L71828:

; 2276 : 
; 2277 : }

  015a2	c3		 ret	 0
_add_feature ENDP
_TEXT	ENDS
PUBLIC	_phone_feature
;	COMDAT _phone_feature
_TEXT	SEGMENT
_phone$ = 12
_phone_feature PROC NEAR				; COMDAT

; 2283 : 	return(all_featb[phone>>8][phone &0xFF]);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _phone$[esp-4]
  00004	8b c8		 mov	 ecx, eax
  00006	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0000b	c1 f9 08	 sar	 ecx, 8
  0000e	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _all_featb[ecx*4]
  00015	66 8b 04 42	 mov	 ax, WORD PTR [edx+eax*2]

; 2284 : #if 0
; 2285 : 	//PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 2286 : 	//PDPH_T                  pDph_t = phTTS->pPHThreadData;
; 2287 : 	//PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;
; 2288 : //#include "ph_def.h"
; 2289 : extern short us_featb[];
; 2290 : extern short uk_featb[];
; 2291 : extern short gr_featb[];
; 2292 : extern short la_featb[];
; 2293 : extern short sp_featb[];
; 2294 : extern short fr_featb[];
; 2295 : 
; 2296 : 	int tmp;
; 2297 : 	tmp = phone & PFONT;
; 2298 : 	if((phone & PVALUE) >= 100 )
; 2299 : 		return(0);
; 2300 : 	phone= phone & PVALUE;
; 2301 : 	if(tmp == PFUSA<<PSFONT)
; 2302 : 	{
; 2303 : 		return(us_featb[phone]);
; 2304 : 	}
; 2305 : 	else if(tmp == PFUK<<PSFONT)
; 2306 : 	{
; 2307 : 		return(uk_featb[phone]);
; 2308 : 	}
; 2309 : 	else if(tmp == PFGR<<PSFONT)
; 2310 : 	{
; 2311 : 		return(gr_featb[phone]);
; 2312 : 	}
; 2313 : 	else if(tmp == PFLA<<PSFONT)
; 2314 : 	{
; 2315 : 		return(la_featb[phone]);
; 2316 : 	}
; 2317 : 	else if(tmp == PFSP<<PSFONT)
; 2318 : 	{
; 2319 : 		return(sp_featb[phone]);
; 2320 : 	}
; 2321 : 	else if(tmp == PFFR<<PSFONT)
; 2322 : 	{
; 2323 : 		return(fr_featb[phone]);
; 2324 : 	}
; 2325 : 	else 
; 2326 : 	{
; 2327 : #ifdef _DEBUG
; 2328 : 	printf("OH MY GOD! THEY'VE KILLED JENNY\n");
; 2329 : #endif
; 2330 : 	return(us_featb[phone]);
; 2331 : 	}
; 2332 : #endif
; 2333 : }

  00019	c3		 ret	 0
_phone_feature ENDP
_TEXT	ENDS
END
