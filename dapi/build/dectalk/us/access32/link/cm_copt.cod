	TITLE	D:\work\Product\dapi\src\Cmd\cm_copt.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_total_commands
PUBLIC	_command_table
PUBLIC	_cm_cmd_rate
PUBLIC	_cm_cmd_name
PUBLIC	_cm_cmd_latin
PUBLIC	_cm_cmd_comma
PUBLIC	_cm_cmd_period
PUBLIC	_cm_cmd_volume
PUBLIC	_cm_cmd_mark
PUBLIC	_cm_cmd_error
PUBLIC	_cm_cmd_phoneme
PUBLIC	_cm_cmd_log
PUBLIC	_cm_cmd_mode
PUBLIC	_cm_cmd_punct
PUBLIC	_cm_cmd_skip
PUBLIC	_cm_cmd_pause
PUBLIC	_cm_cmd_resume
PUBLIC	_cm_cmd_sync
PUBLIC	_cm_cmd_dial
PUBLIC	_cm_cmd_tone
PUBLIC	_cm_cmd_define
PUBLIC	_cm_cmd_say
PUBLIC	_cm_cmd_pronounce
PUBLIC	_cm_cmd_stress
PUBLIC	_cm_cmd_debug
PUBLIC	_cm_cmd_gender
PUBLIC	_cm_cmd_setv
PUBLIC	_cm_cmd_loadv
PUBLIC	_cm_cmd_vs
PUBLIC	_phoneme_modes
PUBLIC	_log_options
PUBLIC	_say_options
PUBLIC	_error_options
PUBLIC	_flush_options
PUBLIC	_punct_options
PUBLIC	_skip_options
PUBLIC	_volume_options
PUBLIC	_lang_options
PUBLIC	_mode_options
PUBLIC	_pronounce_options
PUBLIC	_voice_names
PUBLIC	_index_options
PUBLIC	_gender_options
PUBLIC	_define_options
EXTRN	_cm_cmd_play:NEAR
_BSS	SEGMENT
$SG71410 DB	01H DUP (?)
	ALIGN	4

$SG71412 DB	01H DUP (?)
	ALIGN	4

$SG71414 DB	01H DUP (?)
	ALIGN	4

$SG71416 DB	01H DUP (?)
	ALIGN	4

$SG71418 DB	01H DUP (?)
	ALIGN	4

$SG71420 DB	01H DUP (?)
	ALIGN	4

$SG71422 DB	01H DUP (?)
	ALIGN	4

$SG71424 DB	01H DUP (?)
	ALIGN	4

$SG71426 DB	01H DUP (?)
	ALIGN	4

$SG71428 DB	01H DUP (?)
	ALIGN	4

$SG71462 DB	01H DUP (?)
	ALIGN	4

$SG71464 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_phoneme_modes DD FLAT:$SG71248
	DD	FLAT:$SG71249
	DD	FLAT:$SG71250
	DD	FLAT:$SG71251
	DD	FLAT:$SG71252
	DD	FLAT:$SG71253
	DD	00H
_log_options DD	FLAT:$SG71255
	DD	FLAT:$SG71256
	DD	FLAT:$SG71257
	DD	FLAT:$SG71258
	DD	FLAT:$SG71259
	DD	FLAT:$SG71260
	DD	FLAT:$SG71261
	DD	FLAT:$SG71262
	DD	FLAT:$SG71263
	DD	FLAT:$SG71264
	DD	00H
_say_options DD	FLAT:$SG71266
	DD	FLAT:$SG71267
	DD	FLAT:$SG71268
	DD	FLAT:$SG71269
	DD	FLAT:$SG71270
	DD	FLAT:$SG71271
	DD	00H
_error_options DD FLAT:$SG71273
	DD	FLAT:$SG71274
	DD	FLAT:$SG71275
	DD	FLAT:$SG71276
	DD	FLAT:$SG71277
	DD	00H
_flush_options DD FLAT:$SG71279
	DD	FLAT:$SG71280
	DD	FLAT:$SG71281
	DD	FLAT:$SG71282
	DD	FLAT:$SG71283
	DD	00H
_punct_options DD FLAT:$SG71285
	DD	FLAT:$SG71286
	DD	FLAT:$SG71287
	DD	FLAT:$SG71288
	DD	00H
_skip_options DD FLAT:$SG71290
	DD	FLAT:$SG71291
	DD	FLAT:$SG71292
	DD	FLAT:$SG71293
	DD	FLAT:$SG71294
	DD	FLAT:$SG71295
	DD	00H
_volume_options DD FLAT:$SG71297
	DD	FLAT:$SG71298
	DD	FLAT:$SG71299
	DD	FLAT:$SG71300
	DD	FLAT:$SG71301
	DD	FLAT:$SG71302
	DD	FLAT:$SG71303
	DD	FLAT:$SG71304
	DD	FLAT:$SG71305
	DD	FLAT:$SG71306
	DD	FLAT:$SG71307
	DD	00H
_lang_options DD FLAT:$SG71309
	DD	FLAT:$SG71310
	DD	FLAT:$SG71311
	DD	FLAT:$SG71312
	DD	FLAT:$SG71313
	DD	FLAT:$SG71314
	DD	FLAT:$SG71315
	DD	FLAT:$SG71316
	DD	FLAT:$SG71317
	DD	FLAT:$SG71318
	DD	FLAT:$SG71319
	DD	FLAT:$SG71320
	DD	00H
_mode_options DD FLAT:$SG71322
	DD	FLAT:$SG71323
	DD	FLAT:$SG71324
	DD	FLAT:$SG71325
	DD	FLAT:$SG71326
	DD	FLAT:$SG71327
	DD	FLAT:$SG71328
	DD	FLAT:$SG71329
	DD	FLAT:$SG71330
	DD	FLAT:$SG71331
	DD	FLAT:$SG71332
	DD	FLAT:$SG71333
	DD	00H
_pronounce_options DD FLAT:$SG71335
	DD	FLAT:$SG71336
	DD	FLAT:$SG71337
	DD	FLAT:$SG71338
	DD	FLAT:$SG71339
	DD	FLAT:$SG71340
	DD	FLAT:$SG71341
	DD	FLAT:$SG71342
	DD	00H
_voice_names DD	FLAT:$SG71344
	DD	FLAT:$SG71345
	DD	FLAT:$SG71346
	DD	FLAT:$SG71347
	DD	FLAT:$SG71348
	DD	FLAT:$SG71349
	DD	FLAT:$SG71350
	DD	FLAT:$SG71351
	DD	FLAT:$SG71352
	DD	FLAT:$SG71353
	DD	00H
_index_options DD FLAT:$SG71355
	DD	FLAT:$SG71356
	DD	FLAT:$SG71357
	DD	FLAT:$SG71358
	DD	FLAT:$SG71359
	DD	FLAT:$SG71360
	DD	FLAT:$SG71361
	DD	FLAT:$SG71362
	DD	FLAT:$SG71363
	DD	FLAT:$SG71364
	DD	00H
_gender_options DD FLAT:$SG71366
	DD	FLAT:$SG71367
	DD	FLAT:$SG71368
	DD	00H
_define_options DD FLAT:$SG71370
	DD	FLAT:$SG71371
	DD	FLAT:$SG71372
	DD	FLAT:$SG71373
	DD	FLAT:$SG71374
	DD	FLAT:$SG71375
	DD	FLAT:$SG71376
	DD	FLAT:$SG71377
	DD	FLAT:$SG71378
	DD	FLAT:$SG71379
	DD	FLAT:$SG71380
	DD	FLAT:$SG71381
	DD	FLAT:$SG71382
	DD	FLAT:$SG71383
	DD	FLAT:$SG71384
	DD	FLAT:$SG71385
	DD	FLAT:$SG71386
	DD	FLAT:$SG71387
	DD	FLAT:$SG71388
	DD	FLAT:$SG71389
	DD	FLAT:$SG71390
	DD	FLAT:$SG71391
	DD	FLAT:$SG71392
	DD	FLAT:$SG71393
	DD	FLAT:$SG71394
	DD	FLAT:$SG71395
	DD	FLAT:$SG71396
	DD	FLAT:$SG71397
	DD	FLAT:$SG71398
	DD	FLAT:$SG71399
	DD	FLAT:$SG71400
	DD	FLAT:$SG71401
	DD	FLAT:$SG71402
	DD	00H
_command_table DD FLAT:$SG71403
	DD	FLAT:$SG71404
	DD	01H
	DD	0c8H
	DD	FLAT:_cm_cmd_rate
	DD	FLAT:$SG71405
	DD	FLAT:$SG71406
	DD	01H
	DD	0800aH
	DD	FLAT:_cm_cmd_latin
	DD	FLAT:$SG71407
	DD	FLAT:$SG71408
	DD	01H
	DD	0c9H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71409
	DD	FLAT:$SG71410
	DD	00H
	DD	08000H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71411
	DD	FLAT:$SG71412
	DD	00H
	DD	08001H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71413
	DD	FLAT:$SG71414
	DD	00H
	DD	08002H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71415
	DD	FLAT:$SG71416
	DD	00H
	DD	08003H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71417
	DD	FLAT:$SG71418
	DD	00H
	DD	08004H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71419
	DD	FLAT:$SG71420
	DD	00H
	DD	08005H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71421
	DD	FLAT:$SG71422
	DD	00H
	DD	08006H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71423
	DD	FLAT:$SG71424
	DD	00H
	DD	08007H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71425
	DD	FLAT:$SG71426
	DD	00H
	DD	08008H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71427
	DD	FLAT:$SG71428
	DD	00H
	DD	08009H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71429
	DD	FLAT:$SG71430
	DD	01H
	DD	0caH
	DD	FLAT:_cm_cmd_comma
	DD	FLAT:$SG71431
	DD	FLAT:$SG71432
	DD	01H
	DD	0caH
	DD	FLAT:_cm_cmd_comma
	DD	FLAT:$SG71433
	DD	FLAT:$SG71434
	DD	01H
	DD	0cbH
	DD	FLAT:_cm_cmd_period
	DD	FLAT:$SG71435
	DD	FLAT:$SG71436
	DD	01H
	DD	0cbH
	DD	FLAT:_cm_cmd_period
	DD	FLAT:$SG71437
	DD	FLAT:$SG71438
	DD	03H
	DD	064H
	DD	FLAT:_cm_cmd_volume
	DD	FLAT:$SG71439
	DD	FLAT:$SG71440
	DD	01H
	DD	00H
	DD	FLAT:_cm_cmd_vs
	DD	FLAT:$SG71441
	DD	FLAT:$SG71442
	DD	02H
	DD	014H
	DD	FLAT:_cm_cmd_mark
	DD	FLAT:$SG71443
	DD	FLAT:$SG71444
	DD	01H
	DD	012cH
	DD	FLAT:_cm_cmd_error
	DD	FLAT:$SG71445
	DD	FLAT:$SG71446
	DD	03H
	DD	0258H
	DD	FLAT:_cm_cmd_phoneme
	DD	FLAT:$SG71447
	DD	FLAT:$SG71448
	DD	02H
	DD	051H
	DD	FLAT:_cm_cmd_log
	DD	FLAT:$SG71449
	DD	FLAT:$SG71450
	DD	02H
	DD	050H
	DD	FLAT:_cm_cmd_mode
	DD	FLAT:$SG71451
	DD	FLAT:$SG71452
	DD	01H
	DD	052H
	DD	FLAT:_cm_cmd_say
	DD	FLAT:$SG71453
	DD	FLAT:$SG71454
	DD	01H
	DD	0ccH
	DD	FLAT:_cm_cmd_punct
	DD	FLAT:$SG71455
	DD	FLAT:$SG71456
	DD	01H
	DD	00H
	DD	FLAT:_cm_cmd_skip
	DD	FLAT:$SG71457
	DD	FLAT:$SG71458
	DD	01H
	DD	0cH
	DD	FLAT:_cm_cmd_pause
	DD	FLAT:$SG71459
	DD	FLAT:$SG71460
	DD	01H
	DD	00H
	DD	FLAT:_cm_cmd_play
	DD	FLAT:$SG71461
	DD	FLAT:$SG71462
	DD	00H
	DD	0dH
	DD	FLAT:_cm_cmd_resume
	DD	FLAT:$SG71463
	DD	FLAT:$SG71464
	DD	00H
	DD	0bH
	DD	FLAT:_cm_cmd_sync
	DD	FLAT:$SG71465
	DD	FLAT:$SG71466
	DD	01H
	DD	0190H
	DD	FLAT:_cm_cmd_dial
	DD	FLAT:$SG71467
	DD	FLAT:$SG71468
	DD	01H
	DD	0191H
	DD	FLAT:_cm_cmd_tone
	DD	FLAT:$SG71469
	DD	FLAT:$SG71470
	DD	02H
	DD	02bcH
	DD	FLAT:_cm_cmd_pronounce
	DD	FLAT:$SG71471
	DD	FLAT:$SG71472
	DD	01H
	DD	04b0H
	DD	FLAT:_cm_cmd_stress
	DD	FLAT:$SG71473
	DD	FLAT:$SG71474
	DD	02H
	DD	01f4H
	DD	FLAT:_cm_cmd_define
	DD	FLAT:$SG71475
	DD	FLAT:$SG71476
	DD	02H
	DD	01f4H
	DD	FLAT:_cm_cmd_define
	DD	FLAT:$SG71477
	DD	FLAT:$SG71478
	DD	01H
	DD	00H
	DD	FLAT:_cm_cmd_debug
	DD	FLAT:$SG71479
	DD	FLAT:$SG71480
	DD	01H
	DD	00H
	DD	FLAT:_cm_cmd_setv
	DD	FLAT:$SG71481
	DD	FLAT:$SG71482
	DD	01H
	DD	00H
	DD	FLAT:_cm_cmd_loadv
	DD	FLAT:$SG71483
	DD	FLAT:$SG71484
	DD	01H
	DD	00H
	DD	FLAT:_cm_cmd_gender
_total_commands DD 029H
$SG71248 DB	'asky', 00H
	ORG $+3
$SG71249 DB	'arpabet', 00H
$SG71250 DB	'speak', 00H
	ORG $+2
$SG71251 DB	'silent', 00H
	ORG $+1
$SG71252 DB	'off', 00H
$SG71253 DB	'on', 00H
	ORG $+1
$SG71255 DB	'text', 00H
	ORG $+3
$SG71256 DB	'phonemes', 00H
	ORG $+3
$SG71257 DB	'types', 00H
	ORG $+2
$SG71258 DB	'forms', 00H
	ORG $+2
$SG71259 DB	'syllables', 00H
	ORG $+2
$SG71260 DB	'outphon', 00H
$SG71261 DB	'dbglog', 00H
	ORG $+1
$SG71262 DB	'on', 00H
	ORG $+1
$SG71263 DB	'off', 00H
$SG71264 DB	'set', 00H
$SG71266 DB	'clause', 00H
	ORG $+1
$SG71267 DB	'word', 00H
	ORG $+3
$SG71268 DB	'letter', 00H
	ORG $+1
$SG71269 DB	'filtered_letter', 00H
$SG71270 DB	'line', 00H
	ORG $+3
$SG71271 DB	'syllable', 00H
	ORG $+3
$SG71273 DB	'ignore', 00H
	ORG $+1
$SG71274 DB	'text', 00H
	ORG $+3
$SG71275 DB	'escape', 00H
	ORG $+1
$SG71276 DB	'speak', 00H
	ORG $+2
$SG71277 DB	'tone', 00H
	ORG $+3
$SG71279 DB	'all', 00H
$SG71280 DB	'until', 00H
	ORG $+2
$SG71281 DB	'mask', 00H
	ORG $+3
$SG71282 DB	'after', 00H
	ORG $+2
$SG71283 DB	'speech', 00H
	ORG $+1
$SG71285 DB	'none', 00H
	ORG $+3
$SG71286 DB	'some', 00H
	ORG $+3
$SG71287 DB	'all', 00H
$SG71288 DB	'pass', 00H
	ORG $+3
$SG71290 DB	'none', 00H
	ORG $+3
$SG71291 DB	'email', 00H
	ORG $+2
$SG71292 DB	'punct', 00H
	ORG $+2
$SG71293 DB	'rule', 00H
	ORG $+3
$SG71294 DB	'all', 00H
$SG71295 DB	'cpg', 00H
$SG71297 DB	'set', 00H
$SG71298 DB	'up', 00H
	ORG $+1
$SG71299 DB	'down', 00H
	ORG $+3
$SG71300 DB	'lset', 00H
	ORG $+3
$SG71301 DB	'lup', 00H
$SG71302 DB	'ldown', 00H
	ORG $+2
$SG71303 DB	'rset', 00H
	ORG $+3
$SG71304 DB	'rup', 00H
$SG71305 DB	'rdown', 00H
	ORG $+2
$SG71306 DB	'sset', 00H
	ORG $+3
$SG71307 DB	'att', 00H
$SG71309 DB	'english', 00H
$SG71310 DB	'british', 00H
$SG71311 DB	'french', 00H
	ORG $+1
$SG71312 DB	'german', 00H
	ORG $+1
$SG71313 DB	'spanish', 00H
$SG71314 DB	'latin_amercian', 00H
	ORG $+1
$SG71315 DB	'us', 00H
	ORG $+1
$SG71316 DB	'uk', 00H
	ORG $+1
$SG71317 DB	'fr', 00H
	ORG $+1
$SG71318 DB	'gr', 00H
	ORG $+1
$SG71319 DB	'sp', 00H
	ORG $+1
$SG71320 DB	'la', 00H
	ORG $+1
$SG71322 DB	'math', 00H
	ORG $+3
$SG71323 DB	'europe', 00H
	ORG $+1
$SG71324 DB	'spell', 00H
	ORG $+2
$SG71325 DB	'name', 00H
	ORG $+3
$SG71326 DB	'homograph', 00H
	ORG $+2
$SG71327 DB	'citation', 00H
	ORG $+3
$SG71328 DB	'latin', 00H
	ORG $+2
$SG71329 DB	'table', 00H
	ORG $+2
$SG71330 DB	'email', 00H
	ORG $+2
$SG71331 DB	'on', 00H
	ORG $+1
$SG71332 DB	'off', 00H
$SG71333 DB	'set', 00H
$SG71335 DB	'alternate', 00H
	ORG $+2
$SG71336 DB	'name', 00H
	ORG $+3
$SG71337 DB	'primary', 00H
$SG71338 DB	'noun', 00H
	ORG $+3
$SG71339 DB	'verb', 00H
	ORG $+3
$SG71340 DB	'adjective', 00H
	ORG $+2
$SG71341 DB	'function', 00H
	ORG $+3
$SG71342 DB	'interjection', 00H
	ORG $+3
$SG71344 DB	'paul', 00H
	ORG $+3
$SG71345 DB	'betty', 00H
	ORG $+2
$SG71346 DB	'harry', 00H
	ORG $+2
$SG71347 DB	'frank', 00H
	ORG $+2
$SG71348 DB	'dennis', 00H
	ORG $+1
$SG71349 DB	'kit', 00H
$SG71350 DB	'ursula', 00H
	ORG $+1
$SG71351 DB	'rita', 00H
	ORG $+3
$SG71352 DB	'wendy', 00H
	ORG $+2
$SG71353 DB	'val', 00H
$SG71355 DB	'mark', 00H
	ORG $+3
$SG71356 DB	'reply', 00H
	ORG $+2
$SG71357 DB	'query', 00H
	ORG $+2
$SG71358 DB	'pause', 00H
	ORG $+2
$SG71359 DB	'bookmark', 00H
	ORG $+3
$SG71360 DB	'wordpos', 00H
$SG71361 DB	'start', 00H
	ORG $+2
$SG71362 DB	'stop', 00H
	ORG $+3
$SG71363 DB	'sentence', 00H
	ORG $+3
$SG71364 DB	'volume', 00H
	ORG $+1
$SG71366 DB	'masculine', 00H
	ORG $+2
$SG71367 DB	'neuter', 00H
	ORG $+1
$SG71368 DB	'feminine', 00H
	ORG $+3
$SG71370 DB	'save', 00H
	ORG $+3
$SG71371 DB	'sx', 00H
	ORG $+1
$SG71372 DB	'sm', 00H
	ORG $+1
$SG71373 DB	'as', 00H
	ORG $+1
$SG71374 DB	'ap', 00H
	ORG $+1
$SG71375 DB	'pr', 00H
	ORG $+1
$SG71376 DB	'br', 00H
	ORG $+1
$SG71377 DB	'ri', 00H
	ORG $+1
$SG71378 DB	'nf', 00H
	ORG $+1
$SG71379 DB	'la', 00H
	ORG $+1
$SG71380 DB	'hs', 00H
	ORG $+1
$SG71381 DB	'f4', 00H
	ORG $+1
$SG71382 DB	'b4', 00H
	ORG $+1
$SG71383 DB	'f5', 00H
	ORG $+1
$SG71384 DB	'b5', 00H
	ORG $+1
$SG71385 DB	'f7', 00H
	ORG $+1
$SG71386 DB	'f8', 00H
	ORG $+1
$SG71387 DB	'gf', 00H
	ORG $+1
$SG71388 DB	'gh', 00H
	ORG $+1
$SG71389 DB	'gv', 00H
	ORG $+1
$SG71390 DB	'gn', 00H
	ORG $+1
$SG71391 DB	'g1', 00H
	ORG $+1
$SG71392 DB	'g2', 00H
	ORG $+1
$SG71393 DB	'g3', 00H
	ORG $+1
$SG71394 DB	'g4', 00H
	ORG $+1
$SG71395 DB	'g5', 00H
	ORG $+1
$SG71396 DB	'ft', 00H
	ORG $+1
$SG71397 DB	'bf', 00H
	ORG $+1
$SG71398 DB	'lx', 00H
	ORG $+1
$SG71399 DB	'qu', 00H
	ORG $+1
$SG71400 DB	'hr', 00H
	ORG $+1
$SG71401 DB	'sr', 00H
	ORG $+1
$SG71402 DB	'gs', 00H
	ORG $+1
$SG71403 DB	'rate', 00H
	ORG $+3
$SG71404 DB	'd', 00H
	ORG $+2
$SG71405 DB	'latin', 00H
	ORG $+2
$SG71406 DB	'd', 00H
	ORG $+2
$SG71407 DB	'name', 00H
	ORG $+3
$SG71408 DB	'a', 00H
	ORG $+2
$SG71409 DB	'np', 00H
	ORG $+1
$SG71411 DB	'nb', 00H
	ORG $+1
$SG71413 DB	'nh', 00H
	ORG $+1
$SG71415 DB	'nf', 00H
	ORG $+1
$SG71417 DB	'nd', 00H
	ORG $+1
$SG71419 DB	'nk', 00H
	ORG $+1
$SG71421 DB	'nu', 00H
	ORG $+1
$SG71423 DB	'nr', 00H
	ORG $+1
$SG71425 DB	'nw', 00H
	ORG $+1
$SG71427 DB	'nv', 00H
	ORG $+1
$SG71429 DB	'comma', 00H
	ORG $+2
$SG71430 DB	'd', 00H
	ORG $+2
$SG71431 DB	'cp', 00H
	ORG $+1
$SG71432 DB	'd', 00H
	ORG $+2
$SG71433 DB	'period', 00H
	ORG $+1
$SG71434 DB	'd', 00H
	ORG $+2
$SG71435 DB	'pp', 00H
	ORG $+1
$SG71436 DB	'd', 00H
	ORG $+2
$SG71437 DB	'volume', 00H
	ORG $+1
$SG71438 DB	'add', 00H
$SG71439 DB	'vs', 00H
	ORG $+1
$SG71440 DB	'd', 00H
	ORG $+2
$SG71441 DB	'index', 00H
	ORG $+2
$SG71442 DB	'add', 00H
$SG71443 DB	'error', 00H
	ORG $+2
$SG71444 DB	'a', 00H
	ORG $+2
$SG71445 DB	'phoneme', 00H
$SG71446 DB	'aaa', 00H
$SG71447 DB	'log', 00H
$SG71448 DB	'aa', 00H
	ORG $+1
$SG71449 DB	'mode', 00H
	ORG $+3
$SG71450 DB	'aa', 00H
	ORG $+1
$SG71451 DB	'say', 00H
$SG71452 DB	'a', 00H
	ORG $+2
$SG71453 DB	'punctuation', 00H
$SG71454 DB	'a', 00H
	ORG $+2
$SG71455 DB	'skip', 00H
	ORG $+3
$SG71456 DB	'a', 00H
	ORG $+2
$SG71457 DB	'pause', 00H
	ORG $+2
$SG71458 DB	'd', 00H
	ORG $+2
$SG71459 DB	'play', 00H
	ORG $+3
$SG71460 DB	'a', 00H
	ORG $+2
$SG71461 DB	'resume', 00H
	ORG $+1
$SG71463 DB	'sync', 00H
	ORG $+3
$SG71465 DB	'dial', 00H
	ORG $+3
$SG71466 DB	'a', 00H
	ORG $+2
$SG71467 DB	'tone', 00H
	ORG $+3
$SG71468 DB	'dd', 00H
	ORG $+1
$SG71469 DB	'pronounce', 00H
	ORG $+2
$SG71470 DB	'aa', 00H
	ORG $+1
$SG71471 DB	'pitch', 00H
	ORG $+2
$SG71472 DB	'd', 00H
	ORG $+2
$SG71473 DB	'define_voice', 00H
	ORG $+3
$SG71474 DB	'ad*', 00H
$SG71475 DB	'dv', 00H
	ORG $+1
$SG71476 DB	'ad*', 00H
$SG71477 DB	'debug', 00H
	ORG $+2
$SG71478 DB	'h', 00H
	ORG $+2
$SG71479 DB	'setv', 00H
	ORG $+3
$SG71480 DB	'd', 00H
	ORG $+2
$SG71481 DB	'loadv', 00H
	ORG $+2
$SG71482 DB	'd', 00H
	ORG $+2
$SG71483 DB	'gender', 00H
	ORG $+1
$SG71484 DB	'a', 00H
_DATA	ENDS
EXTRN	_cm_util_string_match:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_cm_cmd_phoneme PROC NEAR

; 202  : 	int     value, i;
; 203  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp
  00006	56		 push	 esi
  00007	8b 68 0c	 mov	 ebp, DWORD PTR [eax+12]

; 204  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;	

  0000a	8b 70 08	 mov	 esi, DWORD PTR [eax+8]

; 205  : 	for(i=0; i < (int)(pCmd_t->param_index); i++)

  0000d	33 db		 xor	 ebx, ebx
  0000f	57		 push	 edi
  00010	8b 85 d0 02 00
	00		 mov	 eax, DWORD PTR [ebp+720]
  00016	85 c0		 test	 eax, eax
  00018	7e 77		 jle	 SHORT $L71515

; 202  : 	int     value, i;
; 203  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  0001a	8d bd 80 02 00
	00		 lea	 edi, DWORD PTR [ebp+640]
$L71513:

; 206  : 	{
; 207  : 		value = cm_util_string_match(phoneme_modes,pCmd_t->pString[i]);

  00020	8b 07		 mov	 eax, DWORD PTR [edi]
  00022	50		 push	 eax
  00023	68 00 00 00 00	 push	 OFFSET FLAT:_phoneme_modes
  00028	e8 00 00 00 00	 call	 _cm_util_string_match
  0002d	83 c4 08	 add	 esp, 8

; 208  : 		if(value == NO_STRING_MATCH)

  00030	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00035	74 61		 je	 SHORT $L72112

; 211  : 		}
; 212  : 		switch(value)
; 213  : 		{         

  00037	83 f8 05	 cmp	 eax, 5
  0003a	77 66		 ja	 SHORT $L71527
  0003c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72115[eax*4]
$L71521:

; 214  : 			case 0:
; 215  : 				pKsd_t->phoneme_mode |= PHONEME_ASCKY; break;   /* ascky */

  00043	8b 86 d0 03 00
	00		 mov	 eax, DWORD PTR [esi+976]
  00049	0c 02		 or	 al, 2
  0004b	eb 30		 jmp	 SHORT $L72114
$L71522:

; 216  : 				break;
; 217  : 			case 1: 
; 218  : 				pKsd_t->phoneme_mode &= (~PHONEME_ASCKY); break;/* arpa */

  0004d	8b 86 d0 03 00
	00		 mov	 eax, DWORD PTR [esi+976]
  00053	24 fd		 and	 al, -3			; fffffffdH
  00055	eb 26		 jmp	 SHORT $L72114
$L71523:

; 219  : 				break;
; 220  : 			case 2:       
; 221  : 				pKsd_t->phoneme_mode |= PHONEME_SPEAK; break;   /* speak */ 

  00057	8b 86 d0 03 00
	00		 mov	 eax, DWORD PTR [esi+976]
  0005d	0c 04		 or	 al, 4
  0005f	eb 1c		 jmp	 SHORT $L72114
$L71524:

; 222  : 				break;
; 223  : 			case 3:       
; 224  : 				pKsd_t->phoneme_mode &= (~PHONEME_SPEAK); break;/* silent */

  00061	8b 86 d0 03 00
	00		 mov	 eax, DWORD PTR [esi+976]
  00067	24 fb		 and	 al, -5			; fffffffbH
  00069	eb 12		 jmp	 SHORT $L72114
$L71525:

; 225  : 				break;
; 226  : 			case 4:       
; 227  : 				pKsd_t->phoneme_mode |= PHONEME_OFF; break;     /* off */

  0006b	8b 86 d0 03 00
	00		 mov	 eax, DWORD PTR [esi+976]
  00071	0c 01		 or	 al, 1
  00073	eb 08		 jmp	 SHORT $L72114
$L71526:

; 228  : 				break;
; 229  : 			case 5:       
; 230  : 				pKsd_t->phoneme_mode &= (~PHONEME_OFF); break;  /* on */

  00075	8b 86 d0 03 00
	00		 mov	 eax, DWORD PTR [esi+976]
  0007b	24 fe		 and	 al, -2			; fffffffeH
$L72114:
  0007d	89 86 d0 03 00
	00		 mov	 DWORD PTR [esi+976], eax
  00083	8b 85 d0 02 00
	00		 mov	 eax, DWORD PTR [ebp+720]
  00089	43		 inc	 ebx
  0008a	83 c7 04	 add	 edi, 4
  0008d	3b d8		 cmp	 ebx, eax
  0008f	7c 8f		 jl	 SHORT $L71513
$L71515:
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5d		 pop	 ebp

; 234  : 		}  /* Matches switch(value) */
; 235  : 	} /* Matches for(i=0; i < (int)param_index; i++) */
; 236  : 	return(CMD_success);

  00094	33 c0		 xor	 eax, eax
  00096	5b		 pop	 ebx

; 237  : }     

  00097	c3		 ret	 0
$L72112:
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5d		 pop	 ebp

; 209  : 		{
; 210  : 			return(CMD_bad_string);

  0009b	b8 01 00 00 00	 mov	 eax, 1
  000a0	5b		 pop	 ebx

; 237  : }     

  000a1	c3		 ret	 0
$L71527:
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5d		 pop	 ebp

; 231  : 				break;
; 232  : 			default:
; 233  : 				return(CMD_bad_param);    

  000a5	b8 04 00 00 00	 mov	 eax, 4
  000aa	5b		 pop	 ebx

; 237  : }     

  000ab	c3		 ret	 0
$L72115:
  000ac	00 00 00 00	 DD	 $L71521
  000b0	00 00 00 00	 DD	 $L71522
  000b4	00 00 00 00	 DD	 $L71523
  000b8	00 00 00 00	 DD	 $L71524
  000bc	00 00 00 00	 DD	 $L71525
  000c0	00 00 00 00	 DD	 $L71526
_cm_cmd_phoneme ENDP
_TEXT	ENDS
PUBLIC	_OpenLogFile
PUBLIC	_CloseLogFile
_TEXT	SEGMENT
_phTTS$ = 8
_pCmd_t$ = 8
_cm_cmd_log PROC NEAR

; 261  : {

  000d0	53		 push	 ebx

; 262  : 	int i, value;
; 263  : 
; 264  : #ifdef DEBUGPARS
; 265  : 	int	p, q;
; 266  : #endif
; 267  : 	unsigned int flag_mask;
; 268  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  000d1	8b 5c 24 08	 mov	 ebx, DWORD PTR _phTTS$[esp]
  000d5	55		 push	 ebp
  000d6	56		 push	 esi

; 269  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  000d7	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000da	8b 6b 08	 mov	 ebp, DWORD PTR [ebx+8]
  000dd	57		 push	 edi

; 270  : 	
; 271  : #ifndef MSDOS
; 272  : 	if(cm_cmd_sync(phTTS) == CMD_flushing)

  000de	53		 push	 ebx
  000df	89 44 24 18	 mov	 DWORD PTR _pCmd_t$[esp+16], eax
  000e3	e8 00 00 00 00	 call	 _cm_cmd_sync
  000e8	83 c4 04	 add	 esp, 4
  000eb	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  000ee	75 05		 jne	 SHORT $L71536
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	5d		 pop	 ebp
  000f3	5b		 pop	 ebx

; 408  : }

  000f4	c3		 ret	 0
$L71536:

; 273  : 	  return(CMD_flushing);
; 274  : #endif
; 275  : 	
; 276  : 	flag_mask = 0;
; 277  : 	for(i=0; i < (int)pCmd_t->param_index; i++)

  000f5	8b 4c 24 14	 mov	 ecx, DWORD PTR _pCmd_t$[esp+12]
  000f9	33 f6		 xor	 esi, esi
  000fb	33 ff		 xor	 edi, edi
  000fd	8b 81 d0 02 00
	00		 mov	 eax, DWORD PTR [ecx+720]
  00103	85 c0		 test	 eax, eax
  00105	0f 8e 04 01 00
	00		 jle	 $L71540
$L71538:

; 278  : 	{
; 279  : 		/*
; 280  : 		 * 3/6/96 SIK This command only takes 2 parameters:  TEXT, FORMS, PHONEME, TYPES, SYLLABLES, 
; 281  : 		 * OUTPHON followed by ON
; 282  : 		 * OFF or SET
; 283  : 		 */
; 284  : #ifdef DEBUGPARS
; 285  : 		for (p=0;log_options[p];p++)
; 286  : 		{
; 287  : 			putc('l');
; 288  : 			putc('o');
; 289  : 			putc('g');
; 290  : 			putc('=');
; 291  : 			for (q=0;log_options[p][q];q++)
; 292  : 			{
; 293  : 				putc(log_options[p][q]);
; 294  : 			}
; 295  : 			putc('\n');
; 296  : 			putc('\r');
; 297  : 		}
; 298  : #endif
; 299  : 			     
; 300  : 		value = cm_util_string_match(log_options,pCmd_t->pString[i]);

  0010b	8b 54 24 14	 mov	 edx, DWORD PTR _pCmd_t$[esp+12]
  0010f	8b 84 ba 80 02
	00 00		 mov	 eax, DWORD PTR [edx+edi*4+640]
  00116	50		 push	 eax
  00117	68 00 00 00 00	 push	 OFFSET FLAT:_log_options
  0011c	e8 00 00 00 00	 call	 _cm_util_string_match
  00121	83 c4 08	 add	 esp, 8

; 301  : 		if(value == NO_STRING_MATCH)

  00124	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00129	0f 84 e7 00 00
	00		 je	 $L72118

; 304  : 		}
; 305  : 		switch(i)
; 306  : 		{

  0012f	8b cf		 mov	 ecx, edi
  00131	83 e9 00	 sub	 ecx, 0
  00134	0f 84 97 00 00
	00		 je	 $L71546
  0013a	49		 dec	 ecx
  0013b	0f 85 df 00 00
	00		 jne	 $L71575

; 337  : 						break;
; 338  : 					default:
; 339  : 						return(CMD_bad_param);
; 340  : 				}
; 341  : 			break;
; 342  : 			case 1: /* Second parameter */
; 343  : 				switch(value)
; 344  : 				{ 

  00141	83 e8 07	 sub	 eax, 7
  00144	74 5e		 je	 SHORT $L71564
  00146	48		 dec	 eax
  00147	74 21		 je	 SHORT $L71568
  00149	48		 dec	 eax
  0014a	0f 85 d0 00 00
	00		 jne	 $L71575

; 391  : 
; 392  : 					case 9:                                /* set */
; 393  : #ifndef MSDOS
; 394  : 						if ( OpenLogFile(phTTS))

  00150	53		 push	 ebx
  00151	e8 00 00 00 00	 call	 _OpenLogFile
  00156	83 c4 04	 add	 esp, 4
  00159	85 c0		 test	 eax, eax
  0015b	74 06		 je	 SHORT $L71574

; 395  : #endif
; 396  : 								pKsd_t->logflag = flag_mask;

  0015d	89 b5 c4 03 00
	00		 mov	 DWORD PTR [ebp+964], esi
$L71574:

; 397  : 						flag_mask = 0;

  00163	33 f6		 xor	 esi, esi

; 398  : 						break;

  00165	e9 94 00 00 00	 jmp	 $L71539
$L71568:

; 359  : #ifndef MSDOS
; 360  : 						}
; 361  : #endif
; 362  : 
; 363  : 						break;
; 364  : 
; 365  : 					case 8:	/* off */
; 366  : 
; 367  : #ifdef MSDOS	
; 368  : 						pKsd_t->logflag &= (~flag_mask);
; 369  : 						flag_mask = 0;
; 370  : #else
; 371  : 
; 372  : 						if ((flag_mask | LOG_DBGLOG) == LOG_DBGLOG)

  0016a	8b ce		 mov	 ecx, esi
  0016c	83 c9 40	 or	 ecx, 64			; 00000040H
  0016f	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00172	75 0d		 jne	 SHORT $L71569

; 373  : 						{  						
; 374  : 							CloseDbgLogFile(phTTS);

  00174	53		 push	 ebx
  00175	e8 00 00 00 00	 call	 _CloseDbgLogFile
  0017a	83 c4 04	 add	 esp, 4

; 375  : 							flag_mask = 0;

  0017d	33 f6		 xor	 esi, esi

; 376  : 						}
; 377  : 						else

  0017f	eb 7d		 jmp	 SHORT $L71539
$L71569:

; 378  : 						{
; 379  : 							if ( pKsd_t->logflag & (~flag_mask))

  00181	8b 85 c4 03 00
	00		 mov	 eax, DWORD PTR [ebp+964]
  00187	f7 d6		 not	 esi
  00189	23 f0		 and	 esi, eax
  0018b	74 0a		 je	 SHORT $L71571

; 380  : 							{
; 381  : 								pKsd_t->logflag &= (~flag_mask);

  0018d	89 b5 c4 03 00
	00		 mov	 DWORD PTR [ebp+964], esi

; 386  : 							}
; 387  : 							flag_mask = 0;

  00193	33 f6		 xor	 esi, esi

; 388  : 						}
; 389  : #endif
; 390  : 						break;

  00195	eb 67		 jmp	 SHORT $L71539
$L71571:

; 382  : 							}
; 383  : 							else
; 384  : 							{
; 385  : 							CloseLogFile(phTTS);

  00197	53		 push	 ebx
  00198	e8 00 00 00 00	 call	 _CloseLogFile
  0019d	83 c4 04	 add	 esp, 4

; 386  : 							}
; 387  : 							flag_mask = 0;

  001a0	33 f6		 xor	 esi, esi

; 388  : 						}
; 389  : #endif
; 390  : 						break;

  001a2	eb 5a		 jmp	 SHORT $L71539
$L71564:

; 345  : 					case 7: /* on */
; 346  : 
; 347  : #ifndef MSDOS			
; 348  : 						if ((flag_mask | LOG_DBGLOG) == LOG_DBGLOG)

  001a4	8b d6		 mov	 edx, esi

; 349  : 						{  						
; 350  : 							OpenDbgLogFile(phTTS);

  001a6	53		 push	 ebx
  001a7	83 ca 40	 or	 edx, 64			; 00000040H
  001aa	83 fa 40	 cmp	 edx, 64			; 00000040H
  001ad	75 0c		 jne	 SHORT $L71565
  001af	e8 00 00 00 00	 call	 _OpenDbgLogFile
  001b4	83 c4 04	 add	 esp, 4

; 351  : 							flag_mask = 0;

  001b7	33 f6		 xor	 esi, esi

; 352  : 						}
; 353  : 						else

  001b9	eb 43		 jmp	 SHORT $L71539
$L71565:

; 354  : 						{		
; 355  : 						if ( OpenLogFile(phTTS))

  001bb	e8 00 00 00 00	 call	 _OpenLogFile
  001c0	83 c4 04	 add	 esp, 4
  001c3	85 c0		 test	 eax, eax
  001c5	74 06		 je	 SHORT $L71567

; 356  : #endif
; 357  : 							pKsd_t->logflag |= flag_mask;

  001c7	09 b5 c4 03 00
	00		 or	 DWORD PTR [ebp+964], esi
$L71567:

; 358  : 						flag_mask = 0;

  001cd	33 f6		 xor	 esi, esi

; 399  : 					default:
; 400  : 						return(CMD_bad_param);
; 401  : 				}
; 402  : 				break;

  001cf	eb 2d		 jmp	 SHORT $L71539
$L71546:

; 307  : 			case 0: /* First parameter */
; 308  : 				switch(value)
; 309  : 				{

  001d1	83 f8 06	 cmp	 eax, 6
  001d4	77 4a		 ja	 SHORT $L71575
  001d6	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72123[eax*4]
$L71551:

; 310  : 					case 0:                               /* text */
; 311  : 						flag_mask |= LOG_TEXT;

  001dd	83 ce 01	 or	 esi, 1

; 312  : 						break;

  001e0	eb 1c		 jmp	 SHORT $L71539
$L71552:

; 313  : 					case 1:                               /* phoneme */
; 314  : 
; 315  : 						flag_mask |= LOG_PHONEMES;

  001e2	83 ce 02	 or	 esi, 2

; 316  : 						break;

  001e5	eb 17		 jmp	 SHORT $L71539
$L71553:

; 317  : 
; 318  : 					case 2:                               /* name types */
; 319  : 
; 320  : 						flag_mask |= LOG_NAME_TYPES;

  001e7	83 ce 04	 or	 esi, 4

; 321  : 						break;

  001ea	eb 12		 jmp	 SHORT $L71539
$L71554:

; 322  : 
; 323  : 					case 3:                               /* word form classes */
; 324  : 
; 325  : 						flag_mask |= LOG_FORM_TYPES;

  001ec	83 ce 08	 or	 esi, 8

; 326  : 						break;

  001ef	eb 0d		 jmp	 SHORT $L71539
$L71555:

; 327  : 
; 328  : 					case 4:                               /* word syllable structure */
; 329  : 
; 330  : 						flag_mask |= LOG_SYLLABLES;

  001f1	83 ce 10	 or	 esi, 16			; 00000010H

; 331  : 						break;

  001f4	eb 08		 jmp	 SHORT $L71539
$L71556:

; 332  : 					case 5:                               /* word outphon structure */
; 333  : 						flag_mask |= LOG_OUTPHON;

  001f6	83 ce 20	 or	 esi, 32			; 00000020H

; 334  : 				   		break;

  001f9	eb 03		 jmp	 SHORT $L71539
$L71557:

; 335  : 					case 6:                               /* word dbglog structure */
; 336  : 						flag_mask |= LOG_DBGLOG;		  /*mfg*/

  001fb	83 ce 40	 or	 esi, 64			; 00000040H
$L71539:

; 273  : 	  return(CMD_flushing);
; 274  : #endif
; 275  : 	
; 276  : 	flag_mask = 0;
; 277  : 	for(i=0; i < (int)pCmd_t->param_index; i++)

  001fe	8b 44 24 14	 mov	 eax, DWORD PTR _pCmd_t$[esp+12]
  00202	47		 inc	 edi
  00203	3b b8 d0 02 00
	00		 cmp	 edi, DWORD PTR [eax+720]
  00209	0f 8c fc fe ff
	ff		 jl	 $L71538
$L71540:
  0020f	5f		 pop	 edi
  00210	5e		 pop	 esi
  00211	5d		 pop	 ebp

; 405  : 		}       /* switch(i) */
; 406  : 	}       /* for(i=0; i < param_index; i++) */
; 407  : 	return(CMD_success);

  00212	33 c0		 xor	 eax, eax
  00214	5b		 pop	 ebx

; 408  : }

  00215	c3		 ret	 0
$L72118:
  00216	5f		 pop	 edi
  00217	5e		 pop	 esi
  00218	5d		 pop	 ebp

; 302  : 		{
; 303  : 			return(CMD_bad_string);

  00219	b8 01 00 00 00	 mov	 eax, 1
  0021e	5b		 pop	 ebx

; 408  : }

  0021f	c3		 ret	 0
$L71575:
  00220	5f		 pop	 edi
  00221	5e		 pop	 esi
  00222	5d		 pop	 ebp

; 403  : 				default:
; 404  : 					return(CMD_bad_param);

  00223	b8 04 00 00 00	 mov	 eax, 4
  00228	5b		 pop	 ebx

; 408  : }

  00229	c3		 ret	 0
  0022a	8b ff		 npad	 2
$L72123:
  0022c	00 00 00 00	 DD	 $L71551
  00230	00 00 00 00	 DD	 $L71552
  00234	00 00 00 00	 DD	 $L71553
  00238	00 00 00 00	 DD	 $L71554
  0023c	00 00 00 00	 DD	 $L71555
  00240	00 00 00 00	 DD	 $L71556
  00244	00 00 00 00	 DD	 $L71557
_cm_cmd_log ENDP
_TEXT	ENDS
EXTRN	__imp__fopen:NEAR
_DATA	SEGMENT
	ORG $+2
$SG71583 DB	'w', 00H
	ORG $+2
$SG71584 DB	'dbglog.txt', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_OpenDbgLogFile PROC NEAR

; 427  : 
; 428  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00250	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00254	56		 push	 esi

; 429  : 
; 430  : 	if ((pKsd_t->dbglog = fopen("dbglog.txt","w"))==NULL)

  00255	68 00 00 00 00	 push	 OFFSET FLAT:$SG71583
  0025a	68 00 00 00 00	 push	 OFFSET FLAT:$SG71584
  0025f	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00262	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00268	83 c4 08	 add	 esp, 8
  0026b	33 c9		 xor	 ecx, ecx
  0026d	85 c0		 test	 eax, eax
  0026f	0f 95 c1	 setne	 cl
  00272	89 86 44 06 00
	00		 mov	 DWORD PTR [esi+1604], eax
  00278	8b c1		 mov	 eax, ecx
  0027a	5e		 pop	 esi

; 431  : 		return(FALSE);
; 432  : 
; 433  : 	return( TRUE );
; 434  : 
; 435  : }

  0027b	c3		 ret	 0
_OpenDbgLogFile ENDP
_TEXT	ENDS
EXTRN	__imp__fclose:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_CloseDbgLogFile PROC NEAR

; 452  : 
; 453  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00280	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00284	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 454  : 	
; 455  : 	if(pKsd_t->dbglog)

  00287	8b 80 44 06 00
	00		 mov	 eax, DWORD PTR [eax+1604]
  0028d	85 c0		 test	 eax, eax
  0028f	74 08		 je	 SHORT $L71589

; 456  : 	{
; 457  : 	fclose((FILE *)pKsd_t->dbglog);

  00291	50		 push	 eax
  00292	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00298	59		 pop	 ecx
$L71589:

; 458  : 	}
; 459  : 
; 460  : }

  00299	c3		 ret	 0
_CloseDbgLogFile ENDP
_TEXT	ENDS
EXTRN	_TextToSpeechErrorHandler:NEAR
EXTRN	__imp__EnterCriticalSection@4:NEAR
EXTRN	__imp__LeaveCriticalSection@4:NEAR
_DATA	SEGMENT
	ORG $+1
$SG71598 DB	'w', 00H
	ORG $+2
$SG71599 DB	'log.txt', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_OpenLogFile PROC NEAR

; 482  : {

  002a0	56		 push	 esi

; 483  :   /*
; 484  :   LPTTS_HANDLE_T phTTS;                                 MVP MI 
; 485  : 
; 486  :   phTTS = TextToSpeechGetHandle();
; 487  :   */
; 488  : #ifdef WIN32
; 489  :   EnterCriticalSection( phTTS->pcsLogFile );

  002a1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  002a5	8b 86 c8 00 00
	00		 mov	 eax, DWORD PTR [esi+200]
  002ab	50		 push	 eax
  002ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 490  : #endif
; 491  : 
; 492  : /* GL 04/21/1997  change this for OSF build */
; 493  : #if defined __osf__ || defined __linux__
; 494  :   /*ToggleLogfileMutex( MUTEX_RESERVE );*/
; 495  :   OP_LockMutex( phTTS->pcsLogFile );
; 496  : #endif
; 497  : 
; 498  :   /********************************************************************/
; 499  :   /*  If a file is already open, then don't try to open another one.  */
; 500  :   /********************************************************************/
; 501  : 
; 502  :   if ( phTTS->dwOutputState == STATE_OUTPUT_LOG_FILE )

  002b2	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  002b8	83 f8 03	 cmp	 eax, 3

; 503  :   {
; 504  : #ifdef WIN32
; 505  : 	LeaveCriticalSection( phTTS->pcsLogFile );
; 506  : #endif
; 507  : /* GL 04/21/1997  change this for OSF build */
; 508  : #if defined __osf__ || defined __linux__
; 509  :   /*ToggleLogfileMutex( MUTEX_RELEASE );*/
; 510  :     OP_UnlockMutex( phTTS->pcsLogFile );
; 511  : #endif
; 512  : 
; 513  : 	return( TRUE );

  002bb	74 68		 je	 SHORT $L72127

; 514  :   }
; 515  : 
; 516  :   /********************************************************************/
; 517  :   /*  If not in NULL output state or AUDIO Output state then return   */
; 518  :   /*  an error.                                                       */
; 519  :   /********************************************************************/
; 520  : 
; 521  :   if (( phTTS->dwOutputState != STATE_OUTPUT_AUDIO )
; 522  :    && ( phTTS->dwOutputState != STATE_OUTPUT_NULL ))

  002bd	85 c0		 test	 eax, eax
  002bf	74 16		 je	 SHORT $L71595
  002c1	83 f8 04	 cmp	 eax, 4
  002c4	74 11		 je	 SHORT $L71595

; 523  :   {
; 524  : #ifdef WIN32
; 525  : 	LeaveCriticalSection( phTTS->pcsLogFile );

  002c6	8b 96 c8 00 00
	00		 mov	 edx, DWORD PTR [esi+200]
  002cc	52		 push	 edx
  002cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 526  : #endif
; 527  : /* GL 04/21/1997  change this for OSF build */
; 528  : #if defined __osf__ || defined __linux__
; 529  :   /*ToggleLogfileMutex( MUTEX_RELEASE );*/
; 530  :     OP_UnlockMutex( phTTS->pcsLogFile );
; 531  : #endif
; 532  : 
; 533  : 	return( FALSE );

  002d3	33 c0		 xor	 eax, eax
  002d5	5e		 pop	 esi

; 572  : }

  002d6	c3		 ret	 0
$L71595:

; 534  :   }
; 535  : 
; 536  :   /********************************************************************/
; 537  :   /*  Open the log file.                                              */
; 538  :   /********************************************************************/
; 539  : 
; 540  :   if (( phTTS->pLogFile = fopen( "log.txt", "w" )) == NULL )

  002d7	68 00 00 00 00	 push	 OFFSET FLAT:$SG71598
  002dc	68 00 00 00 00	 push	 OFFSET FLAT:$SG71599
  002e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  002e7	83 c4 08	 add	 esp, 8
  002ea	89 86 9c 00 00
	00		 mov	 DWORD PTR [esi+156], eax
  002f0	85 c0		 test	 eax, eax
  002f2	75 1e		 jne	 SHORT $L71597

; 541  :   {
; 542  : #ifdef WIN32
; 543  : 	LeaveCriticalSection( phTTS->pcsLogFile );

  002f4	8b 86 c8 00 00
	00		 mov	 eax, DWORD PTR [esi+200]
  002fa	50		 push	 eax
  002fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 544  : #endif
; 545  : /* GL 04/21/1997  change this for OSF build */
; 546  : #if defined __osf__ || defined __linux__
; 547  :   /*ToggleLogfileMutex( MUTEX_RELEASE );*/
; 548  :     OP_UnlockMutex( phTTS->pcsLogFile );
; 549  : #endif
; 550  : 
; 551  : 	TextToSpeechErrorHandler( phTTS,
; 552  : 				  ERROR_WRITING_FILE,
; 553  : 				  0L );

  00301	6a 00		 push	 0
  00303	6a 05		 push	 5
  00305	56		 push	 esi
  00306	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  0030b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 554  : 	return( FALSE );

  0030e	33 c0		 xor	 eax, eax
  00310	5e		 pop	 esi

; 572  : }

  00311	c3		 ret	 0
$L71597:

; 555  :   }
; 556  :   else
; 557  :   {
; 558  : 	cm_cmd_sync(phTTS);

  00312	56		 push	 esi
  00313	e8 00 00 00 00	 call	 _cm_cmd_sync
  00318	83 c4 04	 add	 esp, 4

; 559  : 
; 560  : 	phTTS->dwOutputState = STATE_OUTPUT_LOG_FILE;

  0031b	c7 86 88 00 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+136], 3
$L72127:

; 561  : #ifdef WIN32
; 562  : 	LeaveCriticalSection( phTTS->pcsLogFile );

  00325	8b 8e c8 00 00
	00		 mov	 ecx, DWORD PTR [esi+200]
  0032b	51		 push	 ecx
  0032c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 563  : #endif
; 564  : /* GL 04/21/1997  change this for OSF build */
; 565  : #if defined __osf__ || defined __linux__
; 566  :   /*ToggleLogfileMutex( MUTEX_RELEASE );*/
; 567  :     OP_UnlockMutex( phTTS->pcsLogFile );
; 568  : #endif
; 569  : 
; 570  :   }
; 571  :   return( TRUE );

  00332	b8 01 00 00 00	 mov	 eax, 1
  00337	5e		 pop	 esi

; 572  : }

  00338	c3		 ret	 0
_OpenLogFile ENDP
_TEXT	ENDS
EXTRN	__imp___flushall:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_CloseLogFile PROC NEAR

; 591  : {

  00340	56		 push	 esi

; 592  :   PKSD_T pKsd_t = phTTS->pKernelShareData;

  00341	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  00345	57		 push	 edi

; 593  :   /*
; 594  :   LPTTS_HANDLE_T phTTS;                 MVP MI
; 595  : 
; 596  :   phTTS = TextToSpeechGetHandle();
; 597  :   */
; 598  : 
; 599  :   /********************************************************************/
; 600  :   /*  Wait for all data to complete before closing the log file.      */
; 601  :   /********************************************************************/
; 602  : 
; 603  :   cm_cmd_sync(phTTS);

  00346	56		 push	 esi
  00347	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0034a	e8 00 00 00 00	 call	 _cm_cmd_sync

; 604  : 
; 605  : #ifdef WIN32
; 606  :   EnterCriticalSection( phTTS->pcsLogFile );

  0034f	8b 86 c8 00 00
	00		 mov	 eax, DWORD PTR [esi+200]
  00355	83 c4 04	 add	 esp, 4
  00358	50		 push	 eax
  00359	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 607  : 
; 608  : #if (UNDER_CE == 211) || (UNDER_CE == 200)
; 609  : 	_flushall; 
; 610  : #else
; 611  : 	_flushall();

  0035f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___flushall

; 612  : #endif // (UNDER_CE == 211) || (UNDER_CE == 200)
; 613  : 
; 614  : #endif
; 615  : /* GL 04/21/1997  change this for OSF build */
; 616  : #if defined __osf__ || defined __linux__
; 617  :   /*ToggleLogfileMutex( MUTEX_RESERVE );*/
; 618  :   OP_LockMutex( phTTS->pcsLogFile );
; 619  : #endif
; 620  : 
; 621  :   /********************************************************************/
; 622  :   /*  Exit if the log file is not open.                               */
; 623  :   /********************************************************************/
; 624  : 
; 625  :   if ( phTTS->dwOutputState != STATE_OUTPUT_LOG_FILE )

  00365	83 be 88 00 00
	00 03		 cmp	 DWORD PTR [esi+136], 3
  0036c	74 10		 je	 SHORT $L71605

; 626  :   {
; 627  : #ifdef WIN32
; 628  : 	LeaveCriticalSection( phTTS->pcsLogFile );

  0036e	8b 8e c8 00 00
	00		 mov	 ecx, DWORD PTR [esi+200]
  00374	51		 push	 ecx

; 670  : #ifdef WIN32
; 671  : 	LeaveCriticalSection( phTTS->pcsLogFile );

  00375	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0037b	5f		 pop	 edi
  0037c	5e		 pop	 esi

; 672  : #endif
; 673  : /* GL 04/21/1997  change this for OSF build */
; 674  : #if defined __osf__ || defined __linux__
; 675  :   /*ToggleLogfileMutex( MUTEX_RELEASE );*/
; 676  :     OP_UnlockMutex( phTTS->pcsLogFile );
; 677  : #endif
; 678  : 
; 679  :   }
; 680  :   return;
; 681  : }

  0037d	c3		 ret	 0
$L71605:

; 629  : #endif
; 630  : /* GL 04/21/1997  change this for OSF build */
; 631  : #if defined __osf__ || defined __linux__
; 632  :   /*ToggleLogfileMutex( MUTEX_RELEASE );*/
; 633  :     OP_UnlockMutex( phTTS->pcsLogFile );
; 634  : #endif
; 635  : 
; 636  : 	return;
; 637  :   }
; 638  : 
; 639  :   /********************************************************************/
; 640  :   /*  Set the system output state to audio if it is enabled.          */
; 641  :   /********************************************************************/
; 642  : 
; 643  :   if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )

  0037e	8b 56 78	 mov	 edx, DWORD PTR [esi+120]

; 644  : 	phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
; 645  :   else
; 646  : 	phTTS->dwOutputState = STATE_OUTPUT_NULL;
; 647  : 
; 648  :   /********************************************************************/
; 649  :   /*  Close the log file.                                             */
; 650  :   /********************************************************************/
; 651  : 
; 652  :   if ( fclose( phTTS->pLogFile ))

  00381	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  00387	c1 ea 1d	 shr	 edx, 29			; 0000001dH
  0038a	83 e2 04	 and	 edx, 4
  0038d	50		 push	 eax
  0038e	89 96 88 00 00
	00		 mov	 DWORD PTR [esi+136], edx
  00394	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0039a	83 c4 04	 add	 esp, 4
  0039d	85 c0		 test	 eax, eax
  0039f	74 1d		 je	 SHORT $L71608

; 653  :   {
; 654  : #ifdef WIN32
; 655  : 	LeaveCriticalSection( phTTS->pcsLogFile );

  003a1	8b 8e c8 00 00
	00		 mov	 ecx, DWORD PTR [esi+200]
  003a7	51		 push	 ecx
  003a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 656  : #endif
; 657  : /* GL 04/21/1997  change this for OSF build */
; 658  : #if defined __osf__ || defined __linux__
; 659  :   /*ToggleLogfileMutex( MUTEX_RELEASE );*/
; 660  :     OP_UnlockMutex( phTTS->pcsLogFile );
; 661  : #endif
; 662  : 
; 663  : 	TextToSpeechErrorHandler( phTTS,
; 664  : 				  ERROR_WRITING_FILE,
; 665  : 				  0L );

  003ae	6a 00		 push	 0
  003b0	6a 05		 push	 5
  003b2	56		 push	 esi
  003b3	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  003b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  003bb	5f		 pop	 edi
  003bc	5e		 pop	 esi

; 672  : #endif
; 673  : /* GL 04/21/1997  change this for OSF build */
; 674  : #if defined __osf__ || defined __linux__
; 675  :   /*ToggleLogfileMutex( MUTEX_RELEASE );*/
; 676  :     OP_UnlockMutex( phTTS->pcsLogFile );
; 677  : #endif
; 678  : 
; 679  :   }
; 680  :   return;
; 681  : }

  003bd	c3		 ret	 0
$L71608:

; 666  :   }
; 667  :   else
; 668  :   {
; 669  : 	pKsd_t->logflag = 0;

  003be	c7 87 c4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+964], 0

; 670  : #ifdef WIN32
; 671  : 	LeaveCriticalSection( phTTS->pcsLogFile );

  003c8	8b 96 c8 00 00
	00		 mov	 edx, DWORD PTR [esi+200]
  003ce	52		 push	 edx
  003cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  003d5	5f		 pop	 edi
  003d6	5e		 pop	 esi

; 672  : #endif
; 673  : /* GL 04/21/1997  change this for OSF build */
; 674  : #if defined __osf__ || defined __linux__
; 675  :   /*ToggleLogfileMutex( MUTEX_RELEASE );*/
; 676  :     OP_UnlockMutex( phTTS->pcsLogFile );
; 677  : #endif
; 678  : 
; 679  :   }
; 680  :   return;
; 681  : }

  003d7	c3		 ret	 0
_CloseLogFile ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_break
_TEXT	SEGMENT
_phTTS$ = 8
_cm_cmd_break PROC NEAR

; 702  : 	int     i,value;
; 703  : 	unsigned int flag_mask;
; 704  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  003e0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  003e4	53		 push	 ebx
  003e5	55		 push	 ebp
  003e6	56		 push	 esi

; 705  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  003e7	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]
  003ea	8b 68 08	 mov	 ebp, DWORD PTR [eax+8]
  003ed	57		 push	 edi

; 706  : 	flag_mask = 0;
; 707  : 	for(i = 0; i < (int)pCmd_t->param_index; i++)

  003ee	33 ff		 xor	 edi, edi
  003f0	8b 83 d0 02 00
	00		 mov	 eax, DWORD PTR [ebx+720]
  003f6	85 c0		 test	 eax, eax
  003f8	7e 49		 jle	 SHORT $L71621

; 702  : 	int     i,value;
; 703  : 	unsigned int flag_mask;
; 704  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  003fa	8d b3 80 02 00
	00		 lea	 esi, DWORD PTR [ebx+640]
$L71619:

; 708  : 	{
; 709  : 		value = cm_util_string_match(log_options,pCmd_t->pString[i]);

  00400	8b 06		 mov	 eax, DWORD PTR [esi]
  00402	50		 push	 eax
  00403	68 00 00 00 00	 push	 OFFSET FLAT:_log_options
  00408	e8 00 00 00 00	 call	 _cm_util_string_match
  0040d	83 c4 08	 add	 esp, 8

; 710  : 		if(value == NO_STRING_MATCH)

  00410	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00415	74 33		 je	 SHORT $L72132

; 712  : 		switch(value)
; 713  : 		{

  00417	83 e8 00	 sub	 eax, 0
  0041a	74 0f		 je	 SHORT $L71627
  0041c	48		 dec	 eax
  0041d	75 16		 jne	 SHORT $L71620

; 717  : 				break;
; 718  : 
; 719  : 			case    1       :                               /* off */
; 720  : 
; 721  : 				pKsd_t->wbreak = FALSE;

  0041f	c7 85 d4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ebp+980], 0

; 722  : 				break;

  00429	eb 0a		 jmp	 SHORT $L71620
$L71627:

; 714  : 			case    0       :                               /* on */
; 715  : 
; 716  : 				pKsd_t->wbreak = TRUE;

  0042b	c7 85 d4 03 00
	00 01 00 00 00	 mov	 DWORD PTR [ebp+980], 1
$L71620:

; 706  : 	flag_mask = 0;
; 707  : 	for(i = 0; i < (int)pCmd_t->param_index; i++)

  00435	8b 83 d0 02 00
	00		 mov	 eax, DWORD PTR [ebx+720]
  0043b	47		 inc	 edi
  0043c	83 c6 04	 add	 esi, 4
  0043f	3b f8		 cmp	 edi, eax
  00441	7c bd		 jl	 SHORT $L71619
$L71621:
  00443	5f		 pop	 edi
  00444	5e		 pop	 esi
  00445	5d		 pop	 ebp

; 723  : 	
; 724  : 		}
; 725  : 	}
; 726  : 	return(CMD_success);

  00446	33 c0		 xor	 eax, eax
  00448	5b		 pop	 ebx

; 727  : }

  00449	c3		 ret	 0
$L72132:
  0044a	5f		 pop	 edi
  0044b	5e		 pop	 esi
  0044c	5d		 pop	 ebp

; 711  : 			return(CMD_bad_string);

  0044d	b8 01 00 00 00	 mov	 eax, 1
  00452	5b		 pop	 ebx

; 727  : }

  00453	c3		 ret	 0
_cm_cmd_break ENDP
_phTTS$ = 8
_cm_cmd_say PROC NEAR

; 747  : {

  00460	56		 push	 esi

; 748  : 	int     value; 
; 749  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00461	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  00465	57		 push	 edi

; 750  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00466	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00469	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 751  : 
; 752  : 	value = cm_util_string_match(say_options,pCmd_t->pString[0]);

  0046c	8b 80 80 02 00
	00		 mov	 eax, DWORD PTR [eax+640]
  00472	50		 push	 eax
  00473	68 00 00 00 00	 push	 OFFSET FLAT:_say_options
  00478	e8 00 00 00 00	 call	 _cm_util_string_match
  0047d	83 c4 08	 add	 esp, 8

; 753  : 	if(value == NO_STRING_MATCH)

  00480	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00485	75 08		 jne	 SHORT $L71635
  00487	5f		 pop	 edi

; 754  : 		return(CMD_bad_string);

  00488	b8 01 00 00 00	 mov	 eax, 1
  0048d	5e		 pop	 esi

; 792  : }

  0048e	c3		 ret	 0
$L71635:

; 755  : 	switch(value)
; 756  : 	{

  0048f	83 f8 05	 cmp	 eax, 5
  00492	77 7e		 ja	 SHORT $L71637
  00494	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72135[eax*4]
$L71640:

; 757  : 		case    0       :                               /* clause */
; 758  : 
; 759  : 			pKsd_t->sayflag = SAY_CLAUSE;

  0049b	c7 87 c8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+968], 0
  004a5	5f		 pop	 edi

; 789  : 			break;
; 790  : 	}
; 791  : 	return(CMD_success);

  004a6	33 c0		 xor	 eax, eax
  004a8	5e		 pop	 esi

; 792  : }

  004a9	c3		 ret	 0
$L71641:

; 760  : 			break;
; 761  : 
; 762  : 		case    1       :                               /* word */
; 763  : 
; 764  : 			pKsd_t->sayflag = SAY_WORD;

  004aa	c7 87 c8 03 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+968], 1
  004b4	5f		 pop	 edi

; 789  : 			break;
; 790  : 	}
; 791  : 	return(CMD_success);

  004b5	33 c0		 xor	 eax, eax
  004b7	5e		 pop	 esi

; 792  : }

  004b8	c3		 ret	 0
$L71642:

; 765  : 			break;
; 766  : 
; 767  : 		case    2       :                               /* letter */
; 768  : 
; 769  : 			if(cm_cmd_sync(phTTS) == CMD_flushing)

  004b9	56		 push	 esi
  004ba	e8 00 00 00 00	 call	 _cm_cmd_sync
  004bf	83 c4 04	 add	 esp, 4
  004c2	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  004c5	75 03		 jne	 SHORT $L71643
  004c7	5f		 pop	 edi
  004c8	5e		 pop	 esi

; 792  : }

  004c9	c3		 ret	 0
$L71643:

; 770  : 				return(CMD_flushing);
; 771  : 			pKsd_t->sayflag = SAY_LETTER;

  004ca	c7 87 c8 03 00
	00 02 00 00 00	 mov	 DWORD PTR [edi+968], 2
  004d4	5f		 pop	 edi

; 789  : 			break;
; 790  : 	}
; 791  : 	return(CMD_success);

  004d5	33 c0		 xor	 eax, eax
  004d7	5e		 pop	 esi

; 792  : }

  004d8	c3		 ret	 0
$L71644:

; 772  : 			break;
; 773  : 
; 774  : 		case    3       :                               /* fletter */
; 775  : 
; 776  : 			if(cm_cmd_sync(phTTS) == CMD_flushing)

  004d9	56		 push	 esi
  004da	e8 00 00 00 00	 call	 _cm_cmd_sync
  004df	83 c4 04	 add	 esp, 4
  004e2	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  004e5	75 03		 jne	 SHORT $L71645
  004e7	5f		 pop	 edi
  004e8	5e		 pop	 esi

; 792  : }

  004e9	c3		 ret	 0
$L71645:

; 777  : 				return(CMD_flushing);
; 778  : 			pKsd_t->sayflag = SAY_FLETTER;

  004ea	c7 87 c8 03 00
	00 10 00 00 00	 mov	 DWORD PTR [edi+968], 16	; 00000010H
  004f4	5f		 pop	 edi

; 789  : 			break;
; 790  : 	}
; 791  : 	return(CMD_success);

  004f5	33 c0		 xor	 eax, eax
  004f7	5e		 pop	 esi

; 792  : }

  004f8	c3		 ret	 0
$L71646:

; 779  : 			break;
; 780  : 
; 781  : 		case    4       :                               /* line */
; 782  : 
; 783  : 			pKsd_t->sayflag = SAY_LINE;

  004f9	c7 87 c8 03 00
	00 04 00 00 00	 mov	 DWORD PTR [edi+968], 4
  00503	5f		 pop	 edi

; 789  : 			break;
; 790  : 	}
; 791  : 	return(CMD_success);

  00504	33 c0		 xor	 eax, eax
  00506	5e		 pop	 esi

; 792  : }

  00507	c3		 ret	 0
$L71647:

; 784  : 			break;
; 785  : 
; 786  : 		case    5       :                               /* syllables */
; 787  : 
; 788  : 			pKsd_t->sayflag = SAY_SYLLABLE;

  00508	c7 87 c8 03 00
	00 08 00 00 00	 mov	 DWORD PTR [edi+968], 8
$L71637:
  00512	5f		 pop	 edi

; 789  : 			break;
; 790  : 	}
; 791  : 	return(CMD_success);

  00513	33 c0		 xor	 eax, eax
  00515	5e		 pop	 esi

; 792  : }

  00516	c3		 ret	 0
  00517	90		 npad	 1
$L72135:
  00518	00 00 00 00	 DD	 $L71640
  0051c	00 00 00 00	 DD	 $L71641
  00520	00 00 00 00	 DD	 $L71642
  00524	00 00 00 00	 DD	 $L71644
  00528	00 00 00 00	 DD	 $L71646
  0052c	00 00 00 00	 DD	 $L71647
_cm_cmd_say ENDP
_phTTS$ = 8
_cm_cmd_error PROC NEAR

; 814  : 	int     value;
; 815  : 	//PKSD_T pKsd_t = phTTS->pKernelShareData;
; 816  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00530	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00534	56		 push	 esi
  00535	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]

; 817  : 
; 818  : 	value = cm_util_string_match(error_options,pCmd_t->pString[0]);

  00538	8b 8e 80 02 00
	00		 mov	 ecx, DWORD PTR [esi+640]
  0053e	51		 push	 ecx
  0053f	68 00 00 00 00	 push	 OFFSET FLAT:_error_options
  00544	e8 00 00 00 00	 call	 _cm_util_string_match
  00549	83 c4 08	 add	 esp, 8

; 819  : 	if(value == NO_STRING_MATCH)

  0054c	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00551	75 07		 jne	 SHORT $L71653

; 820  : 		return(CMD_bad_string);

  00553	b8 01 00 00 00	 mov	 eax, 1
  00558	5e		 pop	 esi

; 849  : }

  00559	c3		 ret	 0
$L71653:

; 821  : 	switch(value)
; 822  : 	{

  0055a	83 f8 04	 cmp	 eax, 4
  0055d	77 49		 ja	 SHORT $L71655
  0055f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72137[eax*4]
$L71658:

; 823  : 		case    0       :                               /* ignore */
; 824  : 
; 825  : 			pCmd_t->error_mode = ERROR_ignore;

  00566	c7 86 08 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1288], 0

; 846  : 			break;
; 847  : 	}
; 848  : 	return(CMD_success);

  00570	33 c0		 xor	 eax, eax
  00572	5e		 pop	 esi

; 849  : }

  00573	c3		 ret	 0
$L71659:

; 826  : 			break;
; 827  : 
; 828  : 		case    1       :                               /* text */
; 829  : 
; 830  : 			pCmd_t->error_mode = ERROR_text;

  00574	c7 86 08 05 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+1288], 1

; 846  : 			break;
; 847  : 	}
; 848  : 	return(CMD_success);

  0057e	33 c0		 xor	 eax, eax
  00580	5e		 pop	 esi

; 849  : }

  00581	c3		 ret	 0
$L71660:

; 831  : 			break;
; 832  : 
; 833  : 		case    2       :                               /* escape */
; 834  : 
; 835  : 			pCmd_t->error_mode = ERROR_escape;

  00582	c7 86 08 05 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+1288], 2

; 846  : 			break;
; 847  : 	}
; 848  : 	return(CMD_success);

  0058c	33 c0		 xor	 eax, eax
  0058e	5e		 pop	 esi

; 849  : }

  0058f	c3		 ret	 0
$L71661:

; 836  : 			break;
; 837  : 
; 838  : 		case    3       :                               /* speak */
; 839  : 
; 840  : 			pCmd_t->error_mode = ERROR_speak;

  00590	c7 86 08 05 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+1288], 3

; 846  : 			break;
; 847  : 	}
; 848  : 	return(CMD_success);

  0059a	33 c0		 xor	 eax, eax
  0059c	5e		 pop	 esi

; 849  : }

  0059d	c3		 ret	 0
$L71662:

; 841  : 			break;
; 842  : 
; 843  : 		case    4       :                               /* tone */
; 844  : 
; 845  : 			pCmd_t->error_mode = ERROR_tone;

  0059e	c7 86 08 05 00
	00 04 00 00 00	 mov	 DWORD PTR [esi+1288], 4
$L71655:

; 846  : 			break;
; 847  : 	}
; 848  : 	return(CMD_success);

  005a8	33 c0		 xor	 eax, eax
  005aa	5e		 pop	 esi

; 849  : }

  005ab	c3		 ret	 0
$L72137:
  005ac	00 00 00 00	 DD	 $L71658
  005b0	00 00 00 00	 DD	 $L71659
  005b4	00 00 00 00	 DD	 $L71660
  005b8	00 00 00 00	 DD	 $L71661
  005bc	00 00 00 00	 DD	 $L71662
_cm_cmd_error ENDP
_TEXT	ENDS
EXTRN	__imp__Sleep@4:NEAR
EXTRN	__imp__GetTickCount@0:NEAR
EXTRN	_TextToSpeechPause:NEAR
EXTRN	_TextToSpeechResume:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pKsd_t$ = 8
_cm_cmd_pause PROC NEAR

; 865  : {

  005c0	55		 push	 ebp

; 866  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  005c1	8b 6c 24 08	 mov	 ebp, DWORD PTR _phTTS$[esp]
  005c5	56		 push	 esi

; 867  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  005c6	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  005c9	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  005cc	89 44 24 0c	 mov	 DWORD PTR _pKsd_t$[esp+4], eax

; 868  : 	
; 869  : #ifdef MSDOS
; 870  : 	pKsd_t->pause = TRUE;
; 871  : 	STOP_SAMPCLK;
; 872  : 	if(pCmd_t->defaults[0] == FALSE)
; 873  : 	{
; 874  : 		sleep(pCmd_t->params[0]);
; 875  : 		pKsd_t->pause = FALSE;
; 876  : 		START_SAMPCLK;
; 877  : 	}
; 878  : 	return(CMD_success);
; 879  : #endif
; 880  : 
; 881  : /* GL 04/21/1997  change this for OSF build */
; 882  : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 883  :   /*LPTTS_HANDLE_T phTTS; */
; 884  :   DWORD dwDelay;
; 885  : #ifdef WIN32
; 886  :   DWORD dwStartTime;
; 887  :   DWORD dwElapsedTime;
; 888  :   DWORD dwRemainingTime;
; 889  : #endif
; 890  : 
; 891  : /* GL 10/30/1996, comment out this as V43 code
; 892  :   if( cm_cmd_sync(phTTS) == CMD_flushing )
; 893  : 	return(CMD_flushing);
; 894  : */
; 895  :   dwDelay = (DWORD)(pCmd_t->params[0]);

  005d0	8b 31		 mov	 esi, DWORD PTR [ecx]

; 896  : 
; 897  :   if ( dwDelay != 0 )

  005d2	85 f6		 test	 esi, esi
  005d4	74 57		 je	 SHORT $L72140
  005d6	53		 push	 ebx
  005d7	57		 push	 edi

; 898  :   {
; 899  : 	TextToSpeechPause( phTTS );

  005d8	55		 push	 ebp
  005d9	e8 00 00 00 00	 call	 _TextToSpeechPause

; 900  : 
; 901  : #ifdef WIN32
; 902  : 	dwStartTime = GetTickCount();

  005de	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  005e4	83 c4 04	 add	 esp, 4
  005e7	ff d7		 call	 edi
  005e9	8b d8		 mov	 ebx, eax

; 903  : 
; 904  : 	while ((( dwElapsedTime = GetTickCount() - dwStartTime ) < dwDelay )
; 905  : 		&& ( ! pKsd_t->halting ))

  005eb	ff d7		 call	 edi
  005ed	2b c3		 sub	 eax, ebx
  005ef	3b c6		 cmp	 eax, esi
  005f1	73 2a		 jae	 SHORT $L71676
$L71675:
  005f3	8b 54 24 14	 mov	 edx, DWORD PTR _pKsd_t$[esp+12]
  005f7	8b 8a 34 03 00
	00		 mov	 ecx, DWORD PTR [edx+820]
  005fd	85 c9		 test	 ecx, ecx
  005ff	75 1c		 jne	 SHORT $L71676

; 906  : 	{
; 907  : 	  dwRemainingTime = dwDelay - dwElapsedTime;

  00601	8b ce		 mov	 ecx, esi
  00603	2b c8		 sub	 ecx, eax

; 908  : 
; 909  : 	  if ( dwRemainingTime > 10 )

  00605	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00608	76 04		 jbe	 SHORT $L71677

; 910  : 	  {
; 911  : 			Sleep( 10 );

  0060a	6a 0a		 push	 10			; 0000000aH

; 912  : 	  }
; 913  : 	  else

  0060c	eb 01		 jmp	 SHORT $L72141
$L71677:

; 914  : 	  {
; 915  : 			Sleep( dwRemainingTime );

  0060e	51		 push	 ecx
$L72141:
  0060f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  00615	ff d7		 call	 edi
  00617	2b c3		 sub	 eax, ebx
  00619	3b c6		 cmp	 eax, esi
  0061b	72 d6		 jb	 SHORT $L71675
$L71676:

; 916  : 	  }
; 917  : 	}
; 918  : 	TextToSpeechResume( phTTS );

  0061d	55		 push	 ebp
  0061e	e8 00 00 00 00	 call	 _TextToSpeechResume
  00623	83 c4 04	 add	 esp, 4

; 919  : #endif
; 920  : /* GL 04/21/1997  add this for OSF build */
; 921  : #ifdef __osf__
; 922  :     while ((dwDelay > 0) && ( ! pKsd_t->halting))
; 923  :     {
; 924  : 	if ( dwDelay > 10)
; 925  : 	{
; 926  : 	    OP_Sleep(10);
; 927  : 	    dwDelay -= 10;
; 928  : 	}
; 929  : 	else
; 930  : 	{
; 931  : 	    OP_Sleep(dwDelay);
; 932  : 	    dwDelay = 0;
; 933  : 	}
; 934  :     }
; 935  :     TextToSpeechResume( phTTS );
; 936  : #endif
; 937  : #ifdef __linux__
; 938  :     while ((dwDelay > 0) && ( ! pKsd_t->halting))
; 939  :     {
; 940  :         if ( dwDelay > 10)
; 941  :         {
; 942  :             OP_Sleep(10);
; 943  :             dwDelay -= 10;
; 944  :         }
; 945  :         else
; 946  :         {
; 947  :             OP_Sleep(dwDelay);
; 948  :             dwDelay = 0;
; 949  :         }
; 950  :     }
; 951  :     TextToSpeechResume( phTTS );
; 952  : #endif
; 953  : 
; 954  : 	
; 955  :   }
; 956  :   return(CMD_success);

  00626	33 c0		 xor	 eax, eax
  00628	5f		 pop	 edi
  00629	5b		 pop	 ebx
  0062a	5e		 pop	 esi
  0062b	5d		 pop	 ebp

; 957  : #endif
; 958  : 
; 959  : }

  0062c	c3		 ret	 0
$L72140:
  0062d	5e		 pop	 esi

; 919  : #endif
; 920  : /* GL 04/21/1997  add this for OSF build */
; 921  : #ifdef __osf__
; 922  :     while ((dwDelay > 0) && ( ! pKsd_t->halting))
; 923  :     {
; 924  : 	if ( dwDelay > 10)
; 925  : 	{
; 926  : 	    OP_Sleep(10);
; 927  : 	    dwDelay -= 10;
; 928  : 	}
; 929  : 	else
; 930  : 	{
; 931  : 	    OP_Sleep(dwDelay);
; 932  : 	    dwDelay = 0;
; 933  : 	}
; 934  :     }
; 935  :     TextToSpeechResume( phTTS );
; 936  : #endif
; 937  : #ifdef __linux__
; 938  :     while ((dwDelay > 0) && ( ! pKsd_t->halting))
; 939  :     {
; 940  :         if ( dwDelay > 10)
; 941  :         {
; 942  :             OP_Sleep(10);
; 943  :             dwDelay -= 10;
; 944  :         }
; 945  :         else
; 946  :         {
; 947  :             OP_Sleep(dwDelay);
; 948  :             dwDelay = 0;
; 949  :         }
; 950  :     }
; 951  :     TextToSpeechResume( phTTS );
; 952  : #endif
; 953  : 
; 954  : 	
; 955  :   }
; 956  :   return(CMD_success);

  0062e	33 c0		 xor	 eax, eax
  00630	5d		 pop	 ebp

; 957  : #endif
; 958  : 
; 959  : }

  00631	c3		 ret	 0
_cm_cmd_pause ENDP
_phTTS$ = 8
_cm_cmd_resume PROC NEAR

; 977  : {

  00640	56		 push	 esi

; 978  : #ifdef MSDOS
; 979  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;
; 980  : 	pKsd_t->pause = FALSE;
; 981  : 	START_SAMPCLK;
; 982  : #endif
; 983  : 
; 984  : /* GL 04/21/1997  change this for OSF build */
; 985  : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 986  :   if( cm_cmd_sync(phTTS) == CMD_flushing )

  00641	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  00645	56		 push	 esi
  00646	e8 00 00 00 00	 call	 _cm_cmd_sync
  0064b	83 c4 04	 add	 esp, 4
  0064e	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00651	75 02		 jne	 SHORT $L71682
  00653	5e		 pop	 esi

; 993  : }

  00654	c3		 ret	 0
$L71682:

; 987  : 	return(CMD_flushing);
; 988  : 
; 989  :   TextToSpeechResume( phTTS );

  00655	56		 push	 esi
  00656	e8 00 00 00 00	 call	 _TextToSpeechResume
  0065b	83 c4 04	 add	 esp, 4

; 990  : #endif
; 991  : 
; 992  :   return(CMD_success);          

  0065e	33 c0		 xor	 eax, eax
  00660	5e		 pop	 esi

; 993  : }

  00661	c3		 ret	 0
_cm_cmd_resume ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_flush
EXTRN	_start_flush:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_cm_cmd_flush PROC NEAR

; 1012 : #ifdef MSDOS
; 1013 : 	unsigned short int old_flags;
; 1014 : #endif
; 1015 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00670	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00674	53		 push	 ebx
  00675	56		 push	 esi
  00676	57		 push	 edi

; 1016 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00677	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  0067a	8b 70 08	 mov	 esi, DWORD PTR [eax+8]

; 1017 : 
; 1018 : 	if(pCmd_t->defaults[0] == TRUE || pCmd_t->defaults[1] == TRUE)

  0067d	bb 01 00 00 00	 mov	 ebx, 1
  00682	39 9f a8 02 00
	00		 cmp	 DWORD PTR [edi+680], ebx
  00688	0f 84 d9 00 00
	00		 je	 $L71696
  0068e	39 9f ac 02 00
	00		 cmp	 DWORD PTR [edi+684], ebx
  00694	0f 84 cd 00 00
	00		 je	 $L71696

; 1019 : 	{
; 1020 : #ifdef DTEX
; 1021 : 		p_putc(XON);
; 1022 : #endif /*DTEX*/
; 1023 : 		return(CMD_success);
; 1024 : 	}
; 1025 : 	pCmd_t->params[0] = cm_util_string_match(flush_options, pCmd_t->pString[0]);

  0069a	8b 87 80 02 00
	00		 mov	 eax, DWORD PTR [edi+640]
  006a0	50		 push	 eax
  006a1	68 00 00 00 00	 push	 OFFSET FLAT:_flush_options
  006a6	e8 00 00 00 00	 call	 _cm_util_string_match
  006ab	83 c4 08	 add	 esp, 8

; 1026 : 	if(pCmd_t->params[0] == NO_STRING_MATCH)

  006ae	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  006b3	89 07		 mov	 DWORD PTR [edi], eax
  006b5	75 06		 jne	 SHORT $L71690
  006b7	5f		 pop	 edi

; 1027 : 		return(CMD_bad_string);

  006b8	8b c3		 mov	 eax, ebx
  006ba	5e		 pop	 esi
  006bb	5b		 pop	 ebx

; 1079 : 			break;
; 1080 : 
; 1081 : 	}
; 1082 : 	return(CMD_success);
; 1083 : }

  006bc	c3		 ret	 0
$L71690:

; 1028 : 	if(pCmd_t->params[0] >= (sizeof(flush_options)/2))

  006bd	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  006c0	72 09		 jb	 SHORT $L71691
  006c2	5f		 pop	 edi
  006c3	5e		 pop	 esi

; 1029 : 		return(CMD_bad_value);

  006c4	b8 02 00 00 00	 mov	 eax, 2
  006c9	5b		 pop	 ebx

; 1079 : 			break;
; 1080 : 
; 1081 : 	}
; 1082 : 	return(CMD_success);
; 1083 : }

  006ca	c3		 ret	 0
$L71691:

; 1030 : 	switch(pCmd_t->params[0])
; 1031 : 	{

  006cb	83 f8 04	 cmp	 eax, 4
  006ce	0f 87 93 00 00
	00		 ja	 $L71696
  006d4	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72144[eax*4]
$L71697:

; 1032 : 		case    0       :                               /* all */
; 1033 : 			return(CMD_success);
; 1034 : 			break;
; 1035 : 		
; 1036 : 		case    1       :                               /* until */
; 1037 : 
; 1038 : 			pKsd_t->spc_flush_type = SPC_flush_until;

  006db	89 9e 6c 03 00
	00		 mov	 DWORD PTR [esi+876], ebx

; 1039 : 			pKsd_t->spc_flush_value = pCmd_t->params[1];

  006e1	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  006e4	89 8e 68 03 00
	00		 mov	 DWORD PTR [esi+872], ecx

; 1040 : 			pKsd_t->spc_flush = TRUE;

  006ea	89 9e 64 03 00
	00		 mov	 DWORD PTR [esi+868], ebx
  006f0	5f		 pop	 edi
  006f1	5e		 pop	 esi
  006f2	33 c0		 xor	 eax, eax
  006f4	5b		 pop	 ebx

; 1079 : 			break;
; 1080 : 
; 1081 : 	}
; 1082 : 	return(CMD_success);
; 1083 : }

  006f5	c3		 ret	 0
$L71698:

; 1041 : 			break;
; 1042 : 
; 1043 : 		case    2       :                               /* mask */
; 1044 : 
; 1045 : 			pKsd_t->spc_flush_type = SPC_flush_mask;

  006f6	c7 86 6c 03 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+876], 2

; 1046 : 			pKsd_t->spc_flush_value = pCmd_t->params[1];

  00700	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00703	89 96 68 03 00
	00		 mov	 DWORD PTR [esi+872], edx

; 1047 : 			pKsd_t->spc_flush = TRUE;

  00709	89 9e 64 03 00
	00		 mov	 DWORD PTR [esi+868], ebx
  0070f	5f		 pop	 edi
  00710	5e		 pop	 esi
  00711	33 c0		 xor	 eax, eax
  00713	5b		 pop	 ebx

; 1079 : 			break;
; 1080 : 
; 1081 : 	}
; 1082 : 	return(CMD_success);
; 1083 : }

  00714	c3		 ret	 0
$L71699:

; 1048 : 			break;
; 1049 : 
; 1050 : 		case    3       :                               /* after */
; 1051 : 
; 1052 : #ifdef MSDOS                    
; 1053 : 			old_flags = kernel_disable();
; 1054 : #endif
; 1055 : 			if(pKsd_t->halting == FALSE)

  00715	8b 86 34 03 00
	00		 mov	 eax, DWORD PTR [esi+820]
  0071b	85 c0		 test	 eax, eax
  0071d	75 23		 jne	 SHORT $L71700

; 1056 : 			{
; 1057 : 				pKsd_t->spc_flush_type = SPC_flush_after;

  0071f	c7 86 6c 03 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+876], 3

; 1058 : 				pKsd_t->spc_flush_value = pCmd_t->params[1];

  00729	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0072c	89 86 68 03 00
	00		 mov	 DWORD PTR [esi+872], eax

; 1059 : 				pKsd_t->spc_flush = TRUE;

  00732	89 9e 64 03 00
	00		 mov	 DWORD PTR [esi+868], ebx

; 1060 : 				pKsd_t->spc_sync.value = 0;

  00738	c7 86 a0 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+928], 0
$L71700:

; 1061 : #ifdef MSDOS
; 1062 : 				wait_semaphore(&pKsd_t->spc_sync);
; 1063 : #endif
; 1064 : 			}
; 1065 : #ifdef MSDOS
; 1066 : 			else
; 1067 : 			{                    
; 1068 : 				kernel_enable(old_flags);
; 1069 : 			}
; 1070 : #endif
; 1071 : 			start_flush(TRUE);

  00742	53		 push	 ebx
  00743	e8 00 00 00 00	 call	 _start_flush
  00748	83 c4 04	 add	 esp, 4
  0074b	33 c0		 xor	 eax, eax
  0074d	5f		 pop	 edi
  0074e	5e		 pop	 esi
  0074f	5b		 pop	 ebx

; 1079 : 			break;
; 1080 : 
; 1081 : 	}
; 1082 : 	return(CMD_success);
; 1083 : }

  00750	c3		 ret	 0
$L71701:

; 1072 : 			break;
; 1073 : 
; 1074 : 		case    4       :                               /* text */
; 1075 : 
; 1076 : 			pKsd_t->spc_flush_type = SPC_flush_all;

  00751	c7 86 6c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+876], 0

; 1077 : 			pKsd_t->spc_flush = TRUE;

  0075b	89 9e 64 03 00
	00		 mov	 DWORD PTR [esi+868], ebx

; 1078 : 			pKsd_t->text_flush = TRUE;

  00761	89 9e 30 03 00
	00		 mov	 DWORD PTR [esi+816], ebx
$L71696:
  00767	5f		 pop	 edi
  00768	5e		 pop	 esi
  00769	33 c0		 xor	 eax, eax
  0076b	5b		 pop	 ebx

; 1079 : 			break;
; 1080 : 
; 1081 : 	}
; 1082 : 	return(CMD_success);
; 1083 : }

  0076c	c3		 ret	 0
  0076d	8d 49 00	 npad	 3
$L72144:
  00770	00 00 00 00	 DD	 $L71696
  00774	00 00 00 00	 DD	 $L71697
  00778	00 00 00 00	 DD	 $L71698
  0077c	00 00 00 00	 DD	 $L71699
  00780	00 00 00 00	 DD	 $L71701
_cm_cmd_flush ENDP
_TEXT	ENDS
EXTRN	__imp__ResetEvent@4:NEAR
EXTRN	__imp__WaitForSingleObject@8:NEAR
EXTRN	_cm_util_write_pipe:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pipe_value$ = 8
_cm_cmd_sync PROC NEAR

; 1101 : {   

  00790	56		 push	 esi
  00791	57		 push	 edi

; 1102 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00792	8b 7c 24 0c	 mov	 edi, DWORD PTR _phTTS$[esp+4]
  00796	8b 77 08	 mov	 esi, DWORD PTR [edi+8]

; 1103 : 
; 1104 : #ifdef MSDOS
; 1105 : 	DT_PIPE_T pipe_value;
; 1106 : 	unsigned int old_flags;
; 1107 : 	
; 1108 : #ifdef DTEX
; 1109 : 	/* 
; 1110 : 	 * pKsd_t->idleflag is used to tell when we've been quiescent long
; 1111 : 	 * enough to fall asleep.. 
; 1112 : 	 */
; 1113 : 	pKsd_t->idleflag = 0;
; 1114 : #endif /*DTEX*/ 
; 1115 : 
; 1116 : 	old_flags = kernel_disable();
; 1117 : 	if(pKsd_t->halting == FALSE)
; 1118 : 	{
; 1119 : 		pKsd_t->spc_sync.value = 0;
; 1120 : 		pipe_value = (PFASCII<<PSFONT)+0xb;
; 1121 :                 cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,&pipe_value,1);
; 1122 : 		pipe_value = SYNC;
; 1123 :                 cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,&pipe_value,1);
; 1124 : 		kernel_enable(old_flags);
; 1125 : 		wait_semaphore(&(pKsd_t->spc_sync));
; 1126 : 	}
; 1127 : 	else
; 1128 : 	{
; 1129 : 		kernel_enable(old_flags);
; 1130 : 	}                 
; 1131 : 
; 1132 : 	
; 1133 : 	if(pKsd_t->cmd_flush)
; 1134 : 		return(CMD_flushing);
; 1135 : 	return(CMD_success);
; 1136 : #endif /* #ifdef MSDOS */       
; 1137 : 
; 1138 : /* GL 04/21/1997  add this for OSF build */
; 1139 : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 1140 :   DT_PIPE_T pipe_value;
; 1141 : 
; 1142 : /*  LPTTS_HANDLE_T phTTS; */    /* MVP MI earlier the value of phTTS used to get by
; 1143 : 									TextToSpeechGetHandle()
; 1144 : 								*/
; 1145 : 
; 1146 :   if(pKsd_t->halting == FALSE)

  00799	8b 86 34 03 00
	00		 mov	 eax, DWORD PTR [esi+820]
  0079f	85 c0		 test	 eax, eax
  007a1	75 5b		 jne	 SHORT $L71707

; 1147 :   {
; 1148 : 	/*phTTS = TextToSpeechGetHandle();*/   /*MVP MI */
; 1149 : 
; 1150 : #ifdef WIN32
; 1151 : 	  ResetEvent( phTTS->hSyncEvent );

  007a3	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  007a6	50		 push	 eax
  007a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResetEvent@4

; 1152 : #endif
; 1153 : /* GL 04/21/1997  add this for OSF build */
; 1154 : #ifdef __osf__
; 1155 :     OP_ResetEvent( phTTS->hSyncEvent );
; 1156 : #endif
; 1157 : #ifdef __linux__
; 1158 :     OP_ResetEvent( phTTS->hSyncEvent );
; 1159 : #endif
; 1160 : 
; 1161 : 	pKsd_t->spc_sync.value = 0;

  007ad	c7 86 a0 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+928], 0

; 1162 : 	pipe_value = (PFASCII<<PSFONT)+0xb;

  007b7	c7 44 24 0c 0b
	00 00 00	 mov	 DWORD PTR _pipe_value$[esp+4], 11 ; 0000000bH

; 1163 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,&pipe_value,1);

  007bf	8b 96 90 02 00
	00		 mov	 edx, DWORD PTR [esi+656]
  007c5	8d 4c 24 0c	 lea	 ecx, DWORD PTR _pipe_value$[esp+4]
  007c9	6a 01		 push	 1
  007cb	51		 push	 ecx
  007cc	52		 push	 edx
  007cd	56		 push	 esi
  007ce	e8 00 00 00 00	 call	 _cm_util_write_pipe

; 1164 : 	pipe_value = SYNC;

  007d3	c7 44 24 1c 0a
	1f 00 00	 mov	 DWORD PTR _pipe_value$[esp+20], 7946 ; 00001f0aH

; 1165 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,&pipe_value,1);

  007db	8b 8e 90 02 00
	00		 mov	 ecx, DWORD PTR [esi+656]
  007e1	8d 44 24 1c	 lea	 eax, DWORD PTR _pipe_value$[esp+20]
  007e5	6a 01		 push	 1
  007e7	50		 push	 eax
  007e8	51		 push	 ecx
  007e9	56		 push	 esi
  007ea	e8 00 00 00 00	 call	 _cm_util_write_pipe

; 1166 : 
; 1167 : #ifdef WIN32
; 1168 : 	WaitForSingleObject( phTTS->hSyncEvent, INFINITE );

  007ef	8b 57 38	 mov	 edx, DWORD PTR [edi+56]
  007f2	83 c4 20	 add	 esp, 32			; 00000020H
  007f5	6a ff		 push	 -1
  007f7	52		 push	 edx
  007f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
$L71707:

; 1169 : #endif
; 1170 : /* GL 04/21/1997  add this for OSF build */
; 1171 : #ifdef __osf__
; 1172 :     OP_WaitForEvent( phTTS->hSyncEvent, OP_INFINITE );
; 1173 : #endif
; 1174 : #ifdef __linux__
; 1175 :     OP_WaitForEvent( phTTS->hSyncEvent, OP_INFINITE );
; 1176 : #endif
; 1177 : 
; 1178 :   }
; 1179 : 
; 1180 :   if(pKsd_t->cmd_flush)

  007fe	8b 86 2c 03 00
	00		 mov	 eax, DWORD PTR [esi+812]
  00804	5f		 pop	 edi
  00805	f7 d8		 neg	 eax
  00807	1b c0		 sbb	 eax, eax
  00809	5e		 pop	 esi
  0080a	83 e0 0b	 and	 eax, 11			; 0000000bH

; 1181 : 	return(CMD_flushing);
; 1182 : 
; 1183 :   return(CMD_success);
; 1184 : 
; 1185 : #endif
; 1186 : }

  0080d	c3		 ret	 0
_cm_cmd_sync ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_enable
EXTRN	_reset_spc:NEAR
EXTRN	_wait_semaphore:NEAR
_TEXT	SEGMENT
_pKsd_t$ = 8
_pipe_value$ = 8
_cm_cmd_enable PROC NEAR

; 1202 : {

  00810	56		 push	 esi

; 1203 : 	DT_PIPE_T pipe_value;
; 1204 : #ifdef MSDOS
; 1205 : 	unsigned int old_flags; 
; 1206 : 	old_flags = kernel_disable();
; 1207 : #endif
; 1208 : 	if(pKsd_t->halting == FALSE)

  00811	8b 74 24 08	 mov	 esi, DWORD PTR _pKsd_t$[esp]
  00815	8b 86 34 03 00
	00		 mov	 eax, DWORD PTR [esi+820]
  0081b	85 c0		 test	 eax, eax
  0081d	75 4f		 jne	 SHORT $L71713

; 1209 : 	{
; 1210 : 		pKsd_t->spc_sync.value = 0;
; 1211 : 		pipe_value = (PFASCII<<PSFONT)+0xb;
; 1212 :                 cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,&pipe_value,1);

  0081f	8b 8e 90 02 00
	00		 mov	 ecx, DWORD PTR [esi+656]
  00825	57		 push	 edi
  00826	8d 44 24 0c	 lea	 eax, DWORD PTR _pipe_value$[esp+4]
  0082a	6a 01		 push	 1
  0082c	8d be a0 03 00
	00		 lea	 edi, DWORD PTR [esi+928]
  00832	50		 push	 eax
  00833	51		 push	 ecx
  00834	56		 push	 esi
  00835	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0083b	c7 44 24 1c 0b
	00 00 00	 mov	 DWORD PTR _pipe_value$[esp+20], 11 ; 0000000bH
  00843	e8 00 00 00 00	 call	 _cm_util_write_pipe

; 1213 : 		pipe_value = SYNC;
; 1214 :                 cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,&pipe_value,1);

  00848	8b 86 90 02 00
	00		 mov	 eax, DWORD PTR [esi+656]
  0084e	8d 54 24 1c	 lea	 edx, DWORD PTR _pipe_value$[esp+20]
  00852	6a 01		 push	 1
  00854	52		 push	 edx
  00855	50		 push	 eax
  00856	56		 push	 esi
  00857	c7 44 24 2c 0a
	1f 00 00	 mov	 DWORD PTR _pipe_value$[esp+36], 7946 ; 00001f0aH
  0085f	e8 00 00 00 00	 call	 _cm_util_write_pipe

; 1215 : #ifdef MSDOS
; 1216 : 		kernel_enable(old_flags);
; 1217 : #endif          
; 1218 : #ifndef __linux__
; 1219 : 		wait_semaphore(&pKsd_t->spc_sync);

  00864	57		 push	 edi
  00865	e8 00 00 00 00	 call	 _wait_semaphore
  0086a	83 c4 24	 add	 esp, 36			; 00000024H
  0086d	5f		 pop	 edi
$L71713:

; 1220 : #endif
; 1221 : 	}
; 1222 : #ifdef MSDOS
; 1223 : 	else
; 1224 : 	{
; 1225 : 		kernel_enable(old_flags);
; 1226 : 	}
; 1227 : #endif
; 1228 : 	pKsd_t->spc_flush = FALSE;

  0086e	c7 86 64 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+868], 0

; 1229 : 	pKsd_t->text_flush = FALSE;

  00878	c7 86 30 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+816], 0

; 1230 : 	reset_spc();

  00882	e8 00 00 00 00	 call	 _reset_spc

; 1231 : 	return(CMD_success);

  00887	33 c0		 xor	 eax, eax
  00889	5e		 pop	 esi

; 1232 : }

  0088a	c3		 ret	 0
_cm_cmd_enable ENDP
_phTTS$ = 8
_cm_cmd_punct PROC NEAR

; 1251 : 	int     value;
; 1252 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00890	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00894	56		 push	 esi
  00895	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]

; 1253 : 	
; 1254 : 	value = cm_util_string_match(punct_options,pCmd_t->pString[0]);

  00898	8b 8e 80 02 00
	00		 mov	 ecx, DWORD PTR [esi+640]
  0089e	51		 push	 ecx
  0089f	68 00 00 00 00	 push	 OFFSET FLAT:_punct_options
  008a4	e8 00 00 00 00	 call	 _cm_util_string_match
  008a9	83 c4 08	 add	 esp, 8

; 1255 : 	if(value == NO_STRING_MATCH)

  008ac	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  008b1	75 07		 jne	 SHORT $L71719

; 1256 : 		return(CMD_bad_string);

  008b3	b8 01 00 00 00	 mov	 eax, 1
  008b8	5e		 pop	 esi

; 1285 : }

  008b9	c3		 ret	 0
$L71719:

; 1257 : 	switch(value)
; 1258 :     {

  008ba	83 f8 03	 cmp	 eax, 3
  008bd	77 3f		 ja	 SHORT $L71728
  008bf	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72148[eax*4]
$L71724:

; 1259 : 		case    PUNCT_none       :
; 1260 : 
; 1261 : 			pCmd_t->punct_mode = PUNCT_none;

  008c6	c7 86 0c 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1292], 0

; 1281 : 			break;
; 1282 : 	}         
; 1283 : 		/* pCmd_t->punct_mode=value; duplicate code? cjl 26-sep-95 */
; 1284 : 		return(CMD_success);

  008d0	33 c0		 xor	 eax, eax
  008d2	5e		 pop	 esi

; 1285 : }

  008d3	c3		 ret	 0
$L71725:

; 1262 : 			break;
; 1263 : 
; 1264 : 		case    PUNCT_some       :
; 1265 : 
; 1266 : 			pCmd_t->punct_mode = PUNCT_some;

  008d4	c7 86 0c 05 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+1292], 1

; 1281 : 			break;
; 1282 : 	}         
; 1283 : 		/* pCmd_t->punct_mode=value; duplicate code? cjl 26-sep-95 */
; 1284 : 		return(CMD_success);

  008de	33 c0		 xor	 eax, eax
  008e0	5e		 pop	 esi

; 1285 : }

  008e1	c3		 ret	 0
$L71726:

; 1267 : 			break;
; 1268 : 
; 1269 : 		case    PUNCT_all       :
; 1270 : 
; 1271 : 			pCmd_t->punct_mode = PUNCT_all;

  008e2	c7 86 0c 05 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+1292], 2

; 1281 : 			break;
; 1282 : 	}         
; 1283 : 		/* pCmd_t->punct_mode=value; duplicate code? cjl 26-sep-95 */
; 1284 : 		return(CMD_success);

  008ec	33 c0		 xor	 eax, eax
  008ee	5e		 pop	 esi

; 1285 : }

  008ef	c3		 ret	 0
$L71727:

; 1272 : 			break;
; 1273 : 				
; 1274 : 		case    PUNCT_pass       :
; 1275 : 
; 1276 : 			pCmd_t->punct_mode = PUNCT_pass;

  008f0	c7 86 0c 05 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+1292], 3

; 1281 : 			break;
; 1282 : 	}         
; 1283 : 		/* pCmd_t->punct_mode=value; duplicate code? cjl 26-sep-95 */
; 1284 : 		return(CMD_success);

  008fa	33 c0		 xor	 eax, eax
  008fc	5e		 pop	 esi

; 1285 : }

  008fd	c3		 ret	 0
$L71728:

; 1277 : 			break;
; 1278 : 				
; 1279 : 		default                  :
; 1280 : 			return(CMD_bad_value);

  008fe	b8 02 00 00 00	 mov	 eax, 2
  00903	5e		 pop	 esi

; 1285 : }

  00904	c3		 ret	 0
  00905	8d 49 00	 npad	 3
$L72148:
  00908	00 00 00 00	 DD	 $L71724
  0090c	00 00 00 00	 DD	 $L71725
  00910	00 00 00 00	 DD	 $L71726
  00914	00 00 00 00	 DD	 $L71727
_cm_cmd_punct ENDP
_phTTS$ = 8
_cm_cmd_skip PROC NEAR

; 1304 : 	int     value;
; 1305 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00920	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00924	56		 push	 esi
  00925	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]

; 1306 : 	
; 1307 : 	value = cm_util_string_match(skip_options,pCmd_t->pString[0]);

  00928	8b 8e 80 02 00
	00		 mov	 ecx, DWORD PTR [esi+640]
  0092e	51		 push	 ecx
  0092f	68 00 00 00 00	 push	 OFFSET FLAT:_skip_options
  00934	e8 00 00 00 00	 call	 _cm_util_string_match
  00939	83 c4 08	 add	 esp, 8

; 1308 : 	if(value == NO_STRING_MATCH)

  0093c	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00941	75 07		 jne	 SHORT $L71734

; 1309 : 		return(CMD_bad_string);

  00943	b8 01 00 00 00	 mov	 eax, 1
  00948	5e		 pop	 esi

; 1348 : }

  00949	c3		 ret	 0
$L71734:

; 1310 : 	switch(value)
; 1311 :     {

  0094a	83 f8 05	 cmp	 eax, 5
  0094d	77 5b		 ja	 SHORT $L71745
  0094f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72150[eax*4]
$L71739:

; 1312 : 		case    SKIP_none       :
; 1313 : 
; 1314 : 			pCmd_t->skip_mode = SKIP_none;

  00956	c7 86 10 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1296], 0

; 1344 : 			break;
; 1345 : 	}         
; 1346 : 
; 1347 : 		return(CMD_success);

  00960	33 c0		 xor	 eax, eax
  00962	5e		 pop	 esi

; 1348 : }

  00963	c3		 ret	 0
$L71740:

; 1315 : 			break;
; 1316 : 
; 1317 : 		case    SKIP_email       :
; 1318 : 
; 1319 : 			pCmd_t->skip_mode = SKIP_email;

  00964	c7 86 10 05 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+1296], 1

; 1344 : 			break;
; 1345 : 	}         
; 1346 : 
; 1347 : 		return(CMD_success);

  0096e	33 c0		 xor	 eax, eax
  00970	5e		 pop	 esi

; 1348 : }

  00971	c3		 ret	 0
$L71741:

; 1320 : 			break;
; 1321 : 
; 1322 : 		case    SKIP_punct       :
; 1323 : 
; 1324 : 			pCmd_t->skip_mode = SKIP_punct;

  00972	c7 86 10 05 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+1296], 2

; 1344 : 			break;
; 1345 : 	}         
; 1346 : 
; 1347 : 		return(CMD_success);

  0097c	33 c0		 xor	 eax, eax
  0097e	5e		 pop	 esi

; 1348 : }

  0097f	c3		 ret	 0
$L71742:

; 1325 : 			break;
; 1326 : 
; 1327 : 		case    SKIP_rule       :
; 1328 : 
; 1329 : 			pCmd_t->skip_mode = SKIP_rule;

  00980	c7 86 10 05 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+1296], 3

; 1344 : 			break;
; 1345 : 	}         
; 1346 : 
; 1347 : 		return(CMD_success);

  0098a	33 c0		 xor	 eax, eax
  0098c	5e		 pop	 esi

; 1348 : }

  0098d	c3		 ret	 0
$L71743:

; 1330 : 			break;
; 1331 : 				
; 1332 : 		case    SKIP_all       :
; 1333 : 
; 1334 : 			pCmd_t->skip_mode = SKIP_all;

  0098e	c7 86 10 05 00
	00 04 00 00 00	 mov	 DWORD PTR [esi+1296], 4

; 1344 : 			break;
; 1345 : 	}         
; 1346 : 
; 1347 : 		return(CMD_success);

  00998	33 c0		 xor	 eax, eax
  0099a	5e		 pop	 esi

; 1348 : }

  0099b	c3		 ret	 0
$L71744:

; 1335 : 			break;
; 1336 : 				
; 1337 : 		case    SKIP_cpg       :
; 1338 : 
; 1339 : 			pCmd_t->skip_mode = SKIP_cpg;

  0099c	c7 86 10 05 00
	00 05 00 00 00	 mov	 DWORD PTR [esi+1296], 5

; 1344 : 			break;
; 1345 : 	}         
; 1346 : 
; 1347 : 		return(CMD_success);

  009a6	33 c0		 xor	 eax, eax
  009a8	5e		 pop	 esi

; 1348 : }

  009a9	c3		 ret	 0
$L71745:

; 1340 : 			break;
; 1341 : 				
; 1342 : 		default                  :
; 1343 : 			return(CMD_bad_value);

  009aa	b8 02 00 00 00	 mov	 eax, 2
  009af	5e		 pop	 esi

; 1348 : }

  009b0	c3		 ret	 0
  009b1	8d 49 00	 npad	 3
$L72150:
  009b4	00 00 00 00	 DD	 $L71739
  009b8	00 00 00 00	 DD	 $L71740
  009bc	00 00 00 00	 DD	 $L71741
  009c0	00 00 00 00	 DD	 $L71742
  009c4	00 00 00 00	 DD	 $L71743
  009c8	00 00 00 00	 DD	 $L71744
_cm_cmd_skip ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_timeout
_TEXT	SEGMENT
_phTTS$ = 8
_cm_cmd_timeout PROC NEAR

; 1367 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  009d0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  009d4	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 1368 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  009d7	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 1369 : 	
; 1370 : 	if(pCmd_t->defaults[0] == TRUE)

  009da	83 b8 a8 02 00
	00 01		 cmp	 DWORD PTR [eax+680], 1
  009e1	75 06		 jne	 SHORT $L71751

; 1371 : 		pCmd_t->params[0] = 0;

  009e3	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L71751:

; 1372 : 
; 1373 : 	pCmd_t->timeout = pCmd_t->params[0];

  009e9	66 8b 08	 mov	 cx, WORD PTR [eax]
  009ec	66 89 88 94 57
	00 00		 mov	 WORD PTR [eax+22420], cx

; 1374 : 	pKsd_t->input_timeout = pCmd_t->timeout;

  009f3	0f bf c1	 movsx	 eax, cx
  009f6	89 82 d8 03 00
	00		 mov	 DWORD PTR [edx+984], eax

; 1375 : 	return(CMD_success);

  009fc	33 c0		 xor	 eax, eax

; 1376 : }

  009fe	c3		 ret	 0
_cm_cmd_timeout ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_cpu_rate
_TEXT	SEGMENT
_cm_cmd_cpu_rate PROC NEAR

; 1394 : #ifdef MSDOS    
; 1395 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 1396 : 	if(pCmd_t->defaults[0] == TRUE)
; 1397 : 		pCmd_t->params[0] = 10;
; 1398 : 	if(pCmd_t->params[0] <= 0 || pCmd_t->params[0] > 25)
; 1399 : 		return(CMD_bad_value);
; 1400 : 	module_clocks(pCmd_t->params[0]);
; 1401 : #endif
; 1402 : 	return(CMD_success);

  00a00	33 c0		 xor	 eax, eax

; 1403 : }

  00a02	c3		 ret	 0
_cm_cmd_cpu_rate ENDP
_phTTS$ = 8
_cm_cmd_setv PROC NEAR

; 1421 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00a10	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00a14	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 1422 :     //short cmd_number = pCmd_t->params[0]; /*MVP MI New*/
; 1423 : 	
; 1424 : 	if(pCmd_t->params[0] < 0 || pCmd_t->params[0] > 9)

  00a17	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a19	83 f9 09	 cmp	 ecx, 9
  00a1c	77 1c		 ja	 SHORT $L71760

; 1426 : 	pCmd_t->cmd_count=0;

  00a1e	66 c7 80 1c 05
	00 00 00 00	 mov	 WORD PTR [eax+1308], 0

; 1427 : 	pCmd_t->cmd_number = pCmd_t->params[0];

  00a27	66 89 88 1e 05
	00 00		 mov	 WORD PTR [eax+1310], cx

; 1428 : 	/* 
; 1429 :      * Tells command parser that its time to process                   
; 1430 : 	 * internally stored command string 
; 1431 : 	 */
; 1432 : 	// BATS#638 mfg 3/30/98 set insertflag equalto 2 on VOCAL build
; 1433 : #ifdef VOCAL
; 1434 : 	pCmd_t->insertflag=2;
; 1435 : #else
; 1436 : 	pCmd_t->insertflag=1;

  00a2e	66 c7 80 20 05
	00 00 01 00	 mov	 WORD PTR [eax+1312], 1

; 1437 : #endif	
; 1438 : 
; 1439 : 	return(CMD_success);

  00a37	33 c0		 xor	 eax, eax

; 1440 : }

  00a39	c3		 ret	 0
$L71760:

; 1425 : 		return(CMD_bad_value);

  00a3a	b8 02 00 00 00	 mov	 eax, 2

; 1440 : }

  00a3f	c3		 ret	 0
_cm_cmd_setv ENDP
_TEXT	ENDS
EXTRN	_read_pipe:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pKsd_t$ = 8
_temp$ = -60
_cm_cmd_loadv PROC NEAR

; 1456 : {   

  00a40	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 1457 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00a43	8b 44 24 40	 mov	 eax, DWORD PTR _phTTS$[esp+56]
  00a47	53		 push	 ebx
  00a48	55		 push	 ebp

; 1458 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;
; 1459 :    /* 
; 1460 :     *this will probably crash and burn if a flush happens 
; 1461 : 	* in the middle.. (tek 1/3/96)
; 1462 : 	*/
; 1463 :    unsigned char temp[60];
; 1464 :    int j=0;

  00a49	33 db		 xor	 ebx, ebx
  00a4b	8b 68 0c	 mov	 ebp, DWORD PTR [eax+12]
  00a4e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00a51	89 44 24 48	 mov	 DWORD PTR _pKsd_t$[esp+64], eax
  00a55	57		 push	 edi

; 1465 :    int flag=1;
; 1466 :    //short cmd_number = pCmd_t->params[0];  /* MVP MI new */
; 1467 :    
; 1468 :    if(pCmd_t->params[0] < 0 || pCmd_t->params[0] > 9)

  00a56	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00a59	bf 01 00 00 00	 mov	 edi, 1
  00a5e	83 f8 09	 cmp	 eax, 9
  00a61	77 7b		 ja	 SHORT $L71770

; 1470 :    pCmd_t->cmd_count=0;
; 1471 :    pCmd_t->cmd_number = pCmd_t->params[0];

  00a63	66 8b c8	 mov	 cx, ax
  00a66	56		 push	 esi
  00a67	66 89 9d 1c 05
	00 00		 mov	 WORD PTR [ebp+1308], bx
  00a6e	66 89 8d 1e 05
	00 00		 mov	 WORD PTR [ebp+1310], cx
  00a75	8d 74 24 10	 lea	 esi, DWORD PTR _temp$[esp+76]
$L71772:

; 1472 :    while (flag) 
; 1473 :    {
; 1474 : /* GL 04/21/1997  change this for OSF build */
; 1475 : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 1476 :           read_pipe(pKsd_t->cmd_pipe, &temp[j], 1);

  00a79	8b 54 24 50	 mov	 edx, DWORD PTR _pKsd_t$[esp+72]
  00a7d	6a 01		 push	 1
  00a7f	56		 push	 esi
  00a80	8b 82 98 02 00
	00		 mov	 eax, DWORD PTR [edx+664]
  00a86	50		 push	 eax
  00a87	e8 00 00 00 00	 call	 _read_pipe

; 1477 : #endif
; 1478 : 
; 1479 : #ifdef MSDOS
; 1480 : 	  temp[j] = getc();
; 1481 : #endif
; 1482 : 	  if (temp[j] == ']')

  00a8c	8a 06		 mov	 al, BYTE PTR [esi]
  00a8e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a91	3c 5d		 cmp	 al, 93			; 0000005dH
  00a93	75 02		 jne	 SHORT $L71774

; 1483 : 		flag = 0;

  00a95	33 ff		 xor	 edi, edi
$L71774:

; 1484 : 	  j++;

  00a97	43		 inc	 ebx
  00a98	46		 inc	 esi
  00a99	85 ff		 test	 edi, edi
  00a9b	75 dc		 jne	 SHORT $L71772

; 1485 :    }
; 1486 :    temp[j] = '\0';

  00a9d	c6 44 1c 10 00	 mov	 BYTE PTR _temp$[esp+ebx+76], 0

; 1487 :    strcpy(pCmd_t->setv[pCmd_t->cmd_number].cmd,temp); 

  00aa2	8d 7c 24 10	 lea	 edi, DWORD PTR _temp$[esp+76]
  00aa6	0f bf 85 1e 05
	00 00		 movsx	 eax, WORD PTR [ebp+1310]
  00aad	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00ab0	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00ab3	33 c0		 xor	 eax, eax
  00ab5	8d 54 8d 28	 lea	 edx, DWORD PTR [ebp+ecx*4+40]
  00ab9	83 c9 ff	 or	 ecx, -1
  00abc	f2 ae		 repne scasb
  00abe	f7 d1		 not	 ecx
  00ac0	2b f9		 sub	 edi, ecx
  00ac2	8b c1		 mov	 eax, ecx
  00ac4	8b f7		 mov	 esi, edi
  00ac6	8b fa		 mov	 edi, edx
  00ac8	c1 e9 02	 shr	 ecx, 2
  00acb	f3 a5		 rep movsd
  00acd	8b c8		 mov	 ecx, eax
  00acf	83 e1 03	 and	 ecx, 3

; 1488 :    return(CMD_success);

  00ad2	33 c0		 xor	 eax, eax
  00ad4	f3 a4		 rep movsb
  00ad6	5e		 pop	 esi
  00ad7	5f		 pop	 edi
  00ad8	5d		 pop	 ebp
  00ad9	5b		 pop	 ebx

; 1489 : }

  00ada	83 c4 3c	 add	 esp, 60			; 0000003cH
  00add	c3		 ret	 0
$L71770:
  00ade	5f		 pop	 edi
  00adf	5d		 pop	 ebp

; 1469 : 		return(CMD_bad_value);

  00ae0	b8 02 00 00 00	 mov	 eax, 2
  00ae5	5b		 pop	 ebx

; 1489 : }

  00ae6	83 c4 3c	 add	 esp, 60			; 0000003cH
  00ae9	c3		 ret	 0
_cm_cmd_loadv ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_code_page
_TEXT	SEGMENT
_cm_cmd_code_page PROC NEAR

; 1508 : #ifdef MSDOS    
; 1509 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;
; 1510 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 1511 : 	volatile struct dtpc_code_pages _far *cp;
; 1512 : 	int     i;
; 1513 : 
; 1514 : 	if(pCmd_t->defaults[0] == TRUE || pCmd_t->params[0] == 0)
; 1515 : 	{
; 1516 : 		for(i=0;i<256;i++)
; 1517 : 			pKsd_t->code_page[i] = i;
; 1518 : 		return(CMD_success);
; 1519 : 	}
; 1520 : 
; 1521 : 
; 1522 : 	cp = pKsd_t->loaded_code_pages;
; 1523 : 	while(cp != NULL_CP)
; 1524 : 	{
; 1525 : 		if((*cp).dos_id == (int)pCmd_t->params[0])
; 1526 : 		{
; 1527 : 			for(i=0;i<256;i++)
; 1528 : 				pKsd_t->code_page[i] = (*cp).translation_page[i];
; 1529 : 			return(CMD_success);
; 1530 : 		}
; 1531 : 		cp = (*cp).link;
; 1532 : 	}
; 1533 : #endif /* MSDOS */              
; 1534 : 	return(CMD_bad_value);

  00af0	b8 02 00 00 00	 mov	 eax, 2

; 1535 : }

  00af5	c3		 ret	 0
_cm_cmd_code_page ENDP
_TEXT	ENDS
EXTRN	_StereoVolumeControl:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_cm_cmd_vs PROC NEAR

; 1554 : 	PCMD_T pCmd_t=phTTS->pCMDThreadData;

  00b00	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]

; 1555 : #ifdef MSDOS
; 1556 : 	vol_set(pCmd_t->params[0]);
; 1557 : #else                      
; 1558 : 			StereoVolumeControl( phTTS,
; 1559 : 						 		pCmd_t->params[0],
; 1560 : 						 		VOLUME_SET,
; 1561 : 						 		TRUE,
; 1562 : 						 		TRUE );

  00b04	6a 01		 push	 1
  00b06	6a 01		 push	 1
  00b08	6a 00		 push	 0
  00b0a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00b0d	8b 11		 mov	 edx, DWORD PTR [ecx]
  00b0f	52		 push	 edx
  00b10	50		 push	 eax
  00b11	e8 00 00 00 00	 call	 _StereoVolumeControl
  00b16	83 c4 14	 add	 esp, 20			; 00000014H

; 1563 : #endif
; 1564 : 	return(CMD_success);

  00b19	33 c0		 xor	 eax, eax

; 1565 : }                              

  00b1b	c3		 ret	 0
_cm_cmd_vs ENDP
_TEXT	ENDS
EXTRN	_SetStereoVolume:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_cm_cmd_volume PROC NEAR

; 1587 : {

  00b20	53		 push	 ebx
  00b21	55		 push	 ebp
  00b22	56		 push	 esi

; 1588 : 	int     cmd_type, cmd_value;
; 1589 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00b23	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  00b27	57		 push	 edi
  00b28	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]

; 1590 : 
; 1591 : 	cmd_type = cm_util_string_match(volume_options, pCmd_t->pString[0]);

  00b2b	8b 83 80 02 00
	00		 mov	 eax, DWORD PTR [ebx+640]
  00b31	50		 push	 eax
  00b32	68 00 00 00 00	 push	 OFFSET FLAT:_volume_options
  00b37	e8 00 00 00 00	 call	 _cm_util_string_match
  00b3c	8b e8		 mov	 ebp, eax
  00b3e	83 c4 08	 add	 esp, 8

; 1592 : 	if(cmd_type == NO_STRING_MATCH)

  00b41	81 fd ff ff 00
	00		 cmp	 ebp, 65535		; 0000ffffH
  00b47	75 0a		 jne	 SHORT $L71788
  00b49	5f		 pop	 edi
  00b4a	5e		 pop	 esi
  00b4b	5d		 pop	 ebp

; 1593 : 		return(CMD_bad_string);

  00b4c	b8 01 00 00 00	 mov	 eax, 1
  00b51	5b		 pop	 ebx

; 1700 : }

  00b52	c3		 ret	 0
$L71788:

; 1594 : 	cmd_type += DCS_VOLUME_SET;
; 1595 : 	cmd_value = pCmd_t->params[1];

  00b53	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]

; 1596 : 
; 1597 : 	if( cm_cmd_sync(phTTS) == CMD_flushing )

  00b56	56		 push	 esi
  00b57	e8 00 00 00 00	 call	 _cm_cmd_sync
  00b5c	83 c4 04	 add	 esp, 4
  00b5f	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00b62	75 05		 jne	 SHORT $L71789
  00b64	5f		 pop	 edi
  00b65	5e		 pop	 esi
  00b66	5d		 pop	 ebp
  00b67	5b		 pop	 ebx

; 1700 : }

  00b68	c3		 ret	 0
$L71789:

; 1598 : 		return(CMD_flushing);
; 1599 : 
; 1600 : 	switch(cmd_type)
; 1601 : 	{

  00b69	83 fd 0a	 cmp	 ebp, 10			; 0000000aH
  00b6c	0f 87 fb 00 00
	00		 ja	 $L71805
  00b72	ff 24 ad 00 00
	00 00		 jmp	 DWORD PTR $L72162[ebp*4]
$L71794:

; 1602 : 
; 1603 : 		case    DCS_VOLUME_SET  :
; 1604 : 
; 1605 : 			StereoVolumeControl( phTTS,
; 1606 : 						 cmd_value,
; 1607 : 						 VOLUME_SET,
; 1608 : 						 TRUE,
; 1609 : 						 TRUE );

  00b79	6a 01		 push	 1
  00b7b	6a 01		 push	 1
  00b7d	6a 00		 push	 0
  00b7f	57		 push	 edi
  00b80	56		 push	 esi
  00b81	e8 00 00 00 00	 call	 _StereoVolumeControl
  00b86	83 c4 14	 add	 esp, 20			; 00000014H

; 1698 : 	};
; 1699 : 	return(CMD_success);

  00b89	33 c0		 xor	 eax, eax
  00b8b	5f		 pop	 edi
  00b8c	5e		 pop	 esi
  00b8d	5d		 pop	 ebp
  00b8e	5b		 pop	 ebx

; 1700 : }

  00b8f	c3		 ret	 0
$L71795:

; 1610 : 			break;
; 1611 : 
; 1612 : 		case    DCS_VOLUME_UP   :
; 1613 : 
; 1614 : 			StereoVolumeControl( phTTS,
; 1615 : 						 cmd_value,
; 1616 : 						 VOLUME_UP,
; 1617 : 						 TRUE,
; 1618 : 						 TRUE );

  00b90	6a 01		 push	 1
  00b92	6a 01		 push	 1
  00b94	6a 01		 push	 1
  00b96	57		 push	 edi
  00b97	56		 push	 esi
  00b98	e8 00 00 00 00	 call	 _StereoVolumeControl
  00b9d	83 c4 14	 add	 esp, 20			; 00000014H

; 1698 : 	};
; 1699 : 	return(CMD_success);

  00ba0	33 c0		 xor	 eax, eax
  00ba2	5f		 pop	 edi
  00ba3	5e		 pop	 esi
  00ba4	5d		 pop	 ebp
  00ba5	5b		 pop	 ebx

; 1700 : }

  00ba6	c3		 ret	 0
$L71796:

; 1619 : 			break;
; 1620 : 
; 1621 : 		case    DCS_VOLUME_DOWN :
; 1622 : 
; 1623 : 			StereoVolumeControl( phTTS,
; 1624 : 						 cmd_value,
; 1625 : 						 VOLUME_DOWN,
; 1626 : 						 TRUE,
; 1627 : 						 TRUE );

  00ba7	6a 01		 push	 1
  00ba9	6a 01		 push	 1
  00bab	6a 02		 push	 2
  00bad	57		 push	 edi
  00bae	56		 push	 esi
  00baf	e8 00 00 00 00	 call	 _StereoVolumeControl
  00bb4	83 c4 14	 add	 esp, 20			; 00000014H

; 1698 : 	};
; 1699 : 	return(CMD_success);

  00bb7	33 c0		 xor	 eax, eax
  00bb9	5f		 pop	 edi
  00bba	5e		 pop	 esi
  00bbb	5d		 pop	 ebp
  00bbc	5b		 pop	 ebx

; 1700 : }

  00bbd	c3		 ret	 0
$L71797:

; 1628 : 			break;
; 1629 : 
; 1630 : 		case    DCS_VOLUME_LSET  :
; 1631 : 
; 1632 : 			StereoVolumeControl( phTTS,
; 1633 : 						 cmd_value,
; 1634 : 						 VOLUME_SET,
; 1635 : 						 TRUE,
; 1636 : 						 FALSE );

  00bbe	6a 00		 push	 0
  00bc0	6a 01		 push	 1
  00bc2	6a 00		 push	 0
  00bc4	57		 push	 edi
  00bc5	56		 push	 esi
  00bc6	e8 00 00 00 00	 call	 _StereoVolumeControl
  00bcb	83 c4 14	 add	 esp, 20			; 00000014H

; 1698 : 	};
; 1699 : 	return(CMD_success);

  00bce	33 c0		 xor	 eax, eax
  00bd0	5f		 pop	 edi
  00bd1	5e		 pop	 esi
  00bd2	5d		 pop	 ebp
  00bd3	5b		 pop	 ebx

; 1700 : }

  00bd4	c3		 ret	 0
$L71798:

; 1637 : 			break;
; 1638 : 
; 1639 : 		case    DCS_VOLUME_LUP   :
; 1640 : 
; 1641 : 			StereoVolumeControl( phTTS,
; 1642 : 						 cmd_value,
; 1643 : 						 VOLUME_UP,
; 1644 : 						 TRUE,
; 1645 : 						 FALSE );

  00bd5	6a 00		 push	 0
  00bd7	6a 01		 push	 1
  00bd9	6a 01		 push	 1
  00bdb	57		 push	 edi
  00bdc	56		 push	 esi
  00bdd	e8 00 00 00 00	 call	 _StereoVolumeControl
  00be2	83 c4 14	 add	 esp, 20			; 00000014H

; 1698 : 	};
; 1699 : 	return(CMD_success);

  00be5	33 c0		 xor	 eax, eax
  00be7	5f		 pop	 edi
  00be8	5e		 pop	 esi
  00be9	5d		 pop	 ebp
  00bea	5b		 pop	 ebx

; 1700 : }

  00beb	c3		 ret	 0
$L71799:

; 1646 : 			break;
; 1647 : 
; 1648 : 		case    DCS_VOLUME_LDOWN :
; 1649 : 
; 1650 : 			StereoVolumeControl( phTTS,
; 1651 : 						 cmd_value,
; 1652 : 						 VOLUME_DOWN,
; 1653 : 						 TRUE,
; 1654 : 						 FALSE );

  00bec	6a 00		 push	 0
  00bee	6a 01		 push	 1
  00bf0	6a 02		 push	 2
  00bf2	57		 push	 edi
  00bf3	56		 push	 esi
  00bf4	e8 00 00 00 00	 call	 _StereoVolumeControl
  00bf9	83 c4 14	 add	 esp, 20			; 00000014H

; 1698 : 	};
; 1699 : 	return(CMD_success);

  00bfc	33 c0		 xor	 eax, eax
  00bfe	5f		 pop	 edi
  00bff	5e		 pop	 esi
  00c00	5d		 pop	 ebp
  00c01	5b		 pop	 ebx

; 1700 : }

  00c02	c3		 ret	 0
$L71800:

; 1655 : 			break;
; 1656 : 
; 1657 : 		case    DCS_VOLUME_RSET  :
; 1658 : 
; 1659 : 			StereoVolumeControl( phTTS,
; 1660 : 						 cmd_value,
; 1661 : 						 VOLUME_SET,
; 1662 : 						 FALSE,
; 1663 : 						 TRUE );

  00c03	6a 01		 push	 1
  00c05	6a 00		 push	 0
  00c07	6a 00		 push	 0
  00c09	57		 push	 edi
  00c0a	56		 push	 esi
  00c0b	e8 00 00 00 00	 call	 _StereoVolumeControl
  00c10	83 c4 14	 add	 esp, 20			; 00000014H

; 1698 : 	};
; 1699 : 	return(CMD_success);

  00c13	33 c0		 xor	 eax, eax
  00c15	5f		 pop	 edi
  00c16	5e		 pop	 esi
  00c17	5d		 pop	 ebp
  00c18	5b		 pop	 ebx

; 1700 : }

  00c19	c3		 ret	 0
$L71801:

; 1664 : 			break;
; 1665 : 
; 1666 : 		case    DCS_VOLUME_RUP   :
; 1667 : 
; 1668 : 			StereoVolumeControl( phTTS,
; 1669 : 						 cmd_value,
; 1670 : 						 VOLUME_UP,
; 1671 : 						 FALSE,
; 1672 : 						 TRUE );

  00c1a	6a 01		 push	 1
  00c1c	6a 00		 push	 0
  00c1e	6a 01		 push	 1
  00c20	57		 push	 edi
  00c21	56		 push	 esi
  00c22	e8 00 00 00 00	 call	 _StereoVolumeControl
  00c27	83 c4 14	 add	 esp, 20			; 00000014H

; 1698 : 	};
; 1699 : 	return(CMD_success);

  00c2a	33 c0		 xor	 eax, eax
  00c2c	5f		 pop	 edi
  00c2d	5e		 pop	 esi
  00c2e	5d		 pop	 ebp
  00c2f	5b		 pop	 ebx

; 1700 : }

  00c30	c3		 ret	 0
$L71802:

; 1673 : 			break;
; 1674 : 
; 1675 : 		case    DCS_VOLUME_RDOWN :
; 1676 : 
; 1677 : 			StereoVolumeControl( phTTS,
; 1678 : 						 cmd_value,
; 1679 : 						 VOLUME_DOWN,
; 1680 : 						 FALSE,
; 1681 : 						 TRUE );

  00c31	6a 01		 push	 1
  00c33	6a 00		 push	 0
  00c35	6a 02		 push	 2
  00c37	57		 push	 edi
  00c38	56		 push	 esi
  00c39	e8 00 00 00 00	 call	 _StereoVolumeControl
  00c3e	83 c4 14	 add	 esp, 20			; 00000014H

; 1698 : 	};
; 1699 : 	return(CMD_success);

  00c41	33 c0		 xor	 eax, eax
  00c43	5f		 pop	 edi
  00c44	5e		 pop	 esi
  00c45	5d		 pop	 ebp
  00c46	5b		 pop	 ebx

; 1700 : }

  00c47	c3		 ret	 0
$L71803:

; 1682 : 			break;
; 1683 : 
; 1684 : 		case    DCS_VOLUME_SSET :
; 1685 : 
; 1686 : 			SetStereoVolume( phTTS, cmd_value, pCmd_t->params[2] );

  00c48	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00c4b	51		 push	 ecx
  00c4c	57		 push	 edi
  00c4d	56		 push	 esi
  00c4e	e8 00 00 00 00	 call	 _SetStereoVolume
  00c53	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1698 : 	};
; 1699 : 	return(CMD_success);

  00c56	33 c0		 xor	 eax, eax
  00c58	5f		 pop	 edi
  00c59	5e		 pop	 esi
  00c5a	5d		 pop	 ebp
  00c5b	5b		 pop	 ebx

; 1700 : }

  00c5c	c3		 ret	 0
$L71804:

; 1687 : 
; 1688 : 			break;
; 1689 : 
; 1690 : 		case DCS_VOLUME_ATT:
; 1691 : 
; 1692 : 			phTTS->pKernelShareData->vol_att=cmd_value;

  00c5d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 1698 : 	};
; 1699 : 	return(CMD_success);

  00c60	33 c0		 xor	 eax, eax
  00c62	89 ba e0 03 00
	00		 mov	 DWORD PTR [edx+992], edi
  00c68	5f		 pop	 edi
  00c69	5e		 pop	 esi
  00c6a	5d		 pop	 ebp
  00c6b	5b		 pop	 ebx

; 1700 : }

  00c6c	c3		 ret	 0
$L71805:
  00c6d	5f		 pop	 edi
  00c6e	5e		 pop	 esi
  00c6f	5d		 pop	 ebp

; 1693 : 
; 1694 : 			break;
; 1695 : 
; 1696 : 		default :
; 1697 : 			return(CMD_bad_value);

  00c70	b8 02 00 00 00	 mov	 eax, 2
  00c75	5b		 pop	 ebx

; 1700 : }

  00c76	c3		 ret	 0
  00c77	90		 npad	 1
$L72162:
  00c78	00 00 00 00	 DD	 $L71794
  00c7c	00 00 00 00	 DD	 $L71795
  00c80	00 00 00 00	 DD	 $L71796
  00c84	00 00 00 00	 DD	 $L71797
  00c88	00 00 00 00	 DD	 $L71798
  00c8c	00 00 00 00	 DD	 $L71799
  00c90	00 00 00 00	 DD	 $L71800
  00c94	00 00 00 00	 DD	 $L71801
  00c98	00 00 00 00	 DD	 $L71802
  00c9c	00 00 00 00	 DD	 $L71803
  00ca0	00 00 00 00	 DD	 $L71804
_cm_cmd_volume ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_language
EXTRN	_default_lang:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pipe_value$ = 8
_cm_cmd_language PROC NEAR

; 1780 : {   

  00cb0	53		 push	 ebx

; 1781 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00cb1	8b 5c 24 08	 mov	 ebx, DWORD PTR _phTTS$[esp]
  00cb5	56		 push	 esi
  00cb6	57		 push	 edi

; 1782 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00cb7	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00cba	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]

; 1783 : 	
; 1784 : 	int     cmd_type;
; 1785 : 	DT_PIPE_T pipe_value;
; 1786 : 
; 1787 : 	if(pCmd_t->esc_command == FALSE)

  00cbd	8b 88 18 05 00
	00		 mov	 ecx, DWORD PTR [eax+1304]
  00cc3	85 c9		 test	 ecx, ecx
  00cc5	75 27		 jne	 SHORT $L71813

; 1788 : 	{
; 1789 : 		cmd_type = cm_util_string_match(lang_options,pCmd_t->pString[0]);

  00cc7	8b 80 80 02 00
	00		 mov	 eax, DWORD PTR [eax+640]
  00ccd	50		 push	 eax
  00cce	68 00 00 00 00	 push	 OFFSET FLAT:_lang_options
  00cd3	e8 00 00 00 00	 call	 _cm_util_string_match
  00cd8	8b f8		 mov	 edi, eax
  00cda	83 c4 08	 add	 esp, 8

; 1790 : 		if(cmd_type == NO_STRING_MATCH)

  00cdd	81 ff ff ff 00
	00		 cmp	 edi, 65535		; 0000ffffH
  00ce3	75 0b		 jne	 SHORT $L71815
  00ce5	5f		 pop	 edi
  00ce6	5e		 pop	 esi

; 1791 : 			return(CMD_bad_string);

  00ce7	b8 01 00 00 00	 mov	 eax, 1
  00cec	5b		 pop	 ebx

; 1872 : }

  00ced	c3		 ret	 0
$L71813:

; 1792 : 	}
; 1793 : 	else
; 1794 : 		cmd_type = pCmd_t->params[0];

  00cee	8b 38		 mov	 edi, DWORD PTR [eax]
$L71815:

; 1795 : 				  
; 1796 : 	if(cm_cmd_sync(phTTS) == CMD_flushing)

  00cf0	53		 push	 ebx
  00cf1	e8 00 00 00 00	 call	 _cm_cmd_sync
  00cf6	83 c4 04	 add	 esp, 4
  00cf9	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00cfc	75 04		 jne	 SHORT $L71816
  00cfe	5f		 pop	 edi
  00cff	5e		 pop	 esi
  00d00	5b		 pop	 ebx

; 1872 : }

  00d01	c3		 ret	 0
$L71816:

; 1797 : 		return(CMD_flushing);
; 1798 : 	switch(cmd_type)
; 1799 : 	{

  00d02	83 ff 0b	 cmp	 edi, 11			; 0000000bH
  00d05	0f 87 aa 00 00
	00		 ja	 $L71822
  00d0b	ff 24 bd 00 00
	00 00		 jmp	 DWORD PTR $L72164[edi*4]
$L71821:

; 1800 : 
; 1801 : 		/* GL 03/27/1997 for BATS#317 add "us" option */
; 1802 : 		/* GL 012/02/1998 for BATS#751 add more language option */
; 1803 : 		case    0       :                               /* english */
; 1804 : 		case    6       :                               /* us */
; 1805 : 
; 1806 : 			if(pKsd_t->lang_ready[LANG_english] == LANG_both_ready)

  00d12	83 be bc 02 00
	00 07		 cmp	 DWORD PTR [esi+700], 7
  00d19	0f 85 96 00 00
	00		 jne	 $L71822

; 1807 : 				cmd_type = LANG_english;

  00d1f	33 ff		 xor	 edi, edi

; 1808 : 			else
; 1809 : 				return(CMD_bad_value);
; 1810 : 			break;

  00d21	eb 52		 jmp	 SHORT $L71838
$L71824:

; 1811 : 
; 1812 : 		case    1       :                               /* british */
; 1813 : 		case    7       :                               /* uk */
; 1814 : 
; 1815 : 			if(pKsd_t->lang_ready[LANG_british] == LANG_both_ready)

  00d23	83 be d0 02 00
	00 07		 cmp	 DWORD PTR [esi+720], 7
  00d2a	0f 85 85 00 00
	00		 jne	 $L71822

; 1816 : 				cmd_type = LANG_british;

  00d30	bf 05 00 00 00	 mov	 edi, 5

; 1817 : 			else
; 1818 : 				return(CMD_bad_value);
; 1819 : 			break;

  00d35	eb 3e		 jmp	 SHORT $L71838
$L71827:

; 1820 : 
; 1821 : 		case    2       :                               /* french */
; 1822 : 		case    8       :                               /* fr */
; 1823 : 
; 1824 : 			if(pKsd_t->lang_ready[LANG_french] == LANG_both_ready)

  00d37	83 be c0 02 00
	00 07		 cmp	 DWORD PTR [esi+704], 7
  00d3e	75 75		 jne	 SHORT $L71822

; 1825 : 				cmd_type = LANG_french;

  00d40	bf 01 00 00 00	 mov	 edi, 1

; 1826 : 			else
; 1827 : 				return(CMD_bad_value);
; 1828 : 			break;

  00d45	eb 2e		 jmp	 SHORT $L71838
$L71830:

; 1829 : 
; 1830 : 
; 1831 : 		case    3       :                               /* german */
; 1832 : 		case    9       :                               /* gr */
; 1833 : 
; 1834 : 			if(pKsd_t->lang_ready[LANG_german] == LANG_both_ready)

  00d47	83 be c4 02 00
	00 07		 cmp	 DWORD PTR [esi+708], 7
  00d4e	75 65		 jne	 SHORT $L71822

; 1835 : 				cmd_type = LANG_german;

  00d50	bf 02 00 00 00	 mov	 edi, 2

; 1836 : 			else
; 1837 : 				return(CMD_bad_value);
; 1838 : 			break;

  00d55	eb 1e		 jmp	 SHORT $L71838
$L71833:

; 1839 : 
; 1840 : 		case    4       :                               /* spanish */
; 1841 : 		case    10       :                               /* sp */
; 1842 : 
; 1843 : 			if(pKsd_t->lang_ready[LANG_spanish] == LANG_both_ready)

  00d57	83 be c8 02 00
	00 07		 cmp	 DWORD PTR [esi+712], 7
  00d5e	75 55		 jne	 SHORT $L71822

; 1844 : 				cmd_type = LANG_spanish;

  00d60	bf 03 00 00 00	 mov	 edi, 3

; 1845 : 			else
; 1846 : 				return(CMD_bad_value);
; 1847 : 			break;

  00d65	eb 0e		 jmp	 SHORT $L71838
$L71836:

; 1848 : 
; 1849 : 		case    5       :                               /* latin american */
; 1850 : 		case    11       :                               /* la */
; 1851 : 
; 1852 : 			if(pKsd_t->lang_ready[LANG_latin_american] == LANG_both_ready)

  00d67	83 be d4 02 00
	00 07		 cmp	 DWORD PTR [esi+724], 7
  00d6e	75 45		 jne	 SHORT $L71822

; 1853 : 				cmd_type = LANG_latin_american;

  00d70	bf 06 00 00 00	 mov	 edi, 6
$L71838:

; 1860 : 	};
; 1861 : 
; 1862 : 	if(cm_cmd_sync(phTTS) == CMD_flushing)

  00d75	53		 push	 ebx
  00d76	e8 00 00 00 00	 call	 _cm_cmd_sync
  00d7b	83 c4 04	 add	 esp, 4
  00d7e	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00d81	75 04		 jne	 SHORT $L71840
  00d83	5f		 pop	 edi
  00d84	5e		 pop	 esi
  00d85	5b		 pop	 ebx

; 1872 : }

  00d86	c3		 ret	 0
$L71840:

; 1863 : 		return(CMD_flushing);
; 1864 : #ifdef MSDOS    
; 1865 : 	default_lang(cmd_type,0);
; 1866 : #else
; 1867 : 	default_lang(pKsd_t,cmd_type,0);

  00d87	6a 00		 push	 0
  00d89	57		 push	 edi
  00d8a	56		 push	 esi
  00d8b	e8 00 00 00 00	 call	 _default_lang

; 1868 : #endif
; 1869 : 	pipe_value = LAST_VOICE;

  00d90	c7 44 24 1c 03
	1f 00 00	 mov	 DWORD PTR _pipe_value$[esp+20], 7939 ; 00001f03H

; 1870 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,&pipe_value,1);

  00d98	8b 96 90 02 00
	00		 mov	 edx, DWORD PTR [esi+656]
  00d9e	8d 4c 24 1c	 lea	 ecx, DWORD PTR _pipe_value$[esp+20]
  00da2	6a 01		 push	 1
  00da4	51		 push	 ecx
  00da5	52		 push	 edx
  00da6	56		 push	 esi
  00da7	e8 00 00 00 00	 call	 _cm_util_write_pipe
  00dac	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1871 : 	return(CMD_success);

  00daf	33 c0		 xor	 eax, eax
  00db1	5f		 pop	 edi
  00db2	5e		 pop	 esi
  00db3	5b		 pop	 ebx

; 1872 : }

  00db4	c3		 ret	 0
$L71822:
  00db5	5f		 pop	 edi
  00db6	5e		 pop	 esi

; 1854 : 			else
; 1855 : 				return(CMD_bad_value);
; 1856 : 			break;
; 1857 : 
; 1858 : 		default :
; 1859 : 			return(CMD_bad_value);

  00db7	b8 02 00 00 00	 mov	 eax, 2
  00dbc	5b		 pop	 ebx

; 1872 : }

  00dbd	c3		 ret	 0
  00dbe	8b ff		 npad	 2
$L72164:
  00dc0	00 00 00 00	 DD	 $L71821
  00dc4	00 00 00 00	 DD	 $L71824
  00dc8	00 00 00 00	 DD	 $L71827
  00dcc	00 00 00 00	 DD	 $L71830
  00dd0	00 00 00 00	 DD	 $L71833
  00dd4	00 00 00 00	 DD	 $L71836
  00dd8	00 00 00 00	 DD	 $L71821
  00ddc	00 00 00 00	 DD	 $L71824
  00de0	00 00 00 00	 DD	 $L71827
  00de4	00 00 00 00	 DD	 $L71830
  00de8	00 00 00 00	 DD	 $L71833
  00dec	00 00 00 00	 DD	 $L71836
_cm_cmd_language ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_remove
_TEXT	SEGMENT
_pKsd_t$ = 8
_pipe_value$ = 8
_cm_cmd_remove PROC NEAR

; 1887 : {

  00df0	56		 push	 esi

; 1888 : 	DT_PIPE_T pipe_value;
; 1889 : 
; 1890 : #ifdef MSDOS
; 1891 : 	pKsd_t->lang_ready[pKsd_t->lang_curr] = 0;
; 1892 : #else
; 1893 : 	pKsd_t->lang_ready[LANG_english] = 0;

  00df1	8b 74 24 08	 mov	 esi, DWORD PTR _pKsd_t$[esp]

; 1894 : #endif
; 1895 : 	pipe_value = KILL_TASK;
; 1896 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,&pipe_value,1);

  00df5	8d 44 24 08	 lea	 eax, DWORD PTR _pipe_value$[esp]
  00df9	6a 01		 push	 1
  00dfb	8b 8e 90 02 00
	00		 mov	 ecx, DWORD PTR [esi+656]
  00e01	50		 push	 eax
  00e02	51		 push	 ecx
  00e03	56		 push	 esi
  00e04	c7 86 bc 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+700], 0
  00e0e	c7 44 24 18 0c
	1f 00 00	 mov	 DWORD PTR _pipe_value$[esp+16], 7948 ; 00001f0cH
  00e16	e8 00 00 00 00	 call	 _cm_util_write_pipe
  00e1b	83 c4 10	 add	 esp, 16			; 00000010H

; 1897 : 	pKsd_t->lts_pipe = NULL_PIPE;

  00e1e	c7 86 90 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+656], 0

; 1898 : 	pKsd_t->ph_pipe = NULL_PIPE;

  00e28	c7 86 94 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+660], 0

; 1899 : 	return(CMD_success);

  00e32	33 c0		 xor	 eax, eax
  00e34	5e		 pop	 esi

; 1900 : }

  00e35	c3		 ret	 0
_cm_cmd_remove ENDP
_phTTS$ = 8
_pipe_value$ = -8
_cm_cmd_mode PROC NEAR

; 2205 : {

  00e40	83 ec 08	 sub	 esp, 8

; 2206 : 	unsigned int    i, value;
; 2207 : 	DT_PIPE_T pipe_value[3];
; 2208 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00e43	8b 44 24 0c	 mov	 eax, DWORD PTR _phTTS$[esp+4]
  00e47	53		 push	 ebx
  00e48	55		 push	 ebp

; 2209 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 2210 : 
; 2211 : 	pipe_value[0] = (2<<PSNEXTRA)+LTS_SYNC;
; 2212 : 	pipe_value[1] = 0;

  00e49	33 ed		 xor	 ebp, ebp
  00e4b	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]
  00e4e	56		 push	 esi
  00e4f	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00e52	66 c7 44 24 0c
	04 5f		 mov	 WORD PTR _pipe_value$[esp+20], 24324 ; 00005f04H
  00e59	66 89 6c 24 0e	 mov	 WORD PTR _pipe_value$[esp+22], bp

; 2213 : 	pipe_value[2] = 0;

  00e5e	66 89 6c 24 10	 mov	 WORD PTR _pipe_value$[esp+24], bp

; 2214 : 	for(i=0; i < pCmd_t->param_index; i++)

  00e63	8b 83 d0 02 00
	00		 mov	 eax, DWORD PTR [ebx+720]
  00e69	57		 push	 edi
  00e6a	33 ff		 xor	 edi, edi
  00e6c	3b c5		 cmp	 eax, ebp
  00e6e	0f 86 ed 00 00
	00		 jbe	 $L71857
$L71855:

; 2215 : 	{
; 2216 : 		value = cm_util_string_match(mode_options,(unsigned char *)pCmd_t->pString[i]);

  00e74	8b 84 bb 80 02
	00 00		 mov	 eax, DWORD PTR [ebx+edi*4+640]
  00e7b	50		 push	 eax
  00e7c	68 00 00 00 00	 push	 OFFSET FLAT:_mode_options
  00e81	e8 00 00 00 00	 call	 _cm_util_string_match
  00e86	83 c4 08	 add	 esp, 8

; 2217 : 		if(value == NO_STRING_MATCH)

  00e89	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00e8e	0f 84 d7 00 00
	00		 je	 $L72168

; 2220 : 		}       
; 2221 : 		/*
; 2222 : 		 * 3/6/96 SIK This command only takes 2 parameters:  MATH, EUROPE, SPELL, NAME, 
; 2223 : 		 * HOMOGRAPH, CITATION or LATIN followed by ON, OFF or SET 
; 2224 : 		 */
; 2225 : 		switch(i)
; 2226 : 		{         

  00e94	8b cf		 mov	 ecx, edi
  00e96	2b cd		 sub	 ecx, ebp
  00e98	74 6f		 je	 SHORT $L71864
  00e9a	49		 dec	 ecx
  00e9b	0f 85 d7 00 00
	00		 jne	 $L71887

; 2256 : 						break;
; 2257 : 					default:
; 2258 : 						return(CMD_bad_param);
; 2259 : 				}
; 2260 : 				break;
; 2261 : 			case 1:    /* Second param */
; 2262 : 				switch(value)
; 2263 : 				{               

  00ea1	83 e8 09	 sub	 eax, 9
  00ea4	74 38		 je	 SHORT $L71884
  00ea6	48		 dec	 eax
  00ea7	74 1e		 je	 SHORT $L71885
  00ea9	48		 dec	 eax
  00eaa	0f 85 c8 00 00
	00		 jne	 $L71887

; 2272 : 					case 11:                         /* set */
; 2273 : 						pipe_value[1] = LTS_MODE_ABS;

  00eb0	66 c7 44 24 12
	02 00		 mov	 WORD PTR _pipe_value$[esp+26], 2

; 2274 :                         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,3);

  00eb7	8b 96 90 02 00
	00		 mov	 edx, DWORD PTR [esi+656]
  00ebd	8d 4c 24 10	 lea	 ecx, DWORD PTR _pipe_value$[esp+24]
  00ec1	6a 03		 push	 3
  00ec3	51		 push	 ecx
  00ec4	52		 push	 edx

; 2275 : 						break;

  00ec5	eb 2a		 jmp	 SHORT $L72173
$L71885:

; 2267 : 						break;
; 2268 : 					case 10:                         /* off */
; 2269 : 						pipe_value[1] = LTS_MODE_CLEAR;

  00ec7	66 c7 44 24 12
	01 00		 mov	 WORD PTR _pipe_value$[esp+26], 1

; 2270 :                         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,3);

  00ece	8b 8e 90 02 00
	00		 mov	 ecx, DWORD PTR [esi+656]
  00ed4	8d 44 24 10	 lea	 eax, DWORD PTR _pipe_value$[esp+24]
  00ed8	6a 03		 push	 3
  00eda	50		 push	 eax
  00edb	51		 push	 ecx

; 2271 : 						break;

  00edc	eb 13		 jmp	 SHORT $L72173
$L71884:

; 2264 : 					case 9:                         /* on */
; 2265 : 						pipe_value[1] = LTS_MODE_SET;

  00ede	66 89 6c 24 12	 mov	 WORD PTR _pipe_value$[esp+26], bp

; 2266 :                         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,3);

  00ee3	8b 86 90 02 00
	00		 mov	 eax, DWORD PTR [esi+656]
  00ee9	8d 54 24 10	 lea	 edx, DWORD PTR _pipe_value$[esp+24]
  00eed	6a 03		 push	 3
  00eef	52		 push	 edx
  00ef0	50		 push	 eax
$L72173:
  00ef1	56		 push	 esi
  00ef2	e8 00 00 00 00	 call	 _cm_util_write_pipe

; 2276 : 					default:
; 2277 : 						return(CMD_bad_param);    
; 2278 : 				}
; 2279 : 				/* 
; 2280 : 				   GL 01/28/1997, force SYNC here to fix the race condition in
; 2281 : 				   DECtalk software
; 2282 : 				*/
; 2283 : 				cm_cmd_sync(phTTS);

  00ef7	8b 4c 24 2c	 mov	 ecx, DWORD PTR _phTTS$[esp+36]
  00efb	83 c4 10	 add	 esp, 16			; 00000010H
  00efe	51		 push	 ecx
  00eff	e8 00 00 00 00	 call	 _cm_cmd_sync
  00f04	83 c4 04	 add	 esp, 4

; 2284 : 				break;

  00f07	eb 49		 jmp	 SHORT $L71856
$L71864:

; 2227 : 			case 0:    /* First param */
; 2228 : 				switch(value)
; 2229 : 				{                               

  00f09	83 f8 08	 cmp	 eax, 8
  00f0c	77 6a		 ja	 SHORT $L71887
  00f0e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72174[eax*4]
$L71869:

; 2230 : 					case 0: /* minus */
; 2231 : 						pipe_value[2] |= MODE_MATH;  

  00f15	80 4c 24 14 04	 or	 BYTE PTR _pipe_value$[esp+28], 4

; 2232 : 						break;

  00f1a	eb 36		 jmp	 SHORT $L71856
$L71870:

; 2233 : 					case 1: /* europe */
; 2234 : 						pipe_value[2] |= MODE_EUROPE; 

  00f1c	80 4c 24 14 08	 or	 BYTE PTR _pipe_value$[esp+28], 8

; 2235 : 						break;

  00f21	eb 2f		 jmp	 SHORT $L71856
$L71871:

; 2236 : 					case 2: /* spell */
; 2237 : 						pipe_value[2] |= MODE_SPELL;       

  00f23	80 4c 24 14 10	 or	 BYTE PTR _pipe_value$[esp+28], 16 ; 00000010H

; 2238 : 						break;

  00f28	eb 28		 jmp	 SHORT $L71856
$L71872:

; 2239 : 					case 3: /* name determination */
; 2240 : 						pipe_value[2] |= MODE_NAME;       

  00f2a	80 4c 24 14 40	 or	 BYTE PTR _pipe_value$[esp+28], 64 ; 00000040H

; 2241 : 						break;

  00f2f	eb 21		 jmp	 SHORT $L71856
$L71873:

; 2242 : 					case 4: /* homograph determination */
; 2243 : 						pipe_value[2] |= MODE_HOMOGRAPH;

  00f31	80 4c 24 14 80	 or	 BYTE PTR _pipe_value$[esp+28], -128 ; ffffff80H

; 2244 : 						break;

  00f36	eb 1a		 jmp	 SHORT $L71856
$L71874:

; 2245 : 					case 5: /* citation mode */
; 2246 : 						pipe_value[2] |= MODE_CITATION;

  00f38	80 4c 24 15 01	 or	 BYTE PTR _pipe_value$[esp+29], 1

; 2247 : 						break;

  00f3d	eb 13		 jmp	 SHORT $L71856
$L71875:

; 2248 : 					case 6: /* latin mode */
; 2249 : 						pipe_value[2] |= MODE_LATIN;

  00f3f	80 4c 24 15 02	 or	 BYTE PTR _pipe_value$[esp+29], 2

; 2250 :                         break;

  00f44	eb 0c		 jmp	 SHORT $L71856
$L71876:

; 2251 : 					case 7: /* table reading mode */
; 2252 : 						pipe_value[2] |= MODE_TABLE;

  00f46	80 4c 24 15 04	 or	 BYTE PTR _pipe_value$[esp+29], 4

; 2253 : 						break;

  00f4b	eb 05		 jmp	 SHORT $L71856
$L71877:

; 2254 : 					case 8: /* email reading mode */
; 2255 : 						pipe_value[2] |= MODE_EMAIL;

  00f4d	80 4c 24 15 10	 or	 BYTE PTR _pipe_value$[esp+29], 16 ; 00000010H
$L71856:

; 2214 : 	for(i=0; i < pCmd_t->param_index; i++)

  00f52	8b 83 d0 02 00
	00		 mov	 eax, DWORD PTR [ebx+720]
  00f58	47		 inc	 edi
  00f59	3b f8		 cmp	 edi, eax
  00f5b	0f 82 13 ff ff
	ff		 jb	 $L71855
$L71857:
  00f61	5f		 pop	 edi
  00f62	5e		 pop	 esi
  00f63	5d		 pop	 ebp

; 2287 : 			}  /* Matches switch(i) */
; 2288 : 		}       /* Matches for(i=0; i < pCmd_t->param_index; i++) */
; 2289 : 	return(CMD_success);

  00f64	33 c0		 xor	 eax, eax
  00f66	5b		 pop	 ebx

; 2290 : }

  00f67	83 c4 08	 add	 esp, 8
  00f6a	c3		 ret	 0
$L72168:
  00f6b	5f		 pop	 edi
  00f6c	5e		 pop	 esi
  00f6d	5d		 pop	 ebp

; 2218 : 		{
; 2219 : 			return(CMD_bad_string);

  00f6e	b8 01 00 00 00	 mov	 eax, 1
  00f73	5b		 pop	 ebx

; 2290 : }

  00f74	83 c4 08	 add	 esp, 8
  00f77	c3		 ret	 0
$L71887:
  00f78	5f		 pop	 edi
  00f79	5e		 pop	 esi
  00f7a	5d		 pop	 ebp

; 2285 : 			default:
; 2286 : 				return(CMD_bad_param);

  00f7b	b8 04 00 00 00	 mov	 eax, 4
  00f80	5b		 pop	 ebx

; 2290 : }

  00f81	83 c4 08	 add	 esp, 8
  00f84	c3		 ret	 0
  00f85	8d 49 00	 npad	 3
$L72174:
  00f88	00 00 00 00	 DD	 $L71869
  00f8c	00 00 00 00	 DD	 $L71870
  00f90	00 00 00 00	 DD	 $L71871
  00f94	00 00 00 00	 DD	 $L71872
  00f98	00 00 00 00	 DD	 $L71873
  00f9c	00 00 00 00	 DD	 $L71874
  00fa0	00 00 00 00	 DD	 $L71875
  00fa4	00 00 00 00	 DD	 $L71876
  00fa8	00 00 00 00	 DD	 $L71877
_cm_cmd_mode ENDP
_phTTS$ = 8
_pipe_value$ = 8
_cm_cmd_pronounce PROC NEAR

; 2308 : 	unsigned int i, value;
; 2309 : 	DT_PIPE_T pipe_value[2];
; 2310 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00fb0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00fb4	53		 push	 ebx
  00fb5	55		 push	 ebp
  00fb6	56		 push	 esi

; 2311 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00fb7	8b 68 0c	 mov	 ebp, DWORD PTR [eax+12]
  00fba	57		 push	 edi
  00fbb	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 2312 : 
; 2313 : 	pipe_value[0] = (1<<PSNEXTRA)+LTS_SYNC;

  00fbe	66 c7 44 24 14
	04 3f		 mov	 WORD PTR _pipe_value$[esp+12], 16132 ; 00003f04H

; 2314 : 	for(i=0;i<pCmd_t->param_index;i++)

  00fc5	8b 85 d0 02 00
	00		 mov	 eax, DWORD PTR [ebp+720]
  00fcb	33 f6		 xor	 esi, esi
  00fcd	85 c0		 test	 eax, eax
  00fcf	0f 86 9c 00 00
	00		 jbe	 $L71899

; 2308 : 	unsigned int i, value;
; 2309 : 	DT_PIPE_T pipe_value[2];
; 2310 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00fd5	8d 9d 80 02 00
	00		 lea	 ebx, DWORD PTR [ebp+640]
$L71897:

; 2315 : 	{
; 2316 : 		value = cm_util_string_match(pronounce_options, (unsigned char *)pCmd_t->pString[i]);

  00fdb	8b 03		 mov	 eax, DWORD PTR [ebx]
  00fdd	50		 push	 eax
  00fde	68 00 00 00 00	 push	 OFFSET FLAT:_pronounce_options
  00fe3	e8 00 00 00 00	 call	 _cm_util_string_match
  00fe8	83 c4 08	 add	 esp, 8

; 2317 : 		if(value == NO_STRING_MATCH)

  00feb	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00ff0	0f 84 82 00 00
	00		 je	 $L72177

; 2319 : 		switch(value)
; 2320 : 		{

  00ff6	83 f8 07	 cmp	 eax, 7
  00ff9	77 4d		 ja	 SHORT $L71903
  00ffb	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72179[eax*4]
$L71906:

; 2321 : 			case    0       :                               /* alternate */
; 2322 : 
; 2323 : 				pipe_value[1] = LTS_DIC_ALTERNATE;

  01002	66 c7 44 24 16
	03 00		 mov	 WORD PTR _pipe_value$[esp+14], 3

; 2324 : 				break;

  01009	eb 3d		 jmp	 SHORT $L71903
$L71907:

; 2325 : 
; 2326 : 			case    1       :                               /* acna name */
; 2327 : 
; 2328 : 				pipe_value[1] = LTS_ACNA_NAME;

  0100b	66 c7 44 24 16
	04 00		 mov	 WORD PTR _pipe_value$[esp+14], 4

; 2329 : 				break;

  01012	eb 34		 jmp	 SHORT $L71903
$L71908:

; 2330 : 
; 2331 : 			case    2       :                               /* primary */
; 2332 : 
; 2333 : 				pipe_value[1] = LTS_DIC_PRIMARY;

  01014	66 c7 44 24 16
	05 00		 mov	 WORD PTR _pipe_value$[esp+14], 5

; 2334 : 				break;

  0101b	eb 2b		 jmp	 SHORT $L71903
$L71909:

; 2335 : 
; 2336 : 			case    3       :                               /* noun */
; 2337 : 
; 2338 : 				pipe_value[1] = LTS_DIC_NOUN;

  0101d	66 c7 44 24 16
	06 00		 mov	 WORD PTR _pipe_value$[esp+14], 6

; 2339 : 				break;

  01024	eb 22		 jmp	 SHORT $L71903
$L71910:

; 2340 : 
; 2341 : 			case    4       :                               /* verb */
; 2342 : 
; 2343 : 				pipe_value[1] = LTS_DIC_VERB;

  01026	66 c7 44 24 16
	07 00		 mov	 WORD PTR _pipe_value$[esp+14], 7

; 2344 : 				break;

  0102d	eb 19		 jmp	 SHORT $L71903
$L71911:

; 2345 : 
; 2346 : 			case    5       :                               /* adjective */
; 2347 : 
; 2348 : 				pipe_value[1] = LTS_DIC_ADJECTIVE;

  0102f	66 c7 44 24 16
	08 00		 mov	 WORD PTR _pipe_value$[esp+14], 8

; 2349 : 				break;

  01036	eb 10		 jmp	 SHORT $L71903
$L71912:

; 2350 : 
; 2351 : 			case    6       :                               /* function */
; 2352 : 
; 2353 : 				pipe_value[1] = LTS_DIC_FUNCTION;

  01038	66 c7 44 24 16
	09 00		 mov	 WORD PTR _pipe_value$[esp+14], 9

; 2354 : 				break;

  0103f	eb 07		 jmp	 SHORT $L71903
$L71913:

; 2355 : 
; 2356 : 			case    7       :                               /* interjection */
; 2357 : 
; 2358 : 				pipe_value[1] = LTS_DIC_INTERJECTION;

  01041	66 c7 44 24 16
	0a 00		 mov	 WORD PTR _pipe_value$[esp+14], 10 ; 0000000aH
$L71903:

; 2359 : 				break;
; 2360 : 		}
; 2361 :                 cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,2);

  01048	8b 97 90 02 00
	00		 mov	 edx, DWORD PTR [edi+656]
  0104e	8d 4c 24 14	 lea	 ecx, DWORD PTR _pipe_value$[esp+12]
  01052	6a 02		 push	 2
  01054	51		 push	 ecx
  01055	52		 push	 edx
  01056	57		 push	 edi
  01057	e8 00 00 00 00	 call	 _cm_util_write_pipe
  0105c	8b 85 d0 02 00
	00		 mov	 eax, DWORD PTR [ebp+720]
  01062	83 c4 10	 add	 esp, 16			; 00000010H
  01065	46		 inc	 esi
  01066	83 c3 04	 add	 ebx, 4
  01069	3b f0		 cmp	 esi, eax
  0106b	0f 82 6a ff ff
	ff		 jb	 $L71897
$L71899:
  01071	5f		 pop	 edi
  01072	5e		 pop	 esi
  01073	5d		 pop	 ebp

; 2362 : 	}
; 2363 : 	return(CMD_success);

  01074	33 c0		 xor	 eax, eax
  01076	5b		 pop	 ebx

; 2364 : }

  01077	c3		 ret	 0
$L72177:
  01078	5f		 pop	 edi
  01079	5e		 pop	 esi
  0107a	5d		 pop	 ebp

; 2318 : 			return(CMD_bad_string);

  0107b	b8 01 00 00 00	 mov	 eax, 1
  01080	5b		 pop	 ebx

; 2364 : }

  01081	c3		 ret	 0
  01082	8b ff		 npad	 2
$L72179:
  01084	00 00 00 00	 DD	 $L71906
  01088	00 00 00 00	 DD	 $L71907
  0108c	00 00 00 00	 DD	 $L71908
  01090	00 00 00 00	 DD	 $L71909
  01094	00 00 00 00	 DD	 $L71910
  01098	00 00 00 00	 DD	 $L71911
  0109c	00 00 00 00	 DD	 $L71912
  010a0	00 00 00 00	 DD	 $L71913
_cm_cmd_pronounce ENDP
_phTTS$ = 8
_pipe_value$ = 8
_cm_cmd_rate PROC NEAR

; 2382 : 	DT_PIPE_T pipe_value[2];
; 2383 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  010b0	8b 4c 24 04	 mov	 ecx, DWORD PTR _phTTS$[esp-4]

; 2384 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 2385 : #ifdef SAPI5DECTALK
; 2386 : 	int sapi_realtime_rate;
; 2387 : 	
; 2388 : 	sapi_realtime_rate=GetSapiRealtimeRate(phTTS);
; 2389 : 	pCmd_t->params[0]+=sapi_realtime_rate;
; 2390 : #endif
; 2391 : 	
; 2392 : 	pipe_value[0] = (1<<PSNEXTRA) + RATE;

  010b4	66 c7 44 24 04
	00 3f		 mov	 WORD PTR _pipe_value$[esp-4], 16128 ; 00003f00H

; 2393 : 	pipe_value[1] = pCmd_t->params[0];
; 2394 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,2);

  010bb	6a 02		 push	 2
  010bd	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  010c0	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  010c3	66 8b 11	 mov	 dx, WORD PTR [ecx]
  010c6	8d 4c 24 08	 lea	 ecx, DWORD PTR _pipe_value$[esp]
  010ca	66 89 54 24 0a	 mov	 WORD PTR _pipe_value$[esp+2], dx
  010cf	8b 90 90 02 00
	00		 mov	 edx, DWORD PTR [eax+656]
  010d5	51		 push	 ecx
  010d6	52		 push	 edx
  010d7	50		 push	 eax
  010d8	e8 00 00 00 00	 call	 _cm_util_write_pipe
  010dd	83 c4 10	 add	 esp, 16			; 00000010H

; 2395 : 	return(CMD_success);

  010e0	33 c0		 xor	 eax, eax

; 2396 : 
; 2397 : }

  010e2	c3		 ret	 0
_cm_cmd_rate ENDP
_phTTS$ = 8
_pipe_value$ = 8
_cm_cmd_name PROC NEAR

; 2414 : 	DT_PIPE_T pipe_value[2];
; 2415 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  010f0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  010f4	56		 push	 esi

; 2416 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  010f5	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  010f8	8b 70 08	 mov	 esi, DWORD PTR [eax+8]

; 2417 : 
; 2418 : 	if(CT[pCmd_t->cmd_index].esc_value == DCS_NAME)

  010fb	8b 81 f4 02 00
	00		 mov	 eax, DWORD PTR [ecx+756]
  01101	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  01104	81 3c 85 0c 00
	00 00 c9 00 00
	00		 cmp	 DWORD PTR _command_table[eax*4+12], 201 ; 000000c9H
  0110f	75 16		 jne	 SHORT $L71926

; 2419 : 	{
; 2420 : 		pipe_value[1] = cm_util_string_match(voice_names,pCmd_t->pString[0]);

  01111	8b 81 80 02 00
	00		 mov	 eax, DWORD PTR [ecx+640]
  01117	50		 push	 eax
  01118	68 00 00 00 00	 push	 OFFSET FLAT:_voice_names
  0111d	e8 00 00 00 00	 call	 _cm_util_string_match
  01122	83 c4 08	 add	 esp, 8

; 2421 : 	}
; 2422 : 	else

  01125	eb 0d		 jmp	 SHORT $L72182
$L71926:

; 2423 : 	{
; 2424 : 		pipe_value[1] = CT[pCmd_t->cmd_index].esc_value & ESCAPE_CODE;

  01127	66 8b 04 85 0c
	00 00 00	 mov	 ax, WORD PTR _command_table[eax*4+12]
  0112f	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
$L72182:

; 2425 : 	}	
; 2426 : 	if((pipe_value[1] >= 0) && (pipe_value[1] < MAX_VOICES))

  01134	66 3d 0a 00	 cmp	 ax, 10			; 0000000aH
  01138	66 89 44 24 0a	 mov	 WORD PTR _pipe_value$[esp+2], ax
  0113d	73 22		 jae	 SHORT $L71928

; 2427 : 	{
; 2428 : 		pipe_value[0] = (1<<PSNEXTRA) + NEW_SPEAKER;

  0113f	66 c7 44 24 08
	05 3f		 mov	 WORD PTR _pipe_value$[esp], 16133 ; 00003f05H

; 2429 :                 cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,2);

  01146	8b 96 90 02 00
	00		 mov	 edx, DWORD PTR [esi+656]
  0114c	8d 4c 24 08	 lea	 ecx, DWORD PTR _pipe_value$[esp]
  01150	6a 02		 push	 2
  01152	51		 push	 ecx
  01153	52		 push	 edx
  01154	56		 push	 esi
  01155	e8 00 00 00 00	 call	 _cm_util_write_pipe
  0115a	83 c4 10	 add	 esp, 16			; 00000010H

; 2430 : 		return(CMD_success);

  0115d	33 c0		 xor	 eax, eax
  0115f	5e		 pop	 esi

; 2433 : }

  01160	c3		 ret	 0
$L71928:

; 2431 : 	}
; 2432 : 	return(CMD_bad_string);

  01161	b8 01 00 00 00	 mov	 eax, 1
  01166	5e		 pop	 esi

; 2433 : }

  01167	c3		 ret	 0
_cm_cmd_name ENDP
_phTTS$ = 8
_pipe_value$ = 8
_cm_cmd_latin PROC NEAR

; 2450 : 	DT_PIPE_T pipe_value[2]; 
; 2451 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  01170	8b 4c 24 04	 mov	 ecx, DWORD PTR _phTTS$[esp-4]

; 2452 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 2453 : 
; 2454 : 	pipe_value[0] = (1<<PSNEXTRA) + LATIN;

  01174	66 c7 44 24 04
	0f 3f		 mov	 WORD PTR _pipe_value$[esp-4], 16143 ; 00003f0fH

; 2455 : 	pipe_value[1] = pCmd_t->params[0];
; 2456 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,2);

  0117b	6a 02		 push	 2
  0117d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  01180	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  01183	66 8b 11	 mov	 dx, WORD PTR [ecx]
  01186	8d 4c 24 08	 lea	 ecx, DWORD PTR _pipe_value$[esp]
  0118a	66 89 54 24 0a	 mov	 WORD PTR _pipe_value$[esp+2], dx
  0118f	8b 90 90 02 00
	00		 mov	 edx, DWORD PTR [eax+656]
  01195	51		 push	 ecx
  01196	52		 push	 edx
  01197	50		 push	 eax
  01198	e8 00 00 00 00	 call	 _cm_util_write_pipe
  0119d	83 c4 10	 add	 esp, 16			; 00000010H

; 2457 : 	return(CMD_success);

  011a0	33 c0		 xor	 eax, eax

; 2458 : }

  011a2	c3		 ret	 0
_cm_cmd_latin ENDP
_phTTS$ = 8
_pipe_value$ = 8
_cm_cmd_comma PROC NEAR

; 2474 : 	DT_PIPE_T pipe_value[2];
; 2475 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  011b0	8b 4c 24 04	 mov	 ecx, DWORD PTR _phTTS$[esp-4]

; 2476 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 2477 : 
; 2478 : 	pipe_value[0] = (1<<PSNEXTRA) + CPAUSE;

  011b4	66 c7 44 24 04
	01 3f		 mov	 WORD PTR _pipe_value$[esp-4], 16129 ; 00003f01H

; 2479 : 	pipe_value[1] = pCmd_t->params[0];
; 2480 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,2);

  011bb	6a 02		 push	 2
  011bd	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  011c0	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  011c3	66 8b 11	 mov	 dx, WORD PTR [ecx]
  011c6	8d 4c 24 08	 lea	 ecx, DWORD PTR _pipe_value$[esp]
  011ca	66 89 54 24 0a	 mov	 WORD PTR _pipe_value$[esp+2], dx
  011cf	8b 90 90 02 00
	00		 mov	 edx, DWORD PTR [eax+656]
  011d5	51		 push	 ecx
  011d6	52		 push	 edx
  011d7	50		 push	 eax
  011d8	e8 00 00 00 00	 call	 _cm_util_write_pipe
  011dd	83 c4 10	 add	 esp, 16			; 00000010H

; 2481 : 	return(CMD_success);

  011e0	33 c0		 xor	 eax, eax

; 2482 : }

  011e2	c3		 ret	 0
_cm_cmd_comma ENDP
_phTTS$ = 8
_pipe_value$ = 8
_cm_cmd_period PROC NEAR

; 2499 : 	DT_PIPE_T pipe_value[2];
; 2500 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  011f0	8b 4c 24 04	 mov	 ecx, DWORD PTR _phTTS$[esp-4]

; 2501 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 2502 : 	
; 2503 : 	pipe_value[0] = (1<<PSNEXTRA) + PPAUSE;

  011f4	66 c7 44 24 04
	02 3f		 mov	 WORD PTR _pipe_value$[esp-4], 16130 ; 00003f02H

; 2504 : 	pipe_value[1] = pCmd_t->params[0];
; 2505 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,2);

  011fb	6a 02		 push	 2
  011fd	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  01200	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  01203	66 8b 11	 mov	 dx, WORD PTR [ecx]
  01206	8d 4c 24 08	 lea	 ecx, DWORD PTR _pipe_value$[esp]
  0120a	66 89 54 24 0a	 mov	 WORD PTR _pipe_value$[esp+2], dx
  0120f	8b 90 90 02 00
	00		 mov	 edx, DWORD PTR [eax+656]
  01215	51		 push	 ecx
  01216	52		 push	 edx
  01217	50		 push	 eax
  01218	e8 00 00 00 00	 call	 _cm_util_write_pipe
  0121d	83 c4 10	 add	 esp, 16			; 00000010H

; 2506 : 	return(CMD_success);

  01220	33 c0		 xor	 eax, eax

; 2507 : }

  01222	c3		 ret	 0
_cm_cmd_period ENDP
_TEXT	ENDS
EXTRN	_cm_pars_proc_char:NEAR
EXTRN	_send_index:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pipe_value$ = -8
_pKsd_t$ = 8
_cm_cmd_mark PROC NEAR

; 2522 : {

  01230	83 ec 08	 sub	 esp, 8
  01233	53		 push	 ebx
  01234	55		 push	 ebp
  01235	56		 push	 esi
  01236	57		 push	 edi

; 2523 : 	DT_PIPE_T pipe_value[3];
; 2524 : 	short cmd_type, cmd_value;
; 2525 : 	short temp;
; 2526 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  01237	8b 7c 24 1c	 mov	 edi, DWORD PTR _phTTS$[esp+20]

; 2527 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  0123b	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
  0123e	8b 6f 08	 mov	 ebp, DWORD PTR [edi+8]
  01241	89 6c 24 1c	 mov	 DWORD PTR _pKsd_t$[esp+20], ebp

; 2528 : 	
; 2529 : 	cmd_type = cm_util_string_match(index_options,pCmd_t->pString[0]);

  01245	8b 86 80 02 00
	00		 mov	 eax, DWORD PTR [esi+640]
  0124b	50		 push	 eax
  0124c	68 00 00 00 00	 push	 OFFSET FLAT:_index_options
  01251	e8 00 00 00 00	 call	 _cm_util_string_match

; 2530 : 	if(cmd_type == NO_STRING_MATCH)

  01256	0f bf c8	 movsx	 ecx, ax
  01259	83 c4 08	 add	 esp, 8
  0125c	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH

; 2531 : 	{
; 2532 : 	    /* change for the parser index buffer */
; 2533 :     	/* force the parser buffer to be sent */
; 2534 : #ifdef NEW_INDEXING
; 2535 : 	 	temp=pCmd_t->ParseChar; 
; 2536 : 	 	pCmd_t->ParseChar=0x0fff;
; 2537 :  		cm_pars_proc_char(phTTS,' ');
; 2538 : 	 	pCmd_t->ParseChar=temp;
; 2539 : #endif
; 2540 : 		return(CMD_bad_string);

  01262	0f 84 af 01 00
	00		 je	 $L71972

; 2541 : 	}		
; 2542 : 	if(cmd_type == 3)

  01268	66 3d 03 00	 cmp	 ax, 3
  0126c	75 0e		 jne	 SHORT $L71957

; 2543 : 	{
; 2544 : 		cmd_type = DCS_INDEX;

  0126e	b8 14 00 00 00	 mov	 eax, 20			; 00000014H

; 2545 : 		pipe_value[2] = SPC_INDEX_PAUSE;

  01273	66 c7 44 24 14
	02 00		 mov	 WORD PTR _pipe_value$[esp+28], 2

; 2546 : 	}
; 2547 : 	else

  0127a	eb 0a		 jmp	 SHORT $L71958
$L71957:

; 2548 : 	{
; 2549 : 		cmd_type += DCS_INDEX;

  0127c	83 c0 14	 add	 eax, 20			; 00000014H

; 2550 : 		pipe_value[2] = TEXT_OUTPUT;

  0127f	66 c7 44 24 14
	00 00		 mov	 WORD PTR _pipe_value$[esp+28], 0
$L71958:

; 2551 : 	}
; 2552 : 	cmd_value = pCmd_t->params[1];

  01286	66 8b 4e 04	 mov	 cx, WORD PTR [esi+4]

; 2553 : 
; 2554 : 	switch(cmd_type)
; 2555 : 	{

  0128a	0f bf c0	 movsx	 eax, ax
  0128d	83 c0 ec	 add	 eax, -20		; ffffffecH
  01290	83 f8 09	 cmp	 eax, 9
  01293	0f 87 7e 01 00
	00		 ja	 $L71972
  01299	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72188[eax*4]
$L71963:

; 2556 : 		case    DCS_INDEX       :
; 2557 : 
; 2558 : 			pipe_value[0] = (2<<PSNEXTRA) + INDEX;

  012a0	66 c7 44 24 10
	08 5f		 mov	 WORD PTR _pipe_value$[esp+24], 24328 ; 00005f08H

; 2559 : 			break;

  012a7	e9 a6 00 00 00	 jmp	 $L71960
$L71964:

; 2560 : 
; 2561 : 		case    DCS_INDEX_REPLY :
; 2562 : 
; 2563 : 			pipe_value[0] = (2<<PSNEXTRA) + INDEX_REPLY;

  012ac	66 c7 44 24 10
	09 5f		 mov	 WORD PTR _pipe_value$[esp+24], 24329 ; 00005f09H

; 2564 : 			break;

  012b3	e9 9a 00 00 00	 jmp	 $L71960
$L71965:

; 2565 : 
; 2566 : 		case    DCS_INDEX_QUERY :
; 2567 : 	    /* change for the parser index buffer */
; 2568 :     	/* force the parser buffer to be sent */
; 2569 : #ifdef NEW_INDEXING
; 2570 : 		 	temp=pCmd_t->ParseChar; 

  012b8	66 8b 9e 28 05
	00 00		 mov	 bx, WORD PTR [esi+1320]

; 2571 : 		 	pCmd_t->ParseChar=0x0fff;
; 2572 : 			cm_pars_proc_char(phTTS,' ');

  012bf	6a 20		 push	 32			; 00000020H
  012c1	57		 push	 edi
  012c2	66 c7 86 28 05
	00 00 ff 0f	 mov	 WORD PTR [esi+1320], 4095 ; 00000fffH
  012cb	e8 00 00 00 00	 call	 _cm_pars_proc_char

; 2573 : 		 	pCmd_t->ParseChar=temp;

  012d0	66 89 9e 28 05
	00 00		 mov	 WORD PTR [esi+1320], bx

; 2574 : #endif
; 2575 : #ifdef MSDOS
; 2576 :         	WAIT_PRINT;
; 2577 : 			printf("\n[:index %d]",pKsd_t->lastindex);
; 2578 :         	SIGNAL_PRINT;
; 2579 : #else
; 2580 : 			send_index(pipe_value[2],pKsd_t->lastindex);

  012d7	8b 44 24 1c	 mov	 eax, DWORD PTR _pipe_value$[esp+36]
  012db	8b 95 5c 03 00
	00		 mov	 edx, DWORD PTR [ebp+860]
  012e1	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  012e6	52		 push	 edx
  012e7	50		 push	 eax
  012e8	e8 00 00 00 00	 call	 _send_index
  012ed	83 c4 10	 add	 esp, 16			; 00000010H

; 2581 : #endif
; 2582 : 			return(CMD_success);

  012f0	33 c0		 xor	 eax, eax
  012f2	5f		 pop	 edi
  012f3	5e		 pop	 esi
  012f4	5d		 pop	 ebp
  012f5	5b		 pop	 ebx

; 2666 : }

  012f6	83 c4 08	 add	 esp, 8
  012f9	c3		 ret	 0
$L71966:

; 2583 : 		//tek 01aug97 bats 404
; 2584 : 		// handle these new index types.
; 2585 :                 //cjl 18nov97 Add ifdef for 32bit only.
; 2586 : #ifdef _WIN32
; 2587 : 
; 2588 : 		case DCS_INDEX_BOOKMARK:
; 2589 : 			pipe_value[0] = (2<<PSNEXTRA) | INDEX_BOOKMARK;

  012fa	66 c7 44 24 10
	13 5f		 mov	 WORD PTR _pipe_value$[esp+24], 24339 ; 00005f13H

; 2590 : 			pipe_value[2] = pCmd_t->params[2];//NH

  01301	66 8b 56 08	 mov	 dx, WORD PTR [esi+8]
  01305	66 89 54 24 14	 mov	 WORD PTR _pipe_value$[esp+28], dx

; 2591 : 			break;

  0130a	eb 46		 jmp	 SHORT $L71960
$L71967:

; 2592 : 
; 2593 : 		case DCS_INDEX_WORDPOS:
; 2594 : 			pipe_value[0] = (2<<PSNEXTRA) | INDEX_WORDPOS;

  0130c	66 c7 44 24 10
	14 5f		 mov	 WORD PTR _pipe_value$[esp+24], 24340 ; 00005f14H

; 2595 : 			pipe_value[2] = pCmd_t->params[2];//Nl
; 2596 : 			break;

  01313	eb 34		 jmp	 SHORT $L72187
$L71968:

; 2597 : 
; 2598 : 		case DCS_INDEX_START:
; 2599 : 			pipe_value[0] = (2<<PSNEXTRA) | INDEX_START;

  01315	66 c7 44 24 10
	15 5f		 mov	 WORD PTR _pipe_value$[esp+24], 24341 ; 00005f15H

; 2600 : 			pipe_value[2] = pCmd_t->params[2];//N?

  0131c	66 8b 56 08	 mov	 dx, WORD PTR [esi+8]
  01320	66 89 54 24 14	 mov	 WORD PTR _pipe_value$[esp+28], dx

; 2601 : 			break;

  01325	eb 2b		 jmp	 SHORT $L71960
$L71969:

; 2602 : 
; 2603 : 		case DCS_INDEX_STOP:
; 2604 : 			pipe_value[0] = (2<<PSNEXTRA) | INDEX_STOP;

  01327	66 c7 44 24 10
	16 5f		 mov	 WORD PTR _pipe_value$[esp+24], 24342 ; 00005f16H

; 2605 : 			pipe_value[2] = pCmd_t->params[2];//N?
; 2606 : 			break;

  0132e	eb 19		 jmp	 SHORT $L72187
$L71970:

; 2607 : 
; 2608 : 		case DCS_INDEX_SENTENCE:
; 2609 : 			pipe_value[0] = (2<<PSNEXTRA) | INDEX_SENTENCE;

  01330	66 c7 44 24 10
	18 5f		 mov	 WORD PTR _pipe_value$[esp+24], 24344 ; 00005f18H

; 2610 : 			pipe_value[2] = pCmd_t->params[2];//N?

  01337	66 8b 56 08	 mov	 dx, WORD PTR [esi+8]
  0133b	66 89 54 24 14	 mov	 WORD PTR _pipe_value$[esp+28], dx

; 2611 : 			break;

  01340	eb 10		 jmp	 SHORT $L71960
$L71971:

; 2612 : 
; 2613 : 		case DCS_INDEX_VOLUME:
; 2614 : 			pipe_value[0] = (2<<PSNEXTRA) | INDEX_VOLUME;

  01342	66 c7 44 24 10
	19 5f		 mov	 WORD PTR _pipe_value$[esp+24], 24345 ; 00005f19H
$L72187:

; 2615 : 			pipe_value[2] = pCmd_t->params[2];//N?

  01349	66 8b 46 08	 mov	 ax, WORD PTR [esi+8]
  0134d	66 89 44 24 14	 mov	 WORD PTR _pipe_value$[esp+28], ax
$L71960:

; 2630 : 	}
; 2631 :     /* change for the parser index buffer */
; 2632 :     /* make it place the index command into the buffer and not write it to the output */
; 2633 : 	pipe_value[1] = cmd_value;

  01352	66 89 4c 24 12	 mov	 WORD PTR _pipe_value$[esp+26], cx

; 2634 : #ifdef NEW_INDEXING
; 2635 : 	/* add the space to the clause buffer */
; 2636 :     if (pCmd_t->input_counter>=PAR_ROLLING_STOP_VALUE)

  01357	66 81 be 34 05
	00 00 2c 01	 cmp	 WORD PTR [esi+1332], 300 ; 0000012cH
  01360	7c 36		 jl	 SHORT $L71973

; 2637 :     {
; 2638 : 	 	temp=pCmd_t->ParseChar; 

  01362	66 8b 9e 28 05
	00 00		 mov	 bx, WORD PTR [esi+1320]

; 2639 : 	 	pCmd_t->ParseChar=' ';

  01369	bd 20 00 00 00	 mov	 ebp, 32			; 00000020H

; 2640 : 		cm_pars_proc_char(phTTS,' ');

  0136e	55		 push	 ebp
  0136f	57		 push	 edi
  01370	66 89 ae 28 05
	00 00		 mov	 WORD PTR [esi+1320], bp
  01377	e8 00 00 00 00	 call	 _cm_pars_proc_char

; 2641 : 	 	pCmd_t->ParseChar=' ';
; 2642 : 		cm_pars_proc_char(phTTS,' ');

  0137c	55		 push	 ebp
  0137d	57		 push	 edi
  0137e	66 89 ae 28 05
	00 00		 mov	 WORD PTR [esi+1320], bp
  01385	e8 00 00 00 00	 call	 _cm_pars_proc_char

; 2643 : 	 	pCmd_t->ParseChar=temp;                     

  0138a	8b 6c 24 2c	 mov	 ebp, DWORD PTR _pKsd_t$[esp+36]
  0138e	83 c4 10	 add	 esp, 16			; 00000010H
  01391	66 89 9e 28 05
	00 00		 mov	 WORD PTR [esi+1320], bx
$L71973:

; 2644 : 	}
; 2645 : 	if (pCmd_t->punct_mode==PUNCT_pass || pCmd_t->skip_mode==SKIP_all)

  01398	83 be 0c 05 00
	00 03		 cmp	 DWORD PTR [esi+1292], 3
  0139f	74 55		 je	 SHORT $L71975
  013a1	83 be 10 05 00
	00 04		 cmp	 DWORD PTR [esi+1296], 4
  013a8	74 4c		 je	 SHORT $L71975

; 2649 : 	}
; 2650 : 	/* GL 09/04/1996 insert a dummy space before the index marker */
; 2651 : 	/* MGS 10/14/1999 BATS #876 fix for UK phone numbers (part of it) */
; 2652 : 	/* comment out next line, it adds a second dummy space and breaks things */
; 2653 : 	//	pCmd_t->clausebuf[pCmd_t->input_counter++]=' ';
; 2654 : 	/* insert a dummy character for the index */
; 2655 : 	pCmd_t->clausebuf[pCmd_t->input_counter]=PAR_INDEX_DUMMY_CHAR;

  013aa	0f bf 8e 34 05
	00 00		 movsx	 ecx, WORD PTR [esi+1332]
  013b1	5f		 pop	 edi
  013b2	c6 84 31 3c 05
	00 00 82	 mov	 BYTE PTR [ecx+esi+1340], 130 ; 00000082H

; 2656 : 	/* put the index into the index buffer */
; 2657 : 	memcpy(pCmd_t->input_indexes[pCmd_t->input_counter].index,pipe_value,sizeof(index_data_t));

  013ba	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pipe_value$[esp+20]
  013be	0f bf 86 34 05
	00 00		 movsx	 eax, WORD PTR [esi+1332]
  013c5	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  013c8	8d 84 56 d0 16
	00 00		 lea	 eax, DWORD PTR [esi+edx*2+5840]
  013cf	89 8c 56 d0 16
	00 00		 mov	 DWORD PTR [esi+edx*2+5840], ecx
  013d6	66 8b 54 24 10	 mov	 dx, WORD PTR _pipe_value$[esp+24]
  013db	66 89 50 04	 mov	 WORD PTR [eax+4], dx

; 2658 : 	/* add 1 for the counter updating */
; 2659 : 	pCmd_t->input_counter++;

  013df	66 ff 86 34 05
	00 00		 inc	 WORD PTR [esi+1332]

; 2660 : 	pCmd_t->index_counter++;

  013e6	66 ff 86 36 05
	00 00		 inc	 WORD PTR [esi+1334]
  013ed	5e		 pop	 esi
  013ee	5d		 pop	 ebp

; 2661 : #endif
; 2662 : #ifndef NEW_INDEXING
; 2663 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,3);
; 2664 : #endif
; 2665 : 	return(CMD_success);

  013ef	33 c0		 xor	 eax, eax
  013f1	5b		 pop	 ebx

; 2666 : }

  013f2	83 c4 08	 add	 esp, 8
  013f5	c3		 ret	 0
$L71975:

; 2646 : 	{
; 2647 :                 cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,3);

  013f6	8b 8d 90 02 00
	00		 mov	 ecx, DWORD PTR [ebp+656]
  013fc	8d 44 24 10	 lea	 eax, DWORD PTR _pipe_value$[esp+24]
  01400	6a 03		 push	 3
  01402	50		 push	 eax
  01403	51		 push	 ecx
  01404	55		 push	 ebp
  01405	e8 00 00 00 00	 call	 _cm_util_write_pipe
  0140a	83 c4 10	 add	 esp, 16			; 00000010H

; 2648 : 		return(CMD_success);

  0140d	33 c0		 xor	 eax, eax
  0140f	5f		 pop	 edi
  01410	5e		 pop	 esi
  01411	5d		 pop	 ebp
  01412	5b		 pop	 ebx

; 2666 : }

  01413	83 c4 08	 add	 esp, 8
  01416	c3		 ret	 0
$L71972:

; 2616 : 			break;
; 2617 : #endif
; 2618 : 
; 2619 : 		default                 :
; 2620 : 	    /* change for the parser index buffer */
; 2621 :     	/* force the parser buffer to be sent */
; 2622 : #ifdef NEW_INDEXING
; 2623 : 		 	temp=pCmd_t->ParseChar; 

  01417	66 8b 9e 28 05
	00 00		 mov	 bx, WORD PTR [esi+1320]

; 2624 : 		 	pCmd_t->ParseChar=0x0fff;
; 2625 : 	 		cm_pars_proc_char(phTTS,' ');

  0141e	6a 20		 push	 32			; 00000020H
  01420	57		 push	 edi
  01421	66 c7 86 28 05
	00 00 ff 0f	 mov	 WORD PTR [esi+1320], 4095 ; 00000fffH
  0142a	e8 00 00 00 00	 call	 _cm_pars_proc_char
  0142f	83 c4 08	 add	 esp, 8

; 2626 : 		 	pCmd_t->ParseChar=temp;

  01432	66 89 9e 28 05
	00 00		 mov	 WORD PTR [esi+1320], bx

; 2627 : #endif
; 2628 : 
; 2629 : 			return(CMD_bad_string);

  01439	b8 01 00 00 00	 mov	 eax, 1
  0143e	5f		 pop	 edi
  0143f	5e		 pop	 esi
  01440	5d		 pop	 ebp
  01441	5b		 pop	 ebx

; 2666 : }

  01442	83 c4 08	 add	 esp, 8
  01445	c3		 ret	 0
  01446	8b ff		 npad	 2
$L72188:
  01448	00 00 00 00	 DD	 $L71963
  0144c	00 00 00 00	 DD	 $L71964
  01450	00 00 00 00	 DD	 $L71965
  01454	00 00 00 00	 DD	 $L71972
  01458	00 00 00 00	 DD	 $L71966
  0145c	00 00 00 00	 DD	 $L71967
  01460	00 00 00 00	 DD	 $L71968
  01464	00 00 00 00	 DD	 $L71969
  01468	00 00 00 00	 DD	 $L71970
  0146c	00 00 00 00	 DD	 $L71971
_cm_cmd_mark ENDP
_phTTS$ = 8
_pipe_value$ = -8
_cm_cmd_define PROC NEAR

; 2685 : 	DT_PIPE_T pipe_value[3];
; 2686 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  01470	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  01474	83 ec 08	 sub	 esp, 8
  01477	56		 push	 esi

; 2687 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  01478	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  0147b	57		 push	 edi
  0147c	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 2688 : 	
; 2689 : 	if(pCmd_t->param_index == 0)

  0147f	8b 86 d0 02 00
	00		 mov	 eax, DWORD PTR [esi+720]
  01485	85 c0		 test	 eax, eax

; 2690 : 		return(CMD_success);

  01487	0f 84 91 00 00
	00		 je	 $L71990

; 2691 : 	pipe_value[1] = cm_util_string_match(define_options,pCmd_t->pString[0]);

  0148d	8b 86 80 02 00
	00		 mov	 eax, DWORD PTR [esi+640]
  01493	50		 push	 eax
  01494	68 00 00 00 00	 push	 OFFSET FLAT:_define_options
  01499	e8 00 00 00 00	 call	 _cm_util_string_match
  0149e	83 c4 08	 add	 esp, 8

; 2692 : 	
; 2693 : 	/* 09/09/1996 SIK Fix for this command */
; 2694 : 	if(pipe_value[1] == NO_STRING_MATCH)

  014a1	66 3d ff ff	 cmp	 ax, 65535		; 0000ffffH
  014a5	66 89 44 24 0a	 mov	 WORD PTR _pipe_value$[esp+18], ax
  014aa	75 0b		 jne	 SHORT $L71984
  014ac	5f		 pop	 edi

; 2695 : 		return(CMD_bad_string);

  014ad	b8 01 00 00 00	 mov	 eax, 1
  014b2	5e		 pop	 esi

; 2723 : }

  014b3	83 c4 08	 add	 esp, 8
  014b6	c3		 ret	 0
$L71984:

; 2696 : 	/*
; 2697 :  	 *  do the save first ...
; 2698 :  	 */
; 2699 : 
; 2700 : 	if(pipe_value[1] == 0)

  014b7	66 85 c0	 test	 ax, ax
  014ba	75 20		 jne	 SHORT $L71985

; 2701 : 	{
; 2702 : 		if(pCmd_t->defaults[1] == FALSE)

  014bc	8b 86 ac 02 00
	00		 mov	 eax, DWORD PTR [esi+684]
  014c2	85 c0		 test	 eax, eax
  014c4	75 0b		 jne	 SHORT $L71986
  014c6	5f		 pop	 edi

; 2703 : 			return(CMD_bad_value);

  014c7	b8 02 00 00 00	 mov	 eax, 2
  014cc	5e		 pop	 esi

; 2723 : }

  014cd	83 c4 08	 add	 esp, 8
  014d0	c3		 ret	 0
$L71986:

; 2704 : 		else
; 2705 : 		{
; 2706 : 			pipe_value[0] = SAVE;

  014d1	66 c7 44 24 08
	07 1f		 mov	 WORD PTR _pipe_value$[esp+16], 7943 ; 00001f07H

; 2707 :                         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,1);

  014d8	6a 01		 push	 1

; 2708 : 		}
; 2709 : 	}
; 2710 : 	else

  014da	eb 2d		 jmp	 SHORT $L72190
$L71985:

; 2711 : 	{
; 2712 : 		if(pCmd_t->defaults[1] == TRUE)

  014dc	83 be ac 02 00
	00 01		 cmp	 DWORD PTR [esi+684], 1
  014e3	75 0b		 jne	 SHORT $L71989
  014e5	5f		 pop	 edi

; 2713 : 			return(CMD_bad_value);

  014e6	b8 02 00 00 00	 mov	 eax, 2
  014eb	5e		 pop	 esi

; 2723 : }

  014ec	83 c4 08	 add	 esp, 8
  014ef	c3		 ret	 0
$L71989:

; 2714 : 		else
; 2715 : 		{
; 2716 : 			pipe_value[0] = (2<<PSNEXTRA)+NEW_PARAM;
; 2717 : 			pipe_value[1] -= 1;

  014f0	66 48		 dec	 ax
  014f2	66 c7 44 24 08
	06 5f		 mov	 WORD PTR _pipe_value$[esp+16], 24326 ; 00005f06H
  014f9	66 89 44 24 0a	 mov	 WORD PTR _pipe_value$[esp+18], ax

; 2718 : 			pipe_value[2] = pCmd_t->params[1];

  014fe	66 8b 46 04	 mov	 ax, WORD PTR [esi+4]
  01502	66 89 44 24 0c	 mov	 WORD PTR _pipe_value$[esp+20], ax

; 2719 :                         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,3);

  01507	6a 03		 push	 3
$L72190:
  01509	8b 97 90 02 00
	00		 mov	 edx, DWORD PTR [edi+656]
  0150f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _pipe_value$[esp+20]
  01513	51		 push	 ecx
  01514	52		 push	 edx
  01515	57		 push	 edi
  01516	e8 00 00 00 00	 call	 _cm_util_write_pipe
  0151b	83 c4 10	 add	 esp, 16			; 00000010H
$L71990:
  0151e	5f		 pop	 edi

; 2720 : 		}
; 2721 : 	}
; 2722 : 	return(CMD_success);

  0151f	33 c0		 xor	 eax, eax
  01521	5e		 pop	 esi

; 2723 : }

  01522	83 c4 08	 add	 esp, 8
  01525	c3		 ret	 0
_cm_cmd_define ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_plang
EXTRN	__imp__printf:NEAR
_DATA	SEGMENT
$SG72016 DB	0aH, '  %d arpabet (%c%c)  asky (%c)', 00H
$SG72019 DB	0aH, '  %d arpabet (%c%c)  asky (%c)', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_pipe_value$ = 8
_cm_cmd_plang PROC NEAR

; 2740 : 	DT_PIPE_T pipe_value;
; 2741 : 	int     i;
; 2742 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  01530	8b 4c 24 04	 mov	 ecx, DWORD PTR _phTTS$[esp-4]
  01534	53		 push	 ebx
  01535	55		 push	 ebp
  01536	56		 push	 esi
  01537	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]

; 2743 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  0153a	8b 69 0c	 mov	 ebp, DWORD PTR [ecx+12]

; 2744 : 	int phoneme_code_add=0;

  0153d	33 db		 xor	 ebx, ebx

; 2745 : 
; 2746 : 	switch (pKsd_t->lang_curr)
; 2747 : 	{

  0153f	8b 86 b8 02 00
	00		 mov	 eax, DWORD PTR [esi+696]
  01545	83 f8 06	 cmp	 eax, 6
  01548	77 2f		 ja	 SHORT $L72000
  0154a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72195[eax*4]
$L72003:

; 2748 : 	case LANG_english:
; 2749 : 		phoneme_code_add=(PFUSA<<PSFONT);

  01551	bb 00 1e 00 00	 mov	 ebx, 7680		; 00001e00H

; 2750 : 		break;

  01556	eb 21		 jmp	 SHORT $L72000
$L72004:

; 2751 : 	case LANG_british:
; 2752 : 		phoneme_code_add=(PFUK<<PSFONT);

  01558	bb 00 1d 00 00	 mov	 ebx, 7424		; 00001d00H

; 2753 : 		break;

  0155d	eb 1a		 jmp	 SHORT $L72000
$L72005:

; 2754 : 	case LANG_german:
; 2755 : 		phoneme_code_add=(PFGR<<PSFONT);

  0155f	bb 00 1c 00 00	 mov	 ebx, 7168		; 00001c00H

; 2756 : 		break;

  01564	eb 13		 jmp	 SHORT $L72000
$L72006:

; 2757 : 	case LANG_spanish:
; 2758 : 		phoneme_code_add=(PFSP<<PSFONT);

  01566	bb 00 1b 00 00	 mov	 ebx, 6912		; 00001b00H

; 2759 : 		break;

  0156b	eb 0c		 jmp	 SHORT $L72000
$L72007:

; 2760 : 	case LANG_latin_american:
; 2761 : 		phoneme_code_add=(PFLA<<PSFONT);

  0156d	bb 00 1a 00 00	 mov	 ebx, 6656		; 00001a00H

; 2762 : 		break;

  01572	eb 05		 jmp	 SHORT $L72000
$L72008:

; 2763 : 	case LANG_french:					//chj 7/20/00
; 2764 : 		phoneme_code_add=(PFFR<<PSFONT);

  01574	bb 00 19 00 00	 mov	 ebx, 6400		; 00001900H
$L72000:

; 2765 : 		break;
; 2766 : 	}
; 2767 : 
; 2768 : 	
; 2769 : 	if(cm_cmd_sync(phTTS) == CMD_flushing)

  01579	51		 push	 ecx
  0157a	e8 00 00 00 00	 call	 _cm_cmd_sync
  0157f	83 c4 04	 add	 esp, 4
  01582	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  01585	75 04		 jne	 SHORT $L72009
  01587	5e		 pop	 esi
  01588	5d		 pop	 ebp
  01589	5b		 pop	 ebx

; 2814 : }

  0158a	c3		 ret	 0
$L72009:
  0158b	57		 push	 edi

; 2770 : 		return(CMD_flushing);
; 2771 : 	if(pCmd_t->params[0] == 0 || pCmd_t->defaults[0] == TRUE)

  0158c	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  0158f	85 ff		 test	 edi, edi
  01591	74 7d		 je	 SHORT $L72011
  01593	83 bd a8 02 00
	00 01		 cmp	 DWORD PTR [ebp+680], 1
  0159a	74 74		 je	 SHORT $L72011

; 2790 : #endif
; 2791 : #ifdef __osf__
; 2792 : 				OP_Sleep(100);
; 2793 : #endif
; 2794 : #ifdef __linux__
; 2795 : 				OP_Sleep(100);
; 2796 : #endif
; 2797 : 
; 2798 : 			}
; 2799 : 	}
; 2800 : 	else 
; 2801 : 	if(pCmd_t->params[0] < MAXI_PHONES)

  0159c	83 ff 39	 cmp	 edi, 57			; 00000039H
  0159f	0f 83 ed 00 00
	00		 jae	 $L72014

; 2802 : 	{
; 2803 : 		i = pCmd_t->params[0];
; 2804 : 		WAIT_PRINT;
; 2805 : 		printf("\n  %d arpabet (%c%c)  asky (%c)",
; 2806 : 				i,pKsd_t->arpabet[i*2],pKsd_t->arpabet[i*2+1],pKsd_t->ascky[i]);

  015a5	8b 8e 20 06 00
	00		 mov	 ecx, DWORD PTR [esi+1568]
  015ab	8b 86 2c 06 00
	00		 mov	 eax, DWORD PTR [esi+1580]
  015b1	33 d2		 xor	 edx, edx
  015b3	8a 14 39	 mov	 dl, BYTE PTR [ecx+edi]
  015b6	8d 04 78	 lea	 eax, DWORD PTR [eax+edi*2]
  015b9	52		 push	 edx
  015ba	33 c9		 xor	 ecx, ecx
  015bc	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  015bf	33 d2		 xor	 edx, edx
  015c1	8a 10		 mov	 dl, BYTE PTR [eax]
  015c3	51		 push	 ecx
  015c4	52		 push	 edx
  015c5	57		 push	 edi
  015c6	68 00 00 00 00	 push	 OFFSET FLAT:$SG72019
  015cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf

; 2807 : 		SIGNAL_PRINT;
; 2808 : 		pipe_value = phoneme_code_add | i;

  015d1	0b fb		 or	 edi, ebx

; 2809 :                 cm_util_write_pipe(pKsd_t,pKsd_t->ph_pipe,&pipe_value,1);

  015d3	8d 44 24 28	 lea	 eax, DWORD PTR _pipe_value$[esp+32]
  015d7	89 7c 24 28	 mov	 DWORD PTR _pipe_value$[esp+32], edi
  015db	8b 8e 94 02 00
	00		 mov	 ecx, DWORD PTR [esi+660]
  015e1	6a 01		 push	 1
  015e3	50		 push	 eax
  015e4	51		 push	 ecx
  015e5	56		 push	 esi
  015e6	e8 00 00 00 00	 call	 _cm_util_write_pipe

; 2810 : 		pipe_value = phoneme_code_add | COMMA;

  015eb	83 cb 73	 or	 ebx, 115		; 00000073H

; 2811 :                 cm_util_write_pipe(pKsd_t,pKsd_t->ph_pipe,&pipe_value,1);

  015ee	8d 54 24 38	 lea	 edx, DWORD PTR _pipe_value$[esp+48]
  015f2	89 5c 24 38	 mov	 DWORD PTR _pipe_value$[esp+48], ebx
  015f6	8b 86 94 02 00
	00		 mov	 eax, DWORD PTR [esi+660]
  015fc	6a 01		 push	 1
  015fe	52		 push	 edx
  015ff	50		 push	 eax
  01600	56		 push	 esi
  01601	e8 00 00 00 00	 call	 _cm_util_write_pipe
  01606	83 c4 34	 add	 esp, 52			; 00000034H

; 2812 : 	}
; 2813 : 	return(CMD_success);

  01609	33 c0		 xor	 eax, eax
  0160b	5f		 pop	 edi
  0160c	5e		 pop	 esi
  0160d	5d		 pop	 ebp
  0160e	5b		 pop	 ebx

; 2814 : }

  0160f	c3		 ret	 0
$L72011:

; 2772 : 	{
; 2773 : 		for(i=1; i < MAXI_PHONES; i++)

  01610	bf 01 00 00 00	 mov	 edi, 1
$L72012:
  01615	8b 8e 2c 06 00
	00		 mov	 ecx, DWORD PTR [esi+1580]

; 2774 : 			if(pKsd_t->arpabet[i*2])

  0161b	8a 04 79	 mov	 al, BYTE PTR [ecx+edi*2]
  0161e	8d 2c 79	 lea	 ebp, DWORD PTR [ecx+edi*2]
  01621	84 c0		 test	 al, al
  01623	74 67		 je	 SHORT $L72013

; 2775 : 			{
; 2776 : 				WAIT_PRINT;
; 2777 : 				printf("\n  %d arpabet (%c%c)  asky (%c)",
; 2778 : 					i,pKsd_t->arpabet[i*2],pKsd_t->arpabet[i*2+1],pKsd_t->ascky[i]);

  01625	8b 96 20 06 00
	00		 mov	 edx, DWORD PTR [esi+1568]
  0162b	33 c9		 xor	 ecx, ecx
  0162d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01632	8a 0c 3a	 mov	 cl, BYTE PTR [edx+edi]
  01635	33 d2		 xor	 edx, edx
  01637	8a 55 01	 mov	 dl, BYTE PTR [ebp+1]
  0163a	51		 push	 ecx
  0163b	52		 push	 edx
  0163c	50		 push	 eax
  0163d	57		 push	 edi
  0163e	68 00 00 00 00	 push	 OFFSET FLAT:$SG72016
  01643	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf

; 2779 : 				SIGNAL_PRINT;
; 2780 : 				pipe_value = phoneme_code_add | i;

  01649	8b c7		 mov	 eax, edi

; 2781 :                                 cm_util_write_pipe(pKsd_t,pKsd_t->ph_pipe,&pipe_value,1);

  0164b	8d 4c 24 28	 lea	 ecx, DWORD PTR _pipe_value$[esp+32]
  0164f	0b c3		 or	 eax, ebx
  01651	6a 01		 push	 1
  01653	89 44 24 2c	 mov	 DWORD PTR _pipe_value$[esp+36], eax
  01657	8b 96 94 02 00
	00		 mov	 edx, DWORD PTR [esi+660]
  0165d	51		 push	 ecx
  0165e	52		 push	 edx
  0165f	56		 push	 esi
  01660	e8 00 00 00 00	 call	 _cm_util_write_pipe

; 2782 : 				pipe_value = phoneme_code_add | COMMA;

  01665	8b c3		 mov	 eax, ebx

; 2783 :                                 cm_util_write_pipe(pKsd_t,pKsd_t->ph_pipe,&pipe_value,1);

  01667	8d 4c 24 38	 lea	 ecx, DWORD PTR _pipe_value$[esp+48]
  0166b	0c 73		 or	 al, 115			; 00000073H
  0166d	6a 01		 push	 1
  0166f	89 44 24 3c	 mov	 DWORD PTR _pipe_value$[esp+52], eax
  01673	8b 96 94 02 00
	00		 mov	 edx, DWORD PTR [esi+660]
  01679	51		 push	 ecx
  0167a	52		 push	 edx
  0167b	56		 push	 esi
  0167c	e8 00 00 00 00	 call	 _cm_util_write_pipe
  01681	83 c4 34	 add	 esp, 52			; 00000034H

; 2784 : 				/* GL 04/21/1997  change this for OSF build */
; 2785 : #ifdef MSDOS
; 2786 : 				sleep(100);
; 2787 : #endif
; 2788 : #ifdef WIN32
; 2789 : 				Sleep(100);

  01684	6a 64		 push	 100			; 00000064H
  01686	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
$L72013:
  0168c	47		 inc	 edi
  0168d	83 ff 39	 cmp	 edi, 57			; 00000039H
  01690	7c 83		 jl	 SHORT $L72012
$L72014:
  01692	5f		 pop	 edi
  01693	5e		 pop	 esi
  01694	5d		 pop	 ebp

; 2812 : 	}
; 2813 : 	return(CMD_success);

  01695	33 c0		 xor	 eax, eax
  01697	5b		 pop	 ebx

; 2814 : }

  01698	c3		 ret	 0
  01699	8d 49 00	 npad	 3
$L72195:
  0169c	00 00 00 00	 DD	 $L72003
  016a0	00 00 00 00	 DD	 $L72008
  016a4	00 00 00 00	 DD	 $L72005
  016a8	00 00 00 00	 DD	 $L72006
  016ac	00 00 00 00	 DD	 $L72000
  016b0	00 00 00 00	 DD	 $L72004
  016b4	00 00 00 00	 DD	 $L72007
_cm_cmd_plang ENDP
_phTTS$ = 8
_cm_cmd_stress PROC NEAR

; 2833 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  016c0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  016c4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 2834 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData; 

  016c7	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 2835 : 	
; 2836 : 	if(pCmd_t->defaults[0] == TRUE)

  016ca	83 b8 a8 02 00
	00 01		 cmp	 DWORD PTR [eax+680], 1
  016d1	75 0d		 jne	 SHORT $L72025

; 2837 : 		pKsd_t->pitch_delta = 0;

  016d3	c7 81 18 04 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1048], 0

; 2840 : 	return(CMD_success);

  016dd	33 c0		 xor	 eax, eax

; 2841 : }

  016df	c3		 ret	 0
$L72025:

; 2838 : 	else
; 2839 : 		pKsd_t->pitch_delta = (int)pCmd_t->params[0];

  016e0	8b 00		 mov	 eax, DWORD PTR [eax]
  016e2	89 81 18 04 00
	00		 mov	 DWORD PTR [ecx+1048], eax

; 2840 : 	return(CMD_success);

  016e8	33 c0		 xor	 eax, eax

; 2841 : }

  016ea	c3		 ret	 0
_cm_cmd_stress ENDP
_TEXT	ENDS
EXTRN	_WaitForLtsFlush:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pipe$ = -12
_cm_cmd_tone PROC NEAR

; 2863 : {

  016f0	83 ec 0c	 sub	 esp, 12			; 0000000cH
  016f3	53		 push	 ebx
  016f4	56		 push	 esi

; 2864 :   DT_PIPE_T pipe[6];
; 2865 :   /*LPTTS_HANDLE_T phTTS;*/             /*MVP MI */
; 2866 :   PKSD_T pKsd_t = phTTS->pKernelShareData;

  016f5	8b 74 24 18	 mov	 esi, DWORD PTR _phTTS$[esp+16]
  016f9	57		 push	 edi

; 2867 :   PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 2868 : 
; 2869 : 
; 2870 :   /********************************************************************/
; 2871 :   /*  Get the text to speech handle.                                  */
; 2872 :   /********************************************************************/
; 2873 : 
; 2874 :   /*phTTS = TextToSpeechGetHandle();*/
; 2875 : 
; 2876 :   /********************************************************************/
; 2877 :   /*  Wait for all characters previously queued to LTS to be          */
; 2878 :   /*  processed.                                                      */
; 2879 :   /********************************************************************/
; 2880 : 
; 2881 :   if ( cm_cmd_sync(phTTS) == CMD_flushing )

  016fa	56		 push	 esi
  016fb	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  016fe	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  01701	e8 00 00 00 00	 call	 _cm_cmd_sync
  01706	83 c4 04	 add	 esp, 4
  01709	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0170c	75 07		 jne	 SHORT $L72034
  0170e	5f		 pop	 edi
  0170f	5e		 pop	 esi
  01710	5b		 pop	 ebx

; 2929 : }

  01711	83 c4 0c	 add	 esp, 12			; 0000000cH
  01714	c3		 ret	 0
$L72034:

; 2882 : 	return( CMD_flushing );
; 2883 : 
; 2884 :   WaitForLtsFlush( phTTS, 0xFFFFFFFF );

  01715	6a ff		 push	 -1
  01717	56		 push	 esi
  01718	e8 00 00 00 00	 call	 _WaitForLtsFlush

; 2885 : 
; 2886 :   /********************************************************************/
; 2887 :   /*  The packet format here is different than the DTC07. The ramp    */
; 2888 :   /*  duration has been eliminated. The tone generation software      */
; 2889 :   /*  automatically provides 3 msec. cosine squared tapering for      */
; 2890 :   /*  the tone pulse rise and fall time.                              */
; 2891 :   /*                                                                  */
; 2892 :   /*  Packet Index     Packet Data                 Value              */
; 2893 :   /*                                                                  */
; 2894 :   /*      0            Command Word              SPC_type_tone        */
; 2895 :   /*      1            Tone Duration (msec.)     0 to ?               */
; 2896 :   /*      2            Tone 0 Frequency          0 to Fs/2            */
; 2897 :   /*      3            Tone 0 Amplitude          0 to 32767           */
; 2898 :   /*      4            Tone 1 Frequency          0 to Fs/2            */
; 2899 :   /*      5            Tone 1 Amplitude          0 to 32767           */
; 2900 :   /*                                                                  */
; 2901 :   /********************************************************************/
; 2902 : 
; 2903 :   /********************************************************************/
; 2904 :   /*  params[1] is a character pointer to the duration in msec.       */
; 2905 :   /*  params[0] is a character pointer to the frequency in Hertz.     */
; 2906 :   /********************************************************************/
; 2907 : 
; 2908 :   if ( pCmd_t->params[0] > ( pKsd_t->uiSampleRate >> 1 ))

  0171d	8b 87 f0 03 00
	00		 mov	 eax, DWORD PTR [edi+1008]
  01723	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  01725	d1 e8		 shr	 eax, 1
  01727	83 c4 08	 add	 esp, 8
  0172a	3b c8		 cmp	 ecx, eax
  0172c	76 0c		 jbe	 SHORT $L72035
  0172e	5f		 pop	 edi
  0172f	5e		 pop	 esi

; 2909 : 	return( CMD_bad_value );

  01730	b8 02 00 00 00	 mov	 eax, 2
  01735	5b		 pop	 ebx

; 2929 : }

  01736	83 c4 0c	 add	 esp, 12			; 0000000cH
  01739	c3		 ret	 0
$L72035:

; 2910 : 
; 2911 :   pipe[0] = SPC_type_tone;

  0173a	66 c7 44 24 0c
	02 00		 mov	 WORD PTR _pipe$[esp+24], 2

; 2912 :   pipe[1] = pCmd_t->params[1];

  01741	66 8b 4b 04	 mov	 cx, WORD PTR [ebx+4]
  01745	66 89 4c 24 0e	 mov	 WORD PTR _pipe$[esp+26], cx

; 2913 :   pipe[2] = pCmd_t->params[0];

  0174a	66 8b 13	 mov	 dx, WORD PTR [ebx]
  0174d	66 89 54 24 10	 mov	 WORD PTR _pipe$[esp+28], dx

; 2914 : 
; 2915 :   /********************************************************************/
; 2916 :   /*  Disable the second tone.                                        */
; 2917 :   /********************************************************************/
; 2918 : 
; 2919 :   pipe[3] = TONE_AMPLITUDE;

  01752	66 c7 44 24 12
	ff 7f		 mov	 WORD PTR _pipe$[esp+30], 32767 ; 00007fffH

; 2920 :   pipe[4] = 1000;

  01759	66 c7 44 24 14
	e8 03		 mov	 WORD PTR _pipe$[esp+32], 1000 ; 000003e8H

; 2921 :   pipe[5] = 0;

  01760	66 c7 44 24 16
	00 00		 mov	 WORD PTR _pipe$[esp+34], 0

; 2922 : 
; 2923 : /* GL 04/21/1997  change this for OSF build */
; 2924 : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 2925 :   cm_util_write_pipe(pKsd_t,pKsd_t->vtm_pipe, pipe, 6 );

  01767	8b 8f 9c 02 00
	00		 mov	 ecx, DWORD PTR [edi+668]
  0176d	8d 44 24 0c	 lea	 eax, DWORD PTR _pipe$[esp+24]
  01771	6a 06		 push	 6
  01773	50		 push	 eax
  01774	51		 push	 ecx
  01775	57		 push	 edi
  01776	e8 00 00 00 00	 call	 _cm_util_write_pipe
  0177b	83 c4 10	 add	 esp, 16			; 00000010H

; 2926 : #endif
; 2927 : 
; 2928 :   return( CMD_success );

  0177e	33 c0		 xor	 eax, eax
  01780	5f		 pop	 edi
  01781	5e		 pop	 esi
  01782	5b		 pop	 ebx

; 2929 : }

  01783	83 c4 0c	 add	 esp, 12			; 0000000cH
  01786	c3		 ret	 0
_cm_cmd_tone ENDP
_TEXT	ENDS
EXTRN	_tlitone0:BYTE
EXTRN	_tlitone1:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_pChar$ = 8
_szSingleDigit$ = -16
_pipe$ = -12
_cm_cmd_dial PROC NEAR

; 3000 : {

  01790	83 ec 10	 sub	 esp, 16			; 00000010H
  01793	53		 push	 ebx
  01794	55		 push	 ebp
  01795	56		 push	 esi
  01796	57		 push	 edi

; 3001 :   int iIndex;
; 3002 :   unsigned char *pChar;
; 3003 :   unsigned char szSingleDigit[2];
; 3004 :   DT_PIPE_T pipe[6];
; 3005 :   PKSD_T pKsd_t = phTTS->pKernelShareData;      

  01797	8b 7c 24 24	 mov	 edi, DWORD PTR _phTTS$[esp+28]

; 3006 :   PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 3007 :   /*
; 3008 :   LPTTS_HANDLE_T phTTS;
; 3009 :   */
; 3010 :   /********************************************************************/
; 3011 :   /*  Get the text to speech handle.                                  */
; 3012 :   /********************************************************************/
; 3013 :   /*
; 3014 :   phTTS = TextToSpeechGetHandle();
; 3015 :   */
; 3016 :   /********************************************************************/
; 3017 :   /*  Wait for all characters previously queued to LTS to be          */
; 3018 :   /*  processed.                                                      */
; 3019 :   /********************************************************************/
; 3020 : 
; 3021 :   if ( cm_cmd_sync(phTTS) == CMD_flushing )

  0179b	57		 push	 edi
  0179c	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  0179f	8b 5f 0c	 mov	 ebx, DWORD PTR [edi+12]
  017a2	e8 00 00 00 00	 call	 _cm_cmd_sync
  017a7	83 c4 04	 add	 esp, 4
  017aa	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  017ad	75 08		 jne	 SHORT $L72045
  017af	5f		 pop	 edi
  017b0	5e		 pop	 esi
  017b1	5d		 pop	 ebp
  017b2	5b		 pop	 ebx

; 3216 : }

  017b3	83 c4 10	 add	 esp, 16			; 00000010H
  017b6	c3		 ret	 0
$L72045:

; 3022 : 	return( CMD_flushing );
; 3023 : 
; 3024 :   WaitForLtsFlush( phTTS, 0xFFFFFFFF );

  017b7	6a ff		 push	 -1
  017b9	57		 push	 edi
  017ba	e8 00 00 00 00	 call	 _WaitForLtsFlush

; 3025 : 
; 3026 :   /********************************************************************/
; 3027 :   /*  Write a tone packet to the VTM thread for each character in the */
; 3028 :   /*  dial string.                                                    */
; 3029 :   /********************************************************************/
; 3030 : 
; 3031 :   pChar = pCmd_t->pString[0];

  017bf	8b 9b 80 02 00
	00		 mov	 ebx, DWORD PTR [ebx+640]
  017c5	83 c4 08	 add	 esp, 8
  017c8	89 5c 24 24	 mov	 DWORD PTR _pChar$[esp+28], ebx

; 3032 : 
; 3033 :   while ( *pChar != '\0' )

  017cc	8a 0b		 mov	 cl, BYTE PTR [ebx]
  017ce	84 c9		 test	 cl, cl
  017d0	0f 84 be 01 00
	00		 je	 $L72048
  017d6	bd 02 00 00 00	 mov	 ebp, 2
  017db	bb 64 00 00 00	 mov	 ebx, 100		; 00000064H
  017e0	bf e8 03 00 00	 mov	 edi, 1000		; 000003e8H
$L72047:

; 3034 :   {
; 3035 : 	/******************************************************************/
; 3036 : 	/*  Convert the character to an index.                            */
; 3037 : 	/******************************************************************/
; 3038 : 
; 3039 : 	szSingleDigit[0] = *pChar;

  017e5	88 4c 24 10	 mov	 BYTE PTR _szSingleDigit$[esp+32], cl

; 3040 : 	szSingleDigit[1] = '\0';
; 3041 : 
; 3042 : 	  switch ( szSingleDigit[0] )
; 3043 : 	  {

  017e9	8b 44 24 10	 mov	 eax, DWORD PTR _szSingleDigit$[esp+32]
  017ed	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  017f2	83 c0 dd	 add	 eax, -35		; ffffffddH
  017f5	83 f8 41	 cmp	 eax, 65			; 00000041H
  017f8	0f 87 3e 01 00
	00		 ja	 $L72069
  017fe	33 d2		 xor	 edx, edx
  01800	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $L72203[eax]
  01806	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L72204[edx*4]
$L72053:

; 3044 : 	  		case '0':
; 3045 : 				iIndex = 0;

  0180d	33 c0		 xor	 eax, eax
$L72073:

; 3170 : 	{
; 3171 : 	  /****************************************************************/
; 3172 : 	  /*  DTMF digit.                                                 */
; 3173 : 	  /****************************************************************/
; 3174 : 
; 3175 : 	  pipe[0] = SPC_type_tone;
; 3176 : 	  pipe[1] = DTMF_DIGIT_TIME_IN_MSEC;
; 3177 : 	  pipe[2] = tlitone0[iIndex];

  0180f	66 8b 14 45 00
	00 00 00	 mov	 dx, WORD PTR _tlitone0[eax*2]

; 3178 : 	  pipe[3] = DTMF_HIGH_TONE_AMPLITUDE;
; 3179 : 	  pipe[4] = tlitone1[iIndex];

  01817	66 8b 04 45 00
	00 00 00	 mov	 ax, WORD PTR _tlitone1[eax*2]
  0181f	66 89 6c 24 14	 mov	 WORD PTR _pipe$[esp+32], bp
  01824	66 89 5c 24 16	 mov	 WORD PTR _pipe$[esp+34], bx
  01829	66 89 54 24 18	 mov	 WORD PTR _pipe$[esp+36], dx
  0182e	66 c7 44 24 1a
	7a 4e		 mov	 WORD PTR _pipe$[esp+38], 20090 ; 00004e7aH
  01835	66 89 44 24 1c	 mov	 WORD PTR _pipe$[esp+40], ax

; 3180 : 	  pipe[5] = DTMF_LOW_TONE_AMPLITUDE;

  0183a	66 c7 44 24 1e
	84 31		 mov	 WORD PTR _pipe$[esp+42], 12676 ; 00003184H

; 3181 : 
; 3182 : /* GL 04/21/1997  change this for OSF build */
; 3183 : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 3184 :           cm_util_write_pipe(pKsd_t, pKsd_t->vtm_pipe, pipe, 6 );

  01841	8b 96 9c 02 00
	00		 mov	 edx, DWORD PTR [esi+668]
  01847	8d 4c 24 14	 lea	 ecx, DWORD PTR _pipe$[esp+32]
  0184b	6a 06		 push	 6
  0184d	51		 push	 ecx
  0184e	52		 push	 edx
  0184f	56		 push	 esi
  01850	e8 00 00 00 00	 call	 _cm_util_write_pipe

; 3185 : #endif
; 3186 : 
; 3187 : 
; 3188 : 	  /****************************************************************/
; 3189 : 	  /*  Interdigital space.                                         */
; 3190 : 	  /****************************************************************/
; 3191 : 
; 3192 : 	  pipe[0] = SPC_type_tone;
; 3193 : 	  pipe[1] = DTMF_INTER_DIGITAL_TIME_IN_MSEC;
; 3194 : 	  pipe[2] = 1000;
; 3195 : 	  pipe[3] = 0;

  01855	33 c0		 xor	 eax, eax
  01857	66 89 6c 24 24	 mov	 WORD PTR _pipe$[esp+48], bp
  0185c	66 89 44 24 2a	 mov	 WORD PTR _pipe$[esp+54], ax

; 3196 : 	  pipe[4] = 1000;
; 3197 : 	  pipe[5] = 0;

  01861	66 89 44 24 2e	 mov	 WORD PTR _pipe$[esp+58], ax
  01866	66 89 5c 24 26	 mov	 WORD PTR _pipe$[esp+50], bx
  0186b	66 89 7c 24 28	 mov	 WORD PTR _pipe$[esp+52], di
  01870	66 89 7c 24 2c	 mov	 WORD PTR _pipe$[esp+56], di

; 3198 : 
; 3199 : 
; 3200 : /* GL 04/21/1997  change this for OSF build */
; 3201 : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 3202 : 	  cm_util_write_pipe(pKsd_t, pKsd_t->vtm_pipe, pipe, 6 );

  01875	8b 8e 9c 02 00
	00		 mov	 ecx, DWORD PTR [esi+668]
  0187b	8d 44 24 24	 lea	 eax, DWORD PTR _pipe$[esp+48]
  0187f	6a 06		 push	 6
  01881	50		 push	 eax
  01882	51		 push	 ecx
  01883	56		 push	 esi
  01884	e8 00 00 00 00	 call	 _cm_util_write_pipe
  01889	83 c4 20	 add	 esp, 32			; 00000020H
$L72074:

; 3203 : #endif
; 3204 : 
; 3205 : 
; 3206 : 	}
; 3207 : 
; 3208 : 	/******************************************************************/
; 3209 : 	/*  Increment to the next character.                              */
; 3210 : 	/******************************************************************/
; 3211 : 
; 3212 : 	pChar++;

  0188c	8b 44 24 24	 mov	 eax, DWORD PTR _pChar$[esp+28]
  01890	40		 inc	 eax
  01891	89 44 24 24	 mov	 DWORD PTR _pChar$[esp+28], eax
  01895	8a 08		 mov	 cl, BYTE PTR [eax]
  01897	84 c9		 test	 cl, cl
  01899	0f 85 46 ff ff
	ff		 jne	 $L72047
  0189f	5f		 pop	 edi
  018a0	5e		 pop	 esi
  018a1	5d		 pop	 ebp

; 3213 :   }
; 3214 : 
; 3215 :   return( CMD_success );

  018a2	33 c0		 xor	 eax, eax
  018a4	5b		 pop	 ebx

; 3216 : }

  018a5	83 c4 10	 add	 esp, 16			; 00000010H
  018a8	c3		 ret	 0
$L72054:

; 3046 : 				break;
; 3047 : 
; 3048 : 	  		case '1':
; 3049 : 				iIndex = 1;

  018a9	b8 01 00 00 00	 mov	 eax, 1

; 3050 : 				break;

  018ae	e9 5c ff ff ff	 jmp	 $L72073
$L72055:

; 3051 : 
; 3052 : 	  		case '2':
; 3053 : 				iIndex = 2;

  018b3	8b c5		 mov	 eax, ebp

; 3054 : 				break;

  018b5	e9 55 ff ff ff	 jmp	 $L72073
$L72056:

; 3055 : 
; 3056 : 	  		case '3':
; 3057 : 				iIndex = 3;

  018ba	b8 03 00 00 00	 mov	 eax, 3

; 3058 : 				break;

  018bf	e9 4b ff ff ff	 jmp	 $L72073
$L72057:

; 3059 : 
; 3060 : 	  		case '4':
; 3061 : 				iIndex = 4;

  018c4	b8 04 00 00 00	 mov	 eax, 4

; 3062 : 				break;

  018c9	e9 41 ff ff ff	 jmp	 $L72073
$L72058:

; 3063 : 
; 3064 : 	  		case '5':
; 3065 : 				iIndex = 5;

  018ce	b8 05 00 00 00	 mov	 eax, 5

; 3066 : 				break;

  018d3	e9 37 ff ff ff	 jmp	 $L72073
$L72059:

; 3067 : 
; 3068 : 	  		case '6':
; 3069 : 				iIndex = 6;

  018d8	b8 06 00 00 00	 mov	 eax, 6

; 3070 : 				break;

  018dd	e9 2d ff ff ff	 jmp	 $L72073
$L72060:

; 3071 : 
; 3072 : 	  		case '7':
; 3073 : 				iIndex = 7;

  018e2	b8 07 00 00 00	 mov	 eax, 7

; 3074 : 				break;

  018e7	e9 23 ff ff ff	 jmp	 $L72073
$L72061:

; 3075 : 
; 3076 : 			case '8':
; 3077 : 				iIndex = 8;

  018ec	b8 08 00 00 00	 mov	 eax, 8

; 3078 : 				break;

  018f1	e9 19 ff ff ff	 jmp	 $L72073
$L72062:

; 3079 : 
; 3080 : 			case '9':
; 3081 : 				iIndex = 9;

  018f6	b8 09 00 00 00	 mov	 eax, 9

; 3082 : 				break;

  018fb	e9 0f ff ff ff	 jmp	 $L72073
$L72063:

; 3083 : 	  	
; 3084 : 			case '*':
; 3085 : 				iIndex = 10;

  01900	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH

; 3086 : 				break;

  01905	e9 05 ff ff ff	 jmp	 $L72073
$L72064:

; 3087 : 
; 3088 : 			case '#':
; 3089 : 				iIndex = 11;

  0190a	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH

; 3090 : 				break;

  0190f	e9 fb fe ff ff	 jmp	 $L72073
$L72065:

; 3091 : 
; 3092 : 	  		case 'a':
; 3093 : 	  		case 'A':
; 3094 : 				iIndex = 12;

  01914	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH

; 3095 : 				break;

  01919	e9 f1 fe ff ff	 jmp	 $L72073
$L72066:

; 3096 : 
; 3097 : 			case 'b':
; 3098 : 	  		case 'B':
; 3099 : 				iIndex = 13;

  0191e	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH

; 3100 : 				break;

  01923	e9 e7 fe ff ff	 jmp	 $L72073
$L72067:

; 3101 : 
; 3102 : 	  		case 'c':
; 3103 : 	  		case 'C':
; 3104 : 				iIndex = 14;

  01928	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH

; 3105 : 				break;

  0192d	e9 dd fe ff ff	 jmp	 $L72073
$L72068:

; 3106 : 
; 3107 : 	  		case 'd':
; 3108 : 	  		case 'D':
; 3109 : 				iIndex = 15;

  01932	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH

; 3110 : 				break;

  01937	e9 d3 fe ff ff	 jmp	 $L72073
$L72069:

; 3111 : 
; 3112 : 	  		default:
; 3113 : 
; 3114 : 				if  (( szSingleDigit[0] == '-' )
; 3115 : 	  			|| ( szSingleDigit[0] == ',' )
; 3116 : 	  			|| ( szSingleDigit[0] == ' ' ))

  0193c	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  0193f	74 0a		 je	 SHORT $L72071
  01941	80 f9 2c	 cmp	 cl, 44			; 0000002cH
  01944	74 05		 je	 SHORT $L72071
  01946	80 f9 20	 cmp	 cl, 32			; 00000020H
  01949	75 3c		 jne	 SHORT $L72070
$L72071:

; 3123 : 				}
; 3124 : 
; 3125 : 			break;
; 3126 : 	  } /* switch ( szSingleDigit[0] ) */
; 3127 : 
; 3128 : 	/******************************************************************/
; 3129 : 	/*  If the index == 16 then send a tone packet with a duration of */
; 3130 : 	/*  DTMF_PAUSE_TIME_IN_MSEC and both tone amplitudes set to zero. */
; 3131 : 	/*  Otherwise send DTMF Tones with the default high tone and low  */
; 3132 : 	/*  tone amplitudes.                                              */
; 3133 : 	/*                                                                */
; 3134 : 	/*  The packet format here is different than the DTC07. The ramp  */
; 3135 : 	/*  duration has been eliminated. The tone generation software    */
; 3136 : 	/*  automatically provides 3 msec. cosine squared tapering for    */
; 3137 : 	/*  the tone pulse rise and fall time.                            */
; 3138 : 	/*                                                                */
; 3139 : 	/*  Packet Index     Packet Data                 Value            */
; 3140 : 	/*                                                                */
; 3141 : 	/*      0            Command Word              SPC_type_tone      */
; 3142 : 	/*      1            Tone Duration (msec.)     0 to ?             */
; 3143 : 	/*      2            Tone 0 Frequency          0 to Fs/2          */
; 3144 : 	/*      3            Tone 0 Amplitude          0 to 32767         */
; 3145 : 	/*      4            Tone 1 Frequency          0 to Fs/2          */
; 3146 : 	/*      5            Tone 1 Amplitude          0 to 32767         */
; 3147 : 	/*                                                                */
; 3148 : 	/******************************************************************/
; 3149 : 
; 3150 : 	if ( iIndex == 16 )
; 3151 : 	{
; 3152 : 	  /****************************************************************/
; 3153 : 	  /*  Silent interval.                                            */
; 3154 : 	  /****************************************************************/
; 3155 : 
; 3156 : 	  pipe[0] = SPC_type_tone;
; 3157 : 	  pipe[1] = DTMF_PAUSE_TIME_IN_MSEC;
; 3158 : 	  pipe[2] = 1000;
; 3159 : 	  pipe[3] = 0;

  0194b	33 c0		 xor	 eax, eax
  0194d	66 89 6c 24 14	 mov	 WORD PTR _pipe$[esp+32], bp
  01952	66 89 44 24 1a	 mov	 WORD PTR _pipe$[esp+38], ax

; 3160 : 	  pipe[4] = 1000;
; 3161 : 	  pipe[5] = 0;

  01957	66 89 44 24 1e	 mov	 WORD PTR _pipe$[esp+42], ax
  0195c	66 89 5c 24 16	 mov	 WORD PTR _pipe$[esp+34], bx
  01961	66 89 7c 24 18	 mov	 WORD PTR _pipe$[esp+36], di
  01966	66 89 7c 24 1c	 mov	 WORD PTR _pipe$[esp+40], di

; 3162 : 
; 3163 : /* GL 04/21/1997  change this for OSF build */
; 3164 : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 3165 :       cm_util_write_pipe(pKsd_t, pKsd_t->vtm_pipe, pipe, 6 );

  0196b	8b 8e 9c 02 00
	00		 mov	 ecx, DWORD PTR [esi+668]
  01971	8d 44 24 14	 lea	 eax, DWORD PTR _pipe$[esp+32]
  01975	6a 06		 push	 6
  01977	50		 push	 eax
  01978	51		 push	 ecx
  01979	56		 push	 esi
  0197a	e8 00 00 00 00	 call	 _cm_util_write_pipe
  0197f	83 c4 10	 add	 esp, 16			; 00000010H

; 3166 : #endif
; 3167 : 
; 3168 : 	}
; 3169 : 	else

  01982	e9 05 ff ff ff	 jmp	 $L72074
$L72070:
  01987	5f		 pop	 edi
  01988	5e		 pop	 esi
  01989	5d		 pop	 ebp

; 3117 : 				{
; 3118 : 	  				iIndex = 16;
; 3119 : 				}
; 3120 : 				else
; 3121 : 				{
; 3122 : 	  				return( CMD_bad_string );

  0198a	b8 01 00 00 00	 mov	 eax, 1
  0198f	5b		 pop	 ebx

; 3216 : }

  01990	83 c4 10	 add	 esp, 16			; 00000010H
  01993	c3		 ret	 0
$L72048:
  01994	5f		 pop	 edi
  01995	5e		 pop	 esi
  01996	5d		 pop	 ebp

; 3213 :   }
; 3214 : 
; 3215 :   return( CMD_success );

  01997	33 c0		 xor	 eax, eax
  01999	5b		 pop	 ebx

; 3216 : }

  0199a	83 c4 10	 add	 esp, 16			; 00000010H
  0199d	c3		 ret	 0
  0199e	8b ff		 npad	 2
$L72204:
  019a0	00 00 00 00	 DD	 $L72064
  019a4	00 00 00 00	 DD	 $L72063
  019a8	00 00 00 00	 DD	 $L72053
  019ac	00 00 00 00	 DD	 $L72054
  019b0	00 00 00 00	 DD	 $L72055
  019b4	00 00 00 00	 DD	 $L72056
  019b8	00 00 00 00	 DD	 $L72057
  019bc	00 00 00 00	 DD	 $L72058
  019c0	00 00 00 00	 DD	 $L72059
  019c4	00 00 00 00	 DD	 $L72060
  019c8	00 00 00 00	 DD	 $L72061
  019cc	00 00 00 00	 DD	 $L72062
  019d0	00 00 00 00	 DD	 $L72065
  019d4	00 00 00 00	 DD	 $L72066
  019d8	00 00 00 00	 DD	 $L72067
  019dc	00 00 00 00	 DD	 $L72068
  019e0	00 00 00 00	 DD	 $L72069
$L72203:
  019e4	00		 DB	 0
  019e5	10		 DB	 16			; 00000010H
  019e6	10		 DB	 16			; 00000010H
  019e7	10		 DB	 16			; 00000010H
  019e8	10		 DB	 16			; 00000010H
  019e9	10		 DB	 16			; 00000010H
  019ea	10		 DB	 16			; 00000010H
  019eb	01		 DB	 1
  019ec	10		 DB	 16			; 00000010H
  019ed	10		 DB	 16			; 00000010H
  019ee	10		 DB	 16			; 00000010H
  019ef	10		 DB	 16			; 00000010H
  019f0	10		 DB	 16			; 00000010H
  019f1	02		 DB	 2
  019f2	03		 DB	 3
  019f3	04		 DB	 4
  019f4	05		 DB	 5
  019f5	06		 DB	 6
  019f6	07		 DB	 7
  019f7	08		 DB	 8
  019f8	09		 DB	 9
  019f9	0a		 DB	 10			; 0000000aH
  019fa	0b		 DB	 11			; 0000000bH
  019fb	10		 DB	 16			; 00000010H
  019fc	10		 DB	 16			; 00000010H
  019fd	10		 DB	 16			; 00000010H
  019fe	10		 DB	 16			; 00000010H
  019ff	10		 DB	 16			; 00000010H
  01a00	10		 DB	 16			; 00000010H
  01a01	10		 DB	 16			; 00000010H
  01a02	0c		 DB	 12			; 0000000cH
  01a03	0d		 DB	 13			; 0000000dH
  01a04	0e		 DB	 14			; 0000000eH
  01a05	0f		 DB	 15			; 0000000fH
  01a06	10		 DB	 16			; 00000010H
  01a07	10		 DB	 16			; 00000010H
  01a08	10		 DB	 16			; 00000010H
  01a09	10		 DB	 16			; 00000010H
  01a0a	10		 DB	 16			; 00000010H
  01a0b	10		 DB	 16			; 00000010H
  01a0c	10		 DB	 16			; 00000010H
  01a0d	10		 DB	 16			; 00000010H
  01a0e	10		 DB	 16			; 00000010H
  01a0f	10		 DB	 16			; 00000010H
  01a10	10		 DB	 16			; 00000010H
  01a11	10		 DB	 16			; 00000010H
  01a12	10		 DB	 16			; 00000010H
  01a13	10		 DB	 16			; 00000010H
  01a14	10		 DB	 16			; 00000010H
  01a15	10		 DB	 16			; 00000010H
  01a16	10		 DB	 16			; 00000010H
  01a17	10		 DB	 16			; 00000010H
  01a18	10		 DB	 16			; 00000010H
  01a19	10		 DB	 16			; 00000010H
  01a1a	10		 DB	 16			; 00000010H
  01a1b	10		 DB	 16			; 00000010H
  01a1c	10		 DB	 16			; 00000010H
  01a1d	10		 DB	 16			; 00000010H
  01a1e	10		 DB	 16			; 00000010H
  01a1f	10		 DB	 16			; 00000010H
  01a20	10		 DB	 16			; 00000010H
  01a21	10		 DB	 16			; 00000010H
  01a22	0c		 DB	 12			; 0000000cH
  01a23	0d		 DB	 13			; 0000000dH
  01a24	0e		 DB	 14			; 0000000eH
  01a25	0f		 DB	 15			; 0000000fH
_cm_cmd_dial ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_digitized
_TEXT	SEGMENT
_cm_cmd_digitized PROC NEAR

; 3289 : 	
; 3290 : #ifdef MSDOS
; 3291 : 	PKSD_T pKsd_t = phTTS->pKernelShareData; 
; 3292 : 	DT_PIPE_T pipe_value;
; 3293 : 
; 3294 : #ifndef DTEX
; 3295 : 	if(cm_cmd_sync(phTTS) == CMD_flushing)
; 3296 : 		return(CMD_flushing);
; 3297 : 	pKsd_t->spc_mode = SPC_mode_digital;
; 3298 : 	signal_semaphore(&pKsd_t->isa_sem);
; 3299 : 	wait_semaphore(&pKsd_t->text_sync);
; 3300 : 
; 3301 : 	pipe_value = LAST_VOICE;
; 3302 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,&pipe_value,1);
; 3303 : #endif /*DTEX*/
; 3304 : 
; 3305 : #endif /* MSDOS */
; 3306 : 	return(CMD_success);

  01a30	33 c0		 xor	 eax, eax

; 3307 : }

  01a32	c3		 ret	 0
_cm_cmd_digitized ENDP
_phTTS$ = 8
_cm_cmd_debug PROC NEAR

; 3324 : {

  01a40	53		 push	 ebx
  01a41	56		 push	 esi

; 3325 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  01a42	8b 74 24 0c	 mov	 esi, DWORD PTR _phTTS$[esp+4]
  01a46	57		 push	 edi

; 3326 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 3327 : 
; 3328 : 	cm_cmd_sync(phTTS);				/* mfg 04/27/1998 added 2 cm_cmd_sync*/

  01a47	56		 push	 esi
  01a48	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  01a4b	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  01a4e	e8 00 00 00 00	 call	 _cm_cmd_sync

; 3329 : 	pKsd_t->debug_switch = pCmd_t->params[0];

  01a53	66 8b 03	 mov	 ax, WORD PTR [ebx]

; 3330 : 	cm_cmd_sync(phTTS);

  01a56	56		 push	 esi
  01a57	66 89 87 40 06
	00 00		 mov	 WORD PTR [edi+1600], ax
  01a5e	e8 00 00 00 00	 call	 _cm_cmd_sync
  01a63	83 c4 08	 add	 esp, 8

; 3331 : 
; 3332 : 	return(CMD_success);

  01a66	33 c0		 xor	 eax, eax
  01a68	5f		 pop	 edi
  01a69	5e		 pop	 esi
  01a6a	5b		 pop	 ebx

; 3333 : }

  01a6b	c3		 ret	 0
_cm_cmd_debug ENDP
_phTTS$ = 8
_cm_cmd_gender PROC NEAR

; 3350 : 	int cmd_type;
; 3351 : 	
; 3352 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  01a70	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  01a74	56		 push	 esi
  01a75	8b 70 08	 mov	 esi, DWORD PTR [eax+8]

; 3353 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  01a78	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 3354 : 
; 3355 : 	cmd_type =  cm_util_string_match(gender_options,pCmd_t->pString[0]);

  01a7b	8b 80 80 02 00
	00		 mov	 eax, DWORD PTR [eax+640]
  01a81	50		 push	 eax
  01a82	68 00 00 00 00	 push	 OFFSET FLAT:_gender_options
  01a87	e8 00 00 00 00	 call	 _cm_util_string_match
  01a8c	83 c4 08	 add	 esp, 8

; 3356 : 	if (cmd_type == NO_STRING_MATCH)

  01a8f	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  01a94	75 07		 jne	 SHORT $L72089

; 3357 : 		return(CMD_bad_string);

  01a96	b8 01 00 00 00	 mov	 eax, 1
  01a9b	5e		 pop	 esi

; 3378 : 	}
; 3379 : 	return(CMD_success);
; 3380 : }

  01a9c	c3		 ret	 0
$L72089:

; 3358 : 
; 3359 : 	switch (cmd_type)
; 3360 : 	{

  01a9d	83 e8 00	 sub	 eax, 0
  01aa0	74 27		 je	 SHORT $L72094
  01aa2	48		 dec	 eax
  01aa3	74 17		 je	 SHORT $L72095
  01aa5	48		 dec	 eax
  01aa6	74 07		 je	 SHORT $L72096

; 3373 : 			return(CMD_success);
; 3374 : 			break;
; 3375 : 
; 3376 : 		default:
; 3377 : 			return(CMD_bad_string);

  01aa8	b8 01 00 00 00	 mov	 eax, 1
  01aad	5e		 pop	 esi

; 3378 : 	}
; 3379 : 	return(CMD_success);
; 3380 : }

  01aae	c3		 ret	 0
$L72096:

; 3368 : 			return(CMD_success);
; 3369 : 			break;
; 3370 : 
; 3371 : 		case 2: /* feminine */
; 3372 : 			pKsd_t->gender_switch = 3;

  01aaf	66 c7 86 42 06
	00 00 03 00	 mov	 WORD PTR [esi+1602], 3
  01ab8	33 c0		 xor	 eax, eax
  01aba	5e		 pop	 esi

; 3378 : 	}
; 3379 : 	return(CMD_success);
; 3380 : }

  01abb	c3		 ret	 0
$L72095:

; 3364 : 			break;
; 3365 : 
; 3366 : 		case 1: /* neuter */
; 3367 : 			pKsd_t->gender_switch = 2;

  01abc	66 c7 86 42 06
	00 00 02 00	 mov	 WORD PTR [esi+1602], 2
  01ac5	33 c0		 xor	 eax, eax
  01ac7	5e		 pop	 esi

; 3378 : 	}
; 3379 : 	return(CMD_success);
; 3380 : }

  01ac8	c3		 ret	 0
$L72094:

; 3361 : 		case 0: /* masculine */
; 3362 : 			pKsd_t->gender_switch = 1;

  01ac9	66 c7 86 42 06
	00 00 01 00	 mov	 WORD PTR [esi+1602], 1

; 3363 : 			return(CMD_success);

  01ad2	33 c0		 xor	 eax, eax
  01ad4	5e		 pop	 esi

; 3378 : 	}
; 3379 : 	return(CMD_success);
; 3380 : }

  01ad5	c3		 ret	 0
_cm_cmd_gender ENDP
_TEXT	ENDS
END
