	TITLE	D:\work\product\dapi\src\Lts\lsa_task.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_verbs
_DATA	SEGMENT
_verbs	DB	'are', 00H
	ORG $+1
	ORG $+3
	DD	067H
	DD	06H
	DD	01aH
	DD	00H
	DD	00H
	DD	0820020H
	DB	'had', 00H
	ORG $+1
	ORG $+3
	DD	01cH
	DD	067H
	DD	04H
	DD	030H
	DD	00H
	DD	0820100H
	DB	'is', 00H
	ORG $+2
	ORG $+3
	DD	067H
	DD	02H
	DD	02aH
	DD	00H
	DD	00H
	DD	0820020H
	DB	'was', 00H
	ORG $+1
	ORG $+3
	DD	018H
	DD	067H
	DD	011H
	DD	02aH
	DD	00H
	DD	0820020H
	DB	'were', 00H
	ORG $+3
	DD	018H
	DD	067H
	DD	0fH
	DD	00H
	DD	00H
	DD	0820020H
	DB	'will', 00H
	ORG $+3
	DD	018H
	DD	067H
	DD	02H
	DD	01eH
	DD	00H
	DD	0820408H
_DATA	ENDS
PUBLIC	_ls_task_main
PUBLIC	_ls_task_readword
PUBLIC	_ls_task_do_right_punct
PUBLIC	_ls_task_spell_word
PUBLIC	_ls_task_read_next_word
PUBLIC	_ls_task_set_what_state
PUBLIC	_ls_task_find_end_of_word
PUBLIC	_ls_task_spell_mode
PUBLIC	_ls_task_minidic_search
PUBLIC	_ls_task_math_mode
PUBLIC	_ls_task_dictionary_search
PUBLIC	_ls_task_strip_left_punctuation
PUBLIC	_ls_task_strip_right_punctuation
PUBLIC	_ls_task_spell_all_punct
PUBLIC	_ls_task_dictionary_after_punct
PUBLIC	_ls_task_spell_vs_speak
PUBLIC	_ls_task_single_letter_spell_rules
PUBLIC	_ls_task_remove_case
PUBLIC	_ls_task_Dr_St_process
PUBLIC	_ls_task_set_sign_flag
PUBLIC	_ls_task_currency_processing
PUBLIC	_ls_task_date_processing
PUBLIC	_ls_task_frac_processing
PUBLIC	_ls_task_plain_number_processing
PUBLIC	_ls_task_part_number
PUBLIC	_ls_task_process_word
EXTRN	_ls_util_is_name:NEAR
EXTRN	__chkstk:NEAR
EXTRN	_ls_rule_phone_free:NEAR
EXTRN	_ls_util_read_item:NEAR
EXTRN	_ls_util_dump_cword:NEAR
EXTRN	__imp__printf:NEAR
_DATA	SEGMENT
$SG72248 DB	'LTS debug switch description:', 0aH, 00H
	ORG $+1
$SG72249 DB	'4001 -- Incoming data string  4002 -- Dictionary HIT/MIS'
	DB	'S (0) for miss', 0aH, 00H
$SG72250 DB	'4004 -- Suffix stripping HIT  4008 -- Display MISS word,'
	DB	' not speaking', 0aH, 00H
	ORG $+1
$SG72251 DB	'4010 -- Dict. search trace    4020 -- Homograph rule HIT'
	DB	0aH, 00H
	ORG $+2
$SG72252 DB	'4040 -- Form class array dump 4080 -- ACNA name type', 0aH
	DB	00H
	ORG $+2
$SG72253 DB	'4100 -- log form class        4200 -- dump data before w'
	DB	'rite_pipe', 0aH, 00H
	ORG $+1
$SG72254 DB	'4400 -- Spell it rule HIT     4800 -- drain data before '
	DB	'write_pipe', 0aH, 00H
$SG72256 DB	'LTS Input:', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = -5656
_rlp$ = -5660
_elp$ = -5636
_lp1$ = -5644
_pKsd_t$ = -5648
_pLts_t$ = -5640
_pnode$ = -4608
_origword$ = -5632
_namef$ = -5652
_ls_task_main PROC NEAR

; 216  : {

  00000	b8 1c 16 00 00	 mov	 eax, 5660		; 0000161cH
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	53		 push	 ebx

; 217  : 	/* of special words.*/ 
; 218  : 	int     done, array_i=0;
; 219  :  	LETTER  *tmp;
; 220  : 	LETTER  *llp;
; 221  : 	LETTER  *rlp;
; 222  : 	LETTER  *elp;
; 223  : 	LETTER  *lp1;
; 224  : 	PHONE   *pp; 
; 225  : 	PKSD_T  pKsd_t;
; 226  : 	PLTS_T  pLts_t;
; 227  : 	PHONE   pnode[NPNODE];                  /* Phoneme pool.                */
; 228  : 	/* MGS 6/16/97 BATS #387 Added to allow case to reach ls_task_process_word */
; 229  : 	LETTER	origword[NGWORD];	
; 230  : 	
; 231  : 	int namef=0; 							/* this flag seems useless */ 
; 232  : 	
; 233  : 	/* printf("this is the start of lts\n"); */
; 234  : 	
; 235  : 		
; 236  : 	pKsd_t = phTTS->pKernelShareData;

  0000b	8b 9c 24 24 16
	00 00		 mov	 ebx, DWORD PTR _phTTS$[esp+5660]
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  00017	57		 push	 edi

; 237  : 	pLts_t = phTTS->pLTSThreadData;	

  00018	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  0001b	33 c0		 xor	 eax, eax
  0001d	89 44 24 18	 mov	 DWORD PTR _namef$[esp+5676], eax

; 238  : 	pLts_t->isnumabr=0;
; 239  : 
; 240  :     pLts_t->pflp = 0;   
; 241  : #ifdef MSDOS
; 242  : 	pKsd_t->lang_curr = LANG_none; 
; 243  : #endif
; 244  : #ifdef SPANISH
; 245  :     pLts_t->got_quote = 0;
; 246  : #endif  
; 247  :     memset(&(pLts_t->nitem),0,sizeof(ITEM));
; 248  :     memset(&(pLts_t->citem),0,sizeof(ITEM));

  00021	33 d2		 xor	 edx, edx
  00023	8d 8f 0a 09 00
	00		 lea	 ecx, DWORD PTR [edi+2314]
  00029	89 87 fc 08 00
	00		 mov	 DWORD PTR [edi+2300], eax
  0002f	89 87 04 04 00
	00		 mov	 DWORD PTR [edi+1028], eax
  00035	89 74 24 1c	 mov	 DWORD PTR _pKsd_t$[esp+5676], esi
  00039	89 01		 mov	 DWORD PTR [ecx], eax
  0003b	89 7c 24 24	 mov	 DWORD PTR _pLts_t$[esp+5676], edi

; 249  : 	
; 250  : 	pp = &pnode[0];                         		/* Pool of PHONE nodes. */

  0003f	8d ac 24 2c 04
	00 00		 lea	 ebp, DWORD PTR _pnode$[esp+5676]
  00046	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00049	66 89 41 08	 mov	 WORD PTR [ecx+8], ax
  0004d	8d 87 00 09 00
	00		 lea	 eax, DWORD PTR [edi+2304]
  00053	89 97 00 09 00
	00		 mov	 DWORD PTR [edi+2304], edx
  00059	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0005c	66 89 50 08	 mov	 WORD PTR [eax+8], dx
$L72242:

; 251  : 	
; 252  : 	while (pp < &pnode[NPNODE])         			/* free all the phonemes */
; 253  : 	{
; 254  : 		ls_rule_phone_free(pLts_t,pp);

  00060	55		 push	 ebp
  00061	57		 push	 edi
  00062	e8 00 00 00 00	 call	 _ls_rule_phone_free

; 255  : 		++pp;

  00067	83 c5 24	 add	 ebp, 36			; 00000024H
  0006a	8d 8c 24 34 16
	00 00		 lea	 ecx, DWORD PTR _pnode$[esp+10292]
  00071	83 c4 08	 add	 esp, 8
  00074	3b e9		 cmp	 ebp, ecx
  00076	72 e8		 jb	 SHORT $L72242

; 256  : 	}
; 257  : 	
; 258  : 	pLts_t->wstate = UNK_WH;                        /* Start of sentence.   */

  00078	33 ed		 xor	 ebp, ebp

; 259  : 	pLts_t->lphone = WBOUND;                        /* Out of band.         */
; 260  : 	ls_util_read_item(phTTS);	

  0007a	53		 push	 ebx
  0007b	66 89 af c4 08
	00 00		 mov	 WORD PTR [edi+2244], bp
  00082	66 c7 87 36 04
	00 00 6f 00	 mov	 WORD PTR [edi+1078], 111 ; 0000006fH
  0008b	e8 00 00 00 00	 call	 _ls_util_read_item

; 261  : 	ls_task_readword(phTTS,&(pLts_t->cword[0]));	

  00090	8d 87 14 09 00
	00		 lea	 eax, DWORD PTR [edi+2324]
  00096	50		 push	 eax
  00097	53		 push	 ebx
  00098	e8 00 00 00 00	 call	 _ls_task_readword

; 262  : 	pLts_t->fc_index = 0;

  0009d	89 af bc 08 00
	00		 mov	 DWORD PTR [edi+2236], ebp

; 334  : 			{
; 335  : 				namef=0;
; 336  : 				/*clear pron name even if we did it with the dic*/
; 337  : 				pKsd_t->pronflag &= (~PRON_ACNA_NAME);

  000a3	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__printf
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ac	c7 87 c0 08 00
	00 ff ff ff ff	 mov	 DWORD PTR [edi+2240], -1
$L72245:

; 263  : 	pLts_t->old_fc_index = -1;
; 264  : 	/*
; 265  : 	 * Top of the word processing main loop.
; 266  : 	 * Called with a word in "cword" and the delimiter in
; 267  : 	 * "pLts_t->citem". Look at the word, and update the "which" state
; 268  : 	 * if this is the first word in a sentence. Allow the
; 269  : 	 * "W" to be in either case. Don't get fooled by
; 270  : 	 * strippable punctuation.
; 271  : 	 */
; 272  : 
; 273  : 	while (1)
; 274  : 	{
; 275  : 
; 276  : 		/* ET 6/9/1998: BATS #691
; 277  : 		copied from ...\dapi\src\CMD\cm_pars.c to get the debug win to come up */
; 278  : #if defined (WIN32) && defined (PRINTFDEBUG)
; 279  : 		/* open debug window for window environement */
; 280  : 		if (/*(windbg_flag == 0) && ET 6/9/1998*/(pKsd_t->debug_switch != 0 || pKsd_t->logflag != 0))
; 281  : 		{
; 282  : 			WINstart_thread();
; 283  : 		/*	windbg_flag = 1;	ET 6/9/1998: not defined in ls_task. */ 
; 284  : 		}
; 285  : #endif
; 286  : 
; 287  : 		/* display debug switch manual once */
; 288  : 		if (pKsd_t->debug_switch == 0x4fff)

  000b6	66 81 be 78 04
	00 00 ff 4f	 cmp	 WORD PTR [esi+1144], 20479 ; 00004fffH
  000bf	75 3d		 jne	 SHORT $L72247

; 289  : 		{
; 290  : 			printf("LTS debug switch description:\n");

  000c1	68 00 00 00 00	 push	 OFFSET FLAT:$SG72248
  000c6	ff d5		 call	 ebp

; 291  : 			printf("4001 -- Incoming data string  4002 -- Dictionary HIT/MISS (0) for miss\n");

  000c8	68 00 00 00 00	 push	 OFFSET FLAT:$SG72249
  000cd	ff d5		 call	 ebp

; 292  : 			printf("4004 -- Suffix stripping HIT  4008 -- Display MISS word, not speaking\n");

  000cf	68 00 00 00 00	 push	 OFFSET FLAT:$SG72250
  000d4	ff d5		 call	 ebp

; 293  : 			printf("4010 -- Dict. search trace    4020 -- Homograph rule HIT\n");

  000d6	68 00 00 00 00	 push	 OFFSET FLAT:$SG72251
  000db	ff d5		 call	 ebp

; 294  : 			printf("4040 -- Form class array dump 4080 -- ACNA name type\n");

  000dd	68 00 00 00 00	 push	 OFFSET FLAT:$SG72252
  000e2	ff d5		 call	 ebp

; 295  : 			printf("4100 -- log form class        4200 -- dump data before write_pipe\n");

  000e4	68 00 00 00 00	 push	 OFFSET FLAT:$SG72253
  000e9	ff d5		 call	 ebp

; 296  : 			printf("4400 -- Spell it rule HIT     4800 -- drain data before write_pipe\n");

  000eb	68 00 00 00 00	 push	 OFFSET FLAT:$SG72254
  000f0	ff d5		 call	 ebp
  000f2	83 c4 1c	 add	 esp, 28			; 0000001cH

; 297  : 						
; 298  : 			/* reset to 0 again */
; 299  : 			pKsd_t->debug_switch = 0;

  000f5	66 c7 86 78 04
	00 00 00 00	 mov	 WORD PTR [esi+1144], 0
$L72247:

; 300  : 		}
; 301  : 	
; 302  : 		/* debug switch */
; 303  : 		if (DT_DBG(LTS_DBG,0x001))

  000fe	66 8b 86 78 04
	00 00		 mov	 ax, WORD PTR [esi+1144]
  00105	f6 c4 40	 test	 ah, 64			; 00000040H
  00108	74 18		 je	 SHORT $L72255
  0010a	a8 01		 test	 al, 1
  0010c	74 14		 je	 SHORT $L72255

; 304  : 		{
; 305  : 			ls_util_dump_cword (pLts_t->cword, "LTS Input:");

  0010e	8d 87 14 09 00
	00		 lea	 eax, DWORD PTR [edi+2324]
  00114	68 00 00 00 00	 push	 OFFSET FLAT:$SG72256
  00119	50		 push	 eax
  0011a	e8 00 00 00 00	 call	 _ls_util_dump_cword
  0011f	83 c4 08	 add	 esp, 8
$L72255:

; 306  : 		}
; 307  : #ifdef DUMP_WORD
; 308  : 		ls_util_dump_cword (pLts_t->cword, "ltsinput:");
; 309  : #endif
; 310  : 		done=KEEP_SEARCHING;
; 311  : 		/* 
; 312  : 		 *...tek block here to make sure PH has something to do and that
; 313  : 		 *	we don't hog the CPU.. 
; 314  : 		 */
; 315  : #ifdef MSDOS
; 316  : 		block(NULL_FP);
; 317  : #endif    
; 318  : 		/* 
; 319  : 		 * xxxx eab WE added code to allow for double abreviations such as
; 320  : 		 *	4 sq. ft. but we need to block these abbreviations in normal
; 321  : 		 *	contexts so things like in and ha don't come out as hectors
; 322  : 		 *	and inches. so The 2nd abrreviation checker (nabtab)
; 323  : 		 *	is blocked unless the first time after a look ahead from
; 324  : 		 *	a number hit in the first case using the pLts_t->isnumabr being
; 325  : 		 *	set
; 326  : 		 */
; 327  : 
; 328  : 		if(pLts_t->isnumabr)

  00122	8b 87 fc 08 00
	00		 mov	 eax, DWORD PTR [edi+2300]
  00128	33 c9		 xor	 ecx, ecx
  0012a	3b c1		 cmp	 eax, ecx
  0012c	74 07		 je	 SHORT $L72257

; 329  : 			pLts_t->isnumabr--;

  0012e	48		 dec	 eax
  0012f	89 87 fc 08 00
	00		 mov	 DWORD PTR [edi+2300], eax
$L72257:

; 330  : 
; 331  : 		if( (pKsd_t->pronflag & PRON_ACNA_NAME) !=0)

  00135	8b 86 0c 02 00
	00		 mov	 eax, DWORD PTR [esi+524]
  0013b	a8 04		 test	 al, 4
  0013d	74 1b		 je	 SHORT $L72258

; 332  : 		{
; 333  : 			if(namef == 1)

  0013f	83 7c 24 18 01	 cmp	 DWORD PTR _namef$[esp+5676], 1
  00144	75 0e		 jne	 SHORT $L72259

; 334  : 			{
; 335  : 				namef=0;
; 336  : 				/*clear pron name even if we did it with the dic*/
; 337  : 				pKsd_t->pronflag &= (~PRON_ACNA_NAME);

  00146	24 fb		 and	 al, -5			; fffffffbH
  00148	89 4c 24 18	 mov	 DWORD PTR _namef$[esp+5676], ecx
  0014c	89 86 0c 02 00
	00		 mov	 DWORD PTR [esi+524], eax

; 338  : 			}
; 339  : 			else

  00152	eb 0a		 jmp	 SHORT $L72261
$L72259:

; 340  : 			{
; 341  : 				namef++;

  00154	ff 44 24 18	 inc	 DWORD PTR _namef$[esp+5676]

; 342  : 			}
; 343  : 		}
; 344  : 		else

  00158	eb 04		 jmp	 SHORT $L72261
$L72258:

; 345  : 		{
; 346  : 			namef=0;

  0015a	89 4c 24 18	 mov	 DWORD PTR _namef$[esp+5676], ecx
$L72261:

; 347  : 		}
; 348  : 	
; 349  : 		/* find out if one of the what words are at the beginning of the clause */
; 350  : 		done=ls_task_set_what_state(phTTS,pLts_t);

  0015e	57		 push	 edi
  0015f	53		 push	 ebx
  00160	e8 00 00 00 00	 call	 _ls_task_set_what_state
  00165	83 c4 08	 add	 esp, 8

; 351  : 
; 352  : 		if (!done)

  00168	85 c0		 test	 eax, eax
  0016a	0f 85 51 02 00
	00		 jne	 $L72285

; 353  : 		{
; 354  : 			/* find the end of the word */
; 355  : 			llp = &(pLts_t->cword[0]);

  00170	8d b7 14 09 00
	00		 lea	 esi, DWORD PTR [edi+2324]

; 356  : 			ls_task_find_end_of_word(llp,&rlp,&elp);

  00176	8d 54 24 28	 lea	 edx, DWORD PTR _elp$[esp+5676]
  0017a	8d 4c 24 10	 lea	 ecx, DWORD PTR _rlp$[esp+5676]
  0017e	8b c6		 mov	 eax, esi
  00180	52		 push	 edx
  00181	51		 push	 ecx
  00182	50		 push	 eax
  00183	89 44 24 20	 mov	 DWORD PTR _llp$[esp+5688], eax
  00187	e8 00 00 00 00	 call	 _ls_task_find_end_of_word

; 357  : #ifdef LS1DEBUG
; 358  : 			printf("after find end of word ");
; 359  : 			printf("left=%u  right=%u\n",llp,rlp);
; 360  : #endif
; 361  : 			/*
; 362  : 			 * Bow out quickly on null words.
; 363  : 			 * These happen when you type something like
; 364  : 			 * "[ax] there.". The schwa gets copied right into
; 365  : 			 * the output, and the current word is null.
; 366  : 			 */
; 367  : 			if (llp == rlp) 

  0018c	8b 44 24 20	 mov	 eax, DWORD PTR _llp$[esp+5688]
  00190	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rlp$[esp+5688]
  00194	83 c4 0c	 add	 esp, 12			; 0000000cH
  00197	3b c1		 cmp	 eax, ecx
  00199	75 1b		 jne	 SHORT $L72941

; 368  : 			{
; 369  : 				ls_task_do_right_punct(phTTS,MISS);

  0019b	6a 00		 push	 0
  0019d	53		 push	 ebx
  0019e	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 370  : 				ls_task_readword(phTTS,&(pLts_t->cword[0]));

  001a3	56		 push	 esi
  001a4	53		 push	 ebx
  001a5	e8 00 00 00 00	 call	 _ls_task_readword

; 371  : 				continue;

  001aa	8b 74 24 2c	 mov	 esi, DWORD PTR _pKsd_t$[esp+5692]
  001ae	83 c4 10	 add	 esp, 16			; 00000010H
  001b1	e9 00 ff ff ff	 jmp	 $L72245
$L72941:

; 372  : 			}
; 373  : 		}
; 374  : 		if (!done)
; 375  : 			done=ls_task_spell_mode(phTTS,llp,rlp);

  001b6	51		 push	 ecx
  001b7	50		 push	 eax
  001b8	53		 push	 ebx
  001b9	e8 00 00 00 00	 call	 _ls_task_spell_mode
  001be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 376  : 		if (!done)

  001c1	85 c0		 test	 eax, eax
  001c3	0f 85 f4 01 00
	00		 jne	 $L72949

; 377  : 			done=ls_task_minidic_search(phTTS,llp,rlp); 

  001c9	8b 54 24 10	 mov	 edx, DWORD PTR _rlp$[esp+5676]
  001cd	8b 44 24 14	 mov	 eax, DWORD PTR _llp$[esp+5676]
  001d1	52		 push	 edx
  001d2	50		 push	 eax
  001d3	53		 push	 ebx
  001d4	e8 00 00 00 00	 call	 _ls_task_minidic_search
  001d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 378  : 		if (!done)

  001dc	85 c0		 test	 eax, eax
  001de	0f 85 d9 01 00
	00		 jne	 $L72949

; 379  : 			done=ls_task_math_mode(pKsd_t,llp,rlp);

  001e4	8b 4c 24 10	 mov	 ecx, DWORD PTR _rlp$[esp+5676]
  001e8	8b 54 24 14	 mov	 edx, DWORD PTR _llp$[esp+5676]
  001ec	8b 44 24 1c	 mov	 eax, DWORD PTR _pKsd_t$[esp+5676]
  001f0	51		 push	 ecx
  001f1	52		 push	 edx
  001f2	50		 push	 eax
  001f3	e8 00 00 00 00	 call	 _ls_task_math_mode
  001f8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 380  : 		if (!done)

  001fb	85 c0		 test	 eax, eax
  001fd	0f 85 ba 01 00
	00		 jne	 $L72949

; 381  : 			done=ls_task_dictionary_search(phTTS,llp,rlp);

  00203	8b 4c 24 10	 mov	 ecx, DWORD PTR _rlp$[esp+5676]
  00207	8b 54 24 14	 mov	 edx, DWORD PTR _llp$[esp+5676]
  0020b	51		 push	 ecx
  0020c	52		 push	 edx
  0020d	53		 push	 ebx
  0020e	e8 00 00 00 00	 call	 _ls_task_dictionary_search
  00213	83 c4 0c	 add	 esp, 12			; 0000000cH

; 382  : 
; 383  : 		if (!done)

  00216	85 c0		 test	 eax, eax
  00218	0f 85 9f 01 00
	00		 jne	 $L72949

; 384  : 			ls_task_strip_left_punctuation(pLts_t,&llp,rlp);        

  0021e	8b 44 24 10	 mov	 eax, DWORD PTR _rlp$[esp+5676]
  00222	8d 4c 24 14	 lea	 ecx, DWORD PTR _llp$[esp+5676]
  00226	50		 push	 eax
  00227	51		 push	 ecx
  00228	57		 push	 edi
  00229	e8 00 00 00 00	 call	 _ls_task_strip_left_punctuation

; 385  : 
; 386  : 		if (!done)
; 387  : 			ls_task_strip_right_punctuation(pLts_t,llp,&rlp);

  0022e	8b 44 24 20	 mov	 eax, DWORD PTR _llp$[esp+5688]
  00232	8d 54 24 1c	 lea	 edx, DWORD PTR _rlp$[esp+5688]
  00236	52		 push	 edx
  00237	50		 push	 eax
  00238	57		 push	 edi
  00239	e8 00 00 00 00	 call	 _ls_task_strip_right_punctuation

; 388  : 
; 389  : 		if (!done)
; 390  : 			done=ls_task_spell_all_punct(phTTS,llp,rlp,&(pLts_t->cword[0]),elp);

  0023e	8b 4c 24 40	 mov	 ecx, DWORD PTR _elp$[esp+5700]
  00242	8b 54 24 28	 mov	 edx, DWORD PTR _rlp$[esp+5700]
  00246	8b 44 24 2c	 mov	 eax, DWORD PTR _llp$[esp+5700]
  0024a	51		 push	 ecx
  0024b	56		 push	 esi
  0024c	52		 push	 edx
  0024d	50		 push	 eax
  0024e	53		 push	 ebx
  0024f	e8 00 00 00 00	 call	 _ls_task_spell_all_punct
  00254	83 c4 2c	 add	 esp, 44			; 0000002cH

; 391  : 	
; 392  : 		if (!done)

  00257	85 c0		 test	 eax, eax
  00259	0f 85 5e 01 00
	00		 jne	 $L72949

; 393  : 			done=ls_task_dictionary_after_punct(phTTS,llp,&rlp);

  0025f	8b 54 24 14	 mov	 edx, DWORD PTR _llp$[esp+5676]
  00263	8d 4c 24 10	 lea	 ecx, DWORD PTR _rlp$[esp+5676]
  00267	51		 push	 ecx
  00268	52		 push	 edx
  00269	53		 push	 ebx
  0026a	e8 00 00 00 00	 call	 _ls_task_dictionary_after_punct
  0026f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 394  : 
; 395  : 		if (!done)

  00272	85 c0		 test	 eax, eax
  00274	0f 85 43 01 00
	00		 jne	 $L72949

; 396  : 			done=ls_task_spell_vs_speak(phTTS,llp,rlp);

  0027a	8b 44 24 10	 mov	 eax, DWORD PTR _rlp$[esp+5676]
  0027e	8b 4c 24 14	 mov	 ecx, DWORD PTR _llp$[esp+5676]
  00282	50		 push	 eax
  00283	51		 push	 ecx
  00284	53		 push	 ebx
  00285	e8 00 00 00 00	 call	 _ls_task_spell_vs_speak
  0028a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 397  : 
; 398  : 		if (!done)

  0028d	85 c0		 test	 eax, eax
  0028f	0f 85 28 01 00
	00		 jne	 $L72949

; 399  : 			done=ls_task_single_letter_spell_rules(phTTS,llp,rlp);	           

  00295	8b 54 24 10	 mov	 edx, DWORD PTR _rlp$[esp+5676]
  00299	8b 44 24 14	 mov	 eax, DWORD PTR _llp$[esp+5676]
  0029d	52		 push	 edx
  0029e	50		 push	 eax
  0029f	53		 push	 ebx
  002a0	e8 00 00 00 00	 call	 _ls_task_single_letter_spell_rules
  002a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 400  : 		/*
; 401  : 		 * We are getting ready to feed this
; 402  : 		 * thing to the default processing rules. The
; 403  : 		 * first step is to fold out case distinctions and
; 404  : 		 * diacritical marks. We used to rescan the dictionary
; 405  : 		 * if anything changed; we don't do it anymore because
; 406  : 		 * the dictionary lookup was made more clever, and
; 407  : 		 * understands case distinctions.
; 408  : 		 */
; 409  : 		if (!done)

  002a8	85 c0		 test	 eax, eax
  002aa	0f 85 0d 01 00
	00		 jne	 $L72949

; 410  : 			ls_util_is_name(phTTS,llp,rlp);

  002b0	8b 4c 24 10	 mov	 ecx, DWORD PTR _rlp$[esp+5676]
  002b4	8b 54 24 14	 mov	 edx, DWORD PTR _llp$[esp+5676]
  002b8	51		 push	 ecx
  002b9	52		 push	 edx
  002ba	53		 push	 ebx
  002bb	e8 00 00 00 00	 call	 _ls_util_is_name

; 411  : 		/* MGS 6/16/97 BATS #387  added to keep oroginal word */
; 412  : 		if (!done)
; 413  : 			memcpy(&origword,&(pLts_t->cword),sizeof(origword));
; 414  : 		if (!done)
; 415  : 			ls_task_remove_case(llp,rlp);

  002c0	8b 44 24 1c	 mov	 eax, DWORD PTR _rlp$[esp+5688]
  002c4	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  002c9	8d 7c 24 38	 lea	 edi, DWORD PTR _origword$[esp+5688]
  002cd	50		 push	 eax
  002ce	f3 a5		 rep movsd
  002d0	8b 4c 24 24	 mov	 ecx, DWORD PTR _llp$[esp+5692]
  002d4	51		 push	 ecx
  002d5	e8 00 00 00 00	 call	 _ls_task_remove_case

; 416  : 
; 417  : #ifdef ENGLISH
; 418  : 		if (!done)
; 419  :             done=ls_task_Dr_St_process(phTTS,llp,rlp);

  002da	8b 54 24 24	 mov	 edx, DWORD PTR _rlp$[esp+5696]
  002de	8b 44 24 28	 mov	 eax, DWORD PTR _llp$[esp+5696]
  002e2	52		 push	 edx
  002e3	50		 push	 eax
  002e4	53		 push	 ebx
  002e5	e8 00 00 00 00	 call	 _ls_task_Dr_St_process
  002ea	83 c4 20	 add	 esp, 32			; 00000020H

; 420  : #endif
; 421  : 		if (!done)

  002ed	85 c0		 test	 eax, eax
  002ef	0f 85 c4 00 00
	00		 jne	 $L72948

; 422  : 			done=ls_task_set_sign_flag(phTTS,llp,rlp,&lp1);

  002f5	8b 54 24 10	 mov	 edx, DWORD PTR _rlp$[esp+5676]
  002f9	8b 44 24 14	 mov	 eax, DWORD PTR _llp$[esp+5676]
  002fd	8d 4c 24 20	 lea	 ecx, DWORD PTR _lp1$[esp+5676]
  00301	51		 push	 ecx
  00302	52		 push	 edx
  00303	50		 push	 eax
  00304	53		 push	 ebx
  00305	e8 00 00 00 00	 call	 _ls_task_set_sign_flag
  0030a	83 c4 10	 add	 esp, 16			; 00000010H

; 423  : 
; 424  : 		if (!done)

  0030d	85 c0		 test	 eax, eax
  0030f	0f 85 a4 00 00
	00		 jne	 $L72948

; 425  : 			done=ls_task_currency_processing(phTTS,lp1,rlp);

  00315	8b 4c 24 10	 mov	 ecx, DWORD PTR _rlp$[esp+5676]
  00319	8b 54 24 20	 mov	 edx, DWORD PTR _lp1$[esp+5676]
  0031d	51		 push	 ecx
  0031e	52		 push	 edx
  0031f	53		 push	 ebx
  00320	e8 00 00 00 00	 call	 _ls_task_currency_processing
  00325	83 c4 0c	 add	 esp, 12			; 0000000cH

; 426  : 
; 427  : 		if (!done)

  00328	85 c0		 test	 eax, eax
  0032a	0f 85 89 00 00
	00		 jne	 $L72948

; 428  : 			done=ls_task_date_processing(phTTS,llp,rlp);

  00330	8b 44 24 10	 mov	 eax, DWORD PTR _rlp$[esp+5676]
  00334	8b 4c 24 14	 mov	 ecx, DWORD PTR _llp$[esp+5676]
  00338	50		 push	 eax
  00339	51		 push	 ecx
  0033a	53		 push	 ebx
  0033b	e8 00 00 00 00	 call	 _ls_task_date_processing
  00340	83 c4 0c	 add	 esp, 12			; 0000000cH

; 429  : 
; 430  : 		if (!done)

  00343	85 c0		 test	 eax, eax
  00345	75 72		 jne	 SHORT $L72948

; 431  : 			done=ls_task_frac_processing(phTTS,lp1,rlp);

  00347	8b 54 24 10	 mov	 edx, DWORD PTR _rlp$[esp+5676]
  0034b	8b 44 24 20	 mov	 eax, DWORD PTR _lp1$[esp+5676]
  0034f	52		 push	 edx
  00350	50		 push	 eax
  00351	53		 push	 ebx
  00352	e8 00 00 00 00	 call	 _ls_task_frac_processing
  00357	83 c4 0c	 add	 esp, 12			; 0000000cH

; 432  : 
; 433  : 		if (!done)

  0035a	85 c0		 test	 eax, eax
  0035c	75 5b		 jne	 SHORT $L72948

; 434  : 			done=ls_task_plain_number_processing(phTTS,llp,rlp,lp1);

  0035e	8b 4c 24 20	 mov	 ecx, DWORD PTR _lp1$[esp+5676]
  00362	8b 54 24 10	 mov	 edx, DWORD PTR _rlp$[esp+5676]
  00366	8b 44 24 14	 mov	 eax, DWORD PTR _llp$[esp+5676]
  0036a	51		 push	 ecx
  0036b	52		 push	 edx
  0036c	50		 push	 eax
  0036d	53		 push	 ebx
  0036e	e8 00 00 00 00	 call	 _ls_task_plain_number_processing
  00373	83 c4 10	 add	 esp, 16			; 00000010H

; 435  : 
; 436  : 		/*
; 437  : 		 * Well, all of the fancy heuristics have
; 438  : 		 * failed. Either this is just an ordinary word, or it
; 439  : 		 * is garbage. This first scan looks for things that might
; 440  : 		 * actually be part numbers, and runs the standard part
; 441  : 		 * number rules.
; 442  : 		 */
; 443  : 
; 444  : 		/* MGS 6/16/97 BATS #387  added to restore oroginal word */
; 445  : 		if (!done)

  00376	85 c0		 test	 eax, eax
  00378	75 3f		 jne	 SHORT $L72948

; 446  : 			memcpy(&(pLts_t->cword),&origword,sizeof(origword));

  0037a	8b 54 24 24	 mov	 edx, DWORD PTR _pLts_t$[esp+5676]
  0037e	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00383	8d 74 24 2c	 lea	 esi, DWORD PTR _origword$[esp+5676]
  00387	8d ba 14 09 00
	00		 lea	 edi, DWORD PTR [edx+2324]
  0038d	f3 a5		 rep movsd

; 447  : 
; 448  : 		if (!done)
; 449  : 			done=ls_task_part_number(phTTS,llp,rlp);

  0038f	8b 44 24 10	 mov	 eax, DWORD PTR _rlp$[esp+5676]
  00393	8b 4c 24 14	 mov	 ecx, DWORD PTR _llp$[esp+5676]
  00397	50		 push	 eax
  00398	51		 push	 ecx
  00399	53		 push	 ebx
  0039a	e8 00 00 00 00	 call	 _ls_task_part_number
  0039f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 450  : 	
; 451  : 		
; 452  : 		if (!done)

  003a2	85 c0		 test	 eax, eax
  003a4	75 13		 jne	 SHORT $L72948

; 453  : 			done=ls_task_process_word(phTTS,llp,rlp);

  003a6	8b 54 24 10	 mov	 edx, DWORD PTR _rlp$[esp+5676]
  003aa	8b 44 24 14	 mov	 eax, DWORD PTR _llp$[esp+5676]
  003ae	52		 push	 edx
  003af	50		 push	 eax
  003b0	53		 push	 ebx
  003b1	e8 00 00 00 00	 call	 _ls_task_process_word
  003b6	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72948:
  003b9	8b 7c 24 24	 mov	 edi, DWORD PTR _pLts_t$[esp+5676]
$L72949:
  003bd	8b 74 24 1c	 mov	 esi, DWORD PTR _pKsd_t$[esp+5676]
$L72285:

; 454  : 
; 455  : 		switch (done)
; 456  : 		{

  003c1	48		 dec	 eax
  003c2	0f 84 ee fc ff
	ff		 je	 $L72245
  003c8	48		 dec	 eax
  003c9	74 15		 je	 SHORT $L72291
  003cb	48		 dec	 eax
  003cc	0f 85 e4 fc ff
	ff		 jne	 $L72245

; 461  : 				break;
; 462  : 			case FINISHED_WORD:
; 463  : 				ls_task_read_next_word(phTTS);

  003d2	53		 push	 ebx
  003d3	e8 00 00 00 00	 call	 _ls_task_read_next_word
  003d8	83 c4 04	 add	 esp, 4

; 464  : 				break;

  003db	e9 d6 fc ff ff	 jmp	 $L72245
$L72291:

; 457  : 			case LS_TASK_LOOP:
; 458  : 				continue;
; 459  : 			case SPELL_WORD:
; 460  : 				ls_task_spell_word(phTTS,llp,rlp);

  003e0	8b 4c 24 10	 mov	 ecx, DWORD PTR _rlp$[esp+5676]
  003e4	8b 54 24 14	 mov	 edx, DWORD PTR _llp$[esp+5676]
  003e8	51		 push	 ecx
  003e9	52		 push	 edx
  003ea	53		 push	 ebx
  003eb	e8 00 00 00 00	 call	 _ls_task_spell_word
  003f0	83 c4 0c	 add	 esp, 12			; 0000000cH
  003f3	e9 be fc ff ff	 jmp	 $L72245
_ls_task_main ENDP
_TEXT	ENDS
PUBLIC	_ls_task_parse_number
EXTRN	_ls_char_feat:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_np$ = 20
_pLts_t$ = 8
_pKsd_t$ = -4
_ls_task_parse_number PROC NEAR

; 493  : {

  00400	51		 push	 ecx

; 494  : 	LETTER  *tlp1;
; 495  : 	LETTER  *tlp2;
; 496  : 	int     ncbs;   
; 497  : 	int break_flag;
; 498  : 	PLTS_T  pLts_t;
; 499  : 	PKSD_T  pKsd_t;
; 500  : 
; 501  : 	pLts_t = phTTS->pLTSThreadData;

  00401	8b 44 24 08	 mov	 eax, DWORD PTR _phTTS$[esp]
  00405	53		 push	 ebx
  00406	55		 push	 ebp

; 502  : 	pKsd_t = phTTS->pKernelShareData;   
; 503  : 
; 504  : 	np->n_ilp = NULL;                       /* Null scan.           */
; 505  : 	np->n_flp = NULL;
; 506  : 	np->n_elp = NULL;
; 507  : 	tlp1 = llp;

  00407	8b 6c 24 14	 mov	 ebp, DWORD PTR _llp$[esp+8]
  0040b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0040e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00411	56		 push	 esi
  00412	8b 74 24 20	 mov	 esi, DWORD PTR _np$[esp+12]
  00416	57		 push	 edi

; 508  : 	if (tlp1 != rlp
; 509  : 	&& (tlp1->l_ch == 0xBC                  /* 1/4                  */
; 510  : 	||  tlp1->l_ch == 0xBD                  /* 1/2                  */
; 511  : 	||  IS_DIGIT(tlp1->l_ch))) 

  00417	8b 7c 24 20	 mov	 edi, DWORD PTR _rlp$[esp+16]
  0041b	33 c0		 xor	 eax, eax
  0041d	3b ef		 cmp	 ebp, edi
  0041f	89 06		 mov	 DWORD PTR [esi], eax
  00421	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00424	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00427	89 4c 24 18	 mov	 DWORD PTR _pLts_t$[esp+16], ecx
  0042b	89 54 24 10	 mov	 DWORD PTR _pKsd_t$[esp+20], edx
  0042f	8b c5		 mov	 eax, ebp
  00431	0f 84 73 01 00
	00		 je	 $L72301
  00437	66 8b 4d 00	 mov	 cx, WORD PTR [ebp]
  0043b	b3 10		 mov	 bl, 16			; 00000010H
  0043d	66 81 f9 bc 00	 cmp	 cx, 188			; 000000bcH
  00442	74 16		 je	 SHORT $L72312
  00444	66 81 f9 bd 00	 cmp	 cx, 189			; 000000bdH
  00449	74 0f		 je	 SHORT $L72312
  0044b	0f bf c9	 movsx	 ecx, cx
  0044e	84 99 00 00 00
	00		 test	 BYTE PTR _ls_char_feat[ecx], bl
  00454	0f 84 b9 00 00
	00		 je	 $L72311
$L72312:

; 512  : 	{
; 513  : 		np->n_ilp = tlp1;

  0045a	89 2e		 mov	 DWORD PTR [esi], ebp
$L72314:

; 515  : 		{
; 516  : 			/* 1/2 and 1/4.                                 */
; 517  : 			if (tlp1->l_ch==0xBC || tlp1->l_ch==0xBD) 

  0045c	66 8b 08	 mov	 cx, WORD PTR [eax]
  0045f	66 81 f9 bc 00	 cmp	 cx, 188			; 000000bcH
  00464	0f 84 94 00 00
	00		 je	 $L72317
  0046a	66 81 f9 bd 00	 cmp	 cx, 189			; 000000bdH
  0046f	0f 84 89 00 00
	00		 je	 $L72317

; 521  : 				return (tlp1);
; 522  : 			}
; 523  : 			/* Comma (period if this is MODE_EUROPE).       */
; 524  : 			if (tlp1->l_ch == pLts_t->schar) 

  00475	8b 54 24 18	 mov	 edx, DWORD PTR _pLts_t$[esp+16]
  00479	66 8b 92 ee 08
	00 00		 mov	 dx, WORD PTR [edx+2286]
  00480	66 3b ca	 cmp	 cx, dx
  00483	75 5e		 jne	 SHORT $L72318

; 525  : 			{
; 526  : 				tlp2 = tlp1;

  00485	8b c8		 mov	 ecx, eax

; 527  : 				ncbs = 3;
; 528  : 				break_flag = 0;
; 529  : 				while (ncbs-- && tlp2!=llp) 

  00487	be 02 00 00 00	 mov	 esi, 2
$L72320:
  0048c	3b cd		 cmp	 ecx, ebp
  0048e	74 19		 je	 SHORT $L72324

; 530  : 				{
; 531  : 					--tlp2;

  00490	83 e9 08	 sub	 ecx, 8

; 532  : 					if (tlp2->l_ch == pLts_t->schar)

  00493	66 39 11	 cmp	 WORD PTR [ecx], dx
  00496	74 72		 je	 SHORT $L72315
  00498	8b de		 mov	 ebx, esi
  0049a	4e		 dec	 esi
  0049b	85 db		 test	 ebx, ebx
  0049d	75 ed		 jne	 SHORT $L72320

; 533  :                     {						
; 534  : 						break_flag = 1;
; 535  : 						break;
; 536  : 				    }
; 537  : 				}    
; 538  : 				if (break_flag)
; 539  : 				   break;
; 540  : 				if (tlp2!=llp && (tlp2-1)->l_ch!=pLts_t->schar)

  0049f	3b cd		 cmp	 ecx, ebp
  004a1	74 06		 je	 SHORT $L72324
  004a3	66 39 51 f8	 cmp	 WORD PTR [ecx-8], dx
  004a7	75 61		 jne	 SHORT $L72315
$L72324:

; 514  : 		while (tlp1 != rlp) 

  004a9	8d 70 08	 lea	 esi, DWORD PTR [eax+8]

; 541  : 					break;
; 542  : 				tlp2 = tlp1+1;
; 543  : 				ncbs = 3;
; 544  : 				while (ncbs--) 

  004ac	ba 02 00 00 00	 mov	 edx, 2
  004b1	8b ce		 mov	 ecx, esi
$L72326:

; 545  : 				{
; 546  : 					if (tlp2==rlp || !IS_DIGIT(tlp2->l_ch))

  004b3	3b cf		 cmp	 ecx, edi
  004b5	74 53		 je	 SHORT $L72315
  004b7	0f bf 19	 movsx	 ebx, WORD PTR [ecx]
  004ba	f6 83 00 00 00
	00 10		 test	 BYTE PTR _ls_char_feat[ebx], 16 ; 00000010H
  004c1	74 47		 je	 SHORT $L72315

; 547  : 					{
; 548  : 					   break_flag = 1;
; 549  : 					   break;
; 550  : 					}	
; 551  : 					++tlp2;

  004c3	83 c1 08	 add	 ecx, 8
  004c6	8b da		 mov	 ebx, edx
  004c8	4a		 dec	 edx
  004c9	85 db		 test	 ebx, ebx
  004cb	75 e6		 jne	 SHORT $L72326

; 552  : 				}
; 553  : 				
; 554  : 				if (break_flag)
; 555  : 				   break;
; 556  : 				   
; 557  : 				/*
; 558  : 				 * The normal DECtalk code does not
; 559  : 				 * make this check; instead, it implemented
; 560  : 				 * the exact rules of the DECtalk I. Peter
; 561  : 				 * Stevens at Kurzweil thought that this extra
; 562  : 				 * check was appropriate, and I tend to
; 563  : 				 * agree with him. We should probably make
; 564  : 				 * this change in all DECtalk code.
; 565  : 				 */
; 566  : 				/* Note from EAB-I have looked at this and 
; 567  : 				 * can't figure out how it makes the dectalk
; 568  : 				 * do anything different, but for chicken 
; 569  : 				 * soup reasons I'm leaving it in. 
; 570  : 				 */     
; 571  : 
; 572  : 				if (tlp2!=rlp && IS_DIGIT(tlp2->l_ch))

  004cd	3b cf		 cmp	 ecx, edi
  004cf	74 0c		 je	 SHORT $L72331
  004d1	0f bf 09	 movsx	 ecx, WORD PTR [ecx]
  004d4	f6 81 00 00 00
	00 10		 test	 BYTE PTR _ls_char_feat[ecx], 16 ; 00000010H
  004db	75 2d		 jne	 SHORT $L72315
$L72331:

; 573  : 					break;
; 574  : 				++tlp1;

  004dd	8b c6		 mov	 eax, esi

; 575  : 				continue;

  004df	b3 10		 mov	 bl, 16			; 00000010H
  004e1	eb 0e		 jmp	 SHORT $L72966
$L72318:

; 576  : 			}
; 577  : 			if (IS_DIGIT(tlp1->l_ch)) 

  004e3	0f bf d1	 movsx	 edx, cx
  004e6	84 9a 00 00 00
	00		 test	 BYTE PTR _ls_char_feat[edx], bl
  004ec	74 1c		 je	 SHORT $L72315

; 578  : 			{
; 579  : 				++tlp1;

  004ee	83 c0 08	 add	 eax, 8
$L72966:

; 514  : 		while (tlp1 != rlp) 

  004f1	3b c7		 cmp	 eax, edi
  004f3	74 15		 je	 SHORT $L72315
  004f5	8b 74 24 24	 mov	 esi, DWORD PTR _np$[esp+16]
  004f9	e9 5e ff ff ff	 jmp	 $L72314
$L72317:

; 518  : 			{
; 519  : 				++tlp1;

  004fe	83 c0 08	 add	 eax, 8
  00501	5f		 pop	 edi

; 520  : 				np->n_irp = tlp1;

  00502	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00505	5e		 pop	 esi
  00506	5d		 pop	 ebp
  00507	5b		 pop	 ebx

; 607  : 		}
; 608  : 	}
; 609  : 	return (tlp1);
; 610  : }

  00508	59		 pop	 ecx
  00509	c3		 ret	 0
$L72315:

; 580  : 				continue;
; 581  : 			}
; 582  : 			break;
; 583  : 		}
; 584  : 		np->n_irp = tlp1;

  0050a	8b 74 24 24	 mov	 esi, DWORD PTR _np$[esp+16]
  0050e	b3 10		 mov	 bl, 16			; 00000010H
  00510	89 46 04	 mov	 DWORD PTR [esi+4], eax
$L72311:

; 585  : 	}
; 586  : 	if (tlp1!=rlp && tlp1->l_ch==pLts_t->fchar) 

  00513	3b c7		 cmp	 eax, edi
  00515	0f 84 8f 00 00
	00		 je	 $L72301
  0051b	8b 54 24 18	 mov	 edx, DWORD PTR _pLts_t$[esp+16]
  0051f	66 8b 08	 mov	 cx, WORD PTR [eax]
  00522	66 3b 8a ec 08
	00 00		 cmp	 cx, WORD PTR [edx+2284]
  00529	75 1f		 jne	 SHORT $L72333

; 587  : 	{   /* Fraction             */
; 588  : 		np->n_flp = tlp1;

  0052b	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 589  : 		++tlp1;

  0052e	83 c0 08	 add	 eax, 8

; 590  : 		while (tlp1!=rlp && IS_DIGIT(tlp1->l_ch))

  00531	3b c7		 cmp	 eax, edi
  00533	74 12		 je	 SHORT $L72336
$L72335:
  00535	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00538	84 99 00 00 00
	00		 test	 BYTE PTR _ls_char_feat[ecx], bl
  0053e	74 07		 je	 SHORT $L72336

; 591  : 			++tlp1;

  00540	83 c0 08	 add	 eax, 8
  00543	3b c7		 cmp	 eax, edi
  00545	75 ee		 jne	 SHORT $L72335
$L72336:

; 592  : 		np->n_frp = tlp1;

  00547	89 46 0c	 mov	 DWORD PTR [esi+12], eax
$L72333:

; 593  : 	}
; 594  : 	if (tlp1!=rlp && tlp1->l_ch=='e' && (pKsd_t->modeflag & MODE_MATH)) 

  0054a	3b c7		 cmp	 eax, edi
  0054c	74 5c		 je	 SHORT $L72301
  0054e	66 83 38 65	 cmp	 WORD PTR [eax], 101	; 00000065H
  00552	75 56		 jne	 SHORT $L72301
  00554	8b 54 24 10	 mov	 edx, DWORD PTR _pKsd_t$[esp+20]
  00558	f6 82 00 02 00
	00 04		 test	 BYTE PTR [edx+512], 4
  0055f	74 49		 je	 SHORT $L72301

; 595  : 	{        /* Exponant.            */
; 596  : 		tlp2 = tlp1;

  00561	8b d0		 mov	 edx, eax

; 597  : 		++tlp1;

  00563	83 c0 08	 add	 eax, 8

; 598  : 		if ( tlp1!=rlp && (tlp1->l_ch=='+' || tlp1->l_ch=='-'))

  00566	3b c7		 cmp	 eax, edi
  00568	74 40		 je	 SHORT $L72301
  0056a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0056d	66 83 f9 2b	 cmp	 cx, 43			; 0000002bH
  00571	74 06		 je	 SHORT $L72339
  00573	66 83 f9 2d	 cmp	 cx, 45			; 0000002dH
  00577	75 03		 jne	 SHORT $L72338
$L72339:

; 599  : 			++tlp1;

  00579	83 c0 08	 add	 eax, 8
$L72338:

; 600  : 		if (tlp1!=rlp && IS_DIGIT(tlp1->l_ch)) 

  0057c	3b c7		 cmp	 eax, edi
  0057e	74 2a		 je	 SHORT $L72301
  00580	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00583	84 99 00 00 00
	00		 test	 BYTE PTR _ls_char_feat[ecx], bl
  00589	74 1f		 je	 SHORT $L72301

; 601  : 		{
; 602  : 			np->n_elp = tlp2;
; 603  : 			++tlp1;

  0058b	83 c0 08	 add	 eax, 8
  0058e	89 56 10	 mov	 DWORD PTR [esi+16], edx

; 604  : 			while (tlp1!=rlp && IS_DIGIT(tlp1->l_ch))

  00591	3b c7		 cmp	 eax, edi
  00593	74 12		 je	 SHORT $L72343
$L72342:
  00595	0f bf 10	 movsx	 edx, WORD PTR [eax]
  00598	84 9a 00 00 00
	00		 test	 BYTE PTR _ls_char_feat[edx], bl
  0059e	74 07		 je	 SHORT $L72343

; 605  : 				++tlp1;

  005a0	83 c0 08	 add	 eax, 8
  005a3	3b c7		 cmp	 eax, edi
  005a5	75 ee		 jne	 SHORT $L72342
$L72343:

; 606  : 			np->n_erp = tlp1;

  005a7	89 46 14	 mov	 DWORD PTR [esi+20], eax
$L72301:
  005aa	5f		 pop	 edi
  005ab	5e		 pop	 esi
  005ac	5d		 pop	 ebp
  005ad	5b		 pop	 ebx

; 607  : 		}
; 608  : 	}
; 609  : 	return (tlp1);
; 610  : }

  005ae	59		 pop	 ecx
  005af	c3		 ret	 0
_ls_task_parse_number ENDP
_TEXT	ENDS
PUBLIC	_ls_task_wlookup
EXTRN	_ls_lower:BYTE
_TEXT	SEGMENT
_pLts_t$ = 8
_word$ = 12
_table$ = 16
_ls_task_wlookup PROC NEAR

; 637  : 	LETTER  *lp;
; 638  : 	/* GL 03/20/1998, BATS#633  use "unsigned char" instead of "char" */
; 639  : 	unsigned char  	*cp;
; 640  : 	unsigned char  	*tp;
; 641  : 	int   	c;
; 642  : 	int   	len;
; 643  : 
; 644  : 	tp = &table[0];                 /* Start at the start.  */
; 645  : 	while ((len = *tp++) != 0) 

  005b0	8b 44 24 0c	 mov	 eax, DWORD PTR _table$[esp-4]
  005b4	33 c9		 xor	 ecx, ecx
  005b6	53		 push	 ebx
  005b7	55		 push	 ebp
  005b8	8a 08		 mov	 cl, BYTE PTR [eax]
  005ba	56		 push	 esi
  005bb	8b e9		 mov	 ebp, ecx
  005bd	57		 push	 edi
  005be	85 ed		 test	 ebp, ebp
  005c0	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  005c3	74 52		 je	 SHORT $L72358

; 646  : 	{            					/* 0 => end of table.   */
; 647  : 		lp = &word[0];              
; 648  : 		cp = tp;                    /* Start of text.       */
; 649  : 		for (;;) 
; 650  : 		{
; 651  : 			c = ls_lower[lp->l_ch]; /* Fold case.           */

  005c5	8b 54 24 18	 mov	 edx, DWORD PTR _word$[esp+12]
  005c9	0f bf 02	 movsx	 eax, WORD PTR [edx]
  005cc	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _ls_lower[eax]
  005d2	88 44 24 1c	 mov	 BYTE PTR 16+[esp+12], al
  005d6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
$L72357:
  005db	8b 54 24 18	 mov	 edx, DWORD PTR _word$[esp+12]

; 652  : 			if (c != *cp++)         /* Lose.                */

  005df	33 db		 xor	 ebx, ebx
  005e1	8a 1f		 mov	 bl, BYTE PTR [edi]
  005e3	8b c8		 mov	 ecx, eax
  005e5	3b cb		 cmp	 ecx, ebx
  005e7	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  005ea	75 1e		 jne	 SHORT $L72982
$L72360:

; 653  : 				break;
; 654  : 			if (c == EOS)           /* Win.                 */

  005ec	85 c9		 test	 ecx, ecx
  005ee	74 2e		 je	 SHORT $L72983
  005f0	0f bf 4a 08	 movsx	 ecx, WORD PTR [edx+8]

; 665  :             }
; 666  : 			++lp;   

  005f4	83 c2 08	 add	 edx, 8
  005f7	33 db		 xor	 ebx, ebx
  005f9	8a 99 00 00 00
	00		 mov	 bl, BYTE PTR _ls_lower[ecx]
  005ff	8b cb		 mov	 ecx, ebx
  00601	33 db		 xor	 ebx, ebx
  00603	8a 1e		 mov	 bl, BYTE PTR [esi]
  00605	46		 inc	 esi
  00606	3b cb		 cmp	 ecx, ebx
  00608	74 e2		 je	 SHORT $L72360
$L72982:

; 667  : 		}
; 668  : 		tp += len;                  /* Next.                */

  0060a	03 fd		 add	 edi, ebp
  0060c	33 d2		 xor	 edx, edx
  0060e	8a 17		 mov	 dl, BYTE PTR [edi]
  00610	47		 inc	 edi
  00611	8b ea		 mov	 ebp, edx
  00613	85 ed		 test	 ebp, ebp
  00615	75 c4		 jne	 SHORT $L72357
$L72358:
  00617	5f		 pop	 edi
  00618	5e		 pop	 esi
  00619	5d		 pop	 ebp

; 669  : 	}
; 670  : 	return (NULL);

  0061a	33 c0		 xor	 eax, eax
  0061c	5b		 pop	 ebx

; 671  : }

  0061d	c3		 ret	 0
$L72983:

; 655  :             {
; 656  : #ifdef ENGLISH
; 657  :                  /* set form class for "to" */
; 658  :                  if (ls_lower[(&word[0])->l_ch] == 't') pLts_t->fc_struct[pLts_t->fc_index] = FC_TO | FC_PREP | FC_FUNC;

  0061e	8a 44 24 1c	 mov	 al, BYTE PTR 16+[esp+12]
  00622	3c 74		 cmp	 al, 116			; 00000074H
  00624	8b 44 24 14	 mov	 eax, DWORD PTR _pLts_t$[esp+12]
  00628	75 11		 jne	 SHORT $L72364
  0062a	8b 88 bc 08 00
	00		 mov	 ecx, DWORD PTR [eax+2236]
  00630	c7 84 88 bc 04
	00 00 00 10 81
	00		 mov	 DWORD PTR [eax+ecx*4+1212], 8458240 ; 00811000H
$L72364:

; 659  :                  /* set form class for "and" */
; 660  :                  if (ls_lower[(&word[0])->l_ch] == 'a') pLts_t->fc_struct[pLts_t->fc_index] = FC_CONJ | FC_VERB | FC_FUNC;

  0063b	8b 4c 24 18	 mov	 ecx, DWORD PTR _word$[esp+12]
  0063f	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00642	80 ba 00 00 00
	00 61		 cmp	 BYTE PTR _ls_lower[edx], 97 ; 00000061H
  00649	75 11		 jne	 SHORT $L72365
  0064b	8b 90 bc 08 00
	00		 mov	 edx, DWORD PTR [eax+2236]
  00651	c7 84 90 bc 04
	00 00 40 00 82
	00		 mov	 DWORD PTR [eax+edx*4+1212], 8519744 ; 00820040H
$L72365:

; 661  :                  /* set form class for "for" */
; 662  :                  if (ls_lower[(&word[0])->l_ch] == 'f') pLts_t->fc_struct[pLts_t->fc_index] = FC_ADV | FC_PREP | FC_NEG;

  0065c	0f bf 09	 movsx	 ecx, WORD PTR [ecx]
  0065f	80 b9 00 00 00
	00 66		 cmp	 BYTE PTR _ls_lower[ecx], 102 ; 00000066H
  00666	75 11		 jne	 SHORT $L72366
  00668	8b 90 bc 08 00
	00		 mov	 edx, DWORD PTR [eax+2236]
  0066e	c7 84 90 bc 04
	00 00 02 10 08
	00		 mov	 DWORD PTR [eax+edx*4+1212], 528386 ; 00081002H
$L72366:

; 663  : #endif
; 664  :                  return (cp);    	/* Return phonemes.     */

  00679	8b c6		 mov	 eax, esi
  0067b	5f		 pop	 edi
  0067c	5e		 pop	 esi
  0067d	5d		 pop	 ebp
  0067e	5b		 pop	 ebx

; 671  : }

  0067f	c3		 ret	 0
_ls_task_wlookup ENDP
_TEXT	ENDS
PUBLIC	_ls_task_lookahead
EXTRN	_ls_util_is_index:NEAR
_TEXT	SEGMENT
_pLts_t$ = 8
_ls_task_lookahead PROC NEAR

; 694  : {

  00680	56		 push	 esi

; 695  :     LETTER	*elp;
; 696  : 
; 697  : 	if (ls_util_is_index(&(pLts_t->citem)) == FALSE)	/* Duck if no index     */

  00681	8b 74 24 08	 mov	 esi, DWORD PTR _pLts_t$[esp]
  00685	8d 86 00 09 00
	00		 lea	 eax, DWORD PTR [esi+2304]
  0068b	50		 push	 eax
  0068c	e8 00 00 00 00	 call	 _ls_util_is_index
  00691	83 c4 04	 add	 esp, 4
  00694	85 c0		 test	 eax, eax
  00696	74 19		 je	 SHORT $L72375

; 698  : 		return;
; 699  : 	elp = &(pLts_t->cword[0]);                        	/* Find end of word,    */
; 700  : 	while ((elp+1)->l_ch != EOS)

  00698	66 83 be 1c 09
	00 00 00	 cmp	 WORD PTR [esi+2332], 0
  006a0	8d 86 1c 09 00
	00		 lea	 eax, DWORD PTR [esi+2332]
  006a6	74 09		 je	 SHORT $L72375
$L72374:

; 701  : 	{
; 702  : 		++elp;

  006a8	83 c0 08	 add	 eax, 8
  006ab	66 83 38 00	 cmp	 WORD PTR [eax], 0
  006af	75 f7		 jne	 SHORT $L72374
$L72375:
  006b1	5e		 pop	 esi

; 703  : 	}
; 704  : }

  006b2	c3		 ret	 0
_ls_task_lookahead ENDP
_TEXT	ENDS
EXTRN	_ls_suff_print_fc:NEAR
EXTRN	_ls_util_send_phone:NEAR
EXTRN	_ls_util_write_pipe:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_flag$ = 12
_buf$ = 8
_ls_task_do_right_punct PROC NEAR

; 728  : {

  006c0	53		 push	 ebx
  006c1	56		 push	 esi
  006c2	57		 push	 edi

; 729  : 	int   c;
; 730  : 	short   buf[1];
; 731  : 	PLTS_T  pLts_t;
; 732  : 	PKSD_T  pKsd_t;
; 733  : 
; 734  : 	pLts_t = phTTS->pLTSThreadData;

  006c3	8b 7c 24 10	 mov	 edi, DWORD PTR _phTTS$[esp+8]
  006c7	8b 77 10	 mov	 esi, DWORD PTR [edi+16]

; 735  : 	pKsd_t = phTTS->pKernelShareData;

  006ca	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]

; 736  : 
; 737  : 	if ((pLts_t->citem.i_word[0]&PFONT) != (PFASCII<<PSFONT))

  006cd	66 8b 86 02 09
	00 00		 mov	 ax, WORD PTR [esi+2306]
  006d4	8b c8		 mov	 ecx, eax
  006d6	81 e1 00 1f 00
	00		 and	 ecx, 7936		; 00001f00H
  006dc	66 85 c9	 test	 cx, cx
  006df	0f 85 f0 01 00
	00		 jne	 $L72391

; 738  : 		return;
; 739  : 	c = pLts_t->citem.i_word[0] & PVALUE;
; 740  : 	if (flag==ABBREV && (c==CR || c==LF)) 

  006e5	8b 4c 24 14	 mov	 ecx, DWORD PTR _flag$[esp+8]
  006e9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006ee	83 f9 02	 cmp	 ecx, 2
  006f1	75 4e		 jne	 SHORT $L72386
  006f3	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  006f6	74 05		 je	 SHORT $L72387
  006f8	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  006fb	75 44		 jne	 SHORT $L72386
$L72387:

; 741  : 	{
; 742  : 		ls_util_send_phone(phTTS,PERIOD);

  006fd	6a 74		 push	 116			; 00000074H
  006ff	57		 push	 edi
  00700	e8 00 00 00 00	 call	 _ls_util_send_phone

; 743  : 		pLts_t->wstate = UNK_WH;

  00705	66 c7 86 c4 08
	00 00 00 00	 mov	 WORD PTR [esi+2244], 0

; 744  : 
; 745  : /* GL 11/06/1997 add switch 4100. form class log can be used by any language */
; 746  : //#ifdef ENGLISH		
; 747  : 		if((pKsd_t->logflag& LOG_FORM_TYPES) || DT_DBG(LTS_DBG,0x100))

  0070e	8a 83 04 02 00
	00		 mov	 al, BYTE PTR [ebx+516]
  00714	83 c4 08	 add	 esp, 8
  00717	a8 08		 test	 al, 8
  00719	75 19		 jne	 SHORT $L72389
  0071b	66 8b 9b 78 04
	00 00		 mov	 bx, WORD PTR [ebx+1144]
  00722	f6 c7 40	 test	 bh, 64			; 00000040H
  00725	0f 84 aa 01 00
	00		 je	 $L72391
  0072b	f6 c7 01	 test	 bh, 1
  0072e	0f 84 a1 01 00
	00		 je	 $L72391
$L72389:

; 748  : 			ls_suff_print_fc(phTTS);

  00734	57		 push	 edi
  00735	e8 00 00 00 00	 call	 _ls_suff_print_fc

; 849  : 			ls_util_read_item(phTTS);

  0073a	83 c4 04	 add	 esp, 4
  0073d	5f		 pop	 edi
  0073e	5e		 pop	 esi
  0073f	5b		 pop	 ebx

; 850  : 			break;
; 851  : 	}
; 852  : }

  00740	c3		 ret	 0
$L72386:

; 749  : //#endif
; 750  : 		return;
; 751  : 	}
; 752  : 	switch (c) 
; 753  : 	{

  00741	83 c0 f7	 add	 eax, -9			; fffffff7H
  00744	3d 97 00 00 00	 cmp	 eax, 151		; 00000097H
  00749	0f 87 86 01 00
	00		 ja	 $L72391
  0074f	33 d2		 xor	 edx, edx
  00751	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $L72994[eax]
  00757	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L72995[edx*4]
$L72394:

; 754  : 		case '.':
; 755  : #ifdef GERMAN
; 756  : 			/* GL 03/23/1998, BATS#613 remove the extra pulse for German ordinal number */
; 757  : 			if (ls_util_is_dot(pLts_t) && pLts_t->isnumabr == 3)
; 758  : 				;
; 759  : 			else
; 760  : 			ls_util_send_phone(phTTS,PERIOD);
; 761  : #else
; 762  : 			ls_util_send_phone(phTTS,PERIOD);

  0075e	6a 74		 push	 116			; 00000074H
  00760	57		 push	 edi
  00761	e8 00 00 00 00	 call	 _ls_util_send_phone

; 763  : #endif
; 764  : /* GL 11/06/1997 add switch 4100. form class log can be used by any language */
; 765  : //#ifdef ENGLISH			
; 766  : 			if((pKsd_t->logflag & LOG_FORM_TYPES) || DT_DBG(LTS_DBG,0x100))

  00766	8a 83 04 02 00
	00		 mov	 al, BYTE PTR [ebx+516]
  0076c	83 c4 08	 add	 esp, 8
  0076f	a8 08		 test	 al, 8
  00771	75 47		 jne	 SHORT $L72396
  00773	66 8b 9b 78 04
	00 00		 mov	 bx, WORD PTR [ebx+1144]
  0077a	f6 c7 40	 test	 bh, 64			; 00000040H
  0077d	74 44		 je	 SHORT $L72395
  0077f	f6 c7 01	 test	 bh, 1
  00782	74 3f		 je	 SHORT $L72395

; 767  : 				ls_suff_print_fc(phTTS);
; 768  : //#endif				
; 769  : 			ls_util_read_item(phTTS);
; 770  : 			pLts_t->wstate = UNK_WH;
; 771  : 			break;

  00784	eb 34		 jmp	 SHORT $L72396
$L72397:

; 772  : 
; 773  : 		case '?':
; 774  : 			if (pLts_t->wstate == IS_WH)    			/* Ignore the "?" if at */

  00786	66 83 be c4 08
	00 00 01	 cmp	 WORD PTR [esi+2244], 1
  0078e	75 04		 jne	 SHORT $L72398

; 775  : 			{
; 776  : #ifdef LS1DEBUG
; 777  : 				printf("Changing question mark to period! \n");
; 778  : #endif
; 779  : 				ls_util_send_phone(phTTS,PERIOD);       /* the end of a "Wh..." */

  00790	6a 74		 push	 116			; 00000074H

; 780  : 			}
; 781  : 			else                            			/* style sentence.      */

  00792	eb 02		 jmp	 SHORT $L72992
$L72398:

; 782  : 			{
; 783  : 				ls_util_send_phone(phTTS,QUEST);

  00794	6a 75		 push	 117			; 00000075H
$L72992:
  00796	57		 push	 edi
  00797	e8 00 00 00 00	 call	 _ls_util_send_phone

; 784  : 			}
; 785  : /* GL 11/06/1997 add switch 4100. form class log can be used by any language */
; 786  : //#ifdef ENGLISH
; 787  : 		    if((pKsd_t->logflag& LOG_FORM_TYPES) || DT_DBG(LTS_DBG,0x100))

  0079c	8a 83 04 02 00
	00		 mov	 al, BYTE PTR [ebx+516]
  007a2	83 c4 08	 add	 esp, 8
  007a5	a8 08		 test	 al, 8
  007a7	75 11		 jne	 SHORT $L72396
  007a9	66 8b 9b 78 04
	00 00		 mov	 bx, WORD PTR [ebx+1144]
  007b0	f6 c7 40	 test	 bh, 64			; 00000040H
  007b3	74 0e		 je	 SHORT $L72395
  007b5	f6 c7 01	 test	 bh, 1
  007b8	74 09		 je	 SHORT $L72395
$L72396:

; 788  : 				ls_suff_print_fc(phTTS);

  007ba	57		 push	 edi
  007bb	e8 00 00 00 00	 call	 _ls_suff_print_fc
  007c0	83 c4 04	 add	 esp, 4
$L72395:

; 789  : //#endif
; 790  : 			ls_util_read_item(phTTS);

  007c3	57		 push	 edi
  007c4	e8 00 00 00 00	 call	 _ls_util_read_item
  007c9	83 c4 04	 add	 esp, 4

; 791  : 			pLts_t->wstate = UNK_WH;

  007cc	66 c7 86 c4 08
	00 00 00 00	 mov	 WORD PTR [esi+2244], 0
  007d5	5f		 pop	 edi
  007d6	5e		 pop	 esi
  007d7	5b		 pop	 ebx

; 850  : 			break;
; 851  : 	}
; 852  : }

  007d8	c3		 ret	 0
$L72402:

; 792  : 			break;
; 793  : 
; 794  : 		case '!':
; 795  : 			ls_util_send_phone(phTTS,EXCLAIM);

  007d9	6a 76		 push	 118			; 00000076H
  007db	57		 push	 edi
  007dc	e8 00 00 00 00	 call	 _ls_util_send_phone

; 796  : 
; 797  : 			ls_util_read_item(phTTS);

  007e1	57		 push	 edi
  007e2	e8 00 00 00 00	 call	 _ls_util_read_item

; 798  : /* GL 11/06/1997 add switch 4100. form class log can be used by any language */
; 799  : //#ifdef ENGLISH			
; 800  : 		    if((pKsd_t->logflag& LOG_FORM_TYPES) || DT_DBG(LTS_DBG,0x100))

  007e7	8a 83 04 02 00
	00		 mov	 al, BYTE PTR [ebx+516]
  007ed	83 c4 0c	 add	 esp, 12			; 0000000cH
  007f0	a8 08		 test	 al, 8
  007f2	75 11		 jne	 SHORT $L72404
  007f4	66 8b 9b 78 04
	00 00		 mov	 bx, WORD PTR [ebx+1144]
  007fb	f6 c7 40	 test	 bh, 64			; 00000040H
  007fe	74 0e		 je	 SHORT $L72403
  00800	f6 c7 01	 test	 bh, 1
  00803	74 09		 je	 SHORT $L72403
$L72404:

; 801  : 				ls_suff_print_fc(phTTS);

  00805	57		 push	 edi
  00806	e8 00 00 00 00	 call	 _ls_suff_print_fc
  0080b	83 c4 04	 add	 esp, 4
$L72403:

; 802  : //#endif				
; 803  : 			pLts_t->wstate = UNK_WH;

  0080e	66 c7 86 c4 08
	00 00 00 00	 mov	 WORD PTR [esi+2244], 0
  00817	5f		 pop	 edi
  00818	5e		 pop	 esi
  00819	5b		 pop	 ebx

; 850  : 			break;
; 851  : 	}
; 852  : }

  0081a	c3		 ret	 0
$L72405:

; 804  : 			break;
; 805  : 
; 806  : 		case VT:
; 807  : 		    /* Vertical tab, flush  */
; 808  : 		    /*
; 809  : 			   GL 01/31/1996, need to initialize the form class state for
; 810  : 			   control-k(VT)
; 811  : 			*/
; 812  : /* GL 11/06/1997 add switch 4100. form class log can be used by any language */
; 813  : //#ifdef ENGLISH			
; 814  : 			if((pKsd_t->logflag& LOG_FORM_TYPES) || DT_DBG(LTS_DBG,0x100))

  0081b	f6 83 04 02 00
	00 08		 test	 BYTE PTR [ebx+516], 8
  00822	75 11		 jne	 SHORT $L72407
  00824	66 8b 83 78 04
	00 00		 mov	 ax, WORD PTR [ebx+1144]
  0082b	f6 c4 40	 test	 ah, 64			; 00000040H
  0082e	74 0e		 je	 SHORT $L72406
  00830	f6 c4 01	 test	 ah, 1
  00833	74 09		 je	 SHORT $L72406
$L72407:

; 815  : 				ls_suff_print_fc(phTTS);

  00835	57		 push	 edi
  00836	e8 00 00 00 00	 call	 _ls_suff_print_fc
  0083b	83 c4 04	 add	 esp, 4
$L72406:

; 816  : //#endif				
; 817  : 			pLts_t->fc_index = 0;

  0083e	33 c0		 xor	 eax, eax

; 818  : 			pLts_t->old_fc_index = -1;
; 819  : 			pLts_t->fc_struct[0] = 0;
; 820  : 			pLts_t->fc_struct[1] = 0;
; 821  : 
; 822  : 			buf[0] = BREATH_BREAK;
; 823  : 			ls_util_write_pipe(pKsd_t,&buf[0],1);

  00840	6a 01		 push	 1
  00842	89 86 bc 08 00
	00		 mov	 DWORD PTR [esi+2236], eax
  00848	89 86 bc 04 00
	00		 mov	 DWORD PTR [esi+1212], eax
  0084e	89 86 c0 04 00
	00		 mov	 DWORD PTR [esi+1216], eax
  00854	8d 44 24 14	 lea	 eax, DWORD PTR _buf$[esp+12]
  00858	50		 push	 eax
  00859	c7 86 c0 08 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+2240], -1
  00863	53		 push	 ebx
  00864	66 c7 44 24 1c
	0b 1f		 mov	 WORD PTR _buf$[esp+20], 7947 ; 00001f0bH
  0086b	e8 00 00 00 00	 call	 _ls_util_write_pipe

; 824  : 			ls_util_read_item(phTTS);

  00870	57		 push	 edi
  00871	e8 00 00 00 00	 call	 _ls_util_read_item
  00876	83 c4 10	 add	 esp, 16			; 00000010H
  00879	5f		 pop	 edi
  0087a	5e		 pop	 esi
  0087b	5b		 pop	 ebx

; 850  : 			break;
; 851  : 	}
; 852  : }

  0087c	c3		 ret	 0
$L72408:

; 825  : 			break;
; 826  : 
; 827  : 		case ',':
; 828  : 		case ':':
; 829  : 		case ';':
; 830  : 		case HT:                                /* Tab, longish pause   */
; 831  : 
; 832  : 			pLts_t->fc_index = 1;
; 833  : 			pLts_t->old_fc_index = -1;
; 834  : 			pLts_t->fc_struct[0] = 0;

  0087d	33 c0		 xor	 eax, eax

; 835  : 			pLts_t->fc_struct[1] = 0;
; 836  : 			ls_util_send_phone(phTTS,COMMA);

  0087f	6a 73		 push	 115			; 00000073H
  00881	57		 push	 edi
  00882	c7 86 bc 08 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+2236], 1
  0088c	c7 86 c0 08 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+2240], -1
  00896	89 86 bc 04 00
	00		 mov	 DWORD PTR [esi+1212], eax
  0089c	89 86 c0 04 00
	00		 mov	 DWORD PTR [esi+1216], eax
  008a2	e8 00 00 00 00	 call	 _ls_util_send_phone

; 837  : 			ls_util_read_item(phTTS);

  008a7	57		 push	 edi
  008a8	e8 00 00 00 00	 call	 _ls_util_read_item
  008ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  008b0	5f		 pop	 edi
  008b1	5e		 pop	 esi
  008b2	5b		 pop	 ebx

; 850  : 			break;
; 851  : 	}
; 852  : }

  008b3	c3		 ret	 0
$L72409:

; 838  : 			break;
; 839  : 
; 840  : 		case ' ':                               /* ASCII SP             */
; 841  : 		case 0xA0:                              /* Multinational SP     */
; 842  : 		case LF:                                /* Linefeed             */
; 843  : 		case FF:                                /* Formfeed             */
; 844  : 		case CR:                                /* Carriage return.     */
; 845  : 			if ((pKsd_t->modeflag&MODE_SPELL)!=0)

  008b4	f6 83 00 02 00
	00 10		 test	 BYTE PTR [ebx+512], 16	; 00000010H
  008bb	74 04		 je	 SHORT $L72410

; 846  : 				ls_util_send_phone(phTTS,COMMA);       /* Make longer pause if */

  008bd	6a 73		 push	 115			; 00000073H

; 847  : 			else                            /* forced spelling.     */

  008bf	eb 02		 jmp	 SHORT $L72993
$L72410:

; 848  : 				ls_util_send_phone(phTTS,WBOUND);

  008c1	6a 6f		 push	 111			; 0000006fH
$L72993:
  008c3	57		 push	 edi
  008c4	e8 00 00 00 00	 call	 _ls_util_send_phone
  008c9	83 c4 08	 add	 esp, 8

; 849  : 			ls_util_read_item(phTTS);

  008cc	57		 push	 edi
  008cd	e8 00 00 00 00	 call	 _ls_util_read_item
  008d2	83 c4 04	 add	 esp, 4
$L72391:
  008d5	5f		 pop	 edi
  008d6	5e		 pop	 esi
  008d7	5b		 pop	 ebx

; 850  : 			break;
; 851  : 	}
; 852  : }

  008d8	c3		 ret	 0
  008d9	8d 49 00	 npad	 3
$L72995:
  008dc	00 00 00 00	 DD	 $L72408
  008e0	00 00 00 00	 DD	 $L72409
  008e4	00 00 00 00	 DD	 $L72405
  008e8	00 00 00 00	 DD	 $L72402
  008ec	00 00 00 00	 DD	 $L72394
  008f0	00 00 00 00	 DD	 $L72397
  008f4	00 00 00 00	 DD	 $L72391
$L72994:
  008f8	00		 DB	 0
  008f9	01		 DB	 1
  008fa	02		 DB	 2
  008fb	01		 DB	 1
  008fc	01		 DB	 1
  008fd	06		 DB	 6
  008fe	06		 DB	 6
  008ff	06		 DB	 6
  00900	06		 DB	 6
  00901	06		 DB	 6
  00902	06		 DB	 6
  00903	06		 DB	 6
  00904	06		 DB	 6
  00905	06		 DB	 6
  00906	06		 DB	 6
  00907	06		 DB	 6
  00908	06		 DB	 6
  00909	06		 DB	 6
  0090a	06		 DB	 6
  0090b	06		 DB	 6
  0090c	06		 DB	 6
  0090d	06		 DB	 6
  0090e	06		 DB	 6
  0090f	01		 DB	 1
  00910	03		 DB	 3
  00911	06		 DB	 6
  00912	06		 DB	 6
  00913	06		 DB	 6
  00914	06		 DB	 6
  00915	06		 DB	 6
  00916	06		 DB	 6
  00917	06		 DB	 6
  00918	06		 DB	 6
  00919	06		 DB	 6
  0091a	06		 DB	 6
  0091b	00		 DB	 0
  0091c	06		 DB	 6
  0091d	04		 DB	 4
  0091e	06		 DB	 6
  0091f	06		 DB	 6
  00920	06		 DB	 6
  00921	06		 DB	 6
  00922	06		 DB	 6
  00923	06		 DB	 6
  00924	06		 DB	 6
  00925	06		 DB	 6
  00926	06		 DB	 6
  00927	06		 DB	 6
  00928	06		 DB	 6
  00929	00		 DB	 0
  0092a	00		 DB	 0
  0092b	06		 DB	 6
  0092c	06		 DB	 6
  0092d	06		 DB	 6
  0092e	05		 DB	 5
  0092f	06		 DB	 6
  00930	06		 DB	 6
  00931	06		 DB	 6
  00932	06		 DB	 6
  00933	06		 DB	 6
  00934	06		 DB	 6
  00935	06		 DB	 6
  00936	06		 DB	 6
  00937	06		 DB	 6
  00938	06		 DB	 6
  00939	06		 DB	 6
  0093a	06		 DB	 6
  0093b	06		 DB	 6
  0093c	06		 DB	 6
  0093d	06		 DB	 6
  0093e	06		 DB	 6
  0093f	06		 DB	 6
  00940	06		 DB	 6
  00941	06		 DB	 6
  00942	06		 DB	 6
  00943	06		 DB	 6
  00944	06		 DB	 6
  00945	06		 DB	 6
  00946	06		 DB	 6
  00947	06		 DB	 6
  00948	06		 DB	 6
  00949	06		 DB	 6
  0094a	06		 DB	 6
  0094b	06		 DB	 6
  0094c	06		 DB	 6
  0094d	06		 DB	 6
  0094e	06		 DB	 6
  0094f	06		 DB	 6
  00950	06		 DB	 6
  00951	06		 DB	 6
  00952	06		 DB	 6
  00953	06		 DB	 6
  00954	06		 DB	 6
  00955	06		 DB	 6
  00956	06		 DB	 6
  00957	06		 DB	 6
  00958	06		 DB	 6
  00959	06		 DB	 6
  0095a	06		 DB	 6
  0095b	06		 DB	 6
  0095c	06		 DB	 6
  0095d	06		 DB	 6
  0095e	06		 DB	 6
  0095f	06		 DB	 6
  00960	06		 DB	 6
  00961	06		 DB	 6
  00962	06		 DB	 6
  00963	06		 DB	 6
  00964	06		 DB	 6
  00965	06		 DB	 6
  00966	06		 DB	 6
  00967	06		 DB	 6
  00968	06		 DB	 6
  00969	06		 DB	 6
  0096a	06		 DB	 6
  0096b	06		 DB	 6
  0096c	06		 DB	 6
  0096d	06		 DB	 6
  0096e	06		 DB	 6
  0096f	06		 DB	 6
  00970	06		 DB	 6
  00971	06		 DB	 6
  00972	06		 DB	 6
  00973	06		 DB	 6
  00974	06		 DB	 6
  00975	06		 DB	 6
  00976	06		 DB	 6
  00977	06		 DB	 6
  00978	06		 DB	 6
  00979	06		 DB	 6
  0097a	06		 DB	 6
  0097b	06		 DB	 6
  0097c	06		 DB	 6
  0097d	06		 DB	 6
  0097e	06		 DB	 6
  0097f	06		 DB	 6
  00980	06		 DB	 6
  00981	06		 DB	 6
  00982	06		 DB	 6
  00983	06		 DB	 6
  00984	06		 DB	 6
  00985	06		 DB	 6
  00986	06		 DB	 6
  00987	06		 DB	 6
  00988	06		 DB	 6
  00989	06		 DB	 6
  0098a	06		 DB	 6
  0098b	06		 DB	 6
  0098c	06		 DB	 6
  0098d	06		 DB	 6
  0098e	06		 DB	 6
  0098f	01		 DB	 1
_ls_task_do_right_punct ENDP
_TEXT	ENDS
EXTRN	_ls_util_write_item:NEAR
EXTRN	_ls_util_is_white:NEAR
EXTRN	_ls_util_is_might:NEAR
EXTRN	_lsctype:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_word$ = 12
_ksf$ = 8
_pLts_t$ = -4
_ls_task_readword PROC NEAR

; 883  : {

  00990	51		 push	 ecx
  00991	53		 push	 ebx
  00992	55		 push	 ebp
  00993	56		 push	 esi
  00994	57		 push	 edi

; 884  : 	LETTER        *lp1;
; 885  : 	LETTER        *lp2;
; 886  : 	int   ksf=0;
; 887  : 	int   t;
; 888  : 	int   c=0;
; 889  : 	PHONE *pp1;
; 890  : 	PHONE *pp2;
; 891  : 	PLTS_T  pLts_t;
; 892  : 	PKSD_T  pKsd_t;
; 893  : 
; 894  : 	pLts_t = phTTS->pLTSThreadData;

  00995	8b 7c 24 18	 mov	 edi, DWORD PTR _phTTS$[esp+16]
  00999	33 ed		 xor	 ebp, ebp
  0099b	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0099e	89 44 24 10	 mov	 DWORD PTR _pLts_t$[esp+20], eax

; 895  : 	pKsd_t = phTTS->pKernelShareData;   
; 896  : 	
; 897  : /*
; 898  :  *  start with no flags for this word ...
; 899  :  */
; 900  : 	while (ls_util_is_white(&(pLts_t->citem)) != FALSE) 

  009a2	8d b0 00 09 00
	00		 lea	 esi, DWORD PTR [eax+2304]
  009a8	56		 push	 esi
  009a9	e8 00 00 00 00	 call	 _ls_util_is_white
  009ae	83 c4 04	 add	 esp, 4
  009b1	85 c0		 test	 eax, eax
  009b3	74 39		 je	 SHORT $L72428
$L72427:

; 901  : 	{      /* Skip spaces.         */
; 902  : 		ls_util_read_item(phTTS);

  009b5	57		 push	 edi
  009b6	e8 00 00 00 00	 call	 _ls_util_read_item

; 903  : 		while (ls_util_is_index(&(pLts_t->citem)) != FALSE) 

  009bb	56		 push	 esi
  009bc	e8 00 00 00 00	 call	 _ls_util_is_index
  009c1	83 c4 08	 add	 esp, 8
  009c4	85 c0		 test	 eax, eax
  009c6	74 19		 je	 SHORT $L72431
$L72430:

; 904  : 		{
; 905  : 			ls_util_write_item(phTTS);

  009c8	57		 push	 edi
  009c9	e8 00 00 00 00	 call	 _ls_util_write_item

; 906  : 			ls_util_read_item(phTTS);

  009ce	57		 push	 edi
  009cf	e8 00 00 00 00	 call	 _ls_util_read_item
  009d4	56		 push	 esi
  009d5	e8 00 00 00 00	 call	 _ls_util_is_index
  009da	83 c4 0c	 add	 esp, 12			; 0000000cH
  009dd	85 c0		 test	 eax, eax
  009df	75 e7		 jne	 SHORT $L72430
$L72431:

; 895  : 	pKsd_t = phTTS->pKernelShareData;   
; 896  : 	
; 897  : /*
; 898  :  *  start with no flags for this word ...
; 899  :  */
; 900  : 	while (ls_util_is_white(&(pLts_t->citem)) != FALSE) 

  009e1	56		 push	 esi
  009e2	e8 00 00 00 00	 call	 _ls_util_is_white
  009e7	83 c4 04	 add	 esp, 4
  009ea	85 c0		 test	 eax, eax
  009ec	75 c7		 jne	 SHORT $L72427
$L72428:

; 907  : 		}
; 908  : 	}
; 909  : 	lp1 = &word[0];                         /* Current location     */

  009ee	8b 74 24 1c	 mov	 esi, DWORD PTR _word$[esp+16]

; 910  : 	lp2 = &word[0];                         /* Rightmost location   */
; 911  : 	ksf = FALSE;                            /* Nothing kept         */

  009f2	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _ksf$[esp+16], 0
  009fa	8b de		 mov	 ebx, esi
$L72433:

; 912  :         
; 913  : /* JDB: simple fix to avoid the goto's that used to be here */
; 914  : /* loop: */
; 915  :   while (1) 
; 916  :   { 
; 917  : 		if (ls_util_is_index(&(pLts_t->citem)) != FALSE)

  009fc	8b 44 24 10	 mov	 eax, DWORD PTR _pLts_t$[esp+20]
  00a00	05 00 09 00 00	 add	 eax, 2304		; 00000900H
  00a05	50		 push	 eax
  00a06	e8 00 00 00 00	 call	 _ls_util_is_index
  00a0b	83 c4 04	 add	 esp, 4
  00a0e	85 c0		 test	 eax, eax
  00a10	74 1a		 je	 SHORT $L72435

; 918  : 		{         
; 919  : 			/* Index markers.       */
; 920  : 			if (lp1 == &word[0])            /* Flush through if at  */

  00a12	3b 74 24 1c	 cmp	 esi, DWORD PTR _word$[esp+16]
  00a16	75 09		 jne	 SHORT $L72436

; 921  : 			{
; 922  : 				ls_util_write_item(phTTS);  /* left edge of word.   */

  00a18	57		 push	 edi
  00a19	e8 00 00 00 00	 call	 _ls_util_write_item
  00a1e	83 c4 04	 add	 esp, 4
$L72436:

; 923  : 			}
; 924  : 
; 925  : /* GL 10/23/1996, remove unused index handling code */
; 926  : #if 0
; 927  : 			else 
; 928  : 			{
; 929  : 
; 930  : 				if ((pp1=ls_rule_phone_alloc(pLts_t)) != NULL)
; 931  : 				{
; 932  : 
; 933  : 					pp1->p_itype = pLts_t->citem.i_word[0];   /* allocate PHONE */
; 934  : 	
; 935  : 					pp1->p_value = pLts_t->citem.i_word[1];
; 936  : 					pp1->p_iret = pLts_t->citem.i_word[2];
; 937  : 					pp2 = (lp1-1)->l_ip;
; 938  : 					if (pp2 == NULL)                  /* add it to the end of a linked list */
; 939  : 					{	
; 940  : 	
; 941  : 						(lp1-1)->l_ip = pp1;
; 942  : 					}
; 943  : 					else 
; 944  : 					{
; 945  : 						while (pp2->p_ip != NULL)
; 946  : 							pp2 = pp2->p_ip;
; 947  : 						pp2->p_ip = pp1;
; 948  : 					}
; 949  : 					pp1->p_ip = NULL;
; 950  : 				}
; 951  : 			}
; 952  : #endif
; 953  : 			ls_util_read_item(phTTS); /* read next item */ 

  00a21	57		 push	 edi
  00a22	e8 00 00 00 00	 call	 _ls_util_read_item
  00a27	83 c4 04	 add	 esp, 4

; 954  : 			/* an item is a character with a bunch of other info about it */
; 955  : 			continue; /* goto loop; */

  00a2a	eb d0		 jmp	 SHORT $L72433
$L72435:

; 956  : 
; 957  : 		}
; 958  : 
; 959  : 		t = PHONEME;
; 960  : 		if ((pLts_t->citem.i_word[0]&PFONT) == (PFASCII<<PSFONT)) 

  00a2c	8b 54 24 10	 mov	 edx, DWORD PTR _pLts_t$[esp+20]
  00a30	b9 05 00 00 00	 mov	 ecx, 5
  00a35	66 8b 82 02 09
	00 00		 mov	 ax, WORD PTR [edx+2306]
  00a3c	8b d0		 mov	 edx, eax
  00a3e	81 e2 00 1f 00
	00		 and	 edx, 7936		; 00001f00H
  00a44	66 85 d2	 test	 dx, dx
  00a47	75 3a		 jne	 SHORT $L72439

; 961  : 		{
; 962  : 			c = pLts_t->citem.i_word[0] & PVALUE;

  00a49	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00a4e	8b e8		 mov	 ebp, eax

; 963  : 			t = lsctype[c] & TYPE;

  00a50	8a 0c 6d 00 00
	00 00		 mov	 cl, BYTE PTR _lsctype[ebp*2]
  00a57	83 e1 0f	 and	 ecx, 15			; 0000000fH

; 964  : 			if (t == IGNORE) 

  00a5a	75 0b		 jne	 SHORT $L72438

; 965  : 			{   
; 966  : 				/* These two are easy.  */
; 967  : 				ls_util_read_item(phTTS);

  00a5c	57		 push	 edi
  00a5d	e8 00 00 00 00	 call	 _ls_util_read_item
  00a62	83 c4 04	 add	 esp, 4

; 968  : 				continue; /* goto loop; */

  00a65	eb 95		 jmp	 SHORT $L72433
$L72438:

; 969  : 			}
; 970  : 			if (t == BACKUP) 

  00a67	83 f9 01	 cmp	 ecx, 1
  00a6a	75 17		 jne	 SHORT $L72439

; 971  : 			{
; 972  : 				if (lp1 != &word[0])

  00a6c	3b 74 24 1c	 cmp	 esi, DWORD PTR _word$[esp+16]
  00a70	74 03		 je	 SHORT $L72440

; 973  : 					--lp1;           

  00a72	83 ee 08	 sub	 esi, 8
$L72440:

; 974  : 				ls_util_read_item(phTTS);

  00a75	57		 push	 edi
  00a76	e8 00 00 00 00	 call	 _ls_util_read_item
  00a7b	83 c4 04	 add	 esp, 4

; 975  : 				continue; /* goto loop; */

  00a7e	e9 79 ff ff ff	 jmp	 $L72433
$L72439:

; 976  : 			}
; 977  : 		}
; 978  : 		
; 979  : 		if (lp1 < lp2) 

  00a83	3b f3		 cmp	 esi, ebx
  00a85	73 2c		 jae	 SHORT $L72441

; 980  : 		{                        /* Overstrike.          */
; 981  : 
; 982  : 			if (t==MIGHT || t==ALWAYS)

  00a87	83 f9 03	 cmp	 ecx, 3
  00a8a	74 09		 je	 SHORT $L72443
  00a8c	83 f9 04	 cmp	 ecx, 4
  00a8f	0f 85 bf 00 00
	00		 jne	 $L72442
$L72443:

; 983  : 			{
; 984  : 				if ((lsctype[c]&II) == 0)

  00a95	f6 04 6d 00 00
	00 00 10	 test	 BYTE PTR _lsctype[ebp*2], 16 ; 00000010H
  00a9d	75 03		 jne	 SHORT $L72444

; 985  : 					lp1->l_ch = c;

  00a9f	66 89 2e	 mov	 WORD PTR [esi], bp
$L72444:

; 986  : 				++lp1;
; 987  : 				ls_util_read_item(phTTS);

  00aa2	57		 push	 edi
  00aa3	83 c6 08	 add	 esi, 8
  00aa6	e8 00 00 00 00	 call	 _ls_util_read_item
  00aab	83 c4 04	 add	 esp, 4

; 988  : 				continue; /* goto loop;*/

  00aae	e9 49 ff ff ff	 jmp	 $L72433
$L72441:

; 989  : 			}
; 990  : 		} 
; 991  : 		else
; 992  : 		{
; 993  :  
; 994  : 			if (lp1 == &word[0])

  00ab3	3b 74 24 1c	 cmp	 esi, DWORD PTR _word$[esp+16]
  00ab7	75 59		 jne	 SHORT $L72446

; 995  : 			{           /* Initial position.    */
; 996  : 				if (t == PHONEME) 

  00ab9	83 f9 05	 cmp	 ecx, 5
  00abc	75 1c		 jne	 SHORT $L72447

; 997  : 				{
; 998  : 					ls_util_write_item(phTTS);

  00abe	57		 push	 edi
  00abf	e8 00 00 00 00	 call	 _ls_util_write_item

; 999  : 					ls_util_read_item(phTTS);

  00ac4	57		 push	 edi
  00ac5	e8 00 00 00 00	 call	 _ls_util_read_item
  00aca	83 c4 08	 add	 esp, 8

; 1000 : 					ksf = TRUE;             /* Kept something       */

  00acd	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _ksf$[esp+16], 1

; 1001 : 					continue; /* goto loop; */

  00ad5	e9 22 ff ff ff	 jmp	 $L72433
$L72447:

; 1002 : 				}
; 1003 : 
; 1004 : 				if (t==ALWAYS || (t==MIGHT && ksf==FALSE)) 

  00ada	83 f9 04	 cmp	 ecx, 4
  00add	74 0d		 je	 SHORT $L72449
  00adf	83 f9 03	 cmp	 ecx, 3
  00ae2	75 70		 jne	 SHORT $L72442
  00ae4	8b 44 24 18	 mov	 eax, DWORD PTR _ksf$[esp+16]
  00ae8	85 c0		 test	 eax, eax
  00aea	75 68		 jne	 SHORT $L72442
$L72449:

; 1005 : 				{
; 1006 : 
; 1007 : 					lp1->l_ch = c;

  00aec	66 89 2e	 mov	 WORD PTR [esi], bp

; 1008 : 					lp1->l_ip = NULL;

  00aef	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1009 : 					++lp1;
; 1010 : 					++lp2;
; 1011 : 					ls_util_read_item(phTTS);

  00af6	57		 push	 edi
  00af7	83 c6 08	 add	 esi, 8
  00afa	83 c3 08	 add	 ebx, 8
  00afd	e8 00 00 00 00	 call	 _ls_util_read_item
  00b02	83 c4 04	 add	 esp, 4

; 1012 : 					ksf = TRUE;             /* Kept something.      */

  00b05	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _ksf$[esp+16], 1

; 1013 : 					continue; /* goto loop; */

  00b0d	e9 ea fe ff ff	 jmp	 $L72433
$L72446:

; 1014 : 				}
; 1015 : 			}
; 1016 : 			else 
; 1017 : 			{
; 1018 : 				if (t==ALWAYS || (t==MIGHT && ls_util_is_might(phTTS)!=FALSE)) 

  00b12	83 f9 04	 cmp	 ecx, 4
  00b15	74 12		 je	 SHORT $L72453
  00b17	83 f9 03	 cmp	 ecx, 3
  00b1a	75 38		 jne	 SHORT $L72442
  00b1c	57		 push	 edi
  00b1d	e8 00 00 00 00	 call	 _ls_util_is_might
  00b22	83 c4 04	 add	 esp, 4
  00b25	85 c0		 test	 eax, eax
  00b27	74 2b		 je	 SHORT $L72442
$L72453:

; 1019 : 				{
; 1020 : 					if (lp1 < &word[NGWORD-1]) 

  00b29	8b 44 24 1c	 mov	 eax, DWORD PTR _word$[esp+16]
  00b2d	05 f8 03 00 00	 add	 eax, 1016		; 000003f8H
  00b32	3b f0		 cmp	 esi, eax
  00b34	73 10		 jae	 SHORT $L72454

; 1021 : 					{
; 1022 : 						lp1->l_ch = c;

  00b36	66 89 2e	 mov	 WORD PTR [esi], bp

; 1023 : 						lp1->l_ip = NULL;

  00b39	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1024 : 						++lp1;

  00b40	83 c6 08	 add	 esi, 8

; 1025 : 						++lp2;

  00b43	83 c3 08	 add	 ebx, 8
$L72454:

; 1026 : 					}
; 1027 : 					ls_util_read_item(phTTS);

  00b46	57		 push	 edi
  00b47	e8 00 00 00 00	 call	 _ls_util_read_item
  00b4c	83 c4 04	 add	 esp, 4
  00b4f	e9 a8 fe ff ff	 jmp	 $L72433
$L72442:

; 1028 : 					continue; /* goto loop; */
; 1029 : 				}
; 1030 : 			}
; 1031 : 		}
; 1032 : 		break;
; 1033 : 	}
; 1034 : 
; 1035 : 	lp1->l_ch = EOS;

  00b54	66 c7 06 00 00	 mov	 WORD PTR [esi], 0

; 1036 : 	lp1->l_ip = NULL; 

  00b59	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00b60	5f		 pop	 edi
  00b61	5e		 pop	 esi
  00b62	5d		 pop	 ebp
  00b63	5b		 pop	 ebx

; 1037 : 
; 1038 : 	
; 1039 : }

  00b64	59		 pop	 ecx
  00b65	c3		 ret	 0
_ls_task_readword ENDP
_TEXT	ENDS
EXTRN	_ls_spel_spell:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_spell_word PROC NEAR

; 1060 : 
; 1061 : 	int     speed;
; 1062 : 	PLTS_T pLts_t;
; 1063 : 	
; 1064 : 	pLts_t=phTTS->pLTSThreadData;
; 1065 : 
; 1066 : #ifdef LS1DEBUG
; 1067 : 			printf(" gok spell\n");
; 1068 : #endif
; 1069 : 		   
; 1070 : 		   
; 1071 : 	speed = FAST;/* always fast now ls_spel_spell_speed(llp, rlp);*/
; 1072 : 	pLts_t->fc_struct[pLts_t->fc_index] = FC_NOUN;
; 1073 : 	ls_spel_spell(phTTS,llp, rlp);

  00b70	8b 4c 24 0c	 mov	 ecx, DWORD PTR _rlp$[esp-4]
  00b74	8b 54 24 08	 mov	 edx, DWORD PTR _llp$[esp-4]
  00b78	56		 push	 esi
  00b79	57		 push	 edi
  00b7a	8b 7c 24 0c	 mov	 edi, DWORD PTR _phTTS$[esp+4]
  00b7e	51		 push	 ecx
  00b7f	52		 push	 edx
  00b80	57		 push	 edi
  00b81	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00b84	8b 86 bc 08 00
	00		 mov	 eax, DWORD PTR [esi+2236]
  00b8a	c7 84 86 bc 04
	00 00 00 04 00
	00		 mov	 DWORD PTR [esi+eax*4+1212], 1024 ; 00000400H
  00b95	e8 00 00 00 00	 call	 _ls_spel_spell

; 1074 : 	if (speed!=FAST && rlp!=llp+1 && pLts_t->rbphone==WBOUND)
; 1075 : 		pLts_t->rbphone = COMMA;        
; 1076 : 	/* BATS 490 MGS 10/08/1997 fix for A. B. C. problem ??? */
; 1077 : 	if (pLts_t->rbphone==PERIOD)

  00b9a	8b 86 20 11 00
	00		 mov	 eax, DWORD PTR [esi+4384]
  00ba0	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ba3	83 f8 74	 cmp	 eax, 116		; 00000074H
  00ba6	75 0b		 jne	 SHORT $L72467

; 1078 : 	{
; 1079 : 		ls_util_send_phone(phTTS,PERIOD);

  00ba8	6a 74		 push	 116			; 00000074H
  00baa	57		 push	 edi
  00bab	e8 00 00 00 00	 call	 _ls_util_send_phone
  00bb0	83 c4 08	 add	 esp, 8
$L72467:

; 1080 : 	}
; 1081 : 	ls_task_read_next_word(phTTS);

  00bb3	57		 push	 edi
  00bb4	e8 00 00 00 00	 call	 _ls_task_read_next_word
  00bb9	83 c4 04	 add	 esp, 4
  00bbc	5f		 pop	 edi
  00bbd	5e		 pop	 esi

; 1082 : }

  00bbe	c3		 ret	 0
_ls_task_spell_word ENDP
_phTTS$ = 8
_ls_task_read_next_word PROC NEAR

; 1100 : {

  00bc0	53		 push	 ebx
  00bc1	56		 push	 esi

; 1101 : 	PLTS_T pLts_t;
; 1102 : 	
; 1103 : 	pLts_t=phTTS->pLTSThreadData;

  00bc2	8b 74 24 0c	 mov	 esi, DWORD PTR _phTTS$[esp+4]
  00bc6	57		 push	 edi
  00bc7	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]

; 1104 : #ifdef LS1DEBUG
; 1105 : 	printf(" got to out\n");
; 1106 : #endif
; 1107 : 	if (pLts_t->rbphone!=WBOUND && ls_util_is_white(&(pLts_t->citem))!=FALSE) 

  00bca	83 bb 20 11 00
	00 6f		 cmp	 DWORD PTR [ebx+4384], 111 ; 0000006fH
  00bd1	74 66		 je	 SHORT $L72475
  00bd3	8d bb 00 09 00
	00		 lea	 edi, DWORD PTR [ebx+2304]
  00bd9	57		 push	 edi
  00bda	e8 00 00 00 00	 call	 _ls_util_is_white
  00bdf	83 c4 04	 add	 esp, 4
  00be2	85 c0		 test	 eax, eax
  00be4	74 53		 je	 SHORT $L72475

; 1108 : 	{
; 1109 : 		ls_util_send_phone(phTTS,pLts_t->rbphone);

  00be6	8b 83 20 11 00
	00		 mov	 eax, DWORD PTR [ebx+4384]
  00bec	50		 push	 eax
  00bed	56		 push	 esi
  00bee	e8 00 00 00 00	 call	 _ls_util_send_phone

; 1110 : 		while (ls_util_is_white(&(pLts_t->citem)) != FALSE) 

  00bf3	57		 push	 edi
  00bf4	e8 00 00 00 00	 call	 _ls_util_is_white
  00bf9	83 c4 0c	 add	 esp, 12			; 0000000cH
  00bfc	85 c0		 test	 eax, eax
  00bfe	74 39		 je	 SHORT $L72475
$L72474:

; 1111 : 		{
; 1112 : 			ls_util_read_item(phTTS);

  00c00	56		 push	 esi
  00c01	e8 00 00 00 00	 call	 _ls_util_read_item

; 1113 : 			while (ls_util_is_index(&pLts_t->citem) != FALSE) 

  00c06	57		 push	 edi
  00c07	e8 00 00 00 00	 call	 _ls_util_is_index
  00c0c	83 c4 08	 add	 esp, 8
  00c0f	85 c0		 test	 eax, eax
  00c11	74 19		 je	 SHORT $L72478
$L72477:

; 1114 : 			{
; 1115 : 				ls_util_write_item(phTTS);

  00c13	56		 push	 esi
  00c14	e8 00 00 00 00	 call	 _ls_util_write_item

; 1116 : 				ls_util_read_item(phTTS);

  00c19	56		 push	 esi
  00c1a	e8 00 00 00 00	 call	 _ls_util_read_item
  00c1f	57		 push	 edi
  00c20	e8 00 00 00 00	 call	 _ls_util_is_index
  00c25	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c28	85 c0		 test	 eax, eax
  00c2a	75 e7		 jne	 SHORT $L72477
$L72478:

; 1110 : 		while (ls_util_is_white(&(pLts_t->citem)) != FALSE) 

  00c2c	57		 push	 edi
  00c2d	e8 00 00 00 00	 call	 _ls_util_is_white
  00c32	83 c4 04	 add	 esp, 4
  00c35	85 c0		 test	 eax, eax
  00c37	75 c7		 jne	 SHORT $L72474
$L72475:

; 1117 : 			}
; 1118 : 		}
; 1119 : 	}
; 1120 : 	ls_task_do_right_punct(phTTS,MISS);

  00c39	6a 00		 push	 0
  00c3b	56		 push	 esi
  00c3c	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 1121 : 	ls_task_readword(phTTS,&(pLts_t->cword[0]));

  00c41	81 c3 14 09 00
	00		 add	 ebx, 2324		; 00000914H
  00c47	53		 push	 ebx
  00c48	56		 push	 esi
  00c49	e8 00 00 00 00	 call	 _ls_task_readword
  00c4e	83 c4 10	 add	 esp, 16			; 00000010H
  00c51	5f		 pop	 edi
  00c52	5e		 pop	 esi
  00c53	5b		 pop	 ebx

; 1122 : }

  00c54	c3		 ret	 0
_ls_task_read_next_word ENDP
_TEXT	ENDS
PUBLIC	_ls_task_lookup_first_verbs
EXTRN	_whdic:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_pLts_t$ = 12
_ls_task_set_what_state PROC NEAR

; 1144 : {

  00c60	56		 push	 esi

; 1145 : 	LETTER *llp;
; 1146 : #ifdef LS1DEBUG
; 1147 : 		printf("entering ls_task_set_what_state\n");
; 1148 : #endif
; 1149 : 	if (pLts_t->wstate==UNK_WH && pLts_t->cword[0].l_ch!=EOS)

  00c61	8b 74 24 0c	 mov	 esi, DWORD PTR _pLts_t$[esp]
  00c65	33 c9		 xor	 ecx, ecx
  00c67	66 39 8e c4 08
	00 00		 cmp	 WORD PTR [esi+2244], cx
  00c6e	0f 85 8a 00 00
	00		 jne	 $L72485
  00c74	66 39 8e 14 09
	00 00		 cmp	 WORD PTR [esi+2324], cx
  00c7b	8d 86 14 09 00
	00		 lea	 eax, DWORD PTR [esi+2324]
  00c81	74 7b		 je	 SHORT $L72485

; 1150 : 	{
; 1151 : 		pLts_t->fc_index = 1;

  00c83	c7 86 bc 08 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+2236], 1

; 1152 : 		pLts_t->old_fc_index = -1;

  00c8d	c7 86 c0 08 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+2240], -1

; 1153 : 		pLts_t->fc_struct[0] = 0;

  00c97	89 8e bc 04 00
	00		 mov	 DWORD PTR [esi+1212], ecx

; 1154 : 		pLts_t->fc_struct[1] = 0;

  00c9d	89 8e c0 04 00
	00		 mov	 DWORD PTR [esi+1216], ecx

; 1155 : 		pLts_t->wstate = NOT_WH;

  00ca3	66 c7 86 c4 08
	00 00 02 00	 mov	 WORD PTR [esi+2244], 2

; 1156 : 		llp = &(pLts_t->cword[0]);
; 1157 : 		while ((lsctype[llp->l_ch]&LS) != 0)

  00cac	0f bf 10	 movsx	 edx, WORD PTR [eax]
  00caf	b1 40		 mov	 cl, 64			; 00000040H
  00cb1	84 0c 55 00 00
	00 00		 test	 BYTE PTR _lsctype[edx*2], cl
  00cb8	74 10		 je	 SHORT $L72488
$L72487:
  00cba	0f bf 50 08	 movsx	 edx, WORD PTR [eax+8]

; 1158 : 			++llp;                                              

  00cbe	83 c0 08	 add	 eax, 8
  00cc1	84 0c 55 00 00
	00 00		 test	 BYTE PTR _lsctype[edx*2], cl
  00cc8	75 f0		 jne	 SHORT $L72487
$L72488:

; 1159 : 
; 1160 : #if defined (ENGLISH) || defined (GERMAN)
; 1161 : 		if ( (ls_task_wlookup(pLts_t, llp,&whdic[0])) != NULL)

  00cca	68 00 00 00 00	 push	 OFFSET FLAT:_whdic
  00ccf	50		 push	 eax
  00cd0	56		 push	 esi
  00cd1	e8 00 00 00 00	 call	 _ls_task_wlookup
  00cd6	83 c4 0c	 add	 esp, 12			; 0000000cH
  00cd9	85 c0		 test	 eax, eax
  00cdb	74 09		 je	 SHORT $L72490

; 1162 : 		{
; 1163 : 			pLts_t->wstate = IS_WH;

  00cdd	66 c7 86 c4 08
	00 00 01 00	 mov	 WORD PTR [esi+2244], 1
$L72490:

; 1164 : 		}        
; 1165 : #ifdef ENGLISH
; 1166 : /* MGS 8/20/97 hack for stressing first words in the sentence for kerzweil */
; 1167 : 		if (ls_task_lookup_first_verbs(phTTS))

  00ce6	8b 44 24 08	 mov	 eax, DWORD PTR _phTTS$[esp]
  00cea	50		 push	 eax
  00ceb	e8 00 00 00 00	 call	 _ls_task_lookup_first_verbs
  00cf0	83 c4 04	 add	 esp, 4
  00cf3	85 c0		 test	 eax, eax
  00cf5	74 2b		 je	 SHORT $L72493

; 1168 : 			return(FINISHED_WORD);

  00cf7	b8 03 00 00 00	 mov	 eax, 3
  00cfc	5e		 pop	 esi

; 1200 : }

  00cfd	c3		 ret	 0
$L72485:

; 1169 : #endif
; 1170 : #endif
; 1171 : #ifdef SPANISH
; 1172 : 	  	if ((ls_task_wlookup(pLts_t, llp, &spwhword[0])) != NULL)
; 1173 : 			{
; 1174 : 				/*we need to look at potential legal combinations of wh
; 1175 : 					question introducers so if first word is an introducer
; 1176 : 					then firstnum !=0 and wstate is rest to UNK_wh indicating
; 1177 : 					beginning of sentence*/
; 1178 : /* 		   sendlist(cp);*/
; 1179 : 			pLts_t->wstate = IS_WH;
; 1180 : /*			goto out; */
; 1181 : 			}
; 1182 : 	  	else if (ls_task_wlookup(pLts_t, llp, &prewhword[0]) != NULL)
; 1183 : 			{
; 1184 : 			pLts_t->wstate = UNK_WH;			/* pretend start of sentence.	*/
; 1185 : 						/*becuase got an intro word*/
; 1186 : 			}
; 1187 : 
; 1188 : #endif
; 1189 : 		
; 1190 : 	}   /*  if (pLts_t->wstate==UNK_WH && cword[0].l_ch!=EOS) */
; 1191 : 	else
; 1192 : 	{
; 1193 : 		if((pLts_t->cword[0].l_ch!=SIL ) && pLts_t->fc_index != sizeof(pLts_t->fc_struct)/4)

  00cfe	66 39 8e 14 09
	00 00		 cmp	 WORD PTR [esi+2324], cx
  00d05	74 1b		 je	 SHORT $L72493
  00d07	8b 86 bc 08 00
	00		 mov	 eax, DWORD PTR [esi+2236]
  00d0d	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00d12	74 0e		 je	 SHORT $L72493

; 1194 : 		{
; 1195 : 			pLts_t->fc_index += 1;

  00d14	40		 inc	 eax
  00d15	89 86 bc 08 00
	00		 mov	 DWORD PTR [esi+2236], eax

; 1196 : 			pLts_t->fc_struct[pLts_t->fc_index] = 0;

  00d1b	89 8c 86 bc 04
	00 00		 mov	 DWORD PTR [esi+eax*4+1212], ecx
$L72493:

; 1197 : 		}
; 1198 : 	}   /*  if (pLts_t->wstate==UNK_WH && cword[0].l_ch!=EOS) */
; 1199 : 	return(KEEP_SEARCHING);

  00d22	33 c0		 xor	 eax, eax
  00d24	5e		 pop	 esi

; 1200 : }

  00d25	c3		 ret	 0
_ls_task_set_what_state ENDP
_llp$ = 8
_rlp$ = 12
_elp$ = 16
_ls_task_find_end_of_word PROC NEAR

; 1223 : #ifdef LS1DEBUG
; 1224 : 		printf("entering ls_task_find_end_of_word\n");
; 1225 : #endif
; 1226 : 	(*elp) = llp;

  00d30	8b 44 24 0c	 mov	 eax, DWORD PTR _elp$[esp-4]
  00d34	8b 4c 24 04	 mov	 ecx, DWORD PTR _llp$[esp-4]
  00d38	89 08		 mov	 DWORD PTR [eax], ecx

; 1227 : 	while ((*elp)->l_ch != EOS) /* find the end of the word ?? */

  00d3a	66 83 39 00	 cmp	 WORD PTR [ecx], 0
  00d3e	74 16		 je	 SHORT $L73015
$L72502:

; 1228 : 	{
; 1229 : #ifdef LS1DEBUG
; 1230 : 			printf(" %02x %c \n",(*elp)->l_ch,(*elp)->l_ch);
; 1231 : #endif   
; 1232 : 		
; 1233 : 		++(*elp);               

  00d40	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d42	83 c1 08	 add	 ecx, 8
  00d45	89 08		 mov	 DWORD PTR [eax], ecx
  00d47	66 83 39 00	 cmp	 WORD PTR [ecx], 0
  00d4b	75 f3		 jne	 SHORT $L72502

; 1234 : 	}
; 1235 : #ifdef LS1DEBUG
; 1236 : 		printf (" %02x %c \n",(*elp)->l_ch,(*elp)->l_ch);
; 1237 : #endif
; 1238 : 	
; 1239 : 	(*rlp) = (*elp);

  00d4d	8b c1		 mov	 eax, ecx
  00d4f	8b 4c 24 08	 mov	 ecx, DWORD PTR _rlp$[esp-4]
  00d53	89 01		 mov	 DWORD PTR [ecx], eax

; 1240 : 	
; 1241 : #ifdef LS1DEBUG
; 1242 : 		printf("found the end of word ");
; 1243 : 		printf("left=%u  right=%u\n",llp,*rlp);
; 1244 : #endif    
; 1245 : 
; 1246 : }

  00d55	c3		 ret	 0
$L73015:

; 1234 : 	}
; 1235 : #ifdef LS1DEBUG
; 1236 : 		printf (" %02x %c \n",(*elp)->l_ch,(*elp)->l_ch);
; 1237 : #endif
; 1238 : 	
; 1239 : 	(*rlp) = (*elp);

  00d56	8b 10		 mov	 edx, DWORD PTR [eax]
  00d58	8b 44 24 08	 mov	 eax, DWORD PTR _rlp$[esp-4]
  00d5c	89 10		 mov	 DWORD PTR [eax], edx

; 1240 : 	
; 1241 : #ifdef LS1DEBUG
; 1242 : 		printf("found the end of word ");
; 1243 : 		printf("left=%u  right=%u\n",llp,*rlp);
; 1244 : #endif    
; 1245 : 
; 1246 : }

  00d5e	c3		 ret	 0
_ls_task_find_end_of_word ENDP
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_spell_mode PROC NEAR

; 1272 : {

  00d60	56		 push	 esi

; 1273 : 	/*
; 1274 : 	 * Word spelling.
; 1275 : 	 * A new feature for AT&T - IS.
; 1276 : 	 * Spell the word using the fast spelling speed.
; 1277 : 	 * These is some special code in "ls_task_do_right_punct" that
; 1278 : 	 * helps out word spelling, by speaking " "
; 1279 : 	 * (between words) as COMMA.
; 1280 : 	 */  
; 1281 : 	PLTS_T  pLts_t;
; 1282 : 	PKSD_T  pKsd_t;
; 1283 : 
; 1284 : 	pLts_t = phTTS->pLTSThreadData;

  00d61	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  00d65	57		 push	 edi

; 1285 : 	pKsd_t = phTTS->pKernelShareData;   
; 1286 : 
; 1287 : #ifdef LS1DEBUG
; 1288 : 		printf("entering ls_task_spell_mode\n");
; 1289 : #endif
; 1290 : 	if ((pKsd_t->modeflag&MODE_SPELL)!=0) 

  00d66	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00d69	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00d6c	f6 80 00 02 00
	00 10		 test	 BYTE PTR [eax+512], 16	; 00000010H
  00d73	74 30		 je	 SHORT $L72513

; 1291 : 	{
; 1292 : 
; 1293 : #ifdef LS1DEBUG
; 1294 : 		printf(" mode spell spell\n");
; 1295 : #endif
; 1296 : 
; 1297 : 		ls_spel_spell(phTTS,llp, rlp);

  00d75	8b 4c 24 14	 mov	 ecx, DWORD PTR _rlp$[esp+4]
  00d79	8b 54 24 10	 mov	 edx, DWORD PTR _llp$[esp+4]
  00d7d	51		 push	 ecx
  00d7e	52		 push	 edx
  00d7f	56		 push	 esi
  00d80	e8 00 00 00 00	 call	 _ls_spel_spell

; 1298 : 		ls_task_do_right_punct(phTTS,MISS);

  00d85	6a 00		 push	 0
  00d87	56		 push	 esi
  00d88	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 1299 : 		ls_task_readword(phTTS,&(pLts_t->cword[0]));

  00d8d	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  00d93	57		 push	 edi
  00d94	56		 push	 esi
  00d95	e8 00 00 00 00	 call	 _ls_task_readword
  00d9a	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1300 : 
; 1301 : 		return(LS_TASK_LOOP);

  00d9d	b8 01 00 00 00	 mov	 eax, 1
  00da2	5f		 pop	 edi
  00da3	5e		 pop	 esi

; 1304 : }

  00da4	c3		 ret	 0
$L72513:
  00da5	5f		 pop	 edi

; 1302 : 	}                  
; 1303 : 	return(KEEP_SEARCHING);

  00da6	33 c0		 xor	 eax, eax
  00da8	5e		 pop	 esi

; 1304 : }

  00da9	c3		 ret	 0
_ls_task_spell_mode ENDP
_TEXT	ENDS
EXTRN	_sdic:BYTE
EXTRN	_ls_util_send_phone_list:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_ls_task_minidic_search PROC NEAR

; 1332 : #if (defined ENGLISH) || (defined SPANISH)
; 1333 : 	char    *cp;
; 1334 : 	PLTS_T  pLts_t;
; 1335 : 	PKSD_T  pKsd_t;
; 1336 : 
; 1337 : 	pLts_t = phTTS->pLTSThreadData;
; 1338 : 	pKsd_t = phTTS->pKernelShareData;   
; 1339 : #ifdef LS1DEBUG
; 1340 : 		printf("entering ls_task_minidic_search\n");
; 1341 : #endif
; 1342 : 	if ( (cp = (char *)ls_task_wlookup(pLts_t, llp,&sdic[0])) != NULL)

  00db0	8b 44 24 08	 mov	 eax, DWORD PTR _llp$[esp-4]
  00db4	56		 push	 esi
  00db5	57		 push	 edi
  00db6	8b 7c 24 0c	 mov	 edi, DWORD PTR _phTTS$[esp+4]
  00dba	68 00 00 00 00	 push	 OFFSET FLAT:_sdic
  00dbf	50		 push	 eax
  00dc0	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00dc3	56		 push	 esi
  00dc4	e8 00 00 00 00	 call	 _ls_task_wlookup
  00dc9	83 c4 0c	 add	 esp, 12			; 0000000cH
  00dcc	85 c0		 test	 eax, eax
  00dce	74 23		 je	 SHORT $L72526

; 1343 : 	{       /*eab mini dictionary lookup */
; 1344 : 		ls_util_send_phone_list(phTTS,cp);

  00dd0	50		 push	 eax
  00dd1	57		 push	 edi
  00dd2	e8 00 00 00 00	 call	 _ls_util_send_phone_list
  00dd7	83 c4 08	 add	 esp, 8

; 1345 : 		pLts_t->lbphone=WBOUND;

  00dda	b8 6f 00 00 00	 mov	 eax, 111		; 0000006fH
  00ddf	89 86 1c 11 00
	00		 mov	 DWORD PTR [esi+4380], eax

; 1346 : 		pLts_t->rbphone=WBOUND;

  00de5	89 86 20 11 00
	00		 mov	 DWORD PTR [esi+4384], eax
  00deb	5f		 pop	 edi

; 1347 : 		return(FINISHED_WORD);

  00dec	b8 03 00 00 00	 mov	 eax, 3
  00df1	5e		 pop	 esi

; 1351 : }

  00df2	c3		 ret	 0
$L72526:
  00df3	5f		 pop	 edi

; 1348 : 	}
; 1349 : #endif
; 1350 : 	return(KEEP_SEARCHING);

  00df4	33 c0		 xor	 eax, eax
  00df6	5e		 pop	 esi

; 1351 : }

  00df7	c3		 ret	 0
_ls_task_minidic_search ENDP
_TEXT	ENDS
EXTRN	_ls_math_do_math:NEAR
_TEXT	SEGMENT
_pKsd_t$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_math_mode PROC NEAR

; 1378 : 	if (llp+1==rlp && (pKsd_t->modeflag & MODE_MATH))   

  00e00	8b 4c 24 08	 mov	 ecx, DWORD PTR _llp$[esp-4]
  00e04	8b 54 24 0c	 mov	 edx, DWORD PTR _rlp$[esp-4]
  00e08	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00e0b	3b c2		 cmp	 eax, edx
  00e0d	75 23		 jne	 SHORT $L72536
  00e0f	8b 44 24 04	 mov	 eax, DWORD PTR _pKsd_t$[esp-4]
  00e13	f6 80 00 02 00
	00 04		 test	 BYTE PTR [eax+512], 4
  00e1a	74 16		 je	 SHORT $L72536

; 1379 : 	{
; 1380 : 		if (ls_math_do_math(pKsd_t,(unsigned char )llp->l_ch)!=FALSE)

  00e1c	8a 09		 mov	 cl, BYTE PTR [ecx]
  00e1e	51		 push	 ecx
  00e1f	50		 push	 eax
  00e20	e8 00 00 00 00	 call	 _ls_math_do_math
  00e25	83 c4 08	 add	 esp, 8
  00e28	85 c0		 test	 eax, eax
  00e2a	74 06		 je	 SHORT $L72536

; 1381 : 			return(FINISHED_WORD);

  00e2c	b8 03 00 00 00	 mov	 eax, 3

; 1384 : }

  00e31	c3		 ret	 0
$L72536:

; 1382 : 	}
; 1383 : 	return(KEEP_SEARCHING);

  00e32	33 c0		 xor	 eax, eax

; 1384 : }

  00e34	c3		 ret	 0
_ls_task_math_mode ENDP
_TEXT	ENDS
EXTRN	_ls_util_lookup:NEAR
EXTRN	_ls_util_is_dot:NEAR
EXTRN	_nabtab:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_dictionary_search PROC NEAR

; 1411 : 	int flag;
; 1412 : 	int context;
; 1413 : 	char    *cp;
; 1414 : 	PLTS_T pLts_t;
; 1415 : 	
; 1416 : 	pLts_t = phTTS->pLTSThreadData;
; 1417 : 
; 1418 : #ifdef LS1DEBUG
; 1419 : 		printf("entering ls_task_dictionary_search\n");
; 1420 : #endif
; 1421 : 	/*
; 1422 : 	 * Before you do *anything*, look up the word
; 1423 : 	 * in the dictionaries. This gives the client the ability
; 1424 : 	 * to override almost any built in rules (the only rules that
; 1425 : 	 * must be used are the word framing rules). There are
; 1426 : 	 * two big cases. If the word is at least 2 characters long,
; 1427 : 	 * and the last character is a ".", then look up the root
; 1428 : 	 * with the "." stripped (this is the "Gov.." case). There
; 1429 : 	 * is no additional processing. Else check if the next
; 1430 : 	 * character is a "."; if there is an abbreviation hit then
; 1431 : 	 * the "." has to be eaten.
; 1432 : 	 */
; 1433 : 
; 1434 : 	/* 
; 1435 : 	 * The dictionary uses the fact that it never gets passed a word
; 1436 : 	 *	with a space at the bigging to store items that are to be spelled
; 1437 : 	 *	in the spell routine but don't want to hit here such as numbers.
; 1438 : 	 *	with numbers it does a ls_task_lookahead to see if the next item is in
; 1439 : 	 *	nabtab
; 1440 : 	 */
; 1441 : #ifdef LS1DEBUG
; 1442 : 	printf("%c %02x -- %c %02x\n",llp->l_ch,llp->l_ch,(llp+1)->l_ch,(llp+1)->l_ch);
; 1443 : #endif
; 1444 : 
; 1445 : 	if (rlp>=llp+2 && (rlp-1)->l_ch=='.')

  00e40	8b 44 24 0c	 mov	 eax, DWORD PTR _rlp$[esp-4]
  00e44	53		 push	 ebx
  00e45	55		 push	 ebp
  00e46	8b 6c 24 10	 mov	 ebp, DWORD PTR _llp$[esp+4]
  00e4a	56		 push	 esi
  00e4b	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  00e4f	8d 4d 10	 lea	 ecx, DWORD PTR [ebp+16]
  00e52	57		 push	 edi
  00e53	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00e56	3b c1		 cmp	 eax, ecx
  00e58	72 24		 jb	 SHORT $L72548
  00e5a	83 c0 f8	 add	 eax, -8			; fffffff8H
  00e5d	66 83 38 2e	 cmp	 WORD PTR [eax], 46	; 0000002eH
  00e61	75 1b		 jne	 SHORT $L72548

; 1446 : 	{
; 1447 : 		if ((flag=ls_util_lookup(phTTS,llp, rlp-1, FABBREV)) != MISS)

  00e63	6a 01		 push	 1
  00e65	50		 push	 eax
  00e66	55		 push	 ebp
  00e67	56		 push	 esi
  00e68	e8 00 00 00 00	 call	 _ls_util_lookup
  00e6d	83 c4 10	 add	 esp, 16			; 00000010H
  00e70	85 c0		 test	 eax, eax
  00e72	0f 84 cc 00 00
	00		 je	 $L72559

; 1448 : 		{
; 1449 : 			ls_task_do_right_punct(phTTS,flag);

  00e78	50		 push	 eax

; 1450 : 			ls_task_readword(phTTS,&(pLts_t->cword[0]));
; 1451 : 			return(LS_TASK_LOOP);

  00e79	e9 a6 00 00 00	 jmp	 $L73024
$L72548:

; 1452 : 		}
; 1453 : 	}
; 1454 : 	else
; 1455 : 	{
; 1456 : 		context = FIRST;
; 1457 : 		if (ls_util_is_dot(pLts_t) != FALSE)

  00e7e	57		 push	 edi
  00e7f	33 db		 xor	 ebx, ebx
  00e81	e8 00 00 00 00	 call	 _ls_util_is_dot
  00e86	83 c4 04	 add	 esp, 4
  00e89	85 c0		 test	 eax, eax
  00e8b	74 05		 je	 SHORT $L72551

; 1458 : 		{
; 1459 : 			context = FABBREV;

  00e8d	bb 01 00 00 00	 mov	 ebx, 1
$L72551:

; 1460 : 		}
; 1461 : 		/* xxxx eab 9/94 added to take care of 5 sq. ft. double
; 1462 : 			abbrev in context*/
; 1463 : 		/* Change 7/11/96 to fix 5 sq. ft. problem by removing pLts_t->isnumab.  GL */
; 1464 : 		/* GL 11/21/1996, set the handling approach based on the language */
; 1465 : 		/* GL 02/25/1997, restore pLts_t->isnumabr back  */  
; 1466 : #ifdef ENGLISH
; 1467 : 		if(pLts_t->isnumabr && context == FABBREV &&
; 1468 : 			(cp=(char *)ls_task_wlookup (pLts_t, &(pLts_t->cword[0]), &nabtab[0])) != NULL)

  00e92	8b 87 fc 08 00
	00		 mov	 eax, DWORD PTR [edi+2300]
  00e98	85 c0		 test	 eax, eax
  00e9a	74 63		 je	 SHORT $L72554
  00e9c	83 fb 01	 cmp	 ebx, 1
  00e9f	75 5e		 jne	 SHORT $L72554
  00ea1	8d af 14 09 00
	00		 lea	 ebp, DWORD PTR [edi+2324]
  00ea7	68 00 00 00 00	 push	 OFFSET FLAT:_nabtab
  00eac	55		 push	 ebp
  00ead	57		 push	 edi
  00eae	e8 00 00 00 00	 call	 _ls_task_wlookup
  00eb3	83 c4 0c	 add	 esp, 12			; 0000000cH
  00eb6	85 c0		 test	 eax, eax
  00eb8	74 41		 je	 SHORT $L73023

; 1469 : #endif
; 1470 : #ifdef SPANISH
; 1471 : 		/* GL 10/05/1998, Handle Spanish number abbreviation like German */
; 1472 : 		/* if(pLts_t->isnumabr && context == FABBREV && */
; 1473 : 		if(pLts_t->isnumabr &&
; 1474 : 			(cp=(char *)ls_task_wlookup (pLts_t, &(pLts_t->cword[0]), &nabtab[0])) != NULL)
; 1475 : #endif
; 1476 : #ifdef GERMAN
; 1477 : 		if(pLts_t->isnumabr &&
; 1478 : 			(cp=(char *)ls_task_wlookup (pLts_t, &(pLts_t->cword[0]), &nabtab[0])) != NULL)
; 1479 : #endif
; 1480 : 		{
; 1481 : 			if(pLts_t->pflag != FALSE)      /* Pick right form.     */

  00eba	8b 8f 24 11 00
	00		 mov	 ecx, DWORD PTR [edi+4388]
  00ec0	85 c9		 test	 ecx, ecx
  00ec2	74 0e		 je	 SHORT $L72558

; 1482 : 			{
; 1483 : 				while (*cp++ != SIL);

  00ec4	8a 10		 mov	 dl, BYTE PTR [eax]
  00ec6	40		 inc	 eax
  00ec7	84 d2		 test	 dl, dl
  00ec9	74 07		 je	 SHORT $L72558
$L72557:
  00ecb	8a 08		 mov	 cl, BYTE PTR [eax]
  00ecd	40		 inc	 eax
  00ece	84 c9		 test	 cl, cl
  00ed0	75 f9		 jne	 SHORT $L72557
$L72558:

; 1484 : 			}
; 1485 : 			ls_util_send_phone_list(phTTS,cp);  /* Send abbreviation.    */

  00ed2	50		 push	 eax
  00ed3	56		 push	 esi
  00ed4	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 1486 : 			ls_util_read_item(phTTS);             /* Eat up the ".".      */

  00ed9	56		 push	 esi
  00eda	e8 00 00 00 00	 call	 _ls_util_read_item

; 1487 : 			ls_task_do_right_punct(phTTS,MISS);

  00edf	6a 00		 push	 0
  00ee1	56		 push	 esi
  00ee2	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 1488 : 			ls_task_readword(phTTS,&(pLts_t->cword[0]));    /* Advance, continue.   */

  00ee7	55		 push	 ebp
  00ee8	56		 push	 esi
  00ee9	e8 00 00 00 00	 call	 _ls_task_readword
  00eee	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1489 : 			return(LS_TASK_LOOP);

  00ef1	b8 01 00 00 00	 mov	 eax, 1
  00ef6	5f		 pop	 edi
  00ef7	5e		 pop	 esi
  00ef8	5d		 pop	 ebp
  00ef9	5b		 pop	 ebx

; 1504 : }

  00efa	c3		 ret	 0
$L73023:

; 1489 : 			return(LS_TASK_LOOP);

  00efb	8b 6c 24 18	 mov	 ebp, DWORD PTR _llp$[esp+12]
$L72554:

; 1490 : 		}
; 1491 : 		
; 1492 : 		if ((flag=ls_util_lookup(phTTS,llp, rlp, context)) != MISS)

  00eff	8b 54 24 1c	 mov	 edx, DWORD PTR _rlp$[esp+12]
  00f03	53		 push	 ebx
  00f04	52		 push	 edx
  00f05	55		 push	 ebp
  00f06	56		 push	 esi
  00f07	e8 00 00 00 00	 call	 _ls_util_lookup
  00f0c	8b d8		 mov	 ebx, eax
  00f0e	83 c4 10	 add	 esp, 16			; 00000010H
  00f11	85 db		 test	 ebx, ebx
  00f13	74 2f		 je	 SHORT $L72559

; 1493 : 		{
; 1494 : 			if (flag == ABBREV)     /* Need to gobble up    */

  00f15	83 fb 02	 cmp	 ebx, 2
  00f18	75 09		 jne	 SHORT $L72560

; 1495 : 				ls_util_read_item(phTTS);                     /* the "." here.        */

  00f1a	56		 push	 esi
  00f1b	e8 00 00 00 00	 call	 _ls_util_read_item
  00f20	83 c4 04	 add	 esp, 4
$L72560:

; 1496 : 			ls_task_do_right_punct(phTTS,flag);

  00f23	53		 push	 ebx
$L73024:
  00f24	56		 push	 esi
  00f25	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 1497 : 
; 1498 : 			ls_task_readword(phTTS,&(pLts_t->cword[0]));

  00f2a	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  00f30	57		 push	 edi
  00f31	56		 push	 esi
  00f32	e8 00 00 00 00	 call	 _ls_task_readword
  00f37	83 c4 10	 add	 esp, 16			; 00000010H

; 1499 : 
; 1500 : 			return(LS_TASK_LOOP);

  00f3a	b8 01 00 00 00	 mov	 eax, 1
  00f3f	5f		 pop	 edi
  00f40	5e		 pop	 esi
  00f41	5d		 pop	 ebp
  00f42	5b		 pop	 ebx

; 1504 : }

  00f43	c3		 ret	 0
$L72559:
  00f44	5f		 pop	 edi
  00f45	5e		 pop	 esi
  00f46	5d		 pop	 ebp

; 1501 : 		}
; 1502 : 	}
; 1503 : 	return(KEEP_SEARCHING);

  00f47	33 c0		 xor	 eax, eax
  00f49	5b		 pop	 ebx

; 1504 : }

  00f4a	c3		 ret	 0
_ls_task_dictionary_search ENDP
_pLts_t$ = 8
_llp$ = 12
_ls_task_strip_left_punctuation PROC NEAR

; 1526 : 	/*
; 1527 : 	 * Pull off all left and
; 1528 : 	 * right enclosing punctuation. We only pull one
; 1529 : 	 * layer, so ((a)) gets spelled (it seems like the right
; 1530 : 	 * thing). Keep track of any required pauses. Also watch
; 1531 : 	 * for things like "I went (last year?) to the show".
; 1532 : 	 * Shuffle the "?" to the right spot. We don't shuffle the
; 1533 : 	 * ".", because it might be part of an abbreviation,
; 1534 : 	 * and abbreviations are more common than imbedded
; 1535 : 	 * periods.
; 1536 : 	 */
; 1537 : #ifdef LS1DEBUG
; 1538 : 		printf("entering ls_task_strip_left_punctuation\n");
; 1539 : #endif
; 1540 : 	 pLts_t->lflag  = 0;                             /* Clear all flags.     */

  00f50	8b 4c 24 04	 mov	 ecx, DWORD PTR _pLts_t$[esp-4]

; 1541 : 
; 1542 : #ifdef LS1DEBUG
; 1543 : 	printf("before punctuation stripping ");
; 1544 : 	printf("left=%u  right=%u\n",(*llp),rlp);
; 1545 : #endif
; 1546 : 	pLts_t->lbphone = WBOUND;

  00f54	b8 6f 00 00 00	 mov	 eax, 111		; 0000006fH
  00f59	89 81 1c 11 00
	00		 mov	 DWORD PTR [ecx+4380], eax

; 1547 : 	pLts_t->rbphone = WBOUND;

  00f5f	89 81 20 11 00
	00		 mov	 DWORD PTR [ecx+4384], eax

; 1548 : 	/* Change this "while" to an "if" to strip only 1 layer.        */
; 1549 : 	while ((lsctype[(*llp)->l_ch]&LS) != 0)

  00f65	8b 44 24 08	 mov	 eax, DWORD PTR _llp$[esp-4]
  00f69	c7 81 f8 08 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+2296], 0
  00f73	8b 10		 mov	 edx, DWORD PTR [eax]
  00f75	0f bf 12	 movsx	 edx, WORD PTR [edx]
  00f78	f6 04 55 00 00
	00 00 40	 test	 BYTE PTR _lsctype[edx*2], 64 ; 00000040H
  00f80	74 3c		 je	 SHORT $L72570
$L72569:

; 1550 : 	{                    
; 1551 : #ifdef LS1DEBUG
; 1552 : 			printf("in left stripping loop %c\n",(*llp)->l_ch);
; 1553 : #endif
; 1554 : 		pLts_t->lflag |= LSTRIP;

  00f82	8b 91 f8 08 00
	00		 mov	 edx, DWORD PTR [ecx+2296]
  00f88	83 ca 01	 or	 edx, 1
  00f8b	89 91 f8 08 00
	00		 mov	 DWORD PTR [ecx+2296], edx

; 1555 : 		if ((lsctype[(*llp)->l_ch]&FB) != 0)

  00f91	8b 10		 mov	 edx, DWORD PTR [eax]
  00f93	0f bf 12	 movsx	 edx, WORD PTR [edx]
  00f96	f6 04 55 01 00
	00 00 01	 test	 BYTE PTR _lsctype[edx*2+1], 1
  00f9e	74 0a		 je	 SHORT $L72571

; 1556 : 		{
; 1557 : 			pLts_t->lbphone = COMMA;

  00fa0	c7 81 1c 11 00
	00 73 00 00 00	 mov	 DWORD PTR [ecx+4380], 115 ; 00000073H
$L72571:

; 1558 : 		}
; 1559 : 		++(*llp);

  00faa	8b 10		 mov	 edx, DWORD PTR [eax]
  00fac	83 c2 08	 add	 edx, 8
  00faf	89 10		 mov	 DWORD PTR [eax], edx
  00fb1	0f bf 12	 movsx	 edx, WORD PTR [edx]
  00fb4	f6 04 55 00 00
	00 00 40	 test	 BYTE PTR _lsctype[edx*2], 64 ; 00000040H
  00fbc	75 c4		 jne	 SHORT $L72569
$L72570:

; 1560 : 	}
; 1561 : }           

  00fbe	c3		 ret	 0
_ls_task_strip_left_punctuation ENDP
_pLts_t$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_strip_right_punctuation PROC NEAR

; 1583 : #ifdef LS1DEBUG
; 1584 : 		printf("entering ls_task_strip_right_punctuation\n");
; 1585 : #endif
; 1586 : 	/* Change this "while" to an "if" to strip only 1 layer.        */
; 1587 : 	while ((*rlp)!=llp && (lsctype[((*rlp)-1)->l_ch]&RS)!=0) 

  00fc0	8b 44 24 0c	 mov	 eax, DWORD PTR _rlp$[esp-4]
  00fc4	55		 push	 ebp
  00fc5	56		 push	 esi
  00fc6	57		 push	 edi
  00fc7	8b 10		 mov	 edx, DWORD PTR [eax]
  00fc9	8b 7c 24 14	 mov	 edi, DWORD PTR _llp$[esp+8]
  00fcd	3b d7		 cmp	 edx, edi
  00fcf	0f 84 8f 00 00
	00		 je	 $L72581
  00fd5	8b 4c 24 10	 mov	 ecx, DWORD PTR _pLts_t$[esp+8]
  00fd9	bd 73 00 00 00	 mov	 ebp, 115		; 00000073H
$L72580:
  00fde	0f bf 52 f8	 movsx	 edx, WORD PTR [edx-8]
  00fe2	f6 04 55 00 00
	00 00 80	 test	 BYTE PTR _lsctype[edx*2], 128 ; 00000080H
  00fea	74 78		 je	 SHORT $L72581

; 1588 : 	{
; 1589 : #ifdef LS1DEBUG
; 1590 : 			printf("in right stripping loop %c\n",llp->l_ch);
; 1591 : #endif
; 1592 : 		pLts_t->lflag |= RSTRIP;

  00fec	8b b1 f8 08 00
	00		 mov	 esi, DWORD PTR [ecx+2296]
  00ff2	83 ce 02	 or	 esi, 2
  00ff5	89 b1 f8 08 00
	00		 mov	 DWORD PTR [ecx+2296], esi

; 1593 : 		--(*rlp);

  00ffb	8b 10		 mov	 edx, DWORD PTR [eax]
  00ffd	83 c2 f8	 add	 edx, -8			; fffffff8H
  01000	89 10		 mov	 DWORD PTR [eax], edx

; 1594 : 		if ((lsctype[(*rlp)->l_ch]&FB) != 0)

  01002	0f bf 12	 movsx	 edx, WORD PTR [edx]
  01005	f6 04 55 01 00
	00 00 01	 test	 BYTE PTR _lsctype[edx*2+1], 1
  0100d	74 06		 je	 SHORT $L72582

; 1595 : 		{
; 1596 : 			pLts_t->rbphone = COMMA;

  0100f	89 a9 20 11 00
	00		 mov	 DWORD PTR [ecx+4384], ebp
$L72582:

; 1597 : 		}
; 1598 : 		if ((*rlp) > llp+1) 

  01015	8b 10		 mov	 edx, DWORD PTR [eax]
  01017	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
  0101a	3b d6		 cmp	 edx, esi
  0101c	76 3c		 jbe	 SHORT $L72585

; 1599 : 		{
; 1600 : 			switch (((*rlp)-1)->l_ch) 
; 1601 : 			{

  0101e	0f bf 52 f8	 movsx	 edx, WORD PTR [edx-8]
  01022	8d 72 df	 lea	 esi, DWORD PTR [edx-33]
  01025	83 fe 1e	 cmp	 esi, 30			; 0000001eH
  01028	77 30		 ja	 SHORT $L72585
  0102a	33 d2		 xor	 edx, edx
  0102c	8a 96 00 00 00
	00		 mov	 dl, BYTE PTR $L73031[esi]
  01032	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L73032[edx*4]
$L72588:

; 1602 : 			case '?':
; 1603 : 				pLts_t->rbphone = QUEST;

  01039	c7 81 20 11 00
	00 75 00 00 00	 mov	 DWORD PTR [ecx+4384], 117 ; 00000075H

; 1604 : 				--(*rlp);
; 1605 : 				break;

  01043	eb 12		 jmp	 SHORT $L73030
$L72589:

; 1606 : 
; 1607 : 			case '!':
; 1608 : 				pLts_t->rbphone = EXCLAIM;

  01045	c7 81 20 11 00
	00 76 00 00 00	 mov	 DWORD PTR [ecx+4384], 118 ; 00000076H

; 1609 : 				--(*rlp);
; 1610 : 				break;

  0104f	eb 06		 jmp	 SHORT $L73030
$L72590:

; 1611 : 
; 1612 : 			case ',':
; 1613 : 			case ':':
; 1614 : 			case ';':
; 1615 : 				pLts_t->rbphone = COMMA;

  01051	89 a9 20 11 00
	00		 mov	 DWORD PTR [ecx+4384], ebp
$L73030:

; 1616 : 				--(*rlp);

  01057	83 00 f8	 add	 DWORD PTR [eax], -8	; fffffff8H
$L72585:
  0105a	8b 10		 mov	 edx, DWORD PTR [eax]
  0105c	3b d7		 cmp	 edx, edi
  0105e	0f 85 7a ff ff
	ff		 jne	 $L72580
$L72581:
  01064	5f		 pop	 edi
  01065	5e		 pop	 esi
  01066	5d		 pop	 ebp

; 1617 : 				break;
; 1618 : 			}
; 1619 : 		}
; 1620 : 	}
; 1621 : }

  01067	c3		 ret	 0
$L73032:
  01068	00 00 00 00	 DD	 $L72589
  0106c	00 00 00 00	 DD	 $L72590
  01070	00 00 00 00	 DD	 $L72588
  01074	00 00 00 00	 DD	 $L72585
$L73031:
  01078	00		 DB	 0
  01079	03		 DB	 3
  0107a	03		 DB	 3
  0107b	03		 DB	 3
  0107c	03		 DB	 3
  0107d	03		 DB	 3
  0107e	03		 DB	 3
  0107f	03		 DB	 3
  01080	03		 DB	 3
  01081	03		 DB	 3
  01082	03		 DB	 3
  01083	01		 DB	 1
  01084	03		 DB	 3
  01085	03		 DB	 3
  01086	03		 DB	 3
  01087	03		 DB	 3
  01088	03		 DB	 3
  01089	03		 DB	 3
  0108a	03		 DB	 3
  0108b	03		 DB	 3
  0108c	03		 DB	 3
  0108d	03		 DB	 3
  0108e	03		 DB	 3
  0108f	03		 DB	 3
  01090	03		 DB	 3
  01091	01		 DB	 1
  01092	01		 DB	 1
  01093	03		 DB	 3
  01094	03		 DB	 3
  01095	03		 DB	 3
  01096	02		 DB	 2
_ls_task_strip_right_punctuation ENDP
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_lp1$ = 20
_lp2$ = 24
_ls_task_spell_all_punct PROC NEAR

; 1649 : 	PLTS_T pLts_t;
; 1650 : 	pLts_t = phTTS->pLTSThreadData;
; 1651 : #ifdef LS1DEBUG
; 1652 : 		printf("entering ls_task_spell_all_punct\n");
; 1653 : #endif
; 1654 : 	if (llp == rlp) 

  010a0	8b 44 24 08	 mov	 eax, DWORD PTR _llp$[esp-4]
  010a4	8b 4c 24 0c	 mov	 ecx, DWORD PTR _rlp$[esp-4]
  010a8	56		 push	 esi
  010a9	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  010ad	57		 push	 edi
  010ae	3b c1		 cmp	 eax, ecx
  010b0	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  010b3	75 30		 jne	 SHORT $L72603

; 1655 : 	{                       /* Null word            */
; 1656 : 		ls_spel_spell(phTTS,lp1, lp2);  /* Always slowly.       */

  010b5	8b 4c 24 1c	 mov	 ecx, DWORD PTR _lp2$[esp+4]
  010b9	8b 54 24 18	 mov	 edx, DWORD PTR _lp1$[esp+4]
  010bd	51		 push	 ecx
  010be	52		 push	 edx
  010bf	56		 push	 esi
  010c0	e8 00 00 00 00	 call	 _ls_spel_spell

; 1657 : #ifdef LS1DEBUG
; 1658 : 			printf("null word spell\n");
; 1659 : #endif
; 1660 : 
; 1661 : 		ls_task_do_right_punct(phTTS,MISS);

  010c5	6a 00		 push	 0
  010c7	56		 push	 esi
  010c8	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 1662 : 		ls_task_readword(phTTS,&(pLts_t->cword[0]));

  010cd	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  010d3	57		 push	 edi
  010d4	56		 push	 esi
  010d5	e8 00 00 00 00	 call	 _ls_task_readword
  010da	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1663 : 
; 1664 : 		return(LS_TASK_LOOP);

  010dd	b8 01 00 00 00	 mov	 eax, 1
  010e2	5f		 pop	 edi
  010e3	5e		 pop	 esi

; 1681 : }

  010e4	c3		 ret	 0
$L72603:

; 1665 : 	}
; 1666 : 	/*
; 1667 : 	 * Deal with any side effects of the
; 1668 : 	 * stripped left hand end punctuation marks.
; 1669 : 	 * They will never be looked at again.
; 1670 : 	 */
; 1671 : 
; 1672 : 	if (pLts_t->lbphone != WBOUND)

  010e5	8b 87 1c 11 00
	00		 mov	 eax, DWORD PTR [edi+4380]
  010eb	83 f8 6f	 cmp	 eax, 111		; 0000006fH
  010ee	74 0a		 je	 SHORT $L72604

; 1673 : 		ls_util_send_phone(phTTS,pLts_t->lbphone);

  010f0	50		 push	 eax
  010f1	56		 push	 esi
  010f2	e8 00 00 00 00	 call	 _ls_util_send_phone
  010f7	83 c4 08	 add	 esp, 8
$L72604:
  010fa	5f		 pop	 edi

; 1674 : 
; 1675 : #ifdef LS1DEBUG
; 1676 : 	printf("after punctuation stripping ");
; 1677 : 	printf("left=%u  right=%u\n",llp,rlp);
; 1678 : #endif
; 1679 : 
; 1680 : 	return(KEEP_SEARCHING);

  010fb	33 c0		 xor	 eax, eax
  010fd	5e		 pop	 esi

; 1681 : }

  010fe	c3		 ret	 0
_ls_task_spell_all_punct ENDP
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_context$ = 8
_ls_task_dictionary_after_punct PROC NEAR

; 1708 : {

  01100	53		 push	 ebx
  01101	55		 push	 ebp
  01102	56		 push	 esi
  01103	57		 push	 edi

; 1709 : 	int context;
; 1710 : 	int flag;
; 1711 : 	LETTER *lp1;
; 1712 : 	PLTS_T pLts_t;
; 1713 : 	pLts_t = phTTS->pLTSThreadData;

  01104	8b 7c 24 14	 mov	 edi, DWORD PTR _phTTS$[esp+12]

; 1714 : #ifdef LS1DEBUG
; 1715 : 		printf("entering ls_task_dictionary_after_punct\n");
; 1716 : #endif
; 1717 : 	
; 1718 : 	/*
; 1719 : 	 * If the above code stripped off a
; 1720 : 	 * punctuation mark, give the dictionary another try
; 1721 : 	 * at it. Duck out through the common exit if we get a
; 1722 : 	 * hit at this level. We also understand how to deal
; 1723 : 	 * with an abbreviation contexts that are hidden
; 1724 : 	 * by right end strippable punctuation.
; 1725 : 	 */
; 1726 : 
; 1727 : 	context = FIRST;
; 1728 : 	if (((pLts_t->lflag)&RSTRIP) != 0) 

  01108	8b 6c 24 1c	 mov	 ebp, DWORD PTR _rlp$[esp+12]
  0110c	8b 5c 24 18	 mov	 ebx, DWORD PTR _llp$[esp+12]
  01110	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _context$[esp+12], 0
  01118	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  0111b	f6 86 f8 08 00
	00 02		 test	 BYTE PTR [esi+2296], 2
  01122	74 4f		 je	 SHORT $L72616

; 1729 : 	{
; 1730 : 		lp1 = (*rlp)-1;

  01124	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  01127	83 e8 08	 sub	 eax, 8

; 1731 : 		if (llp!=lp1 && lp1->l_ch=='.') 

  0112a	3b d8		 cmp	 ebx, eax
  0112c	74 5a		 je	 SHORT $L72621
  0112e	66 83 38 2e	 cmp	 WORD PTR [eax], 46	; 0000002eH
  01132	75 54		 jne	 SHORT $L72621

; 1732 : 		{
; 1733 : 			if ((flag=ls_util_lookup(phTTS,llp, lp1, FABBREV)) != MISS) 

  01134	6a 01		 push	 1
  01136	50		 push	 eax
  01137	53		 push	 ebx
  01138	57		 push	 edi
  01139	e8 00 00 00 00	 call	 _ls_util_lookup
  0113e	83 c4 10	 add	 esp, 16			; 00000010H
  01141	85 c0		 test	 eax, eax
  01143	74 19		 je	 SHORT $L72618

; 1734 : 			{
; 1735 : 				if (flag != ABBREV)

  01145	83 f8 02	 cmp	 eax, 2
  01148	74 0a		 je	 SHORT $L72619

; 1736 : 					pLts_t->rbphone = PERIOD;

  0114a	c7 86 20 11 00
	00 74 00 00 00	 mov	 DWORD PTR [esi+4384], 116 ; 00000074H
$L72619:
  01154	5f		 pop	 edi
  01155	5e		 pop	 esi
  01156	5d		 pop	 ebp

; 1737 : 				return(FINISHED_WORD);

  01157	b8 03 00 00 00	 mov	 eax, 3
  0115c	5b		 pop	 ebx

; 1756 : } 

  0115d	c3		 ret	 0
$L72618:

; 1738 : 			}
; 1739 : 			pLts_t->rbphone = PERIOD;       /* Very strong.         */

  0115e	c7 86 20 11 00
	00 74 00 00 00	 mov	 DWORD PTR [esi+4384], 116 ; 00000074H

; 1740 : 			--(*rlp);

  01168	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0116b	83 c0 f8	 add	 eax, -8			; fffffff8H
  0116e	89 45 00	 mov	 DWORD PTR [ebp], eax

; 1741 : 		}
; 1742 : 	} 
; 1743 : 	else 

  01171	eb 15		 jmp	 SHORT $L72621
$L72616:

; 1744 : 	{
; 1745 : 		if (ls_util_is_dot(pLts_t) != FALSE)            /* "(Gov. Smith)"       */

  01173	56		 push	 esi
  01174	e8 00 00 00 00	 call	 _ls_util_is_dot
  01179	83 c4 04	 add	 esp, 4
  0117c	85 c0		 test	 eax, eax
  0117e	74 08		 je	 SHORT $L72621

; 1746 : 			context = FABBREV;

  01180	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _context$[esp+12], 1
$L72621:

; 1747 : 	}
; 1748 : 	if (((pLts_t->lflag)&(LSTRIP|RSTRIP)) != 0
; 1749 : 		&& (flag=ls_util_lookup(phTTS,llp, (*rlp), context)) != MISS) 

  01188	f6 86 f8 08 00
	00 03		 test	 BYTE PTR [esi+2296], 3
  0118f	74 2f		 je	 SHORT $L72622
  01191	8b 44 24 14	 mov	 eax, DWORD PTR _context$[esp+12]
  01195	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  01198	50		 push	 eax
  01199	51		 push	 ecx
  0119a	53		 push	 ebx
  0119b	57		 push	 edi
  0119c	e8 00 00 00 00	 call	 _ls_util_lookup
  011a1	83 c4 10	 add	 esp, 16			; 00000010H
  011a4	85 c0		 test	 eax, eax
  011a6	74 18		 je	 SHORT $L72622

; 1750 : 	{
; 1751 : 		if (flag == ABBREV)             /* Eat the "."          */

  011a8	83 f8 02	 cmp	 eax, 2
  011ab	75 09		 jne	 SHORT $L72623

; 1752 : 			ls_util_read_item(phTTS);

  011ad	57		 push	 edi
  011ae	e8 00 00 00 00	 call	 _ls_util_read_item
  011b3	83 c4 04	 add	 esp, 4
$L72623:
  011b6	5f		 pop	 edi
  011b7	5e		 pop	 esi
  011b8	5d		 pop	 ebp

; 1753 : 		return(FINISHED_WORD);

  011b9	b8 03 00 00 00	 mov	 eax, 3
  011be	5b		 pop	 ebx

; 1756 : } 

  011bf	c3		 ret	 0
$L72622:
  011c0	5f		 pop	 edi
  011c1	5e		 pop	 esi
  011c2	5d		 pop	 ebp

; 1754 : 	}
; 1755 : 	return(KEEP_SEARCHING);

  011c3	33 c0		 xor	 eax, eax
  011c5	5b		 pop	 ebx

; 1756 : } 

  011c6	c3		 ret	 0
_ls_task_dictionary_after_punct ENDP
_TEXT	ENDS
EXTRN	_ls_spel_say_it:NEAR
EXTRN	__imp__fprintf:NEAR
_DATA	SEGMENT
	ORG $+1
$SG72635 DB	0aH, 'SPELL IT (HIT)', 00H
$SG72636 DB	0aH, 'SPELL IT (HIT)', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_spell_vs_speak PROC NEAR

; 1782 : {   

  011d0	53		 push	 ebx

; 1783 : /*
; 1784 :  *  run through the new speak/spell rule tables ...
; 1785 :  */
; 1786 : 	PKSD_T	pKsd_t;
; 1787 : 	pKsd_t = phTTS->pKernelShareData;   
; 1788 : 
; 1789 : 
; 1790 : 
; 1791 : #ifdef LS1DEBUG
; 1792 : 	printf("entering ls_task_spell_vs_speak\n");
; 1793 : 	printf("ls_spel_say_it ");
; 1794 : 	printf("left=%u  right=%u\n",llp,rlp);
; 1795 : #endif
; 1796 : 
; 1797 : 	if(ls_spel_say_it(llp,rlp) == FALSE)

  011d1	8b 5c 24 10	 mov	 ebx, DWORD PTR _rlp$[esp]
  011d5	55		 push	 ebp
  011d6	8b 6c 24 10	 mov	 ebp, DWORD PTR _llp$[esp+4]
  011da	56		 push	 esi
  011db	57		 push	 edi
  011dc	8b 7c 24 14	 mov	 edi, DWORD PTR _phTTS$[esp+12]
  011e0	53		 push	 ebx
  011e1	55		 push	 ebp
  011e2	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  011e5	e8 00 00 00 00	 call	 _ls_spel_say_it
  011ea	83 c4 08	 add	 esp, 8
  011ed	85 c0		 test	 eax, eax
  011ef	75 4d		 jne	 SHORT $L72632

; 1798 : 	{
; 1799 : #ifdef LS1DEBUG
; 1800 : 			printf("ls_spel_say_it spell\n");
; 1801 : #endif
; 1802 : 				/* debug switch */
; 1803 : 		if (DT_DBG(LTS_DBG,0x400))

  011f1	66 8b 86 78 04
	00 00		 mov	 ax, WORD PTR [esi+1144]
  011f8	f6 c4 40	 test	 ah, 64			; 00000040H
  011fb	74 2c		 je	 SHORT $L72633
  011fd	f6 c4 04	 test	 ah, 4
  01200	74 27		 je	 SHORT $L72633

; 1804 : 			{
; 1805 : #ifndef MSDOS
; 1806 : 				if (pKsd_t->dbglog)			/*mfg 05/13/98 added debug support*/

  01202	8b b6 7c 04 00
	00		 mov	 esi, DWORD PTR [esi+1148]
  01208	85 f6		 test	 esi, esi
  0120a	74 0f		 je	 SHORT $L72634

; 1807 : 					fprintf(pKsd_t->dbglog,"\nSPELL IT (HIT)");

  0120c	68 00 00 00 00	 push	 OFFSET FLAT:$SG72635
  01211	56		 push	 esi
  01212	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  01218	83 c4 08	 add	 esp, 8
$L72634:

; 1808 : #endif     
; 1809 : 				printf("\nSPELL IT (HIT)");

  0121b	68 00 00 00 00	 push	 OFFSET FLAT:$SG72636
  01220	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  01226	83 c4 04	 add	 esp, 4
$L72633:

; 1810 : 			}
; 1811 : 
; 1812 : 
; 1813 : 		ls_spel_spell(phTTS,llp,rlp);

  01229	53		 push	 ebx
  0122a	55		 push	 ebp
  0122b	57		 push	 edi
  0122c	e8 00 00 00 00	 call	 _ls_spel_spell
  01231	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1814 : 		return(FINISHED_WORD);

  01234	b8 03 00 00 00	 mov	 eax, 3
  01239	5f		 pop	 edi
  0123a	5e		 pop	 esi
  0123b	5d		 pop	 ebp
  0123c	5b		 pop	 ebx

; 1817 : }

  0123d	c3		 ret	 0
$L72632:
  0123e	5f		 pop	 edi
  0123f	5e		 pop	 esi
  01240	5d		 pop	 ebp

; 1815 : 	}                         
; 1816 : 	return(KEEP_SEARCHING);

  01241	33 c0		 xor	 eax, eax
  01243	5b		 pop	 ebx

; 1817 : }

  01244	c3		 ret	 0
_ls_task_spell_vs_speak ENDP
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_pLts_t$ = -4
_ls_task_single_letter_spell_rules PROC NEAR

; 1842 : {

  01250	51		 push	 ecx

; 1843 : 	int c;
; 1844 : 	LETTER *lp1;
; 1845 : 	int flag;
; 1846 : 	PLTS_T pLts_t;
; 1847 : 	pLts_t = phTTS->pLTSThreadData;

  01251	8b 44 24 08	 mov	 eax, DWORD PTR _phTTS$[esp]
  01255	53		 push	 ebx
  01256	55		 push	 ebp

; 1848 : 
; 1849 : #ifdef LS1DEBUG
; 1850 : 	printf("entering ls_task_single_letter_spell_rules");
; 1851 : 	printf("left=%u  right=%u\n",llp,rlp);
; 1852 : #endif 
; 1853 : 
; 1854 : 	/*
; 1855 : 	 * There are a small set of rules that must be
; 1856 : 	 * run before case distinctions and diacritical marks
; 1857 : 	 * are lost. Single character words are usually spelled,
; 1858 : 	 * but there are some important exceptions. Sequences of
; 1859 : 	 * upper case letters separated by periods (I.B.M.)
; 1860 : 	 * are processed by a fast spelling rule.
; 1861 : 	 */
; 1862 : 	if (llp+1 == rlp)

  01257	8b 6c 24 18	 mov	 ebp, DWORD PTR _rlp$[esp+8]
  0125b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0125e	56		 push	 esi
  0125f	8b 74 24 18	 mov	 esi, DWORD PTR _llp$[esp+12]
  01263	57		 push	 edi
  01264	89 4c 24 10	 mov	 DWORD PTR _pLts_t$[esp+20], ecx
  01268	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
  0126b	3b fd		 cmp	 edi, ebp
  0126d	0f 85 3d 01 00
	00		 jne	 $L72648

; 1863 : 	{
; 1864 : 		c = llp->l_ch;

  01273	0f bf 3e	 movsx	 edi, WORD PTR [esi]

; 1865 : 
; 1866 : 		/*
; 1867 : 		 * Any upper case letter that does not have
; 1868 : 		 * any stripped punctuation, and is followed by a
; 1869 : 		 * period, is taken to be someones initial. The
; 1870 : 		 * period goes away, and the word is spelled.
; 1871 : 		 *
; 1872 : 		 * If you want to make this rule go away you
; 1873 : 		 * can safely just delete the following "if" and
; 1874 : 		 * it's corresponding body.
; 1875 : 		 */
; 1876 : 
; 1877 : 		if (IS_UPPER(c) 
; 1878 : 		&& ((pLts_t->lflag)&(LSTRIP|RSTRIP))==0 && ls_util_is_dot(pLts_t)!=FALSE)

  01276	8b d7		 mov	 edx, edi
  01278	bb 03 00 00 00	 mov	 ebx, 3
  0127d	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  01283	f6 82 00 00 00
	00 02		 test	 BYTE PTR _ls_char_feat[edx], 2
  0128a	74 3f		 je	 SHORT $L72649
  0128c	84 99 f8 08 00
	00		 test	 BYTE PTR [ecx+2296], bl
  01292	75 37		 jne	 SHORT $L72649
  01294	51		 push	 ecx
  01295	e8 00 00 00 00	 call	 _ls_util_is_dot
  0129a	83 c4 04	 add	 esp, 4
  0129d	85 c0		 test	 eax, eax
  0129f	74 26		 je	 SHORT $L73044

; 1879 : 		{
; 1880 : 			/* BATS 460 MGS 10/08/1997 Fixed A. B. C. problem losing periods */
; 1881 : 			pLts_t->rbphone=PERIOD;

  012a1	8b 44 24 10	 mov	 eax, DWORD PTR _pLts_t$[esp+20]

; 1882 : 			ls_util_read_item(phTTS);

  012a5	8b 4c 24 18	 mov	 ecx, DWORD PTR _phTTS$[esp+16]
  012a9	51		 push	 ecx
  012aa	c7 80 20 11 00
	00 74 00 00 00	 mov	 DWORD PTR [eax+4384], 116 ; 00000074H
  012b4	e8 00 00 00 00	 call	 _ls_util_read_item
  012b9	83 c4 04	 add	 esp, 4

; 1883 : #ifdef LS1DEBUG
; 1884 : 			printf(" spell cap letter \n");
; 1885 : #endif
; 1886 : 
; 1887 : 			return(SPELL_WORD);

  012bc	b8 02 00 00 00	 mov	 eax, 2
  012c1	5f		 pop	 edi
  012c2	5e		 pop	 esi
  012c3	5d		 pop	 ebp
  012c4	5b		 pop	 ebx

; 2019 : }           

  012c5	59		 pop	 ecx
  012c6	c3		 ret	 0
$L73044:

; 1883 : #ifdef LS1DEBUG
; 1884 : 			printf(" spell cap letter \n");
; 1885 : #endif
; 1886 : 
; 1887 : 			return(SPELL_WORD);

  012c7	8b 4c 24 10	 mov	 ecx, DWORD PTR _pLts_t$[esp+20]
$L72649:

; 1888 : 		}                                         
; 1889 : 
; 1890 : #ifdef ENGLISH
; 1891 : 		/*
; 1892 : 		 * I    => [`A].        Note stress.
; 1893 : 		 * "I"  => ['A].        This is consistant with
; 1894 : 		 * (I)  => ['A].        the spelling entry.
; 1895 : 		 */
; 1896 : 
; 1897 : 		if (c=='i' || c=='I')

  012cb	83 ff 69	 cmp	 edi, 105		; 00000069H
  012ce	0f 84 a5 00 00
	00		 je	 $L72651
  012d4	83 ff 49	 cmp	 edi, 73			; 00000049H
  012d7	0f 84 9c 00 00
	00		 je	 $L72651

; 1906 : 		}
; 1907 : 
; 1908 : 		/*
; 1909 : 		 * The single character word "a" has two
; 1910 : 		 * different pronounciations. The default one, from
; 1911 : 		 * the spelling entry in the dictionary, is ['e]. The
; 1912 : 		 * exception (actually the most common case) is [x].
; 1913 : 		 * Use [x] if no stripping, and the "a" is not sitting
; 1914 : 		 * against a punctuation mark ("a box." vs "box a.").
; 1915 : 		 */
; 1916 :         /*
; 1917 :            GL 9/10/1996, add checking isnumabr to fix "4.4 a" problem
; 1918 : 		   GL 8/14/1997, for BATS#441 only pLts_t->isnumabr is 0  or 1 "a" will be "AX"
; 1919 :          */
; 1920 : 		if ((c=='a' || c=='A') && (pLts_t->isnumabr == 0 || pLts_t->isnumabr == 1)
; 1921 : 			&& ((pLts_t->lflag)&(LSTRIP|RSTRIP))==0 && ls_util_is_white(&(pLts_t->citem))==TRUE)

  012dd	83 ff 61	 cmp	 edi, 97			; 00000061H
  012e0	74 05		 je	 SHORT $L72655
  012e2	83 ff 41	 cmp	 edi, 65			; 00000041H
  012e5	75 5f		 jne	 SHORT $L72654
$L72655:
  012e7	8b 81 fc 08 00
	00		 mov	 eax, DWORD PTR [ecx+2300]
  012ed	85 c0		 test	 eax, eax
  012ef	74 05		 je	 SHORT $L72656
  012f1	83 f8 01	 cmp	 eax, 1
  012f4	75 50		 jne	 SHORT $L72654
$L72656:
  012f6	84 99 f8 08 00
	00		 test	 BYTE PTR [ecx+2296], bl
  012fc	75 48		 jne	 SHORT $L72654
  012fe	81 c1 00 09 00
	00		 add	 ecx, 2304		; 00000900H
  01304	51		 push	 ecx
  01305	e8 00 00 00 00	 call	 _ls_util_is_white
  0130a	83 c4 04	 add	 esp, 4
  0130d	83 f8 01	 cmp	 eax, 1
  01310	75 34		 jne	 SHORT $L72654

; 1922 : 		{
; 1923 : 			pLts_t->fc_struct[pLts_t->fc_index] = FC_ART;

  01312	8b 44 24 10	 mov	 eax, DWORD PTR _pLts_t$[esp+20]

; 1924 : 			ls_util_send_phone(phTTS,SPECIALWORD);	

  01316	8b 74 24 18	 mov	 esi, DWORD PTR _phTTS$[esp+16]
  0131a	6a 78		 push	 120			; 00000078H
  0131c	56		 push	 esi
  0131d	8b 90 bc 08 00
	00		 mov	 edx, DWORD PTR [eax+2236]
  01323	c7 84 90 bc 04
	00 00 04 00 00
	00		 mov	 DWORD PTR [eax+edx*4+1212], 4
  0132e	e8 00 00 00 00	 call	 _ls_util_send_phone

; 1925 : 			ls_util_send_phone(phTTS,AX);			

  01333	6a 11		 push	 17			; 00000011H
  01335	56		 push	 esi
  01336	e8 00 00 00 00	 call	 _ls_util_send_phone
  0133b	83 c4 10	 add	 esp, 16			; 00000010H

; 1926 : #ifdef LS1DEBUG
; 1927 : 			printf(" a to ah code \n");
; 1928 : #endif
; 1929 : 			return(FINISHED_WORD);

  0133e	8b c3		 mov	 eax, ebx
  01340	5f		 pop	 edi
  01341	5e		 pop	 esi
  01342	5d		 pop	 ebp
  01343	5b		 pop	 ebx

; 2019 : }           

  01344	59		 pop	 ecx
  01345	c3		 ret	 0
$L72654:

; 1930 : 		}
; 1931 : #endif
; 1932 : #ifdef SPANISH
; 1933 : 		/*igrega or i code*/
; 1934 : 		if ((c=='y' || c=='Y')
; 1935 : 		&& ((pLts_t->lflag)&(LSTRIP|RSTRIP))==0 && ls_util_is_white(&(pLts_t->citem))!=FALSE)
; 1936 : 		{
; 1937 : 			pLts_t->fc_struct[pLts_t->fc_index] = FC_CONJ;
; 1938 : 			ls_util_send_phone(phTTS,E_I);
; 1939 : #ifdef LS1DEBUG
; 1940 : 			printf(" iggre to i  code \n");
; 1941 : #endif
; 1942 : 
; 1943 : 			return(FINISHED_WORD);
; 1944 : 		}
; 1945 : 
; 1946 : #endif		
; 1947 : 		/*
; 1948 : 		 * Most other single letter words get
; 1949 : 		 * spelled. Watch out for single character numbers
; 1950 : 		 * (the digits, and the 1/4 and 1/2 DEC supplimental
; 1951 : 		 * characters) which must go through the number
; 1952 : 		 * processing heuristics.
; 1953 : 		 */
; 1954 : 		if (c!=0xBC && c!=0xBD && !IS_DIGIT(llp->l_ch))

  01346	81 ff bc 00 00
	00		 cmp	 edi, 188		; 000000bcH
  0134c	0f 84 05 01 00
	00		 je	 $L72666
  01352	81 ff bd 00 00
	00		 cmp	 edi, 189		; 000000bdH
  01358	0f 84 f9 00 00
	00		 je	 $L72666
  0135e	0f bf 06	 movsx	 eax, WORD PTR [esi]
  01361	f6 80 00 00 00
	00 10		 test	 BYTE PTR _ls_char_feat[eax], 16 ; 00000010H
  01368	0f 85 e9 00 00
	00		 jne	 $L72666
  0136e	5f		 pop	 edi
  0136f	5e		 pop	 esi
  01370	5d		 pop	 ebp

; 1955 : 		{
; 1956 : #ifdef LS1DEBUG
; 1957 : 			printf("single letter spell\n");
; 1958 : #endif
; 1959 : 
; 1960 : 			return(SPELL_WORD);

  01371	b8 02 00 00 00	 mov	 eax, 2
  01376	5b		 pop	 ebx

; 2019 : }           

  01377	59		 pop	 ecx
  01378	c3		 ret	 0
$L72651:

; 1898 : 		{
; 1899 : 			if (((pLts_t->lflag)&(LSTRIP|RSTRIP)) != 0)

  01379	84 99 f8 08 00
	00		 test	 BYTE PTR [ecx+2296], bl
  0137f	74 09		 je	 SHORT $L72652

; 1900 : 				ls_util_send_phone(phTTS,S1);

  01381	8b 4c 24 18	 mov	 ecx, DWORD PTR _phTTS$[esp+16]
  01385	6a 67		 push	 103			; 00000067H
  01387	51		 push	 ecx

; 1901 : 			else            

  01388	eb 07		 jmp	 SHORT $L73049
$L72652:

; 1902 : 				ls_util_send_phone(phTTS,S2);

  0138a	8b 54 24 18	 mov	 edx, DWORD PTR _phTTS$[esp+16]
  0138e	6a 66		 push	 102			; 00000066H
  01390	52		 push	 edx
$L73049:
  01391	e8 00 00 00 00	 call	 _ls_util_send_phone

; 1903 : 
; 1904 : 			ls_util_send_phone(phTTS,AY);			

  01396	8b 44 24 20	 mov	 eax, DWORD PTR _phTTS$[esp+24]
  0139a	83 c4 08	 add	 esp, 8
  0139d	6a 07		 push	 7
  0139f	50		 push	 eax
  013a0	e8 00 00 00 00	 call	 _ls_util_send_phone
  013a5	83 c4 08	 add	 esp, 8

; 1905 : 			return(FINISHED_WORD);

  013a8	8b c3		 mov	 eax, ebx
  013aa	5f		 pop	 edi
  013ab	5e		 pop	 esi
  013ac	5d		 pop	 ebp
  013ad	5b		 pop	 ebx

; 2019 : }           

  013ae	59		 pop	 ecx
  013af	c3		 ret	 0
$L72648:

; 1961 : 		}
; 1962 : 	}
; 1963 : 	else
; 1964 : 	{
; 1965 : 		flag = FALSE;                   /* Start validation.    */

  013b0	33 db		 xor	 ebx, ebx

; 1966 : 		lp1  = llp;
; 1967 : 		while (lp1 != rlp) 

  013b2	3b f5		 cmp	 esi, ebp
  013b4	8b c6		 mov	 eax, esi
  013b6	74 6d		 je	 SHORT $L72669
$L72660:

; 1968 : 		{
; 1969 : 			if (flag == FALSE) 

  013b8	85 db		 test	 ebx, ebx
  013ba	75 18		 jne	 SHORT $L72662

; 1970 : 			{    /* FALSE => even.       */
; 1971 : 
; 1972 : 				/*
; 1973 : 				 * On a standard DECtalk all of
; 1974 : 				 * the characters in an "I.B.M." thing
; 1975 : 				 * must be in upper case. On the special
; 1976 : 				 * Kurzweil DECtalk any letter will do.
; 1977 : 				 * A letter is defined here as vowel
; 1978 : 				 * or consonant.
; 1979 : 				 */
; 1980 : 				
; 1981 : 				if (!(IS_UPPER(lp1->l_ch)))

  013bc	8a 10		 mov	 dl, BYTE PTR [eax]
  013be	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  013c4	f6 82 00 00 00
	00 02		 test	 BYTE PTR _ls_char_feat[edx], 2
  013cb	74 18		 je	 SHORT $L73040

; 1982 : 					break;
; 1983 : 				flag = TRUE;

  013cd	bb 01 00 00 00	 mov	 ebx, 1

; 1984 : 			} 
; 1985 : 			else 

  013d2	eb 08		 jmp	 SHORT $L72664
$L72662:

; 1986 : 			{                /* TRUE => odd.         */
; 1987 : 				if (lp1->l_ch != '.')

  013d4	66 83 38 2e	 cmp	 WORD PTR [eax], 46	; 0000002eH
  013d8	75 0b		 jne	 SHORT $L73040

; 1988 : 					break;
; 1989 : 				flag = FALSE;

  013da	33 db		 xor	 ebx, ebx
$L72664:

; 1990 : 			}
; 1991 : 			++lp1;

  013dc	83 c0 08	 add	 eax, 8
  013df	3b c5		 cmp	 eax, ebp
  013e1	75 d5		 jne	 SHORT $L72660

; 1992 : 		}
; 1993 : 		if (lp1 == rlp) 

  013e3	eb 04		 jmp	 SHORT $L73043
$L73040:
  013e5	3b c5		 cmp	 eax, ebp
  013e7	75 6e		 jne	 SHORT $L72666
$L73043:

; 1994 : 		{               /* Ate it all.          */
; 1995 : 			lp1 = llp;
; 1996 : 			while (lp1 != rlp) 

  013e9	3b f5		 cmp	 esi, ebp
  013eb	74 38		 je	 SHORT $L72669
$L72668:

; 1997 : 			{
; 1998 : #ifdef LS1DEBUG
; 1999 : 				printf("ate it all spell\n");
; 2000 : #endif
; 2001 : 
; 2002 : 				ls_spel_spell(phTTS,lp1, lp1+1);

  013ed	8b 44 24 18	 mov	 eax, DWORD PTR _phTTS$[esp+16]
  013f1	57		 push	 edi
  013f2	56		 push	 esi
  013f3	50		 push	 eax
  013f4	e8 00 00 00 00	 call	 _ls_spel_spell

; 2003 : 				++lp1;

  013f9	83 c6 08	 add	 esi, 8
  013fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  013ff	83 c7 08	 add	 edi, 8

; 2004 : 				if (lp1 != rlp) 

  01402	3b f5		 cmp	 esi, ebp
  01404	74 1b		 je	 SHORT $L73046

; 2005 : 				{
; 2006 : 					++lp1;

  01406	83 c6 08	 add	 esi, 8
  01409	83 c7 08	 add	 edi, 8

; 2007 : 				}
; 2008 : 				if (lp1 != rlp)

  0140c	3b f5		 cmp	 esi, ebp
  0140e	74 11		 je	 SHORT $L73046

; 2009 : 					ls_util_send_phone(phTTS,WBOUND);

  01410	8b 4c 24 18	 mov	 ecx, DWORD PTR _phTTS$[esp+16]
  01414	6a 6f		 push	 111			; 0000006fH
  01416	51		 push	 ecx
  01417	e8 00 00 00 00	 call	 _ls_util_send_phone
  0141c	83 c4 08	 add	 esp, 8
  0141f	eb cc		 jmp	 SHORT $L72668
$L73046:

; 1994 : 		{               /* Ate it all.          */
; 1995 : 			lp1 = llp;
; 1996 : 			while (lp1 != rlp) 

  01421	8b 4c 24 10	 mov	 ecx, DWORD PTR _pLts_t$[esp+20]
$L72669:

; 2010 : 			}
; 2011 : 			if (flag != FALSE       /* Last a letter.       */
; 2012 : 			&& ((pLts_t->lflag)&RSTRIP) == 0  /* and no right strip   */
; 2013 : 			&& ls_util_is_dot(pLts_t) != FALSE)    /* and sitting on "."   */

  01425	85 db		 test	 ebx, ebx
  01427	74 23		 je	 SHORT $L72672
  01429	f6 81 f8 08 00
	00 02		 test	 BYTE PTR [ecx+2296], 2
  01430	75 1a		 jne	 SHORT $L72672
  01432	51		 push	 ecx
  01433	e8 00 00 00 00	 call	 _ls_util_is_dot
  01438	83 c4 04	 add	 esp, 4
  0143b	85 c0		 test	 eax, eax
  0143d	74 0d		 je	 SHORT $L72672

; 2014 : 				ls_util_read_item(phTTS);     /* eat up the ".".      */

  0143f	8b 54 24 18	 mov	 edx, DWORD PTR _phTTS$[esp+16]
  01443	52		 push	 edx
  01444	e8 00 00 00 00	 call	 _ls_util_read_item
  01449	83 c4 04	 add	 esp, 4
$L72672:
  0144c	5f		 pop	 edi
  0144d	5e		 pop	 esi
  0144e	5d		 pop	 ebp

; 2015 : 			return(FINISHED_WORD);

  0144f	b8 03 00 00 00	 mov	 eax, 3
  01454	5b		 pop	 ebx

; 2019 : }           

  01455	59		 pop	 ecx
  01456	c3		 ret	 0
$L72666:
  01457	5f		 pop	 edi
  01458	5e		 pop	 esi
  01459	5d		 pop	 ebp

; 2016 : 		}
; 2017 : 	}
; 2018 : 	return(KEEP_SEARCHING);

  0145a	33 c0		 xor	 eax, eax
  0145c	5b		 pop	 ebx

; 2019 : }           

  0145d	59		 pop	 ecx
  0145e	c3		 ret	 0
_ls_task_single_letter_spell_rules ENDP
_llp$ = 8
_rlp$ = 12
_ls_task_remove_case PROC NEAR

; 2045 : 	while (llp != rlp) 

  01460	8b 44 24 04	 mov	 eax, DWORD PTR _llp$[esp-4]
  01464	8b 4c 24 08	 mov	 ecx, DWORD PTR _rlp$[esp-4]
  01468	3b c1		 cmp	 eax, ecx
  0146a	74 16		 je	 SHORT $L72680
$L72679:

; 2046 : 	{
; 2047 : 		llp->l_ch = ls_lower[llp->l_ch];

  0146c	0f bf 10	 movsx	 edx, WORD PTR [eax]

; 2048 : 		++llp;

  0146f	83 c0 08	 add	 eax, 8
  01472	66 0f b6 92 00
	00 00 00	 movzx	 dx, BYTE PTR _ls_lower[edx]
  0147a	66 89 50 f8	 mov	 WORD PTR [eax-8], dx
  0147e	3b c1		 cmp	 eax, ecx
  01480	75 ea		 jne	 SHORT $L72679
$L72680:

; 2049 : 	}
; 2050 : }

  01482	c3		 ret	 0
_ls_task_remove_case ENDP
_TEXT	ENDS
EXTRN	_pstreet:BYTE
EXTRN	_psaint:BYTE
EXTRN	_pdoctor:BYTE
EXTRN	_pdrive:BYTE
EXTRN	_ls_util_copyword:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_Dr_St_process PROC NEAR

; 2077 : #ifdef ENGLISH
; 2078 : 	int     c1;
; 2079 : 	int     c2;
; 2080 : 	PLTS_T pLts_t;
; 2081 : 	pLts_t = phTTS->pLTSThreadData;

  01490	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]

; 2082 : 
; 2083 : 	/*
; 2084 : 	 * Watch for "Dr." and "St.". Look ahead to
; 2085 : 	 * determine the correct pronounciation, then move
; 2086 : 	 * the ls_task_lookahead into the working word. The two line
; 2087 : 	 * "if" at the start implements rules similar in spirit
; 2088 : 	 * to the code in the first dictionary scan, that has
; 2089 : 	 * do decide if this is an abbreviation context.
; 2090 : 	 */
; 2091 : 
; 2092 : #ifdef LS1DEBUG
; 2093 : 	printf("dr. st. processing ");
; 2094 : 	printf("left=%u  right=%u\n",llp,rlp);
; 2095 : #endif
; 2096 : 				
; 2097 : 	if ((llp+3==rlp && (llp+2)->l_ch=='.')
; 2098 : 	||  (llp+2==rlp && ((pLts_t->lflag)&RSTRIP)==0 && ls_util_is_dot(pLts_t)!=FALSE)) 

  01494	8b 4c 24 0c	 mov	 ecx, DWORD PTR _rlp$[esp-4]
  01498	53		 push	 ebx
  01499	55		 push	 ebp
  0149a	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]
  0149d	56		 push	 esi
  0149e	8b 74 24 14	 mov	 esi, DWORD PTR _llp$[esp+8]
  014a2	57		 push	 edi
  014a3	8d 56 18	 lea	 edx, DWORD PTR [esi+24]
  014a6	3b d1		 cmp	 edx, ecx
  014a8	75 0a		 jne	 SHORT $L72693
  014aa	66 83 7e 10 2e	 cmp	 WORD PTR [esi+16], 46	; 0000002eH
  014af	8d 6e 10	 lea	 ebp, DWORD PTR [esi+16]
  014b2	74 21		 je	 SHORT $L72692
$L72693:
  014b4	8d 6e 10	 lea	 ebp, DWORD PTR [esi+16]
  014b7	3b e9		 cmp	 ebp, ecx
  014b9	75 2b		 jne	 SHORT $L72694
  014bb	f6 83 f8 08 00
	00 02		 test	 BYTE PTR [ebx+2296], 2
  014c2	75 22		 jne	 SHORT $L72694
  014c4	53		 push	 ebx
  014c5	e8 00 00 00 00	 call	 _ls_util_is_dot
  014ca	83 c4 04	 add	 esp, 4
  014cd	85 c0		 test	 eax, eax
  014cf	74 15		 je	 SHORT $L72694
  014d1	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rlp$[esp+12]
$L72692:

; 2099 : 	{
; 2100 : 		c1 = (llp+0)->l_ch;

  014d5	0f bf 3e	 movsx	 edi, WORD PTR [esi]

; 2101 : 		c2 = (llp+1)->l_ch;

  014d8	0f bf 46 08	 movsx	 eax, WORD PTR [esi+8]

; 2102 : 		if ((c1=='s' && c2=='t') || (c1=='d' && c2=='r')) 

  014dc	83 ff 73	 cmp	 edi, 115		; 00000073H
  014df	75 0c		 jne	 SHORT $L72696
  014e1	83 f8 74	 cmp	 eax, 116		; 00000074H
  014e4	74 11		 je	 SHORT $L72695
$L72694:
  014e6	5f		 pop	 edi
  014e7	5e		 pop	 esi
  014e8	5d		 pop	 ebp

; 2140 : 		}
; 2141 : 	}   
; 2142 : 	return(KEEP_SEARCHING);

  014e9	33 c0		 xor	 eax, eax
  014eb	5b		 pop	 ebx

; 2143 : #endif /* end of #ifdef ENGLISH */
; 2144 : }

  014ec	c3		 ret	 0
$L72696:

; 2102 : 		if ((c1=='s' && c2=='t') || (c1=='d' && c2=='r')) 

  014ed	83 ff 64	 cmp	 edi, 100		; 00000064H
  014f0	75 f4		 jne	 SHORT $L72694
  014f2	83 f8 72	 cmp	 eax, 114		; 00000072H
  014f5	75 ef		 jne	 SHORT $L72694
$L72695:

; 2103 : 		{
; 2104 : 			if (llp+2 == rlp)       /* Gobble up the "."    */

  014f7	3b e9		 cmp	 ebp, ecx
  014f9	75 0d		 jne	 SHORT $L72697

; 2105 : 				ls_util_read_item(phTTS);     /* after abbreviation.  */

  014fb	8b 44 24 14	 mov	 eax, DWORD PTR _phTTS$[esp+12]
  014ff	50		 push	 eax
  01500	e8 00 00 00 00	 call	 _ls_util_read_item
  01505	83 c4 04	 add	 esp, 4
$L72697:

; 2106 : 			ls_task_lookahead(pLts_t);

  01508	53		 push	 ebx
  01509	e8 00 00 00 00	 call	 _ls_task_lookahead

; 2107 : 			if (ls_util_is_white(&(pLts_t->citem)) != FALSE) 

  0150e	8d 8b 00 09 00
	00		 lea	 ecx, DWORD PTR [ebx+2304]
  01514	51		 push	 ecx
  01515	e8 00 00 00 00	 call	 _ls_util_is_white
  0151a	83 c4 08	 add	 esp, 8
  0151d	85 c0		 test	 eax, eax
  0151f	0f 84 bf 00 00
	00		 je	 $L72698

; 2108 : 			{
; 2109 : 				ls_task_readword(phTTS,&(pLts_t->nword[0]));

  01525	8b 74 24 14	 mov	 esi, DWORD PTR _phTTS$[esp+12]
  01529	8d ab 14 0d 00
	00		 lea	 ebp, DWORD PTR [ebx+3348]
  0152f	55		 push	 ebp
  01530	56		 push	 esi
  01531	e8 00 00 00 00	 call	 _ls_task_readword

; 2110 : 				if ((lsctype[pLts_t->nword[0].l_ch]&UU) != 0)

  01536	66 8b 45 00	 mov	 ax, WORD PTR [ebp]
  0153a	83 c4 08	 add	 esp, 8
  0153d	0f bf d0	 movsx	 edx, ax
  01540	f6 04 55 00 00
	00 00 20	 test	 BYTE PTR _lsctype[edx*2], 32 ; 00000020H
  01548	74 40		 je	 SHORT $L72699

; 2111 : 				{
; 2112 : 					/* GL 02/25/1997  fix St. Dr. back to back problem */ 
; 2113 : 					if ((pLts_t->nword[0].l_ch=='D' &&
; 2114 : 					     pLts_t->nword[1].l_ch=='r' &&
; 2115 : 					     pLts_t->nword[2].l_ch==0) ||
; 2116 : 					     (pLts_t->nword[0].l_ch=='S' &&
; 2117 : 					      pLts_t->nword[1].l_ch=='t' &&
; 2118 : 					      pLts_t->nword[2].l_ch==0))

  0154a	66 3d 44 00	 cmp	 ax, 68			; 00000044H
  0154e	75 14		 jne	 SHORT $L72702
  01550	66 83 bb 1c 0d
	00 00 72	 cmp	 WORD PTR [ebx+3356], 114 ; 00000072H
  01558	75 0a		 jne	 SHORT $L72702
  0155a	66 83 bb 24 0d
	00 00 00	 cmp	 WORD PTR [ebx+3364], 0
  01562	74 1a		 je	 SHORT $L72701
$L72702:
  01564	66 3d 53 00	 cmp	 ax, 83			; 00000053H
  01568	75 29		 jne	 SHORT $L72700
  0156a	66 83 bb 1c 0d
	00 00 74	 cmp	 WORD PTR [ebx+3356], 116 ; 00000074H
  01572	75 1f		 jne	 SHORT $L72700
  01574	66 83 bb 24 0d
	00 00 00	 cmp	 WORD PTR [ebx+3364], 0
  0157c	75 15		 jne	 SHORT $L72700
$L72701:

; 2119 : 					ls_util_send_phone_list(phTTS,c1=='s' ? pstreet : pdrive);

  0157e	83 ff 73	 cmp	 edi, 115		; 00000073H
  01581	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pstreet
  01586	74 2b		 je	 SHORT $L73056

; 2120 : 					else

  01588	eb 24		 jmp	 SHORT $L73061
$L72699:

; 2121 : 					ls_util_send_phone_list(phTTS,c1=='s' ? psaint : pdoctor);
; 2122 : 				}
; 2123 : 				else
; 2124 : 				{
; 2125 : 					/* GL 03/03/1997  it is doctor or saint if is the first word of sentenct */
; 2126 : 					if (pLts_t->fc_index == 1)

  0158a	83 bb bc 08 00
	00 01		 cmp	 DWORD PTR [ebx+2236], 1
  01591	75 11		 jne	 SHORT $L72705
$L72700:

; 2127 : 						ls_util_send_phone_list(phTTS,c1=='s' ? psaint : pdoctor);

  01593	83 ff 73	 cmp	 edi, 115		; 00000073H
  01596	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_psaint
  0159b	74 16		 je	 SHORT $L73056
  0159d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pdoctor

; 2128 : 					else

  015a2	eb 0f		 jmp	 SHORT $L73056
$L72705:

; 2129 : 						ls_util_send_phone_list(phTTS,c1=='s' ? pstreet : pdrive);

  015a4	83 ff 73	 cmp	 edi, 115		; 00000073H
  015a7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pstreet
  015ac	74 05		 je	 SHORT $L73056
$L73061:
  015ae	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pdrive
$L73056:
  015b3	50		 push	 eax
  015b4	56		 push	 esi
  015b5	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2130 : 				}
; 2131 : 
; 2132 : 				ls_util_send_phone(phTTS,pLts_t->rbphone);

  015ba	8b 83 20 11 00
	00		 mov	 eax, DWORD PTR [ebx+4384]
  015c0	83 c4 08	 add	 esp, 8
  015c3	50		 push	 eax
  015c4	56		 push	 esi
  015c5	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2133 : 				ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));

  015ca	81 c3 14 09 00
	00		 add	 ebx, 2324		; 00000914H
  015d0	55		 push	 ebp
  015d1	53		 push	 ebx
  015d2	e8 00 00 00 00	 call	 _ls_util_copyword
  015d7	83 c4 10	 add	 esp, 16			; 00000010H

; 2134 : 
; 2135 : 				return(LS_TASK_LOOP);

  015da	b8 01 00 00 00	 mov	 eax, 1
  015df	5f		 pop	 edi
  015e0	5e		 pop	 esi
  015e1	5d		 pop	 ebp
  015e2	5b		 pop	 ebx

; 2143 : #endif /* end of #ifdef ENGLISH */
; 2144 : }

  015e3	c3		 ret	 0
$L72698:

; 2136 : 			}
; 2137 : 			ls_util_send_phone_list(phTTS,c1=='s' ? pstreet : pdrive);

  015e4	83 ff 73	 cmp	 edi, 115		; 00000073H
  015e7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pstreet
  015ec	74 05		 je	 SHORT $L73064
  015ee	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pdrive
$L73064:
  015f3	8b 4c 24 14	 mov	 ecx, DWORD PTR _phTTS$[esp+12]
  015f7	50		 push	 eax
  015f8	51		 push	 ecx
  015f9	e8 00 00 00 00	 call	 _ls_util_send_phone_list
  015fe	83 c4 08	 add	 esp, 8

; 2138 : 
; 2139 : 			return(FINISHED_WORD);

  01601	b8 03 00 00 00	 mov	 eax, 3
  01606	5f		 pop	 edi
  01607	5e		 pop	 esi
  01608	5d		 pop	 ebp
  01609	5b		 pop	 ebx

; 2143 : #endif /* end of #ifdef ENGLISH */
; 2144 : }

  0160a	c3		 ret	 0
_ls_task_Dr_St_process ENDP
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_lp1$ = 20
_ls_task_set_sign_flag PROC NEAR

; 2174 : 	PKSD_T  pKsd_t;
; 2175 : 	PLTS_T  pLts_t;
; 2176 : 		
; 2177 : 	pKsd_t = phTTS->pKernelShareData;

  01610	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]

; 2178 : 	pLts_t = phTTS->pLTSThreadData;	
; 2179 : 
; 2180 : #ifdef LS1DEBUG       
; 2181 : 	printf("entering ls_task_set_sign_flag\n");
; 2182 : 	printf("beginnning number processing   ");
; 2183 : 	printf("left=%u  right=%u\n",llp,rlp);
; 2184 : #endif
; 2185 : 							  
; 2186 : 	/*
; 2187 : 	 * This is the top of number processing. The first
; 2188 : 	 * step is to decide how "." and "," will be interpreted.
; 2189 : 	 * This is controlled by a mode flag (MODE_EUROPE) if
; 2190 : 	 * the unit is running at level 2. Then pull off any signs,
; 2191 : 	 * and revert to spelling if this makes the whole word
; 2192 : 	 * go away.
; 2193 : 	 */
; 2194 : 	/* pLts_t->fc_struct[pLts_t->fc_index] = FC_ADJ;xxx marks more than numbers here*/
; 2195 : 
; 2196 : 	/*eab 8/94 numbers form class needs to be marked*/
; 2197 : 	pLts_t->fchar = '.';                            /* Pick the right one.  */
; 2198 : 	pLts_t->schar = ',';

  01614	ba 2c 00 00 00	 mov	 edx, 44			; 0000002cH
  01619	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0161c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0161f	66 c7 80 ec 08
	00 00 2e 00	 mov	 WORD PTR [eax+2284], 46	; 0000002eH
  01628	66 89 90 ee 08
	00 00		 mov	 WORD PTR [eax+2286], dx

; 2199 :     if ((pKsd_t->modeflag&MODE_EUROPE)!=0) {

  0162f	f6 81 00 02 00
	00 08		 test	 BYTE PTR [ecx+512], 8
  01636	74 10		 je	 SHORT $L72718

; 2200 : 		pLts_t->fchar = ',';

  01638	66 89 90 ec 08
	00 00		 mov	 WORD PTR [eax+2284], dx

; 2201 : 		pLts_t->schar = '.';

  0163f	66 c7 80 ee 08
	00 00 2e 00	 mov	 WORD PTR [eax+2286], 46	; 0000002eH
$L72718:

; 2202 : 	}
; 2203 : 	/* GL 11/07/1996, change to fix Spanish Decimal number */
; 2204 : 	/* SPANISH use the "." and "," just as MODE_EUROPE for both Latin and Spanish */
; 2205 : #if defined (SPANISH) || defined (GERMAN)
; 2206 : 		pLts_t->fchar = ',';
; 2207 : 		pLts_t->schar = '.';
; 2208 : #endif
; 2209 : 	
; 2210 : 	pLts_t->sign = 0;
; 2211 : 	(*lp1)  = llp;

  01648	8b 4c 24 10	 mov	 ecx, DWORD PTR _lp1$[esp-4]
  0164c	8b 54 24 08	 mov	 edx, DWORD PTR _llp$[esp-4]
  01650	c7 80 18 11 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+4376], 0
  0165a	89 11		 mov	 DWORD PTR [ecx], edx

; 2212 : 	if ((*lp1)->l_ch == '-'                     /* Signs.               */
; 2213 : 	||  (*lp1)->l_ch == '+'
; 2214 : 	||  (*lp1)->l_ch == 0xA7                    /* Section mark.        */
; 2215 : 	||  (*lp1)->l_ch == 0xB1                    /* Plus-minus.          */
; 2216 : 	||  (*lp1)->l_ch == 0xB6)          			/* Item.                */

  0165c	66 8b 12	 mov	 dx, WORD PTR [edx]
  0165f	66 83 fa 2d	 cmp	 dx, 45			; 0000002dH
  01663	74 1b		 je	 SHORT $L72720
  01665	66 83 fa 2b	 cmp	 dx, 43			; 0000002bH
  01669	74 15		 je	 SHORT $L72720
  0166b	66 81 fa a7 00	 cmp	 dx, 167			; 000000a7H
  01670	74 0e		 je	 SHORT $L72720
  01672	66 81 fa b1 00	 cmp	 dx, 177			; 000000b1H
  01677	74 07		 je	 SHORT $L72720
  01679	66 81 fa b6 00	 cmp	 dx, 182			; 000000b6H
  0167e	75 20		 jne	 SHORT $L72721
$L72720:

; 2217 : 		{               
; 2218 : 		pLts_t->sign = (*lp1)->l_ch;

  01680	0f bf d2	 movsx	 edx, dx
  01683	89 90 18 11 00
	00		 mov	 DWORD PTR [eax+4376], edx

; 2219 : 		++(*lp1);

  01689	8b 11		 mov	 edx, DWORD PTR [ecx]

; 2220 : #ifdef LS1DEBUG
; 2221 : 		printf("num processing sign found\n");
; 2222 : #endif
; 2223 : 		if ((*lp1) == rlp)

  0168b	8b 44 24 0c	 mov	 eax, DWORD PTR _rlp$[esp-4]
  0168f	83 c2 08	 add	 edx, 8
  01692	89 11		 mov	 DWORD PTR [ecx], edx
  01694	8b ca		 mov	 ecx, edx
  01696	3b c8		 cmp	 ecx, eax
  01698	75 06		 jne	 SHORT $L72721

; 2224 : 		{
; 2225 : #ifdef LS1DEBUG
; 2226 : 			printf(" spell from num processing\n");
; 2227 : #endif
; 2228 : 			return(SPELL_WORD);

  0169a	b8 02 00 00 00	 mov	 eax, 2

; 2232 : }

  0169f	c3		 ret	 0
$L72721:

; 2229 : 		}
; 2230 : 	}                          
; 2231 : 	return(KEEP_SEARCHING);

  016a0	33 c0		 xor	 eax, eax

; 2232 : }

  016a2	c3		 ret	 0
_ls_task_set_sign_flag ENDP
_TEXT	ENDS
EXTRN	_ppence:BYTE
EXTRN	_pcent:BYTE
EXTRN	_ppound:BYTE
EXTRN	_pdollar:BYTE
EXTRN	_pand:BYTE
EXTRN	_ls_proc_do_sign:NEAR
EXTRN	_ls_proc_do_number:NEAR
EXTRN	_nwdtab:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_num$ = -24
_type$ = 12
_flag$ = 8
_cp$ = -28
_ls_task_currency_processing PROC NEAR

; 2257 : {   

  016b0	83 ec 1c	 sub	 esp, 28			; 0000001cH
  016b3	53		 push	 ebx

; 2258 : 	NUM     num;
; 2259 : 	LETTER *lp2;
; 2260 : 	int     type;
; 2261 : 	int     flag;
; 2262 : 	char    *cp;
; 2263 : 	PLTS_T pLts_t;
; 2264 : 	
; 2265 : 	pLts_t = phTTS->pLTSThreadData;
; 2266 : 	
; 2267 : #ifdef LS1DEBUG
; 2268 : 		printf("entering ls_task_currency_processing\n");
; 2269 : #endif
; 2270 : 	/*
; 2271 : 	 * If the first character in the remaining string
; 2272 : 	 * is a currency symbol (both the USA/Canada and the
; 2273 : 	 * United Kingdom versions are accepted) this is a signal
; 2274 : 	 * to begin running the money rules.
; 2275 : 	 */
; 2276 : 
; 2277 : #ifdef LS1DEBUG
; 2278 : 	printf("currency rules ");
; 2279 : 	printf("left=%u  right=%u\n",llp,rlp);
; 2280 : #endif
; 2281 : 	if (llp->l_ch=='$' || llp->l_ch==0xA3) 

  016b4	8b 5c 24 28	 mov	 ebx, DWORD PTR _llp$[esp+28]
  016b8	55		 push	 ebp
  016b9	56		 push	 esi
  016ba	66 8b 03	 mov	 ax, WORD PTR [ebx]
  016bd	57		 push	 edi
  016be	8b 7c 24 30	 mov	 edi, DWORD PTR _phTTS$[esp+40]
  016c2	66 3d 24 00	 cmp	 ax, 36			; 00000024H
  016c6	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  016c9	74 10		 je	 SHORT $L72736
  016cb	66 3d a3 00	 cmp	 ax, 163			; 000000a3H
  016cf	74 0a		 je	 SHORT $L72736
  016d1	5f		 pop	 edi
  016d2	5e		 pop	 esi
  016d3	5d		 pop	 ebp

; 2517 : 		}
; 2518 : 		return(FINISHED_WORD);
; 2519 : 	}
; 2520 : 	return(KEEP_SEARCHING);

  016d4	33 c0		 xor	 eax, eax
  016d6	5b		 pop	 ebx

; 2521 : }

  016d7	83 c4 1c	 add	 esp, 28			; 0000001cH
  016da	c3		 ret	 0
$L72736:

; 2282 : 	{
; 2283 : 		type = llp->l_ch;
; 2284 : 		if (++llp == rlp)               /* Lone currency mark.  */

  016db	8b 6c 24 38	 mov	 ebp, DWORD PTR _rlp$[esp+40]
  016df	83 c3 08	 add	 ebx, 8
  016e2	0f bf c0	 movsx	 eax, ax
  016e5	3b dd		 cmp	 ebx, ebp
  016e7	89 44 24 34	 mov	 DWORD PTR _type$[esp+40], eax

; 2285 : 		{
; 2286 : #ifdef LS1DEBUG
; 2287 : 			printf("currency mark spell \n");
; 2288 : #endif
; 2289 : 
; 2290 : 			return(SPELL_WORD);

  016eb	0f 84 2f 03 00
	00		 je	 $L72744

; 2291 : 		}
; 2292 : 		if (llp->l_ch == '-'            /* Signs.               */
; 2293 : 		||  llp->l_ch == '+'
; 2294 : 		||  llp->l_ch == 0xB1) 

  016f1	66 8b 03	 mov	 ax, WORD PTR [ebx]
  016f4	66 3d 2d 00	 cmp	 ax, 45			; 0000002dH
  016f8	74 0c		 je	 SHORT $L72739
  016fa	66 3d 2b 00	 cmp	 ax, 43			; 0000002bH
  016fe	74 06		 je	 SHORT $L72739
  01700	66 3d b1 00	 cmp	 ax, 177			; 000000b1H
  01704	75 22		 jne	 SHORT $L72741
$L72739:

; 2295 : 		{        						/* Plus-minus.          */
; 2296 : 
; 2297 : 			if (pLts_t->sign != 0)

  01706	8b 8e 18 11 00
	00		 mov	 ecx, DWORD PTR [esi+4376]
  0170c	85 c9		 test	 ecx, ecx

; 2298 : 			{
; 2299 : #ifdef LS1DEBUG
; 2300 : 			printf("sign spell \n");
; 2301 : #endif
; 2302 : 
; 2303 : 				return(SPELL_WORD);

  0170e	0f 85 0c 03 00
	00		 jne	 $L72744

; 2304 : 			}
; 2305 : 
; 2306 : 			pLts_t->sign = llp->l_ch;

  01714	0f bf c8	 movsx	 ecx, ax

; 2307 : 			if (++llp == rlp)       /* "$+"                 */

  01717	83 c3 08	 add	 ebx, 8
  0171a	89 8e 18 11 00
	00		 mov	 DWORD PTR [esi+4376], ecx
  01720	3b dd		 cmp	 ebx, ebp

; 2308 : 			{
; 2309 : #ifdef LS1DEBUG
; 2310 : 			printf(" spell from num sign proc \n");
; 2311 : #endif
; 2312 : 
; 2313 : 				return(SPELL_WORD);

  01722	0f 84 f8 02 00
	00		 je	 $L72744
$L72741:

; 2314 : 			}
; 2315 : 		}
; 2316 : 
; 2317 : 		lp2 = ls_task_parse_number(phTTS,llp, rlp, &num);

  01728	8d 54 24 14	 lea	 edx, DWORD PTR _num$[esp+44]
  0172c	52		 push	 edx
  0172d	55		 push	 ebp
  0172e	53		 push	 ebx
  0172f	57		 push	 edi
  01730	e8 00 00 00 00	 call	 _ls_task_parse_number

; 2318 : 		if (num.n_elp!=NULL || lp2!=rlp)

  01735	8b 4c 24 34	 mov	 ecx, DWORD PTR _num$[esp+76]
  01739	83 c4 10	 add	 esp, 16			; 00000010H
  0173c	85 c9		 test	 ecx, ecx
  0173e	0f 85 dc 02 00
	00		 jne	 $L72744
  01744	3b c5		 cmp	 eax, ebp
  01746	0f 85 d4 02 00
	00		 jne	 $L72744

; 2325 : 		}
; 2326 : 
; 2327 : 		/*
; 2328 : 		 * You need to look ahead to see if the
; 2329 : 		 * next word is one of the special words like
; 2330 : 		 * "million" that alters where the word "dollar" or
; 2331 : 		 * or "pound" is spoken.
; 2332 : 		 */
; 2333 : 
; 2334 : 		flag = FALSE;                   /* No ls_task_lookahead.        */
; 2335 : 		ls_task_lookahead(pLts_t);

  0174c	56		 push	 esi
  0174d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR _flag$[esp+44], 0
  01755	e8 00 00 00 00	 call	 _ls_task_lookahead

; 2336 : 		if (ls_util_is_white(&(pLts_t->citem)) != FALSE) 

  0175a	8d 86 00 09 00
	00		 lea	 eax, DWORD PTR [esi+2304]
  01760	50		 push	 eax
  01761	e8 00 00 00 00	 call	 _ls_util_is_white
  01766	83 c4 08	 add	 esp, 8
  01769	85 c0		 test	 eax, eax
  0176b	0f 84 af 00 00
	00		 je	 $L72746

; 2337 : 		{
; 2338 : 			flag = TRUE;            /* Did ls_task_lookahead.       */
; 2339 : 			ls_task_readword(phTTS,&(pLts_t->nword[0]));

  01771	8d ae 14 0d 00
	00		 lea	 ebp, DWORD PTR [esi+3348]
  01777	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR _flag$[esp+40], 1
  0177f	55		 push	 ebp
  01780	57		 push	 edi
  01781	e8 00 00 00 00	 call	 _ls_task_readword

; 2340 : 			cp = ls_task_wlookup(pLts_t, &(pLts_t->nword[0]), &nwdtab[0]);

  01786	68 00 00 00 00	 push	 OFFSET FLAT:_nwdtab
  0178b	55		 push	 ebp
  0178c	56		 push	 esi
  0178d	e8 00 00 00 00	 call	 _ls_task_wlookup
  01792	83 c4 14	 add	 esp, 20			; 00000014H
  01795	89 44 24 10	 mov	 DWORD PTR _cp$[esp+44], eax

; 2341 : 			if (cp != FALSE) 

  01799	85 c0		 test	 eax, eax
  0179b	74 7f		 je	 SHORT $L73076

; 2342 : 			{
; 2343 : 				ls_proc_do_sign(phTTS,pLts_t->sign);

  0179d	8b 8e 18 11 00
	00		 mov	 ecx, DWORD PTR [esi+4376]
  017a3	51		 push	 ecx
  017a4	57		 push	 edi
  017a5	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 2344 : 				pLts_t->pflag=ls_proc_do_number(phTTS,llp, rlp, FALSE);

  017aa	8b 54 24 40	 mov	 edx, DWORD PTR _rlp$[esp+48]
  017ae	6a 00		 push	 0
  017b0	52		 push	 edx
  017b1	53		 push	 ebx
  017b2	57		 push	 edi
  017b3	e8 00 00 00 00	 call	 _ls_proc_do_number
  017b8	89 86 24 11 00
	00		 mov	 DWORD PTR [esi+4388], eax

; 2345 : 				ls_util_send_phone(phTTS,pLts_t->rbphone);

  017be	8b 86 20 11 00
	00		 mov	 eax, DWORD PTR [esi+4384]
  017c4	50		 push	 eax
  017c5	57		 push	 edi
  017c6	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2346 : 				ls_util_send_phone_list(phTTS,cp);

  017cb	8b 4c 24 30	 mov	 ecx, DWORD PTR _cp$[esp+76]
  017cf	51		 push	 ecx
  017d0	57		 push	 edi
  017d1	e8 00 00 00 00	 call	 _ls_util_send_phone_list
  017d6	83 c4 28	 add	 esp, 40			; 00000028H

; 2347 : 				llp = &(pLts_t->nword[0]);
; 2348 : 				while (llp->l_ch != EOS)

  017d9	66 83 7d 00 00	 cmp	 WORD PTR [ebp], 0
  017de	74 0a		 je	 SHORT $L72749
$L72748:

; 2349 : 					++llp;

  017e0	83 c5 08	 add	 ebp, 8
  017e3	66 83 7d 00 00	 cmp	 WORD PTR [ebp], 0
  017e8	75 f6		 jne	 SHORT $L72748
$L72749:

; 2350 : 
; 2351 : #ifdef SPANISH
; 2352 : 				/* GL 11/16/1998, BATS#721 fix number with currency sign */
; 2353 : 				ls_util_send_phone(phTTS,WBOUND);
; 2354 : 				ls_util_send_phone(phTTS,E_D);
; 2355 : //				ls_util_send_phone(phTTS,S1);
; 2356 : 				ls_util_send_phone(phTTS,E_E);
; 2357 : #endif
; 2358 : 
; 2359 : 				ls_util_send_phone_list(phTTS,type=='$' ? pdollar : ppound);

  017ea	8b 44 24 34	 mov	 eax, DWORD PTR _type$[esp+40]
  017ee	83 f8 24	 cmp	 eax, 36			; 00000024H
  017f1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pdollar
  017f6	74 05		 je	 SHORT $L73068
  017f8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_ppound
$L73068:
  017fd	50		 push	 eax
  017fe	57		 push	 edi
  017ff	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2360 : 
; 2361 : /* 
; 2362 :  * JDB: this looks like it is only for ENGLISH_US, so for now it's
; 2363 :  *  conditional
; 2364 :  */				
; 2365 : #ifdef ENGLISH_US
; 2366 : 				ls_util_send_phone(phTTS,Z);

  01804	6a 2a		 push	 42			; 0000002aH
  01806	57		 push	 edi
  01807	e8 00 00 00 00	 call	 _ls_util_send_phone
  0180c	83 c4 10	 add	 esp, 16			; 00000010H

; 2367 : #endif
; 2368 : #ifdef ENGLISH_UK
; 2369 : 				ls_util_send_phone(phTTS,Z);
; 2370 : #endif
; 2371 : /* GL 02/14/1997, add pural for Spanish */
; 2372 : #ifdef SPANISH
; 2373 : 				/* GL 11/16/1998, BATS#721 fix number with currency sign */
; 2374 : 				ls_util_send_phone(phTTS,E_E);
; 2375 : 				ls_util_send_phone(phTTS,E_S);
; 2376 : #endif
; 2377 : 				return(FINISHED_WORD);

  0180f	b8 03 00 00 00	 mov	 eax, 3
  01814	5f		 pop	 edi
  01815	5e		 pop	 esi
  01816	5d		 pop	 ebp
  01817	5b		 pop	 ebx

; 2521 : }

  01818	83 c4 1c	 add	 esp, 28			; 0000001cH
  0181b	c3		 ret	 0
$L73076:

; 2350 : 
; 2351 : #ifdef SPANISH
; 2352 : 				/* GL 11/16/1998, BATS#721 fix number with currency sign */
; 2353 : 				ls_util_send_phone(phTTS,WBOUND);
; 2354 : 				ls_util_send_phone(phTTS,E_D);
; 2355 : //				ls_util_send_phone(phTTS,S1);
; 2356 : 				ls_util_send_phone(phTTS,E_E);
; 2357 : #endif
; 2358 : 
; 2359 : 				ls_util_send_phone_list(phTTS,type=='$' ? pdollar : ppound);

  0181c	8b 6c 24 38	 mov	 ebp, DWORD PTR _rlp$[esp+40]
$L72746:

; 2378 : 			}
; 2379 : 		}
; 2380 : 
; 2381 : 		/*
; 2382 : 		 * $3      Three dollars.
; 2383 : 		 * $3.00   Three dollars.
; 2384 : 		 * $3.24   Three dollars and twenty four cents.
; 2385 : 		 * $3.240  Three point two four zero dollars.
; 2386 : 		 */
; 2387 : 
; 2388 : 		ls_proc_do_sign(phTTS,pLts_t->sign);

  01820	8b 96 18 11 00
	00		 mov	 edx, DWORD PTR [esi+4376]
  01826	52		 push	 edx
  01827	57		 push	 edi
  01828	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 2389 : 
; 2390 : 		if (num.n_flp==NULL || (num.n_frp-num.n_flp)==3)        

  0182d	8b 4c 24 24	 mov	 ecx, DWORD PTR _num$[esp+60]
  01831	83 c4 08	 add	 esp, 8
  01834	85 c9		 test	 ecx, ecx
  01836	0f 84 92 00 00
	00		 je	 $L72752
  0183c	8b 44 24 20	 mov	 eax, DWORD PTR _num$[esp+56]
  01840	2b c1		 sub	 eax, ecx
  01842	24 f8		 and	 al, -8			; fffffff8H
  01844	83 f8 18	 cmp	 eax, 24			; 00000018H
  01847	0f 84 81 00 00
	00		 je	 $L72752

; 2487 : 			}
; 2488 : 			return(FINISHED_WORD);
; 2489 : 		}
; 2490 : #if defined (SPANISH) || defined (GERMAN)
; 2491 : 		/* GL 02/15/1997, set to -1 to force Spanish say "1" as un  */
; 2492 : 		/* GL 02/17/1997, set to -1 to force German say "1" as ein  */
; 2493 : 		pLts_t->pflag = -1;
; 2494 : #endif
; 2495 : 		pLts_t->pflag = ls_proc_do_number(phTTS,llp, rlp, FALSE);

  0184d	6a 00		 push	 0
  0184f	55		 push	 ebp
  01850	53		 push	 ebx
  01851	57		 push	 edi
  01852	e8 00 00 00 00	 call	 _ls_proc_do_number
  01857	89 86 24 11 00
	00		 mov	 DWORD PTR [esi+4388], eax

; 2496 : 		ls_util_send_phone_list(phTTS,type=='$' ? pdollar : ppound);

  0185d	8b 44 24 44	 mov	 eax, DWORD PTR _type$[esp+56]
  01861	83 c4 10	 add	 esp, 16			; 00000010H
  01864	83 f8 24	 cmp	 eax, 36			; 00000024H
  01867	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pdollar
  0186c	74 05		 je	 SHORT $L73072
  0186e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_ppound
$L73072:
  01873	50		 push	 eax
  01874	57		 push	 edi
  01875	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2497 : 
; 2498 : /* JDB: again, ENGLISH plurals made conditional... */						
; 2499 : #ifdef ENGLISH_US
; 2500 : 		if (pLts_t->pflag != FALSE)

  0187a	8b 86 24 11 00
	00		 mov	 eax, DWORD PTR [esi+4388]
  01880	83 c4 08	 add	 esp, 8
  01883	85 c0		 test	 eax, eax
  01885	74 0b		 je	 SHORT $L72766

; 2501 : 			ls_util_send_phone(phTTS,Z);

  01887	6a 2a		 push	 42			; 0000002aH
  01889	57		 push	 edi
  0188a	e8 00 00 00 00	 call	 _ls_util_send_phone
  0188f	83 c4 08	 add	 esp, 8
$L72766:

; 2502 : #endif
; 2503 : #ifdef ENGLISH_UK
; 2504 : 		if (pLts_t->pflag != FALSE)
; 2505 : 			ls_util_send_phone(phTTS,Z);
; 2506 : #endif
; 2507 : /* GL 02/14/1997, add pural for Spanish */
; 2508 : #ifdef SPANISH
; 2509 : 		if (pLts_t->pflag != FALSE)
; 2510 : 			ls_util_send_phone(phTTS,E_S);
; 2511 : #endif
; 2512 : 		if (flag != FALSE) 

  01892	8b 44 24 30	 mov	 eax, DWORD PTR _flag$[esp+40]
  01896	85 c0		 test	 eax, eax
  01898	0f 84 c3 00 00
	00		 je	 $L72765
$L72760:

; 2513 : 		{
; 2514 : 			ls_util_send_phone(phTTS,pLts_t->rbphone);

  0189e	8b 8e 20 11 00
	00		 mov	 ecx, DWORD PTR [esi+4384]
  018a4	51		 push	 ecx
  018a5	57		 push	 edi
  018a6	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2515 : 			ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));

  018ab	8d 96 14 0d 00
	00		 lea	 edx, DWORD PTR [esi+3348]
  018b1	81 c6 14 09 00
	00		 add	 esi, 2324		; 00000914H
  018b7	52		 push	 edx
  018b8	56		 push	 esi
  018b9	e8 00 00 00 00	 call	 _ls_util_copyword
  018be	83 c4 10	 add	 esp, 16			; 00000010H

; 2516 : 			return(LS_TASK_LOOP);

  018c1	b8 01 00 00 00	 mov	 eax, 1
  018c6	5f		 pop	 edi
  018c7	5e		 pop	 esi
  018c8	5d		 pop	 ebp
  018c9	5b		 pop	 ebx

; 2521 : }

  018ca	83 c4 1c	 add	 esp, 28			; 0000001cH
  018cd	c3		 ret	 0
$L72752:

; 2391 : 		{
; 2392 : 			if (num.n_ilp != NULL) 

  018ce	8b 44 24 14	 mov	 eax, DWORD PTR _num$[esp+44]
  018d2	bb 30 00 00 00	 mov	 ebx, 48			; 00000030H
  018d7	85 c0		 test	 eax, eax
  018d9	0f 84 a1 00 00
	00		 je	 $L72754

; 2393 : 			{
; 2394 : 
; 2395 : #if defined (SPANISH) || defined (GERMAN)
; 2396 : 				/* GL 02/15/1997, set to -1 to force Spanish say "1" as un  */
; 2397 : 				/* GL 02/17/1997, set to -1 to force German say "1" as ein  */
; 2398 : 				pLts_t->pflag = -1;
; 2399 : #endif
; 2400 : 				pLts_t->pflag = ls_proc_do_number(phTTS,num.n_ilp, num.n_irp, FALSE);

  018df	8b 4c 24 18	 mov	 ecx, DWORD PTR _num$[esp+48]
  018e3	6a 00		 push	 0
  018e5	51		 push	 ecx
  018e6	50		 push	 eax
  018e7	57		 push	 edi
  018e8	e8 00 00 00 00	 call	 _ls_proc_do_number
  018ed	89 86 24 11 00
	00		 mov	 DWORD PTR [esi+4388], eax

; 2401 : 
; 2402 : 				ls_util_send_phone_list(phTTS,type=='$' ? pdollar : ppound);

  018f3	8b 44 24 44	 mov	 eax, DWORD PTR _type$[esp+56]
  018f7	83 c4 10	 add	 esp, 16			; 00000010H
  018fa	83 f8 24	 cmp	 eax, 36			; 00000024H
  018fd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pdollar
  01902	74 05		 je	 SHORT $L73070
  01904	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_ppound
$L73070:
  01909	50		 push	 eax
  0190a	57		 push	 edi
  0190b	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2403 : 
; 2404 : /* 
; 2405 :  * JDB: this is more plural stuff that doesn't seem to happen
; 2406 :  * in the spanish- make it conditional
; 2407 :  */
; 2408 : #ifdef ENGLISH_US
; 2409 : 				if (pLts_t->pflag != FALSE)

  01910	8b 86 24 11 00
	00		 mov	 eax, DWORD PTR [esi+4388]
  01916	83 c4 08	 add	 esp, 8
  01919	85 c0		 test	 eax, eax
  0191b	74 0b		 je	 SHORT $L72755

; 2410 : 					ls_util_send_phone(phTTS,Z);

  0191d	6a 2a		 push	 42			; 0000002aH
  0191f	57		 push	 edi
  01920	e8 00 00 00 00	 call	 _ls_util_send_phone
  01925	83 c4 08	 add	 esp, 8
$L72755:

; 2411 : #endif			
; 2412 : #ifdef ENGLISH_UK
; 2413 : 				if (pLts_t->pflag != FALSE)
; 2414 : 					ls_util_send_phone(phTTS,Z);
; 2415 : #endif							
; 2416 : /* GL 02/14/1997, add pural for Spanish */
; 2417 : #ifdef SPANISH
; 2418 : 				if (pLts_t->pflag != FALSE)
; 2419 : 				{
; 2420 : 					/* GL 11/16/1998, BATS#721 fix number with currency sign */
; 2421 : 					ls_util_send_phone(phTTS,E_E);
; 2422 : 				    ls_util_send_phone(phTTS,E_S);
; 2423 : 				}
; 2424 : #endif
; 2425 : 				if (num.n_flp == NULL) 

  01928	8b 44 24 1c	 mov	 eax, DWORD PTR _num$[esp+52]
  0192c	85 c0		 test	 eax, eax
  0192e	75 19		 jne	 SHORT $L72757

; 2426 : 				{
; 2427 : 					if (flag == FALSE)

  01930	8b 44 24 30	 mov	 eax, DWORD PTR _flag$[esp+40]
  01934	85 c0		 test	 eax, eax
  01936	0f 85 b4 00 00
	00		 jne	 $L72758
  0193c	5f		 pop	 edi
  0193d	5e		 pop	 esi
  0193e	5d		 pop	 ebp

; 2428 : 						return(FINISHED_WORD);

  0193f	b8 03 00 00 00	 mov	 eax, 3
  01944	5b		 pop	 ebx

; 2521 : }

  01945	83 c4 1c	 add	 esp, 28			; 0000001cH
  01948	c3		 ret	 0
$L72757:

; 2429 : 					ls_util_send_phone(phTTS,pLts_t->rbphone);
; 2430 : 
; 2431 : 					ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));
; 2432 : 
; 2433 : 					return(LS_TASK_LOOP);
; 2434 : 				}
; 2435 : 				if ((num.n_flp+1)->l_ch == '0'
; 2436 : 				&&  (num.n_flp+2)->l_ch == '0') 

  01949	66 39 58 08	 cmp	 WORD PTR [eax+8], bx
  0194d	75 1f		 jne	 SHORT $L72759
  0194f	66 39 58 10	 cmp	 WORD PTR [eax+16], bx
  01953	75 19		 jne	 SHORT $L72759

; 2437 : 				{
; 2438 : 
; 2439 : 					if (flag == FALSE)

  01955	8b 44 24 30	 mov	 eax, DWORD PTR _flag$[esp+40]
  01959	85 c0		 test	 eax, eax
  0195b	0f 85 3d ff ff
	ff		 jne	 $L72760
$L72765:
  01961	5f		 pop	 edi
  01962	5e		 pop	 esi
  01963	5d		 pop	 ebp

; 2440 : 						return(FINISHED_WORD);

  01964	b8 03 00 00 00	 mov	 eax, 3
  01969	5b		 pop	 ebx

; 2521 : }

  0196a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0196d	c3		 ret	 0
$L72759:

; 2441 : 					ls_util_send_phone(phTTS,pLts_t->rbphone);
; 2442 : 
; 2443 : 					ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));
; 2444 : 					return(LS_TASK_LOOP);
; 2445 : 				}
; 2446 : #ifndef ENGLISH_UK
; 2447 : 				ls_util_send_phone_list(phTTS,pand);

  0196e	68 00 00 00 00	 push	 OFFSET FLAT:_pand
  01973	57		 push	 edi
  01974	e8 00 00 00 00	 call	 _ls_util_send_phone_list
  01979	8b 4c 24 24	 mov	 ecx, DWORD PTR _num$[esp+60]
  0197d	83 c4 08	 add	 esp, 8
$L72754:

; 2448 : #endif
; 2449 : 			}
; 2450 : 			lp2 = num.n_flp + 1;    /* Just after the "."   */
; 2451 : 			if (lp2->l_ch == '0')

  01980	66 39 59 08	 cmp	 WORD PTR [ecx+8], bx
  01984	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  01987	75 03		 jne	 SHORT $L72761

; 2452 : 				++lp2;

  01989	83 c0 08	 add	 eax, 8
$L72761:

; 2453 : 
; 2454 : #if defined (SPANISH) || defined (GERMAN)
; 2455 : 				/* GL 02/15/1997, set to -1 to force Spanish say "1" as un  */
; 2456 : 				/* GL 02/17/1997, set to -1 to force German say "1" as ein  */
; 2457 : 				pLts_t->pflag = -1;
; 2458 : #endif
; 2459 : 			pLts_t->pflag = ls_proc_do_number(phTTS,lp2, num.n_frp, FALSE);

  0198c	8b 4c 24 20	 mov	 ecx, DWORD PTR _num$[esp+56]
  01990	6a 00		 push	 0
  01992	51		 push	 ecx
  01993	50		 push	 eax
  01994	57		 push	 edi
  01995	e8 00 00 00 00	 call	 _ls_proc_do_number

; 2460 : 			ls_util_send_phone(phTTS,WBOUND);

  0199a	6a 6f		 push	 111			; 0000006fH
  0199c	57		 push	 edi
  0199d	89 86 24 11 00
	00		 mov	 DWORD PTR [esi+4388], eax
  019a3	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2461 : 			if (type == '$') 

  019a8	8b 44 24 4c	 mov	 eax, DWORD PTR _type$[esp+64]
  019ac	83 c4 18	 add	 esp, 24			; 00000018H
  019af	83 f8 24	 cmp	 eax, 36			; 00000024H
  019b2	75 22		 jne	 SHORT $L72762

; 2462 : 			{
; 2463 : 				ls_util_send_phone_list(phTTS,pcent);

  019b4	68 00 00 00 00	 push	 OFFSET FLAT:_pcent
  019b9	57		 push	 edi
  019ba	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2464 : 				
; 2465 : /* JDB: again, ENGLISH plurals made conditional... */				
; 2466 : #ifdef ENGLISH_US
; 2467 : 				if (pLts_t->pflag != FALSE)

  019bf	8b 86 24 11 00
	00		 mov	 eax, DWORD PTR [esi+4388]
  019c5	83 c4 08	 add	 esp, 8
  019c8	85 c0		 test	 eax, eax
  019ca	74 18		 je	 SHORT $L72764

; 2468 : 					ls_util_send_phone(phTTS,S);

  019cc	6a 29		 push	 41			; 00000029H
  019ce	57		 push	 edi
  019cf	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2469 : #endif					
; 2470 : #ifdef ENGLISH_UK
; 2471 : 				if (pLts_t->pflag != FALSE)
; 2472 : 					ls_util_send_phone(phTTS,S);
; 2473 : #endif					
; 2474 : /* GL 02/14/1997, add pural for Spanish */
; 2475 : #ifdef SPANISH
; 2476 : 				if (pLts_t->pflag != FALSE)
; 2477 : 					ls_util_send_phone(phTTS,E_S);
; 2478 : #endif
; 2479 : 			} 
; 2480 : 			else

  019d4	eb 0b		 jmp	 SHORT $L73078
$L72762:

; 2481 : 				ls_util_send_phone_list(phTTS,ppence);

  019d6	68 00 00 00 00	 push	 OFFSET FLAT:_ppence
  019db	57		 push	 edi
  019dc	e8 00 00 00 00	 call	 _ls_util_send_phone_list
$L73078:
  019e1	83 c4 08	 add	 esp, 8
$L72764:

; 2482 : 			if (flag != FALSE) 

  019e4	8b 44 24 30	 mov	 eax, DWORD PTR _flag$[esp+40]
  019e8	85 c0		 test	 eax, eax
  019ea	0f 84 71 ff ff
	ff		 je	 $L72765
$L72758:

; 2483 : 			{
; 2484 : 				ls_util_send_phone(phTTS,pLts_t->rbphone);

  019f0	8b 96 20 11 00
	00		 mov	 edx, DWORD PTR [esi+4384]
  019f6	52		 push	 edx
  019f7	57		 push	 edi
  019f8	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2485 : 				ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));

  019fd	8d 86 14 0d 00
	00		 lea	 eax, DWORD PTR [esi+3348]
  01a03	81 c6 14 09 00
	00		 add	 esi, 2324		; 00000914H
  01a09	50		 push	 eax
  01a0a	56		 push	 esi
  01a0b	e8 00 00 00 00	 call	 _ls_util_copyword
  01a10	83 c4 10	 add	 esp, 16			; 00000010H

; 2486 : 				return(LS_TASK_LOOP);

  01a13	b8 01 00 00 00	 mov	 eax, 1
  01a18	5f		 pop	 edi
  01a19	5e		 pop	 esi
  01a1a	5d		 pop	 ebp
  01a1b	5b		 pop	 ebx

; 2521 : }

  01a1c	83 c4 1c	 add	 esp, 28			; 0000001cH
  01a1f	c3		 ret	 0
$L72744:
  01a20	5f		 pop	 edi
  01a21	5e		 pop	 esi
  01a22	5d		 pop	 ebp

; 2319 : 		{
; 2320 : #ifdef LS1DEBUG
; 2321 : 			printf("ls_task_parse_number spell \n");
; 2322 : #endif
; 2323 : 
; 2324 : 			return(SPELL_WORD);

  01a23	b8 02 00 00 00	 mov	 eax, 2
  01a28	5b		 pop	 ebx

; 2521 : }

  01a29	83 c4 1c	 add	 esp, 28			; 0000001cH
  01a2c	c3		 ret	 0
_ls_task_currency_processing ENDP
_TEXT	ENDS
EXTRN	_ls_proc_do_date:NEAR
EXTRN	_ls_proc_is_date:NEAR
EXTRN	_ls_proc_do_time:NEAR
EXTRN	_ls_proc_is_am_pm:NEAR
EXTRN	_ls_proc_is_time:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_date_processing PROC NEAR

; 2546 : {  

  01a30	53		 push	 ebx

; 2547 : 	LETTER *lp1;
; 2548 : 	PLTS_T pLts_t;
; 2549 : 	
; 2550 : 	pLts_t = phTTS->pLTSThreadData;

  01a31	8b 5c 24 08	 mov	 ebx, DWORD PTR _phTTS$[esp]
  01a35	55		 push	 ebp
  01a36	56		 push	 esi
  01a37	57		 push	 edi
  01a38	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]

; 2551 : 	/*
; 2552 : 	 * Dates and times are handled by special
; 2553 : 	 * validation and speaking routines. Times are a little
; 2554 : 	 * bit special, because of "AM" and "PM" processing.
; 2555 : 	 * Fractions are special too, but less special then a
; 2556 : 	 * date or a time, because signs are legal.
; 2557 : 	 */
; 2558 : 
; 2559 : #ifdef LS1DEBUG
; 2560 : 	printf("date time processing ");
; 2561 : 	printf("left=%u  right=%u\n",llp,rlp);
; 2562 : #endif
; 2563 : 
; 2564 : 	if (pLts_t->sign == 0) 

  01a3b	8b 87 18 11 00
	00		 mov	 eax, DWORD PTR [edi+4376]
  01a41	85 c0		 test	 eax, eax
  01a43	0f 85 e7 00 00
	00		 jne	 $L72779

; 2565 : 	{
; 2566 : 		if (ls_proc_is_date(llp, rlp) != FALSE) 

  01a49	8b 74 24 1c	 mov	 esi, DWORD PTR _rlp$[esp+12]
  01a4d	8b 6c 24 18	 mov	 ebp, DWORD PTR _llp$[esp+12]
  01a51	56		 push	 esi
  01a52	55		 push	 ebp
  01a53	e8 00 00 00 00	 call	 _ls_proc_is_date
  01a58	83 c4 08	 add	 esp, 8
  01a5b	85 c0		 test	 eax, eax

; 2567 : 		{
; 2568 : 			ls_proc_do_date(phTTS,llp, rlp);

  01a5d	56		 push	 esi
  01a5e	55		 push	 ebp
  01a5f	74 13		 je	 SHORT $L72778
  01a61	53		 push	 ebx
  01a62	e8 00 00 00 00	 call	 _ls_proc_do_date
  01a67	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2569 : 			return(FINISHED_WORD);

  01a6a	b8 03 00 00 00	 mov	 eax, 3
  01a6f	5f		 pop	 edi
  01a70	5e		 pop	 esi
  01a71	5d		 pop	 ebp
  01a72	5b		 pop	 ebx

; 2605 : }

  01a73	c3		 ret	 0
$L72778:

; 2570 : 		} 
; 2571 : 		
; 2572 : 		if (ls_proc_is_time(pLts_t,llp, rlp) != FALSE) 

  01a74	57		 push	 edi
  01a75	e8 00 00 00 00	 call	 _ls_proc_is_time
  01a7a	83 c4 0c	 add	 esp, 12			; 0000000cH
  01a7d	85 c0		 test	 eax, eax
  01a7f	0f 84 ab 00 00
	00		 je	 $L72779

; 2573 : 		{
; 2574 : 			ls_proc_do_time(phTTS,llp, rlp);

  01a85	56		 push	 esi
  01a86	55		 push	 ebp
  01a87	53		 push	 ebx
  01a88	e8 00 00 00 00	 call	 _ls_proc_do_time

; 2575 : 			ls_task_lookahead(pLts_t);

  01a8d	57		 push	 edi
  01a8e	e8 00 00 00 00	 call	 _ls_task_lookahead

; 2576 : 			if (ls_util_is_white(&(pLts_t->citem)) == FALSE)

  01a93	8d 87 00 09 00
	00		 lea	 eax, DWORD PTR [edi+2304]
  01a99	50		 push	 eax
  01a9a	e8 00 00 00 00	 call	 _ls_util_is_white
  01a9f	83 c4 14	 add	 esp, 20			; 00000014H
  01aa2	85 c0		 test	 eax, eax
  01aa4	75 0a		 jne	 SHORT $L72780
  01aa6	5f		 pop	 edi
  01aa7	5e		 pop	 esi
  01aa8	5d		 pop	 ebp

; 2577 : 				return(FINISHED_WORD);

  01aa9	b8 03 00 00 00	 mov	 eax, 3
  01aae	5b		 pop	 ebx

; 2605 : }

  01aaf	c3		 ret	 0
$L72780:

; 2578 : 			ls_util_send_phone(phTTS,pLts_t->rbphone);

  01ab0	8b 8f 20 11 00
	00		 mov	 ecx, DWORD PTR [edi+4384]
  01ab6	51		 push	 ecx
  01ab7	53		 push	 ebx
  01ab8	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2579 : 
; 2580 : 			ls_task_readword(phTTS,&(pLts_t->nword[0]));

  01abd	8d af 14 0d 00
	00		 lea	 ebp, DWORD PTR [edi+3348]
  01ac3	55		 push	 ebp
  01ac4	53		 push	 ebx
  01ac5	e8 00 00 00 00	 call	 _ls_task_readword

; 2581 : 
; 2582 : 			lp1 = &(pLts_t->nword[0]);

  01aca	8b f5		 mov	 esi, ebp
  01acc	83 c4 10	 add	 esp, 16			; 00000010H

; 2583 : 			while (lp1->l_ch != EOS)

  01acf	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  01ad3	74 09		 je	 SHORT $L72783
$L72782:

; 2584 : 				++lp1;       

  01ad5	83 c6 08	 add	 esi, 8
  01ad8	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  01adc	75 f7		 jne	 SHORT $L72782
$L72783:

; 2585 : 				
; 2586 : /* GL 02/13/1997, support am, pm for spanish as well since sometime they do use */
; 2587 : //#if defined (ENGLISH) || defined (GERMAN)	
; 2588 : 			if (ls_proc_is_am_pm(&(pLts_t->nword[0]), lp1) != FALSE)

  01ade	56		 push	 esi
  01adf	55		 push	 ebp
  01ae0	e8 00 00 00 00	 call	 _ls_proc_is_am_pm
  01ae5	83 c4 08	 add	 esp, 8
  01ae8	85 c0		 test	 eax, eax
  01aea	74 2a		 je	 SHORT $L72784

; 2589 : 			{
; 2590 : #ifdef LS1DEBUG
; 2591 : 			printf("ls_proc_is_am_pm spell\n");
; 2592 : #endif
; 2593 : 				ls_spel_spell(phTTS,&(pLts_t->nword[0]), lp1);

  01aec	56		 push	 esi
  01aed	55		 push	 ebp
  01aee	53		 push	 ebx
  01aef	e8 00 00 00 00	 call	 _ls_spel_spell

; 2594 : 				ls_task_do_right_punct(phTTS,MISS);

  01af4	6a 00		 push	 0
  01af6	53		 push	 ebx
  01af7	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 2595 : 				ls_task_readword(phTTS,&(pLts_t->cword[0]));

  01afc	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  01b02	57		 push	 edi
  01b03	53		 push	 ebx
  01b04	e8 00 00 00 00	 call	 _ls_task_readword
  01b09	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2596 : 
; 2597 : 				return(LS_TASK_LOOP);

  01b0c	b8 01 00 00 00	 mov	 eax, 1
  01b11	5f		 pop	 edi
  01b12	5e		 pop	 esi
  01b13	5d		 pop	 ebp
  01b14	5b		 pop	 ebx

; 2605 : }

  01b15	c3		 ret	 0
$L72784:

; 2598 : 			} 
; 2599 : //#endif			
; 2600 : 			ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));

  01b16	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  01b1c	55		 push	 ebp
  01b1d	57		 push	 edi
  01b1e	e8 00 00 00 00	 call	 _ls_util_copyword
  01b23	83 c4 08	 add	 esp, 8

; 2601 : 			return(LS_TASK_LOOP);

  01b26	b8 01 00 00 00	 mov	 eax, 1
  01b2b	5f		 pop	 edi
  01b2c	5e		 pop	 esi
  01b2d	5d		 pop	 ebp
  01b2e	5b		 pop	 ebx

; 2605 : }

  01b2f	c3		 ret	 0
$L72779:
  01b30	5f		 pop	 edi
  01b31	5e		 pop	 esi
  01b32	5d		 pop	 ebp

; 2602 : 		}
; 2603 : 	}
; 2604 : 	return(KEEP_SEARCHING);

  01b33	33 c0		 xor	 eax, eax
  01b35	5b		 pop	 ebx

; 2605 : }

  01b36	c3		 ret	 0
_ls_task_date_processing ENDP
_TEXT	ENDS
EXTRN	_ls_proc_is_frac:NEAR
EXTRN	_ls_proc_do_frac:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_frac_processing PROC NEAR

; 2630 : {

  01b40	53		 push	 ebx

; 2631 : 	PLTS_T pLts_t;
; 2632 : 	pLts_t = phTTS->pLTSThreadData;
; 2633 : #ifdef LS1DEBUG
; 2634 : 		printf("entering ls_task_frac_processing\n");
; 2635 : #endif             
; 2636 : 
; 2637 : /* GL 10/03/96  include fraction processing for Spanish */
; 2638 : #if defined (ENGLISH) || defined (SPANISH)	
; 2639 : 	if (ls_proc_is_frac(llp, rlp) != FALSE) 

  01b41	8b 5c 24 10	 mov	 ebx, DWORD PTR _rlp$[esp]
  01b45	55		 push	 ebp
  01b46	8b 6c 24 10	 mov	 ebp, DWORD PTR _llp$[esp+4]
  01b4a	56		 push	 esi
  01b4b	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  01b4f	57		 push	 edi
  01b50	53		 push	 ebx
  01b51	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  01b54	55		 push	 ebp
  01b55	e8 00 00 00 00	 call	 _ls_proc_is_frac
  01b5a	83 c4 08	 add	 esp, 8
  01b5d	85 c0		 test	 eax, eax
  01b5f	74 22		 je	 SHORT $L72793

; 2640 : 	{
; 2641 : 		ls_proc_do_sign(phTTS,pLts_t->sign);

  01b61	8b 87 18 11 00
	00		 mov	 eax, DWORD PTR [edi+4376]
  01b67	50		 push	 eax
  01b68	56		 push	 esi
  01b69	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 2642 : 
; 2643 : 		ls_proc_do_frac(phTTS,llp, rlp);

  01b6e	53		 push	 ebx
  01b6f	55		 push	 ebp
  01b70	56		 push	 esi
  01b71	e8 00 00 00 00	 call	 _ls_proc_do_frac
  01b76	83 c4 14	 add	 esp, 20			; 00000014H

; 2644 : 		return(FINISHED_WORD);

  01b79	b8 03 00 00 00	 mov	 eax, 3
  01b7e	5f		 pop	 edi
  01b7f	5e		 pop	 esi
  01b80	5d		 pop	 ebp
  01b81	5b		 pop	 ebx

; 2648 : }

  01b82	c3		 ret	 0
$L72793:
  01b83	5f		 pop	 edi
  01b84	5e		 pop	 esi
  01b85	5d		 pop	 ebp

; 2645 : 	}            
; 2646 : #endif	
; 2647 : 	return(KEEP_SEARCHING);

  01b86	33 c0		 xor	 eax, eax
  01b88	5b		 pop	 ebx

; 2648 : }

  01b89	c3		 ret	 0
_ls_task_frac_processing ENDP
_TEXT	ENDS
EXTRN	_pdegree:BYTE
EXTRN	_ppercent:BYTE
EXTRN	_ls_util_pluralize:NEAR
EXTRN	_ls_proc_do_4_digits:NEAR
EXTRN	_ls_util_is_year:NEAR
EXTRN	_ls_util_is_ordinal:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_lp1$ = 20
_num$ = -24
_ls_task_plain_number_processing PROC NEAR

; 2688 : 	LETTER  *lp2;
; 2689 : 	int     c;
; 2690 : 	NUM     num;
; 2691 : 	char    *cp;
; 2692 : 	PLTS_T pLts_t;
; 2693 : 	pLts_t = phTTS->pLTSThreadData;
; 2694 : 
; 2695 : 	 /* Kurz. now wants it to be symetrical with negative numbers
; 2696 : 	 EAB-4-11-89*/
; 2697 : #ifdef LS1DEBUG
; 2698 : 	printf("entering ls_task_plain_number_processing\n");
; 2699 : 	printf("number procesing ");
; 2700 : 	printf("left=%u  right=%u\n",llp,rlp);
; 2701 : #endif
; 2702 : /*ls_util_dump_llp_rlp(llp,rlp,"input number is:");*/	
; 2703 : 	if (lp1->l_ch == '.'                    /* As in ".5".          */
; 2704 : 	||  lp1->l_ch == 0xBC                   /* 1/4                  */
; 2705 : 	||  lp1->l_ch == 0xBD                   /* 1/2                  */
; 2706 : 	||  IS_DIGIT(lp1->l_ch))        		/* ls_proc_digit() */

  01b90	8b 4c 24 10	 mov	 ecx, DWORD PTR _lp1$[esp-4]
  01b94	83 ec 18	 sub	 esp, 24			; 00000018H
  01b97	66 8b 01	 mov	 ax, WORD PTR [ecx]
  01b9a	53		 push	 ebx
  01b9b	55		 push	 ebp
  01b9c	56		 push	 esi
  01b9d	8b 74 24 28	 mov	 esi, DWORD PTR _phTTS$[esp+32]
  01ba1	57		 push	 edi
  01ba2	66 3d 2e 00	 cmp	 ax, 46			; 0000002eH
  01ba6	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  01ba9	74 1c		 je	 SHORT $L72809
  01bab	66 3d bc 00	 cmp	 ax, 188			; 000000bcH
  01baf	74 16		 je	 SHORT $L72809
  01bb1	66 3d bd 00	 cmp	 ax, 189			; 000000bdH
  01bb5	74 10		 je	 SHORT $L72809
  01bb7	0f bf c0	 movsx	 eax, ax
  01bba	f6 80 00 00 00
	00 10		 test	 BYTE PTR _ls_char_feat[eax], 16 ; 00000010H
  01bc1	0f 84 10 03 00
	00		 je	 $L72831
$L72809:

; 2707 : 	{
; 2708 : 		/* GL 9/10/1996, borrow pLts_t->isnumabr to set up the number indication */
; 2709 : 		pLts_t->isnumabr = 3;
; 2710 : 		lp2 = ls_task_parse_number(phTTS,lp1, rlp, &num);

  01bc7	8b 6c 24 34	 mov	 ebp, DWORD PTR _rlp$[esp+36]
  01bcb	8d 54 24 10	 lea	 edx, DWORD PTR _num$[esp+40]
  01bcf	52		 push	 edx
  01bd0	55		 push	 ebp
  01bd1	51		 push	 ecx
  01bd2	56		 push	 esi
  01bd3	c7 87 fc 08 00
	00 03 00 00 00	 mov	 DWORD PTR [edi+2300], 3
  01bdd	e8 00 00 00 00	 call	 _ls_task_parse_number
  01be2	8b d8		 mov	 ebx, eax
  01be4	83 c4 10	 add	 esp, 16			; 00000010H

; 2711 : 		if (lp2 == rlp)

  01be7	3b dd		 cmp	 ebx, ebp
  01be9	0f 85 5b 01 00
	00		 jne	 $L72810

; 2712 : 		{           
; 2713 : 			/* All digits.          */
; 2714 : 			pLts_t->fc_struct[pLts_t->fc_index] = FC_ADJ;

  01bef	8b 87 bc 08 00
	00		 mov	 eax, DWORD PTR [edi+2236]
  01bf5	c7 84 87 bc 04
	00 00 01 00 00
	00		 mov	 DWORD PTR [edi+eax*4+1212], 1

; 2715 : 
; 2716 : 			/*eab 8/94 numbers form class needs to be marked xxx*/
; 2717 : 
; 2718 : 			if (pLts_t->sign==0 && ls_util_is_year(llp, rlp)!=FALSE)

  01c00	8b 87 18 11 00
	00		 mov	 eax, DWORD PTR [edi+4376]
  01c06	85 c0		 test	 eax, eax
  01c08	75 28		 jne	 SHORT $L72811
  01c0a	8b 5c 24 30	 mov	 ebx, DWORD PTR _llp$[esp+36]
  01c0e	55		 push	 ebp
  01c0f	53		 push	 ebx
  01c10	e8 00 00 00 00	 call	 _ls_util_is_year
  01c15	83 c4 08	 add	 esp, 8
  01c18	85 c0		 test	 eax, eax
  01c1a	74 16		 je	 SHORT $L72811

; 2719 : 			{
; 2720 : /* GL 11/15/1996, only English need to take special care of 4 digits year */
; 2721 : #ifdef ENGLISH
; 2722 : 				ls_proc_do_4_digits(phTTS,llp);

  01c1c	53		 push	 ebx
  01c1d	56		 push	 esi
  01c1e	e8 00 00 00 00	 call	 _ls_proc_do_4_digits
  01c23	83 c4 08	 add	 esp, 8

; 2723 : #endif
; 2724 : #ifdef GERMAN
; 2725 : 				/* GL 02/13/1997  use 4 digits form for German years */
; 2726 : 				/* GL 04/10/1998  BATS#651 1000-1099, 2000+ pronunce the same way */
; 2727 : 				if ((lp1->l_ch != '1') || ((lp1->l_ch == '1') & ((lp1+1)->l_ch == '0')))
; 2728 : 					pLts_t->pflag = ls_proc_do_number(phTTS,lp1, rlp, ls_util_is_dot(pLts_t));
; 2729 : 				else
; 2730 : 					ls_proc_do_4_digits(phTTS,llp);
; 2731 : #endif
; 2732 : #ifdef SPANISH
; 2733 : 				pLts_t->pflag = ls_proc_do_number(phTTS,lp1, rlp, FALSE);
; 2734 : #endif
; 2735 : 				pLts_t->pflag = TRUE;   /* 1984 is plural.      */

  01c26	c7 87 24 11 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+4388], 1

; 2736 : 			}
; 2737 : 			else

  01c30	eb 24		 jmp	 SHORT $L72812
$L72811:

; 2738 : 			{
; 2739 : 				ls_proc_do_sign(phTTS,pLts_t->sign);

  01c32	8b 8f 18 11 00
	00		 mov	 ecx, DWORD PTR [edi+4376]
  01c38	51		 push	 ecx
  01c39	56		 push	 esi
  01c3a	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 2740 : #ifdef GERMAN
; 2741 : 				/* German use ending period to send ordial number */
; 2742 :                 pLts_t->pflag = ls_proc_do_number(phTTS,lp1, rlp, ls_util_is_dot(pLts_t));
; 2743 : #endif
; 2744 : #if defined (ENGLISH) || defined (SPANISH)
; 2745 : 				pLts_t->pflag = ls_proc_do_number(phTTS,lp1, rlp, FALSE);

  01c3f	8b 54 24 40	 mov	 edx, DWORD PTR _lp1$[esp+44]
  01c43	6a 00		 push	 0
  01c45	55		 push	 ebp
  01c46	52		 push	 edx
  01c47	56		 push	 esi
  01c48	e8 00 00 00 00	 call	 _ls_proc_do_number
  01c4d	83 c4 18	 add	 esp, 24			; 00000018H
  01c50	89 87 24 11 00
	00		 mov	 DWORD PTR [edi+4388], eax
$L72812:

; 2746 : #endif
; 2747 : 			}
; 2748 : 			
; 2749 : 			ls_task_lookahead(pLts_t);            			/* Watch for "ft."      */

  01c56	57		 push	 edi
  01c57	e8 00 00 00 00	 call	 _ls_task_lookahead

; 2750 : 
; 2751 : 			if (ls_util_is_white(&(pLts_t->citem)) == FALSE)

  01c5c	8d 87 00 09 00
	00		 lea	 eax, DWORD PTR [edi+2304]
  01c62	50		 push	 eax
  01c63	e8 00 00 00 00	 call	 _ls_util_is_white
  01c68	83 c4 08	 add	 esp, 8
  01c6b	85 c0		 test	 eax, eax

; 2752 : 			{
; 2753 : 				return(FINISHED_WORD);

  01c6d	0f 84 87 01 00
	00		 je	 $L73092

; 2754 : 			}
; 2755 : 			ls_util_send_phone(phTTS,pLts_t->rbphone);

  01c73	8b 8f 20 11 00
	00		 mov	 ecx, DWORD PTR [edi+4384]
  01c79	51		 push	 ecx
  01c7a	56		 push	 esi
  01c7b	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2756 : 
; 2757 : 			ls_task_readword(phTTS,&(pLts_t->nword[0]));    /* Read next word.      */

  01c80	8d af 14 0d 00
	00		 lea	 ebp, DWORD PTR [edi+3348]
  01c86	55		 push	 ebp
  01c87	56		 push	 esi
  01c88	e8 00 00 00 00	 call	 _ls_task_readword

; 2758 : 
; 2759 : 			lp1 = &(pLts_t->nword[0]);

  01c8d	8b dd		 mov	 ebx, ebp
  01c8f	83 c4 10	 add	 esp, 16			; 00000010H

; 2760 : 			while (lp1->l_ch != EOS)

  01c92	66 83 3b 00	 cmp	 WORD PTR [ebx], 0
  01c96	74 09		 je	 SHORT $L72816
$L72815:

; 2761 : 				++lp1;

  01c98	83 c3 08	 add	 ebx, 8
  01c9b	66 83 3b 00	 cmp	 WORD PTR [ebx], 0
  01c9f	75 f7		 jne	 SHORT $L72815
$L72816:

; 2762 : #if defined (ENGLISH) || defined (GERMAN)
; 2763 : 			if (ls_proc_is_am_pm(&(pLts_t->nword[0]), lp1) != FALSE) 

  01ca1	53		 push	 ebx
  01ca2	55		 push	 ebp
  01ca3	e8 00 00 00 00	 call	 _ls_proc_is_am_pm
  01ca8	83 c4 08	 add	 esp, 8
  01cab	85 c0		 test	 eax, eax
  01cad	74 0a		 je	 SHORT $L72817

; 2764 : 			{
; 2765 : #ifdef LS1DEBUG
; 2766 : 			printf("iasmpm spell\n");
; 2767 : #endif
; 2768 : 
; 2769 : 				ls_spel_spell(phTTS,&(pLts_t->nword[0]), lp1);

  01caf	53		 push	 ebx
  01cb0	55		 push	 ebp
  01cb1	56		 push	 esi
  01cb2	e8 00 00 00 00	 call	 _ls_spel_spell

; 2770 : 				ls_task_do_right_punct(phTTS,MISS);
; 2771 : 				ls_task_readword(phTTS,&(pLts_t->cword[0]));
; 2772 : 
; 2773 : 				return(LS_TASK_LOOP);

  01cb7	eb 4f		 jmp	 SHORT $L73093
$L72817:

; 2774 : 			}
; 2775 : #endif
; 2776 : 
; 2777 : 			if (ls_util_is_dot(pLts_t) == FALSE    /* Check if special.    */
; 2778 : 			|| (cp=ls_task_wlookup (pLts_t, &(pLts_t->nword[0]), &nabtab[0]) ) == NULL)

  01cb9	57		 push	 edi
  01cba	e8 00 00 00 00	 call	 _ls_util_is_dot
  01cbf	83 c4 04	 add	 esp, 4
  01cc2	85 c0		 test	 eax, eax
  01cc4	74 67		 je	 SHORT $L72820
  01cc6	68 00 00 00 00	 push	 OFFSET FLAT:_nabtab
  01ccb	55		 push	 ebp
  01ccc	57		 push	 edi
  01ccd	e8 00 00 00 00	 call	 _ls_task_wlookup
  01cd2	83 c4 0c	 add	 esp, 12			; 0000000cH
  01cd5	85 c0		 test	 eax, eax
  01cd7	74 54		 je	 SHORT $L72820

; 2782 : 			}
; 2783 : 			pLts_t->isnumabr=3;
; 2784 : 
; 2785 : 			if (pLts_t->pflag != FALSE)

  01cd9	8b 8f 24 11 00
	00		 mov	 ecx, DWORD PTR [edi+4388]
  01cdf	c7 87 fc 08 00
	00 03 00 00 00	 mov	 DWORD PTR [edi+2300], 3
  01ce9	85 c9		 test	 ecx, ecx
  01ceb	74 0e		 je	 SHORT $L72824

; 2786 : 			{   /* Pick right form.     */
; 2787 : 				while (*cp++ != SIL)

  01ced	8a 10		 mov	 dl, BYTE PTR [eax]
  01cef	40		 inc	 eax
  01cf0	84 d2		 test	 dl, dl
  01cf2	74 07		 je	 SHORT $L72824
$L72823:
  01cf4	8a 08		 mov	 cl, BYTE PTR [eax]
  01cf6	40		 inc	 eax
  01cf7	84 c9		 test	 cl, cl
  01cf9	75 f9		 jne	 SHORT $L72823
$L72824:

; 2788 : 					;
; 2789 : 			}
; 2790 : 			ls_util_send_phone_list(phTTS,cp);           	/* Send abbreviation.   */

  01cfb	50		 push	 eax
  01cfc	56		 push	 esi
  01cfd	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2791 : 
; 2792 : 			ls_util_read_item(phTTS);             			/* Eat up the ".".      */

  01d02	56		 push	 esi
  01d03	e8 00 00 00 00	 call	 _ls_util_read_item
$L73093:

; 2793 : 			ls_task_do_right_punct(phTTS,MISS);

  01d08	6a 00		 push	 0
  01d0a	56		 push	 esi
  01d0b	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 2794 : 			ls_task_readword(phTTS,&(pLts_t->cword[0]));    /* Advance, continue.   */

  01d10	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  01d16	57		 push	 edi
  01d17	56		 push	 esi
  01d18	e8 00 00 00 00	 call	 _ls_task_readword
  01d1d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2795 : 
; 2796 : 			return(LS_TASK_LOOP);

  01d20	b8 01 00 00 00	 mov	 eax, 1
  01d25	5f		 pop	 edi
  01d26	5e		 pop	 esi
  01d27	5d		 pop	 ebp
  01d28	5b		 pop	 ebx

; 2882 : }

  01d29	83 c4 18	 add	 esp, 24			; 00000018H
  01d2c	c3		 ret	 0
$L72820:

; 2779 : 			{
; 2780 : 				ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));

  01d2d	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  01d33	55		 push	 ebp
  01d34	57		 push	 edi
  01d35	e8 00 00 00 00	 call	 _ls_util_copyword
  01d3a	83 c4 08	 add	 esp, 8

; 2781 : 				return(LS_TASK_LOOP);

  01d3d	b8 01 00 00 00	 mov	 eax, 1
  01d42	5f		 pop	 edi
  01d43	5e		 pop	 esi
  01d44	5d		 pop	 ebp
  01d45	5b		 pop	 ebx

; 2882 : }

  01d46	83 c4 18	 add	 esp, 24			; 00000018H
  01d49	c3		 ret	 0
$L72810:

; 2797 : 		}
; 2798 : 
; 2799 : 		/*
; 2800 : 		 * Deal with plural numbers, like
; 2801 : 		 * "60s" and "60's". The last phoneme of
; 2802 : 		 * the number is hidden in "pLts_t->lphone", which is
; 2803 : 		 * looked at by the standard pluralizing
; 2804 : 		 * code in "ls7.c". Also deal with cents,
; 2805 : 		 * percents, and degrees.
; 2806 : 		 */
; 2807 :                          
; 2808 : /* JDB:  Spanish doesn't use this section! */                        
; 2809 : #ifdef ENGLISH
; 2810 : 		if (lp2+2 == rlp) 

  01d4a	8d 53 10	 lea	 edx, DWORD PTR [ebx+16]
  01d4d	3b d5		 cmp	 edx, ebp
  01d4f	75 6c		 jne	 SHORT $L72825

; 2811 : 		{             
; 2812 : 			/* 2 after the digits.  */
; 2813 : 			/* Plurals, like "60's".                        */
; 2814 : 			if (lp2->l_ch=='\'' && (lp2+1)->l_ch=='s') 

  01d51	66 83 3b 27	 cmp	 WORD PTR [ebx], 39	; 00000027H
  01d55	75 1e		 jne	 SHORT $L72826
  01d57	66 83 7b 08 73	 cmp	 WORD PTR [ebx+8], 115	; 00000073H
  01d5c	75 17		 jne	 SHORT $L72826

; 2815 : 			{
; 2816 : 				ls_proc_do_sign(phTTS,pLts_t->sign);

  01d5e	8b 87 18 11 00
	00		 mov	 eax, DWORD PTR [edi+4376]
  01d64	50		 push	 eax
  01d65	56		 push	 esi
  01d66	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 2817 : 
; 2818 : 				pLts_t->pflag=ls_proc_do_number(phTTS,lp1, lp2, FALSE);

  01d6b	8b 4c 24 40	 mov	 ecx, DWORD PTR _lp1$[esp+44]
  01d6f	6a 00		 push	 0
  01d71	53		 push	 ebx
  01d72	51		 push	 ecx

; 2819 : 				ls_util_pluralize(phTTS);
; 2820 : 				return(FINISHED_WORD);

  01d73	eb 70		 jmp	 SHORT $L73091
$L72826:

; 2821 : 			}               
; 2822 : #endif		 
; 2823 : /* JDB: end of dependent section */
; 2824 : 			
; 2825 : 			/* Ordinals, like "1st", "2nd", "3rd".          */
; 2826 : 			if (pLts_t->sign==0 && ls_util_is_ordinal(phTTS,&num)!=FALSE) 

  01d75	8b 87 18 11 00
	00		 mov	 eax, DWORD PTR [edi+4376]
  01d7b	85 c0		 test	 eax, eax
  01d7d	0f 85 54 01 00
	00		 jne	 $L72831
  01d83	8d 54 24 10	 lea	 edx, DWORD PTR _num$[esp+40]
  01d87	52		 push	 edx
  01d88	56		 push	 esi
  01d89	e8 00 00 00 00	 call	 _ls_util_is_ordinal
  01d8e	83 c4 08	 add	 esp, 8
  01d91	85 c0		 test	 eax, eax
  01d93	0f 84 3e 01 00
	00		 je	 $L72831

; 2827 : 			{
; 2828 : 				pLts_t->pflag=ls_proc_do_number(phTTS,llp, lp2, TRUE);

  01d99	8b 44 24 30	 mov	 eax, DWORD PTR _llp$[esp+36]
  01d9d	6a 01		 push	 1
  01d9f	53		 push	 ebx
  01da0	50		 push	 eax
  01da1	56		 push	 esi
  01da2	e8 00 00 00 00	 call	 _ls_proc_do_number
  01da7	83 c4 10	 add	 esp, 16			; 00000010H
  01daa	89 87 24 11 00
	00		 mov	 DWORD PTR [edi+4388], eax

; 2829 : 				return(FINISHED_WORD);

  01db0	b8 03 00 00 00	 mov	 eax, 3
  01db5	5f		 pop	 edi
  01db6	5e		 pop	 esi
  01db7	5d		 pop	 ebp
  01db8	5b		 pop	 ebx

; 2882 : }

  01db9	83 c4 18	 add	 esp, 24			; 00000018H
  01dbc	c3		 ret	 0
$L72825:

; 2830 : 			}
; 2831 : 
; 2832 : /* JDB:  Spanish doesn't use this section! */                        
; 2833 : #ifdef ENGLISH			
; 2834 : 		}
; 2835 : 		else
; 2836 : #endif		
; 2837 : 		if (lp2+1 == rlp) 

  01dbd	8d 4b 08	 lea	 ecx, DWORD PTR [ebx+8]
  01dc0	3b cd		 cmp	 ecx, ebp
  01dc2	0f 85 0f 01 00
	00		 jne	 $L72831

; 2838 : 		{      
; 2839 : 			/* 1 after the digits.  */
; 2840 : 			/* Plurals, like "60s". */
; 2841 : 			if ((c=lp2->l_ch) == 's') 

  01dc8	0f bf 2b	 movsx	 ebp, WORD PTR [ebx]
  01dcb	83 fd 73	 cmp	 ebp, 115		; 00000073H
  01dce	75 37		 jne	 SHORT $L72830

; 2842 : 			{           
; 2843 : 				ls_proc_do_sign(phTTS,pLts_t->sign);

  01dd0	8b 97 18 11 00
	00		 mov	 edx, DWORD PTR [edi+4376]
  01dd6	52		 push	 edx
  01dd7	56		 push	 esi
  01dd8	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 2844 : 				pLts_t->pflag=ls_proc_do_number(phTTS,lp1, lp2, FALSE);

  01ddd	8b 44 24 40	 mov	 eax, DWORD PTR _lp1$[esp+44]
  01de1	6a 00		 push	 0
  01de3	53		 push	 ebx
  01de4	50		 push	 eax
$L73091:
  01de5	56		 push	 esi
  01de6	e8 00 00 00 00	 call	 _ls_proc_do_number

; 2845 : 				ls_util_pluralize(phTTS);

  01deb	56		 push	 esi
  01dec	89 87 24 11 00
	00		 mov	 DWORD PTR [edi+4388], eax
  01df2	e8 00 00 00 00	 call	 _ls_util_pluralize
  01df7	83 c4 1c	 add	 esp, 28			; 0000001cH
$L73092:
  01dfa	5f		 pop	 edi
  01dfb	5e		 pop	 esi
  01dfc	5d		 pop	 ebp

; 2846 : 				return(FINISHED_WORD);

  01dfd	b8 03 00 00 00	 mov	 eax, 3
  01e02	5b		 pop	 ebx

; 2882 : }

  01e03	83 c4 18	 add	 esp, 24			; 00000018H
  01e06	c3		 ret	 0
$L72830:

; 2847 : 			}
; 2848 : 			/* "10%", "10 cents", "10 degrees". */
; 2849 : 			if (c=='%' || c==0xA2 || c==0xB0) 

  01e07	83 fd 25	 cmp	 ebp, 37			; 00000025H
  01e0a	74 14		 je	 SHORT $L72832
  01e0c	81 fd a2 00 00
	00		 cmp	 ebp, 162		; 000000a2H
  01e12	74 0c		 je	 SHORT $L72832
  01e14	81 fd b0 00 00
	00		 cmp	 ebp, 176		; 000000b0H
  01e1a	0f 85 b7 00 00
	00		 jne	 $L72831
$L72832:

; 2850 : 			{
; 2851 : 				ls_proc_do_sign(phTTS,pLts_t->sign);

  01e20	8b 8f 18 11 00
	00		 mov	 ecx, DWORD PTR [edi+4376]
  01e26	51		 push	 ecx
  01e27	56		 push	 esi
  01e28	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 2852 : 				pLts_t->pflag = ls_proc_do_number(phTTS,lp1, lp2, FALSE);

  01e2d	8b 54 24 40	 mov	 edx, DWORD PTR _lp1$[esp+44]
  01e31	6a 00		 push	 0
  01e33	53		 push	 ebx
  01e34	52		 push	 edx
  01e35	56		 push	 esi
  01e36	e8 00 00 00 00	 call	 _ls_proc_do_number
  01e3b	83 c4 18	 add	 esp, 24			; 00000018H

; 2853 : 				if (c == '%')

  01e3e	83 fd 25	 cmp	 ebp, 37			; 00000025H
  01e41	89 87 24 11 00
	00		 mov	 DWORD PTR [edi+4388], eax
  01e47	75 1b		 jne	 SHORT $L72833

; 2854 : 					ls_util_send_phone_list(phTTS,ppercent);

  01e49	68 00 00 00 00	 push	 OFFSET FLAT:_ppercent
  01e4e	56		 push	 esi
  01e4f	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2873 : 							ls_util_send_phone(phTTS,Z);

  01e54	83 c4 08	 add	 esp, 8

; 2874 : #endif							
; 2875 : 					}
; 2876 : 				}
; 2877 : 				return(FINISHED_WORD);

  01e57	b8 03 00 00 00	 mov	 eax, 3
  01e5c	5f		 pop	 edi
  01e5d	5e		 pop	 esi
  01e5e	5d		 pop	 ebp
  01e5f	5b		 pop	 ebx

; 2882 : }

  01e60	83 c4 18	 add	 esp, 24			; 00000018H
  01e63	c3		 ret	 0
$L72833:

; 2855 : 				else 
; 2856 : 				{
; 2857 : 					ls_util_send_phone(phTTS,WBOUND);

  01e64	6a 6f		 push	 111			; 0000006fH
  01e66	56		 push	 esi
  01e67	e8 00 00 00 00	 call	 _ls_util_send_phone
  01e6c	83 c4 08	 add	 esp, 8

; 2858 : 					if (c == 0xA2) 

  01e6f	81 fd a2 00 00
	00		 cmp	 ebp, 162		; 000000a2H
  01e75	75 30		 jne	 SHORT $L72835

; 2859 : 					{
; 2860 : 						ls_util_send_phone_list(phTTS,pcent);        

  01e77	68 00 00 00 00	 push	 OFFSET FLAT:_pcent
  01e7c	56		 push	 esi
  01e7d	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2861 : /* JDB: again, English plurals made conditional... */							
; 2862 : #ifdef ENGLISH						
; 2863 : 						if (pLts_t->pflag != FALSE)

  01e82	8b 87 24 11 00
	00		 mov	 eax, DWORD PTR [edi+4388]
  01e88	83 c4 08	 add	 esp, 8
  01e8b	85 c0		 test	 eax, eax
  01e8d	74 3b		 je	 SHORT $L72838

; 2864 : 							ls_util_send_phone(phTTS,S);

  01e8f	6a 29		 push	 41			; 00000029H

; 2873 : 							ls_util_send_phone(phTTS,Z);

  01e91	56		 push	 esi
  01e92	e8 00 00 00 00	 call	 _ls_util_send_phone
  01e97	83 c4 08	 add	 esp, 8

; 2874 : #endif							
; 2875 : 					}
; 2876 : 				}
; 2877 : 				return(FINISHED_WORD);

  01e9a	b8 03 00 00 00	 mov	 eax, 3
  01e9f	5f		 pop	 edi
  01ea0	5e		 pop	 esi
  01ea1	5d		 pop	 ebp
  01ea2	5b		 pop	 ebx

; 2882 : }

  01ea3	83 c4 18	 add	 esp, 24			; 00000018H
  01ea6	c3		 ret	 0
$L72835:

; 2865 : #endif							
; 2866 : 					} 
; 2867 : 					else 
; 2868 : 					{
; 2869 : 						ls_util_send_phone_list(phTTS,pdegree);

  01ea7	68 00 00 00 00	 push	 OFFSET FLAT:_pdegree
  01eac	56		 push	 esi
  01ead	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2870 : /* JDB: again, English plurals made conditional... */				
; 2871 : #ifdef ENGLISH						
; 2872 : 						if (pLts_t->pflag != FALSE)

  01eb2	8b 87 24 11 00
	00		 mov	 eax, DWORD PTR [edi+4388]
  01eb8	83 c4 08	 add	 esp, 8
  01ebb	85 c0		 test	 eax, eax
  01ebd	74 0b		 je	 SHORT $L72838

; 2873 : 							ls_util_send_phone(phTTS,Z);

  01ebf	6a 2a		 push	 42			; 0000002aH
  01ec1	56		 push	 esi
  01ec2	e8 00 00 00 00	 call	 _ls_util_send_phone
  01ec7	83 c4 08	 add	 esp, 8
$L72838:
  01eca	5f		 pop	 edi
  01ecb	5e		 pop	 esi
  01ecc	5d		 pop	 ebp

; 2874 : #endif							
; 2875 : 					}
; 2876 : 				}
; 2877 : 				return(FINISHED_WORD);

  01ecd	b8 03 00 00 00	 mov	 eax, 3
  01ed2	5b		 pop	 ebx

; 2882 : }

  01ed3	83 c4 18	 add	 esp, 24			; 00000018H
  01ed6	c3		 ret	 0
$L72831:
  01ed7	5f		 pop	 edi
  01ed8	5e		 pop	 esi
  01ed9	5d		 pop	 ebp

; 2878 : 			}
; 2879 : 		}
; 2880 : 	}
; 2881 : 	return(KEEP_SEARCHING);

  01eda	33 c0		 xor	 eax, eax
  01edc	5b		 pop	 ebx

; 2882 : }

  01edd	83 c4 18	 add	 esp, 24			; 00000018H
  01ee0	c3		 ret	 0
_ls_task_plain_number_processing ENDP
_TEXT	ENDS
EXTRN	_ls_proc_do_part_number:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_part_number PROC NEAR

; 2907 : {              

  01ef0	55		 push	 ebp

; 2908 : 	int c;
; 2909 : 	LETTER *lp1;
; 2910 : 	PLTS_T pLts_t;
; 2911 : 	pLts_t = phTTS->pLTSThreadData;

  01ef1	8b 6c 24 08	 mov	 ebp, DWORD PTR _phTTS$[esp]
  01ef5	56		 push	 esi

; 2912 : 
; 2913 : #ifdef LS1DEBUG
; 2914 : 	printf("entering ls_task_part_number\n");
; 2915 : 	printf("no more heuristics ");
; 2916 : 	printf("left=%u  right=%u\n",llp,rlp);
; 2917 : #endif        
; 2918 : 	lp1=llp;
; 2919 : 	while (lp1 != rlp) 

  01ef6	8b 74 24 14	 mov	 esi, DWORD PTR _rlp$[esp+4]
  01efa	8b 55 10	 mov	 edx, DWORD PTR [ebp+16]
  01efd	57		 push	 edi
  01efe	8b 7c 24 14	 mov	 edi, DWORD PTR _llp$[esp+8]
  01f02	3b fe		 cmp	 edi, esi
  01f04	8b cf		 mov	 ecx, edi
  01f06	74 46		 je	 SHORT $L72851
$L72850:

; 2920 : 	{
; 2921 : 		c = lp1->l_ch;

  01f08	0f bf 01	 movsx	 eax, WORD PTR [ecx]

; 2922 : 		if (c=='/' || (c>='0' && c<='9'))

  01f0b	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  01f0e	74 29		 je	 SHORT $L72853
  01f10	83 f8 30	 cmp	 eax, 48			; 00000030H
  01f13	7c 05		 jl	 SHORT $L72852
  01f15	83 f8 39	 cmp	 eax, 57			; 00000039H
  01f18	7e 1f		 jle	 SHORT $L72853
$L72852:

; 2925 : 		}
; 2926 : 		else if (c == '\'')

  01f1a	83 f8 27	 cmp	 eax, 39			; 00000027H
  01f1d	75 0a		 jne	 SHORT $L72855

; 2927 : 		{
; 2928 : 			pLts_t->lflag |= SQUOTE;

  01f1f	8b 82 f8 08 00
	00		 mov	 eax, DWORD PTR [edx+2296]
  01f25	0c 08		 or	 al, 8

; 2929 : 		}
; 2930 : 		else if (c!='-' && !(IS_ALPHA(c)))

  01f27	eb 18		 jmp	 SHORT $L73098
$L72855:
  01f29	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  01f2c	74 19		 je	 SHORT $L72857
  01f2e	f6 80 00 00 00
	00 03		 test	 BYTE PTR _ls_char_feat[eax], 3
  01f35	74 27		 je	 SHORT $L73096
  01f37	eb 0e		 jmp	 SHORT $L72857
$L72853:

; 2923 : 		{
; 2924 : 			pLts_t->lflag |= DIGSLSH;

  01f39	8b 82 f8 08 00
	00		 mov	 eax, DWORD PTR [edx+2296]
  01f3f	0c 04		 or	 al, 4
$L73098:
  01f41	89 82 f8 08 00
	00		 mov	 DWORD PTR [edx+2296], eax
$L72857:

; 2931 : 		{
; 2932 : #ifdef LS1DEBUG
; 2933 : 			printf(" drop through spell %c  \n",c);
; 2934 : #endif
; 2935 : 
; 2936 : 			return(SPELL_WORD);
; 2937 : 		}
; 2938 : 		++lp1;

  01f47	83 c1 08	 add	 ecx, 8
  01f4a	3b ce		 cmp	 ecx, esi
  01f4c	75 ba		 jne	 SHORT $L72850
$L72851:

; 2939 : 	}
; 2940 : 	if (((pLts_t->lflag)&DIGSLSH) != 0) 

  01f4e	8b 92 f8 08 00
	00		 mov	 edx, DWORD PTR [edx+2296]
  01f54	f6 c2 04	 test	 dl, 4
  01f57	74 22		 je	 SHORT $L72858

; 2941 : 	{             /* Parts have digits or */
; 2942 : 		if (((pLts_t->lflag)&SQUOTE) != 0)        /* slashes, and do not  */

  01f59	f6 c2 08	 test	 dl, 8
  01f5c	74 09		 je	 SHORT $L72859
$L73096:
  01f5e	5f		 pop	 edi
  01f5f	5e		 pop	 esi

; 2943 : 		{
; 2944 : #ifdef LS1DEBUG
; 2945 : 			printf(" punt spell \n");
; 2946 : #endif
; 2947 : 			return(SPELL_WORD);

  01f60	b8 02 00 00 00	 mov	 eax, 2
  01f65	5d		 pop	 ebp

; 2953 : }

  01f66	c3		 ret	 0
$L72859:

; 2948 : 		}
; 2949 : 		ls_proc_do_part_number(phTTS,llp, rlp);

  01f67	56		 push	 esi
  01f68	57		 push	 edi
  01f69	55		 push	 ebp
  01f6a	e8 00 00 00 00	 call	 _ls_proc_do_part_number
  01f6f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2950 : 		return(FINISHED_WORD);

  01f72	b8 03 00 00 00	 mov	 eax, 3
  01f77	5f		 pop	 edi
  01f78	5e		 pop	 esi
  01f79	5d		 pop	 ebp

; 2953 : }

  01f7a	c3		 ret	 0
$L72858:
  01f7b	5f		 pop	 edi
  01f7c	5e		 pop	 esi

; 2951 : 	}
; 2952 : 	return(KEEP_SEARCHING);                           

  01f7d	33 c0		 xor	 eax, eax
  01f7f	5d		 pop	 ebp

; 2953 : }

  01f80	c3		 ret	 0
_ls_task_part_number ENDP
_TEXT	ENDS
EXTRN	_ls_rule_do_lts:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_firsttim$ = 12
_ls_task_process_word PROC NEAR

; 2981 : 	volatile int    firsttim;
; 2982 : 	LETTER *lp1;
; 2983 : 	LETTER *lp2;
; 2984 : 	int     type;
; 2985 : 	int     c;
; 2986 : 	PLTS_T pLts_t;
; 2987 : 	pLts_t = phTTS->pLTSThreadData;
; 2988 : 	
; 2989 : 	/*
; 2990 : 	 * The second scan checks that each
; 2991 : 	 * chunk of of the word (which may be the whole word,
; 2992 : 	 * or a bit of a compound word) contains a vowel, and a
; 2993 : 	 * consonant except for some special cases. If you get
; 2994 : 	 * to the end without a fail, run the thing through
; 2995 : 	 * the letter to sound rules.
; 2996 : 	 */
; 2997 : #ifdef LS1DEBUG
; 2998 : 	printf("entering ls_task_process_word ");
; 2999 : 	printf("left=%u  right=%u\n",llp,rlp);
; 3000 : #endif
; 3001 : 
; 3002 : 	lp1 = llp;
; 3003 : 	firsttim=1;                             
; 3004 : 
; 3005 : 	while (lp1 != rlp)

  01f90	8b 54 24 0c	 mov	 edx, DWORD PTR _rlp$[esp-4]
  01f94	53		 push	 ebx
  01f95	55		 push	 ebp
  01f96	56		 push	 esi
  01f97	8b 74 24 14	 mov	 esi, DWORD PTR _llp$[esp+8]
  01f9b	57		 push	 edi
  01f9c	8b 7c 24 14	 mov	 edi, DWORD PTR _phTTS$[esp+12]
  01fa0	3b f2		 cmp	 esi, edx
  01fa2	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _firsttim$[esp+12], 1
  01faa	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]
  01fad	0f 84 b1 00 00
	00		 je	 $L73108
  01fb3	eb 04		 jmp	 SHORT $L72874
$L73112:
  01fb5	8b 54 24 1c	 mov	 edx, DWORD PTR _rlp$[esp+12]
$L72874:

; 3006 : 	{
; 3007 : 		lp2 = lp1;
; 3008 : 		pLts_t->lflag &= ~(HNONY|HCONS|HVOWEL);

  01fb9	8b 83 f8 08 00
	00		 mov	 eax, DWORD PTR [ebx+2296]
  01fbf	8b ee		 mov	 ebp, esi
  01fc1	24 4f		 and	 al, 79			; 0000004fH
  01fc3	89 83 f8 08 00
	00		 mov	 DWORD PTR [ebx+2296], eax
$L72877:

; 3009 : 		while (lp1!=rlp && (c=lp1->l_ch)!='-')

  01fc9	0f bf 0e	 movsx	 ecx, WORD PTR [esi]
  01fcc	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  01fcf	74 4f		 je	 SHORT $L72878

; 3010 : 		{
; 3011 : 			type = lsctype[c];

  01fd1	33 c0		 xor	 eax, eax
  01fd3	66 8b 04 4d 00
	00 00 00	 mov	 ax, WORD PTR _lsctype[ecx*2]

; 3012 : 			if ((type&C) != 0)

  01fdb	f6 c4 04	 test	 ah, 4
  01fde	74 0a		 je	 SHORT $L72879

; 3013 : 				pLts_t->lflag |= HNONY|HCONS;

  01fe0	8b 83 f8 08 00
	00		 mov	 eax, DWORD PTR [ebx+2296]
  01fe6	0c a0		 or	 al, -96			; ffffffa0H

; 3014 : 			else 

  01fe8	eb 29		 jmp	 SHORT $L73114
$L72879:

; 3015 : 			{
; 3016 : 				/* 1/2/1997 GL, use OO (defined in ls_defs.h" for vowel checking */
; 3017 : 				if ((type&OO) != 0)

  01fea	f6 c4 02	 test	 ah, 2
  01fed	74 0a		 je	 SHORT $L72881

; 3018 : 					pLts_t->lflag |= HNONY|HVOWEL;

  01fef	8b 83 f8 08 00
	00		 mov	 eax, DWORD PTR [ebx+2296]
  01ff5	0c 90		 or	 al, -112		; ffffff90H

; 3019 : 				else 

  01ff7	eb 1a		 jmp	 SHORT $L73114
$L72881:

; 3020 : 				{
; 3021 : 					/* MG 11/04/1997 BATS#509 add 'Y for checking */  
; 3022 : 					if (c == 'y' || c == 'Y') 

  01ff9	83 f9 79	 cmp	 ecx, 121		; 00000079H
  01ffc	74 05		 je	 SHORT $L72884
  01ffe	83 f9 59	 cmp	 ecx, 89			; 00000059H
  02001	75 16		 jne	 SHORT $L72886
$L72884:

; 3023 : 					{           
; 3024 : /* JDB: language dependent */
; 3025 : #ifdef ENGLISH_US					
; 3026 : 						if (lp1 == lp2)
; 3027 : 							pLts_t->lflag |= HCONS;

  02003	8b 83 f8 08 00
	00		 mov	 eax, DWORD PTR [ebx+2296]
  02009	3b f5		 cmp	 esi, ebp
  0200b	75 04		 jne	 SHORT $L72885
  0200d	0c 20		 or	 al, 32			; 00000020H

; 3028 : 						else

  0200f	eb 02		 jmp	 SHORT $L73114
$L72885:

; 3029 : 							pLts_t->lflag |= HVOWEL;

  02011	0c 10		 or	 al, 16			; 00000010H
$L73114:
  02013	89 83 f8 08 00
	00		 mov	 DWORD PTR [ebx+2296], eax
$L72886:

; 3030 : #endif
; 3031 : #ifdef ENGLISH_UK
; 3032 : 						if (lp1 == lp2)
; 3033 : 							pLts_t->lflag |= HCONS;
; 3034 : 						else
; 3035 : 							pLts_t->lflag |= HVOWEL;
; 3036 : #endif
; 3037 : 
; 3038 : #ifdef SPANISH
; 3039 :                         pLts_t->lflag |= (HNONY | HCONS);							
; 3040 : #endif                        
; 3041 : 					}
; 3042 : 				}
; 3043 : 			}
; 3044 : 			++lp1;

  02019	83 c6 08	 add	 esi, 8
  0201c	3b f2		 cmp	 esi, edx
  0201e	75 a9		 jne	 SHORT $L72877
$L72878:

; 3045 : 		}
; 3046 : 
; 3047 : 		pLts_t->tlflag=pLts_t->lflag;

  02020	8b 83 f8 08 00
	00		 mov	 eax, DWORD PTR [ebx+2296]

; 3048 : 
; 3049 : #ifdef LS1DEBUG
; 3050 : 		printf("b2a %c %c %d\n",lp2->l_ch,lp1->l_ch, lp1->l_ch);
; 3051 : 		printf("looking \n");
; 3052 : 
; 3053 : #endif
; 3054 : 		/* ttlp1=lp1;   */
; 3055 : 		/* if(lp1->l_ch == '-') */ /* this is a bug */
; 3056 : 			/* ttlp1--;  */
; 3057 : 		if (ls_util_lookup(phTTS,lp2, lp1, FIRST) != MISS)

  02026	6a 00		 push	 0
  02028	56		 push	 esi
  02029	55		 push	 ebp
  0202a	57		 push	 edi
  0202b	89 83 14 11 00
	00		 mov	 DWORD PTR [ebx+4372], eax
  02031	e8 00 00 00 00	 call	 _ls_util_lookup
  02036	83 c4 10	 add	 esp, 16			; 00000010H
  02039	85 c0		 test	 eax, eax
  0203b	74 35		 je	 SHORT $L72887

; 3058 : 		{
; 3059 : #ifdef LS1DEBUG
; 3060 : 
; 3061 : 			printf("got a hit");
; 3062 : #endif
; 3063 : 			if(firsttim == 1)

  0203d	83 7c 24 18 01	 cmp	 DWORD PTR _firsttim$[esp+12], 1
  02042	75 2a		 jne	 SHORT $L72888

; 3064 : 			{
; 3065 : 				lp1++;
; 3066 : #ifdef LS1DEBUG
; 3067 : printf("sending hypen");
; 3068 : #endif
; 3069 : 				ls_util_send_phone(phTTS, HYPHEN );

  02044	6a 6e		 push	 110			; 0000006eH
  02046	57		 push	 edi
  02047	83 c6 08	 add	 esi, 8
  0204a	e8 00 00 00 00	 call	 _ls_util_send_phone
  0204f	83 c4 08	 add	 esp, 8

; 3070 : 				lp2=lp1;
; 3071 : 				llp=lp1;
; 3072 : 				firsttim=0;

  02052	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _firsttim$[esp+12], 0
$L72904:
  0205a	3b 74 24 1c	 cmp	 esi, DWORD PTR _rlp$[esp+12]
  0205e	0f 85 51 ff ff
	ff		 jne	 $L73112
$L73108:
  02064	5f		 pop	 edi
  02065	5e		 pop	 esi
  02066	5d		 pop	 ebp

; 3166 : 		}
; 3167 : 	}
; 3168 : 	return(FINISHED_WORD);

  02067	b8 03 00 00 00	 mov	 eax, 3
  0206c	5b		 pop	 ebx

; 3169 : }

  0206d	c3		 ret	 0
$L72888:

; 3073 : 				continue;
; 3074 : 			}
; 3075 : 			lp2=lp1;

  0206e	8b ee		 mov	 ebp, esi

; 3076 : 			llp=lp1;
; 3077 : 		}
; 3078 : 		else

  02070	eb 62		 jmp	 SHORT $L72896
$L72887:

; 3079 : 		{ 
; 3080 : 			/* MGS 6/13/97 BATS #389 changed so single letters get spelled */
; 3081 : 			if( ((pLts_t->tlflag)&HVOWEL) != 0  && (lp2+1 != lp1))

  02072	f6 83 14 11 00
	00 10		 test	 BYTE PTR [ebx+4372], 16	; 00000010H
  02079	74 59		 je	 SHORT $L72896
  0207b	8d 4d 08	 lea	 ecx, DWORD PTR [ebp+8]
  0207e	3b ce		 cmp	 ecx, esi
  02080	74 52		 je	 SHORT $L72896

; 3082 : 			{
; 3083 : #ifdef LS1DEBUG
; 3084 : 				printf("doing lts1 ");
; 3085 : 				printf("left=%u  right=%u\n",lp2,lp1);
; 3086 : #endif
; 3087 : #ifdef DUMP_WORD
; 3088 : 				//printf("doing lts1\n");
; 3089 : #endif
; 3090 : 
; 3091 : 				/* MGS 6/16/97 BATS #387 Added becasue rule engine needs lower case characters */
; 3092 : 				ls_task_remove_case(lp2,lp1);

  02082	56		 push	 esi
  02083	55		 push	 ebp
  02084	e8 00 00 00 00	 call	 _ls_task_remove_case

; 3093 : 
; 3094 : 				ls_rule_do_lts(phTTS,lp2, lp1);

  02089	56		 push	 esi
  0208a	55		 push	 ebp
  0208b	57		 push	 edi
  0208c	e8 00 00 00 00	 call	 _ls_rule_do_lts
  02091	83 c4 14	 add	 esp, 20			; 00000014H

; 3095 : 
; 3096 : #ifdef DUMP_WORD
; 3097 : 				//printf("done lts1\n");
; 3098 : #endif
; 3099 : #ifdef LS1DEBUG
; 3100 : 
; 3101 : 				printf("done lts1 ");
; 3102 : 				printf("left=%u  right=%u\n",lp2,lp1);
; 3103 : #endif
; 3104 : 				if (lp1 != rlp)

  02094	8b 44 24 1c	 mov	 eax, DWORD PTR _rlp$[esp+12]
  02098	3b f0		 cmp	 esi, eax

; 3105 : 				{               /* Inter-chunk gap.     */
; 3106 : 					lp2 = lp1;

  0209a	8b ee		 mov	 ebp, esi

; 3095 : 
; 3096 : #ifdef DUMP_WORD
; 3097 : 				//printf("done lts1\n");
; 3098 : #endif
; 3099 : #ifdef LS1DEBUG
; 3100 : 
; 3101 : 				printf("done lts1 ");
; 3102 : 				printf("left=%u  right=%u\n",lp2,lp1);
; 3103 : #endif
; 3104 : 				if (lp1 != rlp)

  0209c	74 36		 je	 SHORT $L72896
$L72893:

; 3107 : 					while (lp1!=rlp && lp1->l_ch=='-')

  0209e	66 83 3e 2d	 cmp	 WORD PTR [esi], 45	; 0000002dH
  020a2	75 07		 jne	 SHORT $L72894

; 3108 : 						++lp1;

  020a4	83 c6 08	 add	 esi, 8
  020a7	3b f0		 cmp	 esi, eax
  020a9	75 f3		 jne	 SHORT $L72893
$L72894:

; 3109 : 					llp=lp1; 
; 3110 : 					/* GL 03/04/1997  Who add this one? it is a bug */
; 3111 : 					/* it will force lp2_1  never equal to lp1 */
; 3112 : 					/*lp2=lp1;*/
; 3113 : 					ls_util_send_phone(phTTS,lp2+1==lp1 ? HYPHEN : COMMA);

  020ab	8d 7d 08	 lea	 edi, DWORD PTR [ebp+8]
  020ae	8b 44 24 14	 mov	 eax, DWORD PTR _phTTS$[esp+12]
  020b2	8b d7		 mov	 edx, edi
  020b4	2b d6		 sub	 edx, esi
  020b6	f7 da		 neg	 edx
  020b8	1b d2		 sbb	 edx, edx
  020ba	83 e2 05	 and	 edx, 5
  020bd	83 c2 6e	 add	 edx, 110		; 0000006eH
  020c0	52		 push	 edx
  020c1	50		 push	 eax
  020c2	e8 00 00 00 00	 call	 _ls_util_send_phone
  020c7	83 c4 08	 add	 esp, 8

; 3114 : 					/* MGS 6/13/97 BATS #389 added for f-a-r wont say ef a dash r */
; 3115 : 					if (lp2+1==lp1)

  020ca	3b fe		 cmp	 edi, esi
  020cc	75 02		 jne	 SHORT $L73111

; 3116 : 						lp2++;

  020ce	8b ef		 mov	 ebp, edi
$L73111:

; 3117 : 				}
; 3118 : 				else

  020d0	8b 7c 24 14	 mov	 edi, DWORD PTR _phTTS$[esp+12]
$L72896:

; 3119 : 				{
; 3120 : 					llp=lp1;
; 3121 : 					lp2=lp1;
; 3122 : 				}
; 3123 : #ifdef LS1DEBUG
; 3124 : 				printf("done lts1 333");
; 3125 : 				printf("left=%u  right=%u\n",llp,rlp);
; 3126 : #endif
; 3127 : 			}
; 3128 : 		}
; 3129 : 		firsttim=0;   
; 3130 : 		if (lp2!=lp1)

  020d4	3b ee		 cmp	 ebp, esi
  020d6	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _firsttim$[esp+12], 0
  020de	74 3c		 je	 SHORT $L72900

; 3131 : 		{
; 3132 : 			if (((pLts_t->lflag)&HNONY) == 0)         /* Spell if all "y".    */

  020e0	f6 83 f8 08 00
	00 80		 test	 BYTE PTR [ebx+2296], -128 ; ffffff80H
  020e7	75 0b		 jne	 SHORT $L72898

; 3133 : 			{
; 3134 : #ifdef LS1DEBUG
; 3135 : 				printf(" spell all y \n");
; 3136 : #endif
; 3137 : 				ls_spel_spell(phTTS,lp2,lp1);

  020e9	56		 push	 esi
  020ea	55		 push	 ebp
  020eb	57		 push	 edi
  020ec	e8 00 00 00 00	 call	 _ls_spel_spell
  020f1	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72898:

; 3138 : 				/* return(SPELL_WORD); */
; 3139 : 			}
; 3140 : 			if (((pLts_t->lflag)&HVOWEL) == 0)        /* Spell if no vowels.  */

  020f4	f6 83 f8 08 00
	00 10		 test	 BYTE PTR [ebx+2296], 16	; 00000010H
  020fb	75 0b		 jne	 SHORT $L72899

; 3141 : 			{
; 3142 : #ifdef LS1DEBUG
; 3143 : 				printf("spell no vowel  \n");
; 3144 : #endif
; 3145 : 				ls_spel_spell(phTTS,lp2,lp1);

  020fd	56		 push	 esi
  020fe	55		 push	 ebp
  020ff	57		 push	 edi
  02100	e8 00 00 00 00	 call	 _ls_spel_spell
  02105	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72899:

; 3146 : 				/* return(SPELL_WORD); */
; 3147 : 			}
; 3148 : 			if (((pLts_t->lflag)&HCONS) == 0)

  02108	f6 83 f8 08 00
	00 20		 test	 BYTE PTR [ebx+2296], 32	; 00000020H
  0210f	75 0b		 jne	 SHORT $L72900

; 3149 : 			{       /* If no consonant, the */
; 3150 : 				/* if (lp2+1 != lp1)
; 3151 : 				{ */
; 3152 : #ifdef LS1DEBUG
; 3153 : 					printf(" spell no cons. \n");
; 3154 : #endif
; 3155 : 					ls_spel_spell(phTTS,lp2,lp1);

  02111	56		 push	 esi
  02112	55		 push	 ebp
  02113	57		 push	 edi
  02114	e8 00 00 00 00	 call	 _ls_spel_spell
  02119	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72900:

; 3156 : 					/* return(SPELL_WORD); */   /* are legal.*/         
; 3157 : 			/*  } */
; 3158 : 
; 3159 : 			}
; 3160 : 		}
; 3161 : 		if (lp1 != rlp)

  0211c	8b 44 24 1c	 mov	 eax, DWORD PTR _rlp$[esp+12]
  02120	3b f0		 cmp	 esi, eax
  02122	0f 84 3c ff ff
	ff		 je	 $L73108

; 3162 : 		{               /* Hit "-", allow long  */
; 3163 : 			pLts_t->lflag |= HHYPHEN;       /* blocks of "---".     */

  02128	83 8b f8 08 00
	00 40		 or	 DWORD PTR [ebx+2296], 64 ; 00000040H
$L72903:

; 3164 : 			while (lp1!=rlp && lp1->l_ch=='-')

  0212f	66 83 3e 2d	 cmp	 WORD PTR [esi], 45	; 0000002dH
  02133	0f 85 21 ff ff
	ff		 jne	 $L72904

; 3165 : 				++lp1;

  02139	83 c6 08	 add	 esi, 8
  0213c	3b f0		 cmp	 esi, eax
  0213e	0f 84 20 ff ff
	ff		 je	 $L73108

; 3164 : 			while (lp1!=rlp && lp1->l_ch=='-')

  02144	eb e9		 jmp	 SHORT $L72903
_ls_task_process_word ENDP
_phTTS$ = 8
_pLts_t$ = -4
_ls_task_lookup_first_verbs PROC NEAR

; 3202 : {

  02150	51		 push	 ecx

; 3203 : 	PLTS_T pLts_t;
; 3204 : 	PKSD_T pKsd_t;
; 3205 : 	LETTER *llp, *rlp, *elp;
; 3206 : 	int j,i;
; 3207 : 	pKsd_t = phTTS->pKernelShareData;
; 3208 : 	pLts_t = phTTS->pLTSThreadData;

  02151	8b 44 24 08	 mov	 eax, DWORD PTR _phTTS$[esp]
  02155	53		 push	 ebx
  02156	55		 push	 ebp
  02157	56		 push	 esi
  02158	8b 68 10	 mov	 ebp, DWORD PTR [eax+16]
  0215b	57		 push	 edi
  0215c	89 6c 24 10	 mov	 DWORD PTR _pLts_t$[esp+20], ebp

; 3209 : 	llp = &(pLts_t->cword[0]);

  02160	81 c5 14 09 00
	00		 add	 ebp, 2324		; 00000914H

; 3210 : 	
; 3211 : #if 0
; 3212 : 	for (i=0;i<6;i++)
; 3213 : 	{
; 3214 : 		WINprintf("%d %s %c%c %c%c %c%c %c%c %c%c\n",i,verbs[i].word,
; 3215 : 			pKsd_t->arpabet[(verbs[i].phone[0])<<1],pKsd_t->arpabet[((verbs[i].phone[0])<<1)+1],
; 3216 : 			pKsd_t->arpabet[(verbs[i].phone[1])<<1],pKsd_t->arpabet[((verbs[i].phone[1])<<1)+1],
; 3217 : 			pKsd_t->arpabet[(verbs[i].phone[2])<<1],pKsd_t->arpabet[((verbs[i].phone[2])<<1)+1],
; 3218 : 			pKsd_t->arpabet[(verbs[i].phone[3])<<1],pKsd_t->arpabet[((verbs[i].phone[3])<<1)+1],
; 3219 : 			pKsd_t->arpabet[(verbs[i].phone[4])<<1],pKsd_t->arpabet[((verbs[i].phone[4])<<1)+1]);
; 3220 : 	}
; 3221 : #endif
; 3222 : 	for (i=0;i<6;i++)

  02166	33 ff		 xor	 edi, edi
  02168	33 f6		 xor	 esi, esi
$L72921:

; 3223 : 	{
; 3224 : 		j=0;
; 3225 : 		elp=llp;
; 3226 : 		while (elp->l_ch !=EOS)

  0216a	66 8b 45 00	 mov	 ax, WORD PTR [ebp]
  0216e	33 d2		 xor	 edx, edx
  02170	66 85 c0	 test	 ax, ax
  02173	8b cd		 mov	 ecx, ebp
  02175	74 24		 je	 SHORT $L73119
$L72925:

; 3227 : 		{
; 3228 : 			if (verbs[i].word[j]!=ls_lower[elp->l_ch])

  02177	0f bf c0	 movsx	 eax, ax
  0217a	33 db		 xor	 ebx, ebx
  0217c	8a 98 00 00 00
	00		 mov	 bl, BYTE PTR _ls_lower[eax]
  02182	0f be 84 16 00
	00 00 00	 movsx	 eax, BYTE PTR _verbs[esi+edx]
  0218a	3b c3		 cmp	 eax, ebx
  0218c	75 0d		 jne	 SHORT $L73119
  0218e	66 8b 41 08	 mov	 ax, WORD PTR [ecx+8]

; 3229 : 			{
; 3230 : 				break;
; 3231 : 			}
; 3232 : 			j++;
; 3233 : 			elp++;

  02192	83 c1 08	 add	 ecx, 8
  02195	42		 inc	 edx
  02196	66 85 c0	 test	 ax, ax
  02199	75 dc		 jne	 SHORT $L72925
$L73119:

; 3234 : 		}
; 3235 : 		if (verbs[i].word[j]==ls_lower[elp->l_ch] && verbs[i].word[j]==0)

  0219b	0f bf 09	 movsx	 ecx, WORD PTR [ecx]
  0219e	8a 94 16 00 00
	00 00		 mov	 dl, BYTE PTR _verbs[esi+edx]
  021a5	33 c0		 xor	 eax, eax
  021a7	8a 81 00 00 00
	00		 mov	 al, BYTE PTR _ls_lower[ecx]
  021ad	0f be ca	 movsx	 ecx, dl
  021b0	3b c8		 cmp	 ecx, eax
  021b2	75 04		 jne	 SHORT $L72922
  021b4	84 d2		 test	 dl, dl
  021b6	74 14		 je	 SHORT $L73120
$L72922:

; 3210 : 	
; 3211 : #if 0
; 3212 : 	for (i=0;i<6;i++)
; 3213 : 	{
; 3214 : 		WINprintf("%d %s %c%c %c%c %c%c %c%c %c%c\n",i,verbs[i].word,
; 3215 : 			pKsd_t->arpabet[(verbs[i].phone[0])<<1],pKsd_t->arpabet[((verbs[i].phone[0])<<1)+1],
; 3216 : 			pKsd_t->arpabet[(verbs[i].phone[1])<<1],pKsd_t->arpabet[((verbs[i].phone[1])<<1)+1],
; 3217 : 			pKsd_t->arpabet[(verbs[i].phone[2])<<1],pKsd_t->arpabet[((verbs[i].phone[2])<<1)+1],
; 3218 : 			pKsd_t->arpabet[(verbs[i].phone[3])<<1],pKsd_t->arpabet[((verbs[i].phone[3])<<1)+1],
; 3219 : 			pKsd_t->arpabet[(verbs[i].phone[4])<<1],pKsd_t->arpabet[((verbs[i].phone[4])<<1)+1]);
; 3220 : 	}
; 3221 : #endif
; 3222 : 	for (i=0;i<6;i++)

  021b8	83 c6 20	 add	 esi, 32			; 00000020H
  021bb	47		 inc	 edi
  021bc	81 fe c0 00 00
	00		 cmp	 esi, 192		; 000000c0H
  021c2	7c a6		 jl	 SHORT $L72921
  021c4	5f		 pop	 edi
  021c5	5e		 pop	 esi
  021c6	5d		 pop	 ebp

; 3247 : 		}
; 3248 : 	}
; 3249 : 	return(KEEP_SEARCHING);

  021c7	33 c0		 xor	 eax, eax
  021c9	5b		 pop	 ebx

; 3250 : }

  021ca	59		 pop	 ecx
  021cb	c3		 ret	 0
$L73120:

; 3236 : 		{
; 3237 : 			pLts_t->fc_struct[1] = verbs[i].fc;

  021cc	8b 5c 24 10	 mov	 ebx, DWORD PTR _pLts_t$[esp+20]
  021d0	8b cf		 mov	 ecx, edi
  021d2	c1 e1 05	 shl	 ecx, 5

; 3238 : 			j=0;
; 3239 : 			while (verbs[i].phone[j]!=SIL)

  021d5	c1 e7 05	 shl	 edi, 5
  021d8	8b 91 1c 00 00
	00		 mov	 edx, DWORD PTR _verbs[ecx+28]
  021de	89 93 c0 04 00
	00		 mov	 DWORD PTR [ebx+1216], edx
  021e4	8b 87 08 00 00
	00		 mov	 eax, DWORD PTR _verbs[edi+8]
  021ea	85 c0		 test	 eax, eax
  021ec	74 1e		 je	 SHORT $L72931
  021ee	8b 7c 24 18	 mov	 edi, DWORD PTR _phTTS$[esp+16]
  021f2	8d b1 08 00 00
	00		 lea	 esi, DWORD PTR _verbs[ecx+8]
$L72930:

; 3240 : 			{
; 3241 : 				ls_util_send_phone(phTTS,verbs[i].phone[j]);

  021f8	50		 push	 eax
  021f9	57		 push	 edi
  021fa	e8 00 00 00 00	 call	 _ls_util_send_phone
  021ff	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 3242 : 				j++;

  02202	83 c6 04	 add	 esi, 4
  02205	83 c4 08	 add	 esp, 8
  02208	85 c0		 test	 eax, eax
  0220a	75 ec		 jne	 SHORT $L72930
$L72931:

; 3243 : 			}		
; 3244 : 			pLts_t->lbphone=WBOUND;

  0220c	b8 6f 00 00 00	 mov	 eax, 111		; 0000006fH
  02211	5f		 pop	 edi
  02212	5e		 pop	 esi
  02213	89 83 1c 11 00
	00		 mov	 DWORD PTR [ebx+4380], eax

; 3245 : 			pLts_t->rbphone=WBOUND;

  02219	89 83 20 11 00
	00		 mov	 DWORD PTR [ebx+4384], eax
  0221f	5d		 pop	 ebp

; 3246 : 			return(FINISHED_WORD);

  02220	b8 03 00 00 00	 mov	 eax, 3
  02225	5b		 pop	 ebx

; 3250 : }

  02226	59		 pop	 ecx
  02227	c3		 ret	 0
_ls_task_lookup_first_verbs ENDP
_TEXT	ENDS
END
