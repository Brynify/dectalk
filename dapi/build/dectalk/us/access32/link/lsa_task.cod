	TITLE	D:\work\Product\dapi\src\Lts\lsa_task.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_verbs
_DATA	SEGMENT
_verbs	DB	'are', 00H
	ORG $+1
	ORG $+3
	DD	066H
	DD	06H
	DD	01aH
	DD	00H
	DD	00H
	DD	0820020H
	DB	'had', 00H
	ORG $+1
	ORG $+3
	DD	01cH
	DD	066H
	DD	04H
	DD	030H
	DD	00H
	DD	0820100H
	DB	'is', 00H
	ORG $+2
	ORG $+3
	DD	066H
	DD	02H
	DD	02aH
	DD	00H
	DD	00H
	DD	0820020H
	DB	'was', 00H
	ORG $+1
	ORG $+3
	DD	018H
	DD	066H
	DD	011H
	DD	02aH
	DD	00H
	DD	0820020H
	DB	'were', 00H
	ORG $+3
	DD	018H
	DD	066H
	DD	0fH
	DD	00H
	DD	00H
	DD	0820020H
	DB	'will', 00H
	ORG $+3
	DD	018H
	DD	066H
	DD	02H
	DD	01eH
	DD	00H
	DD	0820408H
_DATA	ENDS
PUBLIC	_ls_task_main
PUBLIC	_ls_task_readword
PUBLIC	_ls_task_do_right_punct
PUBLIC	_ls_task_spell_word
PUBLIC	_ls_task_read_next_word
PUBLIC	_ls_task_set_what_state
PUBLIC	_ls_task_find_end_of_word
PUBLIC	_ls_task_spell_mode
PUBLIC	_ls_task_minidic_search
PUBLIC	_ls_task_math_mode
PUBLIC	_ls_task_dictionary_search
PUBLIC	_ls_task_strip_left_punctuation
PUBLIC	_ls_task_strip_right_punctuation
PUBLIC	_ls_task_spell_all_punct
PUBLIC	_ls_task_dictionary_after_punct
PUBLIC	_ls_task_spell_vs_speak
PUBLIC	_ls_task_single_letter_spell_rules
PUBLIC	_ls_task_remove_case
PUBLIC	_ls_task_Dr_St_process
PUBLIC	_ls_task_set_sign_flag
PUBLIC	_ls_task_currency_processing
PUBLIC	_ls_task_date_processing
PUBLIC	_ls_task_frac_processing
PUBLIC	_ls_task_plain_number_processing
PUBLIC	_ls_task_part_number
PUBLIC	_ls_task_process_word
EXTRN	_ls_util_is_name:NEAR
EXTRN	_ls_rule_phone_free:NEAR
EXTRN	__chkstk:NEAR
EXTRN	_ls_util_read_item:NEAR
EXTRN	__imp__printf:NEAR
EXTRN	_ls_util_dump_cword:NEAR
_DATA	SEGMENT
$SG72360 DB	'LTS debug switch description:', 0aH, 00H
	ORG $+1
$SG72361 DB	'4001 -- Incoming data string  4002 -- Dictionary HIT/MIS'
	DB	'S (0) for miss', 0aH, 00H
$SG72362 DB	'4004 -- Suffix stripping HIT  4008 -- Display MISS word,'
	DB	' not speaking', 0aH, 00H
	ORG $+1
$SG72363 DB	'4010 -- Dict. search trace    4020 -- Homograph rule HIT'
	DB	0aH, 00H
	ORG $+2
$SG72364 DB	'4040 -- Form class array dump 4080 -- ACNA name type', 0aH
	DB	00H
	ORG $+2
$SG72365 DB	'4100 -- log form class        4200 -- dump data before w'
	DB	'rite_pipe', 0aH, 00H
	ORG $+1
$SG72366 DB	'4400 -- Spell it rule HIT     4800 -- drain data before '
	DB	'write_pipe', 0aH, 00H
$SG72368 DB	'LTS Input:', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = -4888
_rlp$ = -4892
_elp$ = -4868
_lp1$ = -4876
_pKsd_t$ = -4872
_pLts_t$ = -4880
_pnode$ = -4608
_origword$ = -4864
_namef$ = -4884
_ls_task_main PROC NEAR

; 252  : {

  00000	b8 1c 13 00 00	 mov	 eax, 4892		; 0000131cH
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	53		 push	 ebx

; 253  : 	/* of special words.*/ 
; 254  : 	int     done; // array_i=0;
; 255  : 	LETTER  *llp;
; 256  : 	LETTER  *rlp;
; 257  : 	LETTER  *elp;
; 258  : 	LETTER  *lp1;
; 259  : 	PHONE   *pp; 
; 260  : 	PKSD_T  pKsd_t;
; 261  : 	PLTS_T  pLts_t;
; 262  : 	PHONE   pnode[NPNODE];                  /* Phoneme pool.                */
; 263  : 	/* MGS 6/16/97 BATS #387 Added to allow case to reach ls_task_process_word */
; 264  : 	LETTER	origword[NGWORD];	
; 265  : #ifdef FRENCH
; 266  : //	char  c;       /* for current char of cword */
; 267  : //	int   Fini=0;  /* de 0 à 4 : end of cword analysis */
; 268  : //	int   rbphone; /* phone due to right striping */
; 269  : //	int   sign;    /* sign if number */
; 270  : //	int   lflag;   /* attributes of cword : LSTRIP, RSTRIP, etc */
; 271  : //	int   speed;   /* speed when spelled */
; 272  : //	int   TypDic;  /* dico result */
; 273  : //	short wstate;  /* "Which" state : quoi, qui */
; 274  : //	FLAG  contgc;  /* current word is left context for next word */
; 275  : #endif
; 276  : 	int namef=0; 							/* this flag seems useless */ 
; 277  : 	
; 278  : 	/* printf("this is the start of lts\n"); */
; 279  : 	
; 280  : 		
; 281  : 	pKsd_t = phTTS->pKernelShareData;

  0000b	8b 9c 24 24 13
	00 00		 mov	 ebx, DWORD PTR _phTTS$[esp+4892]
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00017	57		 push	 edi

; 282  : 	pLts_t = phTTS->pLTSThreadData;	

  00018	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  0001b	33 f6		 xor	 esi, esi

; 283  : 	pLts_t->isnumabr=0;
; 284  : 
; 285  :     pLts_t->pflp = 0;   
; 286  : #ifdef MSDOS
; 287  : 	pKsd_t->lang_curr = LANG_none; 
; 288  : #endif
; 289  : #ifdef SPANISH
; 290  :     pLts_t->got_quote = 0;
; 291  : #endif  
; 292  :     memset(&(pLts_t->nitem),0,sizeof(ITEM));

  0001d	33 c9		 xor	 ecx, ecx
  0001f	89 44 24 24	 mov	 DWORD PTR _pKsd_t$[esp+4908], eax
  00023	8d 97 0a 09 00
	00		 lea	 edx, DWORD PTR [edi+2314]
  00029	89 b7 fc 08 00
	00		 mov	 DWORD PTR [edi+2300], esi
  0002f	89 b7 04 04 00
	00		 mov	 DWORD PTR [edi+1028], esi

; 293  :     memset(&(pLts_t->citem),0,sizeof(ITEM));

  00035	33 c0		 xor	 eax, eax
  00037	89 0a		 mov	 DWORD PTR [edx], ecx
  00039	89 74 24 18	 mov	 DWORD PTR _namef$[esp+4908], esi
  0003d	89 7c 24 1c	 mov	 DWORD PTR _pLts_t$[esp+4908], edi

; 294  : 	
; 295  : 	pp = &pnode[0];                         		/* Pool of PHONE nodes. */

  00041	8d ac 24 2c 01
	00 00		 lea	 ebp, DWORD PTR _pnode$[esp+4908]
  00048	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0004b	66 89 4a 08	 mov	 WORD PTR [edx+8], cx
  0004f	8d 8f 00 09 00
	00		 lea	 ecx, DWORD PTR [edi+2304]
  00055	89 87 00 09 00
	00		 mov	 DWORD PTR [edi+2304], eax
  0005b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0005e	66 89 41 08	 mov	 WORD PTR [ecx+8], ax
$L72354:

; 296  : 	
; 297  : 	while (pp < &pnode[NPNODE])         			/* free all the phonemes */
; 298  : 	{
; 299  : 		ls_rule_phone_free(pLts_t,pp);

  00062	55		 push	 ebp
  00063	57		 push	 edi
  00064	e8 00 00 00 00	 call	 _ls_rule_phone_free

; 300  : 		++pp;

  00069	83 c5 24	 add	 ebp, 36			; 00000024H
  0006c	8d 94 24 34 13
	00 00		 lea	 edx, DWORD PTR _pnode$[esp+9524]
  00073	83 c4 08	 add	 esp, 8
  00076	3b ea		 cmp	 ebp, edx
  00078	72 e8		 jb	 SHORT $L72354

; 301  : 	}
; 302  : 	
; 303  : 	pLts_t->wstate = UNK_WH;                        /* Start of sentence.   */
; 304  : 	pLts_t->lphone = WBOUND;                        /* Out of band.         */
; 305  : #ifdef FRENCH
; 306  : 	strcpy(pLts_t->precedent, "");
; 307  : 	pLts_t->nitem.i_nword = 0; /* nothing in nitem */
; 308  : #endif
; 309  : 	ls_util_read_item(phTTS);	

  0007a	53		 push	 ebx
  0007b	66 89 b7 c4 08
	00 00		 mov	 WORD PTR [edi+2244], si
  00082	66 c7 87 36 04
	00 00 6f 00	 mov	 WORD PTR [edi+1078], 111 ; 0000006fH
  0008b	e8 00 00 00 00	 call	 _ls_util_read_item

; 310  : 	ls_task_readword(phTTS,&(pLts_t->cword[0]));	

  00090	8d 87 14 09 00
	00		 lea	 eax, DWORD PTR [edi+2324]
  00096	50		 push	 eax
  00097	53		 push	 ebx
  00098	e8 00 00 00 00	 call	 _ls_task_readword

; 385  : 			{
; 386  : 				namef=0;
; 387  : 				/*clear pron name even if we did it with the dic*/
; 388  : 				pKsd_t->pronflag &= (~PRON_ACNA_NAME);

  0009d	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__printf
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a6	89 b7 bc 08 00
	00		 mov	 DWORD PTR [edi+2236], esi
  000ac	c7 87 c0 08 00
	00 ff ff ff ff	 mov	 DWORD PTR [edi+2240], -1
$L72357:
  000b6	8b 74 24 24	 mov	 esi, DWORD PTR _pKsd_t$[esp+4908]
  000ba	66 81 be 40 06
	00 00 ff 4f	 cmp	 WORD PTR [esi+1600], 20479 ; 00004fffH
  000c3	75 3d		 jne	 SHORT $L72359
  000c5	68 00 00 00 00	 push	 OFFSET FLAT:$SG72360
  000ca	ff d5		 call	 ebp
  000cc	68 00 00 00 00	 push	 OFFSET FLAT:$SG72361
  000d1	ff d5		 call	 ebp
  000d3	68 00 00 00 00	 push	 OFFSET FLAT:$SG72362
  000d8	ff d5		 call	 ebp
  000da	68 00 00 00 00	 push	 OFFSET FLAT:$SG72363
  000df	ff d5		 call	 ebp
  000e1	68 00 00 00 00	 push	 OFFSET FLAT:$SG72364
  000e6	ff d5		 call	 ebp
  000e8	68 00 00 00 00	 push	 OFFSET FLAT:$SG72365
  000ed	ff d5		 call	 ebp
  000ef	68 00 00 00 00	 push	 OFFSET FLAT:$SG72366
  000f4	ff d5		 call	 ebp
  000f6	83 c4 1c	 add	 esp, 28			; 0000001cH
  000f9	66 c7 86 40 06
	00 00 00 00	 mov	 WORD PTR [esi+1600], 0
$L72359:
  00102	66 8b 86 40 06
	00 00		 mov	 ax, WORD PTR [esi+1600]
  00109	f6 c4 40	 test	 ah, 64			; 00000040H
  0010c	74 18		 je	 SHORT $L72367

; 311  : 	pLts_t->fc_index = 0;
; 312  : 	pLts_t->old_fc_index = -1;
; 313  : 	/*
; 314  : 	 * Top of the word processing main loop.
; 315  : 	 * Called with a word in "cword" and the delimiter in
; 316  : 	 * "pLts_t->citem". Look at the word, and update the "which" state
; 317  : 	 * if this is the first word in a sentence. Allow the
; 318  : 	 * "W" to be in either case. Don't get fooled by
; 319  : 	 * strippable punctuation.
; 320  : 	 */
; 321  : 
; 322  : 	while (1)
; 323  : 	{
; 324  : 
; 325  : 		/* ET 6/9/1998: BATS #691
; 326  : 		copied from ...\dapi\src\CMD\cm_pars.c to get the debug win to come up */
; 327  : #if defined (WIN32) && defined (PRINTFDEBUG)
; 328  : 		/* open debug window for window environement */
; 329  : 		if (/*(windbg_flag == 0) && ET 6/9/1998*/(Thread_Alive == 0) && (in_winmain==0) && (pKsd_t->debug_switch != 0 || pKsd_t->logflag != 0))
; 330  : 		{
; 331  : 			WINstart_thread();
; 332  : 		/*	windbg_flag = 1;	ET 6/9/1998: not defined in ls_task. */ 
; 333  : 		}
; 334  : #endif
; 335  : #ifdef FRENCH
; 336  : 		pLts_t->contgc = FALSE; //default is false
; 337  : #endif
; 338  : 		/* display debug switch manual once */
; 339  : 		if (pKsd_t->debug_switch == 0x4fff)
; 340  : 		{
; 341  : 			printf("LTS debug switch description:\n");
; 342  : 			printf("4001 -- Incoming data string  4002 -- Dictionary HIT/MISS (0) for miss\n");
; 343  : 			printf("4004 -- Suffix stripping HIT  4008 -- Display MISS word, not speaking\n");
; 344  : 			printf("4010 -- Dict. search trace    4020 -- Homograph rule HIT\n");
; 345  : 			printf("4040 -- Form class array dump 4080 -- ACNA name type\n");
; 346  : 			printf("4100 -- log form class        4200 -- dump data before write_pipe\n");
; 347  : 			printf("4400 -- Spell it rule HIT     4800 -- drain data before write_pipe\n");
; 348  : 						
; 349  : 			/* reset to 0 again */
; 350  : 			pKsd_t->debug_switch = 0;
; 351  : 		}
; 352  : 	
; 353  : 		/* debug switch */
; 354  : 		if (DT_DBG(LTS_DBG,0x001))

  0010e	a8 01		 test	 al, 1
  00110	74 14		 je	 SHORT $L72367

; 355  : 		{
; 356  : 			ls_util_dump_cword (pLts_t->cword, "LTS Input:");

  00112	8d 87 14 09 00
	00		 lea	 eax, DWORD PTR [edi+2324]
  00118	68 00 00 00 00	 push	 OFFSET FLAT:$SG72368
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 _ls_util_dump_cword
  00123	83 c4 08	 add	 esp, 8
$L72367:

; 357  : 		}
; 358  : #ifdef DUMP_WORD
; 359  : 		ls_util_dump_cword (pLts_t->cword, "ltsinput:");
; 360  : #endif
; 361  : 		done=KEEP_SEARCHING;
; 362  : 		/* 
; 363  : 		 *...tek block here to make sure PH has something to do and that
; 364  : 		 *	we don't hog the CPU.. 
; 365  : 		 */
; 366  : #ifdef MSDOS
; 367  : 		block(NULL_FP);
; 368  : #endif    
; 369  : 		/* 
; 370  : 		 * xxxx eab WE added code to allow for double abreviations such as
; 371  : 		 *	4 sq. ft. but we need to block these abbreviations in normal
; 372  : 		 *	contexts so things like in and ha don't come out as hectors
; 373  : 		 *	and inches. so The 2nd abrreviation checker (nabtab)
; 374  : 		 *	is blocked unless the first time after a look ahead from
; 375  : 		 *	a number hit in the first case using the pLts_t->isnumabr being
; 376  : 		 *	set
; 377  : 		 */
; 378  : 
; 379  : 		if(pLts_t->isnumabr)

  00126	8b 87 fc 08 00
	00		 mov	 eax, DWORD PTR [edi+2300]
  0012c	33 c9		 xor	 ecx, ecx
  0012e	3b c1		 cmp	 eax, ecx
  00130	74 07		 je	 SHORT $L72369

; 380  : 			pLts_t->isnumabr--;

  00132	48		 dec	 eax
  00133	89 87 fc 08 00
	00		 mov	 DWORD PTR [edi+2300], eax
$L72369:

; 381  : 
; 382  : 		if( (pKsd_t->pronflag & PRON_ACNA_NAME) !=0)

  00139	8b 86 cc 03 00
	00		 mov	 eax, DWORD PTR [esi+972]
  0013f	a8 04		 test	 al, 4
  00141	74 1b		 je	 SHORT $L72370

; 383  : 		{
; 384  : 			if(namef == 1)

  00143	83 7c 24 18 01	 cmp	 DWORD PTR _namef$[esp+4908], 1
  00148	75 0e		 jne	 SHORT $L72371

; 385  : 			{
; 386  : 				namef=0;
; 387  : 				/*clear pron name even if we did it with the dic*/
; 388  : 				pKsd_t->pronflag &= (~PRON_ACNA_NAME);

  0014a	24 fb		 and	 al, -5			; fffffffbH
  0014c	89 4c 24 18	 mov	 DWORD PTR _namef$[esp+4908], ecx
  00150	89 86 cc 03 00
	00		 mov	 DWORD PTR [esi+972], eax

; 389  : 			}
; 390  : 			else

  00156	eb 0a		 jmp	 SHORT $L72373
$L72371:

; 391  : 			{
; 392  : 				namef++;

  00158	ff 44 24 18	 inc	 DWORD PTR _namef$[esp+4908]

; 393  : 			}
; 394  : 		}
; 395  : 		else

  0015c	eb 04		 jmp	 SHORT $L72373
$L72370:

; 396  : 		{
; 397  : 			namef=0;

  0015e	89 4c 24 18	 mov	 DWORD PTR _namef$[esp+4908], ecx
$L72373:

; 398  : 		}
; 399  : 	
; 400  : 		/* find out if one of the what words are at the beginning of the clause */
; 401  : 		done=ls_task_set_what_state(phTTS,pLts_t);

  00162	57		 push	 edi
  00163	53		 push	 ebx
  00164	e8 00 00 00 00	 call	 _ls_task_set_what_state
  00169	83 c4 08	 add	 esp, 8

; 402  : 
; 403  : 		if (!done)

  0016c	85 c0		 test	 eax, eax
  0016e	0f 85 5e 02 00
	00		 jne	 $L72398

; 404  : 		{
; 405  : 			/* find the end of the word */
; 406  : 			llp = &(pLts_t->cword[0]);

  00174	8d b7 14 09 00
	00		 lea	 esi, DWORD PTR [edi+2324]

; 407  : 			ls_task_find_end_of_word(llp,&rlp,&elp);

  0017a	8d 4c 24 28	 lea	 ecx, DWORD PTR _elp$[esp+4908]
  0017e	8d 54 24 10	 lea	 edx, DWORD PTR _rlp$[esp+4908]
  00182	8b c6		 mov	 eax, esi
  00184	51		 push	 ecx
  00185	52		 push	 edx
  00186	50		 push	 eax
  00187	89 44 24 20	 mov	 DWORD PTR _llp$[esp+4920], eax
  0018b	e8 00 00 00 00	 call	 _ls_task_find_end_of_word

; 408  : 
; 409  : #ifdef LS1DEBUG
; 410  : 			printf("after find end of word ");
; 411  : 			printf("left=%u  right=%u\n",llp,rlp);
; 412  : #endif
; 413  : 			/*
; 414  : 			 * Bow out quickly on null words.
; 415  : 			 * These happen when you type something like
; 416  : 			 * "[ax] there.". The schwa gets copied right into
; 417  : 			 * the output, and the current word is null.
; 418  : 			 */
; 419  : 			if (llp == rlp) 

  00190	8b 44 24 20	 mov	 eax, DWORD PTR _llp$[esp+4920]
  00194	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rlp$[esp+4920]
  00198	83 c4 0c	 add	 esp, 12			; 0000000cH
  0019b	3b c1		 cmp	 eax, ecx
  0019d	75 2c		 jne	 SHORT $L73104

; 420  : 			{
; 421  : 				ls_task_do_right_punct(phTTS,MISS);

  0019f	6a 00		 push	 0
  001a1	53		 push	 ebx
  001a2	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 422  : 				ls_task_readword(phTTS,&(pLts_t->cword[0]));

  001a7	56		 push	 esi
  001a8	53		 push	 ebx
  001a9	e8 00 00 00 00	 call	 _ls_task_readword

; 423  : 				// add 1 to isnumabr to restore the value from before the null word
; 424  : 				// another fix for 43 sq. ft. with multiple index marks
; 425  : 				if (pLts_t->isnumabr)

  001ae	8b 87 fc 08 00
	00		 mov	 eax, DWORD PTR [edi+2300]
  001b4	83 c4 10	 add	 esp, 16			; 00000010H
  001b7	85 c0		 test	 eax, eax
  001b9	0f 84 f7 fe ff
	ff		 je	 $L72357

; 426  : 				{
; 427  : 					pLts_t->isnumabr++;

  001bf	40		 inc	 eax
  001c0	89 87 fc 08 00
	00		 mov	 DWORD PTR [edi+2300], eax

; 428  : 				}
; 429  : 				continue;

  001c6	e9 eb fe ff ff	 jmp	 $L72357
$L73104:

; 430  : 			}
; 431  : 		}
; 432  : 		if (!done) 
; 433  : 			done=ls_task_spell_mode(phTTS,llp,rlp);

  001cb	51		 push	 ecx
  001cc	50		 push	 eax
  001cd	53		 push	 ebx
  001ce	e8 00 00 00 00	 call	 _ls_task_spell_mode
  001d3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 434  : 		
; 435  : 		if (!done) 

  001d6	85 c0		 test	 eax, eax
  001d8	0f 85 f4 01 00
	00		 jne	 $L72398

; 436  : 			done=ls_task_minidic_search(phTTS,llp,rlp); 

  001de	8b 44 24 10	 mov	 eax, DWORD PTR _rlp$[esp+4908]
  001e2	8b 4c 24 14	 mov	 ecx, DWORD PTR _llp$[esp+4908]
  001e6	50		 push	 eax
  001e7	51		 push	 ecx
  001e8	53		 push	 ebx
  001e9	e8 00 00 00 00	 call	 _ls_task_minidic_search
  001ee	83 c4 0c	 add	 esp, 12			; 0000000cH

; 437  : 		
; 438  : 		if (!done) 

  001f1	85 c0		 test	 eax, eax
  001f3	0f 85 d9 01 00
	00		 jne	 $L72398

; 439  : 			done=ls_task_math_mode(pKsd_t,llp,rlp);

  001f9	8b 54 24 10	 mov	 edx, DWORD PTR _rlp$[esp+4908]
  001fd	8b 44 24 14	 mov	 eax, DWORD PTR _llp$[esp+4908]
  00201	8b 4c 24 24	 mov	 ecx, DWORD PTR _pKsd_t$[esp+4908]
  00205	52		 push	 edx
  00206	50		 push	 eax
  00207	51		 push	 ecx
  00208	e8 00 00 00 00	 call	 _ls_task_math_mode
  0020d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 440  : 		
; 441  : 		if (!done) 	

  00210	85 c0		 test	 eax, eax
  00212	0f 85 ba 01 00
	00		 jne	 $L72398

; 442  : 			done = ls_task_dictionary_search(phTTS,llp,rlp);

  00218	8b 54 24 10	 mov	 edx, DWORD PTR _rlp$[esp+4908]
  0021c	8b 44 24 14	 mov	 eax, DWORD PTR _llp$[esp+4908]
  00220	52		 push	 edx
  00221	50		 push	 eax
  00222	53		 push	 ebx
  00223	e8 00 00 00 00	 call	 _ls_task_dictionary_search
  00228	83 c4 0c	 add	 esp, 12			; 0000000cH

; 443  : 
; 444  : #ifdef GERMAN
; 445  : 		if (!done)
; 446  : 		{
; 447  : 			if (ls_task_fix_german_vowels(pLts_t,llp,&rlp))
; 448  : 			{
; 449  : 				done=ls_task_dictionary_search(phTTS,llp,rlp);
; 450  : 			}
; 451  : 		}
; 452  : #endif
; 453  : 
; 454  : 
; 455  : #if 0 //comment out for now breaks in Windows CE mfg 03/21/2000
; 456  : 		if (!done)
; 457  : 		{
; 458  : 			done=ls_task_dictionary_search(phTTS,llp,rlp);
; 459  : 			//eab 10/5/99 if we messed with prefix fix up pointers 
; 460  : 			if (done <0)
; 461  : 			{
; 462  : 				while(done <0)
; 463  : 				{
; 464  : 					rlp --;
; 465  : 					done++;
; 466  : 				}
; 467  : #ifdef _DEBUG 
; 468  : #ifndef UNDER_CE
; 469  : 			printf("hit it \n");
; 470  : #endif
; 471  : #endif // _DEBUG
; 472  : 			//eab what if prefix-looks like another prefix imim should be ok
; 473  : 			done=ls_task_dictionary_search(phTTS,llp,rlp);
; 474  : 			}
; 475  : 		}
; 476  : #endif // 0
; 477  : 
; 478  : 		if (!done)

  0022b	85 c0		 test	 eax, eax
  0022d	0f 85 9f 01 00
	00		 jne	 $L72398

; 479  : 			ls_task_strip_left_punctuation(pLts_t,&llp,rlp);        

  00233	8b 4c 24 10	 mov	 ecx, DWORD PTR _rlp$[esp+4908]
  00237	8d 54 24 14	 lea	 edx, DWORD PTR _llp$[esp+4908]
  0023b	51		 push	 ecx
  0023c	52		 push	 edx
  0023d	57		 push	 edi
  0023e	e8 00 00 00 00	 call	 _ls_task_strip_left_punctuation

; 480  : 
; 481  : 		if (!done)
; 482  : 			ls_task_strip_right_punctuation(pLts_t,llp,&rlp);

  00243	8b 4c 24 20	 mov	 ecx, DWORD PTR _llp$[esp+4920]
  00247	8d 44 24 1c	 lea	 eax, DWORD PTR _rlp$[esp+4920]
  0024b	50		 push	 eax
  0024c	51		 push	 ecx
  0024d	57		 push	 edi
  0024e	e8 00 00 00 00	 call	 _ls_task_strip_right_punctuation

; 483  : 
; 484  : 		if (!done)
; 485  : 			done=ls_task_spell_all_punct(phTTS,llp,rlp,&(pLts_t->cword[0]),elp);

  00253	8b 54 24 40	 mov	 edx, DWORD PTR _elp$[esp+4932]
  00257	8b 44 24 28	 mov	 eax, DWORD PTR _rlp$[esp+4932]
  0025b	8b 4c 24 2c	 mov	 ecx, DWORD PTR _llp$[esp+4932]
  0025f	52		 push	 edx
  00260	56		 push	 esi
  00261	50		 push	 eax
  00262	51		 push	 ecx
  00263	53		 push	 ebx
  00264	e8 00 00 00 00	 call	 _ls_task_spell_all_punct
  00269	83 c4 2c	 add	 esp, 44			; 0000002cH

; 486  : 	
; 487  : 		if (!done)

  0026c	85 c0		 test	 eax, eax
  0026e	0f 85 5e 01 00
	00		 jne	 $L72398

; 488  : 			done=ls_task_dictionary_after_punct(phTTS,llp,&rlp);

  00274	8b 44 24 14	 mov	 eax, DWORD PTR _llp$[esp+4908]
  00278	8d 54 24 10	 lea	 edx, DWORD PTR _rlp$[esp+4908]
  0027c	52		 push	 edx
  0027d	50		 push	 eax
  0027e	53		 push	 ebx
  0027f	e8 00 00 00 00	 call	 _ls_task_dictionary_after_punct
  00284	83 c4 0c	 add	 esp, 12			; 0000000cH

; 489  : 
; 490  : 		if (!done)

  00287	85 c0		 test	 eax, eax
  00289	0f 85 43 01 00
	00		 jne	 $L72398

; 491  : 			done=ls_task_spell_vs_speak(phTTS,llp,rlp);

  0028f	8b 4c 24 10	 mov	 ecx, DWORD PTR _rlp$[esp+4908]
  00293	8b 54 24 14	 mov	 edx, DWORD PTR _llp$[esp+4908]
  00297	51		 push	 ecx
  00298	52		 push	 edx
  00299	53		 push	 ebx
  0029a	e8 00 00 00 00	 call	 _ls_task_spell_vs_speak
  0029f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 492  : 
; 493  : 		if (!done)

  002a2	85 c0		 test	 eax, eax
  002a4	0f 85 28 01 00
	00		 jne	 $L72398

; 494  : 			done=ls_task_single_letter_spell_rules(phTTS,llp,rlp);

  002aa	8b 44 24 10	 mov	 eax, DWORD PTR _rlp$[esp+4908]
  002ae	8b 4c 24 14	 mov	 ecx, DWORD PTR _llp$[esp+4908]
  002b2	50		 push	 eax
  002b3	51		 push	 ecx
  002b4	53		 push	 ebx
  002b5	e8 00 00 00 00	 call	 _ls_task_single_letter_spell_rules
  002ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 495  : 
; 496  : 		/*
; 497  : 		 * We are getting ready to feed this
; 498  : 		 * thing to the default processing rules. The
; 499  : 		 * first step is to fold out case distinctions and
; 500  : 		 * diacritical marks. We used to rescan the dictionary
; 501  : 		 * if anything changed; we don't do it anymore because
; 502  : 		 * the dictionary lookup was made more clever, and
; 503  : 		 * understands case distinctions.
; 504  : 		 */
; 505  : 		if (!done) 

  002bd	85 c0		 test	 eax, eax
  002bf	0f 85 0d 01 00
	00		 jne	 $L72398

; 506  : 			ls_util_is_name(phTTS,llp,rlp);

  002c5	8b 54 24 10	 mov	 edx, DWORD PTR _rlp$[esp+4908]
  002c9	8b 44 24 14	 mov	 eax, DWORD PTR _llp$[esp+4908]
  002cd	52		 push	 edx
  002ce	50		 push	 eax
  002cf	53		 push	 ebx
  002d0	e8 00 00 00 00	 call	 _ls_util_is_name

; 507  : 		
; 508  : 		/* MGS 6/16/97 BATS #387  added to keep oroginal word */
; 509  : 		if (!done) 
; 510  : 			memcpy(&origword,&(pLts_t->cword),sizeof(origword));
; 511  : 		
; 512  : 		if (!done) 
; 513  : 			ls_task_remove_case(llp,rlp);

  002d5	8b 54 24 20	 mov	 edx, DWORD PTR _llp$[esp+4920]
  002d9	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002de	8d 7c 24 38	 lea	 edi, DWORD PTR _origword$[esp+4920]
  002e2	f3 a5		 rep movsd
  002e4	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rlp$[esp+4920]
  002e8	51		 push	 ecx
  002e9	52		 push	 edx
  002ea	e8 00 00 00 00	 call	 _ls_task_remove_case

; 514  : 
; 515  : #ifdef ENGLISH
; 516  : 		if (!done) 
; 517  : 			done=ls_task_Dr_St_process(phTTS,llp,rlp);

  002ef	8b 44 24 24	 mov	 eax, DWORD PTR _rlp$[esp+4928]
  002f3	8b 4c 24 28	 mov	 ecx, DWORD PTR _llp$[esp+4928]
  002f7	50		 push	 eax
  002f8	51		 push	 ecx
  002f9	53		 push	 ebx
  002fa	e8 00 00 00 00	 call	 _ls_task_Dr_St_process
  002ff	83 c4 20	 add	 esp, 32			; 00000020H

; 518  : #endif
; 519  : 		
; 520  : 		if (!done) 

  00302	85 c0		 test	 eax, eax
  00304	0f 85 c4 00 00
	00		 jne	 $L73111

; 521  : 			done=ls_task_set_sign_flag(phTTS,llp,rlp,&lp1);

  0030a	8b 44 24 10	 mov	 eax, DWORD PTR _rlp$[esp+4908]
  0030e	8b 4c 24 14	 mov	 ecx, DWORD PTR _llp$[esp+4908]
  00312	8d 54 24 20	 lea	 edx, DWORD PTR _lp1$[esp+4908]
  00316	52		 push	 edx
  00317	50		 push	 eax
  00318	51		 push	 ecx
  00319	53		 push	 ebx
  0031a	e8 00 00 00 00	 call	 _ls_task_set_sign_flag
  0031f	83 c4 10	 add	 esp, 16			; 00000010H

; 522  : 
; 523  : #ifndef FRENCH
; 524  : 		if (!done) 

  00322	85 c0		 test	 eax, eax
  00324	0f 85 a4 00 00
	00		 jne	 $L73111

; 525  : 			done=ls_task_currency_processing(phTTS,lp1,rlp);

  0032a	8b 54 24 10	 mov	 edx, DWORD PTR _rlp$[esp+4908]
  0032e	8b 44 24 20	 mov	 eax, DWORD PTR _lp1$[esp+4908]
  00332	52		 push	 edx
  00333	50		 push	 eax
  00334	53		 push	 ebx
  00335	e8 00 00 00 00	 call	 _ls_task_currency_processing
  0033a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 526  : #endif
; 527  : 
; 528  : #ifdef FRENCH
; 529  : 		if (!done) 
; 530  : 			done=ls_task_currency_processing(phTTS, llp, lp1, rlp);
; 531  : #endif
; 532  : 		if (!done) 

  0033d	85 c0		 test	 eax, eax
  0033f	0f 85 89 00 00
	00		 jne	 $L73111

; 533  : 			done=ls_task_date_processing(phTTS,llp,rlp);

  00345	8b 4c 24 10	 mov	 ecx, DWORD PTR _rlp$[esp+4908]
  00349	8b 54 24 14	 mov	 edx, DWORD PTR _llp$[esp+4908]
  0034d	51		 push	 ecx
  0034e	52		 push	 edx
  0034f	53		 push	 ebx
  00350	e8 00 00 00 00	 call	 _ls_task_date_processing
  00355	83 c4 0c	 add	 esp, 12			; 0000000cH

; 534  : 		
; 535  : 		if (!done) 

  00358	85 c0		 test	 eax, eax
  0035a	75 72		 jne	 SHORT $L73111

; 536  : 			done=ls_task_frac_processing(phTTS,lp1,rlp);

  0035c	8b 44 24 10	 mov	 eax, DWORD PTR _rlp$[esp+4908]
  00360	8b 4c 24 20	 mov	 ecx, DWORD PTR _lp1$[esp+4908]
  00364	50		 push	 eax
  00365	51		 push	 ecx
  00366	53		 push	 ebx
  00367	e8 00 00 00 00	 call	 _ls_task_frac_processing
  0036c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 537  : 		
; 538  : 		if (!done) 	

  0036f	85 c0		 test	 eax, eax
  00371	75 5b		 jne	 SHORT $L73111

; 539  : 			done=ls_task_plain_number_processing(phTTS,llp,rlp,lp1);

  00373	8b 54 24 20	 mov	 edx, DWORD PTR _lp1$[esp+4908]
  00377	8b 44 24 10	 mov	 eax, DWORD PTR _rlp$[esp+4908]
  0037b	8b 4c 24 14	 mov	 ecx, DWORD PTR _llp$[esp+4908]
  0037f	52		 push	 edx
  00380	50		 push	 eax
  00381	51		 push	 ecx
  00382	53		 push	 ebx
  00383	e8 00 00 00 00	 call	 _ls_task_plain_number_processing
  00388	83 c4 10	 add	 esp, 16			; 00000010H

; 540  : 
; 541  : 		/*	
; 542  : 		 * Well, all of the fancy heuristics have
; 543  : 		 * failed. Either this is just an ordinary word, or it
; 544  : 		 * is garbage. This first scan looks for things that might
; 545  : 		 * actually be part numbers, and runs the standard part
; 546  : 		 * number rules.
; 547  : 		 */
; 548  : 
; 549  : 		/* MGS 6/16/97 BATS #387  added to restore oroginal word */
; 550  : 		if (!done) 

  0038b	85 c0		 test	 eax, eax
  0038d	75 3f		 jne	 SHORT $L73111

; 551  : 			memcpy(&(pLts_t->cword),&origword,sizeof(origword));

  0038f	8b 54 24 1c	 mov	 edx, DWORD PTR _pLts_t$[esp+4908]
  00393	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00398	8d 74 24 2c	 lea	 esi, DWORD PTR _origword$[esp+4908]
  0039c	8d ba 14 09 00
	00		 lea	 edi, DWORD PTR [edx+2324]
  003a2	f3 a5		 rep movsd

; 552  : 		
; 553  : 		if (!done) 
; 554  : 			done=ls_task_part_number(phTTS,llp,rlp);

  003a4	8b 44 24 10	 mov	 eax, DWORD PTR _rlp$[esp+4908]
  003a8	8b 4c 24 14	 mov	 ecx, DWORD PTR _llp$[esp+4908]
  003ac	50		 push	 eax
  003ad	51		 push	 ecx
  003ae	53		 push	 ebx
  003af	e8 00 00 00 00	 call	 _ls_task_part_number
  003b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 555  : 	
; 556  : 		
; 557  : 		if (!done) 

  003b7	85 c0		 test	 eax, eax
  003b9	75 13		 jne	 SHORT $L73111

; 558  : 			done=ls_task_process_word(phTTS,llp,rlp);

  003bb	8b 54 24 10	 mov	 edx, DWORD PTR _rlp$[esp+4908]
  003bf	8b 44 24 14	 mov	 eax, DWORD PTR _llp$[esp+4908]
  003c3	52		 push	 edx
  003c4	50		 push	 eax
  003c5	53		 push	 ebx
  003c6	e8 00 00 00 00	 call	 _ls_task_process_word
  003cb	83 c4 0c	 add	 esp, 12			; 0000000cH
$L73111:
  003ce	8b 7c 24 1c	 mov	 edi, DWORD PTR _pLts_t$[esp+4908]
$L72398:

; 559  : #ifndef FRENCH
; 560  : 		switch (done)
; 561  : 		{

  003d2	48		 dec	 eax
  003d3	0f 84 dd fc ff
	ff		 je	 $L72357
  003d9	48		 dec	 eax
  003da	74 15		 je	 SHORT $L72404
  003dc	48		 dec	 eax
  003dd	0f 85 d3 fc ff
	ff		 jne	 $L72357

; 566  : 				break;
; 567  : 			case FINISHED_WORD:
; 568  : 				ls_task_read_next_word(phTTS);

  003e3	53		 push	 ebx
  003e4	e8 00 00 00 00	 call	 _ls_task_read_next_word
  003e9	83 c4 04	 add	 esp, 4

; 569  : 				break;

  003ec	e9 c5 fc ff ff	 jmp	 $L72357
$L72404:

; 562  : 			case LS_TASK_LOOP:
; 563  : 				continue;
; 564  : 			case SPELL_WORD:
; 565  : 				ls_task_spell_word(phTTS,llp,rlp);

  003f1	8b 4c 24 10	 mov	 ecx, DWORD PTR _rlp$[esp+4908]
  003f5	8b 54 24 14	 mov	 edx, DWORD PTR _llp$[esp+4908]
  003f9	51		 push	 ecx
  003fa	52		 push	 edx
  003fb	53		 push	 ebx
  003fc	e8 00 00 00 00	 call	 _ls_task_spell_word
  00401	83 c4 0c	 add	 esp, 12			; 0000000cH
  00404	e9 ad fc ff ff	 jmp	 $L72357
_ls_task_main ENDP
_TEXT	ENDS
PUBLIC	_ls_task_parse_number
EXTRN	_ls_char_feat:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_np$ = 20
_pLts_t$ = 8
_pKsd_t$ = -4
_ls_task_parse_number PROC NEAR

; 635  : {

  00410	51		 push	 ecx

; 636  : 	LETTER  *tlp1;
; 637  : 	LETTER  *tlp2;
; 638  : 	int     ncbs;   
; 639  : 	int break_flag;
; 640  : 	PLTS_T  pLts_t;
; 641  : 	PKSD_T  pKsd_t;
; 642  : 
; 643  : 	pLts_t = phTTS->pLTSThreadData;

  00411	8b 44 24 08	 mov	 eax, DWORD PTR _phTTS$[esp]
  00415	53		 push	 ebx
  00416	55		 push	 ebp

; 644  : 	pKsd_t = phTTS->pKernelShareData;   
; 645  : 
; 646  : 	np->n_ilp = NULL;                       /* Null scan.           */
; 647  : 	np->n_flp = NULL;
; 648  : 	np->n_elp = NULL;
; 649  : 	tlp1 = llp;

  00417	8b 6c 24 14	 mov	 ebp, DWORD PTR _llp$[esp+8]
  0041b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0041e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00421	56		 push	 esi
  00422	8b 74 24 20	 mov	 esi, DWORD PTR _np$[esp+12]
  00426	57		 push	 edi

; 650  : 	if (tlp1 != rlp
; 651  : 	&& (tlp1->l_ch == 0xBC                  /* 1/4                  */
; 652  : 	||  tlp1->l_ch == 0xBD                  /* 1/2                  */
; 653  : 	||  IS_DIGIT(tlp1->l_ch))) 

  00427	8b 7c 24 20	 mov	 edi, DWORD PTR _rlp$[esp+16]
  0042b	33 c0		 xor	 eax, eax
  0042d	3b ef		 cmp	 ebp, edi
  0042f	89 06		 mov	 DWORD PTR [esi], eax
  00431	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00434	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00437	89 4c 24 18	 mov	 DWORD PTR _pLts_t$[esp+16], ecx
  0043b	89 54 24 10	 mov	 DWORD PTR _pKsd_t$[esp+20], edx
  0043f	8b c5		 mov	 eax, ebp
  00441	0f 84 73 01 00
	00		 je	 $L72414
  00447	66 8b 4d 00	 mov	 cx, WORD PTR [ebp]
  0044b	b3 10		 mov	 bl, 16			; 00000010H
  0044d	66 81 f9 bc 00	 cmp	 cx, 188			; 000000bcH
  00452	74 16		 je	 SHORT $L72425
  00454	66 81 f9 bd 00	 cmp	 cx, 189			; 000000bdH
  00459	74 0f		 je	 SHORT $L72425
  0045b	0f bf c9	 movsx	 ecx, cx
  0045e	84 99 00 00 00
	00		 test	 BYTE PTR _ls_char_feat[ecx], bl
  00464	0f 84 b9 00 00
	00		 je	 $L72424
$L72425:

; 654  : 	{
; 655  : 		np->n_ilp = tlp1;

  0046a	89 2e		 mov	 DWORD PTR [esi], ebp
$L72427:

; 657  : 		{
; 658  : 			/* 1/2 and 1/4.                                 */
; 659  : 			if (tlp1->l_ch==0xBC || tlp1->l_ch==0xBD) 

  0046c	66 8b 08	 mov	 cx, WORD PTR [eax]
  0046f	66 81 f9 bc 00	 cmp	 cx, 188			; 000000bcH
  00474	0f 84 94 00 00
	00		 je	 $L72430
  0047a	66 81 f9 bd 00	 cmp	 cx, 189			; 000000bdH
  0047f	0f 84 89 00 00
	00		 je	 $L72430

; 663  : 				return (tlp1);
; 664  : 			}
; 665  : 			/* Comma (period if this is MODE_EUROPE).       */
; 666  : 			if (tlp1->l_ch == pLts_t->schar) 

  00485	8b 54 24 18	 mov	 edx, DWORD PTR _pLts_t$[esp+16]
  00489	66 8b 92 ee 08
	00 00		 mov	 dx, WORD PTR [edx+2286]
  00490	66 3b ca	 cmp	 cx, dx
  00493	75 5e		 jne	 SHORT $L72431

; 667  : 			{
; 668  : 				tlp2 = tlp1;

  00495	8b c8		 mov	 ecx, eax

; 669  : 				ncbs = 3;
; 670  : 				break_flag = 0;
; 671  : 				while (ncbs-- && tlp2!=llp) 

  00497	be 02 00 00 00	 mov	 esi, 2
$L72433:
  0049c	3b cd		 cmp	 ecx, ebp
  0049e	74 19		 je	 SHORT $L72437

; 672  : 				{
; 673  : 					--tlp2;

  004a0	83 e9 02	 sub	 ecx, 2

; 674  : 					if (tlp2->l_ch == pLts_t->schar)

  004a3	66 39 11	 cmp	 WORD PTR [ecx], dx
  004a6	74 72		 je	 SHORT $L72428
  004a8	8b de		 mov	 ebx, esi
  004aa	4e		 dec	 esi
  004ab	85 db		 test	 ebx, ebx
  004ad	75 ed		 jne	 SHORT $L72433

; 675  :                     {						
; 676  : 						break_flag = 1;
; 677  : 						break;
; 678  : 				    }
; 679  : 				}    
; 680  : 				if (break_flag)
; 681  : 				   break;
; 682  : 				if (tlp2!=llp && (tlp2-1)->l_ch!=pLts_t->schar)

  004af	3b cd		 cmp	 ecx, ebp
  004b1	74 06		 je	 SHORT $L72437
  004b3	66 39 51 fe	 cmp	 WORD PTR [ecx-2], dx
  004b7	75 61		 jne	 SHORT $L72428
$L72437:

; 656  : 		while (tlp1 != rlp) 

  004b9	8d 70 02	 lea	 esi, DWORD PTR [eax+2]

; 683  : 					break;
; 684  : 				tlp2 = tlp1+1;
; 685  : 				ncbs = 3;
; 686  : 				while (ncbs--) 

  004bc	ba 02 00 00 00	 mov	 edx, 2
  004c1	8b ce		 mov	 ecx, esi
$L72439:

; 687  : 				{
; 688  : 					if (tlp2==rlp || !IS_DIGIT(tlp2->l_ch))

  004c3	3b cf		 cmp	 ecx, edi
  004c5	74 53		 je	 SHORT $L72428
  004c7	0f bf 19	 movsx	 ebx, WORD PTR [ecx]
  004ca	f6 83 00 00 00
	00 10		 test	 BYTE PTR _ls_char_feat[ebx], 16 ; 00000010H
  004d1	74 47		 je	 SHORT $L72428

; 689  : 					{
; 690  : 					   break_flag = 1;
; 691  : 					   break;
; 692  : 					}	
; 693  : 					++tlp2;

  004d3	83 c1 02	 add	 ecx, 2
  004d6	8b da		 mov	 ebx, edx
  004d8	4a		 dec	 edx
  004d9	85 db		 test	 ebx, ebx
  004db	75 e6		 jne	 SHORT $L72439

; 694  : 				}
; 695  : 				
; 696  : 				if (break_flag)
; 697  : 				   break;
; 698  : 				   
; 699  : 				/*
; 700  : 				 * The normal DECtalk code does not
; 701  : 				 * make this check; instead, it implemented
; 702  : 				 * the exact rules of the DECtalk I. Peter
; 703  : 				 * Stevens at Kurzweil thought that this extra
; 704  : 				 * check was appropriate, and I tend to
; 705  : 				 * agree with him. We should probably make
; 706  : 				 * this change in all DECtalk code.
; 707  : 				 */
; 708  : 				/* Note from EAB-I have looked at this and 
; 709  : 				 * can't figure out how it makes the dectalk
; 710  : 				 * do anything different, but for chicken 
; 711  : 				 * soup reasons I'm leaving it in. 
; 712  : 				 */     
; 713  : 
; 714  : 				if (tlp2!=rlp && IS_DIGIT(tlp2->l_ch))

  004dd	3b cf		 cmp	 ecx, edi
  004df	74 0c		 je	 SHORT $L72444
  004e1	0f bf 09	 movsx	 ecx, WORD PTR [ecx]
  004e4	f6 81 00 00 00
	00 10		 test	 BYTE PTR _ls_char_feat[ecx], 16 ; 00000010H
  004eb	75 2d		 jne	 SHORT $L72428
$L72444:

; 715  : 					break;
; 716  : 				++tlp1;

  004ed	8b c6		 mov	 eax, esi

; 717  : 				continue;

  004ef	b3 10		 mov	 bl, 16			; 00000010H
  004f1	eb 0e		 jmp	 SHORT $L73130
$L72431:

; 718  : 			}
; 719  : 			if (IS_DIGIT(tlp1->l_ch)) 

  004f3	0f bf d1	 movsx	 edx, cx
  004f6	84 9a 00 00 00
	00		 test	 BYTE PTR _ls_char_feat[edx], bl
  004fc	74 1c		 je	 SHORT $L72428

; 720  : 			{
; 721  : 				++tlp1;

  004fe	83 c0 02	 add	 eax, 2
$L73130:

; 656  : 		while (tlp1 != rlp) 

  00501	3b c7		 cmp	 eax, edi
  00503	74 15		 je	 SHORT $L72428
  00505	8b 74 24 24	 mov	 esi, DWORD PTR _np$[esp+16]
  00509	e9 5e ff ff ff	 jmp	 $L72427
$L72430:

; 660  : 			{
; 661  : 				++tlp1;

  0050e	83 c0 02	 add	 eax, 2
  00511	5f		 pop	 edi

; 662  : 				np->n_irp = tlp1;

  00512	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00515	5e		 pop	 esi
  00516	5d		 pop	 ebp
  00517	5b		 pop	 ebx

; 749  : 		}
; 750  : 	}
; 751  : 	return (tlp1);
; 752  : }

  00518	59		 pop	 ecx
  00519	c3		 ret	 0
$L72428:

; 722  : 				continue;
; 723  : 			}
; 724  : 			break;
; 725  : 		}
; 726  : 		np->n_irp = tlp1;

  0051a	8b 74 24 24	 mov	 esi, DWORD PTR _np$[esp+16]
  0051e	b3 10		 mov	 bl, 16			; 00000010H
  00520	89 46 04	 mov	 DWORD PTR [esi+4], eax
$L72424:

; 727  : 	}
; 728  : 	if (tlp1!=rlp && tlp1->l_ch==pLts_t->fchar) 

  00523	3b c7		 cmp	 eax, edi
  00525	0f 84 8f 00 00
	00		 je	 $L72414
  0052b	8b 54 24 18	 mov	 edx, DWORD PTR _pLts_t$[esp+16]
  0052f	66 8b 08	 mov	 cx, WORD PTR [eax]
  00532	66 3b 8a ec 08
	00 00		 cmp	 cx, WORD PTR [edx+2284]
  00539	75 1f		 jne	 SHORT $L72446

; 729  : 	{   /* Fraction             */
; 730  : 		np->n_flp = tlp1;

  0053b	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 731  : 		++tlp1;

  0053e	83 c0 02	 add	 eax, 2

; 732  : 		while (tlp1!=rlp && IS_DIGIT(tlp1->l_ch))

  00541	3b c7		 cmp	 eax, edi
  00543	74 12		 je	 SHORT $L72449
$L72448:
  00545	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00548	84 99 00 00 00
	00		 test	 BYTE PTR _ls_char_feat[ecx], bl
  0054e	74 07		 je	 SHORT $L72449

; 733  : 			++tlp1;

  00550	83 c0 02	 add	 eax, 2
  00553	3b c7		 cmp	 eax, edi
  00555	75 ee		 jne	 SHORT $L72448
$L72449:

; 734  : 		np->n_frp = tlp1;

  00557	89 46 0c	 mov	 DWORD PTR [esi+12], eax
$L72446:

; 735  : 	}
; 736  : 	if (tlp1!=rlp && tlp1->l_ch=='e' && (pKsd_t->modeflag & MODE_MATH)) 

  0055a	3b c7		 cmp	 eax, edi
  0055c	74 5c		 je	 SHORT $L72414
  0055e	66 83 38 65	 cmp	 WORD PTR [eax], 101	; 00000065H
  00562	75 56		 jne	 SHORT $L72414
  00564	8b 54 24 10	 mov	 edx, DWORD PTR _pKsd_t$[esp+20]
  00568	f6 82 c0 03 00
	00 04		 test	 BYTE PTR [edx+960], 4
  0056f	74 49		 je	 SHORT $L72414

; 737  : 	{        /* Exponant.            */
; 738  : 		tlp2 = tlp1;

  00571	8b d0		 mov	 edx, eax

; 739  : 		++tlp1;

  00573	83 c0 02	 add	 eax, 2

; 740  : 		if ( tlp1!=rlp && (tlp1->l_ch=='+' || tlp1->l_ch=='-'))

  00576	3b c7		 cmp	 eax, edi
  00578	74 40		 je	 SHORT $L72414
  0057a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0057d	66 83 f9 2b	 cmp	 cx, 43			; 0000002bH
  00581	74 06		 je	 SHORT $L72452
  00583	66 83 f9 2d	 cmp	 cx, 45			; 0000002dH
  00587	75 03		 jne	 SHORT $L72451
$L72452:

; 741  : 			++tlp1;

  00589	83 c0 02	 add	 eax, 2
$L72451:

; 742  : 		if (tlp1!=rlp && IS_DIGIT(tlp1->l_ch)) 

  0058c	3b c7		 cmp	 eax, edi
  0058e	74 2a		 je	 SHORT $L72414
  00590	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00593	84 99 00 00 00
	00		 test	 BYTE PTR _ls_char_feat[ecx], bl
  00599	74 1f		 je	 SHORT $L72414

; 743  : 		{
; 744  : 			np->n_elp = tlp2;
; 745  : 			++tlp1;

  0059b	83 c0 02	 add	 eax, 2
  0059e	89 56 10	 mov	 DWORD PTR [esi+16], edx

; 746  : 			while (tlp1!=rlp && IS_DIGIT(tlp1->l_ch))

  005a1	3b c7		 cmp	 eax, edi
  005a3	74 12		 je	 SHORT $L72456
$L72455:
  005a5	0f bf 10	 movsx	 edx, WORD PTR [eax]
  005a8	84 9a 00 00 00
	00		 test	 BYTE PTR _ls_char_feat[edx], bl
  005ae	74 07		 je	 SHORT $L72456

; 747  : 				++tlp1;

  005b0	83 c0 02	 add	 eax, 2
  005b3	3b c7		 cmp	 eax, edi
  005b5	75 ee		 jne	 SHORT $L72455
$L72456:

; 748  : 			np->n_erp = tlp1;

  005b7	89 46 14	 mov	 DWORD PTR [esi+20], eax
$L72414:
  005ba	5f		 pop	 edi
  005bb	5e		 pop	 esi
  005bc	5d		 pop	 ebp
  005bd	5b		 pop	 ebx

; 749  : 		}
; 750  : 	}
; 751  : 	return (tlp1);
; 752  : }

  005be	59		 pop	 ecx
  005bf	c3		 ret	 0
_ls_task_parse_number ENDP
_TEXT	ENDS
PUBLIC	_ls_task_wlookup
EXTRN	_ls_lower:BYTE
_TEXT	SEGMENT
_pLts_t$ = 8
_word$ = 12
_table$ = 16
_ls_task_wlookup PROC NEAR

; 779  : 	LETTER  *lp;
; 780  : 	/* GL 03/20/1998, BATS#633  use "unsigned char" instead of "char" */
; 781  : 	unsigned char  	*cp;
; 782  : 	unsigned char  	*tp;
; 783  : 	int   	c;
; 784  : 	int   	len;
; 785  : 
; 786  : 	tp = &table[0];                 /* Start at the start.  */
; 787  : 	while ((len = *tp++) != 0) 

  005c0	8b 44 24 0c	 mov	 eax, DWORD PTR _table$[esp-4]
  005c4	33 c9		 xor	 ecx, ecx
  005c6	53		 push	 ebx
  005c7	55		 push	 ebp
  005c8	8a 08		 mov	 cl, BYTE PTR [eax]
  005ca	56		 push	 esi
  005cb	8b e9		 mov	 ebp, ecx
  005cd	57		 push	 edi
  005ce	85 ed		 test	 ebp, ebp
  005d0	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  005d3	74 52		 je	 SHORT $L72471

; 788  : 	{            					/* 0 => end of table.   */
; 789  : 		lp = &word[0];              
; 790  : 		cp = tp;                    /* Start of text.       */
; 791  : 		for (;;) 
; 792  : 		{
; 793  : 			c = ls_lower[lp->l_ch]; /* Fold case.           */

  005d5	8b 54 24 18	 mov	 edx, DWORD PTR _word$[esp+12]
  005d9	0f bf 02	 movsx	 eax, WORD PTR [edx]
  005dc	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _ls_lower[eax]
  005e2	88 44 24 1c	 mov	 BYTE PTR 16+[esp+12], al
  005e6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
$L72470:
  005eb	8b 54 24 18	 mov	 edx, DWORD PTR _word$[esp+12]

; 794  : 			if (c != *cp++)         /* Lose.                */

  005ef	33 db		 xor	 ebx, ebx
  005f1	8a 1f		 mov	 bl, BYTE PTR [edi]
  005f3	8b c8		 mov	 ecx, eax
  005f5	3b cb		 cmp	 ecx, ebx
  005f7	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  005fa	75 1e		 jne	 SHORT $L73146
$L72473:

; 795  : 				break;
; 796  : 			if (c == EOS)           /* Win.                 */

  005fc	85 c9		 test	 ecx, ecx
  005fe	74 2e		 je	 SHORT $L73147
  00600	0f bf 4a 02	 movsx	 ecx, WORD PTR [edx+2]

; 807  :             }
; 808  : 			++lp;   

  00604	83 c2 02	 add	 edx, 2
  00607	33 db		 xor	 ebx, ebx
  00609	8a 99 00 00 00
	00		 mov	 bl, BYTE PTR _ls_lower[ecx]
  0060f	8b cb		 mov	 ecx, ebx
  00611	33 db		 xor	 ebx, ebx
  00613	8a 1e		 mov	 bl, BYTE PTR [esi]
  00615	46		 inc	 esi
  00616	3b cb		 cmp	 ecx, ebx
  00618	74 e2		 je	 SHORT $L72473
$L73146:

; 809  : 		}
; 810  : 		tp += len;                  /* Next.                */

  0061a	03 fd		 add	 edi, ebp
  0061c	33 d2		 xor	 edx, edx
  0061e	8a 17		 mov	 dl, BYTE PTR [edi]
  00620	47		 inc	 edi
  00621	8b ea		 mov	 ebp, edx
  00623	85 ed		 test	 ebp, ebp
  00625	75 c4		 jne	 SHORT $L72470
$L72471:
  00627	5f		 pop	 edi
  00628	5e		 pop	 esi
  00629	5d		 pop	 ebp

; 811  : 	}
; 812  : 	return (NULL);

  0062a	33 c0		 xor	 eax, eax
  0062c	5b		 pop	 ebx

; 813  : }

  0062d	c3		 ret	 0
$L73147:

; 797  :             {
; 798  : #ifdef ENGLISH
; 799  :                  /* set form class for "to" */
; 800  :                  if (ls_lower[(&word[0])->l_ch] == 't') pLts_t->fc_struct[pLts_t->fc_index] = FC_TO | FC_PREP | FC_FUNC;

  0062e	8a 44 24 1c	 mov	 al, BYTE PTR 16+[esp+12]
  00632	3c 74		 cmp	 al, 116			; 00000074H
  00634	8b 44 24 14	 mov	 eax, DWORD PTR _pLts_t$[esp+12]
  00638	75 11		 jne	 SHORT $L72477
  0063a	8b 88 bc 08 00
	00		 mov	 ecx, DWORD PTR [eax+2236]
  00640	c7 84 88 bc 04
	00 00 00 10 81
	00		 mov	 DWORD PTR [eax+ecx*4+1212], 8458240 ; 00811000H
$L72477:

; 801  :                  /* set form class for "and" */
; 802  :                  if (ls_lower[(&word[0])->l_ch] == 'a') pLts_t->fc_struct[pLts_t->fc_index] = FC_CONJ | FC_VERB | FC_FUNC;

  0064b	8b 4c 24 18	 mov	 ecx, DWORD PTR _word$[esp+12]
  0064f	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00652	80 ba 00 00 00
	00 61		 cmp	 BYTE PTR _ls_lower[edx], 97 ; 00000061H
  00659	75 11		 jne	 SHORT $L72478
  0065b	8b 90 bc 08 00
	00		 mov	 edx, DWORD PTR [eax+2236]
  00661	c7 84 90 bc 04
	00 00 40 00 82
	00		 mov	 DWORD PTR [eax+edx*4+1212], 8519744 ; 00820040H
$L72478:

; 803  :                  /* set form class for "for" */
; 804  :                  if (ls_lower[(&word[0])->l_ch] == 'f') pLts_t->fc_struct[pLts_t->fc_index] = FC_ADV | FC_PREP | FC_NEG;

  0066c	0f bf 09	 movsx	 ecx, WORD PTR [ecx]
  0066f	80 b9 00 00 00
	00 66		 cmp	 BYTE PTR _ls_lower[ecx], 102 ; 00000066H
  00676	75 11		 jne	 SHORT $L72479
  00678	8b 90 bc 08 00
	00		 mov	 edx, DWORD PTR [eax+2236]
  0067e	c7 84 90 bc 04
	00 00 02 10 08
	00		 mov	 DWORD PTR [eax+edx*4+1212], 528386 ; 00081002H
$L72479:

; 805  : #endif
; 806  :                  return (cp);    	/* Return phonemes.     */

  00689	8b c6		 mov	 eax, esi
  0068b	5f		 pop	 edi
  0068c	5e		 pop	 esi
  0068d	5d		 pop	 ebp
  0068e	5b		 pop	 ebx

; 813  : }

  0068f	c3		 ret	 0
_ls_task_wlookup ENDP
_TEXT	ENDS
PUBLIC	_ls_task_lookahead
EXTRN	_ls_util_is_index:NEAR
_TEXT	SEGMENT
_pLts_t$ = 8
_ls_task_lookahead PROC NEAR

; 836  : {

  00690	56		 push	 esi

; 837  :     LETTER	*elp;
; 838  : 
; 839  : 	if (ls_util_is_index(&(pLts_t->citem)) == FALSE)	/* Duck if no index     */

  00691	8b 74 24 08	 mov	 esi, DWORD PTR _pLts_t$[esp]
  00695	8d 86 00 09 00
	00		 lea	 eax, DWORD PTR [esi+2304]
  0069b	50		 push	 eax
  0069c	e8 00 00 00 00	 call	 _ls_util_is_index
  006a1	83 c4 04	 add	 esp, 4
  006a4	85 c0		 test	 eax, eax
  006a6	74 19		 je	 SHORT $L72488

; 840  : 		return;
; 841  : 	elp = &(pLts_t->cword[0]);                        	/* Find end of word,    */
; 842  : 	while ((elp+1)->l_ch != EOS)

  006a8	66 83 be 16 09
	00 00 00	 cmp	 WORD PTR [esi+2326], 0
  006b0	8d 86 16 09 00
	00		 lea	 eax, DWORD PTR [esi+2326]
  006b6	74 09		 je	 SHORT $L72488
$L72487:

; 843  : 	{
; 844  : 		++elp;

  006b8	83 c0 02	 add	 eax, 2
  006bb	66 83 38 00	 cmp	 WORD PTR [eax], 0
  006bf	75 f7		 jne	 SHORT $L72487
$L72488:
  006c1	5e		 pop	 esi

; 845  : 	}
; 846  : }

  006c2	c3		 ret	 0
_ls_task_lookahead ENDP
_TEXT	ENDS
EXTRN	_ls_suff_print_fc:NEAR
EXTRN	_ls_util_send_phone:NEAR
EXTRN	_ls_util_write_pipe:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_flag$ = 12
_buf$ = 8
_ls_task_do_right_punct PROC NEAR

; 870  : {

  006d0	53		 push	 ebx
  006d1	56		 push	 esi
  006d2	57		 push	 edi

; 871  : 	int   c;
; 872  : 	short   buf[1];
; 873  : 	PLTS_T  pLts_t;
; 874  : 	PKSD_T  pKsd_t;
; 875  : 
; 876  : 	pLts_t = phTTS->pLTSThreadData;

  006d3	8b 7c 24 10	 mov	 edi, DWORD PTR _phTTS$[esp+8]
  006d7	8b 77 10	 mov	 esi, DWORD PTR [edi+16]

; 877  : 	pKsd_t = phTTS->pKernelShareData;

  006da	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]

; 878  : 
; 879  : 	if ((pLts_t->citem.i_word[0]&PFONT) != (PFASCII<<PSFONT))

  006dd	66 8b 86 02 09
	00 00		 mov	 ax, WORD PTR [esi+2306]
  006e4	8b c8		 mov	 ecx, eax
  006e6	81 e1 00 1f 00
	00		 and	 ecx, 7936		; 00001f00H
  006ec	66 85 c9	 test	 cx, cx
  006ef	0f 85 f0 01 00
	00		 jne	 $L72504

; 880  : 		return;
; 881  : 	c = pLts_t->citem.i_word[0] & PVALUE;
; 882  : 	if (flag==ABBREV && (c==CR || c==LF)) 

  006f5	8b 4c 24 14	 mov	 ecx, DWORD PTR _flag$[esp+8]
  006f9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006fe	83 f9 02	 cmp	 ecx, 2
  00701	75 4e		 jne	 SHORT $L72499
  00703	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  00706	74 05		 je	 SHORT $L72500
  00708	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0070b	75 44		 jne	 SHORT $L72499
$L72500:

; 883  : 	{
; 884  : 		ls_util_send_phone(phTTS,PERIOD);

  0070d	6a 74		 push	 116			; 00000074H
  0070f	57		 push	 edi
  00710	e8 00 00 00 00	 call	 _ls_util_send_phone

; 885  : 		pLts_t->wstate = UNK_WH;

  00715	66 c7 86 c4 08
	00 00 00 00	 mov	 WORD PTR [esi+2244], 0

; 886  : 
; 887  : /* GL 11/06/1997 add switch 4100. form class log can be used by any language */
; 888  : //#ifdef ENGLISH		
; 889  : 		if((pKsd_t->logflag& LOG_FORM_TYPES) || DT_DBG(LTS_DBG,0x100))

  0071e	8a 83 c4 03 00
	00		 mov	 al, BYTE PTR [ebx+964]
  00724	83 c4 08	 add	 esp, 8
  00727	a8 08		 test	 al, 8
  00729	75 19		 jne	 SHORT $L72502
  0072b	66 8b 9b 40 06
	00 00		 mov	 bx, WORD PTR [ebx+1600]
  00732	f6 c7 40	 test	 bh, 64			; 00000040H
  00735	0f 84 aa 01 00
	00		 je	 $L72504
  0073b	f6 c7 01	 test	 bh, 1
  0073e	0f 84 a1 01 00
	00		 je	 $L72504
$L72502:

; 890  : 			ls_suff_print_fc(phTTS);

  00744	57		 push	 edi
  00745	e8 00 00 00 00	 call	 _ls_suff_print_fc

; 991  : 			ls_util_read_item(phTTS);

  0074a	83 c4 04	 add	 esp, 4
  0074d	5f		 pop	 edi
  0074e	5e		 pop	 esi
  0074f	5b		 pop	 ebx

; 992  : 			break;
; 993  : 	}
; 994  : }

  00750	c3		 ret	 0
$L72499:

; 891  : //#endif
; 892  : 		return;
; 893  : 	}
; 894  : 	switch (c) 
; 895  : 	{

  00751	83 c0 f7	 add	 eax, -9			; fffffff7H
  00754	3d 97 00 00 00	 cmp	 eax, 151		; 00000097H
  00759	0f 87 86 01 00
	00		 ja	 $L72504
  0075f	33 d2		 xor	 edx, edx
  00761	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $L73158[eax]
  00767	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L73159[edx*4]
$L72507:

; 896  : 		case '.':
; 897  : #ifdef GERMAN
; 898  : 			/* GL 03/23/1998, BATS#613 remove the extra pulse for German ordinal number */
; 899  : 			if (ls_util_is_dot(pLts_t) && pLts_t->isnumabr == 3)
; 900  : 				;
; 901  : 			else
; 902  : 			ls_util_send_phone(phTTS,PERIOD);
; 903  : #else
; 904  : 			ls_util_send_phone(phTTS,PERIOD);

  0076e	6a 74		 push	 116			; 00000074H
  00770	57		 push	 edi
  00771	e8 00 00 00 00	 call	 _ls_util_send_phone

; 905  : #endif
; 906  : /* GL 11/06/1997 add switch 4100. form class log can be used by any language */
; 907  : //#ifdef ENGLISH			
; 908  : 			if((pKsd_t->logflag & LOG_FORM_TYPES) || DT_DBG(LTS_DBG,0x100))

  00776	8a 83 c4 03 00
	00		 mov	 al, BYTE PTR [ebx+964]
  0077c	83 c4 08	 add	 esp, 8
  0077f	a8 08		 test	 al, 8
  00781	75 47		 jne	 SHORT $L72509
  00783	66 8b 9b 40 06
	00 00		 mov	 bx, WORD PTR [ebx+1600]
  0078a	f6 c7 40	 test	 bh, 64			; 00000040H
  0078d	74 44		 je	 SHORT $L72508
  0078f	f6 c7 01	 test	 bh, 1
  00792	74 3f		 je	 SHORT $L72508

; 909  : 				ls_suff_print_fc(phTTS);
; 910  : //#endif				
; 911  : 			ls_util_read_item(phTTS);
; 912  : 			pLts_t->wstate = UNK_WH;
; 913  : 			break;

  00794	eb 34		 jmp	 SHORT $L72509
$L72510:

; 914  : 
; 915  : 		case '?':
; 916  : 			if (pLts_t->wstate == IS_WH)    			/* Ignore the "?" if at */

  00796	66 83 be c4 08
	00 00 01	 cmp	 WORD PTR [esi+2244], 1
  0079e	75 04		 jne	 SHORT $L72511

; 917  : 			{
; 918  : #ifdef LS1DEBUG
; 919  : 				printf("Changing question mark to period! \n");
; 920  : #endif
; 921  : 				ls_util_send_phone(phTTS,PERIOD);       /* the end of a "Wh..." */

  007a0	6a 74		 push	 116			; 00000074H

; 922  : 			}
; 923  : 			else                            			/* style sentence.      */

  007a2	eb 02		 jmp	 SHORT $L73156
$L72511:

; 924  : 			{
; 925  : 				ls_util_send_phone(phTTS,QUEST);

  007a4	6a 75		 push	 117			; 00000075H
$L73156:
  007a6	57		 push	 edi
  007a7	e8 00 00 00 00	 call	 _ls_util_send_phone

; 926  : 			}
; 927  : /* GL 11/06/1997 add switch 4100. form class log can be used by any language */
; 928  : //#ifdef ENGLISH
; 929  : 		    if((pKsd_t->logflag& LOG_FORM_TYPES) || DT_DBG(LTS_DBG,0x100))

  007ac	8a 83 c4 03 00
	00		 mov	 al, BYTE PTR [ebx+964]
  007b2	83 c4 08	 add	 esp, 8
  007b5	a8 08		 test	 al, 8
  007b7	75 11		 jne	 SHORT $L72509
  007b9	66 8b 9b 40 06
	00 00		 mov	 bx, WORD PTR [ebx+1600]
  007c0	f6 c7 40	 test	 bh, 64			; 00000040H
  007c3	74 0e		 je	 SHORT $L72508
  007c5	f6 c7 01	 test	 bh, 1
  007c8	74 09		 je	 SHORT $L72508
$L72509:

; 930  : 				ls_suff_print_fc(phTTS);

  007ca	57		 push	 edi
  007cb	e8 00 00 00 00	 call	 _ls_suff_print_fc
  007d0	83 c4 04	 add	 esp, 4
$L72508:

; 931  : //#endif
; 932  : 			ls_util_read_item(phTTS);

  007d3	57		 push	 edi
  007d4	e8 00 00 00 00	 call	 _ls_util_read_item
  007d9	83 c4 04	 add	 esp, 4

; 933  : 			pLts_t->wstate = UNK_WH;

  007dc	66 c7 86 c4 08
	00 00 00 00	 mov	 WORD PTR [esi+2244], 0
  007e5	5f		 pop	 edi
  007e6	5e		 pop	 esi
  007e7	5b		 pop	 ebx

; 992  : 			break;
; 993  : 	}
; 994  : }

  007e8	c3		 ret	 0
$L72515:

; 934  : 			break;
; 935  : 
; 936  : 		case '!':
; 937  : 			ls_util_send_phone(phTTS,EXCLAIM);

  007e9	6a 76		 push	 118			; 00000076H
  007eb	57		 push	 edi
  007ec	e8 00 00 00 00	 call	 _ls_util_send_phone

; 938  : 
; 939  : 			ls_util_read_item(phTTS);

  007f1	57		 push	 edi
  007f2	e8 00 00 00 00	 call	 _ls_util_read_item

; 940  : /* GL 11/06/1997 add switch 4100. form class log can be used by any language */
; 941  : //#ifdef ENGLISH			
; 942  : 		    if((pKsd_t->logflag& LOG_FORM_TYPES) || DT_DBG(LTS_DBG,0x100))

  007f7	8a 83 c4 03 00
	00		 mov	 al, BYTE PTR [ebx+964]
  007fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00800	a8 08		 test	 al, 8
  00802	75 11		 jne	 SHORT $L72517
  00804	66 8b 9b 40 06
	00 00		 mov	 bx, WORD PTR [ebx+1600]
  0080b	f6 c7 40	 test	 bh, 64			; 00000040H
  0080e	74 0e		 je	 SHORT $L72516
  00810	f6 c7 01	 test	 bh, 1
  00813	74 09		 je	 SHORT $L72516
$L72517:

; 943  : 				ls_suff_print_fc(phTTS);

  00815	57		 push	 edi
  00816	e8 00 00 00 00	 call	 _ls_suff_print_fc
  0081b	83 c4 04	 add	 esp, 4
$L72516:

; 944  : //#endif				
; 945  : 			pLts_t->wstate = UNK_WH;

  0081e	66 c7 86 c4 08
	00 00 00 00	 mov	 WORD PTR [esi+2244], 0
  00827	5f		 pop	 edi
  00828	5e		 pop	 esi
  00829	5b		 pop	 ebx

; 992  : 			break;
; 993  : 	}
; 994  : }

  0082a	c3		 ret	 0
$L72518:

; 946  : 			break;
; 947  : 
; 948  : 		case VT:
; 949  : 		    /* Vertical tab, flush  */
; 950  : 		    /*
; 951  : 			   GL 01/31/1996, need to initialize the form class state for
; 952  : 			   control-k(VT)
; 953  : 			*/
; 954  : /* GL 11/06/1997 add switch 4100. form class log can be used by any language */
; 955  : //#ifdef ENGLISH			
; 956  : 			if((pKsd_t->logflag& LOG_FORM_TYPES) || DT_DBG(LTS_DBG,0x100))

  0082b	f6 83 c4 03 00
	00 08		 test	 BYTE PTR [ebx+964], 8
  00832	75 11		 jne	 SHORT $L72520
  00834	66 8b 83 40 06
	00 00		 mov	 ax, WORD PTR [ebx+1600]
  0083b	f6 c4 40	 test	 ah, 64			; 00000040H
  0083e	74 0e		 je	 SHORT $L72519
  00840	f6 c4 01	 test	 ah, 1
  00843	74 09		 je	 SHORT $L72519
$L72520:

; 957  : 				ls_suff_print_fc(phTTS);

  00845	57		 push	 edi
  00846	e8 00 00 00 00	 call	 _ls_suff_print_fc
  0084b	83 c4 04	 add	 esp, 4
$L72519:

; 958  : //#endif				
; 959  : 			pLts_t->fc_index = 0;

  0084e	33 c0		 xor	 eax, eax

; 960  : 			pLts_t->old_fc_index = -1;
; 961  : 			pLts_t->fc_struct[0] = 0;
; 962  : 			pLts_t->fc_struct[1] = 0;
; 963  : 
; 964  : 			buf[0] = BREATH_BREAK;
; 965  : 			ls_util_write_pipe(pKsd_t,&buf[0],1);

  00850	6a 01		 push	 1
  00852	89 86 bc 08 00
	00		 mov	 DWORD PTR [esi+2236], eax
  00858	89 86 bc 04 00
	00		 mov	 DWORD PTR [esi+1212], eax
  0085e	89 86 c0 04 00
	00		 mov	 DWORD PTR [esi+1216], eax
  00864	8d 44 24 14	 lea	 eax, DWORD PTR _buf$[esp+12]
  00868	50		 push	 eax
  00869	c7 86 c0 08 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+2240], -1
  00873	53		 push	 ebx
  00874	66 c7 44 24 1c
	0b 1f		 mov	 WORD PTR _buf$[esp+20], 7947 ; 00001f0bH
  0087b	e8 00 00 00 00	 call	 _ls_util_write_pipe

; 966  : 			ls_util_read_item(phTTS);

  00880	57		 push	 edi
  00881	e8 00 00 00 00	 call	 _ls_util_read_item
  00886	83 c4 10	 add	 esp, 16			; 00000010H
  00889	5f		 pop	 edi
  0088a	5e		 pop	 esi
  0088b	5b		 pop	 ebx

; 992  : 			break;
; 993  : 	}
; 994  : }

  0088c	c3		 ret	 0
$L72521:

; 967  : 			break;
; 968  : 
; 969  : 		case ',':
; 970  : 		case ':':
; 971  : 		case ';':
; 972  : 		case HT:                                /* Tab, longish pause   */
; 973  : 
; 974  : 			pLts_t->fc_index = 1;
; 975  : 			pLts_t->old_fc_index = -1;
; 976  : 			pLts_t->fc_struct[0] = 0;

  0088d	33 c0		 xor	 eax, eax

; 977  : 			pLts_t->fc_struct[1] = 0;
; 978  : 			ls_util_send_phone(phTTS,COMMA);

  0088f	6a 73		 push	 115			; 00000073H
  00891	57		 push	 edi
  00892	c7 86 bc 08 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+2236], 1
  0089c	c7 86 c0 08 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+2240], -1
  008a6	89 86 bc 04 00
	00		 mov	 DWORD PTR [esi+1212], eax
  008ac	89 86 c0 04 00
	00		 mov	 DWORD PTR [esi+1216], eax
  008b2	e8 00 00 00 00	 call	 _ls_util_send_phone

; 979  : 			ls_util_read_item(phTTS);

  008b7	57		 push	 edi
  008b8	e8 00 00 00 00	 call	 _ls_util_read_item
  008bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  008c0	5f		 pop	 edi
  008c1	5e		 pop	 esi
  008c2	5b		 pop	 ebx

; 992  : 			break;
; 993  : 	}
; 994  : }

  008c3	c3		 ret	 0
$L72522:

; 980  : 			break;
; 981  : 
; 982  : 		case ' ':                               /* ASCII SP             */
; 983  : 		case 0xA0:                              /* Multinational SP     */
; 984  : 		case LF:                                /* Linefeed             */
; 985  : 		case FF:                                /* Formfeed             */
; 986  : 		case CR:                                /* Carriage return.     */
; 987  : 			if ((pKsd_t->modeflag&MODE_SPELL)!=0)

  008c4	f6 83 c0 03 00
	00 10		 test	 BYTE PTR [ebx+960], 16	; 00000010H
  008cb	74 04		 je	 SHORT $L72523

; 988  : 				ls_util_send_phone(phTTS,COMMA);       /* Make longer pause if */

  008cd	6a 73		 push	 115			; 00000073H

; 989  : 			else                            /* forced spelling.     */

  008cf	eb 02		 jmp	 SHORT $L73157
$L72523:

; 990  : 				ls_util_send_phone(phTTS,WBOUND);

  008d1	6a 6f		 push	 111			; 0000006fH
$L73157:
  008d3	57		 push	 edi
  008d4	e8 00 00 00 00	 call	 _ls_util_send_phone
  008d9	83 c4 08	 add	 esp, 8

; 991  : 			ls_util_read_item(phTTS);

  008dc	57		 push	 edi
  008dd	e8 00 00 00 00	 call	 _ls_util_read_item
  008e2	83 c4 04	 add	 esp, 4
$L72504:
  008e5	5f		 pop	 edi
  008e6	5e		 pop	 esi
  008e7	5b		 pop	 ebx

; 992  : 			break;
; 993  : 	}
; 994  : }

  008e8	c3		 ret	 0
  008e9	8d 49 00	 npad	 3
$L73159:
  008ec	00 00 00 00	 DD	 $L72521
  008f0	00 00 00 00	 DD	 $L72522
  008f4	00 00 00 00	 DD	 $L72518
  008f8	00 00 00 00	 DD	 $L72515
  008fc	00 00 00 00	 DD	 $L72507
  00900	00 00 00 00	 DD	 $L72510
  00904	00 00 00 00	 DD	 $L72504
$L73158:
  00908	00		 DB	 0
  00909	01		 DB	 1
  0090a	02		 DB	 2
  0090b	01		 DB	 1
  0090c	01		 DB	 1
  0090d	06		 DB	 6
  0090e	06		 DB	 6
  0090f	06		 DB	 6
  00910	06		 DB	 6
  00911	06		 DB	 6
  00912	06		 DB	 6
  00913	06		 DB	 6
  00914	06		 DB	 6
  00915	06		 DB	 6
  00916	06		 DB	 6
  00917	06		 DB	 6
  00918	06		 DB	 6
  00919	06		 DB	 6
  0091a	06		 DB	 6
  0091b	06		 DB	 6
  0091c	06		 DB	 6
  0091d	06		 DB	 6
  0091e	06		 DB	 6
  0091f	01		 DB	 1
  00920	03		 DB	 3
  00921	06		 DB	 6
  00922	06		 DB	 6
  00923	06		 DB	 6
  00924	06		 DB	 6
  00925	06		 DB	 6
  00926	06		 DB	 6
  00927	06		 DB	 6
  00928	06		 DB	 6
  00929	06		 DB	 6
  0092a	06		 DB	 6
  0092b	00		 DB	 0
  0092c	06		 DB	 6
  0092d	04		 DB	 4
  0092e	06		 DB	 6
  0092f	06		 DB	 6
  00930	06		 DB	 6
  00931	06		 DB	 6
  00932	06		 DB	 6
  00933	06		 DB	 6
  00934	06		 DB	 6
  00935	06		 DB	 6
  00936	06		 DB	 6
  00937	06		 DB	 6
  00938	06		 DB	 6
  00939	00		 DB	 0
  0093a	00		 DB	 0
  0093b	06		 DB	 6
  0093c	06		 DB	 6
  0093d	06		 DB	 6
  0093e	05		 DB	 5
  0093f	06		 DB	 6
  00940	06		 DB	 6
  00941	06		 DB	 6
  00942	06		 DB	 6
  00943	06		 DB	 6
  00944	06		 DB	 6
  00945	06		 DB	 6
  00946	06		 DB	 6
  00947	06		 DB	 6
  00948	06		 DB	 6
  00949	06		 DB	 6
  0094a	06		 DB	 6
  0094b	06		 DB	 6
  0094c	06		 DB	 6
  0094d	06		 DB	 6
  0094e	06		 DB	 6
  0094f	06		 DB	 6
  00950	06		 DB	 6
  00951	06		 DB	 6
  00952	06		 DB	 6
  00953	06		 DB	 6
  00954	06		 DB	 6
  00955	06		 DB	 6
  00956	06		 DB	 6
  00957	06		 DB	 6
  00958	06		 DB	 6
  00959	06		 DB	 6
  0095a	06		 DB	 6
  0095b	06		 DB	 6
  0095c	06		 DB	 6
  0095d	06		 DB	 6
  0095e	06		 DB	 6
  0095f	06		 DB	 6
  00960	06		 DB	 6
  00961	06		 DB	 6
  00962	06		 DB	 6
  00963	06		 DB	 6
  00964	06		 DB	 6
  00965	06		 DB	 6
  00966	06		 DB	 6
  00967	06		 DB	 6
  00968	06		 DB	 6
  00969	06		 DB	 6
  0096a	06		 DB	 6
  0096b	06		 DB	 6
  0096c	06		 DB	 6
  0096d	06		 DB	 6
  0096e	06		 DB	 6
  0096f	06		 DB	 6
  00970	06		 DB	 6
  00971	06		 DB	 6
  00972	06		 DB	 6
  00973	06		 DB	 6
  00974	06		 DB	 6
  00975	06		 DB	 6
  00976	06		 DB	 6
  00977	06		 DB	 6
  00978	06		 DB	 6
  00979	06		 DB	 6
  0097a	06		 DB	 6
  0097b	06		 DB	 6
  0097c	06		 DB	 6
  0097d	06		 DB	 6
  0097e	06		 DB	 6
  0097f	06		 DB	 6
  00980	06		 DB	 6
  00981	06		 DB	 6
  00982	06		 DB	 6
  00983	06		 DB	 6
  00984	06		 DB	 6
  00985	06		 DB	 6
  00986	06		 DB	 6
  00987	06		 DB	 6
  00988	06		 DB	 6
  00989	06		 DB	 6
  0098a	06		 DB	 6
  0098b	06		 DB	 6
  0098c	06		 DB	 6
  0098d	06		 DB	 6
  0098e	06		 DB	 6
  0098f	06		 DB	 6
  00990	06		 DB	 6
  00991	06		 DB	 6
  00992	06		 DB	 6
  00993	06		 DB	 6
  00994	06		 DB	 6
  00995	06		 DB	 6
  00996	06		 DB	 6
  00997	06		 DB	 6
  00998	06		 DB	 6
  00999	06		 DB	 6
  0099a	06		 DB	 6
  0099b	06		 DB	 6
  0099c	06		 DB	 6
  0099d	06		 DB	 6
  0099e	06		 DB	 6
  0099f	01		 DB	 1
_ls_task_do_right_punct ENDP
_TEXT	ENDS
EXTRN	_lsctype:BYTE
EXTRN	_ls_util_write_item:NEAR
EXTRN	_ls_util_is_white:NEAR
EXTRN	_ls_util_is_might:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_word$ = 12
_ksf$ = 8
_pLts_t$ = -4
_ls_task_readword PROC NEAR

; 1025 : {

  009a0	51		 push	 ecx
  009a1	53		 push	 ebx
  009a2	55		 push	 ebp
  009a3	56		 push	 esi
  009a4	57		 push	 edi

; 1026 : 	LETTER        *lp1;
; 1027 : 	LETTER        *lp2;
; 1028 : 	int   ksf=0;
; 1029 : 	int   t;
; 1030 : 	int   c=0;
; 1031 : 	PLTS_T  pLts_t;
; 1032 : 	PKSD_T  pKsd_t;
; 1033 : 
; 1034 : 	pLts_t = phTTS->pLTSThreadData;

  009a5	8b 7c 24 18	 mov	 edi, DWORD PTR _phTTS$[esp+16]
  009a9	33 ed		 xor	 ebp, ebp
  009ab	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  009ae	89 44 24 10	 mov	 DWORD PTR _pLts_t$[esp+20], eax

; 1035 : 	pKsd_t = phTTS->pKernelShareData;   
; 1036 : 	
; 1037 : /*
; 1038 :  *  start with no flags for this word ...
; 1039 :  */
; 1040 : 	while (ls_util_is_white(&(pLts_t->citem)) != FALSE) 

  009b2	8d b0 00 09 00
	00		 lea	 esi, DWORD PTR [eax+2304]
  009b8	56		 push	 esi
  009b9	e8 00 00 00 00	 call	 _ls_util_is_white
  009be	83 c4 04	 add	 esp, 4
  009c1	85 c0		 test	 eax, eax
  009c3	74 39		 je	 SHORT $L72539
$L72538:

; 1041 : 	{      /* Skip spaces.         */
; 1042 : 		ls_util_read_item(phTTS);

  009c5	57		 push	 edi
  009c6	e8 00 00 00 00	 call	 _ls_util_read_item

; 1043 : 		while (ls_util_is_index(&(pLts_t->citem)) != FALSE) 

  009cb	56		 push	 esi
  009cc	e8 00 00 00 00	 call	 _ls_util_is_index
  009d1	83 c4 08	 add	 esp, 8
  009d4	85 c0		 test	 eax, eax
  009d6	74 19		 je	 SHORT $L72542
$L72541:

; 1044 : 		{
; 1045 : 			ls_util_write_item(phTTS);

  009d8	57		 push	 edi
  009d9	e8 00 00 00 00	 call	 _ls_util_write_item

; 1046 : 			ls_util_read_item(phTTS);

  009de	57		 push	 edi
  009df	e8 00 00 00 00	 call	 _ls_util_read_item
  009e4	56		 push	 esi
  009e5	e8 00 00 00 00	 call	 _ls_util_is_index
  009ea	83 c4 0c	 add	 esp, 12			; 0000000cH
  009ed	85 c0		 test	 eax, eax
  009ef	75 e7		 jne	 SHORT $L72541
$L72542:

; 1035 : 	pKsd_t = phTTS->pKernelShareData;   
; 1036 : 	
; 1037 : /*
; 1038 :  *  start with no flags for this word ...
; 1039 :  */
; 1040 : 	while (ls_util_is_white(&(pLts_t->citem)) != FALSE) 

  009f1	56		 push	 esi
  009f2	e8 00 00 00 00	 call	 _ls_util_is_white
  009f7	83 c4 04	 add	 esp, 4
  009fa	85 c0		 test	 eax, eax
  009fc	75 c7		 jne	 SHORT $L72538
$L72539:

; 1047 : 		}
; 1048 : 	}
; 1049 : 	lp1 = &word[0];                         /* Current location     */

  009fe	8b 74 24 1c	 mov	 esi, DWORD PTR _word$[esp+16]

; 1050 : 	lp2 = &word[0];                         /* Rightmost location   */
; 1051 : 	ksf = FALSE;                            /* Nothing kept         */

  00a02	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _ksf$[esp+16], 0
  00a0a	8b de		 mov	 ebx, esi
$L72544:

; 1052 :         
; 1053 : /* JDB: simple fix to avoid the goto's that used to be here */
; 1054 : /* loop: */
; 1055 :   while (1) 
; 1056 :   { 
; 1057 : 		if (ls_util_is_index(&(pLts_t->citem)) != FALSE)

  00a0c	8b 44 24 10	 mov	 eax, DWORD PTR _pLts_t$[esp+20]
  00a10	05 00 09 00 00	 add	 eax, 2304		; 00000900H
  00a15	50		 push	 eax
  00a16	e8 00 00 00 00	 call	 _ls_util_is_index
  00a1b	83 c4 04	 add	 esp, 4
  00a1e	85 c0		 test	 eax, eax
  00a20	74 1a		 je	 SHORT $L72546

; 1058 : 		{         
; 1059 : 			/* Index markers.       */
; 1060 : 			if (lp1 == &word[0])            /* Flush through if at  */

  00a22	3b 74 24 1c	 cmp	 esi, DWORD PTR _word$[esp+16]
  00a26	75 09		 jne	 SHORT $L72547

; 1061 : 			{
; 1062 : 				ls_util_write_item(phTTS);  /* left edge of word.   */

  00a28	57		 push	 edi
  00a29	e8 00 00 00 00	 call	 _ls_util_write_item
  00a2e	83 c4 04	 add	 esp, 4
$L72547:

; 1063 : 			}
; 1064 : 
; 1065 : 
; 1066 : 			ls_util_read_item(phTTS); /* read next item */ 

  00a31	57		 push	 edi
  00a32	e8 00 00 00 00	 call	 _ls_util_read_item
  00a37	83 c4 04	 add	 esp, 4

; 1067 : 			/* an item is a character with a bunch of other info about it */
; 1068 : 			continue; /* goto loop; */

  00a3a	eb d0		 jmp	 SHORT $L72544
$L72546:

; 1069 : 
; 1070 : 		}
; 1071 : 
; 1072 : 		t = PHONEME;
; 1073 : 		if ((pLts_t->citem.i_word[0]&PFONT) == (PFASCII<<PSFONT)) 

  00a3c	8b 54 24 10	 mov	 edx, DWORD PTR _pLts_t$[esp+20]
  00a40	b9 05 00 00 00	 mov	 ecx, 5
  00a45	66 8b 82 02 09
	00 00		 mov	 ax, WORD PTR [edx+2306]
  00a4c	8b d0		 mov	 edx, eax
  00a4e	81 e2 00 1f 00
	00		 and	 edx, 7936		; 00001f00H
  00a54	66 85 d2	 test	 dx, dx
  00a57	75 3a		 jne	 SHORT $L72550

; 1074 : 		{
; 1075 : 			c = pLts_t->citem.i_word[0] & PVALUE;

  00a59	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00a5e	8b e8		 mov	 ebp, eax

; 1076 : 			t = lsctype[c] & TYPE;

  00a60	8a 0c 6d 00 00
	00 00		 mov	 cl, BYTE PTR _lsctype[ebp*2]
  00a67	83 e1 0f	 and	 ecx, 15			; 0000000fH

; 1077 : 			if (t == IGNORE) 

  00a6a	75 0b		 jne	 SHORT $L72549

; 1078 : 			{   
; 1079 : 				/* These two are easy.  */
; 1080 : 				ls_util_read_item(phTTS);

  00a6c	57		 push	 edi
  00a6d	e8 00 00 00 00	 call	 _ls_util_read_item
  00a72	83 c4 04	 add	 esp, 4

; 1081 : 				continue; /* goto loop; */

  00a75	eb 95		 jmp	 SHORT $L72544
$L72549:

; 1082 : 			}
; 1083 : 			if (t == BACKUP) 

  00a77	83 f9 01	 cmp	 ecx, 1
  00a7a	75 17		 jne	 SHORT $L72550

; 1084 : 			{
; 1085 : 				if (lp1 != &word[0])

  00a7c	3b 74 24 1c	 cmp	 esi, DWORD PTR _word$[esp+16]
  00a80	74 03		 je	 SHORT $L72551

; 1086 : 					--lp1;           

  00a82	83 ee 02	 sub	 esi, 2
$L72551:

; 1087 : 				ls_util_read_item(phTTS);

  00a85	57		 push	 edi
  00a86	e8 00 00 00 00	 call	 _ls_util_read_item
  00a8b	83 c4 04	 add	 esp, 4

; 1088 : 				continue; /* goto loop; */

  00a8e	e9 79 ff ff ff	 jmp	 $L72544
$L72550:

; 1089 : 			}
; 1090 : 		}
; 1091 : 		
; 1092 : 		if (lp1 < lp2) 

  00a93	3b f3		 cmp	 esi, ebx
  00a95	73 2c		 jae	 SHORT $L72552

; 1093 : 		{                        /* Overstrike.          */
; 1094 : 
; 1095 : 			if (t==MIGHT || t==ALWAYS)

  00a97	83 f9 03	 cmp	 ecx, 3
  00a9a	74 09		 je	 SHORT $L72554
  00a9c	83 f9 04	 cmp	 ecx, 4
  00a9f	0f 85 b1 00 00
	00		 jne	 $L73166
$L72554:

; 1096 : 			{
; 1097 : 				if ((lsctype[c]&II) == 0)

  00aa5	f6 04 6d 00 00
	00 00 10	 test	 BYTE PTR _lsctype[ebp*2], 16 ; 00000010H
  00aad	75 03		 jne	 SHORT $L72555

; 1098 : 					lp1->l_ch = c;

  00aaf	66 89 2e	 mov	 WORD PTR [esi], bp
$L72555:

; 1099 : 				++lp1;
; 1100 : 				ls_util_read_item(phTTS);

  00ab2	57		 push	 edi
  00ab3	83 c6 02	 add	 esi, 2
  00ab6	e8 00 00 00 00	 call	 _ls_util_read_item
  00abb	83 c4 04	 add	 esp, 4

; 1101 : 				continue; /* goto loop;*/

  00abe	e9 49 ff ff ff	 jmp	 $L72544
$L72552:

; 1102 : 			}
; 1103 : 		} 
; 1104 : 		else
; 1105 : 		{
; 1106 :  
; 1107 : 			if (lp1 == &word[0])

  00ac3	3b 74 24 1c	 cmp	 esi, DWORD PTR _word$[esp+16]
  00ac7	75 52		 jne	 SHORT $L72557

; 1108 : 			{           /* Initial position.    */
; 1109 : 				if (t == PHONEME) 

  00ac9	83 f9 05	 cmp	 ecx, 5
  00acc	75 1c		 jne	 SHORT $L72558

; 1110 : 				{
; 1111 : 					ls_util_write_item(phTTS);

  00ace	57		 push	 edi
  00acf	e8 00 00 00 00	 call	 _ls_util_write_item

; 1112 : 					ls_util_read_item(phTTS);

  00ad4	57		 push	 edi
  00ad5	e8 00 00 00 00	 call	 _ls_util_read_item
  00ada	83 c4 08	 add	 esp, 8

; 1113 : 					ksf = TRUE;             /* Kept something       */

  00add	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _ksf$[esp+16], 1

; 1114 : 					continue; /* goto loop; */

  00ae5	e9 22 ff ff ff	 jmp	 $L72544
$L72558:

; 1115 : 				}
; 1116 : 
; 1117 : 				if (t==ALWAYS || (t==MIGHT && ksf==FALSE)) 

  00aea	83 f9 04	 cmp	 ecx, 4
  00aed	74 0d		 je	 SHORT $L72560
  00aef	83 f9 03	 cmp	 ecx, 3
  00af2	75 62		 jne	 SHORT $L73166
  00af4	8b 44 24 18	 mov	 eax, DWORD PTR _ksf$[esp+16]
  00af8	85 c0		 test	 eax, eax
  00afa	75 5a		 jne	 SHORT $L73166
$L72560:

; 1118 : 				{
; 1119 : 
; 1120 : 					lp1->l_ch = c;

  00afc	66 89 2e	 mov	 WORD PTR [esi], bp

; 1121 : 					//	lp1->l_ip = NULL;
; 1122 : 					++lp1;
; 1123 : 					++lp2;
; 1124 : 					ls_util_read_item(phTTS);

  00aff	57		 push	 edi
  00b00	83 c6 02	 add	 esi, 2
  00b03	83 c3 02	 add	 ebx, 2
  00b06	e8 00 00 00 00	 call	 _ls_util_read_item
  00b0b	83 c4 04	 add	 esp, 4

; 1125 : 					ksf = TRUE;             /* Kept something.      */

  00b0e	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _ksf$[esp+16], 1

; 1126 : 					continue; /* goto loop; */

  00b16	e9 f1 fe ff ff	 jmp	 $L72544
$L72557:

; 1127 : 				}
; 1128 : 			}
; 1129 : 			else 
; 1130 : 			{
; 1131 : 				if (t==ALWAYS || (t==MIGHT && ls_util_is_might(phTTS)!=FALSE)) 

  00b1b	83 f9 04	 cmp	 ecx, 4
  00b1e	74 12		 je	 SHORT $L72563
  00b20	83 f9 03	 cmp	 ecx, 3
  00b23	75 31		 jne	 SHORT $L73166
  00b25	57		 push	 edi
  00b26	e8 00 00 00 00	 call	 _ls_util_is_might
  00b2b	83 c4 04	 add	 esp, 4
  00b2e	85 c0		 test	 eax, eax
  00b30	74 24		 je	 SHORT $L73166
$L72563:

; 1132 : 				{
; 1133 : 					if (lp1 < &word[NGWORD-1]) 

  00b32	8b 44 24 1c	 mov	 eax, DWORD PTR _word$[esp+16]
  00b36	05 fe 00 00 00	 add	 eax, 254		; 000000feH
  00b3b	3b f0		 cmp	 esi, eax
  00b3d	73 09		 jae	 SHORT $L72564

; 1134 : 					{
; 1135 : 						lp1->l_ch = c;

  00b3f	66 89 2e	 mov	 WORD PTR [esi], bp

; 1136 : 						//	lp1->l_ip = NULL;
; 1137 : 						++lp1;

  00b42	83 c6 02	 add	 esi, 2

; 1138 : 						++lp2;

  00b45	83 c3 02	 add	 ebx, 2
$L72564:

; 1139 : 					}
; 1140 : 					ls_util_read_item(phTTS);

  00b48	57		 push	 edi
  00b49	e8 00 00 00 00	 call	 _ls_util_read_item
  00b4e	83 c4 04	 add	 esp, 4
  00b51	e9 b6 fe ff ff	 jmp	 $L72544
$L73166:

; 1141 : 					continue; /* goto loop; */
; 1142 : 				}
; 1143 : 			}
; 1144 : 		}
; 1145 : 		break;
; 1146 : 	}
; 1147 : 
; 1148 : 	lp1->l_ch = EOS;

  00b56	66 c7 06 00 00	 mov	 WORD PTR [esi], 0
  00b5b	5f		 pop	 edi
  00b5c	5e		 pop	 esi
  00b5d	5d		 pop	 ebp
  00b5e	5b		 pop	 ebx

; 1149 : 	// lp1->l_ip = NULL; 
; 1150 : }

  00b5f	59		 pop	 ecx
  00b60	c3		 ret	 0
_ls_task_readword ENDP
_TEXT	ENDS
EXTRN	_ls_spel_spell:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_spell_word PROC NEAR

; 1173 : 
; 1174 : 	int     speed;
; 1175 : 	PLTS_T pLts_t;
; 1176 : 	
; 1177 : 	pLts_t=phTTS->pLTSThreadData;
; 1178 : 
; 1179 : #ifdef LS1DEBUG
; 1180 : 			printf(" gok spell\n");
; 1181 : #endif
; 1182 : 		   
; 1183 : 		   
; 1184 : 	speed = FAST;/* always fast now ls_spel_spell_speed(llp, rlp);*/
; 1185 : 	pLts_t->fc_struct[pLts_t->fc_index] = FC_NOUN;
; 1186 : 	ls_spel_spell(phTTS,llp, rlp);

  00b70	8b 4c 24 0c	 mov	 ecx, DWORD PTR _rlp$[esp-4]
  00b74	8b 54 24 08	 mov	 edx, DWORD PTR _llp$[esp-4]
  00b78	56		 push	 esi
  00b79	57		 push	 edi
  00b7a	8b 7c 24 0c	 mov	 edi, DWORD PTR _phTTS$[esp+4]
  00b7e	51		 push	 ecx
  00b7f	52		 push	 edx
  00b80	57		 push	 edi
  00b81	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00b84	8b 86 bc 08 00
	00		 mov	 eax, DWORD PTR [esi+2236]
  00b8a	c7 84 86 bc 04
	00 00 00 04 00
	00		 mov	 DWORD PTR [esi+eax*4+1212], 1024 ; 00000400H
  00b95	e8 00 00 00 00	 call	 _ls_spel_spell

; 1187 : 	if (speed!=FAST && rlp!=llp+1 && pLts_t->rbphone==WBOUND)
; 1188 : 		pLts_t->rbphone = COMMA;        
; 1189 : 	/* BATS 490 MGS 10/08/1997 fix for A. B. C. problem ??? */
; 1190 : 	if (pLts_t->rbphone==PERIOD)

  00b9a	8b 86 20 0b 00
	00		 mov	 eax, DWORD PTR [esi+2848]
  00ba0	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ba3	83 f8 74	 cmp	 eax, 116		; 00000074H
  00ba6	75 0b		 jne	 SHORT $L72575

; 1191 : 	{
; 1192 : 		ls_util_send_phone(phTTS,PERIOD);

  00ba8	6a 74		 push	 116			; 00000074H
  00baa	57		 push	 edi
  00bab	e8 00 00 00 00	 call	 _ls_util_send_phone
  00bb0	83 c4 08	 add	 esp, 8
$L72575:

; 1193 : 	}
; 1194 : 	ls_task_read_next_word(phTTS);

  00bb3	57		 push	 edi
  00bb4	e8 00 00 00 00	 call	 _ls_task_read_next_word
  00bb9	83 c4 04	 add	 esp, 4
  00bbc	5f		 pop	 edi
  00bbd	5e		 pop	 esi

; 1195 : }

  00bbe	c3		 ret	 0
_ls_task_spell_word ENDP
_phTTS$ = 8
_ls_task_read_next_word PROC NEAR

; 1213 : {

  00bc0	53		 push	 ebx
  00bc1	56		 push	 esi

; 1214 : 	PLTS_T pLts_t;
; 1215 : 	
; 1216 : 	pLts_t=phTTS->pLTSThreadData;

  00bc2	8b 74 24 0c	 mov	 esi, DWORD PTR _phTTS$[esp+4]
  00bc6	57		 push	 edi
  00bc7	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]

; 1217 : #ifdef LS1DEBUG
; 1218 : 	printf(" got to out\n");
; 1219 : #endif
; 1220 : 	if (pLts_t->rbphone!=WBOUND && ls_util_is_white(&(pLts_t->citem))!=FALSE) 

  00bca	83 bb 20 0b 00
	00 6f		 cmp	 DWORD PTR [ebx+2848], 111 ; 0000006fH
  00bd1	74 66		 je	 SHORT $L72583
  00bd3	8d bb 00 09 00
	00		 lea	 edi, DWORD PTR [ebx+2304]
  00bd9	57		 push	 edi
  00bda	e8 00 00 00 00	 call	 _ls_util_is_white
  00bdf	83 c4 04	 add	 esp, 4
  00be2	85 c0		 test	 eax, eax
  00be4	74 53		 je	 SHORT $L72583

; 1221 : 	{
; 1222 : 		ls_util_send_phone(phTTS,pLts_t->rbphone);

  00be6	8b 83 20 0b 00
	00		 mov	 eax, DWORD PTR [ebx+2848]
  00bec	50		 push	 eax
  00bed	56		 push	 esi
  00bee	e8 00 00 00 00	 call	 _ls_util_send_phone

; 1223 : 		while (ls_util_is_white(&(pLts_t->citem)) != FALSE) 

  00bf3	57		 push	 edi
  00bf4	e8 00 00 00 00	 call	 _ls_util_is_white
  00bf9	83 c4 0c	 add	 esp, 12			; 0000000cH
  00bfc	85 c0		 test	 eax, eax
  00bfe	74 39		 je	 SHORT $L72583
$L72582:

; 1224 : 		{
; 1225 : 			ls_util_read_item(phTTS);

  00c00	56		 push	 esi
  00c01	e8 00 00 00 00	 call	 _ls_util_read_item

; 1226 : 			while (ls_util_is_index(&pLts_t->citem) != FALSE) 

  00c06	57		 push	 edi
  00c07	e8 00 00 00 00	 call	 _ls_util_is_index
  00c0c	83 c4 08	 add	 esp, 8
  00c0f	85 c0		 test	 eax, eax
  00c11	74 19		 je	 SHORT $L72586
$L72585:

; 1227 : 			{
; 1228 : 				ls_util_write_item(phTTS);

  00c13	56		 push	 esi
  00c14	e8 00 00 00 00	 call	 _ls_util_write_item

; 1229 : 				ls_util_read_item(phTTS);

  00c19	56		 push	 esi
  00c1a	e8 00 00 00 00	 call	 _ls_util_read_item
  00c1f	57		 push	 edi
  00c20	e8 00 00 00 00	 call	 _ls_util_is_index
  00c25	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c28	85 c0		 test	 eax, eax
  00c2a	75 e7		 jne	 SHORT $L72585
$L72586:

; 1223 : 		while (ls_util_is_white(&(pLts_t->citem)) != FALSE) 

  00c2c	57		 push	 edi
  00c2d	e8 00 00 00 00	 call	 _ls_util_is_white
  00c32	83 c4 04	 add	 esp, 4
  00c35	85 c0		 test	 eax, eax
  00c37	75 c7		 jne	 SHORT $L72582
$L72583:

; 1230 : 			}
; 1231 : 		}
; 1232 : 	}
; 1233 : 	ls_task_do_right_punct(phTTS,MISS);

  00c39	6a 00		 push	 0
  00c3b	56		 push	 esi
  00c3c	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 1234 : 	ls_task_readword(phTTS,&(pLts_t->cword[0]));

  00c41	81 c3 14 09 00
	00		 add	 ebx, 2324		; 00000914H
  00c47	53		 push	 ebx
  00c48	56		 push	 esi
  00c49	e8 00 00 00 00	 call	 _ls_task_readword
  00c4e	83 c4 10	 add	 esp, 16			; 00000010H
  00c51	5f		 pop	 edi
  00c52	5e		 pop	 esi
  00c53	5b		 pop	 ebx

; 1235 : }

  00c54	c3		 ret	 0
_ls_task_read_next_word ENDP
_TEXT	ENDS
PUBLIC	_ls_task_lookup_first_verbs
EXTRN	_whdic:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_pLts_t$ = 12
_ls_task_set_what_state PROC NEAR

; 1257 : {

  00c60	56		 push	 esi

; 1258 : 	LETTER *llp;
; 1259 : #ifdef LS1DEBUG
; 1260 : 		printf("entering ls_task_set_what_state\n");
; 1261 : #endif
; 1262 : 	if (pLts_t->wstate==UNK_WH && pLts_t->cword[0].l_ch!=EOS)

  00c61	8b 74 24 0c	 mov	 esi, DWORD PTR _pLts_t$[esp]
  00c65	33 c9		 xor	 ecx, ecx
  00c67	66 39 8e c4 08
	00 00		 cmp	 WORD PTR [esi+2244], cx
  00c6e	0f 85 8a 00 00
	00		 jne	 $L72593
  00c74	66 39 8e 14 09
	00 00		 cmp	 WORD PTR [esi+2324], cx
  00c7b	8d 86 14 09 00
	00		 lea	 eax, DWORD PTR [esi+2324]
  00c81	74 7b		 je	 SHORT $L72593

; 1263 : 	{
; 1264 : 		pLts_t->fc_index = 1;

  00c83	c7 86 bc 08 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+2236], 1

; 1265 : 		pLts_t->old_fc_index = -1;

  00c8d	c7 86 c0 08 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+2240], -1

; 1266 : 		pLts_t->fc_struct[0] = 0;

  00c97	89 8e bc 04 00
	00		 mov	 DWORD PTR [esi+1212], ecx

; 1267 : 		pLts_t->fc_struct[1] = 0;

  00c9d	89 8e c0 04 00
	00		 mov	 DWORD PTR [esi+1216], ecx

; 1268 : 		pLts_t->wstate = NOT_WH;

  00ca3	66 c7 86 c4 08
	00 00 02 00	 mov	 WORD PTR [esi+2244], 2

; 1269 : 		llp = &(pLts_t->cword[0]);
; 1270 : 		while ((lsctype[llp->l_ch]&LS) != 0)

  00cac	0f bf 10	 movsx	 edx, WORD PTR [eax]
  00caf	b1 40		 mov	 cl, 64			; 00000040H
  00cb1	84 0c 55 00 00
	00 00		 test	 BYTE PTR _lsctype[edx*2], cl
  00cb8	74 10		 je	 SHORT $L72596
$L72595:
  00cba	0f bf 50 02	 movsx	 edx, WORD PTR [eax+2]

; 1271 : 			++llp;                                              

  00cbe	83 c0 02	 add	 eax, 2
  00cc1	84 0c 55 00 00
	00 00		 test	 BYTE PTR _lsctype[edx*2], cl
  00cc8	75 f0		 jne	 SHORT $L72595
$L72596:

; 1272 : 
; 1273 : #if defined (ENGLISH) || defined (GERMAN)
; 1274 : 		if ( (ls_task_wlookup(pLts_t, llp,&whdic[0])) != NULL)

  00cca	68 00 00 00 00	 push	 OFFSET FLAT:_whdic
  00ccf	50		 push	 eax
  00cd0	56		 push	 esi
  00cd1	e8 00 00 00 00	 call	 _ls_task_wlookup
  00cd6	83 c4 0c	 add	 esp, 12			; 0000000cH
  00cd9	85 c0		 test	 eax, eax
  00cdb	74 09		 je	 SHORT $L72598

; 1275 : 		{
; 1276 : 			pLts_t->wstate = IS_WH;

  00cdd	66 c7 86 c4 08
	00 00 01 00	 mov	 WORD PTR [esi+2244], 1
$L72598:

; 1277 : 		}        
; 1278 : #ifdef ENGLISH
; 1279 : /* MGS 8/20/97 hack for stressing first words in the sentence for kerzweil */
; 1280 : 		//eab 1/1199 Modify the stress to a secondary stress which is more appropriate.
; 1281 : 		if (ls_task_lookup_first_verbs(phTTS))

  00ce6	8b 44 24 08	 mov	 eax, DWORD PTR _phTTS$[esp]
  00cea	50		 push	 eax
  00ceb	e8 00 00 00 00	 call	 _ls_task_lookup_first_verbs
  00cf0	83 c4 04	 add	 esp, 4
  00cf3	85 c0		 test	 eax, eax
  00cf5	74 2b		 je	 SHORT $L72601

; 1282 : 			return(FINISHED_WORD);

  00cf7	b8 03 00 00 00	 mov	 eax, 3
  00cfc	5e		 pop	 esi

; 1323 : }

  00cfd	c3		 ret	 0
$L72593:

; 1283 : #endif
; 1284 : #endif
; 1285 : #ifdef FRENCH
; 1286 : 		if ( tolower((char)llp->l_ch)=='q' && (llp+1)->l_ch=='u' ) 
; 1287 : 		{
; 1288 : 			pLts_t->wstate = IS_WH;
; 1289 : 		}
; 1290 : #endif
; 1291 : #ifdef SPANISH
; 1292 : 	  	if ((ls_task_wlookup(pLts_t, llp, &spwhword[0])) != NULL)
; 1293 : 			{
; 1294 : 				/*we need to look at potential legal combinations of wh
; 1295 : 					question introducers so if first word is an introducer
; 1296 : 					then firstnum !=0 and wstate is rest to UNK_wh indicating
; 1297 : 					beginning of sentence*/
; 1298 : /* 		   sendlist(cp);*/
; 1299 : 			pLts_t->wstate = IS_WH;
; 1300 : /*			goto out; */
; 1301 : 			}
; 1302 : 	  	else if (ls_task_wlookup(pLts_t, llp, &spwhword[0]) != NULL)
; 1303 : 			{
; 1304 : 			pLts_t->wstate = UNK_WH;			
; 1305 : 						/*pretend start of sentence*/
; 1306 : 						/*becuase got an intro word*/
; 1307 : 			}
; 1308 : 
; 1309 : #endif
; 1310 : 		
; 1311 : 	}   /*  if (pLts_t->wstate==UNK_WH && cword[0].l_ch!=EOS) */
; 1312 : #ifndef FRENCH
; 1313 : 	else
; 1314 : 	{
; 1315 : 		if((pLts_t->cword[0].l_ch!=SIL ) && pLts_t->fc_index != sizeof(pLts_t->fc_struct)/4)

  00cfe	66 39 8e 14 09
	00 00		 cmp	 WORD PTR [esi+2324], cx
  00d05	74 1b		 je	 SHORT $L72601
  00d07	8b 86 bc 08 00
	00		 mov	 eax, DWORD PTR [esi+2236]
  00d0d	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00d12	74 0e		 je	 SHORT $L72601

; 1316 : 		{
; 1317 : 			pLts_t->fc_index += 1;

  00d14	40		 inc	 eax
  00d15	89 86 bc 08 00
	00		 mov	 DWORD PTR [esi+2236], eax

; 1318 : 			pLts_t->fc_struct[pLts_t->fc_index] = 0;

  00d1b	89 8c 86 bc 04
	00 00		 mov	 DWORD PTR [esi+eax*4+1212], ecx
$L72601:

; 1319 : 		}
; 1320 : 	}   /*  if (pLts_t->wstate==UNK_WH && cword[0].l_ch!=EOS) */
; 1321 : #endif
; 1322 : 	return(KEEP_SEARCHING);

  00d22	33 c0		 xor	 eax, eax
  00d24	5e		 pop	 esi

; 1323 : }

  00d25	c3		 ret	 0
_ls_task_set_what_state ENDP
_llp$ = 8
_rlp$ = 12
_elp$ = 16
_ls_task_find_end_of_word PROC NEAR

; 1346 : #ifdef LS1DEBUG
; 1347 : 		printf("entering ls_task_find_end_of_word\n");
; 1348 : #endif
; 1349 : 	(*elp) = llp;

  00d30	8b 44 24 0c	 mov	 eax, DWORD PTR _elp$[esp-4]
  00d34	8b 4c 24 04	 mov	 ecx, DWORD PTR _llp$[esp-4]
  00d38	89 08		 mov	 DWORD PTR [eax], ecx

; 1350 : 	while ((*elp)->l_ch != EOS) /* find the end of the word ?? */

  00d3a	66 83 39 00	 cmp	 WORD PTR [ecx], 0
  00d3e	74 16		 je	 SHORT $L73182
$L72610:

; 1351 : 	{
; 1352 : #ifdef LS1DEBUG
; 1353 : 			printf(" %02x %c \n",(*elp)->l_ch,(*elp)->l_ch);
; 1354 : #endif   
; 1355 : 		
; 1356 : 		++(*elp);               

  00d40	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d42	83 c1 02	 add	 ecx, 2
  00d45	89 08		 mov	 DWORD PTR [eax], ecx
  00d47	66 83 39 00	 cmp	 WORD PTR [ecx], 0
  00d4b	75 f3		 jne	 SHORT $L72610

; 1357 : 	}
; 1358 : #ifdef LS1DEBUG
; 1359 : 		printf (" %02x %c \n",(*elp)->l_ch,(*elp)->l_ch);
; 1360 : #endif
; 1361 : 	
; 1362 : 	(*rlp) = (*elp);

  00d4d	8b c1		 mov	 eax, ecx
  00d4f	8b 4c 24 08	 mov	 ecx, DWORD PTR _rlp$[esp-4]
  00d53	89 01		 mov	 DWORD PTR [ecx], eax

; 1363 : 	
; 1364 : #ifdef LS1DEBUG
; 1365 : 		printf("found the end of word ");
; 1366 : 		printf("left=%u  right=%u\n",llp,*rlp);
; 1367 : #endif    
; 1368 : 
; 1369 : }

  00d55	c3		 ret	 0
$L73182:

; 1357 : 	}
; 1358 : #ifdef LS1DEBUG
; 1359 : 		printf (" %02x %c \n",(*elp)->l_ch,(*elp)->l_ch);
; 1360 : #endif
; 1361 : 	
; 1362 : 	(*rlp) = (*elp);

  00d56	8b 10		 mov	 edx, DWORD PTR [eax]
  00d58	8b 44 24 08	 mov	 eax, DWORD PTR _rlp$[esp-4]
  00d5c	89 10		 mov	 DWORD PTR [eax], edx

; 1363 : 	
; 1364 : #ifdef LS1DEBUG
; 1365 : 		printf("found the end of word ");
; 1366 : 		printf("left=%u  right=%u\n",llp,*rlp);
; 1367 : #endif    
; 1368 : 
; 1369 : }

  00d5e	c3		 ret	 0
_ls_task_find_end_of_word ENDP
_TEXT	ENDS
PUBLIC	_ls_task_fix_german_vowels
_TEXT	SEGMENT
_llp$ = 12
_rlp$ = 16
_ls_task_fix_german_vowels PROC NEAR

; 1394 : 	int ret=0;
; 1395 : 	int move=0;
; 1396 : 	LETTER *elp;
; 1397 : 	LETTER *flp;
; 1398 : 	//mgs fix for	u eab added eue fix for neue...
; 1399 : 	for (elp=llp;elp->l_ch!=EOS;elp++)

  00d60	8b 54 24 08	 mov	 edx, DWORD PTR _llp$[esp-4]
  00d64	57		 push	 edi
  00d65	33 ff		 xor	 edi, edi
  00d67	66 39 3a	 cmp	 WORD PTR [edx], di
  00d6a	0f 84 c3 00 00
	00		 je	 $L73189
  00d70	53		 push	 ebx
  00d71	55		 push	 ebp
  00d72	8b 6c 24 18	 mov	 ebp, DWORD PTR _rlp$[esp+8]
  00d76	56		 push	 esi
  00d77	b0 65		 mov	 al, 101			; 00000065H
$L72623:

; 1400 : 	{
; 1401 : 		if (ls_lower[(elp->l_ch)]=='q' && (ls_lower[((elp+1)->l_ch)]=='u'))

  00d79	0f bf 32	 movsx	 esi, WORD PTR [edx]
  00d7c	8a 8e 00 00 00
	00		 mov	 cl, BYTE PTR _ls_lower[esi]
  00d82	80 f9 71	 cmp	 cl, 113			; 00000071H
  00d85	75 15		 jne	 SHORT $L72626
  00d87	0f bf 5a 02	 movsx	 ebx, WORD PTR [edx+2]
  00d8b	80 bb 00 00 00
	00 75		 cmp	 BYTE PTR _ls_lower[ebx], 117 ; 00000075H
  00d92	75 08		 jne	 SHORT $L72626

; 1394 : 	int ret=0;
; 1395 : 	int move=0;
; 1396 : 	LETTER *elp;
; 1397 : 	LETTER *flp;
; 1398 : 	//mgs fix for	u eab added eue fix for neue...
; 1399 : 	for (elp=llp;elp->l_ch!=EOS;elp++)

  00d94	83 c2 02	 add	 edx, 2

; 1402 : 		{
; 1403 : 			elp++;
; 1404 : 			continue;

  00d97	e9 83 00 00 00	 jmp	 $L72624
$L72626:

; 1405 : 		}
; 1406 : 		if (ls_lower[(elp->l_ch)]=='e' && (ls_lower[((elp+1)->l_ch)]=='u'))

  00d9c	3a c8		 cmp	 cl, al
  00d9e	75 12		 jne	 SHORT $L72627
  00da0	0f bf 4a 02	 movsx	 ecx, WORD PTR [edx+2]
  00da4	80 b9 00 00 00
	00 75		 cmp	 BYTE PTR _ls_lower[ecx], 117 ; 00000075H
  00dab	75 05		 jne	 SHORT $L72627

; 1394 : 	int ret=0;
; 1395 : 	int move=0;
; 1396 : 	LETTER *elp;
; 1397 : 	LETTER *flp;
; 1398 : 	//mgs fix for	u eab added eue fix for neue...
; 1399 : 	for (elp=llp;elp->l_ch!=EOS;elp++)

  00dad	83 c2 02	 add	 edx, 2

; 1407 : 		{
; 1408 : 			elp++;
; 1409 : 			continue;

  00db0	eb 6d		 jmp	 SHORT $L72624
$L72627:

; 1410 : 		}
; 1411 : 		if (ls_lower[((elp+1)->l_ch)] == 'e')

  00db2	0f bf 5a 02	 movsx	 ebx, WORD PTR [edx+2]
  00db6	8d 4a 02	 lea	 ecx, DWORD PTR [edx+2]
  00db9	38 83 00 00 00
	00		 cmp	 BYTE PTR _ls_lower[ebx], al
  00dbf	75 5e		 jne	 SHORT $L72624

; 1412 : 		{
; 1413 : 			switch (elp->l_ch)
; 1414 : 			{

  00dc1	83 c6 bf	 add	 esi, -65		; ffffffbfH
  00dc4	83 fe 34	 cmp	 esi, 52			; 00000034H
  00dc7	77 56		 ja	 SHORT $L72624
  00dc9	33 db		 xor	 ebx, ebx
  00dcb	8a 9e 00 00 00
	00		 mov	 bl, BYTE PTR $L73192[esi]
  00dd1	ff 24 9d 00 00
	00 00		 jmp	 DWORD PTR $L73193[ebx*4]
$L72633:

; 1415 : 			case 'a':
; 1416 : 				elp->l_ch=(unsigned char)'ä';

  00dd8	66 c7 02 e4 00	 mov	 WORD PTR [edx], 228	; 000000e4H

; 1417 : 				move=1;
; 1418 : 				break;

  00ddd	eb 21		 jmp	 SHORT $L73188
$L72635:

; 1419 : 			case 'A':
; 1420 : 				elp->l_ch=(unsigned char)'Ä';

  00ddf	66 c7 02 c4 00	 mov	 WORD PTR [edx], 196	; 000000c4H

; 1421 : 				move=1;
; 1422 : 				break;

  00de4	eb 1a		 jmp	 SHORT $L73188
$L72637:

; 1423 : 			case 'o':
; 1424 : 				elp->l_ch=(unsigned char)'ö';

  00de6	66 c7 02 f6 00	 mov	 WORD PTR [edx], 246	; 000000f6H

; 1425 : 				move=1;
; 1426 : 				break;

  00deb	eb 13		 jmp	 SHORT $L73188
$L72639:

; 1427 : 			case 'O':
; 1428 : 				elp->l_ch=(unsigned char)'Ö';

  00ded	66 c7 02 d6 00	 mov	 WORD PTR [edx], 214	; 000000d6H

; 1429 : 				move=1;
; 1430 : 				break;

  00df2	eb 0c		 jmp	 SHORT $L73188
$L72641:

; 1431 : 			case 'u':
; 1432 : 				elp->l_ch=(unsigned char)'ü';

  00df4	66 c7 02 fc 00	 mov	 WORD PTR [edx], 252	; 000000fcH

; 1433 : 				move=1;
; 1434 : 				break;

  00df9	eb 05		 jmp	 SHORT $L73188
$L72643:

; 1435 : 			case 'U':
; 1436 : 				elp->l_ch=(unsigned char)'Ü';

  00dfb	66 c7 02 dc 00	 mov	 WORD PTR [edx], 220	; 000000dcH
$L73188:

; 1437 : 				move=1;
; 1438 : 				break;
; 1439 : 			}
; 1440 : 			if (move)
; 1441 : 			{
; 1442 : 				move=0;
; 1443 : 				ret=1;
; 1444 : 				for (flp=elp+1;flp->l_ch!=EOS;flp++)

  00e00	66 83 39 00	 cmp	 WORD PTR [ecx], 0
  00e04	bf 01 00 00 00	 mov	 edi, 1
  00e09	74 10		 je	 SHORT $L72648
$L72646:

; 1445 : 				{
; 1446 : 					flp->l_ch=(flp+1)->l_ch;

  00e0b	66 8b 71 02	 mov	 si, WORD PTR [ecx+2]
  00e0f	66 89 31	 mov	 WORD PTR [ecx], si
  00e12	83 c1 02	 add	 ecx, 2
  00e15	66 83 39 00	 cmp	 WORD PTR [ecx], 0
  00e19	75 f0		 jne	 SHORT $L72646
$L72648:

; 1447 : 				}
; 1448 : 				(*rlp)--;

  00e1b	83 45 00 fe	 add	 DWORD PTR [ebp], -2	; fffffffeH
$L72624:
  00e1f	83 c2 02	 add	 edx, 2
  00e22	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  00e26	0f 85 4d ff ff
	ff		 jne	 $L72623
  00e2c	5e		 pop	 esi
  00e2d	5d		 pop	 ebp

; 1449 : 			}
; 1450 : 		}
; 1451 : 	}
; 1452 : 	return(ret);

  00e2e	8b c7		 mov	 eax, edi
  00e30	5b		 pop	 ebx
  00e31	5f		 pop	 edi

; 1453 : }

  00e32	c3		 ret	 0
$L73189:

; 1449 : 			}
; 1450 : 		}
; 1451 : 	}
; 1452 : 	return(ret);

  00e33	8b c7		 mov	 eax, edi
  00e35	5f		 pop	 edi

; 1453 : }

  00e36	c3		 ret	 0
  00e37	90		 npad	 1
$L73193:
  00e38	00 00 00 00	 DD	 $L72635
  00e3c	00 00 00 00	 DD	 $L72639
  00e40	00 00 00 00	 DD	 $L72643
  00e44	00 00 00 00	 DD	 $L72633
  00e48	00 00 00 00	 DD	 $L72637
  00e4c	00 00 00 00	 DD	 $L72641
  00e50	00 00 00 00	 DD	 $L72624
$L73192:
  00e54	00		 DB	 0
  00e55	06		 DB	 6
  00e56	06		 DB	 6
  00e57	06		 DB	 6
  00e58	06		 DB	 6
  00e59	06		 DB	 6
  00e5a	06		 DB	 6
  00e5b	06		 DB	 6
  00e5c	06		 DB	 6
  00e5d	06		 DB	 6
  00e5e	06		 DB	 6
  00e5f	06		 DB	 6
  00e60	06		 DB	 6
  00e61	06		 DB	 6
  00e62	01		 DB	 1
  00e63	06		 DB	 6
  00e64	06		 DB	 6
  00e65	06		 DB	 6
  00e66	06		 DB	 6
  00e67	06		 DB	 6
  00e68	02		 DB	 2
  00e69	06		 DB	 6
  00e6a	06		 DB	 6
  00e6b	06		 DB	 6
  00e6c	06		 DB	 6
  00e6d	06		 DB	 6
  00e6e	06		 DB	 6
  00e6f	06		 DB	 6
  00e70	06		 DB	 6
  00e71	06		 DB	 6
  00e72	06		 DB	 6
  00e73	06		 DB	 6
  00e74	03		 DB	 3
  00e75	06		 DB	 6
  00e76	06		 DB	 6
  00e77	06		 DB	 6
  00e78	06		 DB	 6
  00e79	06		 DB	 6
  00e7a	06		 DB	 6
  00e7b	06		 DB	 6
  00e7c	06		 DB	 6
  00e7d	06		 DB	 6
  00e7e	06		 DB	 6
  00e7f	06		 DB	 6
  00e80	06		 DB	 6
  00e81	06		 DB	 6
  00e82	04		 DB	 4
  00e83	06		 DB	 6
  00e84	06		 DB	 6
  00e85	06		 DB	 6
  00e86	06		 DB	 6
  00e87	06		 DB	 6
  00e88	05		 DB	 5
_ls_task_fix_german_vowels ENDP
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_spell_mode PROC NEAR

; 1479 : {

  00e90	56		 push	 esi

; 1480 : 	/*
; 1481 : 	 * Word spelling.
; 1482 : 	 * A new feature for AT&T - IS.
; 1483 : 	 * Spell the word using the fast spelling speed.
; 1484 : 	 * These is some special code in "ls_task_do_right_punct" that
; 1485 : 	 * helps out word spelling, by speaking " "
; 1486 : 	 * (between words) as COMMA.
; 1487 : 	 */  
; 1488 : 	PLTS_T  pLts_t;
; 1489 : 	PKSD_T  pKsd_t;
; 1490 : 
; 1491 : 	pLts_t = phTTS->pLTSThreadData;

  00e91	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  00e95	57		 push	 edi

; 1492 : 	pKsd_t = phTTS->pKernelShareData;   
; 1493 : 
; 1494 : #ifdef LS1DEBUG
; 1495 : 		printf("entering ls_task_spell_mode\n");
; 1496 : #endif
; 1497 : 	if ((pKsd_t->modeflag&MODE_SPELL)!=0) 

  00e96	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00e99	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00e9c	f6 80 c0 03 00
	00 10		 test	 BYTE PTR [eax+960], 16	; 00000010H
  00ea3	74 30		 je	 SHORT $L72658

; 1498 : 	{
; 1499 : 
; 1500 : #ifdef LS1DEBUG
; 1501 : 		printf(" mode spell spell\n");
; 1502 : #endif
; 1503 : 
; 1504 : 		ls_spel_spell(phTTS,llp, rlp);

  00ea5	8b 4c 24 14	 mov	 ecx, DWORD PTR _rlp$[esp+4]
  00ea9	8b 54 24 10	 mov	 edx, DWORD PTR _llp$[esp+4]
  00ead	51		 push	 ecx
  00eae	52		 push	 edx
  00eaf	56		 push	 esi
  00eb0	e8 00 00 00 00	 call	 _ls_spel_spell

; 1505 : #ifndef FRENCH
; 1506 : 		ls_task_do_right_punct(phTTS,MISS);

  00eb5	6a 00		 push	 0
  00eb7	56		 push	 esi
  00eb8	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 1507 : 		ls_task_readword(phTTS,&(pLts_t->cword[0]));

  00ebd	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  00ec3	57		 push	 edi
  00ec4	56		 push	 esi
  00ec5	e8 00 00 00 00	 call	 _ls_task_readword
  00eca	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1508 : 
; 1509 : 		return(LS_TASK_LOOP);

  00ecd	b8 01 00 00 00	 mov	 eax, 1
  00ed2	5f		 pop	 edi
  00ed3	5e		 pop	 esi

; 1516 : }

  00ed4	c3		 ret	 0
$L72658:
  00ed5	5f		 pop	 edi

; 1510 : #endif
; 1511 : #ifdef FRENCH
; 1512 : 		return 3;
; 1513 : #endif
; 1514 : 	}                  
; 1515 : 	return(KEEP_SEARCHING);

  00ed6	33 c0		 xor	 eax, eax
  00ed8	5e		 pop	 esi

; 1516 : }

  00ed9	c3		 ret	 0
_ls_task_spell_mode ENDP
_TEXT	ENDS
EXTRN	_sdic:BYTE
EXTRN	_ls_util_send_phone_list:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_ls_task_minidic_search PROC NEAR

; 1544 : #if (defined ENGLISH) || (defined SPANISH)
; 1545 : 	char    *cp;
; 1546 : 	PLTS_T  pLts_t;
; 1547 : 	PKSD_T  pKsd_t;
; 1548 : 
; 1549 : 	pLts_t = phTTS->pLTSThreadData;
; 1550 : 	pKsd_t = phTTS->pKernelShareData;   
; 1551 : #ifdef LS1DEBUG
; 1552 : 		printf("entering ls_task_minidic_search\n");
; 1553 : #endif
; 1554 : 	if ( (cp = (char *)ls_task_wlookup(pLts_t, llp,&sdic[0])) != NULL)

  00ee0	8b 44 24 08	 mov	 eax, DWORD PTR _llp$[esp-4]
  00ee4	56		 push	 esi
  00ee5	57		 push	 edi
  00ee6	8b 7c 24 0c	 mov	 edi, DWORD PTR _phTTS$[esp+4]
  00eea	68 00 00 00 00	 push	 OFFSET FLAT:_sdic
  00eef	50		 push	 eax
  00ef0	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00ef3	56		 push	 esi
  00ef4	e8 00 00 00 00	 call	 _ls_task_wlookup
  00ef9	83 c4 0c	 add	 esp, 12			; 0000000cH
  00efc	85 c0		 test	 eax, eax
  00efe	74 23		 je	 SHORT $L72671

; 1555 : 	{       /*eab mini dictionary lookup */
; 1556 : 		ls_util_send_phone_list(phTTS,cp);

  00f00	50		 push	 eax
  00f01	57		 push	 edi
  00f02	e8 00 00 00 00	 call	 _ls_util_send_phone_list
  00f07	83 c4 08	 add	 esp, 8

; 1557 : 		pLts_t->lbphone=WBOUND;

  00f0a	b8 6f 00 00 00	 mov	 eax, 111		; 0000006fH
  00f0f	89 86 1c 0b 00
	00		 mov	 DWORD PTR [esi+2844], eax

; 1558 : 		pLts_t->rbphone=WBOUND;

  00f15	89 86 20 0b 00
	00		 mov	 DWORD PTR [esi+2848], eax
  00f1b	5f		 pop	 edi

; 1559 : 		return(FINISHED_WORD);

  00f1c	b8 03 00 00 00	 mov	 eax, 3
  00f21	5e		 pop	 esi

; 1563 : }

  00f22	c3		 ret	 0
$L72671:
  00f23	5f		 pop	 edi

; 1560 : 	}
; 1561 : #endif
; 1562 : 	return(KEEP_SEARCHING);

  00f24	33 c0		 xor	 eax, eax
  00f26	5e		 pop	 esi

; 1563 : }

  00f27	c3		 ret	 0
_ls_task_minidic_search ENDP
_TEXT	ENDS
EXTRN	_ls_math_do_math:NEAR
_TEXT	SEGMENT
_pKsd_t$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_math_mode PROC NEAR

; 1590 : 	if (llp+1==rlp && (pKsd_t->modeflag & MODE_MATH))   

  00f30	8b 4c 24 08	 mov	 ecx, DWORD PTR _llp$[esp-4]
  00f34	8b 54 24 0c	 mov	 edx, DWORD PTR _rlp$[esp-4]
  00f38	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]
  00f3b	3b c2		 cmp	 eax, edx
  00f3d	75 23		 jne	 SHORT $L72681
  00f3f	8b 44 24 04	 mov	 eax, DWORD PTR _pKsd_t$[esp-4]
  00f43	f6 80 c0 03 00
	00 04		 test	 BYTE PTR [eax+960], 4
  00f4a	74 16		 je	 SHORT $L72681

; 1591 : 	{
; 1592 : 		if (ls_math_do_math(pKsd_t,(unsigned char )llp->l_ch)!=FALSE)

  00f4c	8a 09		 mov	 cl, BYTE PTR [ecx]
  00f4e	51		 push	 ecx
  00f4f	50		 push	 eax
  00f50	e8 00 00 00 00	 call	 _ls_math_do_math
  00f55	83 c4 08	 add	 esp, 8
  00f58	85 c0		 test	 eax, eax
  00f5a	74 06		 je	 SHORT $L72681

; 1593 : 			return(FINISHED_WORD);

  00f5c	b8 03 00 00 00	 mov	 eax, 3

; 1596 : }

  00f61	c3		 ret	 0
$L72681:

; 1594 : 	}
; 1595 : 	return(KEEP_SEARCHING);

  00f62	33 c0		 xor	 eax, eax

; 1596 : }

  00f64	c3		 ret	 0
_ls_task_math_mode ENDP
_TEXT	ENDS
EXTRN	_ls_util_lookup:NEAR
EXTRN	_ls_util_is_dot:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_pLts_t$ = 8
_ls_task_dictionary_search PROC NEAR

; 1658 : {

  00f70	53		 push	 ebx

; 1659 : 	int flag;
; 1660 : 
; 1661 : #ifdef WORK_IN_PROGRESS
; 1662 : 	int i, count;
; 1663 : #endif
; 1664 : 
; 1665 : 	int context;
; 1666 : 	char    *cp;
; 1667 : 	PLTS_T pLts_t;
; 1668 : 	
; 1669 : 	pLts_t = phTTS->pLTSThreadData;
; 1670 : 
; 1671 : #ifdef LS1DEBUG
; 1672 : 		printf("entering ls_task_dictionary_search\n");
; 1673 : #endif
; 1674 : 
; 1675 : 	/*
; 1676 : 	 * Before you do *anything*, look up the word
; 1677 : 	 * in the dictionaries. This gives the client the ability
; 1678 : 	 * to override almost any built in rules (the only rules that
; 1679 : 	 * must be used are the word framing rules). There are
; 1680 : 	 * two big cases. If the word is at least 2 characters long,
; 1681 : 	 * and the last character is a ".", then look up the root
; 1682 : 	 * with the "." stripped (this is the "Gov.." case). There
; 1683 : 	 * is no additional processing. Else check if the next
; 1684 : 	 * character is a "."; if there is an abbreviation hit then
; 1685 : 	 * the "." has to be eaten.
; 1686 : 	 */
; 1687 : 
; 1688 : 	/* 
; 1689 : 	 * The dictionary uses the fact that it never gets passed a word
; 1690 : 	 *	with a space at the bigging to store items that are to be spelled
; 1691 : 	 *	in the spell routine but don't want to hit here such as numbers.
; 1692 : 	 *	with numbers it does a ls_task_lookahead to see if the next item is in
; 1693 : 	 *	nabtab
; 1694 : 	 */
; 1695 : 
; 1696 : #ifdef LS1DEBUG
; 1697 : 	printf("%c %02x -- %c %02x\n",llp->l_ch,llp->l_ch,(llp+1)->l_ch,(llp+1)->l_ch);
; 1698 : #endif
; 1699 : 
; 1700 : 	if (rlp>=llp+2 && (rlp-1)->l_ch=='.') 

  00f71	8b 5c 24 0c	 mov	 ebx, DWORD PTR _llp$[esp]
  00f75	55		 push	 ebp
  00f76	8b 6c 24 14	 mov	 ebp, DWORD PTR _rlp$[esp+4]
  00f7a	56		 push	 esi
  00f7b	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  00f7f	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00f82	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00f85	3b e8		 cmp	 ebp, eax
  00f87	89 4c 24 10	 mov	 DWORD PTR _pLts_t$[esp+8], ecx
  00f8b	72 3f		 jb	 SHORT $L72693
  00f8d	66 83 7d fe 2e	 cmp	 WORD PTR [ebp-2], 46	; 0000002eH
  00f92	8d 45 fe	 lea	 eax, DWORD PTR [ebp-2]
  00f95	75 35		 jne	 SHORT $L72693

; 1701 : 	{	
; 1702 : 		if ((flag = ls_util_lookup(phTTS,llp, rlp-1, FABBREV)) != MISS) 

  00f97	6a 01		 push	 1
  00f99	50		 push	 eax
  00f9a	53		 push	 ebx
  00f9b	56		 push	 esi
  00f9c	e8 00 00 00 00	 call	 _ls_util_lookup
  00fa1	83 c4 10	 add	 esp, 16			; 00000010H
  00fa4	85 c0		 test	 eax, eax
  00fa6	74 58		 je	 SHORT $L72697

; 1703 : 		{
; 1704 : #ifndef FRENCH
; 1705 : 			ls_task_do_right_punct(phTTS,flag);

  00fa8	50		 push	 eax
  00fa9	56		 push	 esi
  00faa	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 1706 : 			ls_task_readword(phTTS,&(pLts_t->cword[0]));

  00faf	8b 4c 24 18	 mov	 ecx, DWORD PTR _pLts_t$[esp+16]
  00fb3	81 c1 14 09 00
	00		 add	 ecx, 2324		; 00000914H
  00fb9	51		 push	 ecx
  00fba	56		 push	 esi
  00fbb	e8 00 00 00 00	 call	 _ls_task_readword
  00fc0	83 c4 10	 add	 esp, 16			; 00000010H

; 1707 : 			return LS_TASK_LOOP;

  00fc3	b8 01 00 00 00	 mov	 eax, 1
  00fc8	5e		 pop	 esi
  00fc9	5d		 pop	 ebp
  00fca	5b		 pop	 ebx

; 1822 : }

  00fcb	c3		 ret	 0
$L72693:
  00fcc	57		 push	 edi

; 1708 : #endif
; 1709 : 
; 1710 : #ifdef FRENCH
; 1711 : 	return 3;
; 1712 : #endif
; 1713 : 		}
; 1714 : 	} 
; 1715 : 	else 
; 1716 : 	{
; 1717 : #ifdef FRENCH
; 1718 : 	ls_task_categ_gram(phTTS);
; 1719 : #endif
; 1720 : 	context = FIRST;
; 1721 : 	if (ls_util_is_dot(pLts_t) != FALSE)

  00fcd	51		 push	 ecx
  00fce	33 ff		 xor	 edi, edi
  00fd0	e8 00 00 00 00	 call	 _ls_util_is_dot
  00fd5	83 c4 04	 add	 esp, 4
  00fd8	85 c0		 test	 eax, eax
  00fda	74 05		 je	 SHORT $L72696

; 1722 : 	{
; 1723 : 		context = FABBREV;

  00fdc	bf 01 00 00 00	 mov	 edi, 1
$L72696:

; 1724 : 	}
; 1725 : 	/* xxxx eab 9/94 added to take care of 5 sq. ft. double
; 1726 : 	   abbrev in context*/
; 1727 : 	/* Change 7/11/96 to fix 5 sq. ft. problem by removing pLts_t->isnumab.  GL */
; 1728 : 	/* GL 11/21/1996, set the handling approach based on the language */
; 1729 : 	/* GL 02/25/1997, restore pLts_t->isnumabr back  */  
; 1730 : #ifndef GWMICRO
; 1731 : #ifdef ENGLISH
; 1732 : 	if(pLts_t->isnumabr && context == FABBREV &&
; 1733 : 		(cp=(char *)ls_task_wlookup (pLts_t, &(pLts_t->cword[0]), &nabtab[0])) != NULL)
; 1734 : #endif
; 1735 : #ifdef SPANISH
; 1736 : 	/* GL 10/05/1998, Handle Spanish number abbreviation like German */
; 1737 : 	/* if(pLts_t->isnumabr && context == FABBREV && */
; 1738 : 	if(pLts_t->isnumabr &&
; 1739 : 		(cp=(char *)ls_task_wlookup (pLts_t, &(pLts_t->cword[0]), &nabtab[0])) != NULL)
; 1740 : #endif
; 1741 : #ifdef GERMAN
; 1742 : 	if(pLts_t->isnumabr &&
; 1743 : 		(cp=(char *)ls_task_wlookup (pLts_t, &(pLts_t->cword[0]), &nabtab[0])) != NULL)
; 1744 : #endif
; 1745 : #ifdef FRENCH
; 1746 : 	if (0)
; 1747 : #endif
; 1748 : 	{
; 1749 : 		if(pLts_t->pflag != FALSE)      /* Pick right form.     */
; 1750 : 		{
; 1751 : 			while (*cp++ != SIL);
; 1752 : 		}
; 1753 : 		ls_util_send_phone_list(phTTS,cp);  /* Send abbreviation.    */
; 1754 : 		ls_util_read_item(phTTS);           /* Eat up the ".".      */
; 1755 : 		ls_task_do_right_punct(phTTS,MISS);
; 1756 : 		ls_task_readword(phTTS,&(pLts_t->cword[0]));    /* Advance, continue.   */
; 1757 : 		return(LS_TASK_LOOP);
; 1758 : 		}
; 1759 : #endif		
; 1760 : 		if ((flag=ls_util_lookup(phTTS,llp, rlp, context)) != MISS) 

  00fe1	57		 push	 edi
  00fe2	55		 push	 ebp
  00fe3	53		 push	 ebx
  00fe4	56		 push	 esi
  00fe5	e8 00 00 00 00	 call	 _ls_util_lookup
  00fea	83 c4 10	 add	 esp, 16			; 00000010H
  00fed	85 c0		 test	 eax, eax
  00fef	5f		 pop	 edi
  00ff0	74 0e		 je	 SHORT $L72697

; 1761 : 		{
; 1762 : 			if (flag == ABBREV)     /* Need to gobble up    */

  00ff2	83 f8 02	 cmp	 eax, 2
  00ff5	75 0f		 jne	 SHORT $L72698

; 1763 : 			{
; 1764 : 				ls_util_read_item(phTTS);                     /* the "." here.        */

  00ff7	56		 push	 esi
  00ff8	e8 00 00 00 00	 call	 _ls_util_read_item
  00ffd	83 c4 04	 add	 esp, 4
$L72697:
  01000	5e		 pop	 esi
  01001	5d		 pop	 ebp

; 1773 : #endif
; 1774 : #ifdef FRENCH
; 1775 : 		return FINISHED_WORD;
; 1776 : #endif
; 1777 : 		}
; 1778 : 	}
; 1779 : 	/*eab 1/5/99 temporary code for ce to reduce dictionary
; 1780 : 	will get more eligant with the re-write*/
; 1781 : 
; 1782 : 	/* this is fir a class of imxxx words */
; 1783 : #ifdef nevermore	
; 1784 : 	if( ( (llp->l_ch,llp->l_ch == 'i') && 
; 1785 : 		(llp+1)->l_ch == 'm') &&
; 1786 : 		( (llp+2)->l_ch == 'p'||
; 1787 : 		(llp+2)->l_ch == 'b' )
; 1788 : 		)
; 1789 : 	{
; 1790 : 		ls_util_send_phone(phTTS,IX);
; 1791 : 		ls_util_send_phone(phTTS,M);
; 1792 : 		for(i=0;i<NGWORD;i++)
; 1793 : 		{
; 1794 : 			pLts_t->cword[i] = pLts_t->cword[i+2];
; 1795 : 		}
; 1796 : 		return(-2);
; 1797 : 	}
; 1798 : #endif
; 1799 : 
; 1800 : 		/*eab 1/5/99 temporary code for ce to reduce dictionary
; 1801 : 	will get more eligant with the re-write*/
; 1802 : #ifdef WORK_IN_PROGRESS
; 1803 : 
; 1804 : 	if ( (cp = (char *)ls_task_prelookup(pLts_t, llp, &count,&predic[0])) != NULL)
; 1805 : 	{       /*eab mini dictionary lookup */
; 1806 : 		ls_util_send_phone_list(phTTS,cp);
; 1807 : 		pLts_t->lbphone = WBOUND;
; 1808 : 		// pLts_t->rbphone = WBOUND;
; 1809 : 		// ls_util_send_phone(phTTS,IX);
; 1810 : 		// ls_util_send_phone(phTTS,N);
; 1811 : 		for(i=0; i<NGWORD; i++)
; 1812 : 		{
; 1813 : 			pLts_t->cword[i] = pLts_t->cword[i+count];
; 1814 : 			if(pLts_t->cword[i+2]. l_ch == '0')
; 1815 : 				break;
; 1816 : 		}
; 1817 : 		return(-count);
; 1818 : 	}
; 1819 : #endif 
; 1820 : 
; 1821 : 	return (KEEP_SEARCHING);

  01002	33 c0		 xor	 eax, eax
  01004	5b		 pop	 ebx

; 1822 : }

  01005	c3		 ret	 0
$L72698:

; 1765 : #ifdef GWMICRO
; 1766 : 				return(KEEP_SEARCHING);
; 1767 : #endif
; 1768 : 			}
; 1769 : #ifndef FRENCH
; 1770 : 		ls_task_do_right_punct(phTTS,flag);

  01006	50		 push	 eax
  01007	56		 push	 esi
  01008	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 1771 : 		ls_task_readword(phTTS,&(pLts_t->cword[0]));

  0100d	8b 54 24 18	 mov	 edx, DWORD PTR _pLts_t$[esp+16]
  01011	81 c2 14 09 00
	00		 add	 edx, 2324		; 00000914H
  01017	52		 push	 edx
  01018	56		 push	 esi
  01019	e8 00 00 00 00	 call	 _ls_task_readword
  0101e	83 c4 10	 add	 esp, 16			; 00000010H

; 1772 : 		return(LS_TASK_LOOP);

  01021	b8 01 00 00 00	 mov	 eax, 1
  01026	5e		 pop	 esi
  01027	5d		 pop	 ebp
  01028	5b		 pop	 ebx

; 1822 : }

  01029	c3		 ret	 0
_ls_task_dictionary_search ENDP
_pLts_t$ = 8
_llp$ = 12
_ls_task_strip_left_punctuation PROC NEAR

; 1845 : 	/*
; 1846 : 	 * Pull off all left and
; 1847 : 	 * right enclosing punctuation. We only pull one
; 1848 : 	 * layer, so ((a)) gets spelled (it seems like the right
; 1849 : 	 * thing). Keep track of any required pauses. Also watch
; 1850 : 	 * for things like "I went (last year?) to the show".
; 1851 : 	 * Shuffle the "?" to the right spot. We don't shuffle the
; 1852 : 	 * ".", because it might be part of an abbreviation,
; 1853 : 	 * and abbreviations are more common than imbedded
; 1854 : 	 * periods.
; 1855 : 	 */
; 1856 : #ifdef LS1DEBUG
; 1857 : 		printf("entering ls_task_strip_left_punctuation\n");
; 1858 : #endif
; 1859 : 	 pLts_t->lflag  = 0;                             /* Clear all flags.     */

  01030	8b 4c 24 04	 mov	 ecx, DWORD PTR _pLts_t$[esp-4]

; 1860 : 
; 1861 : #ifdef LS1DEBUG
; 1862 : 	printf("before punctuation stripping ");
; 1863 : 	printf("left=%u  right=%u\n",(*llp),rlp);
; 1864 : #endif
; 1865 : 	pLts_t->lbphone = WBOUND;

  01034	b8 6f 00 00 00	 mov	 eax, 111		; 0000006fH
  01039	89 81 1c 0b 00
	00		 mov	 DWORD PTR [ecx+2844], eax

; 1866 : 	pLts_t->rbphone = WBOUND;

  0103f	89 81 20 0b 00
	00		 mov	 DWORD PTR [ecx+2848], eax

; 1867 : 	/* Change this "while" to an "if" to strip only 1 layer.        */
; 1868 : 	while ((lsctype[(*llp)->l_ch]&LS) != 0)

  01045	8b 44 24 08	 mov	 eax, DWORD PTR _llp$[esp-4]
  01049	c7 81 f8 08 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+2296], 0
  01053	8b 10		 mov	 edx, DWORD PTR [eax]
  01055	0f bf 12	 movsx	 edx, WORD PTR [edx]
  01058	f6 04 55 00 00
	00 00 40	 test	 BYTE PTR _lsctype[edx*2], 64 ; 00000040H
  01060	74 3c		 je	 SHORT $L72708
$L72707:

; 1869 : 	{
; 1870 : #ifdef LS1DEBUG
; 1871 : 			printf("in left stripping loop %c\n",(*llp)->l_ch);
; 1872 : #endif
; 1873 : 		pLts_t->lflag |= LSTRIP;

  01062	8b 91 f8 08 00
	00		 mov	 edx, DWORD PTR [ecx+2296]
  01068	83 ca 01	 or	 edx, 1
  0106b	89 91 f8 08 00
	00		 mov	 DWORD PTR [ecx+2296], edx

; 1874 : 		if ((lsctype[(*llp)->l_ch]&FB) != 0)

  01071	8b 10		 mov	 edx, DWORD PTR [eax]
  01073	0f bf 12	 movsx	 edx, WORD PTR [edx]
  01076	f6 04 55 01 00
	00 00 01	 test	 BYTE PTR _lsctype[edx*2+1], 1
  0107e	74 0a		 je	 SHORT $L72709

; 1875 : 		{
; 1876 : 			pLts_t->lbphone = COMMA;

  01080	c7 81 1c 0b 00
	00 73 00 00 00	 mov	 DWORD PTR [ecx+2844], 115 ; 00000073H
$L72709:

; 1877 : 		}
; 1878 : 		++(*llp);

  0108a	8b 10		 mov	 edx, DWORD PTR [eax]
  0108c	83 c2 02	 add	 edx, 2
  0108f	89 10		 mov	 DWORD PTR [eax], edx
  01091	0f bf 12	 movsx	 edx, WORD PTR [edx]
  01094	f6 04 55 00 00
	00 00 40	 test	 BYTE PTR _lsctype[edx*2], 64 ; 00000040H
  0109c	75 c4		 jne	 SHORT $L72707
$L72708:

; 1879 : 	}
; 1880 : }           

  0109e	c3		 ret	 0
_ls_task_strip_left_punctuation ENDP
_pLts_t$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_strip_right_punctuation PROC NEAR

; 1902 : #ifdef LS1DEBUG
; 1903 : 		printf("entering ls_task_strip_right_punctuation\n");
; 1904 : #endif
; 1905 : 	/* Change this "while" to an "if" to strip only 1 layer.        */
; 1906 : 	while ((*rlp)!=llp && (lsctype[((*rlp)-1)->l_ch]&RS)!=0) 

  010a0	8b 44 24 0c	 mov	 eax, DWORD PTR _rlp$[esp-4]
  010a4	55		 push	 ebp
  010a5	56		 push	 esi
  010a6	57		 push	 edi
  010a7	8b 10		 mov	 edx, DWORD PTR [eax]
  010a9	8b 7c 24 14	 mov	 edi, DWORD PTR _llp$[esp+8]
  010ad	3b d7		 cmp	 edx, edi
  010af	0f 84 8f 00 00
	00		 je	 $L72719
  010b5	8b 4c 24 10	 mov	 ecx, DWORD PTR _pLts_t$[esp+8]
  010b9	bd 73 00 00 00	 mov	 ebp, 115		; 00000073H
$L72718:
  010be	0f bf 52 fe	 movsx	 edx, WORD PTR [edx-2]
  010c2	f6 04 55 00 00
	00 00 80	 test	 BYTE PTR _lsctype[edx*2], 128 ; 00000080H
  010ca	74 78		 je	 SHORT $L72719

; 1907 : 	{
; 1908 : #ifdef LS1DEBUG
; 1909 : 			printf("in right stripping loop %c\n",llp->l_ch);
; 1910 : #endif
; 1911 : 		pLts_t->lflag |= RSTRIP;

  010cc	8b b1 f8 08 00
	00		 mov	 esi, DWORD PTR [ecx+2296]
  010d2	83 ce 02	 or	 esi, 2
  010d5	89 b1 f8 08 00
	00		 mov	 DWORD PTR [ecx+2296], esi

; 1912 : 		--(*rlp);

  010db	8b 10		 mov	 edx, DWORD PTR [eax]
  010dd	83 c2 fe	 add	 edx, -2			; fffffffeH
  010e0	89 10		 mov	 DWORD PTR [eax], edx

; 1913 : 		if ((lsctype[(*rlp)->l_ch]&FB) != 0)

  010e2	0f bf 12	 movsx	 edx, WORD PTR [edx]
  010e5	f6 04 55 01 00
	00 00 01	 test	 BYTE PTR _lsctype[edx*2+1], 1
  010ed	74 06		 je	 SHORT $L72720

; 1914 : 		{
; 1915 : 			pLts_t->rbphone = COMMA;

  010ef	89 a9 20 0b 00
	00		 mov	 DWORD PTR [ecx+2848], ebp
$L72720:

; 1916 : 		}
; 1917 : 		if ((*rlp) > llp+1) 

  010f5	8b 10		 mov	 edx, DWORD PTR [eax]
  010f7	8d 77 02	 lea	 esi, DWORD PTR [edi+2]
  010fa	3b d6		 cmp	 edx, esi
  010fc	76 3c		 jbe	 SHORT $L72723

; 1918 : 		{
; 1919 : 			switch (((*rlp)-1)->l_ch) 
; 1920 : 			{

  010fe	0f bf 52 fe	 movsx	 edx, WORD PTR [edx-2]
  01102	8d 72 df	 lea	 esi, DWORD PTR [edx-33]
  01105	83 fe 1e	 cmp	 esi, 30			; 0000001eH
  01108	77 30		 ja	 SHORT $L72723
  0110a	33 d2		 xor	 edx, edx
  0110c	8a 96 00 00 00
	00		 mov	 dl, BYTE PTR $L73204[esi]
  01112	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L73205[edx*4]
$L72726:

; 1921 : 			case '?':
; 1922 : 				pLts_t->rbphone = QUEST;

  01119	c7 81 20 0b 00
	00 75 00 00 00	 mov	 DWORD PTR [ecx+2848], 117 ; 00000075H

; 1923 : 				--(*rlp);
; 1924 : 				break;

  01123	eb 12		 jmp	 SHORT $L73203
$L72727:

; 1925 : 
; 1926 : 			case '!':
; 1927 : 				pLts_t->rbphone = EXCLAIM;

  01125	c7 81 20 0b 00
	00 76 00 00 00	 mov	 DWORD PTR [ecx+2848], 118 ; 00000076H

; 1928 : 				--(*rlp);
; 1929 : 				break;

  0112f	eb 06		 jmp	 SHORT $L73203
$L72728:

; 1930 : 
; 1931 : 			case ',':
; 1932 : 			case ':':
; 1933 : 			case ';':
; 1934 : 				pLts_t->rbphone = COMMA;

  01131	89 a9 20 0b 00
	00		 mov	 DWORD PTR [ecx+2848], ebp
$L73203:

; 1935 : 				--(*rlp);

  01137	83 00 fe	 add	 DWORD PTR [eax], -2	; fffffffeH
$L72723:
  0113a	8b 10		 mov	 edx, DWORD PTR [eax]
  0113c	3b d7		 cmp	 edx, edi
  0113e	0f 85 7a ff ff
	ff		 jne	 $L72718
$L72719:
  01144	5f		 pop	 edi
  01145	5e		 pop	 esi
  01146	5d		 pop	 ebp

; 1936 : 				break;
; 1937 : 			}
; 1938 : 		}
; 1939 : 	}
; 1940 : }

  01147	c3		 ret	 0
$L73205:
  01148	00 00 00 00	 DD	 $L72727
  0114c	00 00 00 00	 DD	 $L72728
  01150	00 00 00 00	 DD	 $L72726
  01154	00 00 00 00	 DD	 $L72723
$L73204:
  01158	00		 DB	 0
  01159	03		 DB	 3
  0115a	03		 DB	 3
  0115b	03		 DB	 3
  0115c	03		 DB	 3
  0115d	03		 DB	 3
  0115e	03		 DB	 3
  0115f	03		 DB	 3
  01160	03		 DB	 3
  01161	03		 DB	 3
  01162	03		 DB	 3
  01163	01		 DB	 1
  01164	03		 DB	 3
  01165	03		 DB	 3
  01166	03		 DB	 3
  01167	03		 DB	 3
  01168	03		 DB	 3
  01169	03		 DB	 3
  0116a	03		 DB	 3
  0116b	03		 DB	 3
  0116c	03		 DB	 3
  0116d	03		 DB	 3
  0116e	03		 DB	 3
  0116f	03		 DB	 3
  01170	03		 DB	 3
  01171	01		 DB	 1
  01172	01		 DB	 1
  01173	03		 DB	 3
  01174	03		 DB	 3
  01175	03		 DB	 3
  01176	02		 DB	 2
_ls_task_strip_right_punctuation ENDP
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_lp1$ = 20
_lp2$ = 24
_ls_task_spell_all_punct PROC NEAR

; 1968 : 	PLTS_T pLts_t;
; 1969 : 	pLts_t = phTTS->pLTSThreadData;
; 1970 : #ifdef LS1DEBUG
; 1971 : 		printf("entering ls_task_spell_all_punct\n");
; 1972 : #endif
; 1973 : 	if (llp == rlp) 

  01180	8b 44 24 08	 mov	 eax, DWORD PTR _llp$[esp-4]
  01184	8b 4c 24 0c	 mov	 ecx, DWORD PTR _rlp$[esp-4]
  01188	56		 push	 esi
  01189	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  0118d	57		 push	 edi
  0118e	3b c1		 cmp	 eax, ecx
  01190	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  01193	75 30		 jne	 SHORT $L72741

; 1974 : 	{                       /* Null word            */
; 1975 : 		ls_spel_spell(phTTS,lp1, lp2);  /* Always slowly.       */

  01195	8b 4c 24 1c	 mov	 ecx, DWORD PTR _lp2$[esp+4]
  01199	8b 54 24 18	 mov	 edx, DWORD PTR _lp1$[esp+4]
  0119d	51		 push	 ecx
  0119e	52		 push	 edx
  0119f	56		 push	 esi
  011a0	e8 00 00 00 00	 call	 _ls_spel_spell

; 1976 : #ifdef LS1DEBUG
; 1977 : 			printf("null word spell\n");
; 1978 : #endif
; 1979 : #ifndef FRENCH
; 1980 : 		ls_task_do_right_punct(phTTS,MISS);

  011a5	6a 00		 push	 0
  011a7	56		 push	 esi
  011a8	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 1981 : 		ls_task_readword(phTTS,&(pLts_t->cword[0]));

  011ad	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  011b3	57		 push	 edi
  011b4	56		 push	 esi
  011b5	e8 00 00 00 00	 call	 _ls_task_readword
  011ba	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1982 : 
; 1983 : 		return(LS_TASK_LOOP);

  011bd	b8 01 00 00 00	 mov	 eax, 1
  011c2	5f		 pop	 edi
  011c3	5e		 pop	 esi

; 2004 : }

  011c4	c3		 ret	 0
$L72741:

; 1984 : #endif
; 1985 : #ifdef FRENCH
; 1986 : 		return 3;
; 1987 : #endif
; 1988 : 	}
; 1989 : 	/*
; 1990 : 	 * Deal with any side effects of the
; 1991 : 	 * stripped left hand end punctuation marks.
; 1992 : 	 * They will never be looked at again.
; 1993 : 	 */
; 1994 : 
; 1995 : 	if (pLts_t->lbphone != WBOUND)

  011c5	8b 87 1c 0b 00
	00		 mov	 eax, DWORD PTR [edi+2844]
  011cb	83 f8 6f	 cmp	 eax, 111		; 0000006fH
  011ce	74 0a		 je	 SHORT $L72742

; 1996 : 		ls_util_send_phone(phTTS,pLts_t->lbphone);

  011d0	50		 push	 eax
  011d1	56		 push	 esi
  011d2	e8 00 00 00 00	 call	 _ls_util_send_phone
  011d7	83 c4 08	 add	 esp, 8
$L72742:
  011da	5f		 pop	 edi

; 1997 : 
; 1998 : #ifdef LS1DEBUG
; 1999 : 	printf("after punctuation stripping ");
; 2000 : 	printf("left=%u  right=%u\n",llp,rlp);
; 2001 : #endif
; 2002 : 
; 2003 : 	return(KEEP_SEARCHING);

  011db	33 c0		 xor	 eax, eax
  011dd	5e		 pop	 esi

; 2004 : }

  011de	c3		 ret	 0
_ls_task_spell_all_punct ENDP
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_context$ = 8
_ls_task_dictionary_after_punct PROC NEAR

; 2031 : {

  011e0	53		 push	 ebx
  011e1	55		 push	 ebp
  011e2	56		 push	 esi
  011e3	57		 push	 edi

; 2032 : 	int context;
; 2033 : 	int flag;
; 2034 : 	LETTER *lp1;
; 2035 : 	PLTS_T pLts_t;
; 2036 : 	pLts_t = phTTS->pLTSThreadData;

  011e4	8b 7c 24 14	 mov	 edi, DWORD PTR _phTTS$[esp+12]

; 2037 : #ifdef LS1DEBUG
; 2038 : 		printf("entering ls_task_dictionary_after_punct\n");
; 2039 : #endif
; 2040 : 	
; 2041 : 	/*
; 2042 : 	 * If the above code stripped off a
; 2043 : 	 * punctuation mark, give the dictionary another try
; 2044 : 	 * at it. Duck out through the common exit if we get a
; 2045 : 	 * hit at this level. We also understand how to deal
; 2046 : 	 * with an abbreviation contexts that are hidden
; 2047 : 	 * by right end strippable punctuation.
; 2048 : 	 */
; 2049 : 
; 2050 : 	context = FIRST;
; 2051 : 	if (((pLts_t->lflag)&RSTRIP) != 0) 

  011e8	8b 6c 24 1c	 mov	 ebp, DWORD PTR _rlp$[esp+12]
  011ec	8b 5c 24 18	 mov	 ebx, DWORD PTR _llp$[esp+12]
  011f0	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _context$[esp+12], 0
  011f8	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  011fb	f6 86 f8 08 00
	00 02		 test	 BYTE PTR [esi+2296], 2
  01202	74 4f		 je	 SHORT $L72754

; 2052 : 	{
; 2053 : 		lp1 = (*rlp)-1;

  01204	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  01207	83 e8 02	 sub	 eax, 2

; 2054 : 		if (llp!=lp1 && lp1->l_ch=='.') 

  0120a	3b d8		 cmp	 ebx, eax
  0120c	74 5a		 je	 SHORT $L72759
  0120e	66 83 38 2e	 cmp	 WORD PTR [eax], 46	; 0000002eH
  01212	75 54		 jne	 SHORT $L72759

; 2055 : 		{
; 2056 : 			if ((flag=ls_util_lookup(phTTS,llp, lp1, FABBREV)) != MISS) 

  01214	6a 01		 push	 1
  01216	50		 push	 eax
  01217	53		 push	 ebx
  01218	57		 push	 edi
  01219	e8 00 00 00 00	 call	 _ls_util_lookup
  0121e	83 c4 10	 add	 esp, 16			; 00000010H
  01221	85 c0		 test	 eax, eax
  01223	74 19		 je	 SHORT $L72756

; 2057 : 			{
; 2058 : 				if (flag != ABBREV)

  01225	83 f8 02	 cmp	 eax, 2
  01228	74 0a		 je	 SHORT $L72757

; 2059 : 					pLts_t->rbphone = PERIOD;

  0122a	c7 86 20 0b 00
	00 74 00 00 00	 mov	 DWORD PTR [esi+2848], 116 ; 00000074H
$L72757:
  01234	5f		 pop	 edi
  01235	5e		 pop	 esi
  01236	5d		 pop	 ebp

; 2060 : 				return(FINISHED_WORD);

  01237	b8 03 00 00 00	 mov	 eax, 3
  0123c	5b		 pop	 ebx

; 2079 : } 

  0123d	c3		 ret	 0
$L72756:

; 2061 : 			}
; 2062 : 			pLts_t->rbphone = PERIOD;       /* Very strong.         */

  0123e	c7 86 20 0b 00
	00 74 00 00 00	 mov	 DWORD PTR [esi+2848], 116 ; 00000074H

; 2063 : 			--(*rlp);

  01248	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0124b	83 c0 fe	 add	 eax, -2			; fffffffeH
  0124e	89 45 00	 mov	 DWORD PTR [ebp], eax

; 2064 : 		}
; 2065 : 	} 
; 2066 : 	else 

  01251	eb 15		 jmp	 SHORT $L72759
$L72754:

; 2067 : 	{
; 2068 : 		if (ls_util_is_dot(pLts_t) != FALSE)            /* "(Gov. Smith)"       */

  01253	56		 push	 esi
  01254	e8 00 00 00 00	 call	 _ls_util_is_dot
  01259	83 c4 04	 add	 esp, 4
  0125c	85 c0		 test	 eax, eax
  0125e	74 08		 je	 SHORT $L72759

; 2069 : 			context = FABBREV;

  01260	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _context$[esp+12], 1
$L72759:

; 2070 : 	}
; 2071 : 	if (((pLts_t->lflag)&(LSTRIP|RSTRIP)) != 0
; 2072 : 		&& (flag=ls_util_lookup(phTTS,llp, (*rlp), context)) != MISS) 

  01268	f6 86 f8 08 00
	00 03		 test	 BYTE PTR [esi+2296], 3
  0126f	74 2f		 je	 SHORT $L72760
  01271	8b 44 24 14	 mov	 eax, DWORD PTR _context$[esp+12]
  01275	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  01278	50		 push	 eax
  01279	51		 push	 ecx
  0127a	53		 push	 ebx
  0127b	57		 push	 edi
  0127c	e8 00 00 00 00	 call	 _ls_util_lookup
  01281	83 c4 10	 add	 esp, 16			; 00000010H
  01284	85 c0		 test	 eax, eax
  01286	74 18		 je	 SHORT $L72760

; 2073 : 	{
; 2074 : 		if (flag == ABBREV)             /* Eat the "."          */

  01288	83 f8 02	 cmp	 eax, 2
  0128b	75 09		 jne	 SHORT $L72761

; 2075 : 			ls_util_read_item(phTTS);

  0128d	57		 push	 edi
  0128e	e8 00 00 00 00	 call	 _ls_util_read_item
  01293	83 c4 04	 add	 esp, 4
$L72761:
  01296	5f		 pop	 edi
  01297	5e		 pop	 esi
  01298	5d		 pop	 ebp

; 2076 : 		return(FINISHED_WORD);

  01299	b8 03 00 00 00	 mov	 eax, 3
  0129e	5b		 pop	 ebx

; 2079 : } 

  0129f	c3		 ret	 0
$L72760:
  012a0	5f		 pop	 edi
  012a1	5e		 pop	 esi
  012a2	5d		 pop	 ebp

; 2077 : 	}
; 2078 : 	return(KEEP_SEARCHING);

  012a3	33 c0		 xor	 eax, eax
  012a5	5b		 pop	 ebx

; 2079 : } 

  012a6	c3		 ret	 0
_ls_task_dictionary_after_punct ENDP
_TEXT	ENDS
EXTRN	_ls_spel_say_it:NEAR
EXTRN	__imp__fprintf:NEAR
_DATA	SEGMENT
	ORG $+1
$SG72774 DB	0aH, 'SPELL IT (HIT)', 00H
$SG72775 DB	0aH, 'SPELL IT (HIT)', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_spell_vs_speak PROC NEAR

; 2105 : {   

  012b0	53		 push	 ebx

; 2106 : /*
; 2107 :  *  run through the new speak/spell rule tables ...
; 2108 :  */
; 2109 : 	PKSD_T	pKsd_t;
; 2110 : 	pKsd_t = phTTS->pKernelShareData;   
; 2111 : 
; 2112 : 
; 2113 : 
; 2114 : #ifdef LS1DEBUG
; 2115 : 	printf("entering ls_task_spell_vs_speak\n");
; 2116 : 	printf("ls_spel_say_it ");
; 2117 : 	printf("left=%u  right=%u\n",llp,rlp);
; 2118 : #endif
; 2119 : 
; 2120 : 	if(ls_spel_say_it(llp,rlp) == FALSE)

  012b1	8b 5c 24 10	 mov	 ebx, DWORD PTR _rlp$[esp]
  012b5	55		 push	 ebp
  012b6	8b 6c 24 10	 mov	 ebp, DWORD PTR _llp$[esp+4]
  012ba	56		 push	 esi
  012bb	57		 push	 edi
  012bc	8b 7c 24 14	 mov	 edi, DWORD PTR _phTTS$[esp+12]
  012c0	53		 push	 ebx
  012c1	55		 push	 ebp
  012c2	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  012c5	e8 00 00 00 00	 call	 _ls_spel_say_it
  012ca	83 c4 08	 add	 esp, 8
  012cd	85 c0		 test	 eax, eax
  012cf	75 4d		 jne	 SHORT $L72770

; 2121 : 	{
; 2122 : #ifdef LS1DEBUG
; 2123 : 			printf("ls_spel_say_it spell\n");
; 2124 : #endif
; 2125 : 				/* debug switch */
; 2126 : 		if (DT_DBG(LTS_DBG,0x400))

  012d1	66 8b 86 40 06
	00 00		 mov	 ax, WORD PTR [esi+1600]
  012d8	f6 c4 40	 test	 ah, 64			; 00000040H
  012db	74 2c		 je	 SHORT $L72771
  012dd	f6 c4 04	 test	 ah, 4
  012e0	74 27		 je	 SHORT $L72771

; 2127 : 			{
; 2128 : #ifndef MSDOS
; 2129 : 				if (pKsd_t->dbglog)			/*mfg 05/13/98 added debug support*/

  012e2	8b b6 44 06 00
	00		 mov	 esi, DWORD PTR [esi+1604]
  012e8	85 f6		 test	 esi, esi
  012ea	74 0f		 je	 SHORT $L72772

; 2130 : 					fprintf((FILE *)pKsd_t->dbglog,"\nSPELL IT (HIT)");

  012ec	68 00 00 00 00	 push	 OFFSET FLAT:$SG72774
  012f1	56		 push	 esi
  012f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  012f8	83 c4 08	 add	 esp, 8
$L72772:

; 2131 : #endif     
; 2132 : 				printf("\nSPELL IT (HIT)");

  012fb	68 00 00 00 00	 push	 OFFSET FLAT:$SG72775
  01300	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  01306	83 c4 04	 add	 esp, 4
$L72771:

; 2133 : 			}
; 2134 : 
; 2135 : 
; 2136 : 		ls_spel_spell(phTTS,llp,rlp);

  01309	53		 push	 ebx
  0130a	55		 push	 ebp
  0130b	57		 push	 edi
  0130c	e8 00 00 00 00	 call	 _ls_spel_spell
  01311	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2137 : 		return(FINISHED_WORD);

  01314	b8 03 00 00 00	 mov	 eax, 3
  01319	5f		 pop	 edi
  0131a	5e		 pop	 esi
  0131b	5d		 pop	 ebp
  0131c	5b		 pop	 ebx

; 2140 : }

  0131d	c3		 ret	 0
$L72770:
  0131e	5f		 pop	 edi
  0131f	5e		 pop	 esi
  01320	5d		 pop	 ebp

; 2138 : 	}                         
; 2139 : 	return(KEEP_SEARCHING);

  01321	33 c0		 xor	 eax, eax
  01323	5b		 pop	 ebx

; 2140 : }

  01324	c3		 ret	 0
_ls_task_spell_vs_speak ENDP
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_flag$ = 12
_pLts_t$ = -4
_ls_task_single_letter_spell_rules PROC NEAR

; 2165 : {

  01330	51		 push	 ecx

; 2166 : 	int c;
; 2167 : #ifndef FRENCH
; 2168 : 	LETTER *lp1;
; 2169 : 	int flag;
; 2170 : #endif //warning removal
; 2171 : 	//int done=0;
; 2172 : 	PLTS_T pLts_t;
; 2173 : 	pLts_t = phTTS->pLTSThreadData;

  01331	8b 54 24 08	 mov	 edx, DWORD PTR _phTTS$[esp]
  01335	53		 push	 ebx
  01336	55		 push	 ebp

; 2174 : 
; 2175 : #ifdef LS1DEBUG
; 2176 : 	printf("entering ls_task_single_letter_spell_rules");
; 2177 : 	printf("left=%u  right=%u\n",llp,rlp);
; 2178 : #endif 
; 2179 : 
; 2180 : 	/*
; 2181 : 	 * There are a small set of rules that must be
; 2182 : 	 * run before case distinctions and diacritical marks
; 2183 : 	 * are lost. Single character words are usually spelled,
; 2184 : 	 * but there are some important exceptions. Sequences of
; 2185 : 	 * upper case letters separated by periods (I.B.M.)
; 2186 : 	 * are processed by a fast spelling rule.
; 2187 : 	 */
; 2188 : 	if (llp+1 == rlp)

  01337	8b 6c 24 18	 mov	 ebp, DWORD PTR _rlp$[esp+8]
  0133b	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  0133e	56		 push	 esi
  0133f	8b 74 24 18	 mov	 esi, DWORD PTR _llp$[esp+12]
  01343	57		 push	 edi
  01344	89 4c 24 10	 mov	 DWORD PTR _pLts_t$[esp+20], ecx
  01348	8d 7e 02	 lea	 edi, DWORD PTR [esi+2]
  0134b	3b fd		 cmp	 edi, ebp
  0134d	0f 85 37 01 00
	00		 jne	 $L72787

; 2189 : 	{
; 2190 : 		c = llp->l_ch;

  01353	0f bf 3e	 movsx	 edi, WORD PTR [esi]

; 2191 : 
; 2192 : 		/*
; 2193 : 		 * Any upper case letter that does not have
; 2194 : 		 * any stripped punctuation, and is followed by a
; 2195 : 		 * period, is taken to be someones initial. The
; 2196 : 		 * period goes away, and the word is spelled.
; 2197 : 		 *
; 2198 : 		 * If you want to make this rule go away you
; 2199 : 		 * can safely just delete the following "if" and
; 2200 : 		 * it's corresponding body.
; 2201 : 		 */
; 2202 : 
; 2203 : 		if (IS_UPPER(c) 
; 2204 : 		&& ((pLts_t->lflag)&(LSTRIP|RSTRIP))==0 && ls_util_is_dot(pLts_t)!=FALSE)

  01356	8b c7		 mov	 eax, edi
  01358	bb 03 00 00 00	 mov	 ebx, 3
  0135d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01362	f6 80 00 00 00
	00 02		 test	 BYTE PTR _ls_char_feat[eax], 2
  01369	74 43		 je	 SHORT $L72788
  0136b	84 99 f8 08 00
	00		 test	 BYTE PTR [ecx+2296], bl
  01371	75 3b		 jne	 SHORT $L72788
  01373	51		 push	 ecx
  01374	e8 00 00 00 00	 call	 _ls_util_is_dot
  01379	83 c4 04	 add	 esp, 4
  0137c	85 c0		 test	 eax, eax
  0137e	74 26		 je	 SHORT $L73217

; 2205 : 		{
; 2206 : 			/* BATS 460 MGS 10/08/1997 Fixed A. B. C. problem losing periods */
; 2207 : 			pLts_t->rbphone=PERIOD;

  01380	8b 4c 24 10	 mov	 ecx, DWORD PTR _pLts_t$[esp+20]

; 2208 : 			ls_util_read_item(phTTS);

  01384	8b 54 24 18	 mov	 edx, DWORD PTR _phTTS$[esp+16]
  01388	52		 push	 edx
  01389	c7 81 20 0b 00
	00 74 00 00 00	 mov	 DWORD PTR [ecx+2848], 116 ; 00000074H
  01393	e8 00 00 00 00	 call	 _ls_util_read_item
  01398	83 c4 04	 add	 esp, 4

; 2209 : #ifdef LS1DEBUG
; 2210 : 			printf(" spell cap letter \n");
; 2211 : #endif
; 2212 : #ifndef FRENCH
; 2213 : 			return(SPELL_WORD);

  0139b	b8 02 00 00 00	 mov	 eax, 2
  013a0	5f		 pop	 edi
  013a1	5e		 pop	 esi
  013a2	5d		 pop	 ebp
  013a3	5b		 pop	 ebx

; 2454 : }           

  013a4	59		 pop	 ecx
  013a5	c3		 ret	 0
$L73217:

; 2209 : #ifdef LS1DEBUG
; 2210 : 			printf(" spell cap letter \n");
; 2211 : #endif
; 2212 : #ifndef FRENCH
; 2213 : 			return(SPELL_WORD);

  013a6	8b 54 24 18	 mov	 edx, DWORD PTR _phTTS$[esp+16]
  013aa	8b 4c 24 10	 mov	 ecx, DWORD PTR _pLts_t$[esp+20]
$L72788:

; 2214 : #endif
; 2215 : #ifdef FRENCH
; 2216 : 			return 1;
; 2217 : #endif
; 2218 : 		}                                         
; 2219 : 
; 2220 : #ifdef ENGLISH_US
; 2221 : 		/*
; 2222 : 		 * I    => [`A].        Note stress.
; 2223 : 		 * "I"  => ['A].        This is consistant with
; 2224 : 		 * (I)  => ['A].        the spelling entry.
; 2225 : 		 */
; 2226 : 
; 2227 : 		if (c=='i' || c=='I')

  013ae	83 ff 69	 cmp	 edi, 105		; 00000069H
  013b1	0f 84 a5 00 00
	00		 je	 $L72790
  013b7	83 ff 49	 cmp	 edi, 73			; 00000049H
  013ba	0f 84 9c 00 00
	00		 je	 $L72790

; 2236 : 		}
; 2237 : 
; 2238 : 		/*
; 2239 : 		 * The single character word "a" has two
; 2240 : 		 * different pronounciations. The default one, from
; 2241 : 		 * the spelling entry in the dictionary, is ['e]. The
; 2242 : 		 * exception (actually the most common case) is [x].
; 2243 : 		 * Use [x] if no stripping, and the "a" is not sitting
; 2244 : 		 * against a punctuation mark ("a box." vs "box a.").
; 2245 : 		 */
; 2246 :         /*
; 2247 :            GL 9/10/1996, add checking isnumabr to fix "4.4 a" problem
; 2248 : 		   GL 8/14/1997, for BATS#441 only pLts_t->isnumabr is 0  or 1 "a" will be "AX"
; 2249 :          */
; 2250 : 		if ((c=='a' || c=='A') && (pLts_t->isnumabr == 0 || pLts_t->isnumabr == 1)
; 2251 : 			&& ((pLts_t->lflag)&(LSTRIP|RSTRIP))==0 && ls_util_is_white(&(pLts_t->citem))==TRUE)

  013c0	83 ff 61	 cmp	 edi, 97			; 00000061H
  013c3	74 05		 je	 SHORT $L72794
  013c5	83 ff 41	 cmp	 edi, 65			; 00000041H
  013c8	75 5f		 jne	 SHORT $L72793
$L72794:
  013ca	8b 81 fc 08 00
	00		 mov	 eax, DWORD PTR [ecx+2300]
  013d0	85 c0		 test	 eax, eax
  013d2	74 05		 je	 SHORT $L72795
  013d4	83 f8 01	 cmp	 eax, 1
  013d7	75 50		 jne	 SHORT $L72793
$L72795:
  013d9	84 99 f8 08 00
	00		 test	 BYTE PTR [ecx+2296], bl
  013df	75 48		 jne	 SHORT $L72793
  013e1	81 c1 00 09 00
	00		 add	 ecx, 2304		; 00000900H
  013e7	51		 push	 ecx
  013e8	e8 00 00 00 00	 call	 _ls_util_is_white
  013ed	83 c4 04	 add	 esp, 4
  013f0	83 f8 01	 cmp	 eax, 1
  013f3	75 34		 jne	 SHORT $L72793

; 2252 : 		{
; 2253 : 			pLts_t->fc_struct[pLts_t->fc_index] = FC_ART;

  013f5	8b 44 24 10	 mov	 eax, DWORD PTR _pLts_t$[esp+20]

; 2254 : 			ls_util_send_phone(phTTS,SPECIALWORD);	

  013f9	8b 74 24 18	 mov	 esi, DWORD PTR _phTTS$[esp+16]
  013fd	6a 78		 push	 120			; 00000078H
  013ff	56		 push	 esi
  01400	8b 88 bc 08 00
	00		 mov	 ecx, DWORD PTR [eax+2236]
  01406	c7 84 88 bc 04
	00 00 04 00 00
	00		 mov	 DWORD PTR [eax+ecx*4+1212], 4
  01411	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2255 : 			ls_util_send_phone(phTTS,US_AX);			

  01416	6a 11		 push	 17			; 00000011H
  01418	56		 push	 esi
  01419	e8 00 00 00 00	 call	 _ls_util_send_phone
  0141e	83 c4 10	 add	 esp, 16			; 00000010H

; 2256 : #ifdef LS1DEBUG
; 2257 : 			printf(" a to ah code \n");
; 2258 : #endif
; 2259 : 			return(FINISHED_WORD);

  01421	8b c3		 mov	 eax, ebx
  01423	5f		 pop	 edi
  01424	5e		 pop	 esi
  01425	5d		 pop	 ebp
  01426	5b		 pop	 ebx

; 2454 : }           

  01427	59		 pop	 ecx
  01428	c3		 ret	 0
$L72793:

; 2260 : 		}
; 2261 : #endif // ENGLISH_US
; 2262 : #ifdef ENGLISH_UK
; 2263 : 		/*
; 2264 : 		 * I    => [`A].        Note stress.
; 2265 : 		 * "I"  => ['A].        This is consistant with
; 2266 : 		 * (I)  => ['A].        the spelling entry.
; 2267 : 		 */
; 2268 : 
; 2269 : 		if (c=='i' || c=='I')
; 2270 : 		{
; 2271 : 			if (((pLts_t->lflag)&(LSTRIP|RSTRIP)) != 0)
; 2272 : 				ls_util_send_phone(phTTS,S1);
; 2273 : 			else            
; 2274 : 				ls_util_send_phone(phTTS,S2);
; 2275 : 
; 2276 : 			ls_util_send_phone(phTTS,UK_AY);			
; 2277 : 			return(FINISHED_WORD);
; 2278 : 		}
; 2279 : 
; 2280 : 		/*
; 2281 : 		 * The single character word "a" has two
; 2282 : 		 * different pronounciations. The default one, from
; 2283 : 		 * the spelling entry in the dictionary, is ['e]. The
; 2284 : 		 * exception (actually the most common case) is [x].
; 2285 : 		 * Use [x] if no stripping, and the "a" is not sitting
; 2286 : 		 * against a punctuation mark ("a box." vs "box a.").
; 2287 : 		 */
; 2288 :         /*
; 2289 :            GL 9/10/1996, add checking isnumabr to fix "4.4 a" problem
; 2290 : 		   GL 8/14/1997, for BATS#441 only pLts_t->isnumabr is 0  or 1 "a" will be "AX"
; 2291 :          */
; 2292 : 		if ((c=='a' || c=='A') && (pLts_t->isnumabr == 0 || pLts_t->isnumabr == 1)
; 2293 : 			&& ((pLts_t->lflag)&(LSTRIP|RSTRIP))==0 && ls_util_is_white(&(pLts_t->citem))==TRUE)
; 2294 : 		{
; 2295 : 			pLts_t->fc_struct[pLts_t->fc_index] = FC_ART;
; 2296 : 			ls_util_send_phone(phTTS,SPECIALWORD);	
; 2297 : 			ls_util_send_phone(phTTS,UK_AX);			
; 2298 : #ifdef LS1DEBUG
; 2299 : 			printf(" a to ah code \n");
; 2300 : #endif
; 2301 : 			return(FINISHED_WORD);
; 2302 : 		}
; 2303 : #endif //ENGLISH_UK
; 2304 : #ifdef SPANISH_SP
; 2305 : 		/*igrega or i code*/
; 2306 : 		if ((c=='y' || c=='Y')
; 2307 : 		&& ((pLts_t->lflag)&(LSTRIP|RSTRIP))==0 && ls_util_is_white(&(pLts_t->citem))!=FALSE)
; 2308 : 		{
; 2309 : 			pLts_t->fc_struct[pLts_t->fc_index] = FC_CONJ;
; 2310 : 			ls_util_send_phone(phTTS,SP_I);
; 2311 : #ifdef LS1DEBUG
; 2312 : 			printf(" iggre to i  code \n");
; 2313 : #endif
; 2314 : 			return(FINISHED_WORD);
; 2315 : 		}
; 2316 : 
; 2317 : #endif
; 2318 : #ifdef SPANISH_LA
; 2319 : 		/*igrega or i code*/
; 2320 : 		if ((c=='y' || c=='Y')
; 2321 : 		&& ((pLts_t->lflag)&(LSTRIP|RSTRIP))==0 && ls_util_is_white(&(pLts_t->citem))!=FALSE)
; 2322 : 		{
; 2323 : 			pLts_t->fc_struct[pLts_t->fc_index] = FC_CONJ;
; 2324 : 			ls_util_send_phone(phTTS,LA_I);
; 2325 : #ifdef LS1DEBUG
; 2326 : 			printf(" iggre to i  code \n");
; 2327 : #endif
; 2328 : 
; 2329 : 			return(FINISHED_WORD);
; 2330 : 		}
; 2331 : 
; 2332 : #endif		
; 2333 : 
; 2334 : 		/*
; 2335 : 		 * Most other single letter words get
; 2336 : 		 * spelled. Watch out for single character numbers
; 2337 : 		 * (the digits, and the 1/4 and 1/2 DEC supplimental
; 2338 : 		 * characters) which must go through the number
; 2339 : 		 * processing heuristics.
; 2340 : 		 */
; 2341 : #ifndef FRENCH
; 2342 : 		if (c!=0xBC && c!=0xBD && !IS_DIGIT(llp->l_ch))

  01429	81 ff bc 00 00
	00		 cmp	 edi, 188		; 000000bcH
  0142f	0f 84 08 01 00
	00		 je	 $L72805
  01435	81 ff bd 00 00
	00		 cmp	 edi, 189		; 000000bdH
  0143b	0f 84 fc 00 00
	00		 je	 $L72805
  01441	0f bf 16	 movsx	 edx, WORD PTR [esi]
  01444	f6 82 00 00 00
	00 10		 test	 BYTE PTR _ls_char_feat[edx], 16 ; 00000010H
  0144b	0f 85 ec 00 00
	00		 jne	 $L72805
  01451	5f		 pop	 edi
  01452	5e		 pop	 esi
  01453	5d		 pop	 ebp

; 2343 : #endif
; 2344 : #ifdef FRENCH
; 2345 : 		if (c!=0xBC && c!=0xBD && ( (lsctype[c] & O) == 0)
; 2346 : 		&& !IS_DIGIT(llp->l_ch) )
; 2347 : #endif
; 2348 : 		{
; 2349 : #ifdef LS1DEBUG
; 2350 : 			printf("single letter spell\n");
; 2351 : #endif
; 2352 : 
; 2353 : #ifndef FRENCH
; 2354 : 			return(SPELL_WORD);

  01454	b8 02 00 00 00	 mov	 eax, 2
  01459	5b		 pop	 ebx

; 2454 : }           

  0145a	59		 pop	 ecx
  0145b	c3		 ret	 0
$L72790:

; 2228 : 		{
; 2229 : 			if (((pLts_t->lflag)&(LSTRIP|RSTRIP)) != 0)

  0145c	84 99 f8 08 00
	00		 test	 BYTE PTR [ecx+2296], bl
  01462	74 04		 je	 SHORT $L72791

; 2230 : 				ls_util_send_phone(phTTS,S1);

  01464	6a 67		 push	 103			; 00000067H

; 2231 : 			else            

  01466	eb 02		 jmp	 SHORT $L73221
$L72791:

; 2232 : 				ls_util_send_phone(phTTS,S2);

  01468	6a 66		 push	 102			; 00000066H
$L73221:
  0146a	52		 push	 edx
  0146b	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2233 : 
; 2234 : 			ls_util_send_phone(phTTS,US_AY);			

  01470	8b 44 24 20	 mov	 eax, DWORD PTR _phTTS$[esp+24]
  01474	83 c4 08	 add	 esp, 8
  01477	6a 07		 push	 7
  01479	50		 push	 eax
  0147a	e8 00 00 00 00	 call	 _ls_util_send_phone
  0147f	83 c4 08	 add	 esp, 8

; 2235 : 			return(FINISHED_WORD);

  01482	8b c3		 mov	 eax, ebx
  01484	5f		 pop	 edi
  01485	5e		 pop	 esi
  01486	5d		 pop	 ebp
  01487	5b		 pop	 ebx

; 2454 : }           

  01488	59		 pop	 ecx
  01489	c3		 ret	 0
$L72787:

; 2355 : #endif
; 2356 : #ifdef FRENCH
; 2357 : 			      switch (c) {
; 2358 :     case ':':
; 2359 :     case '-':
; 2360 :       if ( ls_util_is_white (&(pLts_t->citem)) ) {
; 2361 :         ls_util_send_phone(phTTS, COMMA);
; 2362 :         return 2;  /* il dit : il ... */
; 2363 :       } else {
; 2364 :         return 1; /* Spell  :, */
; 2365 :       }
; 2366 :       break;
; 2367 :     case '?':
; 2368 :       if ( ls_util_is_white (&(pLts_t->citem)) || ls_util_is_dot(pLts_t) ) {
; 2369 :         if (pLts_t->wstate == IS_WH) {
; 2370 :           ls_util_send_phone (phTTS, PERIOD); /* qui est-tu ?  ou  ... ?. */
; 2371 :         } else {
; 2372 :           ls_util_send_phone (phTTS, QUEST);  /* viens ? ou viens ?. */
; 2373 :         }
; 2374 :         pLts_t->wstate = FIRST;
; 2375 :         return 2;
; 2376 :       } else {
; 2377 :         return 1; /* Spell  ?, */
; 2378 :       }
; 2379 :       break;
; 2380 :     case '!':
; 2381 :       if ( ls_util_is_white (&(pLts_t->citem)) || ls_util_is_dot(pLts_t) ) {
; 2382 :         ls_util_send_phone (phTTS, EXCLAIM);
; 2383 :         pLts_t->wstate = FIRST;
; 2384 :         return 2;  /* Ah bon ! Il dit ... ou Ah !. */
; 2385 :       } else {
; 2386 :         return 1; /* Spell  :, */
; 2387 :       }
; 2388 :       break;
; 2389 :     default : /* D G % " { = ] */
; 2390 :       return 1;   /* spell */
; 2391 :       break;
; 2392 :       } /* switch */
; 2393 : #endif //FRENCH
; 2394 : 		}
; 2395 : 	}
; 2396 : #ifndef FRENCH
; 2397 : 	else
; 2398 : 	{
; 2399 : 		flag = FALSE;                   /* Start validation.    */

  0148a	33 db		 xor	 ebx, ebx

; 2400 : 		lp1  = llp;
; 2401 : 		while (lp1 != rlp) 

  0148c	3b f5		 cmp	 esi, ebp
  0148e	89 5c 24 1c	 mov	 DWORD PTR _flag$[esp+16], ebx
  01492	8b c6		 mov	 eax, esi
  01494	74 75		 je	 SHORT $L72808
$L72799:

; 2402 : 		{
; 2403 : 			if (flag == FALSE) 

  01496	85 db		 test	 ebx, ebx
  01498	75 18		 jne	 SHORT $L72801

; 2404 : 			{    /* FALSE => even.       */
; 2405 : 
; 2406 : 				/*
; 2407 : 				 * On a standard DECtalk all of
; 2408 : 				 * the characters in an "I.B.M." thing
; 2409 : 				 * must be in upper case. On the special
; 2410 : 				 * Kurzweil DECtalk any letter will do.
; 2411 : 				 * A letter is defined here as vowel
; 2412 : 				 * or consonant.
; 2413 : 				 */
; 2414 : 				
; 2415 : 				if (!(IS_UPPER(lp1->l_ch)))

  0149a	8a 18		 mov	 bl, BYTE PTR [eax]
  0149c	81 e3 ff 00 00
	00		 and	 ebx, 255		; 000000ffH
  014a2	f6 83 00 00 00
	00 02		 test	 BYTE PTR _ls_char_feat[ebx], 2
  014a9	74 1c		 je	 SHORT $L73220

; 2416 : 					break;
; 2417 : 				flag = TRUE;

  014ab	bb 01 00 00 00	 mov	 ebx, 1

; 2418 : 			} 
; 2419 : 			else 

  014b0	eb 08		 jmp	 SHORT $L73223
$L72801:

; 2420 : 			{                /* TRUE => odd.         */
; 2421 : 				if (lp1->l_ch != '.')

  014b2	66 83 38 2e	 cmp	 WORD PTR [eax], 46	; 0000002eH
  014b6	75 13		 jne	 SHORT $L73213

; 2422 : 					break;
; 2423 : 				flag = FALSE;

  014b8	33 db		 xor	 ebx, ebx
$L73223:

; 2424 : 			}
; 2425 : 			++lp1;

  014ba	83 c0 02	 add	 eax, 2
  014bd	89 5c 24 1c	 mov	 DWORD PTR _flag$[esp+16], ebx
  014c1	3b c5		 cmp	 eax, ebp
  014c3	75 d1		 jne	 SHORT $L72799

; 2426 : 		}
; 2427 : 		if (lp1 == rlp) 

  014c5	eb 08		 jmp	 SHORT $L73216
$L73220:
  014c7	8b 5c 24 1c	 mov	 ebx, DWORD PTR _flag$[esp+16]
$L73213:
  014cb	3b c5		 cmp	 eax, ebp
  014cd	75 6e		 jne	 SHORT $L72805
$L73216:

; 2428 : 		{               /* Ate it all.          */
; 2429 : 			lp1 = llp;
; 2430 : 			while (lp1 != rlp) 

  014cf	3b f5		 cmp	 esi, ebp
  014d1	74 38		 je	 SHORT $L72808
$L72807:

; 2431 : 			{
; 2432 : #ifdef LS1DEBUG
; 2433 : 				printf("ate it all spell\n");
; 2434 : #endif
; 2435 : 
; 2436 : 				ls_spel_spell(phTTS,lp1, lp1+1);

  014d3	57		 push	 edi
  014d4	56		 push	 esi
  014d5	52		 push	 edx
  014d6	e8 00 00 00 00	 call	 _ls_spel_spell

; 2437 : 				++lp1;

  014db	83 c6 02	 add	 esi, 2
  014de	83 c4 0c	 add	 esp, 12			; 0000000cH
  014e1	83 c7 02	 add	 edi, 2

; 2438 : 				if (lp1 != rlp) 

  014e4	3b f5		 cmp	 esi, ebp
  014e6	74 1f		 je	 SHORT $L73219

; 2439 : 				{
; 2440 : 					++lp1;

  014e8	83 c6 02	 add	 esi, 2
  014eb	83 c7 02	 add	 edi, 2

; 2441 : 				}
; 2442 : 				if (lp1 != rlp)

  014ee	3b f5		 cmp	 esi, ebp
  014f0	74 15		 je	 SHORT $L73219

; 2443 : 					ls_util_send_phone(phTTS,WBOUND);

  014f2	8b 4c 24 18	 mov	 ecx, DWORD PTR _phTTS$[esp+16]
  014f6	6a 6f		 push	 111			; 0000006fH
  014f8	51		 push	 ecx
  014f9	e8 00 00 00 00	 call	 _ls_util_send_phone
  014fe	8b 54 24 20	 mov	 edx, DWORD PTR _phTTS$[esp+24]
  01502	83 c4 08	 add	 esp, 8
  01505	eb cc		 jmp	 SHORT $L72807
$L73219:

; 2428 : 		{               /* Ate it all.          */
; 2429 : 			lp1 = llp;
; 2430 : 			while (lp1 != rlp) 

  01507	8b 4c 24 10	 mov	 ecx, DWORD PTR _pLts_t$[esp+20]
$L72808:

; 2444 : 			}
; 2445 : 			if (flag != FALSE       /* Last a letter.       */
; 2446 : 			&& ((pLts_t->lflag)&RSTRIP) == 0  /* and no right strip   */
; 2447 : 			&& ls_util_is_dot(pLts_t) != FALSE)    /* and sitting on "."   */

  0150b	85 db		 test	 ebx, ebx
  0150d	74 23		 je	 SHORT $L72811
  0150f	f6 81 f8 08 00
	00 02		 test	 BYTE PTR [ecx+2296], 2
  01516	75 1a		 jne	 SHORT $L72811
  01518	51		 push	 ecx
  01519	e8 00 00 00 00	 call	 _ls_util_is_dot
  0151e	83 c4 04	 add	 esp, 4
  01521	85 c0		 test	 eax, eax
  01523	74 0d		 je	 SHORT $L72811

; 2448 : 				ls_util_read_item(phTTS);     /* eat up the ".".      */

  01525	8b 54 24 18	 mov	 edx, DWORD PTR _phTTS$[esp+16]
  01529	52		 push	 edx
  0152a	e8 00 00 00 00	 call	 _ls_util_read_item
  0152f	83 c4 04	 add	 esp, 4
$L72811:
  01532	5f		 pop	 edi
  01533	5e		 pop	 esi
  01534	5d		 pop	 ebp

; 2449 : 			return(FINISHED_WORD);

  01535	b8 03 00 00 00	 mov	 eax, 3
  0153a	5b		 pop	 ebx

; 2454 : }           

  0153b	59		 pop	 ecx
  0153c	c3		 ret	 0
$L72805:
  0153d	5f		 pop	 edi
  0153e	5e		 pop	 esi
  0153f	5d		 pop	 ebp

; 2450 : 		}
; 2451 : 	}
; 2452 : #endif //ndef FRENCH
; 2453 : 	return(KEEP_SEARCHING);

  01540	33 c0		 xor	 eax, eax
  01542	5b		 pop	 ebx

; 2454 : }           

  01543	59		 pop	 ecx
  01544	c3		 ret	 0
_ls_task_single_letter_spell_rules ENDP
_llp$ = 8
_rlp$ = 12
_ls_task_remove_case PROC NEAR

; 2480 : 	while (llp != rlp) 

  01550	8b 44 24 04	 mov	 eax, DWORD PTR _llp$[esp-4]
  01554	8b 4c 24 08	 mov	 ecx, DWORD PTR _rlp$[esp-4]
  01558	3b c1		 cmp	 eax, ecx
  0155a	74 16		 je	 SHORT $L72819
$L72818:

; 2481 : 	{
; 2482 : 		llp->l_ch = ls_lower[(llp->l_ch)];

  0155c	0f bf 10	 movsx	 edx, WORD PTR [eax]

; 2483 : 		++llp;

  0155f	83 c0 02	 add	 eax, 2
  01562	66 0f b6 92 00
	00 00 00	 movzx	 dx, BYTE PTR _ls_lower[edx]
  0156a	66 89 50 fe	 mov	 WORD PTR [eax-2], dx
  0156e	3b c1		 cmp	 eax, ecx
  01570	75 ea		 jne	 SHORT $L72818
$L72819:

; 2484 : 	}
; 2485 : }

  01572	c3		 ret	 0
_ls_task_remove_case ENDP
_TEXT	ENDS
EXTRN	_pstreet:BYTE
EXTRN	_psaint:BYTE
EXTRN	_pdoctor:BYTE
EXTRN	_pdrive:BYTE
EXTRN	_ls_util_copyword:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_Dr_St_process PROC NEAR

; 2513 : 	int     c1;
; 2514 : 	int     c2;
; 2515 : 	PLTS_T pLts_t;
; 2516 : 	pLts_t = phTTS->pLTSThreadData;

  01580	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]

; 2517 : 
; 2518 : 	/*
; 2519 : 	 * Watch for "Dr." and "St.". Look ahead to
; 2520 : 	 * determine the correct pronounciation, then move
; 2521 : 	 * the ls_task_lookahead into the working word. The two line
; 2522 : 	 * "if" at the start implements rules similar in spirit
; 2523 : 	 * to the code in the first dictionary scan, that has
; 2524 : 	 * do decide if this is an abbreviation context.
; 2525 : 	 */
; 2526 : 
; 2527 : #ifdef LS1DEBUG
; 2528 : 	printf("dr. st. processing ");
; 2529 : 	printf("left=%u  right=%u\n",llp,rlp);
; 2530 : #endif
; 2531 : 				
; 2532 : 	if ((llp+3==rlp && (llp+2)->l_ch=='.')
; 2533 : 	||  (llp+2==rlp && ((pLts_t->lflag)&RSTRIP)==0 && ls_util_is_dot(pLts_t)!=FALSE)) 

  01584	8b 4c 24 0c	 mov	 ecx, DWORD PTR _rlp$[esp-4]
  01588	53		 push	 ebx
  01589	55		 push	 ebp
  0158a	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]
  0158d	56		 push	 esi
  0158e	8b 74 24 14	 mov	 esi, DWORD PTR _llp$[esp+8]
  01592	57		 push	 edi
  01593	8d 56 06	 lea	 edx, DWORD PTR [esi+6]
  01596	3b d1		 cmp	 edx, ecx
  01598	75 0a		 jne	 SHORT $L72832
  0159a	66 83 7e 04 2e	 cmp	 WORD PTR [esi+4], 46	; 0000002eH
  0159f	8d 6e 04	 lea	 ebp, DWORD PTR [esi+4]
  015a2	74 21		 je	 SHORT $L72831
$L72832:
  015a4	8d 6e 04	 lea	 ebp, DWORD PTR [esi+4]
  015a7	3b e9		 cmp	 ebp, ecx
  015a9	75 2b		 jne	 SHORT $L72833
  015ab	f6 83 f8 08 00
	00 02		 test	 BYTE PTR [ebx+2296], 2
  015b2	75 22		 jne	 SHORT $L72833
  015b4	53		 push	 ebx
  015b5	e8 00 00 00 00	 call	 _ls_util_is_dot
  015ba	83 c4 04	 add	 esp, 4
  015bd	85 c0		 test	 eax, eax
  015bf	74 15		 je	 SHORT $L72833
  015c1	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rlp$[esp+12]
$L72831:

; 2534 : 	{
; 2535 : 		c1 = (llp+0)->l_ch;

  015c5	0f bf 3e	 movsx	 edi, WORD PTR [esi]

; 2536 : 		c2 = (llp+1)->l_ch;

  015c8	0f bf 46 02	 movsx	 eax, WORD PTR [esi+2]

; 2537 : 		if ((c1=='s' && c2=='t') || (c1=='d' && c2=='r')) 

  015cc	83 ff 73	 cmp	 edi, 115		; 00000073H
  015cf	75 0c		 jne	 SHORT $L72835
  015d1	83 f8 74	 cmp	 eax, 116		; 00000074H
  015d4	74 11		 je	 SHORT $L72834
$L72833:
  015d6	5f		 pop	 edi
  015d7	5e		 pop	 esi
  015d8	5d		 pop	 ebp

; 2575 : 		}
; 2576 : 	}   
; 2577 : 	return(KEEP_SEARCHING);

  015d9	33 c0		 xor	 eax, eax
  015db	5b		 pop	 ebx

; 2578 : }

  015dc	c3		 ret	 0
$L72835:

; 2537 : 		if ((c1=='s' && c2=='t') || (c1=='d' && c2=='r')) 

  015dd	83 ff 64	 cmp	 edi, 100		; 00000064H
  015e0	75 f4		 jne	 SHORT $L72833
  015e2	83 f8 72	 cmp	 eax, 114		; 00000072H
  015e5	75 ef		 jne	 SHORT $L72833
$L72834:

; 2538 : 		{
; 2539 : 			if (llp+2 == rlp)       /* Gobble up the "."    */

  015e7	3b e9		 cmp	 ebp, ecx
  015e9	75 0d		 jne	 SHORT $L72836

; 2540 : 				ls_util_read_item(phTTS);     /* after abbreviation.  */

  015eb	8b 44 24 14	 mov	 eax, DWORD PTR _phTTS$[esp+12]
  015ef	50		 push	 eax
  015f0	e8 00 00 00 00	 call	 _ls_util_read_item
  015f5	83 c4 04	 add	 esp, 4
$L72836:

; 2541 : 			ls_task_lookahead(pLts_t);

  015f8	53		 push	 ebx
  015f9	e8 00 00 00 00	 call	 _ls_task_lookahead

; 2542 : 			if (ls_util_is_white(&(pLts_t->citem)) != FALSE) 

  015fe	8d 8b 00 09 00
	00		 lea	 ecx, DWORD PTR [ebx+2304]
  01604	51		 push	 ecx
  01605	e8 00 00 00 00	 call	 _ls_util_is_white
  0160a	83 c4 08	 add	 esp, 8
  0160d	85 c0		 test	 eax, eax
  0160f	0f 84 bf 00 00
	00		 je	 $L72837

; 2543 : 			{
; 2544 : 				ls_task_readword(phTTS,&(pLts_t->nword[0]));

  01615	8b 74 24 14	 mov	 esi, DWORD PTR _phTTS$[esp+12]
  01619	8d ab 14 0a 00
	00		 lea	 ebp, DWORD PTR [ebx+2580]
  0161f	55		 push	 ebp
  01620	56		 push	 esi
  01621	e8 00 00 00 00	 call	 _ls_task_readword

; 2545 : 				if ((lsctype[pLts_t->nword[0].l_ch]&UU) != 0)

  01626	66 8b 45 00	 mov	 ax, WORD PTR [ebp]
  0162a	83 c4 08	 add	 esp, 8
  0162d	0f bf d0	 movsx	 edx, ax
  01630	f6 04 55 00 00
	00 00 20	 test	 BYTE PTR _lsctype[edx*2], 32 ; 00000020H
  01638	74 40		 je	 SHORT $L72838

; 2546 : 				{
; 2547 : 					/* GL 02/25/1997  fix St. Dr. back to back problem */ 
; 2548 : 					if ((pLts_t->nword[0].l_ch=='D' &&
; 2549 : 					     pLts_t->nword[1].l_ch=='r' &&
; 2550 : 					     pLts_t->nword[2].l_ch==0) ||
; 2551 : 					     (pLts_t->nword[0].l_ch=='S' &&
; 2552 : 					      pLts_t->nword[1].l_ch=='t' &&
; 2553 : 					      pLts_t->nword[2].l_ch==0))

  0163a	66 3d 44 00	 cmp	 ax, 68			; 00000044H
  0163e	75 14		 jne	 SHORT $L72841
  01640	66 83 bb 16 0a
	00 00 72	 cmp	 WORD PTR [ebx+2582], 114 ; 00000072H
  01648	75 0a		 jne	 SHORT $L72841
  0164a	66 83 bb 18 0a
	00 00 00	 cmp	 WORD PTR [ebx+2584], 0
  01652	74 1a		 je	 SHORT $L72840
$L72841:
  01654	66 3d 53 00	 cmp	 ax, 83			; 00000053H
  01658	75 29		 jne	 SHORT $L72839
  0165a	66 83 bb 16 0a
	00 00 74	 cmp	 WORD PTR [ebx+2582], 116 ; 00000074H
  01662	75 1f		 jne	 SHORT $L72839
  01664	66 83 bb 18 0a
	00 00 00	 cmp	 WORD PTR [ebx+2584], 0
  0166c	75 15		 jne	 SHORT $L72839
$L72840:

; 2554 : 					ls_util_send_phone_list(phTTS,c1=='s' ? pstreet : pdrive);

  0166e	83 ff 73	 cmp	 edi, 115		; 00000073H
  01671	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pstreet
  01676	74 2b		 je	 SHORT $L73229

; 2555 : 					else

  01678	eb 24		 jmp	 SHORT $L73234
$L72838:

; 2556 : 					ls_util_send_phone_list(phTTS,c1=='s' ? psaint : pdoctor);
; 2557 : 				}
; 2558 : 				else
; 2559 : 				{
; 2560 : 					/* GL 03/03/1997  it is doctor or saint if is the first word of sentenct */
; 2561 : 					if (pLts_t->fc_index == 1)

  0167a	83 bb bc 08 00
	00 01		 cmp	 DWORD PTR [ebx+2236], 1
  01681	75 11		 jne	 SHORT $L72844
$L72839:

; 2562 : 						ls_util_send_phone_list(phTTS,c1=='s' ? psaint : pdoctor);

  01683	83 ff 73	 cmp	 edi, 115		; 00000073H
  01686	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_psaint
  0168b	74 16		 je	 SHORT $L73229
  0168d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pdoctor

; 2563 : 					else

  01692	eb 0f		 jmp	 SHORT $L73229
$L72844:

; 2564 : 						ls_util_send_phone_list(phTTS,c1=='s' ? pstreet : pdrive);

  01694	83 ff 73	 cmp	 edi, 115		; 00000073H
  01697	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pstreet
  0169c	74 05		 je	 SHORT $L73229
$L73234:
  0169e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pdrive
$L73229:
  016a3	50		 push	 eax
  016a4	56		 push	 esi
  016a5	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2565 : 				}
; 2566 : 
; 2567 : 				ls_util_send_phone(phTTS,pLts_t->rbphone);

  016aa	8b 83 20 0b 00
	00		 mov	 eax, DWORD PTR [ebx+2848]
  016b0	83 c4 08	 add	 esp, 8
  016b3	50		 push	 eax
  016b4	56		 push	 esi
  016b5	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2568 : 				ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));

  016ba	81 c3 14 09 00
	00		 add	 ebx, 2324		; 00000914H
  016c0	55		 push	 ebp
  016c1	53		 push	 ebx
  016c2	e8 00 00 00 00	 call	 _ls_util_copyword
  016c7	83 c4 10	 add	 esp, 16			; 00000010H

; 2569 : 
; 2570 : 				return(LS_TASK_LOOP);

  016ca	b8 01 00 00 00	 mov	 eax, 1
  016cf	5f		 pop	 edi
  016d0	5e		 pop	 esi
  016d1	5d		 pop	 ebp
  016d2	5b		 pop	 ebx

; 2578 : }

  016d3	c3		 ret	 0
$L72837:

; 2571 : 			}
; 2572 : 			ls_util_send_phone_list(phTTS,c1=='s' ? pstreet : pdrive);

  016d4	83 ff 73	 cmp	 edi, 115		; 00000073H
  016d7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pstreet
  016dc	74 05		 je	 SHORT $L73237
  016de	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pdrive
$L73237:
  016e3	8b 4c 24 14	 mov	 ecx, DWORD PTR _phTTS$[esp+12]
  016e7	50		 push	 eax
  016e8	51		 push	 ecx
  016e9	e8 00 00 00 00	 call	 _ls_util_send_phone_list
  016ee	83 c4 08	 add	 esp, 8

; 2573 : 
; 2574 : 			return(FINISHED_WORD);

  016f1	b8 03 00 00 00	 mov	 eax, 3
  016f6	5f		 pop	 edi
  016f7	5e		 pop	 esi
  016f8	5d		 pop	 ebp
  016f9	5b		 pop	 ebx

; 2578 : }

  016fa	c3		 ret	 0
_ls_task_Dr_St_process ENDP
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_lp1$ = 20
_ls_task_set_sign_flag PROC NEAR

; 2608 : 	PKSD_T  pKsd_t;
; 2609 : 	PLTS_T  pLts_t;
; 2610 : 		
; 2611 : 	pKsd_t = phTTS->pKernelShareData;

  01700	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]

; 2612 : 	pLts_t = phTTS->pLTSThreadData;	
; 2613 : 
; 2614 : #ifdef LS1DEBUG       
; 2615 : 	printf("entering ls_task_set_sign_flag\n");
; 2616 : 	printf("beginnning number processing   ");
; 2617 : 	printf("left=%u  right=%u\n",llp,rlp);
; 2618 : #endif
; 2619 : 							  
; 2620 : 	/*
; 2621 : 	 * This is the top of number processing. The first
; 2622 : 	 * step is to decide how "." and "," will be interpreted.
; 2623 : 	 * This is controlled by a mode flag (MODE_EUROPE) if
; 2624 : 	 * the unit is running at level 2. Then pull off any signs,
; 2625 : 	 * and revert to spelling if this makes the whole word
; 2626 : 	 * go away.
; 2627 : 	 */
; 2628 : 	/* pLts_t->fc_struct[pLts_t->fc_index] = FC_ADJ;xxx marks more than numbers here*/
; 2629 : 
; 2630 : 	/*eab 8/94 numbers form class needs to be marked*/
; 2631 : 	pLts_t->fchar = '.';                            /* Pick the right one.  */
; 2632 : 	pLts_t->schar = ',';

  01704	ba 2c 00 00 00	 mov	 edx, 44			; 0000002cH
  01709	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0170c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0170f	66 c7 80 ec 08
	00 00 2e 00	 mov	 WORD PTR [eax+2284], 46	; 0000002eH
  01718	66 89 90 ee 08
	00 00		 mov	 WORD PTR [eax+2286], dx

; 2633 :     if ((pKsd_t->modeflag&MODE_EUROPE)!=0) {

  0171f	f6 81 c0 03 00
	00 08		 test	 BYTE PTR [ecx+960], 8
  01726	74 10		 je	 SHORT $L72857

; 2634 : 		pLts_t->fchar = ',';

  01728	66 89 90 ec 08
	00 00		 mov	 WORD PTR [eax+2284], dx

; 2635 : 		pLts_t->schar = '.';

  0172f	66 c7 80 ee 08
	00 00 2e 00	 mov	 WORD PTR [eax+2286], 46	; 0000002eH
$L72857:

; 2636 : 	}
; 2637 : 	/* GL 11/07/1996, change to fix Spanish Decimal number */
; 2638 : 	/* SPANISH use the "." and "," just as MODE_EUROPE for both Latin and Spanish */
; 2639 : #if defined (SPANISH) || defined (GERMAN)
; 2640 : 		pLts_t->fchar = ',';
; 2641 : 		pLts_t->schar = '.';
; 2642 : #endif
; 2643 : 	
; 2644 : 	pLts_t->sign = 0;
; 2645 : 	(*lp1)  = llp;

  01738	8b 4c 24 10	 mov	 ecx, DWORD PTR _lp1$[esp-4]
  0173c	8b 54 24 08	 mov	 edx, DWORD PTR _llp$[esp-4]
  01740	c7 80 18 0b 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2840], 0
  0174a	89 11		 mov	 DWORD PTR [ecx], edx

; 2646 : 	if ((*lp1)->l_ch == '-'                     /* Signs.               */
; 2647 : 	||  (*lp1)->l_ch == '+'
; 2648 : 	||  (*lp1)->l_ch == 0xA7                    /* Section mark.        */
; 2649 : 	||  (*lp1)->l_ch == 0xB1                    /* Plus-minus.          */
; 2650 : 	||  (*lp1)->l_ch == 0xB6)          			/* Item.                */

  0174c	66 8b 12	 mov	 dx, WORD PTR [edx]
  0174f	66 83 fa 2d	 cmp	 dx, 45			; 0000002dH
  01753	74 1b		 je	 SHORT $L72859
  01755	66 83 fa 2b	 cmp	 dx, 43			; 0000002bH
  01759	74 15		 je	 SHORT $L72859
  0175b	66 81 fa a7 00	 cmp	 dx, 167			; 000000a7H
  01760	74 0e		 je	 SHORT $L72859
  01762	66 81 fa b1 00	 cmp	 dx, 177			; 000000b1H
  01767	74 07		 je	 SHORT $L72859
  01769	66 81 fa b6 00	 cmp	 dx, 182			; 000000b6H
  0176e	75 20		 jne	 SHORT $L72860
$L72859:

; 2651 : 		{               
; 2652 : 		pLts_t->sign = (*lp1)->l_ch;

  01770	0f bf d2	 movsx	 edx, dx
  01773	89 90 18 0b 00
	00		 mov	 DWORD PTR [eax+2840], edx

; 2653 : 		++(*lp1);

  01779	8b 11		 mov	 edx, DWORD PTR [ecx]

; 2654 : #ifdef LS1DEBUG
; 2655 : 		printf("num processing sign found\n");
; 2656 : #endif
; 2657 : 		if ((*lp1) == rlp)

  0177b	8b 44 24 0c	 mov	 eax, DWORD PTR _rlp$[esp-4]
  0177f	83 c2 02	 add	 edx, 2
  01782	89 11		 mov	 DWORD PTR [ecx], edx
  01784	8b ca		 mov	 ecx, edx
  01786	3b c8		 cmp	 ecx, eax
  01788	75 06		 jne	 SHORT $L72860

; 2658 : 		{
; 2659 : #ifdef LS1DEBUG
; 2660 : 			printf(" spell from num processing\n");
; 2661 : #endif
; 2662 : #ifndef FRENCH
; 2663 : 			return(SPELL_WORD);

  0178a	b8 02 00 00 00	 mov	 eax, 2

; 2671 : }

  0178f	c3		 ret	 0
$L72860:

; 2664 : #endif
; 2665 : #ifdef FRENCH
; 2666 : 			return 1;
; 2667 : #endif
; 2668 : 		}
; 2669 : 	}                          
; 2670 : 	return(KEEP_SEARCHING);

  01790	33 c0		 xor	 eax, eax

; 2671 : }

  01792	c3		 ret	 0
_ls_task_set_sign_flag ENDP
_TEXT	ENDS
EXTRN	_nwdtab:BYTE
EXTRN	_ppence:BYTE
EXTRN	_pcent:BYTE
EXTRN	_ppound:BYTE
EXTRN	_pdollar:BYTE
EXTRN	_pand:BYTE
EXTRN	_ls_proc_do_sign:NEAR
EXTRN	_ls_proc_do_number:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_num$ = -24
_type$ = 12
_flag$ = 8
_cp$ = -28
_ls_task_currency_processing PROC NEAR

; 2697 : {   

  017a0	83 ec 1c	 sub	 esp, 28			; 0000001cH
  017a3	53		 push	 ebx

; 2698 : 	NUM     num;
; 2699 : 	LETTER *lp2;
; 2700 : 	int     type;
; 2701 : 	int     flag;
; 2702 : 	char    *cp;
; 2703 : 	PLTS_T pLts_t;
; 2704 : 	
; 2705 : 	pLts_t = phTTS->pLTSThreadData;
; 2706 : 	
; 2707 : #ifdef LS1DEBUG
; 2708 : 		printf("entering ls_task_currency_processing\n");
; 2709 : #endif
; 2710 : 	/*
; 2711 : 	 * If the first character in the remaining string
; 2712 : 	 * is a currency symbol (both the USA/Canada and the
; 2713 : 	 * United Kingdom versions are accepted) this is a signal
; 2714 : 	 * to begin running the money rules.
; 2715 : 	 */
; 2716 : 
; 2717 : #ifdef LS1DEBUG
; 2718 : 	printf("currency rules ");
; 2719 : 	printf("left=%u  right=%u\n",llp,rlp);
; 2720 : #endif
; 2721 : 	if (llp->l_ch=='$' || llp->l_ch==0xA3) 

  017a4	8b 5c 24 28	 mov	 ebx, DWORD PTR _llp$[esp+28]
  017a8	55		 push	 ebp
  017a9	56		 push	 esi
  017aa	66 8b 03	 mov	 ax, WORD PTR [ebx]
  017ad	57		 push	 edi
  017ae	8b 7c 24 30	 mov	 edi, DWORD PTR _phTTS$[esp+40]
  017b2	66 3d 24 00	 cmp	 ax, 36			; 00000024H
  017b6	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  017b9	74 10		 je	 SHORT $L72875
  017bb	66 3d a3 00	 cmp	 ax, 163			; 000000a3H
  017bf	74 0a		 je	 SHORT $L72875
  017c1	5f		 pop	 edi
  017c2	5e		 pop	 esi
  017c3	5d		 pop	 ebp

; 2997 : 		}
; 2998 : 		return(FINISHED_WORD);
; 2999 : 	}
; 3000 : 	return(KEEP_SEARCHING);

  017c4	33 c0		 xor	 eax, eax
  017c6	5b		 pop	 ebx

; 3001 : }

  017c7	83 c4 1c	 add	 esp, 28			; 0000001cH
  017ca	c3		 ret	 0
$L72875:

; 2722 : 	{
; 2723 : 		type = llp->l_ch;
; 2724 : 		if (++llp == rlp)               /* Lone currency mark.  */

  017cb	8b 6c 24 38	 mov	 ebp, DWORD PTR _rlp$[esp+40]
  017cf	83 c3 02	 add	 ebx, 2
  017d2	0f bf c0	 movsx	 eax, ax
  017d5	3b dd		 cmp	 ebx, ebp
  017d7	89 44 24 34	 mov	 DWORD PTR _type$[esp+40], eax

; 2725 : 		{
; 2726 : #ifdef LS1DEBUG
; 2727 : 			printf("currency mark spell \n");
; 2728 : #endif
; 2729 : 
; 2730 : 			return(SPELL_WORD);

  017db	0f 84 2f 03 00
	00		 je	 $L72883

; 2731 : 		}
; 2732 : 		if (llp->l_ch == '-'            /* Signs.               */
; 2733 : 		||  llp->l_ch == '+'
; 2734 : 		||  llp->l_ch == 0xB1) 

  017e1	66 8b 03	 mov	 ax, WORD PTR [ebx]
  017e4	66 3d 2d 00	 cmp	 ax, 45			; 0000002dH
  017e8	74 0c		 je	 SHORT $L72878
  017ea	66 3d 2b 00	 cmp	 ax, 43			; 0000002bH
  017ee	74 06		 je	 SHORT $L72878
  017f0	66 3d b1 00	 cmp	 ax, 177			; 000000b1H
  017f4	75 22		 jne	 SHORT $L72880
$L72878:

; 2735 : 		{        						/* Plus-minus.          */
; 2736 : 
; 2737 : 			if (pLts_t->sign != 0)

  017f6	8b 8e 18 0b 00
	00		 mov	 ecx, DWORD PTR [esi+2840]
  017fc	85 c9		 test	 ecx, ecx

; 2738 : 			{
; 2739 : #ifdef LS1DEBUG
; 2740 : 			printf("sign spell \n");
; 2741 : #endif
; 2742 : 
; 2743 : 				return(SPELL_WORD);

  017fe	0f 85 0c 03 00
	00		 jne	 $L72883

; 2744 : 			}
; 2745 : 
; 2746 : 			pLts_t->sign = llp->l_ch;

  01804	0f bf c8	 movsx	 ecx, ax

; 2747 : 			if (++llp == rlp)       /* "$+"                 */

  01807	83 c3 02	 add	 ebx, 2
  0180a	89 8e 18 0b 00
	00		 mov	 DWORD PTR [esi+2840], ecx
  01810	3b dd		 cmp	 ebx, ebp

; 2748 : 			{
; 2749 : #ifdef LS1DEBUG
; 2750 : 			printf(" spell from num sign proc \n");
; 2751 : #endif
; 2752 : 
; 2753 : 				return(SPELL_WORD);

  01812	0f 84 f8 02 00
	00		 je	 $L72883
$L72880:

; 2754 : 			}
; 2755 : 		}
; 2756 : 
; 2757 : 		lp2 = ls_task_parse_number(phTTS,llp, rlp, &num);

  01818	8d 54 24 14	 lea	 edx, DWORD PTR _num$[esp+44]
  0181c	52		 push	 edx
  0181d	55		 push	 ebp
  0181e	53		 push	 ebx
  0181f	57		 push	 edi
  01820	e8 00 00 00 00	 call	 _ls_task_parse_number

; 2758 : 		if (num.n_elp!=NULL || lp2!=rlp)

  01825	8b 4c 24 34	 mov	 ecx, DWORD PTR _num$[esp+76]
  01829	83 c4 10	 add	 esp, 16			; 00000010H
  0182c	85 c9		 test	 ecx, ecx
  0182e	0f 85 dc 02 00
	00		 jne	 $L72883
  01834	3b c5		 cmp	 eax, ebp
  01836	0f 85 d4 02 00
	00		 jne	 $L72883

; 2765 : 		}
; 2766 : 
; 2767 : 		/*
; 2768 : 		 * You need to look ahead to see if the
; 2769 : 		 * next word is one of the special words like
; 2770 : 		 * "million" that alters where the word "dollar" or
; 2771 : 		 * or "pound" is spoken.
; 2772 : 		 */
; 2773 : 
; 2774 : 		flag = FALSE;                   /* No ls_task_lookahead.        */
; 2775 : 		ls_task_lookahead(pLts_t);

  0183c	56		 push	 esi
  0183d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR _flag$[esp+44], 0
  01845	e8 00 00 00 00	 call	 _ls_task_lookahead

; 2776 : 		if (ls_util_is_white(&(pLts_t->citem)) != FALSE) 

  0184a	8d 86 00 09 00
	00		 lea	 eax, DWORD PTR [esi+2304]
  01850	50		 push	 eax
  01851	e8 00 00 00 00	 call	 _ls_util_is_white
  01856	83 c4 08	 add	 esp, 8
  01859	85 c0		 test	 eax, eax
  0185b	0f 84 af 00 00
	00		 je	 $L72885

; 2777 : 		{
; 2778 : 			flag = TRUE;            /* Did ls_task_lookahead.       */
; 2779 : 			ls_task_readword(phTTS,&(pLts_t->nword[0]));

  01861	8d ae 14 0a 00
	00		 lea	 ebp, DWORD PTR [esi+2580]
  01867	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR _flag$[esp+40], 1
  0186f	55		 push	 ebp
  01870	57		 push	 edi
  01871	e8 00 00 00 00	 call	 _ls_task_readword

; 2780 : 			cp = ls_task_wlookup(pLts_t, &(pLts_t->nword[0]), &nwdtab[0]);

  01876	68 00 00 00 00	 push	 OFFSET FLAT:_nwdtab
  0187b	55		 push	 ebp
  0187c	56		 push	 esi
  0187d	e8 00 00 00 00	 call	 _ls_task_wlookup
  01882	83 c4 14	 add	 esp, 20			; 00000014H
  01885	89 44 24 10	 mov	 DWORD PTR _cp$[esp+44], eax

; 2781 : 			if (cp != FALSE) 

  01889	85 c0		 test	 eax, eax
  0188b	74 7f		 je	 SHORT $L73249

; 2782 : 			{
; 2783 : 				ls_proc_do_sign(phTTS,pLts_t->sign);

  0188d	8b 8e 18 0b 00
	00		 mov	 ecx, DWORD PTR [esi+2840]
  01893	51		 push	 ecx
  01894	57		 push	 edi
  01895	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 2784 : 				pLts_t->pflag=ls_proc_do_number(phTTS,llp, rlp, FALSE);

  0189a	8b 54 24 40	 mov	 edx, DWORD PTR _rlp$[esp+48]
  0189e	6a 00		 push	 0
  018a0	52		 push	 edx
  018a1	53		 push	 ebx
  018a2	57		 push	 edi
  018a3	e8 00 00 00 00	 call	 _ls_proc_do_number
  018a8	89 86 24 0b 00
	00		 mov	 DWORD PTR [esi+2852], eax

; 2785 : 				ls_util_send_phone(phTTS,pLts_t->rbphone);

  018ae	8b 86 20 0b 00
	00		 mov	 eax, DWORD PTR [esi+2848]
  018b4	50		 push	 eax
  018b5	57		 push	 edi
  018b6	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2786 : 				ls_util_send_phone_list(phTTS,cp);

  018bb	8b 4c 24 30	 mov	 ecx, DWORD PTR _cp$[esp+76]
  018bf	51		 push	 ecx
  018c0	57		 push	 edi
  018c1	e8 00 00 00 00	 call	 _ls_util_send_phone_list
  018c6	83 c4 28	 add	 esp, 40			; 00000028H

; 2787 : 				llp = &(pLts_t->nword[0]);
; 2788 : 				while (llp->l_ch != EOS)

  018c9	66 83 7d 00 00	 cmp	 WORD PTR [ebp], 0
  018ce	74 0a		 je	 SHORT $L72888
$L72887:

; 2789 : 					++llp;

  018d0	83 c5 02	 add	 ebp, 2
  018d3	66 83 7d 00 00	 cmp	 WORD PTR [ebp], 0
  018d8	75 f6		 jne	 SHORT $L72887
$L72888:

; 2790 : 
; 2791 : #ifdef SPANISH_SP
; 2792 : 				/* GL 11/16/1998, BATS#721 fix number with currency sign */
; 2793 : 				ls_util_send_phone(phTTS,WBOUND);
; 2794 : 				ls_util_send_phone(phTTS,SP_D);
; 2795 : //				ls_util_send_phone(phTTS,S1);
; 2796 : 				ls_util_send_phone(phTTS,SP_E);
; 2797 : #endif
; 2798 : #ifdef SPANISH_LA
; 2799 : 				/* GL 11/16/1998, BATS#721 fix number with currency sign */
; 2800 : 				ls_util_send_phone(phTTS,WBOUND);
; 2801 : 				ls_util_send_phone(phTTS,LA_D);
; 2802 : //				ls_util_send_phone(phTTS,S1);
; 2803 : 				ls_util_send_phone(phTTS,LA_E);
; 2804 : #endif
; 2805 : 
; 2806 : 				ls_util_send_phone_list(phTTS,type=='$' ? pdollar : ppound);

  018da	8b 44 24 34	 mov	 eax, DWORD PTR _type$[esp+40]
  018de	83 f8 24	 cmp	 eax, 36			; 00000024H
  018e1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pdollar
  018e6	74 05		 je	 SHORT $L73241
  018e8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_ppound
$L73241:
  018ed	50		 push	 eax
  018ee	57		 push	 edi
  018ef	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2807 : 
; 2808 : /* 
; 2809 :  * JDB: this looks like it is only for ENGLISH_US, so for now it's
; 2810 :  *  conditional
; 2811 :  */				
; 2812 : #ifdef ENGLISH_US
; 2813 : 				ls_util_send_phone(phTTS,US_Z);

  018f4	6a 2a		 push	 42			; 0000002aH
  018f6	57		 push	 edi
  018f7	e8 00 00 00 00	 call	 _ls_util_send_phone
  018fc	83 c4 10	 add	 esp, 16			; 00000010H

; 2814 : #endif
; 2815 : #ifdef ENGLISH_UK
; 2816 : 				ls_util_send_phone(phTTS,UK_Z);
; 2817 : #endif
; 2818 : /* GL 02/14/1997, add pural for Spanish */
; 2819 : #ifdef SPANISH_SP
; 2820 : 				/* GL 11/16/1998, BATS#721 fix number with currency sign */
; 2821 : 				ls_util_send_phone(phTTS,SP_E);
; 2822 : 				ls_util_send_phone(phTTS,SP_S);
; 2823 : #endif
; 2824 : #ifdef SPANISH_LA
; 2825 : 				/* GL 11/16/1998, BATS#721 fix number with currency sign */
; 2826 : 				ls_util_send_phone(phTTS,LA_E);
; 2827 : 				ls_util_send_phone(phTTS,LA_S);
; 2828 : #endif
; 2829 : 				return(FINISHED_WORD);

  018ff	b8 03 00 00 00	 mov	 eax, 3
  01904	5f		 pop	 edi
  01905	5e		 pop	 esi
  01906	5d		 pop	 ebp
  01907	5b		 pop	 ebx

; 3001 : }

  01908	83 c4 1c	 add	 esp, 28			; 0000001cH
  0190b	c3		 ret	 0
$L73249:

; 2790 : 
; 2791 : #ifdef SPANISH_SP
; 2792 : 				/* GL 11/16/1998, BATS#721 fix number with currency sign */
; 2793 : 				ls_util_send_phone(phTTS,WBOUND);
; 2794 : 				ls_util_send_phone(phTTS,SP_D);
; 2795 : //				ls_util_send_phone(phTTS,S1);
; 2796 : 				ls_util_send_phone(phTTS,SP_E);
; 2797 : #endif
; 2798 : #ifdef SPANISH_LA
; 2799 : 				/* GL 11/16/1998, BATS#721 fix number with currency sign */
; 2800 : 				ls_util_send_phone(phTTS,WBOUND);
; 2801 : 				ls_util_send_phone(phTTS,LA_D);
; 2802 : //				ls_util_send_phone(phTTS,S1);
; 2803 : 				ls_util_send_phone(phTTS,LA_E);
; 2804 : #endif
; 2805 : 
; 2806 : 				ls_util_send_phone_list(phTTS,type=='$' ? pdollar : ppound);

  0190c	8b 6c 24 38	 mov	 ebp, DWORD PTR _rlp$[esp+40]
$L72885:

; 2830 : 			}
; 2831 : 		}
; 2832 : 
; 2833 : 		/*
; 2834 : 		 * $3      Three dollars.
; 2835 : 		 * $3.00   Three dollars.
; 2836 : 		 * $3.24   Three dollars and twenty four cents.
; 2837 : 		 * $3.240  Three point two four zero dollars.
; 2838 : 		 */
; 2839 : 
; 2840 : 		ls_proc_do_sign(phTTS,pLts_t->sign);

  01910	8b 96 18 0b 00
	00		 mov	 edx, DWORD PTR [esi+2840]
  01916	52		 push	 edx
  01917	57		 push	 edi
  01918	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 2841 : 
; 2842 : 		if (num.n_flp==NULL || (num.n_frp-num.n_flp)==3)        

  0191d	8b 4c 24 24	 mov	 ecx, DWORD PTR _num$[esp+60]
  01921	83 c4 08	 add	 esp, 8
  01924	85 c9		 test	 ecx, ecx
  01926	0f 84 92 00 00
	00		 je	 $L72891
  0192c	8b 44 24 20	 mov	 eax, DWORD PTR _num$[esp+56]
  01930	2b c1		 sub	 eax, ecx
  01932	24 fe		 and	 al, -2			; fffffffeH
  01934	83 f8 06	 cmp	 eax, 6
  01937	0f 84 81 00 00
	00		 je	 $L72891

; 2959 : 			}
; 2960 : 			return(FINISHED_WORD);
; 2961 : 		}
; 2962 : #if defined (SPANISH) || defined (GERMAN)
; 2963 : 		/* GL 02/15/1997, set to -1 to force Spanish say "1" as un  */
; 2964 : 		/* GL 02/17/1997, set to -1 to force German say "1" as ein  */
; 2965 : 		pLts_t->pflag = -1;
; 2966 : #endif
; 2967 : 		pLts_t->pflag = ls_proc_do_number(phTTS,llp, rlp, FALSE);

  0193d	6a 00		 push	 0
  0193f	55		 push	 ebp
  01940	53		 push	 ebx
  01941	57		 push	 edi
  01942	e8 00 00 00 00	 call	 _ls_proc_do_number
  01947	89 86 24 0b 00
	00		 mov	 DWORD PTR [esi+2852], eax

; 2968 : 		ls_util_send_phone_list(phTTS,type=='$' ? pdollar : ppound);

  0194d	8b 44 24 44	 mov	 eax, DWORD PTR _type$[esp+56]
  01951	83 c4 10	 add	 esp, 16			; 00000010H
  01954	83 f8 24	 cmp	 eax, 36			; 00000024H
  01957	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pdollar
  0195c	74 05		 je	 SHORT $L73245
  0195e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_ppound
$L73245:
  01963	50		 push	 eax
  01964	57		 push	 edi
  01965	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2969 : 
; 2970 : /* JDB: again, ENGLISH plurals made conditional... */						
; 2971 : #ifdef ENGLISH_US
; 2972 : 		if (pLts_t->pflag != FALSE)

  0196a	8b 86 24 0b 00
	00		 mov	 eax, DWORD PTR [esi+2852]
  01970	83 c4 08	 add	 esp, 8
  01973	85 c0		 test	 eax, eax
  01975	74 0b		 je	 SHORT $L72905

; 2973 : 			ls_util_send_phone(phTTS,US_Z);

  01977	6a 2a		 push	 42			; 0000002aH
  01979	57		 push	 edi
  0197a	e8 00 00 00 00	 call	 _ls_util_send_phone
  0197f	83 c4 08	 add	 esp, 8
$L72905:

; 2974 : #endif
; 2975 : #ifdef ENGLISH_UK
; 2976 : 		if (pLts_t->pflag != FALSE)
; 2977 : 			ls_util_send_phone(phTTS,UK_Z);
; 2978 : #endif
; 2979 : /* GL 02/14/1997, add pural for Spanish */
; 2980 : #ifdef SPANISH_SP
; 2981 : 		if (pLts_t->pflag != FALSE)
; 2982 : 			ls_util_send_phone(phTTS,SP_S);
; 2983 : #endif
; 2984 : #ifdef SPANISH_LA
; 2985 : 		if (pLts_t->pflag != FALSE)
; 2986 : 			ls_util_send_phone(phTTS,LA_S);
; 2987 : #endif
; 2988 : #ifdef FRENCH
; 2989 : 		if (pLts_t->pflag != FALSE)
; 2990 : 			ls_util_send_phone(phTTS,F_Z);
; 2991 : #endif
; 2992 : 		if (flag != FALSE) 

  01982	8b 44 24 30	 mov	 eax, DWORD PTR _flag$[esp+40]
  01986	85 c0		 test	 eax, eax
  01988	0f 84 c3 00 00
	00		 je	 $L72904
$L72899:

; 2993 : 		{
; 2994 : 			ls_util_send_phone(phTTS,pLts_t->rbphone);

  0198e	8b 8e 20 0b 00
	00		 mov	 ecx, DWORD PTR [esi+2848]
  01994	51		 push	 ecx
  01995	57		 push	 edi
  01996	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2995 : 			ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));

  0199b	8d 96 14 0a 00
	00		 lea	 edx, DWORD PTR [esi+2580]
  019a1	81 c6 14 09 00
	00		 add	 esi, 2324		; 00000914H
  019a7	52		 push	 edx
  019a8	56		 push	 esi
  019a9	e8 00 00 00 00	 call	 _ls_util_copyword
  019ae	83 c4 10	 add	 esp, 16			; 00000010H

; 2996 : 			return(LS_TASK_LOOP);

  019b1	b8 01 00 00 00	 mov	 eax, 1
  019b6	5f		 pop	 edi
  019b7	5e		 pop	 esi
  019b8	5d		 pop	 ebp
  019b9	5b		 pop	 ebx

; 3001 : }

  019ba	83 c4 1c	 add	 esp, 28			; 0000001cH
  019bd	c3		 ret	 0
$L72891:

; 2843 : 		{
; 2844 : 			if (num.n_ilp != NULL) 

  019be	8b 44 24 14	 mov	 eax, DWORD PTR _num$[esp+44]
  019c2	bb 30 00 00 00	 mov	 ebx, 48			; 00000030H
  019c7	85 c0		 test	 eax, eax
  019c9	0f 84 a1 00 00
	00		 je	 $L72893

; 2845 : 			{
; 2846 : 
; 2847 : #if defined (SPANISH) || defined (GERMAN)
; 2848 : 				/* GL 02/15/1997, set to -1 to force Spanish say "1" as un  */
; 2849 : 				/* GL 02/17/1997, set to -1 to force German say "1" as ein  */
; 2850 : 				pLts_t->pflag = -1;
; 2851 : #endif
; 2852 : 				pLts_t->pflag = ls_proc_do_number(phTTS,num.n_ilp, num.n_irp, FALSE);

  019cf	8b 4c 24 18	 mov	 ecx, DWORD PTR _num$[esp+48]
  019d3	6a 00		 push	 0
  019d5	51		 push	 ecx
  019d6	50		 push	 eax
  019d7	57		 push	 edi
  019d8	e8 00 00 00 00	 call	 _ls_proc_do_number
  019dd	89 86 24 0b 00
	00		 mov	 DWORD PTR [esi+2852], eax

; 2853 : 
; 2854 : 				ls_util_send_phone_list(phTTS,type=='$' ? pdollar : ppound);

  019e3	8b 44 24 44	 mov	 eax, DWORD PTR _type$[esp+56]
  019e7	83 c4 10	 add	 esp, 16			; 00000010H
  019ea	83 f8 24	 cmp	 eax, 36			; 00000024H
  019ed	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pdollar
  019f2	74 05		 je	 SHORT $L73243
  019f4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_ppound
$L73243:
  019f9	50		 push	 eax
  019fa	57		 push	 edi
  019fb	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2855 : 
; 2856 : /* 
; 2857 :  * JDB: this is more plural stuff that doesn't seem to happen
; 2858 :  * in the spanish- make it conditional
; 2859 :  */
; 2860 : #ifdef ENGLISH_US
; 2861 : 				if (pLts_t->pflag != FALSE)

  01a00	8b 86 24 0b 00
	00		 mov	 eax, DWORD PTR [esi+2852]
  01a06	83 c4 08	 add	 esp, 8
  01a09	85 c0		 test	 eax, eax
  01a0b	74 0b		 je	 SHORT $L72894

; 2862 : 					ls_util_send_phone(phTTS,US_Z);

  01a0d	6a 2a		 push	 42			; 0000002aH
  01a0f	57		 push	 edi
  01a10	e8 00 00 00 00	 call	 _ls_util_send_phone
  01a15	83 c4 08	 add	 esp, 8
$L72894:

; 2863 : #endif			
; 2864 : #ifdef ENGLISH_UK
; 2865 : 				if (pLts_t->pflag != FALSE)
; 2866 : 					ls_util_send_phone(phTTS,UK_Z);
; 2867 : #endif							
; 2868 : /* GL 02/14/1997, add pural for Spanish */
; 2869 : #ifdef SPANISH_SP
; 2870 : 				if (pLts_t->pflag != FALSE)
; 2871 : 				{
; 2872 : 					/* GL 11/16/1998, BATS#721 fix number with currency sign */
; 2873 : 					ls_util_send_phone(phTTS,SP_E);
; 2874 : 				    ls_util_send_phone(phTTS,SP_S);
; 2875 : 				}
; 2876 : #endif
; 2877 : #ifdef SPANISH_LA
; 2878 : 				if (pLts_t->pflag != FALSE)
; 2879 : 				{
; 2880 : 					/* GL 11/16/1998, BATS#721 fix number with currency sign */
; 2881 : 					ls_util_send_phone(phTTS,LA_E);
; 2882 : 				    ls_util_send_phone(phTTS,LA_S);
; 2883 : 				}
; 2884 : #endif
; 2885 : #ifdef FRENCH
; 2886 : 				if (pLts_t->pflag != FALSE)
; 2887 : 					ls_util_send_phone(phTTS,F_Z);
; 2888 : #endif	
; 2889 : 				if (num.n_flp == NULL) 

  01a18	8b 44 24 1c	 mov	 eax, DWORD PTR _num$[esp+52]
  01a1c	85 c0		 test	 eax, eax
  01a1e	75 19		 jne	 SHORT $L72896

; 2890 : 				{
; 2891 : 					if (flag == FALSE)

  01a20	8b 44 24 30	 mov	 eax, DWORD PTR _flag$[esp+40]
  01a24	85 c0		 test	 eax, eax
  01a26	0f 85 b4 00 00
	00		 jne	 $L72897
  01a2c	5f		 pop	 edi
  01a2d	5e		 pop	 esi
  01a2e	5d		 pop	 ebp

; 2892 : 						return(FINISHED_WORD);

  01a2f	b8 03 00 00 00	 mov	 eax, 3
  01a34	5b		 pop	 ebx

; 3001 : }

  01a35	83 c4 1c	 add	 esp, 28			; 0000001cH
  01a38	c3		 ret	 0
$L72896:

; 2893 : 					ls_util_send_phone(phTTS,pLts_t->rbphone);
; 2894 : 
; 2895 : 					ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));
; 2896 : 
; 2897 : 					return(LS_TASK_LOOP);
; 2898 : 				}
; 2899 : 				if ((num.n_flp+1)->l_ch == '0'
; 2900 : 				&&  (num.n_flp+2)->l_ch == '0') 

  01a39	66 39 58 02	 cmp	 WORD PTR [eax+2], bx
  01a3d	75 1f		 jne	 SHORT $L72898
  01a3f	66 39 58 04	 cmp	 WORD PTR [eax+4], bx
  01a43	75 19		 jne	 SHORT $L72898

; 2901 : 				{
; 2902 : 
; 2903 : 					if (flag == FALSE)

  01a45	8b 44 24 30	 mov	 eax, DWORD PTR _flag$[esp+40]
  01a49	85 c0		 test	 eax, eax
  01a4b	0f 85 3d ff ff
	ff		 jne	 $L72899
$L72904:
  01a51	5f		 pop	 edi
  01a52	5e		 pop	 esi
  01a53	5d		 pop	 ebp

; 2904 : 						return(FINISHED_WORD);

  01a54	b8 03 00 00 00	 mov	 eax, 3
  01a59	5b		 pop	 ebx

; 3001 : }

  01a5a	83 c4 1c	 add	 esp, 28			; 0000001cH
  01a5d	c3		 ret	 0
$L72898:

; 2905 : 					ls_util_send_phone(phTTS,pLts_t->rbphone);
; 2906 : 
; 2907 : 					ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));
; 2908 : 					return(LS_TASK_LOOP);
; 2909 : 				}
; 2910 : #ifndef ENGLISH_UK
; 2911 : 				ls_util_send_phone_list(phTTS,pand);

  01a5e	68 00 00 00 00	 push	 OFFSET FLAT:_pand
  01a63	57		 push	 edi
  01a64	e8 00 00 00 00	 call	 _ls_util_send_phone_list
  01a69	8b 4c 24 24	 mov	 ecx, DWORD PTR _num$[esp+60]
  01a6d	83 c4 08	 add	 esp, 8
$L72893:

; 2912 : #endif
; 2913 : 			}
; 2914 : 			lp2 = num.n_flp + 1;    /* Just after the "."   */
; 2915 : 			if (lp2->l_ch == '0')

  01a70	66 39 59 02	 cmp	 WORD PTR [ecx+2], bx
  01a74	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]
  01a77	75 03		 jne	 SHORT $L72900

; 2916 : 				++lp2;

  01a79	83 c0 02	 add	 eax, 2
$L72900:

; 2917 : 
; 2918 : #if defined (SPANISH) || defined (GERMAN)
; 2919 : 				/* GL 02/15/1997, set to -1 to force Spanish say "1" as un  */
; 2920 : 				/* GL 02/17/1997, set to -1 to force German say "1" as ein  */
; 2921 : 				pLts_t->pflag = -1;
; 2922 : #endif
; 2923 : 			pLts_t->pflag = ls_proc_do_number(phTTS,lp2, num.n_frp, FALSE);

  01a7c	8b 4c 24 20	 mov	 ecx, DWORD PTR _num$[esp+56]
  01a80	6a 00		 push	 0
  01a82	51		 push	 ecx
  01a83	50		 push	 eax
  01a84	57		 push	 edi
  01a85	e8 00 00 00 00	 call	 _ls_proc_do_number

; 2924 : 			ls_util_send_phone(phTTS,WBOUND);

  01a8a	6a 6f		 push	 111			; 0000006fH
  01a8c	57		 push	 edi
  01a8d	89 86 24 0b 00
	00		 mov	 DWORD PTR [esi+2852], eax
  01a93	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2925 : 			if (type == '$') 

  01a98	8b 44 24 4c	 mov	 eax, DWORD PTR _type$[esp+64]
  01a9c	83 c4 18	 add	 esp, 24			; 00000018H
  01a9f	83 f8 24	 cmp	 eax, 36			; 00000024H
  01aa2	75 22		 jne	 SHORT $L72901

; 2926 : 			{
; 2927 : 				ls_util_send_phone_list(phTTS,pcent);

  01aa4	68 00 00 00 00	 push	 OFFSET FLAT:_pcent
  01aa9	57		 push	 edi
  01aaa	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2928 : 				
; 2929 : /* JDB: again, ENGLISH plurals made conditional... */				
; 2930 : #ifdef ENGLISH_US
; 2931 : 				if (pLts_t->pflag != FALSE)

  01aaf	8b 86 24 0b 00
	00		 mov	 eax, DWORD PTR [esi+2852]
  01ab5	83 c4 08	 add	 esp, 8
  01ab8	85 c0		 test	 eax, eax
  01aba	74 18		 je	 SHORT $L72903

; 2932 : 					ls_util_send_phone(phTTS,US_S);

  01abc	6a 29		 push	 41			; 00000029H
  01abe	57		 push	 edi
  01abf	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2933 : #endif					
; 2934 : #ifdef ENGLISH_UK
; 2935 : 				if (pLts_t->pflag != FALSE)
; 2936 : 					ls_util_send_phone(phTTS,UK_S);
; 2937 : #endif					
; 2938 : /* GL 02/14/1997, add pural for Spanish */
; 2939 : #ifdef SPANISH_SP
; 2940 : 				if (pLts_t->pflag != FALSE)
; 2941 : 					ls_util_send_phone(phTTS,SP_S);
; 2942 : #endif
; 2943 : #ifdef SPANISH_LA
; 2944 : 				if (pLts_t->pflag != FALSE)
; 2945 : 					ls_util_send_phone(phTTS,LA_S);
; 2946 : #endif
; 2947 : #ifdef FRENCH
; 2948 : 				if (pLts_t->pflag != FALSE)
; 2949 : 					ls_util_send_phone(phTTS,F_S);
; 2950 : #endif	
; 2951 : 			} 
; 2952 : 			else

  01ac4	eb 0b		 jmp	 SHORT $L73251
$L72901:

; 2953 : 				ls_util_send_phone_list(phTTS,ppence);

  01ac6	68 00 00 00 00	 push	 OFFSET FLAT:_ppence
  01acb	57		 push	 edi
  01acc	e8 00 00 00 00	 call	 _ls_util_send_phone_list
$L73251:
  01ad1	83 c4 08	 add	 esp, 8
$L72903:

; 2954 : 			if (flag != FALSE) 

  01ad4	8b 44 24 30	 mov	 eax, DWORD PTR _flag$[esp+40]
  01ad8	85 c0		 test	 eax, eax
  01ada	0f 84 71 ff ff
	ff		 je	 $L72904
$L72897:

; 2955 : 			{
; 2956 : 				ls_util_send_phone(phTTS,pLts_t->rbphone);

  01ae0	8b 96 20 0b 00
	00		 mov	 edx, DWORD PTR [esi+2848]
  01ae6	52		 push	 edx
  01ae7	57		 push	 edi
  01ae8	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2957 : 				ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));

  01aed	8d 86 14 0a 00
	00		 lea	 eax, DWORD PTR [esi+2580]
  01af3	81 c6 14 09 00
	00		 add	 esi, 2324		; 00000914H
  01af9	50		 push	 eax
  01afa	56		 push	 esi
  01afb	e8 00 00 00 00	 call	 _ls_util_copyword
  01b00	83 c4 10	 add	 esp, 16			; 00000010H

; 2958 : 				return(LS_TASK_LOOP);

  01b03	b8 01 00 00 00	 mov	 eax, 1
  01b08	5f		 pop	 edi
  01b09	5e		 pop	 esi
  01b0a	5d		 pop	 ebp
  01b0b	5b		 pop	 ebx

; 3001 : }

  01b0c	83 c4 1c	 add	 esp, 28			; 0000001cH
  01b0f	c3		 ret	 0
$L72883:
  01b10	5f		 pop	 edi
  01b11	5e		 pop	 esi
  01b12	5d		 pop	 ebp

; 2759 : 		{
; 2760 : #ifdef LS1DEBUG
; 2761 : 			printf("ls_task_parse_number spell \n");
; 2762 : #endif
; 2763 : 
; 2764 : 			return(SPELL_WORD);

  01b13	b8 02 00 00 00	 mov	 eax, 2
  01b18	5b		 pop	 ebx

; 3001 : }

  01b19	83 c4 1c	 add	 esp, 28			; 0000001cH
  01b1c	c3		 ret	 0
_ls_task_currency_processing ENDP
_TEXT	ENDS
EXTRN	_ls_proc_do_date:NEAR
EXTRN	_ls_proc_is_date:NEAR
EXTRN	_ls_proc_do_time:NEAR
EXTRN	_ls_proc_is_am_pm:NEAR
EXTRN	_ls_proc_is_time:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_date_processing PROC NEAR

; 3074 : {  

  01b20	53		 push	 ebx

; 3075 : #ifndef FRENCH
; 3076 : 	LETTER *lp1;
; 3077 : #endif //warning removal
; 3078 : 	PLTS_T pLts_t;
; 3079 : 	
; 3080 : 	pLts_t = phTTS->pLTSThreadData;

  01b21	8b 5c 24 08	 mov	 ebx, DWORD PTR _phTTS$[esp]
  01b25	55		 push	 ebp
  01b26	56		 push	 esi
  01b27	57		 push	 edi
  01b28	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]

; 3081 : 	/*
; 3082 : 	 * Dates and times are handled by special
; 3083 : 	 * validation and speaking routines. Times are a little
; 3084 : 	 * bit special, because of "AM" and "PM" processing.
; 3085 : 	 * Fractions are special too, but less special then a
; 3086 : 	 * date or a time, because signs are legal.
; 3087 : 	 */
; 3088 : 
; 3089 : #ifdef LS1DEBUG
; 3090 : 	printf("date time processing ");
; 3091 : 	printf("left=%u  right=%u\n",llp,rlp);
; 3092 : #endif
; 3093 : 
; 3094 : 	if (pLts_t->sign == 0) 

  01b2b	8b 87 18 0b 00
	00		 mov	 eax, DWORD PTR [edi+2840]
  01b31	85 c0		 test	 eax, eax
  01b33	0f 85 e7 00 00
	00		 jne	 $L72918

; 3095 : 	{
; 3096 : 		if (ls_proc_is_date(llp, rlp) != FALSE) 

  01b39	8b 74 24 1c	 mov	 esi, DWORD PTR _rlp$[esp+12]
  01b3d	8b 6c 24 18	 mov	 ebp, DWORD PTR _llp$[esp+12]
  01b41	56		 push	 esi
  01b42	55		 push	 ebp
  01b43	e8 00 00 00 00	 call	 _ls_proc_is_date
  01b48	83 c4 08	 add	 esp, 8
  01b4b	85 c0		 test	 eax, eax

; 3097 : 		{
; 3098 : 			ls_proc_do_date(phTTS,llp, rlp);

  01b4d	56		 push	 esi
  01b4e	55		 push	 ebp
  01b4f	74 13		 je	 SHORT $L72917
  01b51	53		 push	 ebx
  01b52	e8 00 00 00 00	 call	 _ls_proc_do_date
  01b57	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3099 : #ifndef FRENCH
; 3100 : 			return(FINISHED_WORD);

  01b5a	b8 03 00 00 00	 mov	 eax, 3
  01b5f	5f		 pop	 edi
  01b60	5e		 pop	 esi
  01b61	5d		 pop	 ebp
  01b62	5b		 pop	 ebx

; 3145 : }

  01b63	c3		 ret	 0
$L72917:

; 3101 : #endif
; 3102 : #ifdef FRENCH
; 3103 : 			return 2;
; 3104 : #endif
; 3105 : 		} 
; 3106 : 		
; 3107 : 		if (ls_proc_is_time(pLts_t,llp, rlp) != FALSE) 

  01b64	57		 push	 edi
  01b65	e8 00 00 00 00	 call	 _ls_proc_is_time
  01b6a	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b6d	85 c0		 test	 eax, eax
  01b6f	0f 84 ab 00 00
	00		 je	 $L72918

; 3108 : 		{
; 3109 : 			ls_proc_do_time(phTTS,llp, rlp);

  01b75	56		 push	 esi
  01b76	55		 push	 ebp
  01b77	53		 push	 ebx
  01b78	e8 00 00 00 00	 call	 _ls_proc_do_time

; 3110 : #ifndef FRENCH
; 3111 : 			ls_task_lookahead(pLts_t);

  01b7d	57		 push	 edi
  01b7e	e8 00 00 00 00	 call	 _ls_task_lookahead

; 3112 : 			if (ls_util_is_white(&(pLts_t->citem)) == FALSE)

  01b83	8d 87 00 09 00
	00		 lea	 eax, DWORD PTR [edi+2304]
  01b89	50		 push	 eax
  01b8a	e8 00 00 00 00	 call	 _ls_util_is_white
  01b8f	83 c4 14	 add	 esp, 20			; 00000014H
  01b92	85 c0		 test	 eax, eax
  01b94	75 0a		 jne	 SHORT $L72919
  01b96	5f		 pop	 edi
  01b97	5e		 pop	 esi
  01b98	5d		 pop	 ebp

; 3113 : 				return(FINISHED_WORD);

  01b99	b8 03 00 00 00	 mov	 eax, 3
  01b9e	5b		 pop	 ebx

; 3145 : }

  01b9f	c3		 ret	 0
$L72919:

; 3114 : 			ls_util_send_phone(phTTS,pLts_t->rbphone);

  01ba0	8b 8f 20 0b 00
	00		 mov	 ecx, DWORD PTR [edi+2848]
  01ba6	51		 push	 ecx
  01ba7	53		 push	 ebx
  01ba8	e8 00 00 00 00	 call	 _ls_util_send_phone

; 3115 : 
; 3116 : 			ls_task_readword(phTTS,&(pLts_t->nword[0]));

  01bad	8d af 14 0a 00
	00		 lea	 ebp, DWORD PTR [edi+2580]
  01bb3	55		 push	 ebp
  01bb4	53		 push	 ebx
  01bb5	e8 00 00 00 00	 call	 _ls_task_readword

; 3117 : 
; 3118 : 			lp1 = &(pLts_t->nword[0]);

  01bba	8b f5		 mov	 esi, ebp
  01bbc	83 c4 10	 add	 esp, 16			; 00000010H

; 3119 : 			while (lp1->l_ch != EOS)

  01bbf	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  01bc3	74 09		 je	 SHORT $L72922
$L72921:

; 3120 : 				++lp1;       

  01bc5	83 c6 02	 add	 esi, 2
  01bc8	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  01bcc	75 f7		 jne	 SHORT $L72921
$L72922:

; 3121 : 				
; 3122 : /* GL 02/13/1997, support am, pm for spanish as well since sometime they do use */
; 3123 : 			if (ls_proc_is_am_pm(&(pLts_t->nword[0]), lp1) != FALSE)

  01bce	56		 push	 esi
  01bcf	55		 push	 ebp
  01bd0	e8 00 00 00 00	 call	 _ls_proc_is_am_pm
  01bd5	83 c4 08	 add	 esp, 8
  01bd8	85 c0		 test	 eax, eax
  01bda	74 2a		 je	 SHORT $L72923

; 3124 : 			{
; 3125 : #ifdef LS1DEBUG
; 3126 : 			printf("ls_proc_is_am_pm spell\n");
; 3127 : #endif
; 3128 : 				ls_spel_spell(phTTS,&(pLts_t->nword[0]), lp1);

  01bdc	56		 push	 esi
  01bdd	55		 push	 ebp
  01bde	53		 push	 ebx
  01bdf	e8 00 00 00 00	 call	 _ls_spel_spell

; 3129 : 				ls_task_do_right_punct(phTTS,MISS);

  01be4	6a 00		 push	 0
  01be6	53		 push	 ebx
  01be7	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 3130 : 				ls_task_readword(phTTS,&(pLts_t->cword[0]));

  01bec	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  01bf2	57		 push	 edi
  01bf3	53		 push	 ebx
  01bf4	e8 00 00 00 00	 call	 _ls_task_readword
  01bf9	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3131 : 
; 3132 : 				return(LS_TASK_LOOP);

  01bfc	b8 01 00 00 00	 mov	 eax, 1
  01c01	5f		 pop	 edi
  01c02	5e		 pop	 esi
  01c03	5d		 pop	 ebp
  01c04	5b		 pop	 ebx

; 3145 : }

  01c05	c3		 ret	 0
$L72923:

; 3133 : 			} 	
; 3134 : 			ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));

  01c06	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  01c0c	55		 push	 ebp
  01c0d	57		 push	 edi
  01c0e	e8 00 00 00 00	 call	 _ls_util_copyword
  01c13	83 c4 08	 add	 esp, 8

; 3135 : 			return(LS_TASK_LOOP);

  01c16	b8 01 00 00 00	 mov	 eax, 1
  01c1b	5f		 pop	 edi
  01c1c	5e		 pop	 esi
  01c1d	5d		 pop	 ebp
  01c1e	5b		 pop	 ebx

; 3145 : }

  01c1f	c3		 ret	 0
$L72918:
  01c20	5f		 pop	 edi
  01c21	5e		 pop	 esi
  01c22	5d		 pop	 ebp

; 3136 : 		}
; 3137 : 	}
; 3138 : #endif //ndef FRENCH
; 3139 : #ifdef FRENCH
; 3140 : 			return 2;
; 3141 : 		}
; 3142 : 	}
; 3143 : #endif
; 3144 : 	return(KEEP_SEARCHING);

  01c23	33 c0		 xor	 eax, eax
  01c25	5b		 pop	 ebx

; 3145 : }

  01c26	c3		 ret	 0
_ls_task_date_processing ENDP
_TEXT	ENDS
EXTRN	_ls_proc_is_frac:NEAR
EXTRN	_ls_proc_do_frac:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_frac_processing PROC NEAR

; 3170 : {

  01c30	53		 push	 ebx

; 3171 : 	PLTS_T pLts_t;
; 3172 : 	pLts_t = phTTS->pLTSThreadData;
; 3173 : #ifdef LS1DEBUG
; 3174 : 		printf("entering ls_task_frac_processing\n");
; 3175 : #endif             
; 3176 : 
; 3177 : /* GL 10/03/96  include fraction processing for Spanish */
; 3178 : #if defined (ENGLISH) || defined (SPANISH)	|| defined (FRENCH)
; 3179 : 	if (ls_proc_is_frac(llp, rlp) != FALSE) 

  01c31	8b 5c 24 10	 mov	 ebx, DWORD PTR _rlp$[esp]
  01c35	55		 push	 ebp
  01c36	8b 6c 24 10	 mov	 ebp, DWORD PTR _llp$[esp+4]
  01c3a	56		 push	 esi
  01c3b	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  01c3f	57		 push	 edi
  01c40	53		 push	 ebx
  01c41	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  01c44	55		 push	 ebp
  01c45	e8 00 00 00 00	 call	 _ls_proc_is_frac
  01c4a	83 c4 08	 add	 esp, 8
  01c4d	85 c0		 test	 eax, eax
  01c4f	74 22		 je	 SHORT $L72932

; 3180 : 	{
; 3181 : 		ls_proc_do_sign(phTTS,pLts_t->sign);

  01c51	8b 87 18 0b 00
	00		 mov	 eax, DWORD PTR [edi+2840]
  01c57	50		 push	 eax
  01c58	56		 push	 esi
  01c59	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 3182 : 
; 3183 : 		ls_proc_do_frac(phTTS,llp, rlp);

  01c5e	53		 push	 ebx
  01c5f	55		 push	 ebp
  01c60	56		 push	 esi
  01c61	e8 00 00 00 00	 call	 _ls_proc_do_frac
  01c66	83 c4 14	 add	 esp, 20			; 00000014H

; 3184 : 		return(FINISHED_WORD);

  01c69	b8 03 00 00 00	 mov	 eax, 3
  01c6e	5f		 pop	 edi
  01c6f	5e		 pop	 esi
  01c70	5d		 pop	 ebp
  01c71	5b		 pop	 ebx

; 3188 : }

  01c72	c3		 ret	 0
$L72932:
  01c73	5f		 pop	 edi
  01c74	5e		 pop	 esi
  01c75	5d		 pop	 ebp

; 3185 : 	}            
; 3186 : #endif	
; 3187 : 	return(KEEP_SEARCHING);

  01c76	33 c0		 xor	 eax, eax
  01c78	5b		 pop	 ebx

; 3188 : }

  01c79	c3		 ret	 0
_ls_task_frac_processing ENDP
_TEXT	ENDS
EXTRN	_nabtab:BYTE
EXTRN	_pdegree:BYTE
EXTRN	_ppercent:BYTE
EXTRN	_ls_util_pluralize:NEAR
EXTRN	_ls_proc_do_4_digits:NEAR
EXTRN	_ls_util_is_year:NEAR
EXTRN	_ls_util_is_ordinal:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_lp1$ = 20
_num$ = -24
_ls_task_plain_number_processing PROC NEAR

; 3228 : 	LETTER  *lp2;
; 3229 : 	int     c;
; 3230 : 	NUM     num;
; 3231 : 	char    *cp;
; 3232 : 	PLTS_T pLts_t;
; 3233 : #ifdef FRENCH
; 3234 : 	int Fini=0;
; 3235 : #endif
; 3236 : 	pLts_t = phTTS->pLTSThreadData;
; 3237 : 
; 3238 : 	 /* Kurz. now wants it to be symetrical with negative numbers
; 3239 : 	 EAB-4-11-89*/
; 3240 : #ifdef LS1DEBUG
; 3241 : 	printf("entering ls_task_plain_number_processing\n");
; 3242 : 	printf("number procesing ");
; 3243 : 	printf("left=%u  right=%u\n",llp,rlp);
; 3244 : #endif
; 3245 : /*ls_util_dump_llp_rlp(llp,rlp,"input number is:");*/	
; 3246 : 	if (lp1->l_ch == '.'                    /* As in ".5".          */
; 3247 : 	||  lp1->l_ch == 0xBC                   /* 1/4                  */
; 3248 : 	||  lp1->l_ch == 0xBD                   /* 1/2                  */
; 3249 : 	||  IS_DIGIT(lp1->l_ch))        		/* ls_proc_digit() */

  01c80	8b 4c 24 10	 mov	 ecx, DWORD PTR _lp1$[esp-4]
  01c84	83 ec 18	 sub	 esp, 24			; 00000018H
  01c87	66 8b 01	 mov	 ax, WORD PTR [ecx]
  01c8a	53		 push	 ebx
  01c8b	55		 push	 ebp
  01c8c	56		 push	 esi
  01c8d	8b 74 24 28	 mov	 esi, DWORD PTR _phTTS$[esp+32]
  01c91	57		 push	 edi
  01c92	66 3d 2e 00	 cmp	 ax, 46			; 0000002eH
  01c96	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  01c99	74 1c		 je	 SHORT $L72948
  01c9b	66 3d bc 00	 cmp	 ax, 188			; 000000bcH
  01c9f	74 16		 je	 SHORT $L72948
  01ca1	66 3d bd 00	 cmp	 ax, 189			; 000000bdH
  01ca5	74 10		 je	 SHORT $L72948
  01ca7	0f bf c0	 movsx	 eax, ax
  01caa	f6 80 00 00 00
	00 10		 test	 BYTE PTR _ls_char_feat[eax], 16 ; 00000010H
  01cb1	0f 84 10 03 00
	00		 je	 $L72970
$L72948:

; 3250 : 	{
; 3251 : 		/* GL 9/10/1996, borrow pLts_t->isnumabr to set up the number indication */
; 3252 : 		pLts_t->isnumabr = 3;
; 3253 : 		lp2 = ls_task_parse_number(phTTS,lp1, rlp, &num);

  01cb7	8b 6c 24 34	 mov	 ebp, DWORD PTR _rlp$[esp+36]
  01cbb	8d 54 24 10	 lea	 edx, DWORD PTR _num$[esp+40]
  01cbf	52		 push	 edx
  01cc0	55		 push	 ebp
  01cc1	51		 push	 ecx
  01cc2	56		 push	 esi
  01cc3	c7 87 fc 08 00
	00 03 00 00 00	 mov	 DWORD PTR [edi+2300], 3
  01ccd	e8 00 00 00 00	 call	 _ls_task_parse_number
  01cd2	8b d8		 mov	 ebx, eax
  01cd4	83 c4 10	 add	 esp, 16			; 00000010H

; 3254 : 		if (lp2 == rlp)

  01cd7	3b dd		 cmp	 ebx, ebp
  01cd9	0f 85 5b 01 00
	00		 jne	 $L72949

; 3255 : 		{           
; 3256 : 			/* All digits.          */
; 3257 : 			pLts_t->fc_struct[pLts_t->fc_index] = FC_ADJ;

  01cdf	8b 87 bc 08 00
	00		 mov	 eax, DWORD PTR [edi+2236]
  01ce5	c7 84 87 bc 04
	00 00 01 00 00
	00		 mov	 DWORD PTR [edi+eax*4+1212], 1

; 3258 : 
; 3259 : 			/*eab 8/94 numbers form class needs to be marked xxx*/
; 3260 : #ifndef FRENCH
; 3261 : 			if (pLts_t->sign==0 && ls_util_is_year(llp, rlp)!=FALSE)

  01cf0	8b 87 18 0b 00
	00		 mov	 eax, DWORD PTR [edi+2840]
  01cf6	85 c0		 test	 eax, eax
  01cf8	75 28		 jne	 SHORT $L72950
  01cfa	8b 5c 24 30	 mov	 ebx, DWORD PTR _llp$[esp+36]
  01cfe	55		 push	 ebp
  01cff	53		 push	 ebx
  01d00	e8 00 00 00 00	 call	 _ls_util_is_year
  01d05	83 c4 08	 add	 esp, 8
  01d08	85 c0		 test	 eax, eax
  01d0a	74 16		 je	 SHORT $L72950

; 3262 : 			{
; 3263 : /* GL 11/15/1996, only English need to take special care of 4 digits year */
; 3264 : #ifdef ENGLISH
; 3265 : 				ls_proc_do_4_digits(phTTS,llp);

  01d0c	53		 push	 ebx
  01d0d	56		 push	 esi
  01d0e	e8 00 00 00 00	 call	 _ls_proc_do_4_digits
  01d13	83 c4 08	 add	 esp, 8

; 3266 : #endif
; 3267 : #ifdef GERMAN
; 3268 : 				/* GL 02/13/1997  use 4 digits form for German years */
; 3269 : 				/* GL 04/10/1998  BATS#651 1000-1099, 2000+ pronunce the same way */
; 3270 : 				if ((lp1->l_ch != '1') || ((lp1->l_ch == '1') & ((lp1+1)->l_ch == '0')))
; 3271 : 					pLts_t->pflag = ls_proc_do_number(phTTS,lp1, rlp, ls_util_is_dot(pLts_t));
; 3272 : 				else
; 3273 : 					ls_proc_do_4_digits(phTTS,llp);
; 3274 : #endif
; 3275 : #ifdef SPANISH
; 3276 : 				pLts_t->pflag = ls_proc_do_number(phTTS,lp1, rlp, FALSE);
; 3277 : #endif
; 3278 : 				pLts_t->pflag = TRUE;   /* 1984 is plural.      */

  01d16	c7 87 24 0b 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+2852], 1

; 3279 : 			}
; 3280 : 			else

  01d20	eb 24		 jmp	 SHORT $L72951
$L72950:

; 3281 : #endif
; 3282 : 			{
; 3283 : 				ls_proc_do_sign(phTTS,pLts_t->sign);

  01d22	8b 8f 18 0b 00
	00		 mov	 ecx, DWORD PTR [edi+2840]
  01d28	51		 push	 ecx
  01d29	56		 push	 esi
  01d2a	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 3284 : #ifdef GERMAN
; 3285 : 				/* German use ending period to send ordial number */
; 3286 :                 pLts_t->pflag = ls_proc_do_number(phTTS,lp1, rlp, ls_util_is_dot(pLts_t));
; 3287 : #endif
; 3288 : #if defined (ENGLISH) || defined (SPANISH) || defined (FRENCH)
; 3289 : 				pLts_t->pflag = ls_proc_do_number(phTTS,lp1, rlp, FALSE);

  01d2f	8b 54 24 40	 mov	 edx, DWORD PTR _lp1$[esp+44]
  01d33	6a 00		 push	 0
  01d35	55		 push	 ebp
  01d36	52		 push	 edx
  01d37	56		 push	 esi
  01d38	e8 00 00 00 00	 call	 _ls_proc_do_number
  01d3d	83 c4 18	 add	 esp, 24			; 00000018H
  01d40	89 87 24 0b 00
	00		 mov	 DWORD PTR [edi+2852], eax
$L72951:

; 3290 : #endif
; 3291 : 
; 3292 : 			}
; 3293 : 			
; 3294 : 			ls_task_lookahead(pLts_t);            			/* Watch for "ft."      */

  01d46	57		 push	 edi
  01d47	e8 00 00 00 00	 call	 _ls_task_lookahead

; 3295 : 
; 3296 : 			if (ls_util_is_white(&(pLts_t->citem)) == FALSE)

  01d4c	8d 87 00 09 00
	00		 lea	 eax, DWORD PTR [edi+2304]
  01d52	50		 push	 eax
  01d53	e8 00 00 00 00	 call	 _ls_util_is_white
  01d58	83 c4 08	 add	 esp, 8
  01d5b	85 c0		 test	 eax, eax

; 3297 : 			{
; 3298 : #ifndef FRENCH
; 3299 : 				return(FINISHED_WORD);

  01d5d	0f 84 87 01 00
	00		 je	 $L73265

; 3300 : #endif
; 3301 : #ifdef FRENCH
; 3302 : 				return 2; //Fini = 2
; 3303 : #endif
; 3304 : 			}
; 3305 : 			ls_util_send_phone(phTTS,pLts_t->rbphone);

  01d63	8b 8f 20 0b 00
	00		 mov	 ecx, DWORD PTR [edi+2848]
  01d69	51		 push	 ecx
  01d6a	56		 push	 esi
  01d6b	e8 00 00 00 00	 call	 _ls_util_send_phone

; 3306 : 
; 3307 : 			ls_task_readword(phTTS,&(pLts_t->nword[0]));    /* Read next word.      */

  01d70	8d af 14 0a 00
	00		 lea	 ebp, DWORD PTR [edi+2580]
  01d76	55		 push	 ebp
  01d77	56		 push	 esi
  01d78	e8 00 00 00 00	 call	 _ls_task_readword

; 3308 : 
; 3309 : 			lp1 = &(pLts_t->nword[0]);

  01d7d	8b dd		 mov	 ebx, ebp
  01d7f	83 c4 10	 add	 esp, 16			; 00000010H

; 3310 : 			while (lp1->l_ch != EOS)

  01d82	66 83 3b 00	 cmp	 WORD PTR [ebx], 0
  01d86	74 09		 je	 SHORT $L72955
$L72954:

; 3311 : 				++lp1;

  01d88	83 c3 02	 add	 ebx, 2
  01d8b	66 83 3b 00	 cmp	 WORD PTR [ebx], 0
  01d8f	75 f7		 jne	 SHORT $L72954
$L72955:

; 3312 : #if defined (ENGLISH) || defined (GERMAN)
; 3313 : 			if (ls_proc_is_am_pm(&(pLts_t->nword[0]), lp1) != FALSE) 

  01d91	53		 push	 ebx
  01d92	55		 push	 ebp
  01d93	e8 00 00 00 00	 call	 _ls_proc_is_am_pm
  01d98	83 c4 08	 add	 esp, 8
  01d9b	85 c0		 test	 eax, eax
  01d9d	74 0a		 je	 SHORT $L72956

; 3314 : 			{
; 3315 : #ifdef LS1DEBUG
; 3316 : 			printf("iasmpm spell\n");
; 3317 : #endif
; 3318 : 
; 3319 : 				ls_spel_spell(phTTS,&(pLts_t->nword[0]), lp1);

  01d9f	53		 push	 ebx
  01da0	55		 push	 ebp
  01da1	56		 push	 esi
  01da2	e8 00 00 00 00	 call	 _ls_spel_spell

; 3320 : 				ls_task_do_right_punct(phTTS,MISS);
; 3321 : 				ls_task_readword(phTTS,&(pLts_t->cword[0]));
; 3322 : 
; 3323 : 				return(LS_TASK_LOOP);

  01da7	eb 4f		 jmp	 SHORT $L73266
$L72956:

; 3324 : 			}
; 3325 : #endif
; 3326 : 
; 3327 : 			if (ls_util_is_dot(pLts_t) == FALSE    /* Check if special.    */
; 3328 : 			|| (cp=ls_task_wlookup (pLts_t, &(pLts_t->nword[0]), &nabtab[0]) ) == NULL)

  01da9	57		 push	 edi
  01daa	e8 00 00 00 00	 call	 _ls_util_is_dot
  01daf	83 c4 04	 add	 esp, 4
  01db2	85 c0		 test	 eax, eax
  01db4	74 67		 je	 SHORT $L72959
  01db6	68 00 00 00 00	 push	 OFFSET FLAT:_nabtab
  01dbb	55		 push	 ebp
  01dbc	57		 push	 edi
  01dbd	e8 00 00 00 00	 call	 _ls_task_wlookup
  01dc2	83 c4 0c	 add	 esp, 12			; 0000000cH
  01dc5	85 c0		 test	 eax, eax
  01dc7	74 54		 je	 SHORT $L72959

; 3384 : #endif
; 3385 : #ifdef FRENCH
; 3386 : 				return 4; //Fini = 4;
; 3387 : #endif
; 3388 : 			}
; 3389 : 			pLts_t->isnumabr=3;
; 3390 : #ifndef FRENCH
; 3391 : 			if (pLts_t->pflag != FALSE)

  01dc9	8b 8f 24 0b 00
	00		 mov	 ecx, DWORD PTR [edi+2852]
  01dcf	c7 87 fc 08 00
	00 03 00 00 00	 mov	 DWORD PTR [edi+2300], 3
  01dd9	85 c9		 test	 ecx, ecx
  01ddb	74 0e		 je	 SHORT $L72963

; 3392 : 			{   /* Pick right form.     */
; 3393 : 				while (*cp++ != SIL)

  01ddd	8a 10		 mov	 dl, BYTE PTR [eax]
  01ddf	40		 inc	 eax
  01de0	84 d2		 test	 dl, dl
  01de2	74 07		 je	 SHORT $L72963
$L72962:
  01de4	8a 08		 mov	 cl, BYTE PTR [eax]
  01de6	40		 inc	 eax
  01de7	84 c9		 test	 cl, cl
  01de9	75 f9		 jne	 SHORT $L72962
$L72963:

; 3394 : 					;
; 3395 : 			}
; 3396 : #endif
; 3397 : 			ls_util_send_phone_list(phTTS,cp);           	/* Send abbreviation.   */

  01deb	50		 push	 eax
  01dec	56		 push	 esi
  01ded	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 3398 : 
; 3399 : 			ls_util_read_item(phTTS);             			/* Eat up the ".".      */

  01df2	56		 push	 esi
  01df3	e8 00 00 00 00	 call	 _ls_util_read_item
$L73266:

; 3400 : #ifndef FRENCH
; 3401 : 			ls_task_do_right_punct(phTTS,MISS);

  01df8	6a 00		 push	 0
  01dfa	56		 push	 esi
  01dfb	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 3402 : 			ls_task_readword(phTTS,&(pLts_t->cword[0]));    /* Advance, continue.   */

  01e00	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  01e06	57		 push	 edi
  01e07	56		 push	 esi
  01e08	e8 00 00 00 00	 call	 _ls_task_readword
  01e0d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3403 : 
; 3404 : 			return(LS_TASK_LOOP);

  01e10	b8 01 00 00 00	 mov	 eax, 1
  01e15	5f		 pop	 edi
  01e16	5e		 pop	 esi
  01e17	5d		 pop	 ebp
  01e18	5b		 pop	 ebx

; 3556 : #endif
; 3557 : }

  01e19	83 c4 18	 add	 esp, 24			; 00000018H
  01e1c	c3		 ret	 0
$L72959:

; 3329 : 			{
; 3330 : #ifdef FRENCH
; 3331 :       /*
; 3332 :         right word not an abreviation :
; 3333 :         next not ending in .,  like 10 avions
; 3334 :         or not in nabtab         like 10 TT.
; 3335 :       */
; 3336 : 
; 3337 :       /* for the linking, keep graphemes of the last digit */
; 3338 :       if (llp==rlp-1                   /* one digit */
; 3339 :         || ( (rlp-1)->l_ch != '0'
; 3340 :         && (rlp-2)->l_ch!='1' && (rlp-2)->l_ch!='7'
; 3341 :         && (rlp-2)->l_ch!='9') ) {
; 3342 :         /*
; 3343 :           1 digit : 1 enfant
; 3344 :           not : ..0    : 70, 100
; 3345 :           not 1. 7. 9. : 12, 17, 99
; 3346 :           OK : 0, 1, 5, 31, 55, 82
; 3347 :         */
; 3348 :         pLts_t->contgc = TRUE;
; 3349 :         switch ( (rlp-1)->l_ch) {
; 3350 :           case '1': strcpy( pLts_t->precedent, "un");     break;
; 3351 :           case '2': strcpy( pLts_t->precedent, "deux");   break;
; 3352 :           case '3': strcpy( pLts_t->precedent, "trois");  break;
; 3353 :           case '4': strcpy( pLts_t->precedent, "quatre"); break;
; 3354 :           case '5': strcpy( pLts_t->precedent, "cinq");   break;
; 3355 :           case '6': strcpy( pLts_t->precedent, "six");    break;
; 3356 :           case '7': strcpy( pLts_t->precedent, "sept");   break;
; 3357 :           case '8': strcpy( pLts_t->precedent, "huit");   break;
; 3358 :           case '9': strcpy( pLts_t->precedent, "neuf");   break;
; 3359 :         }
; 3360 :       } else if ( (rlp-1)->l_ch=='0' && (rlp-2)->l_ch!='0' ) {
; 3361 :         /* 10, 70, 2370 120, 80 */
; 3362 :         pLts_t->contgc = TRUE;
; 3363 :         switch ( (rlp-2)->l_ch) {
; 3364 :           case '1':
; 3365 :           case '7':
; 3366 :           case '9': strcpy( pLts_t->precedent, "dis");    break;
; 3367 :           case '2': strcpy( pLts_t->precedent, "vingt");  break;
; 3368 :           case '8': strcpy( pLts_t->precedent, "vingts"); break;
; 3369 :         }
; 3370 :       } else if ( llp<=(rlp-3) && (rlp-3)->l_ch!='0') {
; 3371 :         if ( (rlp-2)->l_ch=='0' && (rlp-1)->l_ch=='0' ) {
; 3372 :           pLts_t->contgc = TRUE;
; 3373 :           if ( (rlp-3)->l_ch=='1' ) {
; 3374 :         strcpy( pLts_t->precedent, "cent"); /* 100 */
; 3375 :           } else if ( (rlp-3)->l_ch!='0' ) {
; 3376 :         strcpy( pLts_t->precedent, "cents");  /* 800 */
; 3377 :           }
; 3378 :         }
; 3379 :       }
; 3380 : #endif
; 3381 : 				ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));

  01e1d	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  01e23	55		 push	 ebp
  01e24	57		 push	 edi
  01e25	e8 00 00 00 00	 call	 _ls_util_copyword
  01e2a	83 c4 08	 add	 esp, 8

; 3382 : #ifndef FRENCH
; 3383 : 				return(LS_TASK_LOOP);

  01e2d	b8 01 00 00 00	 mov	 eax, 1
  01e32	5f		 pop	 edi
  01e33	5e		 pop	 esi
  01e34	5d		 pop	 ebp
  01e35	5b		 pop	 ebx

; 3556 : #endif
; 3557 : }

  01e36	83 c4 18	 add	 esp, 24			; 00000018H
  01e39	c3		 ret	 0
$L72949:

; 3405 : #endif
; 3406 : #ifdef FRENCH
; 3407 : 			return 3;
; 3408 : #endif
; 3409 : 		}
; 3410 : 
; 3411 : 		/*
; 3412 : 		 * Deal with plural numbers, like
; 3413 : 		 * "60s" and "60's". The last phoneme of
; 3414 : 		 * the number is hidden in "pLts_t->lphone", which is
; 3415 : 		 * looked at by the standard pluralizing
; 3416 : 		 * code in "ls7.c". Also deal with cents,
; 3417 : 		 * percents, and degrees.
; 3418 : 		 */
; 3419 :                          
; 3420 : /* JDB:  Spanish doesn't use this section! */                        
; 3421 : #ifdef ENGLISH
; 3422 : 		if (lp2+2 == rlp) 

  01e3a	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
  01e3d	3b d5		 cmp	 edx, ebp
  01e3f	75 6c		 jne	 SHORT $L72964

; 3423 : 		{             
; 3424 : 			/* 2 after the digits.  */
; 3425 : 			/* Plurals, like "60's".                        */
; 3426 : 			if (lp2->l_ch=='\'' && (lp2+1)->l_ch=='s') 

  01e41	66 83 3b 27	 cmp	 WORD PTR [ebx], 39	; 00000027H
  01e45	75 1e		 jne	 SHORT $L72965
  01e47	66 83 7b 02 73	 cmp	 WORD PTR [ebx+2], 115	; 00000073H
  01e4c	75 17		 jne	 SHORT $L72965

; 3427 : 			{
; 3428 : 				ls_proc_do_sign(phTTS,pLts_t->sign);

  01e4e	8b 87 18 0b 00
	00		 mov	 eax, DWORD PTR [edi+2840]
  01e54	50		 push	 eax
  01e55	56		 push	 esi
  01e56	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 3429 : 
; 3430 : 				pLts_t->pflag=ls_proc_do_number(phTTS,lp1, lp2, FALSE);

  01e5b	8b 4c 24 40	 mov	 ecx, DWORD PTR _lp1$[esp+44]
  01e5f	6a 00		 push	 0
  01e61	53		 push	 ebx
  01e62	51		 push	 ecx

; 3431 : 				ls_util_pluralize(phTTS);
; 3432 : 				return(FINISHED_WORD);

  01e63	eb 70		 jmp	 SHORT $L73264
$L72965:

; 3433 : 			}               
; 3434 : #endif		 
; 3435 : /* JDB: end of dependent section */
; 3436 : 			
; 3437 : 			/* Ordinals, like "1st", "2nd", "3rd".          */
; 3438 : #ifndef FRENCH
; 3439 : 			if (pLts_t->sign==0 && ls_util_is_ordinal(phTTS,&num)!=FALSE) 

  01e65	8b 87 18 0b 00
	00		 mov	 eax, DWORD PTR [edi+2840]
  01e6b	85 c0		 test	 eax, eax
  01e6d	0f 85 54 01 00
	00		 jne	 $L72970
  01e73	8d 54 24 10	 lea	 edx, DWORD PTR _num$[esp+40]
  01e77	52		 push	 edx
  01e78	56		 push	 esi
  01e79	e8 00 00 00 00	 call	 _ls_util_is_ordinal
  01e7e	83 c4 08	 add	 esp, 8
  01e81	85 c0		 test	 eax, eax
  01e83	0f 84 3e 01 00
	00		 je	 $L72970

; 3440 : 			{
; 3441 : 				pLts_t->pflag=ls_proc_do_number(phTTS,llp, lp2, TRUE);

  01e89	8b 44 24 30	 mov	 eax, DWORD PTR _llp$[esp+36]
  01e8d	6a 01		 push	 1
  01e8f	53		 push	 ebx
  01e90	50		 push	 eax
  01e91	56		 push	 esi
  01e92	e8 00 00 00 00	 call	 _ls_proc_do_number
  01e97	83 c4 10	 add	 esp, 16			; 00000010H
  01e9a	89 87 24 0b 00
	00		 mov	 DWORD PTR [edi+2852], eax

; 3442 : 				return(FINISHED_WORD);

  01ea0	b8 03 00 00 00	 mov	 eax, 3
  01ea5	5f		 pop	 edi
  01ea6	5e		 pop	 esi
  01ea7	5d		 pop	 ebp
  01ea8	5b		 pop	 ebx

; 3556 : #endif
; 3557 : }

  01ea9	83 c4 18	 add	 esp, 24			; 00000018H
  01eac	c3		 ret	 0
$L72964:

; 3443 : 			}
; 3444 : #endif
; 3445 : #ifdef FRENCH
; 3446 : 		if (lp2+3 == rlp && lp2->l_ch==(unsigned char)'è' && (lp2+1)->l_ch=='m' 
; 3447 : 			&& ((lp2+2)->l_ch=='e')) 
; 3448 : 			{
; 3449 : 				pLts_t->pflag= ls_proc_do_number (phTTS, llp, lp2, TRUE); /* TRUE for ordinal */
; 3450 : 				return(2);
; 3451 : 		} 
; 3452 : 		else if ( llp+3 == rlp && llp->l_ch=='1'    /* 1er */
; 3453 : 		&& (llp+1)->l_ch=='e' && (llp+2)->l_ch=='r' ) 
; 3454 : 		{
; 3455 : 			ls_util_send_phone_list (phTTS, premier);
; 3456 : //			sendindex (llp, rlp);
; 3457 : //			Fini=2;
; 3458 : 			return (2);
; 3459 : 		} 
; 3460 : 		else if ( llp+4 == rlp && llp->l_ch=='1'    /* 1e2re */
; 3461 : 		&& (llp+1)->l_ch==(unsigned char)'è' && (llp+2)->l_ch=='r'
; 3462 : 		&& (llp+3)->l_ch=='e' ) 
; 3463 : 		{
; 3464 : 			ls_util_send_phone_list (phTTS, premiere);
; 3465 : //			sendindex (llp, rlp);
; 3466 : //			Fini=2;
; 3467 : 			return (2);
; 3468 : 		} 
; 3469 : 		else if (lp2+1 == rlp) 
; 3470 : 		{
; 3471 :     /* there is 1 character after last digit like 10% or 10° */
; 3472 : 		if ( (c=lp2->l_ch)=='%' || c==(unsigned char)'°') 
; 3473 : 		{
; 3474 : 			ls_proc_do_sign (phTTS, pLts_t->sign);
; 3475 : //			sendindex (llp, lp1);
; 3476 : 			ls_proc_do_number (phTTS, lp1, lp2, FALSE);
; 3477 : 		if ( c=='%') 
; 3478 : 		{
; 3479 : 			ls_util_send_phone_list (phTTS, ppercent);
; 3480 : 		} 
; 3481 : 		else 
; 3482 : 		{
; 3483 : 			ls_util_send_phone (phTTS, WBOUND);
; 3484 : 			ls_util_send_phone_list (phTTS, pdegree);
; 3485 : 		}
; 3486 : //			sendindex (lp2,rlp);
; 3487 : //			Fini=2;
; 3488 : 		return (2);
; 3489 : 		} /* if % ou ° */
; 3490 :       } /* else if one char after number */
; 3491 : 		}
; 3492 : //		}
; 3493 : #endif
; 3494 : #ifdef FRENCH 
; 3495 : 		return KEEP_SEARCHING;
; 3496 : #endif
; 3497 : #ifndef FRENCH
; 3498 : /* JDB:  Spanish doesn't use this section! */                        
; 3499 : #ifdef ENGLISH			
; 3500 : 		}
; 3501 : 		else
; 3502 : #endif		
; 3503 : 		if (lp2+1 == rlp) 

  01ead	8d 4b 02	 lea	 ecx, DWORD PTR [ebx+2]
  01eb0	3b cd		 cmp	 ecx, ebp
  01eb2	0f 85 0f 01 00
	00		 jne	 $L72970

; 3504 : 		{      
; 3505 : 			/* 1 after the digits.  */
; 3506 : 			/* Plurals, like "60s". */
; 3507 : 			if ((c=lp2->l_ch) == 's') 

  01eb8	0f bf 2b	 movsx	 ebp, WORD PTR [ebx]
  01ebb	83 fd 73	 cmp	 ebp, 115		; 00000073H
  01ebe	75 37		 jne	 SHORT $L72969

; 3508 : 			{           
; 3509 : 				ls_proc_do_sign(phTTS,pLts_t->sign);

  01ec0	8b 97 18 0b 00
	00		 mov	 edx, DWORD PTR [edi+2840]
  01ec6	52		 push	 edx
  01ec7	56		 push	 esi
  01ec8	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 3510 : 				pLts_t->pflag=ls_proc_do_number(phTTS,lp1, lp2, FALSE);

  01ecd	8b 44 24 40	 mov	 eax, DWORD PTR _lp1$[esp+44]
  01ed1	6a 00		 push	 0
  01ed3	53		 push	 ebx
  01ed4	50		 push	 eax
$L73264:
  01ed5	56		 push	 esi
  01ed6	e8 00 00 00 00	 call	 _ls_proc_do_number

; 3511 : 				ls_util_pluralize(phTTS);

  01edb	56		 push	 esi
  01edc	89 87 24 0b 00
	00		 mov	 DWORD PTR [edi+2852], eax
  01ee2	e8 00 00 00 00	 call	 _ls_util_pluralize
  01ee7	83 c4 1c	 add	 esp, 28			; 0000001cH
$L73265:
  01eea	5f		 pop	 edi
  01eeb	5e		 pop	 esi
  01eec	5d		 pop	 ebp

; 3512 : 				return(FINISHED_WORD);

  01eed	b8 03 00 00 00	 mov	 eax, 3
  01ef2	5b		 pop	 ebx

; 3556 : #endif
; 3557 : }

  01ef3	83 c4 18	 add	 esp, 24			; 00000018H
  01ef6	c3		 ret	 0
$L72969:

; 3513 : 			}
; 3514 : 			/* "10%", "10 cents", "10 degrees". */
; 3515 : 			if (c=='%' || c==0xA2 || c==0xB0) 

  01ef7	83 fd 25	 cmp	 ebp, 37			; 00000025H
  01efa	74 14		 je	 SHORT $L72971
  01efc	81 fd a2 00 00
	00		 cmp	 ebp, 162		; 000000a2H
  01f02	74 0c		 je	 SHORT $L72971
  01f04	81 fd b0 00 00
	00		 cmp	 ebp, 176		; 000000b0H
  01f0a	0f 85 b7 00 00
	00		 jne	 $L72970
$L72971:

; 3516 : 			{
; 3517 : 				ls_proc_do_sign(phTTS,pLts_t->sign);

  01f10	8b 8f 18 0b 00
	00		 mov	 ecx, DWORD PTR [edi+2840]
  01f16	51		 push	 ecx
  01f17	56		 push	 esi
  01f18	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 3518 : 				pLts_t->pflag = ls_proc_do_number(phTTS,lp1, lp2, FALSE);

  01f1d	8b 54 24 40	 mov	 edx, DWORD PTR _lp1$[esp+44]
  01f21	6a 00		 push	 0
  01f23	53		 push	 ebx
  01f24	52		 push	 edx
  01f25	56		 push	 esi
  01f26	e8 00 00 00 00	 call	 _ls_proc_do_number
  01f2b	83 c4 18	 add	 esp, 24			; 00000018H

; 3519 : 				if (c == '%')

  01f2e	83 fd 25	 cmp	 ebp, 37			; 00000025H
  01f31	89 87 24 0b 00
	00		 mov	 DWORD PTR [edi+2852], eax
  01f37	75 1b		 jne	 SHORT $L72972

; 3520 : 					ls_util_send_phone_list(phTTS,ppercent);

  01f39	68 00 00 00 00	 push	 OFFSET FLAT:_ppercent
  01f3e	56		 push	 esi
  01f3f	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 3543 : 							ls_util_send_phone(phTTS,US_Z);

  01f44	83 c4 08	 add	 esp, 8

; 3544 : #endif							
; 3545 : #ifdef ENGLISH_UK
; 3546 : 						if (pLts_t->pflag != FALSE)
; 3547 : 							ls_util_send_phone(phTTS,UK_Z);
; 3548 : #endif								
; 3549 : 					}
; 3550 : 				}
; 3551 : 				return(FINISHED_WORD);

  01f47	b8 03 00 00 00	 mov	 eax, 3
  01f4c	5f		 pop	 edi
  01f4d	5e		 pop	 esi
  01f4e	5d		 pop	 ebp
  01f4f	5b		 pop	 ebx

; 3556 : #endif
; 3557 : }

  01f50	83 c4 18	 add	 esp, 24			; 00000018H
  01f53	c3		 ret	 0
$L72972:

; 3521 : 				else 
; 3522 : 				{
; 3523 : 					ls_util_send_phone(phTTS,WBOUND);

  01f54	6a 6f		 push	 111			; 0000006fH
  01f56	56		 push	 esi
  01f57	e8 00 00 00 00	 call	 _ls_util_send_phone
  01f5c	83 c4 08	 add	 esp, 8

; 3524 : 					if (c == 0xA2) 

  01f5f	81 fd a2 00 00
	00		 cmp	 ebp, 162		; 000000a2H
  01f65	75 30		 jne	 SHORT $L72974

; 3525 : 					{
; 3526 : 						ls_util_send_phone_list(phTTS,pcent);        

  01f67	68 00 00 00 00	 push	 OFFSET FLAT:_pcent
  01f6c	56		 push	 esi
  01f6d	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 3527 : /* JDB: again, English plurals made conditional... */							
; 3528 : #ifdef ENGLISH_US
; 3529 : 						if (pLts_t->pflag != FALSE)

  01f72	8b 87 24 0b 00
	00		 mov	 eax, DWORD PTR [edi+2852]
  01f78	83 c4 08	 add	 esp, 8
  01f7b	85 c0		 test	 eax, eax
  01f7d	74 3b		 je	 SHORT $L72977

; 3530 : 							ls_util_send_phone(phTTS,US_S);

  01f7f	6a 29		 push	 41			; 00000029H

; 3543 : 							ls_util_send_phone(phTTS,US_Z);

  01f81	56		 push	 esi
  01f82	e8 00 00 00 00	 call	 _ls_util_send_phone
  01f87	83 c4 08	 add	 esp, 8

; 3544 : #endif							
; 3545 : #ifdef ENGLISH_UK
; 3546 : 						if (pLts_t->pflag != FALSE)
; 3547 : 							ls_util_send_phone(phTTS,UK_Z);
; 3548 : #endif								
; 3549 : 					}
; 3550 : 				}
; 3551 : 				return(FINISHED_WORD);

  01f8a	b8 03 00 00 00	 mov	 eax, 3
  01f8f	5f		 pop	 edi
  01f90	5e		 pop	 esi
  01f91	5d		 pop	 ebp
  01f92	5b		 pop	 ebx

; 3556 : #endif
; 3557 : }

  01f93	83 c4 18	 add	 esp, 24			; 00000018H
  01f96	c3		 ret	 0
$L72974:

; 3531 : #endif							
; 3532 : #ifdef ENGLISH_UK					
; 3533 : 						if (pLts_t->pflag != FALSE)
; 3534 : 							ls_util_send_phone(phTTS,UK_S);
; 3535 : #endif							
; 3536 : 					} 
; 3537 : 					else 
; 3538 : 					{
; 3539 : 						ls_util_send_phone_list(phTTS,pdegree);

  01f97	68 00 00 00 00	 push	 OFFSET FLAT:_pdegree
  01f9c	56		 push	 esi
  01f9d	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 3540 : /* JDB: again, English plurals made conditional... */				
; 3541 : #ifdef ENGLISH_US
; 3542 : 						if (pLts_t->pflag != FALSE)

  01fa2	8b 87 24 0b 00
	00		 mov	 eax, DWORD PTR [edi+2852]
  01fa8	83 c4 08	 add	 esp, 8
  01fab	85 c0		 test	 eax, eax
  01fad	74 0b		 je	 SHORT $L72977

; 3543 : 							ls_util_send_phone(phTTS,US_Z);

  01faf	6a 2a		 push	 42			; 0000002aH
  01fb1	56		 push	 esi
  01fb2	e8 00 00 00 00	 call	 _ls_util_send_phone
  01fb7	83 c4 08	 add	 esp, 8
$L72977:
  01fba	5f		 pop	 edi
  01fbb	5e		 pop	 esi
  01fbc	5d		 pop	 ebp

; 3544 : #endif							
; 3545 : #ifdef ENGLISH_UK
; 3546 : 						if (pLts_t->pflag != FALSE)
; 3547 : 							ls_util_send_phone(phTTS,UK_Z);
; 3548 : #endif								
; 3549 : 					}
; 3550 : 				}
; 3551 : 				return(FINISHED_WORD);

  01fbd	b8 03 00 00 00	 mov	 eax, 3
  01fc2	5b		 pop	 ebx

; 3556 : #endif
; 3557 : }

  01fc3	83 c4 18	 add	 esp, 24			; 00000018H
  01fc6	c3		 ret	 0
$L72970:
  01fc7	5f		 pop	 edi
  01fc8	5e		 pop	 esi
  01fc9	5d		 pop	 ebp

; 3552 : 			}
; 3553 : 		}
; 3554 : 	}
; 3555 : 	return(KEEP_SEARCHING);

  01fca	33 c0		 xor	 eax, eax
  01fcc	5b		 pop	 ebx

; 3556 : #endif
; 3557 : }

  01fcd	83 c4 18	 add	 esp, 24			; 00000018H
  01fd0	c3		 ret	 0
_ls_task_plain_number_processing ENDP
_TEXT	ENDS
EXTRN	_ls_proc_do_part_number:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_part_number PROC NEAR

; 3582 : {              

  01fe0	55		 push	 ebp

; 3583 : 	int c;
; 3584 : 	LETTER *lp1;
; 3585 : 	PLTS_T pLts_t;
; 3586 : 	pLts_t = phTTS->pLTSThreadData;

  01fe1	8b 6c 24 08	 mov	 ebp, DWORD PTR _phTTS$[esp]
  01fe5	56		 push	 esi

; 3587 : 
; 3588 : #ifdef LS1DEBUG
; 3589 : 	printf("entering ls_task_part_number\n");
; 3590 : 	printf("no more heuristics ");
; 3591 : 	printf("left=%u  right=%u\n",llp,rlp);
; 3592 : #endif        
; 3593 : 	lp1=llp;

  01fe6	8b 74 24 10	 mov	 esi, DWORD PTR _llp$[esp+4]
  01fea	8b 55 10	 mov	 edx, DWORD PTR [ebp+16]
  01fed	57		 push	 edi

; 3594 : 	while (lp1 != rlp) 

  01fee	8b 7c 24 18	 mov	 edi, DWORD PTR _rlp$[esp+8]
  01ff2	8b ce		 mov	 ecx, esi
  01ff4	3b f7		 cmp	 esi, edi
  01ff6	74 46		 je	 SHORT $L72990
$L72989:

; 3595 : 	{
; 3596 : 		c = lp1->l_ch;

  01ff8	0f bf 01	 movsx	 eax, WORD PTR [ecx]

; 3597 : 		if (c=='/' || (c>='0' && c<='9'))

  01ffb	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  01ffe	74 29		 je	 SHORT $L72992
  02000	83 f8 30	 cmp	 eax, 48			; 00000030H
  02003	7c 05		 jl	 SHORT $L72991
  02005	83 f8 39	 cmp	 eax, 57			; 00000039H
  02008	7e 1f		 jle	 SHORT $L72992
$L72991:

; 3600 : 		}
; 3601 : 		else if (c == '\'')

  0200a	83 f8 27	 cmp	 eax, 39			; 00000027H
  0200d	75 0a		 jne	 SHORT $L72994

; 3602 : 		{
; 3603 : 			pLts_t->lflag |= SQUOTE;

  0200f	8b 82 f8 08 00
	00		 mov	 eax, DWORD PTR [edx+2296]
  02015	0c 08		 or	 al, 8

; 3604 : 		}
; 3605 : 		else if (c!='-' && !(IS_ALPHA(c)))

  02017	eb 18		 jmp	 SHORT $L73271
$L72994:
  02019	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0201c	74 19		 je	 SHORT $L72996
  0201e	f6 80 00 00 00
	00 03		 test	 BYTE PTR _ls_char_feat[eax], 3
  02025	74 27		 je	 SHORT $L73269
  02027	eb 0e		 jmp	 SHORT $L72996
$L72992:

; 3598 : 		{
; 3599 : 			pLts_t->lflag |= DIGSLSH;

  02029	8b 82 f8 08 00
	00		 mov	 eax, DWORD PTR [edx+2296]
  0202f	0c 04		 or	 al, 4
$L73271:
  02031	89 82 f8 08 00
	00		 mov	 DWORD PTR [edx+2296], eax
$L72996:

; 3606 : 		{
; 3607 : #ifdef LS1DEBUG
; 3608 : 			printf(" drop through spell %c  \n",c);
; 3609 : #endif
; 3610 : #ifndef FRENCH
; 3611 : 			return(SPELL_WORD);
; 3612 : #endif
; 3613 : #ifdef FRENCH
; 3614 : 			return 1;
; 3615 : #endif
; 3616 : 		}
; 3617 : 		++lp1;

  02037	83 c1 02	 add	 ecx, 2
  0203a	3b cf		 cmp	 ecx, edi
  0203c	75 ba		 jne	 SHORT $L72989
$L72990:

; 3618 : 	}
; 3619 : 	if (((pLts_t->lflag)&DIGSLSH) != 0) 

  0203e	8b 92 f8 08 00
	00		 mov	 edx, DWORD PTR [edx+2296]
  02044	f6 c2 04	 test	 dl, 4
  02047	74 22		 je	 SHORT $L72997

; 3620 : 	{             /* Parts have digits or */
; 3621 : 		if (((pLts_t->lflag)&SQUOTE) != 0)        /* slashes, and do not  */

  02049	f6 c2 08	 test	 dl, 8
  0204c	74 09		 je	 SHORT $L72998
$L73269:
  0204e	5f		 pop	 edi
  0204f	5e		 pop	 esi

; 3622 : 		{
; 3623 : #ifdef LS1DEBUG
; 3624 : 			printf(" punt spell \n");
; 3625 : #endif
; 3626 : #ifndef FRENCH
; 3627 : 			return(SPELL_WORD);

  02050	b8 02 00 00 00	 mov	 eax, 2
  02055	5d		 pop	 ebp

; 3642 : }

  02056	c3		 ret	 0
$L72998:

; 3628 : #endif
; 3629 : #ifdef FRENCH
; 3630 : 			return 1;
; 3631 : #endif
; 3632 : 		}
; 3633 : 		ls_proc_do_part_number(phTTS,llp, rlp);

  02057	57		 push	 edi
  02058	56		 push	 esi
  02059	55		 push	 ebp
  0205a	e8 00 00 00 00	 call	 _ls_proc_do_part_number
  0205f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3634 : #ifndef FRENCH
; 3635 : 		return(FINISHED_WORD);

  02062	b8 03 00 00 00	 mov	 eax, 3
  02067	5f		 pop	 edi
  02068	5e		 pop	 esi
  02069	5d		 pop	 ebp

; 3642 : }

  0206a	c3		 ret	 0
$L72997:
  0206b	5f		 pop	 edi
  0206c	5e		 pop	 esi

; 3636 : #endif
; 3637 : #ifdef FRENCH
; 3638 : 		return 2;
; 3639 : #endif
; 3640 : 	}
; 3641 : 	return(KEEP_SEARCHING);                           

  0206d	33 c0		 xor	 eax, eax
  0206f	5d		 pop	 ebp

; 3642 : }

  02070	c3		 ret	 0
_ls_task_part_number ENDP
_TEXT	ENDS
EXTRN	_ls_rule_do_lts:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_firsttim$ = 12
_ls_task_process_word PROC NEAR

; 3671 : 	volatile int    firsttim;
; 3672 : 	LETTER *lp1;
; 3673 : 	LETTER *lp2;
; 3674 : 	int     type;
; 3675 : 	int     c;
; 3676 : #ifdef FRENCH
; 3677 : 	int    done=0;
; 3678 : 	LETTER *elp;   /* always right end of cword */
; 3679 : 	FLAG   Echec;
; 3680 : 	FLAG   Trouve_Voy;
; 3681 : 	int    lflag=0;
; 3682 : #endif //FRENCH
; 3683 : 	PLTS_T pLts_t;
; 3684 : 	pLts_t = phTTS->pLTSThreadData;
; 3685 : 	
; 3686 : 	/*
; 3687 : 	 * The second scan checks that each
; 3688 : 	 * chunk of of the word (which may be the whole word,
; 3689 : 	 * or a bit of a compound word) contains a vowel, and a
; 3690 : 	 * consonant except for some special cases. If you get
; 3691 : 	 * to the end without a fail, run the thing through
; 3692 : 	 * the letter to sound rules.
; 3693 : 	 */
; 3694 : #ifdef LS1DEBUG
; 3695 : 	printf("entering ls_task_process_word ");
; 3696 : 	printf("left=%u  right=%u\n",llp,rlp);
; 3697 : #endif
; 3698 : 
; 3699 : 	lp1 = llp;
; 3700 : 	firsttim=1;                             
; 3701 : #ifdef FRENCH
; 3702 : 	Echec = FALSE;
; 3703 : 	Trouve_Voy = FALSE;
; 3704 : #endif
; 3705 : 	while (lp1 != rlp
; 3706 : #ifdef FRENCH
; 3707 : 		&& !Echec
; 3708 : #endif
; 3709 : 		   ) /* while */

  02080	8b 54 24 0c	 mov	 edx, DWORD PTR _rlp$[esp-4]
  02084	53		 push	 ebx
  02085	55		 push	 ebp
  02086	56		 push	 esi
  02087	8b 74 24 14	 mov	 esi, DWORD PTR _llp$[esp+8]
  0208b	57		 push	 edi
  0208c	8b 7c 24 14	 mov	 edi, DWORD PTR _phTTS$[esp+12]
  02090	3b f2		 cmp	 esi, edx
  02092	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _firsttim$[esp+12], 1
  0209a	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]
  0209d	0f 84 b7 00 00
	00		 je	 $L73281
  020a3	eb 04		 jmp	 SHORT $L73013
$L73285:
  020a5	8b 54 24 1c	 mov	 edx, DWORD PTR _rlp$[esp+12]
$L73013:

; 3710 : 	{
; 3711 : 		lp2 = lp1;
; 3712 : #ifndef FRENCH
; 3713 : 		pLts_t->lflag &= ~(HNONY|HCONS|HVOWEL);

  020a9	8b 83 f8 08 00
	00		 mov	 eax, DWORD PTR [ebx+2296]
  020af	8b ee		 mov	 ebp, esi
  020b1	24 4f		 and	 al, 79			; 0000004fH
  020b3	89 83 f8 08 00
	00		 mov	 DWORD PTR [ebx+2296], eax
$L73016:

; 3714 : #endif
; 3715 : #ifdef FRENCH
; 3716 : 		pLts_t->lflag &= ~(HCONS|HVOWEL);
; 3717 : #endif
; 3718 : 		while (lp1!=rlp && (c=lp1->l_ch)!='-')

  020b9	0f bf 0e	 movsx	 ecx, WORD PTR [esi]
  020bc	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  020bf	74 4f		 je	 SHORT $L73017

; 3719 : 		{
; 3720 : 			type = lsctype[c];

  020c1	33 c0		 xor	 eax, eax
  020c3	66 8b 04 4d 00
	00 00 00	 mov	 ax, WORD PTR _lsctype[ecx*2]

; 3721 : 			if ((type&C) != 0)

  020cb	f6 c4 04	 test	 ah, 4
  020ce	74 0a		 je	 SHORT $L73018

; 3722 : #ifndef FRENCH
; 3723 : 				pLts_t->lflag |= HNONY|HCONS;

  020d0	8b 83 f8 08 00
	00		 mov	 eax, DWORD PTR [ebx+2296]
  020d6	0c a0		 or	 al, -96			; ffffffa0H

; 3724 : #endif
; 3725 : #ifdef FRENCH
; 3726 : 				pLts_t->lflag |= HCONS;
; 3727 : #endif
; 3728 : 			else 

  020d8	eb 29		 jmp	 SHORT $L73288
$L73018:

; 3729 : 			{
; 3730 : 				/* 1/2/1997 GL, use OO (defined in ls_defs.h" for vowel checking */
; 3731 : 				if ((type&OO) != 0)

  020da	f6 c4 02	 test	 ah, 2
  020dd	74 0a		 je	 SHORT $L73020

; 3732 : #ifndef FRENCH
; 3733 : 					pLts_t->lflag |= HNONY|HVOWEL;

  020df	8b 83 f8 08 00
	00		 mov	 eax, DWORD PTR [ebx+2296]
  020e5	0c 90		 or	 al, -112		; ffffff90H

; 3734 : #endif
; 3735 : #ifdef FRENCH
; 3736 : 					pLts_t->lflag |= HVOWEL;
; 3737 : #endif
; 3738 : 				else 

  020e7	eb 1a		 jmp	 SHORT $L73288
$L73020:

; 3739 : 				{
; 3740 : 					/* MG 11/04/1997 BATS#509 add 'Y for checking */  
; 3741 : 					if (c == 'y' || c == 'Y') 

  020e9	83 f9 79	 cmp	 ecx, 121		; 00000079H
  020ec	74 05		 je	 SHORT $L73023
  020ee	83 f9 59	 cmp	 ecx, 89			; 00000059H
  020f1	75 16		 jne	 SHORT $L73025
$L73023:

; 3742 : 					{           
; 3743 : /* JDB: language dependent */
; 3744 : #ifdef ENGLISH_US					
; 3745 : 						if (lp1 == lp2)
; 3746 : 							pLts_t->lflag |= HCONS;

  020f3	8b 83 f8 08 00
	00		 mov	 eax, DWORD PTR [ebx+2296]
  020f9	3b f5		 cmp	 esi, ebp
  020fb	75 04		 jne	 SHORT $L73024
  020fd	0c 20		 or	 al, 32			; 00000020H

; 3747 : 						else

  020ff	eb 02		 jmp	 SHORT $L73288
$L73024:

; 3748 : 							pLts_t->lflag |= HVOWEL;

  02101	0c 10		 or	 al, 16			; 00000010H
$L73288:
  02103	89 83 f8 08 00
	00		 mov	 DWORD PTR [ebx+2296], eax
$L73025:

; 3749 : #endif
; 3750 : #ifdef ENGLISH_UK
; 3751 : 						if (lp1 == lp2)
; 3752 : 							pLts_t->lflag |= HCONS;
; 3753 : 						else
; 3754 : 							pLts_t->lflag |= HVOWEL;
; 3755 : #endif
; 3756 : 
; 3757 : #ifdef SPANISH
; 3758 :                         pLts_t->lflag |= (HNONY | HCONS);							
; 3759 : #endif                        
; 3760 : #ifdef FRENCH
; 3761 : 							pLts_t->lflag |= HVOWEL;
; 3762 : #endif
; 3763 : 					}
; 3764 : 				}
; 3765 : 			}
; 3766 : 			++lp1;

  02109	83 c6 02	 add	 esi, 2
  0210c	3b f2		 cmp	 esi, edx
  0210e	75 a9		 jne	 SHORT $L73016
$L73017:

; 3767 : 		}
; 3768 : 
; 3769 : 		pLts_t->tlflag=pLts_t->lflag;

  02110	8b 83 f8 08 00
	00		 mov	 eax, DWORD PTR [ebx+2296]

; 3770 : 
; 3771 : #ifdef LS1DEBUG
; 3772 : 		printf("b2a %c %c %d\n",lp2->l_ch,lp1->l_ch, lp1->l_ch);
; 3773 : 		printf("looking \n");
; 3774 : 
; 3775 : #endif
; 3776 : 		/* ttlp1=lp1;   */
; 3777 : 		/* if(lp1->l_ch == '-') */ /* this is a bug */
; 3778 : 			/* ttlp1--;  */
; 3779 : 		if (ls_util_lookup(phTTS,lp2, lp1, FIRST) != MISS)

  02116	6a 00		 push	 0
  02118	56		 push	 esi
  02119	55		 push	 ebp
  0211a	57		 push	 edi
  0211b	89 83 14 0b 00
	00		 mov	 DWORD PTR [ebx+2836], eax
  02121	e8 00 00 00 00	 call	 _ls_util_lookup
  02126	83 c4 10	 add	 esp, 16			; 00000010H
  02129	85 c0		 test	 eax, eax
  0212b	74 3b		 je	 SHORT $L73026

; 3780 : 		{
; 3781 : #ifdef LS1DEBUG
; 3782 : 
; 3783 : 			printf("got a hit");
; 3784 : #endif
; 3785 : 			if(firsttim == 1 && lp1!=rlp)

  0212d	83 7c 24 18 01	 cmp	 DWORD PTR _firsttim$[esp+12], 1
  02132	75 30		 jne	 SHORT $L73027
  02134	3b 74 24 1c	 cmp	 esi, DWORD PTR _rlp$[esp+12]
  02138	74 2a		 je	 SHORT $L73027

; 3786 : 			{
; 3787 : 				lp1++;
; 3788 : #ifdef LS1DEBUG
; 3789 : printf("sending hypen");
; 3790 : #endif
; 3791 : 				ls_util_send_phone(phTTS, HYPHEN );

  0213a	6a 6e		 push	 110			; 0000006eH
  0213c	57		 push	 edi
  0213d	83 c6 02	 add	 esi, 2
  02140	e8 00 00 00 00	 call	 _ls_util_send_phone
  02145	83 c4 08	 add	 esp, 8

; 3792 : 				lp2=lp1;
; 3793 : 				llp=lp1;
; 3794 : 				firsttim=0;

  02148	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _firsttim$[esp+12], 0
$L73043:
  02150	3b 74 24 1c	 cmp	 esi, DWORD PTR _rlp$[esp+12]
  02154	0f 85 4b ff ff
	ff		 jne	 $L73285
$L73281:
  0215a	5f		 pop	 edi
  0215b	5e		 pop	 esi
  0215c	5d		 pop	 ebp

; 3888 : 		}
; 3889 : 	}
; 3890 : 	return(FINISHED_WORD);

  0215d	b8 03 00 00 00	 mov	 eax, 3
  02162	5b		 pop	 ebx

; 3891 : #endif //ndef FRENCH
; 3892 : #ifdef FRENCH
; 3893 : int ls_task_process_word(LPTTS_HANDLE_T phTTS,LETTER *llp,LETTER *rlp)
; 3894 : {
; 3895 : 	int    Fini=0;
; 3896 : 	LETTER *lp1;
; 3897 : 	LETTER *lp2;
; 3898 : 	//  LETTER *elp;   /* always right end of cword */
; 3899 : 	FLAG   Echec;
; 3900 : 	FLAG   Trouve_Voy;
; 3901 : 	unsigned char   c;
; 3902 : 	int    lflag=0;
; 3903 : 	int    type;
; 3904 : 	PLTS_T pLts_t;
; 3905 : 	pLts_t = phTTS->pLTSThreadData; 
; 3906 : 	/*
; 3907 :     10 : COMPOUND WORD or WORD
; 3908 : 	*/
; 3909 : 	/* each part between - has a vowel : coq-au-vin */
; 3910 : 	lp1 = llp;
; 3911 : 	Echec = FALSE;
; 3912 : 	Trouve_Voy = FALSE;
; 3913 : 	while (lp1 != rlp && !Echec) {
; 3914 : 		c=(unsigned char)lp1->l_ch;
; 3915 : 		if (c=='-') {
; 3916 : 			if (!Trouve_Voy) {
; 3917 : 				Echec=TRUE;
; 3918 : 			} else {
; 3919 : 				Trouve_Voy=FALSE; /* for next chunk */
; 3920 : 				lp1++;
; 3921 : 			}
; 3922 : 		} else {
; 3923 : 			if ( (lsctype[c] & O) != 0) 
; 3924 : 				Trouve_Voy=TRUE;
; 3925 : 			lp1++;
; 3926 : 		}
; 3927 : 	} /* while */
; 3928 : 	
; 3929 : 	if (lp1==rlp && Trouve_Voy) { /* analyse the entire word */
; 3930 : 		/* Trouve_Voy for last part :
; 3931 : 		   sous-officier, c'est-à-dire, tout-à-coup, vis-à-vis, dit-elle
; 3932 : 	       petit, papa
; 3933 : 		*/
; 3934 : 		if (ls_util_is_white(&(pLts_t->citem))) 
; 3935 : 		{  
; 3936 : 			/* for : "tous les" with tous in cword */
; 3937 : 			/* we have swapped the readword and these lts & sendphone calls from their
; 3938 : 			   original ordering. this code used to hold each word which was entered
; 3939 : 			   until the next word was retrieved, now it sends each word to the 
; 3940 : 			   pipe as it is seen and sync'ing works correctly.
; 3941 : 			*/ 
; 3942 : 			ls_rule_lts (phTTS, llp, rlp, FALSE); /* "tous" */
; 3943 : 			/* chj 8/21/00 changed fourth argument to false 
; 3944 : 		 	   because nword no longer contains the next word because of
; 3945 : 			   the above-mentioned 'swap' that happened in 1995.
; 3946 :  			*/
; 3947 : 			ls_util_send_phone (phTTS, WBOUND);
; 3948 : 			
; 3949 : 			pLts_t->contgc=TRUE;          /* keep "tous" as left context in lts */
; 3950 : 			ls_task_readword (phTTS, pLts_t->nword);     /* "les" */
; 3951 : 			
; 3952 : 			
; 3953 : 			Fini=4;
; 3954 : 			
; 3955 : #ifdef DEBG
; 3956 : 			if (DbgLs1) {
; 3957 : 				printf ("ls1.c Word_or_Compound LTS for word without - : ");
; 3958 : 				//Ecrit (llp, rlp);
; 3959 : 			}
; 3960 : #endif
; 3961 : 			/* copyword after printf : nword in cword for next loop */
; 3962 : 			ls_util_copyword (pLts_t->cword, pLts_t->nword);
; 3963 : 			
; 3964 : 		} else {
; 3965 : 			/* not followed by a space, no liaison */
; 3966 : 			ls_rule_lts (phTTS, llp, rlp, FALSE); /* les ANS.     ET,  */
; 3967 : 			/* helpme should pLts_t->precedent get set to "" here? or contgc to FALSE? */
; 3968 : 			Fini=2;
; 3969 : #ifdef DEBG
; 3970 : 			if (DbgLs1) {
; 3971 : 				printf ("ls1.c Word_or_Compound LTS for word with - : ");
; 3972 : 				//Ecrit (llp, rlp);
; 3973 : 			}
; 3974 : #endif
; 3975 : 			
; 3976 : 		}
; 3977 : 		
; 3978 : 	} else {
; 3979 :     /*
; 3980 : 	not a regular word : hyphen with no vowel for one chunk
; 3981 : 	check each chunk and spell it or present it to LTS
; 3982 : 		*/
; 3983 : 		lp1 = llp;
; 3984 : 		while (lp1 != rlp) { /* 3 loops hiv-cv-dc */
; 3985 : 			lp2=lp1;
; 3986 : 			lflag &= ~(HCONS|HVOWEL);
; 3987 : 			
; 3988 : 			/* loop for one chunk */
; 3989 : 			while (lp1 != rlp && (c = (char)lp1->l_ch) != '-') {
; 3990 : 				type = lsctype [c];
; 3991 : 				if ((type & C) != 0) {
; 3992 : 					lflag |= HCONS;
; 3993 : 				} else if ((type & O) != 0) {
; 3994 : 					lflag |= HVOWEL;
; 3995 : 				} else if (c=='y') {
; 3996 : 					lflag |= HVOWEL;
; 3997 : 				}
; 3998 : 				++lp1;
; 3999 : 			} /* while not found a chunk */
; 4000 : 			
; 4001 : #ifdef DEBG
; 4002 : 			if (DbgLs1) {
; 4003 : 				printf ("ls1.c Word_or_Compound spell or lts? : ");
; 4004 : 				//Ecrit (lp2, lp1);
; 4005 : 			}
; 4006 : #endif
; 4007 : 			
; 4008 : 			if ( (lflag & HVOWEL) == 0) {
; 4009 : 				/* Spell if no vowel except : t  of va-t-en, sera-t-elle */
; 4010 : 				if (lp2+1==lp1 && lp1->l_ch=='-'
; 4011 : 					&& ls_task_wlookup (pLts_t, lp2, apres_tiret) )  {
; 4012 : 					/* -t-... : va-t-en, sera-t-elle, or -z-en... */
; 4013 : 					lp1->l_ch = '\''; /* va-t'en */
; 4014 : 					while (++lp1 != rlp && lp1->l_ch!='-');
; 4015 : 					ls_rule_lts (phTTS, lp2, lp1, FALSE);    /* lp1 points on - or rlp */
; 4016 : 				} else {
; 4017 : 					/* spell : BC, b-c-d, MS-dos */
; 4018 : 					ls_spel_spell (phTTS, lp2, lp1);
; 4019 : 					//    sendindex (lp2, lp1);
; 4020 : 				}
; 4021 : 			} else {     /* the chunk has a vowel */
; 4022 : 				/* ms-DOS : lp2 sur D, lp1 sur S */
; 4023 : 				
; 4024 : #ifdef DEBG
; 4025 : 				if (DbgLs1) {
; 4026 : 					printf ("ls1.c Word_or_Compound hyphen  LTS : ");
; 4027 : 					//Ecrit (lp2, lp1);
; 4028 : 				}
; 4029 : #endif
; 4030 : 				
; 4031 : 				/* don't keep DOS for next time */
; 4032 : 				strcpy(pLts_t->precedent, "");       /* nothing on the left */
; 4033 : 				ls_rule_lts (phTTS, lp2, lp1, FALSE); /* DOS */
; 4034 : 			} /* if has or has not a vowel */
; 4035 : 			
; 4036 : 			if (lp1 != rlp) {
; 4037 : 				lp2=lp1;
; 4038 : 				/* blocks of "----" */
; 4039 : 				while (lp2 != rlp && lp1->l_ch=='-') lp1++;
; 4040 : 				ls_util_send_phone (phTTS, WBOUND);  /* comma ? if several - */
; 4041 : 				// sendindex (lp2, lp1);
; 4042 : 			} /* if */
; 4043 : 			
; 4044 : 		} /* while not reached the end of cword */
; 4045 : 		
; 4046 : 		Fini=2;
; 4047 : 		
; 4048 : 	} /* if regular word or word with hyphen */
; 4049 : 	
; 4050 : 	return (Fini);
; 4051 : 	
; 4052 : #endif //FRENCH
; 4053 : 	
; 4054 : }

  02163	c3		 ret	 0
$L73027:

; 3795 : 				continue;
; 3796 : 			}
; 3797 : 			lp2=lp1;

  02164	8b ee		 mov	 ebp, esi

; 3798 : 			llp=lp1;
; 3799 : 		}
; 3800 : 		else

  02166	eb 62		 jmp	 SHORT $L73035
$L73026:

; 3801 : 		{ 
; 3802 : 			/* MGS 6/13/97 BATS #389 changed so single letters get spelled */
; 3803 : 			if( ((pLts_t->tlflag)&HVOWEL) != 0  && (lp2+1 != lp1))

  02168	f6 83 14 0b 00
	00 10		 test	 BYTE PTR [ebx+2836], 16	; 00000010H
  0216f	74 59		 je	 SHORT $L73035
  02171	8d 4d 02	 lea	 ecx, DWORD PTR [ebp+2]
  02174	3b ce		 cmp	 ecx, esi
  02176	74 52		 je	 SHORT $L73035

; 3804 : 			{
; 3805 : #ifdef LS1DEBUG
; 3806 : 				printf("doing lts1 ");
; 3807 : 				printf("left=%u  right=%u\n",lp2,lp1);
; 3808 : #endif
; 3809 : #ifdef DUMP_WORD
; 3810 : 				//printf("doing lts1\n");
; 3811 : #endif
; 3812 : 
; 3813 : 				/* MGS 6/16/97 BATS #387 Added becasue rule engine needs lower case characters */
; 3814 : 				ls_task_remove_case(lp2,lp1);

  02178	56		 push	 esi
  02179	55		 push	 ebp
  0217a	e8 00 00 00 00	 call	 _ls_task_remove_case

; 3815 : 
; 3816 : 				ls_rule_do_lts(phTTS,lp2, lp1);

  0217f	56		 push	 esi
  02180	55		 push	 ebp
  02181	57		 push	 edi
  02182	e8 00 00 00 00	 call	 _ls_rule_do_lts
  02187	83 c4 14	 add	 esp, 20			; 00000014H

; 3817 : 
; 3818 : #ifdef DUMP_WORD
; 3819 : 				//printf("done lts1\n");
; 3820 : #endif
; 3821 : #ifdef LS1DEBUG
; 3822 : 
; 3823 : 				printf("done lts1 ");
; 3824 : 				printf("left=%u  right=%u\n",lp2,lp1);
; 3825 : #endif
; 3826 : 				if (lp1 != rlp)

  0218a	8b 44 24 1c	 mov	 eax, DWORD PTR _rlp$[esp+12]
  0218e	3b f0		 cmp	 esi, eax

; 3827 : 				{               /* Inter-chunk gap.     */
; 3828 : 					lp2 = lp1;

  02190	8b ee		 mov	 ebp, esi

; 3817 : 
; 3818 : #ifdef DUMP_WORD
; 3819 : 				//printf("done lts1\n");
; 3820 : #endif
; 3821 : #ifdef LS1DEBUG
; 3822 : 
; 3823 : 				printf("done lts1 ");
; 3824 : 				printf("left=%u  right=%u\n",lp2,lp1);
; 3825 : #endif
; 3826 : 				if (lp1 != rlp)

  02192	74 36		 je	 SHORT $L73035
$L73032:

; 3829 : 					while (lp1!=rlp && lp1->l_ch=='-')

  02194	66 83 3e 2d	 cmp	 WORD PTR [esi], 45	; 0000002dH
  02198	75 07		 jne	 SHORT $L73033

; 3830 : 						++lp1;

  0219a	83 c6 02	 add	 esi, 2
  0219d	3b f0		 cmp	 esi, eax
  0219f	75 f3		 jne	 SHORT $L73032
$L73033:

; 3831 : 					llp=lp1; 
; 3832 : 					/* GL 03/04/1997  Who add this one? it is a bug */
; 3833 : 					/* it will force lp2_1  never equal to lp1 */
; 3834 : 					/*lp2=lp1;*/
; 3835 : 					ls_util_send_phone(phTTS,lp2+1==lp1 ? HYPHEN : COMMA);

  021a1	8d 7d 02	 lea	 edi, DWORD PTR [ebp+2]
  021a4	8b 44 24 14	 mov	 eax, DWORD PTR _phTTS$[esp+12]
  021a8	8b d7		 mov	 edx, edi
  021aa	2b d6		 sub	 edx, esi
  021ac	f7 da		 neg	 edx
  021ae	1b d2		 sbb	 edx, edx
  021b0	83 e2 05	 and	 edx, 5
  021b3	83 c2 6e	 add	 edx, 110		; 0000006eH
  021b6	52		 push	 edx
  021b7	50		 push	 eax
  021b8	e8 00 00 00 00	 call	 _ls_util_send_phone
  021bd	83 c4 08	 add	 esp, 8

; 3836 : 					/* MGS 6/13/97 BATS #389 added for f-a-r wont say ef a dash r */
; 3837 : 					if (lp2+1==lp1)

  021c0	3b fe		 cmp	 edi, esi
  021c2	75 02		 jne	 SHORT $L73284

; 3838 : 						lp2++;

  021c4	8b ef		 mov	 ebp, edi
$L73284:

; 3839 : 				}
; 3840 : 				else

  021c6	8b 7c 24 14	 mov	 edi, DWORD PTR _phTTS$[esp+12]
$L73035:

; 3841 : 				{
; 3842 : 					llp=lp1;
; 3843 : 					lp2=lp1;
; 3844 : 				}
; 3845 : #ifdef LS1DEBUG
; 3846 : 				printf("done lts1 333");
; 3847 : 				printf("left=%u  right=%u\n",llp,rlp);
; 3848 : #endif
; 3849 : 			}
; 3850 : 		}
; 3851 : 		firsttim=0;   
; 3852 : 		if (lp2!=lp1)

  021ca	3b ee		 cmp	 ebp, esi
  021cc	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _firsttim$[esp+12], 0
  021d4	74 3c		 je	 SHORT $L73039

; 3853 : 		{
; 3854 : 			if (((pLts_t->lflag)&HNONY) == 0)         /* Spell if all "y".    */

  021d6	f6 83 f8 08 00
	00 80		 test	 BYTE PTR [ebx+2296], -128 ; ffffff80H
  021dd	75 0b		 jne	 SHORT $L73037

; 3855 : 			{
; 3856 : #ifdef LS1DEBUG
; 3857 : 				printf(" spell all y \n");
; 3858 : #endif
; 3859 : 				ls_spel_spell(phTTS,lp2,lp1);

  021df	56		 push	 esi
  021e0	55		 push	 ebp
  021e1	57		 push	 edi
  021e2	e8 00 00 00 00	 call	 _ls_spel_spell
  021e7	83 c4 0c	 add	 esp, 12			; 0000000cH
$L73037:

; 3860 : 				/* return(SPELL_WORD); */
; 3861 : 			}
; 3862 : 			if (((pLts_t->lflag)&HVOWEL) == 0)        /* Spell if no vowels.  */

  021ea	f6 83 f8 08 00
	00 10		 test	 BYTE PTR [ebx+2296], 16	; 00000010H
  021f1	75 0b		 jne	 SHORT $L73038

; 3863 : 			{
; 3864 : #ifdef LS1DEBUG
; 3865 : 				printf("spell no vowel  \n");
; 3866 : #endif
; 3867 : 				ls_spel_spell(phTTS,lp2,lp1);

  021f3	56		 push	 esi
  021f4	55		 push	 ebp
  021f5	57		 push	 edi
  021f6	e8 00 00 00 00	 call	 _ls_spel_spell
  021fb	83 c4 0c	 add	 esp, 12			; 0000000cH
$L73038:

; 3868 : 				/* return(SPELL_WORD); */
; 3869 : 			}
; 3870 : 			if (((pLts_t->lflag)&HCONS) == 0)

  021fe	f6 83 f8 08 00
	00 20		 test	 BYTE PTR [ebx+2296], 32	; 00000020H
  02205	75 0b		 jne	 SHORT $L73039

; 3871 : 			{       /* If no consonant, the */
; 3872 : 				/* if (lp2+1 != lp1)
; 3873 : 				{ */
; 3874 : #ifdef LS1DEBUG
; 3875 : 					printf(" spell no cons. \n");
; 3876 : #endif
; 3877 : 					ls_spel_spell(phTTS,lp2,lp1);

  02207	56		 push	 esi
  02208	55		 push	 ebp
  02209	57		 push	 edi
  0220a	e8 00 00 00 00	 call	 _ls_spel_spell
  0220f	83 c4 0c	 add	 esp, 12			; 0000000cH
$L73039:

; 3878 : 					/* return(SPELL_WORD); */   /* are legal.*/         
; 3879 : 			/*  } */
; 3880 : 
; 3881 : 			}
; 3882 : 		}
; 3883 : 		if (lp1 != rlp)

  02212	3b 74 24 1c	 cmp	 esi, DWORD PTR _rlp$[esp+12]
  02216	0f 84 3e ff ff
	ff		 je	 $L73281

; 3884 : 		{               /* Hit "-", allow long  */
; 3885 : 			pLts_t->lflag |= HHYPHEN;       /* blocks of "---".     */

  0221c	8b 83 f8 08 00
	00		 mov	 eax, DWORD PTR [ebx+2296]
  02222	0c 40		 or	 al, 64			; 00000040H
  02224	89 83 f8 08 00
	00		 mov	 DWORD PTR [ebx+2296], eax
$L73042:

; 3886 : 			while (lp1!=rlp && lp1->l_ch=='-')

  0222a	66 83 3e 2d	 cmp	 WORD PTR [esi], 45	; 0000002dH
  0222e	0f 85 1c ff ff
	ff		 jne	 $L73043
  02234	8b 44 24 1c	 mov	 eax, DWORD PTR _rlp$[esp+12]

; 3887 : 				++lp1;

  02238	83 c6 02	 add	 esi, 2
  0223b	3b f0		 cmp	 esi, eax
  0223d	0f 84 17 ff ff
	ff		 je	 $L73281

; 3886 : 			while (lp1!=rlp && lp1->l_ch=='-')

  02243	eb e5		 jmp	 SHORT $L73042
_ls_task_process_word ENDP
_phTTS$ = 8
_pLts_t$ = -4
_ls_task_lookup_first_verbs PROC NEAR

; 4087 : {

  02250	51		 push	 ecx

; 4088 : 	PLTS_T pLts_t;
; 4089 : 	PKSD_T pKsd_t;
; 4090 : 	LETTER *llp, *elp;
; 4091 : 
; 4092 : 	int j,i;
; 4093 : 	pKsd_t = phTTS->pKernelShareData;
; 4094 : 	pLts_t = phTTS->pLTSThreadData;

  02251	8b 44 24 08	 mov	 eax, DWORD PTR _phTTS$[esp]
  02255	53		 push	 ebx
  02256	55		 push	 ebp
  02257	56		 push	 esi
  02258	8b 68 10	 mov	 ebp, DWORD PTR [eax+16]
  0225b	57		 push	 edi
  0225c	89 6c 24 10	 mov	 DWORD PTR _pLts_t$[esp+20], ebp

; 4095 : 	llp = &(pLts_t->cword[0]);

  02260	81 c5 14 09 00
	00		 add	 ebp, 2324		; 00000914H

; 4096 : 	
; 4097 : #if 0
; 4098 : 	for (i=0;i<6;i++)
; 4099 : 	{
; 4100 : 		WINprintf("%d %s %c%c %c%c %c%c %c%c %c%c\n",i,verbs[i].word,
; 4101 : 			pKsd_t->arpabet[(verbs[i].phone[0])<<1],pKsd_t->arpabet[((verbs[i].phone[0])<<1)+1],
; 4102 : 			pKsd_t->arpabet[(verbs[i].phone[1])<<1],pKsd_t->arpabet[((verbs[i].phone[1])<<1)+1],
; 4103 : 			pKsd_t->arpabet[(verbs[i].phone[2])<<1],pKsd_t->arpabet[((verbs[i].phone[2])<<1)+1],
; 4104 : 			pKsd_t->arpabet[(verbs[i].phone[3])<<1],pKsd_t->arpabet[((verbs[i].phone[3])<<1)+1],
; 4105 : 			pKsd_t->arpabet[(verbs[i].phone[4])<<1],pKsd_t->arpabet[((verbs[i].phone[4])<<1)+1]);
; 4106 : 	}
; 4107 : #endif
; 4108 : 	for (i=0;i<6;i++)

  02266	33 ff		 xor	 edi, edi
  02268	33 f6		 xor	 esi, esi
$L73059:

; 4109 : 	{
; 4110 : 		j=0;
; 4111 : 		elp=llp;
; 4112 : 		while (elp->l_ch !=EOS)

  0226a	66 8b 45 00	 mov	 ax, WORD PTR [ebp]
  0226e	33 d2		 xor	 edx, edx
  02270	66 85 c0	 test	 ax, ax
  02273	8b cd		 mov	 ecx, ebp
  02275	74 24		 je	 SHORT $L73293
$L73063:

; 4113 : 		{
; 4114 : 			if (verbs[i].word[j]!=ls_lower[elp->l_ch])

  02277	0f bf c0	 movsx	 eax, ax
  0227a	33 db		 xor	 ebx, ebx
  0227c	8a 98 00 00 00
	00		 mov	 bl, BYTE PTR _ls_lower[eax]
  02282	0f be 84 16 00
	00 00 00	 movsx	 eax, BYTE PTR _verbs[esi+edx]
  0228a	3b c3		 cmp	 eax, ebx
  0228c	75 0d		 jne	 SHORT $L73293
  0228e	66 8b 41 02	 mov	 ax, WORD PTR [ecx+2]

; 4115 : 			{
; 4116 : 				break;
; 4117 : 			}
; 4118 : 			j++;
; 4119 : 			elp++;

  02292	83 c1 02	 add	 ecx, 2
  02295	42		 inc	 edx
  02296	66 85 c0	 test	 ax, ax
  02299	75 dc		 jne	 SHORT $L73063
$L73293:

; 4120 : 		}
; 4121 : 		if (verbs[i].word[j]==ls_lower[elp->l_ch] && verbs[i].word[j]==0)

  0229b	0f bf 09	 movsx	 ecx, WORD PTR [ecx]
  0229e	8a 94 16 00 00
	00 00		 mov	 dl, BYTE PTR _verbs[esi+edx]
  022a5	33 c0		 xor	 eax, eax
  022a7	8a 81 00 00 00
	00		 mov	 al, BYTE PTR _ls_lower[ecx]
  022ad	0f be ca	 movsx	 ecx, dl
  022b0	3b c8		 cmp	 ecx, eax
  022b2	75 04		 jne	 SHORT $L73060
  022b4	84 d2		 test	 dl, dl
  022b6	74 14		 je	 SHORT $L73294
$L73060:

; 4096 : 	
; 4097 : #if 0
; 4098 : 	for (i=0;i<6;i++)
; 4099 : 	{
; 4100 : 		WINprintf("%d %s %c%c %c%c %c%c %c%c %c%c\n",i,verbs[i].word,
; 4101 : 			pKsd_t->arpabet[(verbs[i].phone[0])<<1],pKsd_t->arpabet[((verbs[i].phone[0])<<1)+1],
; 4102 : 			pKsd_t->arpabet[(verbs[i].phone[1])<<1],pKsd_t->arpabet[((verbs[i].phone[1])<<1)+1],
; 4103 : 			pKsd_t->arpabet[(verbs[i].phone[2])<<1],pKsd_t->arpabet[((verbs[i].phone[2])<<1)+1],
; 4104 : 			pKsd_t->arpabet[(verbs[i].phone[3])<<1],pKsd_t->arpabet[((verbs[i].phone[3])<<1)+1],
; 4105 : 			pKsd_t->arpabet[(verbs[i].phone[4])<<1],pKsd_t->arpabet[((verbs[i].phone[4])<<1)+1]);
; 4106 : 	}
; 4107 : #endif
; 4108 : 	for (i=0;i<6;i++)

  022b8	83 c6 20	 add	 esi, 32			; 00000020H
  022bb	47		 inc	 edi
  022bc	81 fe c0 00 00
	00		 cmp	 esi, 192		; 000000c0H
  022c2	7c a6		 jl	 SHORT $L73059
  022c4	5f		 pop	 edi
  022c5	5e		 pop	 esi
  022c6	5d		 pop	 ebp

; 4133 : 		}
; 4134 : 	}
; 4135 : 	return(KEEP_SEARCHING);

  022c7	33 c0		 xor	 eax, eax
  022c9	5b		 pop	 ebx

; 4136 : }

  022ca	59		 pop	 ecx
  022cb	c3		 ret	 0
$L73294:

; 4122 : 		{
; 4123 : 			pLts_t->fc_struct[1] = verbs[i].fc;

  022cc	8b 5c 24 10	 mov	 ebx, DWORD PTR _pLts_t$[esp+20]
  022d0	8b cf		 mov	 ecx, edi
  022d2	c1 e1 05	 shl	 ecx, 5

; 4124 : 			j=0;
; 4125 : 			while (verbs[i].phone[j]!=SIL)

  022d5	c1 e7 05	 shl	 edi, 5
  022d8	8b 91 1c 00 00
	00		 mov	 edx, DWORD PTR _verbs[ecx+28]
  022de	89 93 c0 04 00
	00		 mov	 DWORD PTR [ebx+1216], edx
  022e4	8b 87 08 00 00
	00		 mov	 eax, DWORD PTR _verbs[edi+8]
  022ea	85 c0		 test	 eax, eax
  022ec	74 1e		 je	 SHORT $L73069
  022ee	8b 7c 24 18	 mov	 edi, DWORD PTR _phTTS$[esp+16]
  022f2	8d b1 08 00 00
	00		 lea	 esi, DWORD PTR _verbs[ecx+8]
$L73068:

; 4126 : 			{
; 4127 : 				ls_util_send_phone(phTTS,verbs[i].phone[j]);

  022f8	50		 push	 eax
  022f9	57		 push	 edi
  022fa	e8 00 00 00 00	 call	 _ls_util_send_phone
  022ff	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 4128 : 				j++;

  02302	83 c6 04	 add	 esi, 4
  02305	83 c4 08	 add	 esp, 8
  02308	85 c0		 test	 eax, eax
  0230a	75 ec		 jne	 SHORT $L73068
$L73069:

; 4129 : 			}		
; 4130 : 			pLts_t->lbphone=WBOUND;

  0230c	b8 6f 00 00 00	 mov	 eax, 111		; 0000006fH
  02311	5f		 pop	 edi
  02312	5e		 pop	 esi
  02313	89 83 1c 0b 00
	00		 mov	 DWORD PTR [ebx+2844], eax

; 4131 : 			pLts_t->rbphone=WBOUND;

  02319	89 83 20 0b 00
	00		 mov	 DWORD PTR [ebx+2848], eax
  0231f	5d		 pop	 ebp

; 4132 : 			return(FINISHED_WORD);

  02320	b8 03 00 00 00	 mov	 eax, 3
  02325	5b		 pop	 ebx

; 4136 : }

  02326	59		 pop	 ecx
  02327	c3		 ret	 0
_ls_task_lookup_first_verbs ENDP
_TEXT	ENDS
PUBLIC	_ls_task_prelookup
_TEXT	SEGMENT
_word$ = 12
_count$ = 16
_table$ = 20
_len$ = 20
_ls_task_prelookup PROC NEAR

; 4163 : {

  02330	53		 push	 ebx
  02331	55		 push	 ebp

; 4164 : 	LETTER  *lp;
; 4165 : 	/* GL 03/20/1998, BATS#633  use "unsigned char" instead of "char" */
; 4166 : 	char  	*cp;
; 4167 : 	char  	*tp;
; 4168 : 	int   	c;
; 4169 : 	int   	len;
; 4170 : 
; 4171 : 
; 4172 : 	tp = &table[0];                 /* Start at the start.  */
; 4173 : 	while ((len = *tp++) != 0) 

  02332	8b 6c 24 18	 mov	 ebp, DWORD PTR _table$[esp+4]
  02336	56		 push	 esi
  02337	57		 push	 edi
  02338	0f be 45 00	 movsx	 eax, BYTE PTR [ebp]
  0233c	45		 inc	 ebp
  0233d	89 44 24 20	 mov	 DWORD PTR _len$[esp+12], eax
  02341	85 c0		 test	 eax, eax
  02343	74 46		 je	 SHORT $L73086
  02345	8b 7c 24 1c	 mov	 edi, DWORD PTR _count$[esp+12]
$L73085:

; 4174 : 	{            					/* 0 => end of table.   */
; 4175 : 		lp = &word[0];              

  02349	8b 74 24 18	 mov	 esi, DWORD PTR _word$[esp+12]

; 4176 : 		*count=0;

  0234d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 4177 : 		cp = tp;                    /* Start of text.       */

  02353	8b cd		 mov	 ecx, ebp
$L73088:

; 4178 : 		for (;;) 
; 4179 : 		{
; 4180 : 			c = ls_lower[lp->l_ch]; /* Fold case.           */
; 4181 : 		if (*cp == EOS || *cp < 0 )           /* Win.                 */

  02355	8a 01		 mov	 al, BYTE PTR [ecx]
  02357	84 c0		 test	 al, al
  02359	74 37		 je	 SHORT $L73304
  0235b	7c 35		 jl	 SHORT $L73304

; 4190 :             }
; 4191 : 			if (c != *cp++)         /* Lose.                */

  0235d	0f bf 16	 movsx	 edx, WORD PTR [esi]
  02360	33 db		 xor	 ebx, ebx
  02362	41		 inc	 ecx
  02363	8a 9a 00 00 00
	00		 mov	 bl, BYTE PTR _ls_lower[edx]
  02369	0f be c0	 movsx	 eax, al
  0236c	3b d8		 cmp	 ebx, eax
  0236e	75 0a		 jne	 SHORT $L73305

; 4192 : 			{
; 4193 : 				break;
; 4194 : 			}
; 4195 : 
; 4196 : 			++lp;   
; 4197 : 			*count +=1;

  02370	8b 07		 mov	 eax, DWORD PTR [edi]
  02372	83 c6 02	 add	 esi, 2
  02375	40		 inc	 eax
  02376	89 07		 mov	 DWORD PTR [edi], eax

; 4198 : 		}

  02378	eb db		 jmp	 SHORT $L73088
$L73305:

; 4199 : 		tp += len;                  /* Next.                */

  0237a	03 6c 24 20	 add	 ebp, DWORD PTR _len$[esp+12]
  0237e	0f be 45 00	 movsx	 eax, BYTE PTR [ebp]
  02382	45		 inc	 ebp
  02383	89 44 24 20	 mov	 DWORD PTR _len$[esp+12], eax
  02387	85 c0		 test	 eax, eax
  02389	75 be		 jne	 SHORT $L73085
$L73086:
  0238b	5f		 pop	 edi
  0238c	5e		 pop	 esi
  0238d	5d		 pop	 ebp

; 4200 : 	}
; 4201 : 	return (NULL);

  0238e	33 c0		 xor	 eax, eax
  02390	5b		 pop	 ebx

; 4202 : }

  02391	c3		 ret	 0
$L73304:

; 4182 :             {
; 4183 : 			if(*cp != EOS)

  02392	8a 01		 mov	 al, BYTE PTR [ecx]
  02394	84 c0		 test	 al, al
  02396	74 0a		 je	 SHORT $L73092

; 4184 : 			{
; 4185 : 				//modify replacement count and move to EOS
; 4186 : 				*count += *cp++;

  02398	8b 37		 mov	 esi, DWORD PTR [edi]
  0239a	0f be d0	 movsx	 edx, al
  0239d	03 f2		 add	 esi, edx
  0239f	41		 inc	 ecx
  023a0	89 37		 mov	 DWORD PTR [edi], esi
$L73092:
  023a2	5f		 pop	 edi
  023a3	5e		 pop	 esi
  023a4	5d		 pop	 ebp

; 4187 : 			}
; 4188 : 			//bump pointer past the EOS char
; 4189 :                  return (++cp);    	/* Return phonemes.     */

  023a5	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  023a8	5b		 pop	 ebx

; 4202 : }

  023a9	c3		 ret	 0
_ls_task_prelookup ENDP
_TEXT	ENDS
END
