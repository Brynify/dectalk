	TITLE	D:\work\product\dapi\src\Ph\ph_setar.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_phsettar
EXTRN	_partyp:BYTE
EXTRN	_divtab:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_inhdr_frames$ = -20
_pholas$ = -28
_fealas$ = -24
_feacur$ = -36
_feanex$ = -40
_struclm2$ = -12
_struclas$ = -32
_struccur$ = -44
_strucnex$ = -16
_ndips$ = -4
_phonp2$ = -8
_phsettar PROC NEAR

; 318  : {

  00000	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi

; 319  : 	/* 
; 320  : 	 * MVP :The following variables are made local to phsettar,
; 321  : 	 * Earlier they were static at file scope 
; 322  : 	 */
; 323  : 	short inhdr_frames = 0;
; 324  : 	short pholas = 0;
; 325  : 	short fealas = 0, feacur = 0, feanex = 0;
; 326  : 	short struclm2 = 0, struclas = 0, struccur = 0, strucnex = 0;
; 327  : 	short *ndips;      /* pointer in dipspec[]                   */
; 328  : 	short temp;
; 329  : 	short phonp2=0;
; 330  : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;
; 331  : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 332  : 	PDPHSETTAR_ST   pDphsettar = pDph_t->pSTphsettar;
; 333  : 
; 334  : 	/* Initialize program at beginning of each clause */
; 335  : 
; 336  : 	init_variables (phTTS, &inhdr_frames, &pDph_t->shrink,
; 337  : 					&pDph_t->shrif, &pDph_t->shrib,
; 338  : 					&pholas, &fealas, &feacur,
; 339  : 					&feanex, &struclm2, &struclas,
; 340  : 					&struccur, &strucnex, &ndips,&phonp2);

  00006	8d 6c 24 30	 lea	 ebp, DWORD PTR _phonp2$[esp+56]
  0000a	57		 push	 edi
  0000b	55		 push	 ebp
  0000c	8d 6c 24 3c	 lea	 ebp, DWORD PTR _ndips$[esp+64]
  00010	8b 44 24 44	 mov	 eax, DWORD PTR _phTTS$[esp+60]
  00014	55		 push	 ebp
  00015	8d 6c 24 34	 lea	 ebp, DWORD PTR _strucnex$[esp+68]
  00019	55		 push	 ebp
  0001a	8d 6c 24 1c	 lea	 ebp, DWORD PTR _struccur$[esp+72]
  0001e	55		 push	 ebp
  0001f	8d 6c 24 2c	 lea	 ebp, DWORD PTR _struclas$[esp+76]
  00023	55		 push	 ebp
  00024	8d 6c 24 44	 lea	 ebp, DWORD PTR _struclm2$[esp+80]
  00028	8b 78 18	 mov	 edi, DWORD PTR [eax+24]
  0002b	55		 push	 ebp
  0002c	8d 6c 24 2c	 lea	 ebp, DWORD PTR _feanex$[esp+84]
  00030	33 db		 xor	 ebx, ebx
  00032	55		 push	 ebp
  00033	8d 6c 24 34	 lea	 ebp, DWORD PTR _feacur$[esp+88]
  00037	55		 push	 ebp
  00038	8d 6c 24 44	 lea	 ebp, DWORD PTR _fealas$[esp+92]
  0003c	55		 push	 ebp
  0003d	8d 6c 24 44	 lea	 ebp, DWORD PTR _pholas$[esp+96]
  00041	8d 87 34 28 00
	00		 lea	 eax, DWORD PTR [edi+10292]
  00047	8d 8f 32 28 00
	00		 lea	 ecx, DWORD PTR [edi+10290]
  0004d	55		 push	 ebp
  0004e	8d 97 30 28 00
	00		 lea	 edx, DWORD PTR [edi+10288]
  00054	50		 push	 eax
  00055	51		 push	 ecx
  00056	52		 push	 edx
  00057	8b 54 24 74	 mov	 edx, DWORD PTR _phTTS$[esp+108]
  0005b	8d 4c 24 5c	 lea	 ecx, DWORD PTR _inhdr_frames$[esp+112]
  0005f	89 5c 24 5c	 mov	 DWORD PTR _inhdr_frames$[esp+112], ebx
  00063	51		 push	 ecx
  00064	89 5c 24 58	 mov	 DWORD PTR _pholas$[esp+116], ebx
  00068	89 5c 24 5c	 mov	 DWORD PTR _fealas$[esp+116], ebx
  0006c	89 5c 24 50	 mov	 DWORD PTR _feacur$[esp+116], ebx
  00070	89 5c 24 4c	 mov	 DWORD PTR _feanex$[esp+116], ebx
  00074	89 5c 24 68	 mov	 DWORD PTR _struclm2$[esp+116], ebx
  00078	89 5c 24 54	 mov	 DWORD PTR _struclas$[esp+116], ebx
  0007c	89 5c 24 48	 mov	 DWORD PTR _struccur$[esp+116], ebx
  00080	89 5c 24 64	 mov	 DWORD PTR _strucnex$[esp+116], ebx
  00084	89 5c 24 6c	 mov	 DWORD PTR _phonp2$[esp+116], ebx
  00088	8b b7 48 28 00
	00		 mov	 esi, DWORD PTR [edi+10312]
  0008e	52		 push	 edx
  0008f	e8 00 00 00 00	 call	 _init_variables
  00094	83 c4 3c	 add	 esp, 60			; 0000003cH

; 341  : 
; 342  : 	/* Turn off breathyness switch at end of a phrase */    
; 343  : 	/* 12/10/1996 EDB */
; 344  : 	if ((pDphsettar->phcur == SIL)/* || ((struccur & FHAT_BEGINS) IS_PLUS)*/)

  00097	66 39 5e 18	 cmp	 WORD PTR [esi+24], bx
  0009b	75 07		 jne	 SHORT $L71814

; 345  : 			pDph_t->breathysw = 0;

  0009d	66 89 9f b6 02
	00 00		 mov	 WORD PTR [edi+694], bx
$L71814:

; 346  : 	
; 347  : 	/* Turn on breathyness switch during last syllable of clause */
; 348  : 	/* (generally restricted to female voices via spdef LX) */
; 349  : 	if ((struccur & FSENTENDS) IS_PLUS)

  000a4	8b 44 24 10	 mov	 eax, DWORD PTR _struccur$[esp+60]
  000a8	25 00 01 00 00	 and	 eax, 256		; 00000100H
  000ad	66 85 c0	 test	 ax, ax
  000b0	74 09		 je	 SHORT $L71815

; 350  : 	{
; 351  : 		pDph_t->breathysw = 1;

  000b2	66 c7 87 b6 02
	00 00 01 00	 mov	 WORD PTR [edi+694], 1
$L71815:

; 352  : 	}
; 353  : 	/* Main loop: For each parameter, set target and transition specs    */
; 354  : 
; 355  : 	for (pDphsettar->np = &PF1; pDphsettar->np <= &PTILT; pDphsettar->np++)

  000bb	8d 47 24	 lea	 eax, DWORD PTR [edi+36]
  000be	8d 8f 40 02 00
	00		 lea	 ecx, DWORD PTR [edi+576]
  000c4	3b c1		 cmp	 eax, ecx
  000c6	89 46 10	 mov	 DWORD PTR [esi+16], eax
  000c9	0f 87 ba 03 00
	00		 ja	 $L71818
$L71816:

; 356  : 	{
; 357  : 		pDphsettar->par_type = partyp[pDphsettar->np - &PF1];   /* formfreq, ampl, etc. */

  000cf	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  000d2	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  000d7	8b cd		 mov	 ecx, ebp
  000d9	2b cf		 sub	 ecx, edi
  000db	83 e9 24	 sub	 ecx, 36			; 00000024H
  000de	f7 e9		 imul	 ecx
  000e0	c1 fa 03	 sar	 edx, 3
  000e3	8b ca		 mov	 ecx, edx
  000e5	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000e8	8a 94 0a 00 00
	00 00		 mov	 dl, BYTE PTR _partyp[edx+ecx]
  000ef	88 56 14	 mov	 BYTE PTR [esi+20], dl

; 358  : 
; 359  : 		/* 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 */
; 360  : 		/* Set target value associated with end time of last phone         */
; 361  : 		/* 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 */
; 362  : 
; 363  : 		pDphsettar->np->tarlas = pDphsettar->np->tarend;

  000f2	66 8b 45 1a	 mov	 ax, WORD PTR [ebp+26]
  000f6	66 89 45 18	 mov	 WORD PTR [ebp+24], ax

; 364  : 
; 365  : 		/* 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 */
; 366  : 		/* Set target value associated with onset of next phone            */
; 367  : 		/* and compute any shift due to coartic with adjacent phones       */
; 368  : 		/* 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 */
; 369  : 
; 370  : 		pDphsettar->np->tarnex = getbegtar (phTTS, (pDph_t->nphone + 1));       /* Calls gettar() */

  000fa	66 8b 8f 1c 20
	00 00		 mov	 cx, WORD PTR [edi+8220]
  00101	8b 6c 24 40	 mov	 ebp, DWORD PTR _phTTS$[esp+56]
  00105	66 41		 inc	 cx
  00107	51		 push	 ecx
  00108	55		 push	 ebp
  00109	e8 00 00 00 00	 call	 _getbegtar
  0010e	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00111	66 89 42 16	 mov	 WORD PTR [edx+22], ax

; 371  : 
; 372  : 		/* 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 */
; 373  : 		/* Set target value(s) associated with current phone               */
; 374  : 		/* tarcur is target at phone beginning                             */
; 375  : 		/* tarend is target at phone ending                                */
; 376  : 		/* if diphthongized, also set sequence of time,value commands &    */
; 377  : 		/* add special coartic such as change in [ih] due to postvoc [l] */
; 378  : 		/* 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 */
; 379  : 
; 380  : 		pDphsettar->np->tarcur = gettar (phTTS, pDph_t->nphone);        /* target or -pointer to target     */

  00115	66 8b 87 1c 20
	00 00		 mov	 ax, WORD PTR [edi+8220]
  0011c	50		 push	 eax
  0011d	55		 push	 ebp
  0011e	e8 00 00 00 00	 call	 _gettar
  00123	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00126	83 c4 10	 add	 esp, 16			; 00000010H
  00129	66 89 01	 mov	 WORD PTR [ecx], ax

; 381  : #ifdef SPANISH_OUT /* For the life of me I can't understand what this was for eab 7/23/98*/
; 382  : 		// BATS 716 Fixed but bats never noted and cleared
; 383  : 		if (pDphsettar->np == &PF2)
; 384  : #endif
; 385  : 			pDphsettar->np->dipcum = 0;        /* Diph time since phone begin      */

  0012c	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0012f	66 89 5a 06	 mov	 WORD PTR [edx+6], bx

; 386  : 		if (pDphsettar->np->tarcur < -1)

  00133	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00136	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00139	66 3d ff ff	 cmp	 ax, -1
  0013d	7d 28		 jge	 SHORT $L71819

; 387  : 		{   /* -pointer: diphthongized vowel    */
; 388  : 
; 389  : 			make_dip (pDph_t, (-pDphsettar->np->tarcur), inhdr_frames, pDph_t->shrink,
; 390  : 					  struccur, &ndips);    /* Cur seg diphthongized, generate  */

  0013f	8b 54 24 10	 mov	 edx, DWORD PTR _struccur$[esp+60]
  00143	8d 4c 24 38	 lea	 ecx, DWORD PTR _ndips$[esp+60]
  00147	51		 push	 ecx
  00148	66 8b 8f 30 28
	00 00		 mov	 cx, WORD PTR [edi+10288]
  0014f	52		 push	 edx
  00150	8b 54 24 30	 mov	 edx, DWORD PTR _inhdr_frames$[esp+68]
  00154	51		 push	 ecx
  00155	52		 push	 edx
  00156	f7 d8		 neg	 eax
  00158	50		 push	 eax
  00159	57		 push	 edi
  0015a	e8 00 00 00 00	 call	 _make_dip
  0015f	83 c4 18	 add	 esp, 24			; 00000018H

; 391  : 			/* several straight lines (this    */
; 392  : 		}
; 393  : 		/* routine also sets pDphsettar->np->tarend)   */
; 394  : 		else

  00162	e9 81 00 00 00	 jmp	 $L71820
$L71819:

; 395  : 		{
; 396  : 			pDphsettar->np->deldip = 0;             /* Set dipthong increment to zero    */

  00167	66 89 59 04	 mov	 WORD PTR [ecx+4], bx

; 397  : 			pDphsettar->np->durlin = pDph_t->durfon;        /* and dipth dur to phone duration   */

  0016b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0016e	66 8b 8f ac 11
	00 00		 mov	 cx, WORD PTR [edi+4524]
  00175	66 89 48 02	 mov	 WORD PTR [eax+2], cx

; 398  : 
; 399  : 			/* 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 */
; 400  : 			/* General coartic rule for curr sonor cons: prev. & next phones      */
; 401  : 			/* modify formant freqs: 5% tarlas, 5% tarnex, 90% tarcur           */
; 402  : 			/* (only effective for -diph -obst because of p_ locus[] tables)            */
; 403  : 			/* Special case for /r/ and /rr/ in Spanish                           */
; 404  : 			/* 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 */
; 405  : 			if (pDphsettar->par_type IS_FORM_FREQ)

  00179	8a 46 14	 mov	 al, BYTE PTR [esi+20]
  0017c	3c 03		 cmp	 al, 3
  0017e	75 5e		 jne	 SHORT $L71821

; 406  : 			{
; 407  : 				pDphsettar->gencoartic = N10PRCNT;

  00180	66 c7 46 0c 66
	06		 mov	 WORD PTR [esi+12], 1638	; 00000666H

; 408  : #ifdef GERMAN 
; 409  : 				pDph_t->arg3 = 0;
; 410  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 411  : 				/* special german coarticulation rules              */
; 412  : 				/* /R/-coarticulation rules before vowel                */
; 413  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 414  : 				if ((pDphsettar->phcur == R) && (pholas != EX) &&
; 415  : 					((fealas & FVOWEL) IS_PLUS))
; 416  : 				{
; 417  : 					pDphsettar->gencoartic = N20PRCNT;
; 418  : 					pDph_t->arg3 = R;
; 419  : 
; 420  : 				}
; 421  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 422  : 				/* special rule for /@r/ suffix                 */
; 423  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 424  : 				else if ((pDphsettar->phcur == EX) && (pDphsettar->phonex == R))
; 425  : 				{
; 426  : 					if (pDphsettar->np == &PF1)
; 427  : 					{
; 428  : 						pDphsettar->np->tarcur = 520;
; 429  : 					}
; 430  : 					if (pDphsettar->np == &PF2)
; 431  : 					{
; 432  : 						pDphsettar->np->tarcur = 1300;
; 433  : 					}
; 434  : 					pDphsettar->gencoartic = 0;
; 435  : 					pDph_t->arg3 = R;
; 436  : 
; 437  : 				}
; 438  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 439  : 				/* no modification of /r/ after /@/             */
; 440  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 441  : 				else if ((pholas == EX) && (pDphsettar->phcur == R))
; 442  : 				{
; 443  : 					pDphsettar->gencoartic = 0;
; 444  : 					pDph_t->arg3 = R;
; 445  : 
; 446  : 				}
; 447  : 
; 448  : #ifdef LRULES
; 449  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 450  : 				/* special german coarticulation rules              */
; 451  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 452  : 				else if (pDphsettar->phcur == L)
; 453  : 				{
; 454  : 					if (((feanex & FVOWEL) IS_PLUS) &&
; 455  : 						((begtyp[pDphsettar->phonex] != 2) &&
; 456  : 						 (begtyp[pDphsettar->phonex] != 6) &&
; 457  : 						 !((endtyp[pholas] != 1) &&
; 458  : 						   (begtyp[pDphsettar->phonex] == 1))))
; 459  : 					{
; 460  : 						if (pDphsettar->np == &PF1)
; 461  : 						{
; 462  : 							pDphsettar->gencoartic = N30PRCNT;
; 463  : 						}
; 464  : 						else
; 465  : 						{
; 466  : 							pDphsettar->gencoartic = N50PRCNT;
; 467  : 						}
; 468  : 						pDph_t->arg3 = L;
; 469  : 					}
; 470  : 					else if ((endtyp[pholas] == 1) ||
; 471  : 							 ((endtyp[pholas] == 2) ||
; 472  : 							  (endtyp[pholas] == 6)))
; 473  : 					{
; 474  : 						if (pDphsettar->np == &PF1)
; 475  : 						{
; 476  : 							pDphsettar->gencoartic = N40PRCNT;
; 477  : 						}
; 478  : 						else
; 479  : 						{
; 480  : 							pDphsettar->gencoartic = N50PRCNT;
; 481  : 						}
; 482  : 						pDph_t->arg3 = R;
; 483  : 					}
; 484  : 					/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 485  : 					/* make 'L' audible in 'schwa'-'L'-'nasal' cluster           */
; 486  : 					/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 487  : 					else if ((pholas == EX) &&
; 488  : 							 ((featb[pDphsettar->phonex] & FNASAL) IS_PLUS))
; 489  : 					{
; 490  : 						if (pDphsettar->np == &PF1)
; 491  : 						{
; 492  : 							pDphsettar->np->tarnex -= 0;
; 493  : 						}
; 494  : 						else if (pDphsettar->np == &PF2)
; 495  : 						{
; 496  : 							pDphsettar->np->tarnex += 200;
; 497  : 						}
; 498  : 						pDphsettar->gencoartic = 0;
; 499  : 						pDph_t->arg3 = L;
; 500  : 					}
; 501  : 
; 502  : 				}
; 503  : #endif
; 504  : 				/* eab 4/2/7/98 f2 needs some dropping in these contexts*/
; 505  : 				if (pDphsettar->phcur == RR && (pDphsettar->phonex == U))
; 506  : 						if (pDphsettar->np == &PF2)
; 507  : 						{
; 508  : 							pDphsettar->np->tarcur -= 300;
; 509  : 						}
; 510  : 					
; 511  : #ifdef RRULES
; 512  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 513  : 				/* special coarticulation rules for uvular R (RR)           */
; 514  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 515  : 				else if ((pDphsettar->phcur == RR))
; 516  : 				{
; 517  : 					pDphsettar->gencoartic = N20PRCNT;
; 518  : 					pDph_t->arg3 = 0;
; 519  : 					if (begtyp[pDphsettar->phonex] == 1)
; 520  : 					{
; 521  : 						pDphsettar->gencoartic += N10PRCNT;
; 522  : 						pDph_t->arg3 = L;
; 523  : 					}
; 524  : 					if (endtyp[pDphsettar->phonex] == 1)
; 525  : 					{
; 526  : 						pDphsettar->gencoartic += N30PRCNT;
; 527  : 						pDph_t->arg3 = R;
; 528  : 					}
; 529  : 
; 530  : 				}
; 531  : #endif
; 532  : 				else
; 533  : 				{                                          /* standard dt3 treatment */
; 534  : #endif  /* #ifdef GERMAN */
; 535  : 				if ((struccur & FSTRESS) IS_MINUS)

  00186	8a 44 24 10	 mov	 al, BYTE PTR _struccur$[esp+60]
  0018a	a8 03		 test	 al, 3
  0018c	75 16		 jne	 SHORT $L71823

; 536  : 				{
; 537  : 					/* Increased coarticulation, especially F2, if unstressed */
; 538  : 					pDphsettar->gencoartic = N15PRCNT;
; 539  : 					if (pDphsettar->np == &PF2)

  0018e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00191	8d 47 48	 lea	 eax, DWORD PTR [edi+72]
  00194	3b c8		 cmp	 ecx, eax
  00196	66 c7 46 0c 99
	09		 mov	 WORD PTR [esi+12], 2457	; 00000999H
  0019c	75 06		 jne	 SHORT $L71823

; 540  : 					{
; 541  : 						pDphsettar->gencoartic = N25PRCNT;

  0019e	66 c7 46 0c 00
	10		 mov	 WORD PTR [esi+12], 4096	; 00001000H
$L71823:

; 542  : 					}
; 543  : 				} 
; 544  : #ifdef GERMAN
; 545  : 				}
; 546  : 				/* end of else, standard dt3 treatment */
; 547  : 				if (pDphsettar->np->tarnex <= 0)
; 548  : 				{
; 549  : 					pDph_t->arg1 = pDphsettar->np->tarlas - pDphsettar->np->tarcur;
; 550  : 				}
; 551  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 552  : 				/* german R-coarticulation only with previous phonemes      */
; 553  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 554  : 				else if (pDph_t->arg3 == R)
; 555  : 				{
; 556  : 					pDph_t->arg1 = pDphsettar->np->tarlas - pDphsettar->np->tarcur;
; 557  : 
; 558  : 				}
; 559  : 
; 560  : #ifdef LRULES
; 561  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 562  : 				/* most german L-coarticulation only with next phonemes     */
; 563  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 564  : 				else if (pDph_t->arg3 == L)
; 565  : 				{
; 566  : 					pDph_t->arg1 = pDphsettar->np->tarnex - pDphsettar->np->tarcur;
; 567  : 
; 568  : 				}
; 569  : #endif
; 570  : 				else
; 571  : 				{
; 572  : #endif /* #ifdef GERMAN */                              
; 573  : 				pDph_t->arg1 = ((pDphsettar->np->tarlas + pDphsettar->np->tarnex) >> 1) - pDphsettar->np->tarcur;

  001a4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  001a7	0f bf 50 18	 movsx	 edx, WORD PTR [eax+24]
  001ab	0f bf 48 16	 movsx	 ecx, WORD PTR [eax+22]
  001af	03 d1		 add	 edx, ecx
  001b1	d1 fa		 sar	 edx, 1
  001b3	66 2b 10	 sub	 dx, WORD PTR [eax]
  001b6	66 89 97 c4 11
	00 00		 mov	 WORD PTR [edi+4548], dx

; 574  : #ifdef GERMAN
; 575  : 				}
; 576  : #endif
; 577  : 				pDph_t->arg2 = pDphsettar->gencoartic;

  001bd	66 8b 46 0c	 mov	 ax, WORD PTR [esi+12]
  001c1	66 89 87 c6 11
	00 00		 mov	 WORD PTR [edi+4550], ax

; 578  : 				pDphsettar->np->tarcur += mlsh1 (pDph_t->arg1, pDph_t->arg2);

  001c8	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  001cb	0f bf d0	 movsx	 edx, ax
  001ce	0f bf 87 c4 11
	00 00		 movsx	 eax, WORD PTR [edi+4548]
  001d5	0f af d0	 imul	 edx, eax
  001d8	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  001db	66 01 11	 add	 WORD PTR [ecx], dx
$L71821:

; 579  : 			}
; 580  : 			pDphsettar->np->tarend = pDphsettar->np->tarcur;        /* Tar at end of cur phone */

  001de	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  001e1	66 8b 08	 mov	 cx, WORD PTR [eax]
  001e4	66 89 48 1a	 mov	 WORD PTR [eax+26], cx
$L71820:

; 581  : 		}
; 582  : 		/* end of 'else' begun in rule 3 */
; 583  : 
; 584  : 		/* 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 */
; 585  : 		/* Compute (approx.) general coartic of tarnex with tarend         */
; 586  : 		/* THIS IS BAD, FIX IT IF POSSIBLE                                 */
; 587  : 		/* 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 */
; 588  : 		if (pDphsettar->par_type IS_FORM_FREQ)

  001e8	80 7e 14 03	 cmp	 BYTE PTR [esi+20], 3
  001ec	75 32		 jne	 SHORT $L71824

; 589  : 		{
; 590  : 			pDph_t->arg2 = N10PRCNT;

  001ee	66 c7 87 c6 11
	00 00 66 06	 mov	 WORD PTR [edi+4550], 1638 ; 00000666H

; 591  : #ifdef GERMAN
; 592  : 			pDph_t->arg3 = 0;
; 593  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 594  : 			/* special german coarticulation rules             */
; 595  : 			/* /R/-coarticulation rules after vowel                */
; 596  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 597  : 			if ((pDphsettar->phonex == R) && (pDphsettar->phcur != EX) &&
; 598  : 				((feacur & FVOWEL) IS_PLUS))
; 599  : 			{
; 600  : 				pDph_t->arg2 = N20PRCNT;
; 601  : 				pDph_t->arg3 = R;
; 602  : 
; 603  : 			}
; 604  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 605  : 			/* special rule for '@r' suffix                    */
; 606  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 607  : 			else if ((pDphsettar->phcur == EX) && (pDphsettar->phonex == R))
; 608  : 			{
; 609  : 				pDph_t->arg2 = 0;
; 610  : 				pDph_t->arg3 = R;
; 611  : 
; 612  : 			}
; 613  : 
; 614  : #ifdef LRULES
; 615  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 616  : 			/* special german coarticulation rules, if next phoneme is 'L' */
; 617  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 618  : 			else if (pDphsettar->phonex == L)
; 619  : 			{
; 620  : 				if (((featb[phonp2] & FVOWEL) IS_PLUS) &&
; 621  : 					((begtyp[phonp2] != 2) &&
; 622  : 					 (begtyp[phonp2] != 6) &&
; 623  : 					 !((endtyp[pDphsettar->phcur] != 1) &&
; 624  : 					   (begtyp[phonp2] == 1))))
; 625  : 				{
; 626  : 					if (pDphsettar->np == &PF1)
; 627  : 					{
; 628  : 						pDph_t->arg2 = N30PRCNT;
; 629  : 					}
; 630  : 					else
; 631  : 					{
; 632  : 						pDph_t->arg2 = N50PRCNT;
; 633  : 					}
; 634  : 					pDph_t->arg3 = L;
; 635  : 				}
; 636  : 				else if ((endtyp[pDphsettar->phcur] == 1) ||
; 637  : 						 ((endtyp[pDphsettar->phcur] == 2) ||
; 638  : 						  (endtyp[pDphsettar->phcur] == 6)))
; 639  : 				{
; 640  : 					if (pDphsettar->np == &PF1)
; 641  : 					{
; 642  : 						pDph_t->arg2 = N20PRCNT;        /* n40prcnt, eab 5/95  */
; 643  : 					}
; 644  : 					else
; 645  : 					{
; 646  : 						pDph_t->arg2 = N20PRCNT;        /* n50prcnt, eab 5/95 */
; 647  : 					}
; 648  : 					pDph_t->arg3 = R;
; 649  : 				}
; 650  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 651  : 				/* make 'L' audible in 'schwa'-'L'-'nasal' cluster          */
; 652  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 653  : 				else if ((pDphsettar->phcur == EX) &&
; 654  : 						 ((featb[phonp2] & FNASAL) IS_PLUS))
; 655  : 				{
; 656  : 					if (pDphsettar->np == &PF1)
; 657  : 					{
; 658  : 						pDphsettar->np->tarnex -= 0;
; 659  : 					}
; 660  : 					else if (pDphsettar->np == &PF2)
; 661  : 					{
; 662  : 						pDphsettar->np->tarnex += 200;
; 663  : 					}
; 664  : 					pDph_t->arg2 = 0;
; 665  : 					pDph_t->arg3 = L;
; 666  : 				}
; 667  : 
; 668  : 			}
; 669  : #endif
; 670  : 
; 671  : #ifdef RRULES
; 672  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 673  : 			/* special coarticulation rules for uvular R (RR)          */
; 674  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 675  : 			else if ((pDphsettar->phonex == RR))
; 676  : 			{
; 677  : 				pDph_t->arg2 = N20PRCNT;
; 678  : 				pDph_t->arg3 = 0;
; 679  : 				if (begtyp[phonp2] == 1)
; 680  : 				{
; 681  : 					pDph_t->arg2 += N10PRCNT;
; 682  : 					pDph_t->arg3 = L;
; 683  : 				}
; 684  : 				if (endtyp[phonp2] == 1)
; 685  : 				{
; 686  : 					pDph_t->arg2 += N30PRCNT;
; 687  : 					pDph_t->arg3 = R;
; 688  : 				}
; 689  : 
; 690  : 			}
; 691  : #endif
; 692  : 			else
; 693  : 			{                                                  /* standard dt3 treatment */
; 694  : 				if ((struccur & FSTRESS) IS_MINUS)
; 695  : 				{
; 696  : 					/* Increased coarticulation, especially F2, if unstressed */
; 697  : 					pDph_t->arg2 = N15PRCNT;
; 698  : 					if (pDphsettar->np == &PF2)
; 699  : 					{
; 700  : 						pDph_t->arg2 = N25PRCNT;
; 701  : 					}
; 702  : 				}
; 703  : 			}
; 704  : 			/* end of else, standard dt3 treatment */
; 705  : 			if (pDphsettar->np->tarnex <= 0)
; 706  : 			{
; 707  : 				pDph_t->arg1 = pDphsettar->np->tarend;
; 708  : 			}
; 709  : 
; 710  : #ifdef LRULES
; 711  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 712  : 			/* some german L-coarticulation rules with second next phonemes    */
; 713  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 714  : 			else if (pDph_t->arg3 == L)
; 715  : 			{
; 716  : 				pDph_t->arg1 = pDphsettar->np->tarend - getbegtar (phTTS,pDph_t->nphone + 2);
; 717  : 				/* Calls gettar() */
; 718  : 
; 719  : 			}
; 720  : #endif
; 721  : 			else
; 722  : 			{
; 723  : #endif /* #ifdef GERMAN */
; 724  : 				pDph_t->arg1 = pDphsettar->np->tarend - pDphsettar->np->tarnex;

  001f7	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  001fa	66 8b 41 1a	 mov	 ax, WORD PTR [ecx+26]
  001fe	66 2b 41 16	 sub	 ax, WORD PTR [ecx+22]
  00202	66 89 87 c4 11
	00 00		 mov	 WORD PTR [edi+4548], ax

; 725  : #ifdef GERMAN
; 726  : 		}
; 727  : #endif
; 728  : 			pDphsettar->np->tarnex += mlsh1 (pDph_t->arg1, pDph_t->arg2);

  00209	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0020c	0f bf d0	 movsx	 edx, ax
  0020f	0f bf 87 c6 11
	00 00		 movsx	 eax, WORD PTR [edi+4550]
  00216	0f af d0	 imul	 edx, eax
  00219	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  0021c	66 01 51 16	 add	 WORD PTR [ecx+22], dx
$L71824:

; 729  : 		}
; 730  : 		/*WINprintf("pholas=%d  pDphsettar->phcur=%d  pDphsettar->phonex=%d \n",
; 731  : 	  pholas, pDphsettar->phcur, pDphsettar->phonex); */
; 732  : 		
; 733  : 
; 734  : 		/* 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 */
; 735  : 		/* Smooth forward from beginning of current phone            */
; 736  : 		/* Default bouval is halfway, half of transition duration is 30 ms */
; 737  : 		/* 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 */
; 738  : 
; 739  : 		pDphsettar->bouval = (pDphsettar->np->tarlas + pDphsettar->np->tarcur) >> 1;

  00220	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00223	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  00227	0f bf 10	 movsx	 edx, WORD PTR [eax]
  0022a	03 ca		 add	 ecx, edx

; 740  : 		pDphsettar->durtran = NF30MS;

  0022c	66 c7 46 06 05
	00		 mov	 WORD PTR [esi+6], 5
  00232	d1 f9		 sar	 ecx, 1
  00234	66 89 0e	 mov	 WORD PTR [esi], cx

; 741  : 		/* 
; 742  : 		 * printf("pDph_t->shrif %d, pholas %d, fealas %d, feacur %d, struclas %d, struccur %d, 
; 743  : 		 * feanex %d\n",pDph_t->shrif, pholas,fealas, feacur, struclas, struccur,feanex);
; 744  : 		 */
; 745  : 		forw_smooth_rules (phTTS, pDph_t->shrif, pholas,
; 746  : 						   fealas, feacur, struclas, struccur,feanex);          /* This routine contains all the "smarts" */

  00237	8b 44 24 14	 mov	 eax, DWORD PTR _feanex$[esp+60]
  0023b	8b 4c 24 10	 mov	 ecx, DWORD PTR _struccur$[esp+60]
  0023f	8b 54 24 1c	 mov	 edx, DWORD PTR _struclas$[esp+60]
  00243	50		 push	 eax
  00244	8b 44 24 1c	 mov	 eax, DWORD PTR _feacur$[esp+64]
  00248	51		 push	 ecx
  00249	8b 4c 24 2c	 mov	 ecx, DWORD PTR _fealas$[esp+68]
  0024d	52		 push	 edx
  0024e	8b 54 24 2c	 mov	 edx, DWORD PTR _pholas$[esp+72]
  00252	50		 push	 eax
  00253	66 8b 87 32 28
	00 00		 mov	 ax, WORD PTR [edi+10290]
  0025a	51		 push	 ecx
  0025b	52		 push	 edx
  0025c	50		 push	 eax
  0025d	55		 push	 ebp
  0025e	e8 00 00 00 00	 call	 _forw_smooth_rules

; 747  : 		 
; 748  : 	/*	 printf("forward durtran %d tarend %d tarlas %d bouval %d tbacktr %d\n",
; 749  : 		  pDphsettar->durtran, pDphsettar->np->tarend,pDphsettar->np->tarlas,
; 750  : 		  pDphsettar->bouval, pDphsettar->np->tbacktr); 
; 751  : 	*/	 
; 752  : 
; 753  : 		/* Convert bouval and pDphsettar->durtran into params used directly by phdraw() */
; 754  : 		pDphsettar->np->ftran = 0;

  00263	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00266	83 c4 20	 add	 esp, 32			; 00000020H
  00269	66 89 59 08	 mov	 WORD PTR [ecx+8], bx

; 755  : 		if (pDphsettar->durtran > 0)

  0026d	66 39 5e 06	 cmp	 WORD PTR [esi+6], bx
  00271	7e 5d		 jle	 SHORT $L71826

; 756  : 		{
; 757  : 			/* Incremental change per frame                        */
; 758  : 			/* (shift left 3 bits to avoid roundoff accumulation)  */
; 759  : 			pDphsettar->np->ftran = (pDphsettar->bouval - pDphsettar->np->tarcur) << 3;

  00273	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00276	66 8b 16	 mov	 dx, WORD PTR [esi]
  00279	66 2b 10	 sub	 dx, WORD PTR [eax]
  0027c	c1 e2 03	 shl	 edx, 3
  0027f	66 89 50 08	 mov	 WORD PTR [eax+8], dx

; 760  : 			if (pDphsettar->np->ftran != 0)

  00283	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00286	66 8b 40 08	 mov	 ax, WORD PTR [eax+8]
  0028a	66 3b c3	 cmp	 ax, bx
  0028d	74 41		 je	 SHORT $L71826

; 761  : 			{
; 762  : 				pDph_t->arg1 = pDphsettar->np->ftran;

  0028f	66 89 87 c4 11
	00 00		 mov	 WORD PTR [edi+4548], ax

; 763  : 				pDph_t->arg2 = divtab[pDphsettar->durtran];

  00296	0f bf 4e 06	 movsx	 ecx, WORD PTR [esi+6]
  0029a	66 8b 04 4d 00
	00 00 00	 mov	 ax, WORD PTR _divtab[ecx*2]
  002a2	66 89 87 c6 11
	00 00		 mov	 WORD PTR [edi+4550], ax

; 764  : 				pDphsettar->np->dftran = mlsh1 (pDph_t->arg1, pDph_t->arg2);

  002a9	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  002ac	0f bf d0	 movsx	 edx, ax
  002af	0f bf 87 c4 11
	00 00		 movsx	 eax, WORD PTR [edi+4548]
  002b6	0f af d0	 imul	 edx, eax
  002b9	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  002bc	66 89 51 0a	 mov	 WORD PTR [ecx+10], dx

; 765  : 				pDphsettar->np->ftran = pDphsettar->np->dftran * pDphsettar->durtran;

  002c0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  002c3	66 8b 50 0a	 mov	 dx, WORD PTR [eax+10]
  002c7	66 0f af 56 06	 imul	 dx, WORD PTR [esi+6]
  002cc	66 89 50 08	 mov	 WORD PTR [eax+8], dx
$L71826:

; 766  : 			}
; 767  : 		}
; 768  : 		//debugforward (" Unknown rule must have been executed", pDphsettar->np);
; 769  : 
; 770  : 		/* Slowish vowel-vowel formant motions across consonant modeled by   */
; 771  : 		/* a separate transition increment and duration, so far only for F2 */
; 772  : 		/* (vvbouval and vvdurtran set in routine forw_smooth_rules() which */
; 773  : 		/* calls setloc() which calls vv_coartic_across_c())                  */
; 774  : 		if (pDphsettar->np == &PF2)

  002d0	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  002d3	8d 47 48	 lea	 eax, DWORD PTR [edi+72]
  002d6	3b c8		 cmp	 ecx, eax
  002d8	75 76		 jne	 SHORT $L71827

; 775  : 		{
; 776  : 			pDph_t->fvvtran = 0;
; 777  : 			pDph_t->dfvvtran = 0;
; 778  : 			/* Truncate tran dur if exceeds duration of current phone */
; 779  : 			if (pDphsettar->vvdurtran > pDph_t->durfon)

  002da	66 8b 87 ac 11
	00 00		 mov	 ax, WORD PTR [edi+4524]
  002e1	66 89 9f ac 02
	00 00		 mov	 WORD PTR [edi+684], bx
  002e8	66 89 9f b2 02
	00 00		 mov	 WORD PTR [edi+690], bx
  002ef	66 39 46 08	 cmp	 WORD PTR [esi+8], ax
  002f3	7e 04		 jle	 SHORT $L71828

; 780  : 				pDphsettar->vvdurtran = pDph_t->durfon;

  002f5	66 89 46 08	 mov	 WORD PTR [esi+8], ax
$L71828:

; 781  : 			if ((pDphsettar->vvdurtran > 0) && (pDphsettar->vvbouval != 0))

  002f9	66 39 5e 08	 cmp	 WORD PTR [esi+8], bx
  002fd	7e 49		 jle	 SHORT $L71829
  002ff	66 8b 46 04	 mov	 ax, WORD PTR [esi+4]
  00303	66 3b c3	 cmp	 ax, bx
  00306	74 40		 je	 SHORT $L71829

; 782  : 			{
; 783  : 				/* Shift left 3 bits to avoid roundoff accumulation */
; 784  : 				pDph_t->arg1 = pDphsettar->vvbouval << 3;

  00308	c1 e0 03	 shl	 eax, 3
  0030b	66 89 87 c4 11
	00 00		 mov	 WORD PTR [edi+4548], ax

; 785  : 				pDph_t->arg2 = divtab[pDphsettar->vvdurtran];

  00312	0f bf 4e 08	 movsx	 ecx, WORD PTR [esi+8]

; 786  : 				pDph_t->dfvvtran = mlsh1 (pDph_t->arg1, pDph_t->arg2);  /* pDphsettar->vvbouval*8 / pDphsettar->vvdurtran */

  00316	0f bf 97 c4 11
	00 00		 movsx	 edx, WORD PTR [edi+4548]
  0031d	66 8b 04 4d 00
	00 00 00	 mov	 ax, WORD PTR _divtab[ecx*2]
  00325	66 89 87 c6 11
	00 00		 mov	 WORD PTR [edi+4550], ax
  0032c	0f bf c0	 movsx	 eax, ax
  0032f	0f af c2	 imul	 eax, edx
  00332	c1 f8 0e	 sar	 eax, 14			; 0000000eH
  00335	66 89 87 b2 02
	00 00		 mov	 WORD PTR [edi+690], ax

; 787  : 				pDph_t->fvvtran = pDph_t->dfvvtran * pDphsettar->vvdurtran;

  0033c	66 0f af 46 08	 imul	 ax, WORD PTR [esi+8]
  00341	66 89 87 ac 02
	00 00		 mov	 WORD PTR [edi+684], ax
$L71829:

; 788  : 			}
; 789  : 			pDphsettar->vvdurtran = 0;

  00348	66 89 5e 08	 mov	 WORD PTR [esi+8], bx

; 790  : 			pDphsettar->vvbouval = 0;

  0034c	66 89 5e 04	 mov	 WORD PTR [esi+4], bx
$L71827:

; 791  : 		}
; 792  : 		/* 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 */
; 793  : 		/* Smooth backward from end of current phone                               */
; 794  : 		/* Default bouval is halfway, half of transition duration is 30 ms                 */
; 795  : 		/* 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 */
; 796  : 
; 797  : 		pDphsettar->bouval = (pDphsettar->np->tarend + pDphsettar->np->tarnex) >> 1;

  00350	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00353	0f bf 48 1a	 movsx	 ecx, WORD PTR [eax+26]
  00357	0f bf 50 16	 movsx	 edx, WORD PTR [eax+22]
  0035b	03 ca		 add	 ecx, edx

; 798  : 		pDphsettar->durtran = NF25MS;

  0035d	66 c7 46 06 04
	00		 mov	 WORD PTR [esi+6], 4
  00363	d1 f9		 sar	 ecx, 1
  00365	66 89 0e	 mov	 WORD PTR [esi], cx

; 799  : 
; 800  : 		/* 
; 801  : 		 * printf("pDph_t->shrib %d, pDphsettar->phcur %d feacur %d, feanex %d, 
; 802  : 		 * strucnex %d\n",pDph_t->shrib, pDphsettar->phcur, feacur, feanex, strucnex); 
; 803  : 		 */
; 804  : 		/* This routine contains all the "smarts" */
; 805  : 		back_smooth_rules (phTTS, pDph_t->shrib, feacur, feanex, strucnex);     

  00368	8b 44 24 2c	 mov	 eax, DWORD PTR _strucnex$[esp+60]
  0036c	8b 4c 24 14	 mov	 ecx, DWORD PTR _feanex$[esp+60]
  00370	8b 54 24 18	 mov	 edx, DWORD PTR _feacur$[esp+60]
  00374	50		 push	 eax
  00375	66 8b 87 34 28
	00 00		 mov	 ax, WORD PTR [edi+10292]
  0037c	51		 push	 ecx
  0037d	52		 push	 edx
  0037e	50		 push	 eax
  0037f	55		 push	 ebp
  00380	e8 00 00 00 00	 call	 _back_smooth_rules

; 806  : 		
; 807  : 		 /*
; 808  : 		  printf("backward durtran %d tarend %d tarlas %d bouval %d tbacktr %d\n",
; 809  : 		  pDphsettar->durtran, 
; 810  : 		  pDphsettar->np->tarend,pDphsettar->np->tarlas,pDphsettar->bouval, 
; 811  : 		  pDphsettar->np->tbacktr);
; 812  : 		 */
; 813  : 
; 814  : 		/* Convert bouval and pDphsettar->durtran into params used directly by phdraw() */
; 815  : 		pDphsettar->np->btran = 0;

  00385	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00388	83 c4 14	 add	 esp, 20			; 00000014H
  0038b	66 89 59 0c	 mov	 WORD PTR [ecx+12], bx

; 816  : 		pDphsettar->np->dbtran = 0;

  0038f	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00392	66 89 5a 0e	 mov	 WORD PTR [edx+14], bx

; 817  : 		if (pDphsettar->durtran > 0)

  00396	66 39 5e 06	 cmp	 WORD PTR [esi+6], bx
  0039a	7e 43		 jle	 SHORT $L71831

; 818  : 		{
; 819  : 			/* Shift left 3 bits to avoid roundoff accumulation */
; 820  : 			temp = (pDphsettar->bouval - pDphsettar->np->tarend) << 3;

  0039c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0039f	66 8b 06	 mov	 ax, WORD PTR [esi]
  003a2	66 2b 41 1a	 sub	 ax, WORD PTR [ecx+26]
  003a6	c1 e0 03	 shl	 eax, 3

; 821  : 			if (temp != 0)

  003a9	66 3b c3	 cmp	 ax, bx
  003ac	74 31		 je	 SHORT $L71831

; 822  : 			{
; 823  : 				pDph_t->arg1 = temp;

  003ae	66 89 87 c4 11
	00 00		 mov	 WORD PTR [edi+4548], ax

; 824  : 				pDph_t->arg2 = divtab[pDphsettar->durtran];

  003b5	0f bf 56 06	 movsx	 edx, WORD PTR [esi+6]

; 825  : 				pDphsettar->np->dbtran = mlsh1 (pDph_t->arg1, pDph_t->arg2);

  003b9	0f bf 8f c4 11
	00 00		 movsx	 ecx, WORD PTR [edi+4548]
  003c0	66 8b 04 55 00
	00 00 00	 mov	 ax, WORD PTR _divtab[edx*2]
  003c8	66 89 87 c6 11
	00 00		 mov	 WORD PTR [edi+4550], ax
  003cf	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  003d2	0f bf c0	 movsx	 eax, ax
  003d5	0f af c1	 imul	 eax, ecx
  003d8	c1 f8 0e	 sar	 eax, 14			; 0000000eH
  003db	66 89 42 0e	 mov	 WORD PTR [edx+14], ax
$L71831:

; 826  : 			}
; 827  : 		}
; 828  : 		//debugbackward (" Unknown rule must have been executed", pDphsettar->np);
; 829  : 
; 830  : 		/* Slowish vowel-vowel formant motions across consonant modeled by   */
; 831  : 		/* a separate transition increment and duration, so far only for F2 */
; 832  : 		/* (vvbouval and pDphsettar->vvdurtran set in routine back_smooth_rules() which */
; 833  : 		/* calls setloc() which calls vv_coartic_across_c())                  */
; 834  : 		if (pDphsettar->np == &PF2)

  003df	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  003e2	8d 47 48	 lea	 eax, DWORD PTR [edi+72]
  003e5	3b c8		 cmp	 ecx, eax
  003e7	0f 85 83 00 00
	00		 jne	 $L71817

; 835  : 		{
; 836  : 			pDph_t->bvvtran = 0;       /* Default if no vv-coartic */
; 837  : 			pDph_t->dbvvtran = 0;      /* Default if no vv-coartic */
; 838  : 			pDph_t->tvvbacktr = pDph_t->durfon;             /* Default if no vv-coartic */

  003ed	66 8b 87 ac 11
	00 00		 mov	 ax, WORD PTR [edi+4524]
  003f4	66 89 9f ae 02
	00 00		 mov	 WORD PTR [edi+686], bx
  003fb	66 89 9f b4 02
	00 00		 mov	 WORD PTR [edi+692], bx
  00402	66 89 87 b0 02
	00 00		 mov	 WORD PTR [edi+688], ax

; 839  : 			/* Truncate tran dur if exceeds duration of current phone */
; 840  : 			if (pDphsettar->vvdurtran > pDph_t->durfon)

  00409	66 39 46 08	 cmp	 WORD PTR [esi+8], ax
  0040d	7e 04		 jle	 SHORT $L71833

; 841  : 				pDphsettar->vvdurtran = pDph_t->durfon;

  0040f	66 89 46 08	 mov	 WORD PTR [esi+8], ax
$L71833:

; 842  : 			if ((pDphsettar->vvdurtran > 0) && (pDphsettar->vvbouval != 0))

  00413	66 8b 46 08	 mov	 ax, WORD PTR [esi+8]
  00417	66 3b c3	 cmp	 ax, bx
  0041a	7e 4c		 jle	 SHORT $L71834
  0041c	66 39 5e 04	 cmp	 WORD PTR [esi+4], bx
  00420	74 46		 je	 SHORT $L71834

; 843  : 			{
; 844  : 				pDph_t->tvvbacktr = pDph_t->durfon - pDphsettar->vvdurtran;

  00422	66 8b 8f ac 11
	00 00		 mov	 cx, WORD PTR [edi+4524]
  00429	66 2b c8	 sub	 cx, ax
  0042c	66 89 8f b0 02
	00 00		 mov	 WORD PTR [edi+688], cx

; 845  : 				/* Shift left 3 bits to avoid roundoff accumulation */
; 846  : 				pDph_t->arg1 = pDphsettar->vvbouval << 3;

  00433	66 8b 56 04	 mov	 dx, WORD PTR [esi+4]
  00437	66 c1 e2 03	 shl	 dx, 3
  0043b	66 89 97 c4 11
	00 00		 mov	 WORD PTR [edi+4548], dx

; 847  : 				pDph_t->arg2 = divtab[pDphsettar->vvdurtran];

  00442	0f bf 46 08	 movsx	 eax, WORD PTR [esi+8]

; 848  : 				pDph_t->dbvvtran = mlsh1 (pDph_t->arg1, pDph_t->arg2);  /* vvbouval*8 / pDphsettar->vvdurtran */

  00446	0f bf d2	 movsx	 edx, dx
  00449	66 8b 04 45 00
	00 00 00	 mov	 ax, WORD PTR _divtab[eax*2]
  00451	0f bf c8	 movsx	 ecx, ax
  00454	0f af ca	 imul	 ecx, edx
  00457	c1 f9 0e	 sar	 ecx, 14			; 0000000eH
  0045a	66 89 87 c6 11
	00 00		 mov	 WORD PTR [edi+4550], ax
  00461	66 89 8f b4 02
	00 00		 mov	 WORD PTR [edi+692], cx
$L71834:

; 849  : 			}
; 850  : 			pDphsettar->vvdurtran = 0;

  00468	66 89 5e 08	 mov	 WORD PTR [esi+8], bx

; 851  : 			pDphsettar->vvbouval = 0;

  0046c	66 89 5e 04	 mov	 WORD PTR [esi+4], bx
$L71817:
  00470	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00473	8d 87 40 02 00
	00		 lea	 eax, DWORD PTR [edi+576]
  00479	83 c2 24	 add	 edx, 36			; 00000024H
  0047c	8b ca		 mov	 ecx, edx
  0047e	89 56 10	 mov	 DWORD PTR [esi+16], edx
  00481	3b c8		 cmp	 ecx, eax
  00483	0f 86 46 fc ff
	ff		 jbe	 $L71816
$L71818:

; 852  : 		}
; 853  : 	}
; 854  : 	/* 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 */
; 855  : 	/* Special rules that override values computed in regular way.          */
; 856  : 	/* From the beginning of the current phone to a time "tspesh",          */
; 857  : 	/* place the constant value "pspesh" in the given parameter track.      */
; 858  : 	/* (Used to generate bursts, aspiration for [ptk], voicebar for [bdg]) */
; 859  : 	/* 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 */
; 860  : 
; 861  : 	special_rules (phTTS, fealas, feacur, feanex, struclm2, struccur, pholas, struclas);

  00489	8b 44 24 1c	 mov	 eax, DWORD PTR _struclas$[esp+60]
  0048d	8b 4c 24 20	 mov	 ecx, DWORD PTR _pholas$[esp+60]
  00491	8b 54 24 10	 mov	 edx, DWORD PTR _struccur$[esp+60]
  00495	50		 push	 eax
  00496	8b 44 24 34	 mov	 eax, DWORD PTR _struclm2$[esp+64]
  0049a	51		 push	 ecx
  0049b	8b 4c 24 1c	 mov	 ecx, DWORD PTR _feanex$[esp+68]
  0049f	52		 push	 edx
  004a0	8b 54 24 24	 mov	 edx, DWORD PTR _feacur$[esp+72]
  004a4	50		 push	 eax
  004a5	8b 44 24 34	 mov	 eax, DWORD PTR _fealas$[esp+76]
  004a9	51		 push	 ecx
  004aa	8b 4c 24 54	 mov	 ecx, DWORD PTR _phTTS$[esp+76]
  004ae	52		 push	 edx
  004af	50		 push	 eax
  004b0	51		 push	 ecx
  004b1	e8 00 00 00 00	 call	 _special_rules
  004b6	83 c4 20	 add	 esp, 32			; 00000020H
  004b9	5f		 pop	 edi
  004ba	5e		 pop	 esi
  004bb	5d		 pop	 ebp
  004bc	5b		 pop	 ebx

; 862  : }

  004bd	83 c4 2c	 add	 esp, 44			; 0000002cH
  004c0	c3		 ret	 0
_phsettar ENDP
_TEXT	ENDS
EXTRN	_featb:BYTE
EXTRN	_place:BYTE
EXTRN	_begtyp:BYTE
EXTRN	_endtyp:BYTE
EXTRN	_ptram:BYTE
EXTRN	_parini:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_nphone_temp$ = 12
_phone_temp$ = 12
_phlas_temp$ = 8
_phnex_temp$ = -16
_tartemp$ = 12
_npar$ = -12
_pKsd_t$ = -4
_pDphsettar$ = -8
_gettar	PROC NEAR

; 68   : {

  004d0	83 ec 10	 sub	 esp, 16			; 00000010H

; 69   : 	short                   phone_temp, phlas_temp, phnex_temp, tartemp, pphotr, begtypnex, npar;
; 70   : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  004d3	8b 44 24 14	 mov	 eax, DWORD PTR _phTTS$[esp+12]
  004d7	53		 push	 ebx
  004d8	55		 push	 ebp
  004d9	56		 push	 esi
  004da	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]

; 71   : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;

  004dd	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  004e0	89 44 24 18	 mov	 DWORD PTR _pKsd_t$[esp+28], eax
  004e4	57		 push	 edi

; 72   : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;

  004e5	8b 81 48 28 00
	00		 mov	 eax, DWORD PTR [ecx+10312]
  004eb	89 44 24 18	 mov	 DWORD PTR _pDphsettar$[esp+32], eax

; 73   : 
; 74   : 	npar = pDphsettar->np - &PF1;

  004ef	8b 68 10	 mov	 ebp, DWORD PTR [eax+16]
  004f2	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  004f7	8b d5		 mov	 edx, ebp
  004f9	2b d1		 sub	 edx, ecx
  004fb	83 ea 24	 sub	 edx, 36			; 00000024H
  004fe	f7 ea		 imul	 edx
  00500	c1 fa 03	 sar	 edx, 3
  00503	8b c2		 mov	 eax, edx
  00505	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00508	03 d0		 add	 edx, eax

; 75   : 	if (pDphsettar->np < &PFZ)                      

  0050a	8d 81 90 00 00
	00		 lea	 eax, DWORD PTR [ecx+144]
  00510	3b e8		 cmp	 ebp, eax
  00512	89 54 24 14	 mov	 DWORD PTR _npar$[esp+32], edx

; 76   : 		pphotr = (npar) * TOT_ALLOPHONES;

  00516	8d 04 d2	 lea	 eax, DWORD PTR [edx+edx*8]
  00519	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0051c	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  0051f	72 04		 jb	 SHORT $L71350

; 77   : 	else
; 78   : 		pphotr = (npar - 1) * TOT_ALLOPHONES;

  00521	8d 7c 40 c7	 lea	 edi, DWORD PTR [eax+eax*2-57]
$L71350:

; 79   : 		/* No table entries for PAP parameter */
; 80   : 
; 81   : 	phlas_temp = get_phone (pDph_t, nphone_temp - 1);

  00525	66 8b 74 24 28	 mov	 si, WORD PTR _nphone_temp$[esp+28]
  0052a	0f bf de	 movsx	 ebx, si
  0052d	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00530	85 c0		 test	 eax, eax
  00532	7c 22		 jl	 SHORT $L71955
  00534	0f bf 91 ae 11
	00 00		 movsx	 edx, WORD PTR [ecx+4526]
  0053b	3b c2		 cmp	 eax, edx
  0053d	7d 13		 jge	 SHORT $L71967
  0053f	66 8b 84 59 00
	03 00 00	 mov	 ax, WORD PTR [ecx+ebx*2+768]
  00547	8b 54 24 14	 mov	 edx, DWORD PTR _npar$[esp+32]
  0054b	66 89 44 24 24	 mov	 WORD PTR _phlas_temp$[esp+28], ax
  00550	eb 0c		 jmp	 SHORT $L71956
$L71967:
  00552	8b 54 24 14	 mov	 edx, DWORD PTR _npar$[esp+32]
$L71955:
  00556	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _phlas_temp$[esp+28], 0
$L71956:

; 82   : 	phone_temp = get_phone (pDph_t, nphone_temp);

  0055e	66 85 f6	 test	 si, si
  00561	7c 18		 jl	 SHORT $L71957
  00563	66 3b b1 ae 11
	00 00		 cmp	 si, WORD PTR [ecx+4526]
  0056a	7d 0f		 jge	 SHORT $L71957
  0056c	66 8b 84 59 02
	03 00 00	 mov	 ax, WORD PTR [ecx+ebx*2+770]
  00574	66 89 44 24 28	 mov	 WORD PTR _phone_temp$[esp+28], ax
  00579	eb 08		 jmp	 SHORT $L71958
$L71957:
  0057b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _phone_temp$[esp+28], 0
$L71958:

; 83   : 	phnex_temp = get_phone (pDph_t, nphone_temp + 1);

  00583	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00586	85 c0		 test	 eax, eax
  00588	7c 1a		 jl	 SHORT $L71959
  0058a	0f bf b1 ae 11
	00 00		 movsx	 esi, WORD PTR [ecx+4526]
  00591	3b c6		 cmp	 eax, esi
  00593	7d 0f		 jge	 SHORT $L71959
  00595	66 8b 84 59 04
	03 00 00	 mov	 ax, WORD PTR [ecx+ebx*2+772]
  0059d	66 89 44 24 10	 mov	 WORD PTR _phnex_temp$[esp+32], ax
  005a2	eb 08		 jmp	 SHORT $L71960
$L71959:
  005a4	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _phnex_temp$[esp+32], 0
$L71960:

; 84   : 
; 85   : 	/* GETTAR:  F1, F2, F3, B1, B2, B3 */
; 86   : 	if ((pDphsettar->par_type = partyp[npar]) IS_FORM_FREQ_OR_BW)

  005ac	8b 74 24 18	 mov	 esi, DWORD PTR _pDphsettar$[esp+32]
  005b0	0f bf c2	 movsx	 eax, dx
  005b3	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _partyp[eax]
  005b9	3c 02		 cmp	 al, 2
  005bb	88 46 14	 mov	 BYTE PTR [esi+20], al
  005be	0f 8e 7c 01 00
	00		 jle	 $L71351

; 87   : 	{
; 88   : 		if ((tartemp = pDph_t->p_tar[phone_temp + pphotr]) < -1)

  005c4	0f bf 6c 24 28	 movsx	 ebp, WORD PTR _phone_temp$[esp+28]
  005c9	0f bf f7	 movsx	 esi, di
  005cc	8b b9 bc 11 00
	00		 mov	 edi, DWORD PTR [ecx+4540]
  005d2	8d 04 2e	 lea	 eax, DWORD PTR [esi+ebp]
  005d5	66 8b 04 47	 mov	 ax, WORD PTR [edi+eax*2]
  005d9	66 3d ff ff	 cmp	 ax, -1

; 89   : 		{
; 90   : 			/* printf("tartem1 %d of %d \n",*tartemp,phone_temp); */
; 91   : 			return (tartemp);		   /* Pointer to diph info in p_diph[] */

  005dd	0f 8c a6 03 00
	00		 jl	 $L71338

; 92   : 		}
; 93   : 		else if (tartemp == -1)

  005e3	0f 85 9a 00 00
	00		 jne	 $L71361

; 94   : 		{
; 95   : 			/* Tar undefined, use tarval of next segment */
; 96   : 			if ((tartemp = pDph_t->p_tar[phnex_temp + pphotr]) == -1)

  005e9	0f bf 44 24 10	 movsx	 eax, WORD PTR _phnex_temp$[esp+32]
  005ee	03 c6		 add	 eax, esi
  005f0	66 8b 04 47	 mov	 ax, WORD PTR [edi+eax*2]
  005f4	66 3d ff ff	 cmp	 ax, -1
  005f8	0f 85 89 00 00
	00		 jne	 $L71981

; 97   : 			{
; 98   : 				/* Tar still undefined, use tarval of second-next segment */
; 99   : 				if ((tartemp = pDph_t->p_tar[get_phone (pDph_t, nphone_temp + 2) + pphotr]) == -1)

  005fe	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  00601	85 c0		 test	 eax, eax
  00603	7c 1d		 jl	 SHORT $L71961
  00605	0f bf 91 ae 11
	00 00		 movsx	 edx, WORD PTR [ecx+4526]
  0060c	3b c2		 cmp	 eax, edx
  0060e	7d 0e		 jge	 SHORT $L71972
  00610	0f bf 84 59 06
	03 00 00	 movsx	 eax, WORD PTR [ecx+ebx*2+774]
  00618	8b 54 24 14	 mov	 edx, DWORD PTR _npar$[esp+32]
  0061c	eb 06		 jmp	 SHORT $L71962
$L71972:
  0061e	8b 54 24 14	 mov	 edx, DWORD PTR _npar$[esp+32]
$L71961:
  00622	33 c0		 xor	 eax, eax
$L71962:
  00624	03 c6		 add	 eax, esi
  00626	66 8b 04 47	 mov	 ax, WORD PTR [edi+eax*2]
  0062a	66 3d ff ff	 cmp	 ax, -1
  0062e	75 57		 jne	 SHORT $L71981

; 100  : 				{
; 101  : 					/* Tar still undefined, use previous phone */
; 102  : 					if ((tartemp = pDph_t->p_tar[phlas_temp + pphotr]) < -1)

  00630	0f bf 44 24 24	 movsx	 eax, WORD PTR _phlas_temp$[esp+28]
  00635	03 c6		 add	 eax, esi
  00637	66 8b 04 47	 mov	 ax, WORD PTR [edi+eax*2]
  0063b	66 3d ff ff	 cmp	 ax, -1
  0063f	7d 35		 jge	 SHORT $L71982

; 103  : 					{
; 104  : 						/* Diphthonized seg, use last target value */
; 105  : 						while (pDph_t->p_diph[-tartemp] != -1)

  00641	8b b1 b8 11 00
	00		 mov	 esi, DWORD PTR [ecx+4536]
  00647	0f bf f8	 movsx	 edi, ax
  0064a	d1 e7		 shl	 edi, 1
  0064c	8b de		 mov	 ebx, esi
  0064e	2b df		 sub	 ebx, edi
  00650	66 83 3b ff	 cmp	 WORD PTR [ebx], -1
  00654	74 10		 je	 SHORT $L71360
$L71359:

; 106  : 						{
; 107  : 							tartemp--;

  00656	48		 dec	 eax
  00657	8b de		 mov	 ebx, esi
  00659	0f bf f8	 movsx	 edi, ax
  0065c	d1 e7		 shl	 edi, 1
  0065e	2b df		 sub	 ebx, edi
  00660	66 83 3b ff	 cmp	 WORD PTR [ebx], -1
  00664	75 f0		 jne	 SHORT $L71359
$L71360:

; 108  : 						}
; 109  : 						tartemp = pDph_t->p_diph[-tartemp - 1];

  00666	0f bf c0	 movsx	 eax, ax
  00669	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  0066d	2b f0		 sub	 esi, eax
  0066f	66 8b 06	 mov	 ax, WORD PTR [esi]

; 110  : 					}
; 111  : 					/* If this doesn't work, use default value */
; 112  : 					if (tartemp == -1)

  00672	66 3d ff ff	 cmp	 ax, -1
$L71982:
  00676	75 0f		 jne	 SHORT $L71981

; 113  : 					{
; 114  : 						tartemp = parini[npar];

  00678	0f bf c2	 movsx	 eax, dx
  0067b	66 8b 04 45 00
	00 00 00	 mov	 ax, WORD PTR _parini[eax*2]
$L71361:

; 115  : 					}
; 116  : 				}
; 117  : 			}
; 118  : 		}
; 119  : 		if (tartemp < -1)

  00683	66 3d ff ff	 cmp	 ax, -1
$L71981:
  00687	7d 10		 jge	 SHORT $L71362

; 120  : 		{
; 121  : 			tartemp = pDph_t->p_diph[-tartemp];

  00689	8b 89 b8 11 00
	00		 mov	 ecx, DWORD PTR [ecx+4536]
  0068f	0f bf c0	 movsx	 eax, ax
  00692	d1 e0		 shl	 eax, 1
  00694	2b c8		 sub	 ecx, eax
  00696	66 8b 01	 mov	 ax, WORD PTR [ecx]
$L71362:

; 122  : 		}
; 123  : 		/* Fricatives have higher F1 if preceeded by a vowel */
; 124  : 		if ((npar == F1 - 1)
; 125  : 			&& ((featb[phone_temp] & FOBST) IS_PLUS)
; 126  : 			&& ((featb[phone_temp] & FSTOP) IS_MINUS)
; 127  : 			&& ((featb[phlas_temp] & FSYLL) IS_PLUS))

  00699	66 85 d2	 test	 dx, dx
  0069c	75 2a		 jne	 SHORT $L71363
  0069e	66 8b 0c 6d 00
	00 00 00	 mov	 cx, WORD PTR _featb[ebp*2]
  006a6	f6 c1 20	 test	 cl, 32			; 00000020H
  006a9	74 1d		 je	 SHORT $L71363
  006ab	81 e1 00 20 00
	00		 and	 ecx, 8192		; 00002000H
  006b1	66 85 c9	 test	 cx, cx
  006b4	75 12		 jne	 SHORT $L71363
  006b6	0f bf 4c 24 24	 movsx	 ecx, WORD PTR _phlas_temp$[esp+28]
  006bb	f6 04 4d 00 00
	00 00 01	 test	 BYTE PTR _featb[ecx*2], 1
  006c3	74 03		 je	 SHORT $L71363

; 128  : 		{
; 129  : 			tartemp += 40;

  006c5	83 c0 28	 add	 eax, 40			; 00000028H
$L71363:

; 130  : 		}
; 131  : 		/* Special rule for B2 of \n/ before non-front vowels */
; 132  : 		if (((phone_temp == N) || (phone_temp == EN))
; 133  : 			&& (npar == B2 - 1))

  006c8	8b 4c 24 28	 mov	 ecx, DWORD PTR _phone_temp$[esp+28]
  006cc	66 83 f9 20	 cmp	 cx, 32			; 00000020H
  006d0	74 06		 je	 SHORT $L71365
  006d2	66 83 f9 24	 cmp	 cx, 36			; 00000024H
  006d6	75 19		 jne	 SHORT $L71366
$L71365:
  006d8	66 83 fa 05	 cmp	 dx, 5
  006dc	75 13		 jne	 SHORT $L71366

; 134  : 		{
; 135  : 			if (begtyp[phnex_temp] != 1)

  006de	0f bf 74 24 10	 movsx	 esi, WORD PTR _phnex_temp$[esp+32]
  006e3	66 83 3c 75 00
	00 00 00 01	 cmp	 WORD PTR _begtyp[esi*2], 1
  006ec	74 03		 je	 SHORT $L71366

; 136  : 			{
; 137  : 				tartemp += 60;

  006ee	83 c0 3c	 add	 eax, 60			; 0000003cH
$L71366:

; 138  : 			}
; 139  : 		}
; 140  : 		/* Special rule for B3 of \n/ adjacent to high-front vowels */
; 141  : 		if (((phone_temp == N) || (phone_temp == EN) || (phone_temp == NX))
; 142  : 			&& (npar == B3 - 1))

  006f1	66 83 f9 20	 cmp	 cx, 32			; 00000020H
  006f5	74 10		 je	 SHORT $L71368
  006f7	66 83 f9 24	 cmp	 cx, 36			; 00000024H
  006fb	74 0a		 je	 SHORT $L71368
  006fd	66 83 f9 21	 cmp	 cx, 33			; 00000021H
  00701	0f 85 82 02 00
	00		 jne	 $L71338
$L71368:
  00707	66 83 fa 06	 cmp	 dx, 6
  0070b	0f 85 78 02 00
	00		 jne	 $L71338

; 143  : 		{
; 144  : 			if (((place[phnex_temp] & F2BACKI) IS_PLUS)
; 145  : 				|| ((place[phlas_temp] & F2BACKF) IS_PLUS))

  00711	0f bf 54 24 10	 movsx	 edx, WORD PTR _phnex_temp$[esp+32]
  00716	f6 04 55 00 00
	00 00 40	 test	 BYTE PTR _place[edx*2], 64 ; 00000040H
  0071e	75 13		 jne	 SHORT $L71370
  00720	0f bf 4c 24 24	 movsx	 ecx, WORD PTR _phlas_temp$[esp+28]
  00725	f6 04 4d 00 00
	00 00 80	 test	 BYTE PTR _place[ecx*2], -128 ; ffffff80H
  0072d	0f 84 56 02 00
	00		 je	 $L71338
$L71370:
  00733	5f		 pop	 edi
  00734	5e		 pop	 esi
  00735	5d		 pop	 ebp

; 146  : 			{
; 147  : 				tartemp = 1600;

  00736	b8 40 06 00 00	 mov	 eax, 1600		; 00000640H
  0073b	5b		 pop	 ebx

; 296  : 				{
; 297  : 					tartemp += 6;
; 298  : 				}
; 299  : 				else
; 300  : 				{
; 301  : 					tartemp += 3;
; 302  : 				}
; 303  : 			}
; 304  : 
; 305  : 		}
; 306  : 	}
; 307  : 	return (tartemp);
; 308  : }

  0073c	83 c4 10	 add	 esp, 16			; 00000010H
  0073f	c3		 ret	 0
$L71351:

; 148  : 			}
; 149  : 		}
; 150  : 	}
; 151  : 	/* 
; 152  : 	 * eab do nasals differently by nasalizing vowel before it and then 
; 153  : 	 * reduce dur on n not vowel in rule 22 context. The code actually nasalizes
; 154  : 	 * anything in front of it 
; 155  : 	 */
; 156  : 	/* GETTAR:  FZ */
; 157  : 	else if (pDphsettar->par_type IS_NASAL_ZERO_FREQ)

  00740	3c 01		 cmp	 al, 1
  00742	75 27		 jne	 SHORT $L71372

; 158  : 	{
; 159  : 		tartemp = 290;				   /* Default for non-nasalized, cancel FP=280 */
; 160  : 		if ((featb[phone_temp] & FNASAL) IS_PLUS)

  00744	0f bf 54 24 28	 movsx	 edx, WORD PTR _phone_temp$[esp+28]
  00749	b8 22 01 00 00	 mov	 eax, 290		; 00000122H
  0074e	f6 04 55 00 00
	00 00 80	 test	 BYTE PTR _featb[edx*2], -128 ; ffffff80H
  00756	74 05		 je	 SHORT $L71373

; 161  : 		{
; 162  : 			tartemp = 400;			   /* Value dur nasal murmur (527=max) */

  00758	b8 90 01 00 00	 mov	 eax, 400		; 00000190H
$L71373:

; 163  : 		}
; 164  : 		pDphsettar->nasvowel = 0;

  0075d	66 c7 46 16 00
	00		 mov	 WORD PTR [esi+22], 0
  00763	5f		 pop	 edi
  00764	5e		 pop	 esi
  00765	5d		 pop	 ebp
  00766	5b		 pop	 ebx

; 296  : 				{
; 297  : 					tartemp += 6;
; 298  : 				}
; 299  : 				else
; 300  : 				{
; 301  : 					tartemp += 3;
; 302  : 				}
; 303  : 			}
; 304  : 
; 305  : 		}
; 306  : 	}
; 307  : 	return (tartemp);
; 308  : }

  00767	83 c4 10	 add	 esp, 16			; 00000010H
  0076a	c3		 ret	 0
$L71372:

; 165  : /* if ((pDphsettar->phonex == N  || pDphsettar->phonex == M) && (phone_temp != R )) { tartemp = 300; pDphsettar->nasvowel=1; }        */
; 166  : 	}
; 167  : 	/* GETTAR:  AV, AP */
; 168  : 	else if (pDphsettar->par_type IS_AV_OR_AH)

  0076b	84 c0		 test	 al, al
  0076d	0f 85 cd 00 00
	00		 jne	 $L71375

; 169  : 	{
; 170  : 		/* Rules for voicing amplitude */
; 171  : 		if (npar == AV - 1)

  00773	66 83 fa 07	 cmp	 dx, 7
  00777	0f 85 95 00 00
	00		 jne	 $L71376

; 172  : 		{
; 173  : 			tartemp = pDph_t->p_tar[phone_temp + pphotr];

  0077d	8b 74 24 28	 mov	 esi, DWORD PTR _phone_temp$[esp+28]
  00781	0f bf d6	 movsx	 edx, si
  00784	0f bf c7	 movsx	 eax, di
  00787	8b b9 bc 11 00
	00		 mov	 edi, DWORD PTR [ecx+4540]
  0078d	03 c2		 add	 eax, edx
  0078f	66 8b 04 47	 mov	 ax, WORD PTR [edi+eax*2]

; 174  : #ifdef SLOWTALK
; 175  : 			/* 5/13/98 EAB The glotal stop in this instance goes all the way to perceived silence
; 176  : 			for some reason it was too strong so I fixed it*/
; 177  : 
; 178  : 			if(pKsd_t->sprate <100)

  00793	8b 7c 24 1c	 mov	 edi, DWORD PTR _pKsd_t$[esp+32]
  00797	66 83 bf 22 02
	00 00 64	 cmp	 WORD PTR [edi+546], 100	; 00000064H
  0079f	7d 09		 jge	 SHORT $L71378

; 179  : 				if (phone_temp == Q)

  007a1	66 83 fe 35	 cmp	 si, 53			; 00000035H
  007a5	75 03		 jne	 SHORT $L71378

; 180  : 					tartemp -=30;

  007a7	83 e8 1e	 sub	 eax, 30			; 0000001eH
$L71378:

; 181  : #endif
; 182  : 			/* Dummy vowel has less intensity */
; 183  : 			if ((pDph_t->allofeats[nphone_temp] & FDUMMY_VOWEL) IS_PLUS)

  007aa	8b 8c 99 70 05
	00 00		 mov	 ecx, DWORD PTR [ecx+ebx*4+1392]
  007b1	f6 c5 08	 test	 ch, 8
  007b4	74 03		 je	 SHORT $L71379

; 184  : 			{
; 185  : 				tartemp -= 7;

  007b6	83 e8 07	 sub	 eax, 7
$L71379:

; 186  : 			}
; 187  : 			/* Voiced stop devoiced if preceding seg voiceless */
; 188  : 			if (((featb[phone_temp] & FPLOSV) IS_PLUS)
; 189  : 				&& ((featb[phlas_temp] & FVOICD) IS_MINUS))

  007b9	f6 04 55 00 00
	00 00 40	 test	 BYTE PTR _featb[edx*2], 64 ; 00000040H
  007c1	74 11		 je	 SHORT $L71380
  007c3	0f bf 54 24 24	 movsx	 edx, WORD PTR _phlas_temp$[esp+28]
  007c8	f6 04 55 00 00
	00 00 02	 test	 BYTE PTR _featb[edx*2], 2
  007d0	75 02		 jne	 SHORT $L71380

; 190  : 			{
; 191  : 				tartemp = 0;

  007d2	33 c0		 xor	 eax, eax
$L71380:

; 192  : 			}
; 193  : 			/* Voice [h] if unstressed and preceeded by voiced seg */
; 194  : 			if ((phone_temp == HX)
; 195  : 				&& ((featb[phlas_temp] & FVOICD) IS_PLUS)
; 196  : 				&& ((pDph_t->allofeats[nphone_temp] & FSTRESS_1) IS_MINUS))

  007d4	66 83 fe 1c	 cmp	 si, 28			; 0000001cH
  007d8	75 19		 jne	 SHORT $L71381
  007da	0f bf 54 24 24	 movsx	 edx, WORD PTR _phlas_temp$[esp+28]
  007df	f6 04 55 00 00
	00 00 02	 test	 BYTE PTR _featb[edx*2], 2
  007e7	74 0a		 je	 SHORT $L71381
  007e9	f6 c1 01	 test	 cl, 1
  007ec	75 05		 jne	 SHORT $L71381

; 197  : 			{
; 198  : 				tartemp = 54;

  007ee	b8 36 00 00 00	 mov	 eax, 54			; 00000036H
$L71381:

; 199  : 			}
; 200  : 
; 201  : 			/* Reduce amplitudes if unstressed 4/4/98 Found another problem the original code was in the wrong 
; 202  : 			place so it effected both aspiration and av and in the right circumstances could cause problems
; 203  : 			this needs to be shecked in all the langauges*/
; 204  : 				/* Reduce amplitudes if unstressed */
; 205  : 		/*	eab 2/96 This only handles stressted unstress and doesn't
; 206  : 			accomadate other stress levels today*/
; 207  : 		if ((pDph_t->allofeats[nphone_temp] & FSTRESS) IS_MINUS)

  007f3	f6 c1 03	 test	 cl, 3
  007f6	0f 85 8d 01 00
	00		 jne	 $L71338

; 208  : 		{
; 209  : 			tartemp -= 4;

  007fc	83 e8 04	 sub	 eax, 4

; 210  : 			if (tartemp < 0)

  007ff	66 85 c0	 test	 ax, ax
  00802	0f 8d 81 01 00
	00		 jge	 $L71338
$L71385:
  00808	5f		 pop	 edi
  00809	5e		 pop	 esi
  0080a	5d		 pop	 ebp

; 211  : 				tartemp = 0;

  0080b	33 c0		 xor	 eax, eax
  0080d	5b		 pop	 ebx

; 296  : 				{
; 297  : 					tartemp += 6;
; 298  : 				}
; 299  : 				else
; 300  : 				{
; 301  : 					tartemp += 3;
; 302  : 				}
; 303  : 			}
; 304  : 
; 305  : 		}
; 306  : 	}
; 307  : 	return (tartemp);
; 308  : }

  0080e	83 c4 10	 add	 esp, 16			; 00000010H
  00811	c3		 ret	 0
$L71376:

; 212  : 		}
; 213  : 		}
; 214  : 		/* Rules for aspiration amplitude */
; 215  : 		else
; 216  : 		{
; 217  : 			if (phone_temp == HX)

  00812	66 83 7c 24 28
	1c		 cmp	 WORD PTR _phone_temp$[esp+28], 28 ; 0000001cH
  00818	75 ee		 jne	 SHORT $L71385

; 218  : 			{
; 219  : 				tartemp = 53;
; 220  : 				if (begtyp[phnex_temp] != 1)

  0081a	0f bf 4c 24 10	 movsx	 ecx, WORD PTR _phnex_temp$[esp+32]
  0081f	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  00824	66 83 3c 4d 00
	00 00 00 01	 cmp	 WORD PTR _begtyp[ecx*2], 1
  0082d	0f 84 56 01 00
	00		 je	 $L71338
  00833	5f		 pop	 edi
  00834	5e		 pop	 esi
  00835	5d		 pop	 ebp

; 221  : 				{
; 222  : 					tartemp = 60;	   /* Stronger asp before +back */

  00836	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
  0083b	5b		 pop	 ebx

; 296  : 				{
; 297  : 					tartemp += 6;
; 298  : 				}
; 299  : 				else
; 300  : 				{
; 301  : 					tartemp += 3;
; 302  : 				}
; 303  : 			}
; 304  : 
; 305  : 		}
; 306  : 	}
; 307  : 	return (tartemp);
; 308  : }

  0083c	83 c4 10	 add	 esp, 16			; 00000010H
  0083f	c3		 ret	 0
$L71375:

; 223  : 				}
; 224  : 			}
; 225  : 			else
; 226  : 			{
; 227  : 				tartemp = 0;
; 228  : 			}
; 229  : 		}
; 230  : 	
; 231  : 	}
; 232  : 	/* GETTAR:  A2, A3, A4, A5, A6, AB */
; 233  : 	else if (pDphsettar->par_type IS_PARALLEL_FORM_AMP)

  00840	3c 02		 cmp	 al, 2
  00842	0f 85 3d 01 00
	00		 jne	 $L71966

; 234  : 	{
; 235  : 		/* If ptram >0, it is a pointer in obstruent array taram */
; 236  : 		if ((pDphsettar->np != &PTILT) && ((tartemp = ptram[phone_temp]) > 0))

  00848	8d b9 40 02 00
	00		 lea	 edi, DWORD PTR [ecx+576]
  0084e	3b ef		 cmp	 ebp, edi
  00850	74 74		 je	 SHORT $L71965
  00852	0f bf 54 24 28	 movsx	 edx, WORD PTR _phone_temp$[esp+28]
  00857	66 8b 04 55 00
	00 00 00	 mov	 ax, WORD PTR _ptram[edx*2]
  0085f	66 85 c0	 test	 ax, ax
  00862	7e 66		 jle	 SHORT $L71394

; 237  : 		{
; 238  : 			begtypnex = begtyp[phnex_temp] - 1;

  00864	8b 54 24 10	 mov	 edx, DWORD PTR _phnex_temp$[esp+32]
  00868	0f bf f2	 movsx	 esi, dx
  0086b	66 8b 34 75 00
	00 00 00	 mov	 si, WORD PTR _begtyp[esi*2]
  00873	66 4e		 dec	 si

; 239  : 			if (phnex_temp == SIL)

  00875	66 85 d2	 test	 dx, dx
  00878	75 0f		 jne	 SHORT $L71391

; 240  : 				begtypnex = endtyp[phlas_temp] - 1;

  0087a	0f bf 54 24 24	 movsx	 edx, WORD PTR _phlas_temp$[esp+28]
  0087f	66 8b 34 55 00
	00 00 00	 mov	 si, WORD PTR _endtyp[edx*2]
  00887	66 4e		 dec	 si
$L71391:

; 241  : 			if (begtypnex == 4)

  00889	66 83 fe 04	 cmp	 si, 4
  0088d	75 05		 jne	 SHORT $L71392

; 242  : 				begtypnex = 2;

  0088f	be 02 00 00 00	 mov	 esi, 2
$L71392:

; 243  : 
; 244  : 			tartemp += (npar - A2 + 1 + (6 * begtypnex));

  00894	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]

; 245  : 			tartemp = pDph_t->p_amp[tartemp];

  00897	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  0089a	8b 54 24 14	 mov	 edx, DWORD PTR _npar$[esp+32]
  0089e	8d 44 10 f7	 lea	 eax, DWORD PTR [eax+edx-9]
  008a2	0f bf d0	 movsx	 edx, ax
  008a5	8b 81 c0 11 00
	00		 mov	 eax, DWORD PTR [ecx+4544]
  008ab	66 8b 04 50	 mov	 ax, WORD PTR [eax+edx*2]

; 246  : 
; 247  : 			/* Burst has less intensity if dummy vowel next */
; 248  : 			if ((pDph_t->allofeats[nphone_temp + 1] & FDUMMY_VOWEL) IS_PLUS)

  008af	8b 94 99 74 05
	00 00		 mov	 edx, DWORD PTR [ecx+ebx*4+1396]
  008b6	f6 c6 08	 test	 dh, 8
  008b9	74 0f		 je	 SHORT $L71394

; 249  : 			{
; 250  : 				if (tartemp >= 4)

  008bb	66 3d 04 00	 cmp	 ax, 4
  008bf	7c 09		 jl	 SHORT $L71394

; 251  : 				{
; 252  : 					tartemp -= 4;

  008c1	83 e8 04	 sub	 eax, 4
  008c4	eb 04		 jmp	 SHORT $L71394
$L71965:
  008c6	8b 44 24 28	 mov	 eax, DWORD PTR _tartemp$[esp+28]
$L71394:

; 253  : 				}
; 254  : 			}
; 255  : 		}
; 256  : 		/* GETTAR:  TLT */
; 257  : 
; 258  : 		/* Source spectral tilt: highly tilted for obstruents */
; 259  : 		/* (Voiced obstruents are special case, set F1=0 to signal voicebar) */
; 260  : 		if (pDphsettar->np == &PTILT)

  008ca	3b ef		 cmp	 ebp, edi
  008cc	0f 85 b7 00 00
	00		 jne	 $L71338

; 261  : 		{
; 262  : 			tartemp = 0;
; 263  : 			if (phone_temp == SIL)

  008d2	8b 54 24 28	 mov	 edx, DWORD PTR _phone_temp$[esp+28]
  008d6	33 c0		 xor	 eax, eax
  008d8	66 85 d2	 test	 dx, dx
  008db	75 19		 jne	 SHORT $L71396
$L71397:

; 271  : 			}
; 272  : 
; 273  : 			else if ((pDph_t->allofeats[nphone_temp] & FDUMMY_VOWEL) IS_PLUS)

  008dd	8b 94 99 70 05
	00 00		 mov	 edx, DWORD PTR [ecx+ebx*4+1392]
  008e4	f6 c6 08	 test	 dh, 8
  008e7	74 20		 je	 SHORT $L71399
  008e9	5f		 pop	 edi
  008ea	5e		 pop	 esi
  008eb	5d		 pop	 ebp

; 274  : 			{
; 275  : 				tartemp = 20;

  008ec	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  008f1	5b		 pop	 ebx

; 296  : 				{
; 297  : 					tartemp += 6;
; 298  : 				}
; 299  : 				else
; 300  : 				{
; 301  : 					tartemp += 3;
; 302  : 				}
; 303  : 			}
; 304  : 
; 305  : 		}
; 306  : 	}
; 307  : 	return (tartemp);
; 308  : }

  008f2	83 c4 10	 add	 esp, 16			; 00000010H
  008f5	c3		 ret	 0
$L71396:

; 264  : 			{
; 265  : 				tartemp = 0;
; 266  : 			}
; 267  : 			/* eab hx energy too high at high frequency try controling with tilt */
; 268  : 			if (phone_temp == HX)

  008f6	66 83 fa 1c	 cmp	 dx, 28			; 0000001cH
  008fa	75 e1		 jne	 SHORT $L71397
  008fc	5f		 pop	 edi
  008fd	5e		 pop	 esi
  008fe	5d		 pop	 ebp

; 269  : 			{
; 270  : 				tartemp = 20;

  008ff	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00904	5b		 pop	 ebx

; 296  : 				{
; 297  : 					tartemp += 6;
; 298  : 				}
; 299  : 				else
; 300  : 				{
; 301  : 					tartemp += 3;
; 302  : 				}
; 303  : 			}
; 304  : 
; 305  : 		}
; 306  : 	}
; 307  : 	return (tartemp);
; 308  : }

  00905	83 c4 10	 add	 esp, 16			; 00000010H
  00908	c3		 ret	 0
$L71399:

; 276  : 			}
; 277  : 			else if ((featb[phone_temp] & FOBST) IS_PLUS)

  00909	0f bf 74 24 28	 movsx	 esi, WORD PTR _phone_temp$[esp+28]
  0090e	d1 e6		 shl	 esi, 1
  00910	66 8b 96 00 00
	00 00		 mov	 dx, WORD PTR _featb[esi]
  00917	f6 c2 20	 test	 dl, 32			; 00000020H
  0091a	74 27		 je	 SHORT $L71401

; 278  : 			{
; 279  : 				tartemp = 7;
; 280  : 				if (((featb[phone_temp] & FVOICD) IS_PLUS)
; 281  : 					&& (((featb[phone_temp] & FPLOSV) IS_PLUS)
; 282  : 						|| (pDphsettar->phcur == JH)))

  0091c	f6 c2 02	 test	 dl, 2
  0091f	b8 07 00 00 00	 mov	 eax, 7
  00924	74 63		 je	 SHORT $L71338
  00926	f6 c2 40	 test	 dl, 64			; 00000040H
  00929	75 0b		 jne	 SHORT $L71403
  0092b	8b 4c 24 18	 mov	 ecx, DWORD PTR _pDphsettar$[esp+32]
  0092f	66 83 79 18 37	 cmp	 WORD PTR [ecx+24], 55	; 00000037H
  00934	75 53		 jne	 SHORT $L71338
$L71403:
  00936	5f		 pop	 edi
  00937	5e		 pop	 esi
  00938	5d		 pop	 ebp

; 283  : 				{
; 284  : 					tartemp = 40;	   /* Max tilt for [b,d,g] */

  00939	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  0093e	5b		 pop	 ebx

; 296  : 				{
; 297  : 					tartemp += 6;
; 298  : 				}
; 299  : 				else
; 300  : 				{
; 301  : 					tartemp += 3;
; 302  : 				}
; 303  : 			}
; 304  : 
; 305  : 		}
; 306  : 	}
; 307  : 	return (tartemp);
; 308  : }

  0093f	83 c4 10	 add	 esp, 16			; 00000010H
  00942	c3		 ret	 0
$L71401:

; 285  : 				}
; 286  : 			}
; 287  : 			else if ((featb[phone_temp] & FNASAL) IS_PLUS)

  00943	f6 c2 80	 test	 dl, -128		; ffffff80H
  00946	74 0d		 je	 SHORT $L71405
  00948	5f		 pop	 edi
  00949	5e		 pop	 esi
  0094a	5d		 pop	 ebp

; 288  : 			{
; 289  : 				tartemp = 6;		   /* Tilt down nasal murmurs */

  0094b	b8 06 00 00 00	 mov	 eax, 6
  00950	5b		 pop	 ebx

; 296  : 				{
; 297  : 					tartemp += 6;
; 298  : 				}
; 299  : 				else
; 300  : 				{
; 301  : 					tartemp += 3;
; 302  : 				}
; 303  : 			}
; 304  : 
; 305  : 		}
; 306  : 	}
; 307  : 	return (tartemp);
; 308  : }

  00951	83 c4 10	 add	 esp, 16			; 00000010H
  00954	c3		 ret	 0
$L71405:

; 290  : 			}
; 291  : 
; 292  : 			/* Female front vowels should be tilted down slightly */
; 293  : 			else if ((begtyp[phone_temp] == 1) || (endtyp[phone_temp] == 1))

  00955	ba 01 00 00 00	 mov	 edx, 1
  0095a	66 39 96 00 00
	00 00		 cmp	 WORD PTR _begtyp[esi], dx
  00961	74 09		 je	 SHORT $L71408
  00963	66 39 96 00 00
	00 00		 cmp	 WORD PTR _endtyp[esi], dx
  0096a	75 1d		 jne	 SHORT $L71338
$L71408:

; 294  : 			{
; 295  : 				if (pDph_t->malfem == FEMALE)

  0096c	66 8b 81 b0 11
	00 00		 mov	 ax, WORD PTR [ecx+4528]
  00973	5f		 pop	 edi
  00974	66 f7 d8	 neg	 ax
  00977	1b c0		 sbb	 eax, eax
  00979	5e		 pop	 esi
  0097a	24 fd		 and	 al, -3			; fffffffdH
  0097c	5d		 pop	 ebp
  0097d	83 c0 06	 add	 eax, 6
  00980	5b		 pop	 ebx

; 296  : 				{
; 297  : 					tartemp += 6;
; 298  : 				}
; 299  : 				else
; 300  : 				{
; 301  : 					tartemp += 3;
; 302  : 				}
; 303  : 			}
; 304  : 
; 305  : 		}
; 306  : 	}
; 307  : 	return (tartemp);
; 308  : }

  00981	83 c4 10	 add	 esp, 16			; 00000010H
  00984	c3		 ret	 0
$L71966:

; 294  : 			{
; 295  : 				if (pDph_t->malfem == FEMALE)

  00985	8b 44 24 28	 mov	 eax, DWORD PTR _tartemp$[esp+28]
$L71338:
  00989	5f		 pop	 edi
  0098a	5e		 pop	 esi
  0098b	5d		 pop	 ebp
  0098c	5b		 pop	 ebx

; 296  : 				{
; 297  : 					tartemp += 6;
; 298  : 				}
; 299  : 				else
; 300  : 				{
; 301  : 					tartemp += 3;
; 302  : 				}
; 303  : 			}
; 304  : 
; 305  : 		}
; 306  : 	}
; 307  : 	return (tartemp);
; 308  : }

  0098d	83 c4 10	 add	 esp, 16			; 00000010H
  00990	c3		 ret	 0
_gettar	ENDP
_phTTS$ = 8
_shrif$ = 12
_pholas$ = 16
_fealas$ = 20
_feacur$ = 24
_struclas$ = 28
_feanex$ = 36
_forw_smooth_rules PROC NEAR

; 443  : {

  009a0	53		 push	 ebx

; 444  : 	short                   temp;	   /* MVP MI : This variable is made local */
; 445  : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  009a1	8b 5c 24 08	 mov	 ebx, DWORD PTR _phTTS$[esp]
  009a5	55		 push	 ebp
  009a6	56		 push	 esi
  009a7	57		 push	 edi
  009a8	8b 7b 18	 mov	 edi, DWORD PTR [ebx+24]

; 446  : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 447  : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;
; 448  : 
; 449  : 	//debugforward ("Set default", pDphsettar->np);
; 450  : 	/* FORWARD SMOOTH: F1, F2, F3 */
; 451  : 	if (pDphsettar->par_type IS_FORM_FREQ)

  009ab	bd 03 00 00 00	 mov	 ebp, 3
  009b0	8b b7 48 28 00
	00		 mov	 esi, DWORD PTR [edi+10312]
  009b6	8a 46 14	 mov	 al, BYTE PTR [esi+20]
  009b9	3c 03		 cmp	 al, 3
  009bb	0f 85 5b 02 00
	00		 jne	 $L71474

; 452  : 	{
; 453  : 		/* 0. Use default values for obst-obst transition */
; 454  : 		if ((feacur & FSONOR) IS_PLUS)

  009c1	8b 44 24 24	 mov	 eax, DWORD PTR _feacur$[esp+12]
  009c5	66 8b 54 24 1c	 mov	 dx, WORD PTR _pholas$[esp+12]
  009ca	a8 10		 test	 al, 16			; 00000010H
  009cc	bd 05 00 00 00	 mov	 ebp, 5
  009d1	0f 84 96 00 00
	00		 je	 $L71484

; 455  : 		{
; 456  : 			if ((feacur & FSONCON) IS_MINUS)

  009d7	25 00 02 00 00	 and	 eax, 512		; 00000200H
  009dc	66 85 c0	 test	 ax, ax
  009df	75 69		 jne	 SHORT $L71476

; 457  : 			{
; 458  : 				pDphsettar->durtran = NF45MS;
; 459  : 				if ((fealas & FSONCON) IS_PLUS)

  009e1	8b 44 24 20	 mov	 eax, DWORD PTR _fealas$[esp+12]
  009e5	66 c7 46 06 07
	00		 mov	 WORD PTR [esi+6], 7
  009eb	25 00 02 00 00	 and	 eax, 512		; 00000200H
  009f0	66 85 c0	 test	 ax, ax
  009f3	74 3b		 je	 SHORT $L71477

; 460  : 				{
; 461  : 					/* 1. Soncon-vowel transition, use 25-75% rule */
; 462  : 					pDphsettar->bouval = (pDphsettar->bouval + pDphsettar->np->tarlas) >> 1;

  009f5	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  009f8	0f bf 2e	 movsx	 ebp, WORD PTR [esi]
  009fb	0f bf 41 18	 movsx	 eax, WORD PTR [ecx+24]
  009ff	03 c5		 add	 eax, ebp
  00a01	d1 f8		 sar	 eax, 1

; 463  : 					/* Make F1 discontinuous for light /l/ */
; 464  : 					if ((pholas == LL) && (pDphsettar->np == &PF1))

  00a03	66 83 fa 1b	 cmp	 dx, 27			; 0000001bH
  00a07	66 89 06	 mov	 WORD PTR [esi], ax
  00a0a	75 0f		 jne	 SHORT $L71478
  00a0c	8d 57 24	 lea	 edx, DWORD PTR [edi+36]
  00a0f	3b ca		 cmp	 ecx, edx
  00a11	75 5a		 jne	 SHORT $L71484

; 465  : 					{
; 466  : 						pDphsettar->bouval += 80;

  00a13	83 c0 50	 add	 eax, 80			; 00000050H
  00a16	66 89 06	 mov	 WORD PTR [esi], ax

; 467  : 					}
; 468  : 					/* Make F3 & F2 transitions slower out of /r/ */
; 469  : 					if ((pholas == R) && (pDphsettar->np != &PF1))

  00a19	eb 52		 jmp	 SHORT $L71484
$L71478:
  00a1b	66 83 fa 1a	 cmp	 dx, 26			; 0000001aH
  00a1f	75 4c		 jne	 SHORT $L71484
  00a21	8d 47 24	 lea	 eax, DWORD PTR [edi+36]
  00a24	3b c8		 cmp	 ecx, eax
  00a26	74 45		 je	 SHORT $L71484

; 470  : 					{
; 471  : 						pDphsettar->durtran = NF70MS;

  00a28	66 c7 46 06 0b
	00		 mov	 WORD PTR [esi+6], 11	; 0000000bH

; 472  : 					}
; 473  : 				}
; 474  : 				else

  00a2e	eb 3d		 jmp	 SHORT $L71484
$L71477:

; 475  : 				{
; 476  : 					/* 2. Vowel-[vowel/h] transition */
; 477  : 					/* Preceeding seg has strong influence on [h] init val */
; 478  : 					if (pDphsettar->phcur == HX)

  00a30	66 83 7e 18 1c	 cmp	 WORD PTR [esi+24], 28	; 0000001cH
  00a35	75 36		 jne	 SHORT $L71484

; 479  : 					{
; 480  : 						pDphsettar->bouval = (pDphsettar->bouval + pDphsettar->np->tarlas) >> 1;

  00a37	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00a3a	0f bf 06	 movsx	 eax, WORD PTR [esi]
  00a3d	0f bf 51 18	 movsx	 edx, WORD PTR [ecx+24]
  00a41	03 d0		 add	 edx, eax
  00a43	d1 fa		 sar	 edx, 1
  00a45	66 89 16	 mov	 WORD PTR [esi], dx

; 481  : 					}
; 482  : 				}
; 483  : 			}
; 484  : 			else

  00a48	eb 23		 jmp	 SHORT $L71484
$L71476:

; 485  : 			{
; 486  : 				/* Phcur is a sonorant conson */
; 487  : 				if ((fealas & FSONCON) IS_MINUS)

  00a4a	8b 4c 24 20	 mov	 ecx, DWORD PTR _fealas$[esp+12]
  00a4e	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00a54	66 85 c9	 test	 cx, cx
  00a57	75 10		 jne	 SHORT $L71483

; 488  : 				{
; 489  : 					/* 3. Vowel-soncon trans, use 75-25% rule */
; 490  : 					pDphsettar->bouval = (pDphsettar->bouval + pDphsettar->np->tarcur) >> 1;

  00a59	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00a5c	0f bf 0e	 movsx	 ecx, WORD PTR [esi]
  00a5f	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00a62	03 c1		 add	 eax, ecx
  00a64	d1 f8		 sar	 eax, 1
  00a66	66 89 06	 mov	 WORD PTR [esi], ax
$L71483:

; 491  : 					pDphsettar->durtran = NF30MS;
; 492  : 				}
; 493  : 				else
; 494  : 				{
; 495  : 					/* 4. Soncon-soncon transition */
; 496  : 					pDphsettar->durtran = NF30MS;

  00a69	66 89 6e 06	 mov	 WORD PTR [esi+6], bp
$L71484:

; 497  : 				}
; 498  : 			}
; 499  : 		}
; 500  : 		/* Bound value = previous target if current phone is sil */
; 501  : 		/* eab not if it's the first sil EAB 4/apr/95 I've fixed this once before */
; 502  : 		if (pDphsettar->phcur == SIL)

  00a6d	66 83 7e 18 00	 cmp	 WORD PTR [esi+24], 0
  00a72	75 3e		 jne	 SHORT $L71485

; 503  : 		{
; 504  : 			/*Eab 7/31/96 changed > 2 to >1 for ending sil*/
; 505  : 			if (pDph_t->nphone > 1)

  00a74	66 83 bf 1c 20
	00 00 01	 cmp	 WORD PTR [edi+8220], 1
  00a7c	7e 1a		 jle	 SHORT $L71486

; 506  : 			{
; 507  : 				pDphsettar->bouval = pDphsettar->np->tarlas;

  00a7e	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00a81	66 8b 42 18	 mov	 ax, WORD PTR [edx+24]
  00a85	66 89 06	 mov	 WORD PTR [esi], ax

; 512  : 			}
; 513  :             pDphsettar->durtran = pDph_t->durfon;

  00a88	66 8b 87 ac 11
	00 00		 mov	 ax, WORD PTR [edi+4524]
  00a8f	66 89 46 06	 mov	 WORD PTR [esi+6], ax

; 514  : 		}
; 515  : 		else

  00a93	e9 2b 01 00 00	 jmp	 $L71506
$L71486:

; 508  : 			}
; 509  : 			else
; 510  : 			{
; 511  : 				pDphsettar->bouval = pDphsettar->np->tarnex;

  00a98	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00a9b	66 8b 51 16	 mov	 dx, WORD PTR [ecx+22]
  00a9f	66 89 16	 mov	 WORD PTR [esi], dx

; 512  : 			}
; 513  :             pDphsettar->durtran = pDph_t->durfon;

  00aa2	66 8b 87 ac 11
	00 00		 mov	 ax, WORD PTR [edi+4524]
  00aa9	66 89 46 06	 mov	 WORD PTR [esi+6], ax

; 514  : 		}
; 515  : 		else

  00aad	e9 11 01 00 00	 jmp	 $L71506
$L71485:

; 516  : 		{
; 517  : 			/* 5. pholas=obst, pDphsettar->phcur=sonor transition */
; 518  : 			if (setloc (phTTS, pDph_t->nphone - 1, pDph_t->nphone, 'i', pDph_t->nphone - 2, feanex))

  00ab2	66 8b 87 1c 20
	00 00		 mov	 ax, WORD PTR [edi+8220]
  00ab9	8b 6c 24 30	 mov	 ebp, DWORD PTR _feanex$[esp+12]
  00abd	55		 push	 ebp
  00abe	8d 48 fe	 lea	 ecx, DWORD PTR [eax-2]
  00ac1	51		 push	 ecx
  00ac2	6a 69		 push	 105			; 00000069H
  00ac4	50		 push	 eax
  00ac5	48		 dec	 eax
  00ac6	50		 push	 eax
  00ac7	53		 push	 ebx
  00ac8	e8 00 00 00 00	 call	 _setloc

; 519  : 			{
; 520  : 				//debugforward (" Use locus,percent", pDphsettar->np);
; 521  : 			}
; 522  : 			/* 6. pholas=sonor, pDphsettar->phcur=obst transition */
; 523  : 			if (setloc (phTTS, pDph_t->nphone, pDph_t->nphone - 1, 'f', pDph_t->nphone + 1,feanex))

  00acd	66 8b 87 1c 20
	00 00		 mov	 ax, WORD PTR [edi+8220]
  00ad4	55		 push	 ebp
  00ad5	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00ad8	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00adb	52		 push	 edx
  00adc	6a 66		 push	 102			; 00000066H
  00ade	51		 push	 ecx
  00adf	50		 push	 eax
  00ae0	53		 push	 ebx
  00ae1	e8 00 00 00 00	 call	 _setloc

; 524  : 			{
; 525  : 				//debugforward (" Use locus,percent", pDphsettar->np);
; 526  : 			}
; 527  : 			/* Dummy vowel for final plosive release into silence is too */
; 528  : 			/* short for an extensive formant transition, make tran less */
; 529  : 			if ((struccur & FDUMMY_VOWEL) IS_PLUS)
; 530  : 			{
; 531  : 				/* OUT                      xx += ((pDphsettar->bouval - pDphsettar->np->tarend) >> 1); pDphsettar->np->tarend += xx;   (DOESN'T
; 532  : 				 * WORK) END OUT */
; 533  : 			}
; 534  : 			/* F1 raised at onset of voiceless plosive release */
; 535  : 			if (((fealas & FPLOSV) IS_PLUS)
; 536  : 				&& ((fealas & FVOICD) IS_MINUS))

  00ae6	8a 44 24 50	 mov	 al, BYTE PTR _fealas$[esp+60]
  00aea	83 c4 30	 add	 esp, 48			; 00000030H
  00aed	a8 40		 test	 al, 64			; 00000040H
  00aef	74 12		 je	 SHORT $L71493
  00af1	a8 02		 test	 al, 2
  00af3	75 0e		 jne	 SHORT $L71493

; 537  : 			{
; 538  : 				if (pDphsettar->np == &PF1)

  00af5	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00af8	8d 57 24	 lea	 edx, DWORD PTR [edi+36]
  00afb	3b c2		 cmp	 eax, edx
  00afd	75 04		 jne	 SHORT $L71493

; 539  : 					pDphsettar->bouval += 100;

  00aff	66 83 06 64	 add	 WORD PTR [esi], 100	; 00000064H
$L71493:

; 540  : 			}
; 541  : 			/* Transitions modified inside obstruents */
; 542  : 			if ((feacur & FOBST) IS_PLUS)

  00b03	8a 44 24 24	 mov	 al, BYTE PTR _feacur$[esp+12]
  00b07	a8 20		 test	 al, 32			; 00000020H
  00b09	74 25		 je	 SHORT $L71496

; 543  : 			{
; 544  : 				pDphsettar->durtran = NF30MS;
; 545  : 				if (pDphsettar->np == &PF1)

  00b0b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00b0e	8d 4f 24	 lea	 ecx, DWORD PTR [edi+36]
  00b11	3b d1		 cmp	 edx, ecx
  00b13	66 c7 46 06 05
	00		 mov	 WORD PTR [esi+6], 5
  00b19	75 06		 jne	 SHORT $L71495

; 546  : 					pDphsettar->durtran = NF20MS;

  00b1b	66 c7 46 06 03
	00		 mov	 WORD PTR [esi+6], 3
$L71495:

; 547  : 				/* Transitions take all of plosive duration */
; 548  : 				if ((feacur & FPLOSV) IS_PLUS)

  00b21	a8 40		 test	 al, 64			; 00000040H
  00b23	74 0b		 je	 SHORT $L71496

; 549  : 				{
; 550  : 					pDphsettar->durtran = pDph_t->durfon;

  00b25	66 8b 97 ac 11
	00 00		 mov	 dx, WORD PTR [edi+4524]
  00b2c	66 89 56 06	 mov	 WORD PTR [esi+6], dx
$L71496:

; 551  : 				}
; 552  : 			}
; 553  : 			/* Higher formant transitions slow inside a nasal */
; 554  : 			if ((feacur & FNASAL) IS_PLUS)

  00b30	a8 80		 test	 al, -128		; ffffff80H
  00b32	0f 84 8b 00 00
	00		 je	 $L71506

; 555  : 			{
; 556  : 				pDphsettar->durtran = pDph_t->durfon;
; 557  : 				/* Except F1, which jumps to value above FNZRO */
; 558  : 				if (pDphsettar->np == &PF1)

  00b38	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00b3b	66 8b 87 ac 11
	00 00		 mov	 ax, WORD PTR [edi+4524]
  00b42	8d 4f 24	 lea	 ecx, DWORD PTR [edi+36]
  00b45	66 89 46 06	 mov	 WORD PTR [esi+6], ax
  00b49	3b d1		 cmp	 edx, ecx
  00b4b	75 08		 jne	 SHORT $L71498

; 559  : 				{
; 560  : 					pDphsettar->durtran = 0;

  00b4d	66 c7 46 06 00
	00		 mov	 WORD PTR [esi+6], 0

; 561  : 				}
; 562  : 				/* Lower F2 & F3 of [n] nasal murmur after front vowels */
; 563  : 				else if (((pDphsettar->phcur == N) || (pDphsettar->phcur == EN))

  00b53	eb 6e		 jmp	 SHORT $L71506
$L71498:

; 564  : 						 && (endtyp[pholas] == 1))

  00b55	66 8b 4e 18	 mov	 cx, WORD PTR [esi+24]
  00b59	66 83 f9 20	 cmp	 cx, 32			; 00000020H
  00b5d	74 06		 je	 SHORT $L71501
  00b5f	66 83 f9 24	 cmp	 cx, 36			; 00000024H
  00b63	75 3d		 jne	 SHORT $L71500
$L71501:
  00b65	0f bf 44 24 1c	 movsx	 eax, WORD PTR _pholas$[esp+12]
  00b6a	d1 e0		 shl	 eax, 1
  00b6c	66 83 b8 00 00
	00 00 01	 cmp	 WORD PTR _endtyp[eax], 1
  00b74	75 2c		 jne	 SHORT $L71500

; 565  : 				{
; 566  : 					if (pDphsettar->np == &PF2)

  00b76	8d 4f 48	 lea	 ecx, DWORD PTR [edi+72]
  00b79	3b d1		 cmp	 edx, ecx
  00b7b	75 18		 jne	 SHORT $L71503

; 567  : 					{
; 568  : 						pDphsettar->bouval -= 100;

  00b7d	66 83 06 9c	 add	 WORD PTR [esi], -100	; ffffff9cH

; 569  : 						if ((place[pholas] & F2BACKF) IS_PLUS)

  00b81	8a 98 00 00 00
	00		 mov	 bl, BYTE PTR _place[eax]
  00b87	66 8b 0e	 mov	 cx, WORD PTR [esi]
  00b8a	f6 c3 80	 test	 bl, -128		; ffffff80H
  00b8d	74 06		 je	 SHORT $L71503

; 570  : 						{
; 571  : 							pDphsettar->bouval -= 100;

  00b8f	83 c1 9c	 add	 ecx, -100		; ffffff9cH
  00b92	66 89 0e	 mov	 WORD PTR [esi], cx
$L71503:

; 572  : 						}
; 573  : 					}
; 574  : 					if (pDphsettar->np == &PF3)

  00b95	8d 47 6c	 lea	 eax, DWORD PTR [edi+108]
  00b98	3b d0		 cmp	 edx, eax
  00b9a	75 27		 jne	 SHORT $L71506

; 575  : 						pDphsettar->bouval -= 100;;

  00b9c	66 83 06 9c	 add	 WORD PTR [esi], -100	; ffffff9cH

; 576  : 				}
; 577  : 				/* Lower F2 of [m] nasal murmur near [i,e] */
; 578  : 				else if ((pDphsettar->np == &PF2) && (pDphsettar->phcur == M)

  00ba0	eb 21		 jmp	 SHORT $L71506
$L71500:

; 579  : 						 && ((place[pholas] & F2BACKF) IS_PLUS))

  00ba2	8d 47 48	 lea	 eax, DWORD PTR [edi+72]
  00ba5	3b d0		 cmp	 edx, eax
  00ba7	75 1a		 jne	 SHORT $L71506
  00ba9	66 83 f9 1f	 cmp	 cx, 31			; 0000001fH
  00bad	75 14		 jne	 SHORT $L71506
  00baf	0f bf 4c 24 1c	 movsx	 ecx, WORD PTR _pholas$[esp+12]
  00bb4	f6 04 4d 00 00
	00 00 80	 test	 BYTE PTR _place[ecx*2], -128 ; ffffff80H
  00bbc	74 05		 je	 SHORT $L71506

; 580  : 				{
; 581  : 					pDphsettar->bouval -= 150;

  00bbe	66 81 06 6a ff	 add	 WORD PTR [esi], -150	; ffffff6aH
$L71506:

; 582  : 				}
; 583  : 			}
; 584  : 		}
; 585  : 		/* Shrink transition dur inside sonor if sonor short */
; 586  : 		if (((feacur & FOBST) IS_MINUS)
; 587  : 			&& (endtyp[pholas] != OBSTRUENT)   /* Unless prev seg is obst */
; 588  : 			&& (pDphsettar->durtran > 0))

  00bc3	f6 44 24 24 20	 test	 BYTE PTR _feacur$[esp+12], 32 ; 00000020H
  00bc8	0f 85 83 03 00
	00		 jne	 $L71556
  00bce	0f bf 54 24 1c	 movsx	 edx, WORD PTR _pholas$[esp+12]
  00bd3	66 83 3c 55 00
	00 00 00 04	 cmp	 WORD PTR _endtyp[edx*2], 4
  00bdc	0f 84 6f 03 00
	00		 je	 $L71556
  00be2	66 8b 46 06	 mov	 ax, WORD PTR [esi+6]
  00be6	66 85 c0	 test	 ax, ax
  00be9	0f 8e 62 03 00
	00		 jle	 $L71556

; 589  : 		{
; 590  : 			pDph_t->arg1 = pDphsettar->durtran;

  00bef	66 89 87 c4 11
	00 00		 mov	 WORD PTR [edi+4548], ax

; 591  : 			pDph_t->arg2 = shrif;

  00bf6	66 8b 44 24 18	 mov	 ax, WORD PTR _shrif$[esp+12]

; 592  : 			pDphsettar->durtran = mlsh1 (pDph_t->arg1, pDph_t->arg2) + 1;

  00bfb	0f bf 8f c4 11
	00 00		 movsx	 ecx, WORD PTR [edi+4548]
  00c02	0f bf d0	 movsx	 edx, ax
  00c05	0f af ca	 imul	 ecx, edx
  00c08	c1 f9 0e	 sar	 ecx, 14			; 0000000eH
  00c0b	41		 inc	 ecx
  00c0c	66 89 87 c6 11
	00 00		 mov	 WORD PTR [edi+4550], ax
  00c13	66 89 4e 06	 mov	 WORD PTR [esi+6], cx

; 593  : 		}
; 594  : 	}
; 595  : 	/* FORWARD SMOOTH:  FN */
; 596  : 	else if (pDphsettar->par_type IS_NASAL_ZERO_FREQ)

  00c17	e9 35 03 00 00	 jmp	 $L71556
$L71474:
  00c1c	3c 01		 cmp	 al, 1
  00c1e	75 2d		 jne	 SHORT $L71509

; 597  : 	{
; 598  : 		pDphsettar->durtran = 0;
; 599  : 		if (((fealas & FNASAL) IS_PLUS)
; 600  : 			&& ((feacur & FNASAL) IS_MINUS))

  00c20	8a 44 24 20	 mov	 al, BYTE PTR _fealas$[esp+12]
  00c24	66 c7 46 06 00
	00		 mov	 WORD PTR [esi+6], 0
  00c2a	a8 80		 test	 al, -128		; ffffff80H
  00c2c	0f 84 1f 03 00
	00		 je	 $L71556
  00c32	f6 44 24 24 80	 test	 BYTE PTR _feacur$[esp+12], -128 ; ffffff80H
  00c37	0f 85 14 03 00
	00		 jne	 $L71556

; 601  : 		{
; 602  : 			pDphsettar->bouval = 400;

  00c3d	66 c7 06 90 01	 mov	 WORD PTR [esi], 400	; 00000190H

; 603  : 			pDphsettar->durtran = NF80MS;

  00c42	66 c7 46 06 0d
	00		 mov	 WORD PTR [esi+6], 13	; 0000000dH

; 604  : 		}
; 605  : 	}
; 606  : 	/* FORWARD SMOOTH:  B1, B2, B3 */
; 607  : 	else if (pDphsettar->par_type IS_FORM_BW)

  00c48	e9 04 03 00 00	 jmp	 $L71556
$L71509:
  00c4d	3c 04		 cmp	 al, 4
  00c4f	0f 85 60 01 00
	00		 jne	 $L71512

; 608  : 	{
; 609  : 		/* Default transition duration is 40 ms */
; 610  : 		pDphsettar->durtran = NF40MS;
; 611  : 		/* Widen first formant bw if preceeding seg voiceless */
; 612  : 		if ((feacur & FVOICD) IS_PLUS)

  00c55	8a 44 24 24	 mov	 al, BYTE PTR _feacur$[esp+12]
  00c59	66 c7 46 06 06
	00		 mov	 WORD PTR [esi+6], 6
  00c5f	a8 02		 test	 al, 2
  00c61	bb 08 00 00 00	 mov	 ebx, 8
  00c66	74 28		 je	 SHORT $L71513

; 613  : 		{
; 614  : 			if ((pDphsettar->np == &PB1)
; 615  : 				&& ((fealas & FVOICD) IS_MINUS))

  00c68	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00c6b	8d 8f b4 00 00
	00		 lea	 ecx, DWORD PTR [edi+180]
  00c71	3b c1		 cmp	 eax, ecx
  00c73	75 1f		 jne	 SHORT $L71515
  00c75	f6 44 24 20 02	 test	 BYTE PTR _fealas$[esp+12], 2
  00c7a	75 18		 jne	 SHORT $L71515

; 616  : 			{
; 617  : 				pDphsettar->durtran = NF50MS;

  00c7c	66 89 5e 06	 mov	 WORD PTR [esi+6], bx

; 618  : 				/* More increase for low vowels (F1 high) */
; 619  : 				pDphsettar->bouval = pDphsettar->np->tarcur + (PF1.tarcur >> 3);

  00c80	66 8b 57 24	 mov	 dx, WORD PTR [edi+36]
  00c84	66 c1 fa 03	 sar	 dx, 3
  00c88	66 03 10	 add	 dx, WORD PTR [eax]
  00c8b	66 89 16	 mov	 WORD PTR [esi], dx

; 620  : 			}
; 621  : 		}
; 622  : 		else

  00c8e	eb 04		 jmp	 SHORT $L71515
$L71513:

; 623  : 		{                                       
; 624  : 			pDphsettar->durtran = NF20MS;

  00c90	66 89 6e 06	 mov	 WORD PTR [esi+6], bp
$L71515:

; 625  : 		}
; 626  : 		/* Treat boundary with silence */
; 627  : 		if (pholas == SIL)

  00c94	66 83 7c 24 1c
	00		 cmp	 WORD PTR _pholas$[esp+12], 0
  00c9a	75 2f		 jne	 SHORT $L71516

; 628  : 		{
; 629  : 			pDphsettar->bouval = pDphsettar->np->tarcur + ((&PB3 - pDphsettar->np) * 50);

  00c9c	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  00c9f	8b cf		 mov	 ecx, edi
  00ca1	2b cd		 sub	 ecx, ebp
  00ca3	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00ca8	81 c1 fc 00 00
	00		 add	 ecx, 252		; 000000fcH
  00cae	f7 e9		 imul	 ecx
  00cb0	c1 fa 03	 sar	 edx, 3
  00cb3	8b c2		 mov	 eax, edx
  00cb5	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00cb8	03 d0		 add	 edx, eax
  00cba	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  00cbd	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00cc0	d1 e1		 shl	 ecx, 1
  00cc2	66 03 4d 00	 add	 cx, WORD PTR [ebp]
  00cc6	66 89 0e	 mov	 WORD PTR [esi], cx

; 630  : 			pDphsettar->durtran = NF50MS;
; 631  : 		}
; 632  : 		else if (pDphsettar->phcur == SIL)

  00cc9	eb 6b		 jmp	 SHORT $L71519
$L71516:
  00ccb	66 83 7e 18 00	 cmp	 WORD PTR [esi+24], 0
  00cd0	75 68		 jne	 SHORT $L71518

; 633  : 		{
; 634  : 			pDphsettar->bouval = pDphsettar->np->tarlas + ((&PB3 - pDphsettar->np) * 50);

  00cd2	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  00cd5	8b cf		 mov	 ecx, edi
  00cd7	2b cd		 sub	 ecx, ebp
  00cd9	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00cde	81 c1 fc 00 00
	00		 add	 ecx, 252		; 000000fcH
  00ce4	f7 e9		 imul	 ecx
  00ce6	c1 fa 03	 sar	 edx, 3
  00ce9	8b c2		 mov	 eax, edx
  00ceb	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00cee	03 d0		 add	 edx, eax
  00cf0	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  00cf3	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00cf6	d1 e1		 shl	 ecx, 1
  00cf8	66 03 4d 18	 add	 cx, WORD PTR [ebp+24]
  00cfc	66 89 0e	 mov	 WORD PTR [esi], cx

; 635  : 			if (((featb[pDph_t->allophons[pDph_t->nphone - 2]] & FVOICD) IS_MINUS)
; 636  : 				&& ((struclas & FDUMMY_VOWEL) IS_PLUS)
; 637  : 				&& (pDphsettar->np == &PB1))

  00cff	0f bf 97 1c 20
	00 00		 movsx	 edx, WORD PTR [edi+8220]
  00d06	0f bf 84 57 fe
	02 00 00	 movsx	 eax, WORD PTR [edi+edx*2+766]
  00d0e	f6 04 45 00 00
	00 00 02	 test	 BYTE PTR _featb[eax*2], 2
  00d16	75 1e		 jne	 SHORT $L71519
  00d18	8b 4c 24 28	 mov	 ecx, DWORD PTR _struclas$[esp+12]
  00d1c	81 e1 00 08 00
	00		 and	 ecx, 2048		; 00000800H
  00d22	66 85 c9	 test	 cx, cx
  00d25	74 0f		 je	 SHORT $L71519
  00d27	8d 97 b4 00 00
	00		 lea	 edx, DWORD PTR [edi+180]
  00d2d	3b ea		 cmp	 ebp, edx
  00d2f	75 05		 jne	 SHORT $L71519

; 638  : 			{
; 639  : 				pDphsettar->bouval = 260;	/* Kluge to avoid discontinutiy */

  00d31	66 c7 06 04 01	 mov	 WORD PTR [esi], 260	; 00000104H
$L71519:

; 640  : 			}
; 641  : 			pDphsettar->durtran = NF50MS;

  00d36	66 89 5e 06	 mov	 WORD PTR [esi+6], bx
$L71518:

; 642  : 		}
; 643  : 		/* eab narrow b2 somewhat to compensate for volume drop in nasalizing vowel klugy way for now. */
; 644  : 
; 645  : 		if (pDphsettar->nasvowel)

  00d3a	66 83 7e 16 00	 cmp	 WORD PTR [esi+22], 0
  00d3f	74 04		 je	 SHORT $L71520

; 646  : 		{
; 647  : 			pDphsettar->bouval -= 20;

  00d41	66 83 06 ec	 add	 WORD PTR [esi], -20	; ffffffecH
$L71520:

; 648  : 		}
; 649  : 
; 650  : 		/* BW1 widen, to nasalize transition out of previous nasal */
; 651  : 		if ((fealas & FNASAL) IS_PLUS)

  00d45	f6 44 24 20 80	 test	 BYTE PTR _fealas$[esp+12], -128 ; ffffff80H
  00d4a	74 53		 je	 SHORT $L71524

; 652  : 		{
; 653  : 			pDphsettar->bouval = pDphsettar->np->tarcur;	/* B2,B3 not influ by nasal */

  00d4c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 654  : 			/* Except F2 of [n], which is wider in a non-front vowel */
; 655  : 			if ((pDphsettar->np == &PB2) && ((pholas == N) || (pholas == EN))
; 656  : 				&& (begtyp[pDphsettar->phcur] != 1))

  00d4f	8d 97 d8 00 00
	00		 lea	 edx, DWORD PTR [edi+216]
  00d55	3b c2		 cmp	 eax, edx
  00d57	66 8b 08	 mov	 cx, WORD PTR [eax]
  00d5a	66 89 0e	 mov	 WORD PTR [esi], cx
  00d5d	75 2c		 jne	 SHORT $L71522
  00d5f	66 8b 54 24 1c	 mov	 dx, WORD PTR _pholas$[esp+12]
  00d64	66 83 fa 20	 cmp	 dx, 32			; 00000020H
  00d68	74 06		 je	 SHORT $L71523
  00d6a	66 83 fa 24	 cmp	 dx, 36			; 00000024H
  00d6e	75 1b		 jne	 SHORT $L71522
$L71523:
  00d70	0f bf 56 18	 movsx	 edx, WORD PTR [esi+24]
  00d74	66 83 3c 55 00
	00 00 00 01	 cmp	 WORD PTR _begtyp[edx*2], 1
  00d7d	74 0c		 je	 SHORT $L71522

; 657  : 			{
; 658  : 				pDphsettar->bouval += 60;

  00d7f	83 c1 3c	 add	 ecx, 60			; 0000003cH

; 659  : 				pDphsettar->durtran = NF60MS;

  00d82	66 c7 46 06 09
	00		 mov	 WORD PTR [esi+6], 9
  00d88	66 89 0e	 mov	 WORD PTR [esi], cx
$L71522:

; 660  : 			}
; 661  : 			if (pDphsettar->np == &PB1)

  00d8b	8d 8f b4 00 00
	00		 lea	 ecx, DWORD PTR [edi+180]
  00d91	3b c1		 cmp	 eax, ecx
  00d93	75 0a		 jne	 SHORT $L71524

; 662  : 			{
; 663  : 				pDphsettar->durtran = NF100MS;
; 664  : 				pDphsettar->bouval += 70;

  00d95	66 83 06 46	 add	 WORD PTR [esi], 70	; 00000046H
  00d99	66 c7 46 06 10
	00		 mov	 WORD PTR [esi+6], 16	; 00000010H
$L71524:

; 665  : 			}
; 666  : 		}
; 667  : 		/* Nasals have constant bandwidths at target values */
; 668  : 		if ((feacur & FNASAL) IS_PLUS)

  00d9f	f6 44 24 24 80	 test	 BYTE PTR _feacur$[esp+12], -128 ; ffffff80H
  00da4	0f 84 a7 01 00
	00		 je	 $L71556

; 669  : 		{
; 670  : 			pDphsettar->durtran = 0;

  00daa	66 c7 46 06 00
	00		 mov	 WORD PTR [esi+6], 0

; 671  : 			//debugforward (" Nasal has const par val", pDphsettar->np);
; 672  : 		}
; 673  : 	}
; 674  : 	/* FORWARD SMOOTH:  AV, AP, A2, A3, A4, A5, A6, AB */
; 675  : 
; 676  : 	/* Default pDphsettar->bouval is average of tarcur & tarend, default tc is 30 ms */
; 677  : 	else if ((pDphsettar->par_type IS_PARALLEL_FORM_AMP)

  00db0	e9 9c 01 00 00	 jmp	 $L71556
$L71512:

; 678  : 			 || (pDphsettar->par_type IS_AV_OR_AH))

  00db5	3c 02		 cmp	 al, 2
  00db7	74 08		 je	 SHORT $L71528
  00db9	84 c0		 test	 al, al
  00dbb	0f 85 90 01 00
	00		 jne	 $L71556
$L71528:

; 679  : 	{
; 680  : 
; 681  : 		/* See if onset, i.e. plosive or large source intensity increase */
; 682  : 		temp = pDphsettar->np->tarcur - 10;

  00dc1	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]

; 683  : 		if ((pDphsettar->bouval < temp) || ((fealas & FPLOSV) IS_PLUS)
; 684  : 			|| (pholas == JH))

  00dc4	8b 5c 24 24	 mov	 ebx, DWORD PTR _feacur$[esp+12]
  00dc8	8b 54 24 20	 mov	 edx, DWORD PTR _fealas$[esp+12]
  00dcc	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00dcf	66 2d 0a 00	 sub	 ax, 10			; 0000000aH
  00dd3	66 39 06	 cmp	 WORD PTR [esi], ax
  00dd6	7c 0d		 jl	 SHORT $L71530
  00dd8	f6 c2 40	 test	 dl, 64			; 00000040H
  00ddb	75 08		 jne	 SHORT $L71530
  00ddd	66 83 7c 24 1c
	37		 cmp	 WORD PTR _pholas$[esp+12], 55 ; 00000037H
  00de3	75 47		 jne	 SHORT $L71536
$L71530:

; 685  : 		{
; 686  : 			pDphsettar->bouval = temp;
; 687  : 			if ((feacur & FOBST) IS_MINUS)

  00de5	f6 c3 20	 test	 bl, 32			; 00000020H
  00de8	66 89 06	 mov	 WORD PTR [esi], ax
  00deb	75 04		 jne	 SHORT $L71531

; 688  : 				pDphsettar->durtran = NF20MS;

  00ded	66 89 6e 06	 mov	 WORD PTR [esi+6], bp
$L71531:

; 689  : 			/* Voicing is special */
; 690  : 			if (pDphsettar->np == &PAV)

  00df1	8d af 20 01 00
	00		 lea	 ebp, DWORD PTR [edi+288]
  00df7	3b cd		 cmp	 ecx, ebp
  00df9	75 31		 jne	 SHORT $L71536

; 691  : 			{
; 692  : 				/* Gradual buildup of voicing */
; 693  : 				if (pholas == SIL)

  00dfb	66 83 7c 24 1c
	00		 cmp	 WORD PTR _pholas$[esp+12], 0
  00e01	75 0f		 jne	 SHORT $L71534

; 694  : 				{
; 695  : 					if ((feacur & FVOICD) IS_PLUS)

  00e03	f6 c3 02	 test	 bl, 2
  00e06	74 0a		 je	 SHORT $L71534

; 696  : 					{
; 697  : 						pDphsettar->durtran = NF45MS;
; 698  : 						pDphsettar->bouval -= 8;

  00e08	66 83 06 f8	 add	 WORD PTR [esi], -8	; fffffff8H
  00e0c	66 c7 46 06 07
	00		 mov	 WORD PTR [esi+6], 7
$L71534:

; 699  : 					}
; 700  : 				}
; 701  : 				/* Obstruent voicing onset is abrupt */
; 702  : 				if ((fealas & FOBST) IS_PLUS)

  00e12	f6 c2 20	 test	 dl, 32			; 00000020H
  00e15	74 06		 je	 SHORT $L71535

; 703  : 				{
; 704  : 					pDphsettar->bouval = temp + 6;

  00e17	83 c0 06	 add	 eax, 6
  00e1a	66 89 06	 mov	 WORD PTR [esi], ax
$L71535:

; 705  : 				}
; 706  : 				/* Plosive onset is abrupt (used mainly for [bdg]) */
; 707  : 				if ((fealas & FPLOSV) IS_PLUS)

  00e1d	f6 c2 40	 test	 dl, 64			; 00000040H
  00e20	74 0a		 je	 SHORT $L71536

; 708  : 				{
; 709  : 					pDphsettar->bouval = pDphsettar->np->tarcur - 5;

  00e22	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00e25	66 2d 05 00	 sub	 ax, 5
  00e29	66 89 06	 mov	 WORD PTR [esi], ax
$L71536:

; 710  : 				}
; 711  : 			}
; 712  : 			//debugforward (" Onset", pDphsettar->np);
; 713  : 		}
; 714  : 		/* If last nasal, and source amp increased, abrupt onset */
; 715  : 		if (((fealas & FNASAL) IS_PLUS)
; 716  : 			&& ((feacur & FVOICD) IS_PLUS))

  00e2c	f6 c2 80	 test	 dl, -128		; ffffff80H
  00e2f	74 0d		 je	 SHORT $L71992
  00e31	f6 c3 02	 test	 bl, 2
  00e34	74 08		 je	 SHORT $L71992

; 717  : 		{
; 718  : 			pDphsettar->durtran = 0;

  00e36	33 ed		 xor	 ebp, ebp
  00e38	66 89 6e 06	 mov	 WORD PTR [esi+6], bp
  00e3c	eb 02		 jmp	 SHORT $L71537
$L71992:
  00e3e	33 ed		 xor	 ebp, ebp
$L71537:

; 719  : 			//debugforward (" Onset from nasal", pDphsettar->np);
; 720  : 		}
; 721  : 		/* Voicing source amp const in intervocalic nasal */
; 722  : 		if ((feacur & FNASAL) IS_PLUS)

  00e40	f6 c3 80	 test	 bl, -128		; ffffff80H
  00e43	74 13		 je	 SHORT $L71540

; 723  : 		{
; 724  : 			if ((fealas & FVOICD) IS_PLUS)

  00e45	f6 c2 02	 test	 dl, 2
  00e48	74 0e		 je	 SHORT $L71540

; 725  : 			{
; 726  : 				if (pDphsettar->np == &PAV)

  00e4a	8d 87 20 01 00
	00		 lea	 eax, DWORD PTR [edi+288]
  00e50	3b c8		 cmp	 ecx, eax
  00e52	75 04		 jne	 SHORT $L71540

; 727  : 					pDphsettar->durtran = 0;

  00e54	66 89 6e 06	 mov	 WORD PTR [esi+6], bp
$L71540:

; 728  : 			}
; 729  : 		}
; 730  : 		/* See if offset, i.e. source intensity decreasing */
; 731  : 		temp = pDphsettar->np->tarlas - 10;

  00e58	66 8b 41 18	 mov	 ax, WORD PTR [ecx+24]
  00e5c	66 2d 0a 00	 sub	 ax, 10			; 0000000aH

; 732  : 		if (pDphsettar->bouval < temp)

  00e60	66 39 06	 cmp	 WORD PTR [esi], ax
  00e63	7d 20		 jge	 SHORT $L71543

; 733  : 		{
; 734  : 			/* Reduce bounval by 3 dB because bval time is onset */
; 735  : 			/* of next phoneme */
; 736  : 			pDphsettar->bouval = temp - 3;

  00e65	83 c0 fd	 add	 eax, -3			; fffffffdH

; 737  : 			/* Source amplitudes fall gradually into silence */
; 738  : 			if (pDphsettar->phcur == SIL)

  00e68	66 39 6e 18	 cmp	 WORD PTR [esi+24], bp
  00e6c	66 89 06	 mov	 WORD PTR [esi], ax
  00e6f	75 06		 jne	 SHORT $L71542

; 739  : 				pDphsettar->durtran = NF70MS;

  00e71	66 c7 46 06 0b
	00		 mov	 WORD PTR [esi+6], 11	; 0000000bH
$L71542:

; 740  : 			/* Except voicing offset is abrupt */
; 741  : 			if (pDphsettar->np == &PAV)

  00e77	8d 87 20 01 00
	00		 lea	 eax, DWORD PTR [edi+288]
  00e7d	3b c8		 cmp	 ecx, eax
  00e7f	75 04		 jne	 SHORT $L71543

; 742  : 				pDphsettar->durtran = 0;

  00e81	66 89 6e 06	 mov	 WORD PTR [esi+6], bp
$L71543:

; 743  : 			//debugforward (" Offset", pDphsettar->np);
; 744  : 		}
; 745  : 		/* Buildup A3 gradually in [C, J] */
; 746  : 		if (pDphsettar->np == &PA3)

  00e85	8d 87 8c 01 00
	00		 lea	 eax, DWORD PTR [edi+396]
  00e8b	3b c8		 cmp	 ecx, eax
  00e8d	75 29		 jne	 SHORT $L71545

; 747  : 		{
; 748  : 			if ((pDphsettar->phcur == CH) || (pDphsettar->phcur == JH))

  00e8f	66 8b 46 18	 mov	 ax, WORD PTR [esi+24]
  00e93	66 3d 36 00	 cmp	 ax, 54			; 00000036H
  00e97	74 06		 je	 SHORT $L71546
  00e99	66 3d 37 00	 cmp	 ax, 55			; 00000037H
  00e9d	75 19		 jne	 SHORT $L71545
$L71546:

; 749  : 			{
; 750  : 				pDphsettar->durtran = pDph_t->durfon - NF15MS;

  00e9f	66 8b 87 ac 11
	00 00		 mov	 ax, WORD PTR [edi+4524]
  00ea6	66 2d 02 00	 sub	 ax, 2
  00eaa	66 89 46 06	 mov	 WORD PTR [esi+6], ax

; 751  : 				pDphsettar->bouval = pDphsettar->np->tarcur - 30;

  00eae	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00eb1	66 2d 1e 00	 sub	 ax, 30			; 0000001eH
  00eb5	66 89 06	 mov	 WORD PTR [esi], ax
$L71545:

; 752  : 				//debugforward (" CH/JH rule", pDphsettar->np);
; 753  : 			}
; 754  : 		}
; 755  : 		/* Offset of a vowel into voiceless open vocal tract is breathy */
; 756  : 		if (pDphsettar->np == &PAP)

  00eb8	8d 87 44 01 00
	00		 lea	 eax, DWORD PTR [edi+324]
  00ebe	3b c8		 cmp	 ecx, eax
  00ec0	75 48		 jne	 SHORT $L71552

; 757  : 		{
; 758  : 			if ((pDphsettar->phcur == SIL) || (pDphsettar->phcur == F) || (pDphsettar->phcur == TH)
; 759  : 				|| (pDphsettar->phcur == S) || (pDphsettar->phcur == SH))

  00ec2	66 8b 46 18	 mov	 ax, WORD PTR [esi+24]
  00ec6	66 3b c5	 cmp	 ax, bp
  00ec9	74 18		 je	 SHORT $L71549
  00ecb	66 3d 25 00	 cmp	 ax, 37			; 00000025H
  00ecf	74 12		 je	 SHORT $L71549
  00ed1	66 3d 27 00	 cmp	 ax, 39			; 00000027H
  00ed5	74 0c		 je	 SHORT $L71549
  00ed7	66 3d 29 00	 cmp	 ax, 41			; 00000029H
  00edb	74 06		 je	 SHORT $L71549
  00edd	66 3d 2b 00	 cmp	 ax, 43			; 0000002bH
  00ee1	75 27		 jne	 SHORT $L71552
$L71549:

; 760  : 			{
; 761  : 				if (((fealas & FVOICD) IS_PLUS)
; 762  : 					&& ((fealas & FOBST) IS_MINUS))

  00ee3	f6 c2 02	 test	 dl, 2
  00ee6	74 22		 je	 SHORT $L71552
  00ee8	f6 c2 20	 test	 dl, 32			; 00000020H
  00eeb	75 1d		 jne	 SHORT $L71552

; 763  : 				{
; 764  : 					if (pDphsettar->phcur == SIL)

  00eed	66 3b c5	 cmp	 ax, bp
  00ef0	75 0d		 jne	 SHORT $L71551

; 765  : 					{
; 766  : 						pDphsettar->bouval = 52;

  00ef2	66 c7 06 34 00	 mov	 WORD PTR [esi], 52	; 00000034H

; 767  : 						pDphsettar->durtran = NF80MS;

  00ef7	66 c7 46 06 0d
	00		 mov	 WORD PTR [esi+6], 13	; 0000000dH

; 768  : 					}
; 769  : 					else

  00efd	eb 0b		 jmp	 SHORT $L71552
$L71551:

; 770  : 					{
; 771  : 						pDphsettar->bouval = 48;

  00eff	66 c7 06 30 00	 mov	 WORD PTR [esi], 48	; 00000030H

; 772  : 						pDphsettar->durtran = NF45MS;

  00f04	66 c7 46 06 07
	00		 mov	 WORD PTR [esi+6], 7
$L71552:

; 773  : 					}
; 774  : 				}
; 775  : 			}
; 776  : 		}
; 777  : 		/* FORWARD SMOOTH:  TLT */
; 778  : 
; 779  : 		/* Tilt parameter jumps to target values near stops and silence */
; 780  : 		if (pDphsettar->np == &PTILT)

  00f0a	8d 87 40 02 00
	00		 lea	 eax, DWORD PTR [edi+576]
  00f10	3b c8		 cmp	 ecx, eax
  00f12	75 3d		 jne	 SHORT $L71556

; 781  : 		{
; 782  : 			pDphsettar->durtran = NF25MS;
; 783  : 			if (pholas == SIL)

  00f14	66 39 6c 24 1c	 cmp	 WORD PTR _pholas$[esp+12], bp
  00f19	66 c7 46 06 04
	00		 mov	 WORD PTR [esi+6], 4
  00f1f	75 06		 jne	 SHORT $L71554

; 784  : 			{
; 785  : 				pDphsettar->bouval = pDphsettar->np->tarcur;

  00f21	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00f24	66 89 0e	 mov	 WORD PTR [esi], cx
$L71554:

; 786  : 			}
; 787  : 			if (pDphsettar->phcur == SIL)

  00f27	66 39 6e 18	 cmp	 WORD PTR [esi+24], bp
  00f2b	75 0a		 jne	 SHORT $L71555

; 788  : 			{
; 789  : 				/* Reach into par buffer to get actual previous value */
; 790  : 				pDphsettar->bouval = pDph_t->parstochip[OUT_TLT];

  00f2d	66 8b 87 d6 02
	00 00		 mov	 ax, WORD PTR [edi+726]
  00f34	66 89 06	 mov	 WORD PTR [esi], ax
$L71555:

; 791  : 			}
; 792  : 			if (((fealas & FSTOP) IS_PLUS)
; 793  : 				|| ((feacur & FSTOP) IS_PLUS))

  00f37	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  00f3d	66 85 d2	 test	 dx, dx
  00f40	75 0b		 jne	 SHORT $L71557
  00f42	81 e3 00 20 00
	00		 and	 ebx, 8192		; 00002000H
  00f48	66 85 db	 test	 bx, bx
  00f4b	74 04		 je	 SHORT $L71556
$L71557:

; 794  : 			{
; 795  : 				pDphsettar->durtran = 0;

  00f4d	66 89 6e 06	 mov	 WORD PTR [esi+6], bp
$L71556:

; 796  : 			}
; 797  : 		}
; 798  : 	}
; 799  : 	/* Truncate tran dur if exceeds duration of current phone */
; 800  : 	if (pDphsettar->durtran > pDph_t->durfon)

  00f51	66 8b bf ac 11
	00 00		 mov	 di, WORD PTR [edi+4524]
  00f58	66 39 7e 06	 cmp	 WORD PTR [esi+6], di
  00f5c	7e 04		 jle	 SHORT $L71558

; 801  : 		pDphsettar->durtran = pDph_t->durfon;

  00f5e	66 89 7e 06	 mov	 WORD PTR [esi+6], di
$L71558:

; 802  : 	/* Or duration of 20 frames */
; 803  : 	if (pDphsettar->durtran > NF130MS)

  00f62	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00f67	66 39 46 06	 cmp	 WORD PTR [esi+6], ax
  00f6b	7e 04		 jle	 SHORT $L71559

; 804  : 		pDphsettar->durtran = NF130MS;

  00f6d	66 89 46 06	 mov	 WORD PTR [esi+6], ax
$L71559:

; 805  : 	/* Do not allow amplitude value to go below zero */
; 806  : 	if (pDphsettar->bouval < 0)

  00f71	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  00f75	7d 05		 jge	 SHORT $L71560

; 807  : 		pDphsettar->bouval = 0;

  00f77	66 c7 06 00 00	 mov	 WORD PTR [esi], 0
$L71560:
  00f7c	5f		 pop	 edi
  00f7d	5e		 pop	 esi
  00f7e	5d		 pop	 ebp
  00f7f	5b		 pop	 ebx

; 808  : }

  00f80	c3		 ret	 0
_forw_smooth_rules ENDP
_phTTS$ = 8
_shrib$ = 12
_feacur$ = 16
_feanex$ = 20
_strucnex$ = 24
_back_smooth_rules PROC NEAR

; 832  : {

  00f90	53		 push	 ebx
  00f91	55		 push	 ebp

; 833  : 	short                   temp;	   /* MVP MI : This varaible is made local */
; 834  : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  00f92	8b 6c 24 0c	 mov	 ebp, DWORD PTR _phTTS$[esp+4]
  00f96	56		 push	 esi
  00f97	57		 push	 edi
  00f98	8b 5d 18	 mov	 ebx, DWORD PTR [ebp+24]

; 835  : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 836  : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;

  00f9b	8b b3 48 28 00
	00		 mov	 esi, DWORD PTR [ebx+10312]

; 837  : 
; 838  : 	//debugfackward ("Set default", pDphsettar->np);
; 839  : 
; 840  : 	/* BACKWARD SMOOTH:  F1, F2, F3 */
; 841  : 	if (pDphsettar->par_type IS_FORM_FREQ)

  00fa1	8a 46 14	 mov	 al, BYTE PTR [esi+20]
  00fa4	3c 03		 cmp	 al, 3
  00fa6	0f 85 0f 02 00
	00		 jne	 $L71576

; 842  : 	{
; 843  : 		/* 0. Use default values for obst-obst transition */
; 844  : 		if ((feacur & FSONOR) IS_PLUS)

  00fac	8b 44 24 1c	 mov	 eax, DWORD PTR _feacur$[esp+12]
  00fb0	8b 7c 24 20	 mov	 edi, DWORD PTR _feanex$[esp+12]
  00fb4	a8 10		 test	 al, 16			; 00000010H
  00fb6	0f 84 91 00 00
	00		 je	 $L71585

; 845  : 		{
; 846  : 			pDphsettar->durtran = NF45MS;
; 847  : 			if ((feacur & FSONCON) IS_MINUS)

  00fbc	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00fc1	66 c7 46 06 07
	00		 mov	 WORD PTR [esi+6], 7
  00fc7	66 85 c0	 test	 ax, ax
  00fca	75 58		 jne	 SHORT $L71578

; 848  : 			{
; 849  : 				if ((feanex & FSONCON) IS_PLUS)

  00fcc	8b c7		 mov	 eax, edi
  00fce	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00fd3	66 85 c0	 test	 ax, ax
  00fd6	74 32		 je	 SHORT $L71579

; 850  : 				{
; 851  : 					/* 1. Vowel-soncon trans, use 75-25% rule */
; 852  : 					pDphsettar->bouval = (pDphsettar->bouval + pDphsettar->np->tarnex) >> 1;

  00fd8	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00fdb	0f bf 16	 movsx	 edx, WORD PTR [esi]
  00fde	0f bf 48 16	 movsx	 ecx, WORD PTR [eax+22]
  00fe2	03 ca		 add	 ecx, edx
  00fe4	d1 f9		 sar	 ecx, 1
  00fe6	66 89 0e	 mov	 WORD PTR [esi], cx

; 853  : 					/* F3 transitions slower esp for [r,l] */
; 854  : 					if (pDphsettar->np == &PF3)

  00fe9	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  00fec	3b c1		 cmp	 eax, ecx
  00fee	75 06		 jne	 SHORT $L71580

; 855  : 					{
; 856  : 						pDphsettar->durtran = NF64MS;

  00ff0	66 c7 46 06 0a
	00		 mov	 WORD PTR [esi+6], 10	; 0000000aH
$L71580:

; 857  : 					}
; 858  : 					/* First formant jumps down 80 Hz in /l/ */
; 859  : 					if ((pDphsettar->phonex == LL) && (pDphsettar->np == &PF1))

  00ff6	66 83 7e 0a 1b	 cmp	 WORD PTR [esi+10], 27	; 0000001bH
  00ffb	75 50		 jne	 SHORT $L71585
  00ffd	8d 53 24	 lea	 edx, DWORD PTR [ebx+36]
  01000	3b c2		 cmp	 eax, edx
  01002	75 49		 jne	 SHORT $L71585

; 860  : 					{
; 861  : 						pDphsettar->bouval += 80;

  01004	66 83 06 50	 add	 WORD PTR [esi], 80	; 00000050H

; 862  : 					}
; 863  : 				}
; 864  : 				else

  01008	eb 43		 jmp	 SHORT $L71585
$L71579:

; 865  : 				{
; 866  : 					/* 2. Vowel-[vowel/h] transition */
; 867  : 					/* Following [h] has little influence on pDphsettar->bouval */
; 868  : 					if (pDphsettar->phonex == HX)

  0100a	66 83 7e 0a 1c	 cmp	 WORD PTR [esi+10], 28	; 0000001cH
  0100f	75 3c		 jne	 SHORT $L71585

; 869  : 					{
; 870  : 						pDphsettar->bouval = (pDphsettar->bouval + pDphsettar->np->tarend) >> 1;

  01011	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  01014	0f bf 16	 movsx	 edx, WORD PTR [esi]
  01017	0f bf 48 1a	 movsx	 ecx, WORD PTR [eax+26]
  0101b	03 ca		 add	 ecx, edx
  0101d	d1 f9		 sar	 ecx, 1
  0101f	66 89 0e	 mov	 WORD PTR [esi], cx

; 871  : 					}
; 872  : 				}
; 873  : 			}
; 874  : 			else

  01022	eb 29		 jmp	 SHORT $L71585
$L71578:

; 875  : 			{
; 876  : 				pDphsettar->durtran = NF40MS;
; 877  : 				if ((feanex & FSONCON) IS_MINUS)

  01024	8b c7		 mov	 eax, edi
  01026	66 c7 46 06 06
	00		 mov	 WORD PTR [esi+6], 6
  0102c	25 00 02 00 00	 and	 eax, 512		; 00000200H
  01031	66 85 c0	 test	 ax, ax
  01034	75 17		 jne	 SHORT $L71585

; 878  : 				{
; 879  : 					/* 3. Soncon-vowel trans, use 25-75% rule */
; 880  : 					pDphsettar->bouval = (pDphsettar->bouval + pDphsettar->np->tarend) >> 1;

  01036	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  01039	0f bf 06	 movsx	 eax, WORD PTR [esi]
  0103c	0f bf 51 1a	 movsx	 edx, WORD PTR [ecx+26]
  01040	03 d0		 add	 edx, eax

; 881  : 					pDphsettar->durtran = NF20MS;

  01042	66 c7 46 06 03
	00		 mov	 WORD PTR [esi+6], 3
  01048	d1 fa		 sar	 edx, 1
  0104a	66 89 16	 mov	 WORD PTR [esi], dx
$L71585:

; 882  : 				}
; 883  : 				else
; 884  : 				{
; 885  : 					/* 4. Soncon-soncon transition */
; 886  : 					/* Use defaults */
; 887  : 				}
; 888  : 			}
; 889  : 		}
; 890  : 		/* No backward smoothing if next phone is silence */
; 891  : 		if (pDphsettar->phonex == SIL)

  0104d	66 83 7e 0a 00	 cmp	 WORD PTR [esi+10], 0
  01052	75 0b		 jne	 SHORT $L71587

; 892  : 		{
; 893  : 			pDphsettar->durtran = 0;

  01054	66 c7 46 06 00
	00		 mov	 WORD PTR [esi+6], 0

; 894  : 		}
; 895  : 		else

  0105a	e9 04 01 00 00	 jmp	 $L71604
$L71587:

; 896  : 		{
; 897  : 			/* 5. pDphsettar->phcur=sonor, pDphsettar->phonex=obst transition */
; 898  : 			if (setloc (phTTS, pDph_t->nphone + 1, pDph_t->nphone, 'f', pDph_t->nphone + 2,feanex))

  0105f	66 8b 83 1c 20
	00 00		 mov	 ax, WORD PTR [ebx+8220]
  01066	57		 push	 edi
  01067	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  0106a	51		 push	 ecx
  0106b	6a 66		 push	 102			; 00000066H
  0106d	50		 push	 eax
  0106e	40		 inc	 eax
  0106f	50		 push	 eax
  01070	55		 push	 ebp
  01071	e8 00 00 00 00	 call	 _setloc

; 899  : 			{
; 900  : 				//debugfackward (" Use locus,percent", pDphsettar->np);
; 901  : 			}
; 902  : 			/* 6. pDphsettar->phcur=obst, pDphsettar->phonex=sonor transition */
; 903  : 			if (setloc (phTTS, pDph_t->nphone, pDph_t->nphone + 1, 'i', pDph_t->nphone - 1,feanex))

  01076	66 8b 83 1c 20
	00 00		 mov	 ax, WORD PTR [ebx+8220]
  0107d	57		 push	 edi
  0107e	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  01081	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  01084	52		 push	 edx
  01085	6a 69		 push	 105			; 00000069H
  01087	51		 push	 ecx
  01088	50		 push	 eax
  01089	55		 push	 ebp
  0108a	e8 00 00 00 00	 call	 _setloc

; 904  : 			{
; 905  : 				//debugfackward (" Use locus,percent", pDphsettar->np);
; 906  : 			}
; 907  : 			/* Transitions slow inside obstruents */
; 908  : 			if ((feacur & FOBST) IS_PLUS)

  0108f	8a 44 24 4c	 mov	 al, BYTE PTR _feacur$[esp+60]
  01093	83 c4 30	 add	 esp, 48			; 00000030H
  01096	a8 20		 test	 al, 32			; 00000020H
  01098	74 37		 je	 SHORT $L71594

; 909  : 			{
; 910  : 				pDphsettar->durtran = NF30MS;
; 911  : 				if (pDphsettar->np == &PF1)

  0109a	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0109d	8d 43 24	 lea	 eax, DWORD PTR [ebx+36]
  010a0	3b c8		 cmp	 ecx, eax
  010a2	66 c7 46 06 05
	00		 mov	 WORD PTR [esi+6], 5
  010a8	75 06		 jne	 SHORT $L71592

; 912  : 					pDphsettar->durtran = NF20MS;

  010aa	66 c7 46 06 03
	00		 mov	 WORD PTR [esi+6], 3
$L71592:

; 913  : 				/* Transitions take all of plosive duration */
; 914  : 				if ((feacur & FPLOSV) IS_PLUS)

  010b0	f6 44 24 1c 40	 test	 BYTE PTR _feacur$[esp+12], 64 ; 00000040H
  010b5	74 1a		 je	 SHORT $L71594

; 915  : 				{
; 916  : 					pDphsettar->durtran = pDph_t->durfon;

  010b7	66 8b 93 ac 11
	00 00		 mov	 dx, WORD PTR [ebx+4524]

; 917  : 					if ((pDphsettar->np == &PF1) && ((feacur & FVOICD) IS_MINUS))

  010be	3b c8		 cmp	 ecx, eax
  010c0	66 89 56 06	 mov	 WORD PTR [esi+6], dx
  010c4	75 0b		 jne	 SHORT $L71594
  010c6	f6 44 24 1c 02	 test	 BYTE PTR _feacur$[esp+12], 2
  010cb	75 04		 jne	 SHORT $L71594

; 918  : 					{
; 919  : 						pDphsettar->bouval += 100;

  010cd	66 83 06 64	 add	 WORD PTR [esi], 100	; 00000064H
$L71594:

; 920  : 					}
; 921  : 				}
; 922  : 			}
; 923  : 			/* Higher formant transitions slow inside a nasal */
; 924  : 			if ((feacur & FNASAL) IS_PLUS)

  010d1	f6 44 24 1c 80	 test	 BYTE PTR _feacur$[esp+12], -128 ; ffffff80H
  010d6	0f 84 87 00 00
	00		 je	 $L71604

; 925  : 			{
; 926  : 				pDphsettar->durtran = pDph_t->durfon;
; 927  : 				/* Except F1, which jumps to value below FNZRO */
; 928  : 				if (pDphsettar->np == &PF1)

  010dc	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  010df	66 8b 83 ac 11
	00 00		 mov	 ax, WORD PTR [ebx+4524]
  010e6	8d 4b 24	 lea	 ecx, DWORD PTR [ebx+36]
  010e9	66 89 46 06	 mov	 WORD PTR [esi+6], ax
  010ed	3b d1		 cmp	 edx, ecx
  010ef	75 08		 jne	 SHORT $L71596

; 929  : 				{
; 930  : 					pDphsettar->durtran = 0;

  010f1	66 c7 46 06 00
	00		 mov	 WORD PTR [esi+6], 0

; 931  : 				}
; 932  : 				/* Lower F2 & F3 of [n] nasal murmur before front vowels */
; 933  : 				else if (((pDphsettar->phcur == N) || (pDphsettar->phcur == EN))

  010f7	eb 6a		 jmp	 SHORT $L71604
$L71596:

; 934  : 						 && (begtyp[pDphsettar->phonex] == 1))

  010f9	66 8b 4e 18	 mov	 cx, WORD PTR [esi+24]
  010fd	66 83 f9 20	 cmp	 cx, 32			; 00000020H
  01101	74 06		 je	 SHORT $L71599
  01103	66 83 f9 24	 cmp	 cx, 36			; 00000024H
  01107	75 3a		 jne	 SHORT $L71598
$L71599:
  01109	0f bf 46 0a	 movsx	 eax, WORD PTR [esi+10]
  0110d	d1 e0		 shl	 eax, 1
  0110f	66 83 b8 00 00
	00 00 01	 cmp	 WORD PTR _begtyp[eax], 1
  01117	75 2a		 jne	 SHORT $L71598

; 935  : 				{
; 936  : 					if (pDphsettar->np == &PF2)

  01119	8d 4b 48	 lea	 ecx, DWORD PTR [ebx+72]
  0111c	3b d1		 cmp	 edx, ecx
  0111e	75 16		 jne	 SHORT $L71601

; 937  : 					{
; 938  : 						pDphsettar->bouval -= 100;

  01120	66 83 06 9c	 add	 WORD PTR [esi], -100	; ffffff9cH
  01124	66 8b 0e	 mov	 cx, WORD PTR [esi]

; 939  : 						if ((place[pDphsettar->phonex] & F2BACKI) IS_PLUS)

  01127	f6 80 00 00 00
	00 40		 test	 BYTE PTR _place[eax], 64 ; 00000040H
  0112e	74 06		 je	 SHORT $L71601

; 940  : 						{
; 941  : 							pDphsettar->bouval -= 100;

  01130	83 c1 9c	 add	 ecx, -100		; ffffff9cH
  01133	66 89 0e	 mov	 WORD PTR [esi], cx
$L71601:

; 942  : 						}
; 943  : 					}
; 944  : 					if (pDphsettar->np == &PF3)

  01136	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  01139	3b d0		 cmp	 edx, eax
  0113b	75 26		 jne	 SHORT $L71604

; 945  : 						pDphsettar->bouval -= 100;

  0113d	66 83 06 9c	 add	 WORD PTR [esi], -100	; ffffff9cH

; 946  : 				}
; 947  : 				/* Lower F2 of [m] murmur near [i,y,yu,ir] */
; 948  : 				else if ((pDphsettar->np == &PF2) && (pDphsettar->phcur == M)

  01141	eb 20		 jmp	 SHORT $L71604
$L71598:

; 949  : 						 && ((place[pDphsettar->phonex] & F2BACKI) IS_PLUS))

  01143	8d 43 48	 lea	 eax, DWORD PTR [ebx+72]
  01146	3b d0		 cmp	 edx, eax
  01148	75 19		 jne	 SHORT $L71604
  0114a	66 83 f9 1f	 cmp	 cx, 31			; 0000001fH
  0114e	75 13		 jne	 SHORT $L71604
  01150	0f bf 4e 0a	 movsx	 ecx, WORD PTR [esi+10]
  01154	f6 04 4d 00 00
	00 00 40	 test	 BYTE PTR _place[ecx*2], 64 ; 00000040H
  0115c	74 05		 je	 SHORT $L71604

; 950  : 				{
; 951  : 					pDphsettar->bouval -= 150;

  0115e	66 81 06 6a ff	 add	 WORD PTR [esi], -150	; ffffff6aH
$L71604:

; 952  : 				}
; 953  : 			}
; 954  : 		}
; 955  : 		/* Shrink tran dur inside sonorant if sonorant short */
; 956  : 		if (((feacur & FOBST) IS_MINUS)
; 957  : 			&& (begtyp[pDphsettar->phonex] != 4)	/* Unless next seg is obst */
; 958  : 			&& (pDphsettar->durtran > 0))

  01163	f6 44 24 1c 20	 test	 BYTE PTR _feacur$[esp+12], 32 ; 00000020H
  01168	0f 85 18 04 00
	00		 jne	 $endbsmo$71635
  0116e	0f bf 56 0a	 movsx	 edx, WORD PTR [esi+10]
  01172	66 83 3c 55 00
	00 00 00 04	 cmp	 WORD PTR _begtyp[edx*2], 4
  0117b	0f 84 05 04 00
	00		 je	 $endbsmo$71635
  01181	66 8b 46 06	 mov	 ax, WORD PTR [esi+6]
  01185	66 85 c0	 test	 ax, ax
  01188	0f 8e f8 03 00
	00		 jle	 $endbsmo$71635

; 959  : 		{
; 960  : 			pDph_t->arg1 = pDphsettar->durtran;

  0118e	66 89 83 c4 11
	00 00		 mov	 WORD PTR [ebx+4548], ax

; 961  : 			pDph_t->arg2 = shrib;

  01195	66 8b 44 24 18	 mov	 ax, WORD PTR _shrib$[esp+12]

; 962  : 			pDphsettar->durtran = mlsh1 (pDph_t->arg1, pDph_t->arg2) + 1;

  0119a	0f bf 8b c4 11
	00 00		 movsx	 ecx, WORD PTR [ebx+4548]
  011a1	0f bf d0	 movsx	 edx, ax
  011a4	0f af ca	 imul	 ecx, edx
  011a7	c1 f9 0e	 sar	 ecx, 14			; 0000000eH
  011aa	41		 inc	 ecx
  011ab	66 89 83 c6 11
	00 00		 mov	 WORD PTR [ebx+4550], ax
  011b2	66 89 4e 06	 mov	 WORD PTR [esi+6], cx

; 963  : 		}
; 964  : 	}
; 965  : 	/* BACKWARD SMOOTH:  FN */
; 966  : 	else if (pDphsettar->par_type IS_NASAL_ZERO_FREQ)

  011b6	e9 cb 03 00 00	 jmp	 $endbsmo$71635
$L71576:
  011bb	3c 01		 cmp	 al, 1
  011bd	75 38		 jne	 SHORT $L71607

; 967  : 	{
; 968  : 		pDphsettar->durtran = 0;
; 969  : 		/* Nasalization cue: place zero between F1 and FP */
; 970  : 		if (((feanex & FNASAL) IS_PLUS)
; 971  : 			&& ((feacur & FNASAL) IS_MINUS))

  011bf	8a 44 24 20	 mov	 al, BYTE PTR _feanex$[esp+12]
  011c3	66 c7 46 06 00
	00		 mov	 WORD PTR [esi+6], 0
  011c9	a8 80		 test	 al, -128		; ffffff80H
  011cb	0f 84 b5 03 00
	00		 je	 $endbsmo$71635
  011d1	f6 44 24 1c 80	 test	 BYTE PTR _feacur$[esp+12], -128 ; ffffff80H
  011d6	0f 85 aa 03 00
	00		 jne	 $endbsmo$71635

; 972  : 		{
; 973  : 			pDphsettar->bouval = 400;
; 974  : 			pDphsettar->durtran = NF80MS;
; 975  : 			if (pDphsettar->phonex == EN)

  011dc	66 83 7e 0a 24	 cmp	 WORD PTR [esi+10], 36	; 00000024H
  011e1	66 c7 06 90 01	 mov	 WORD PTR [esi], 400	; 00000190H
  011e6	66 c7 46 06 0d
	00		 mov	 WORD PTR [esi+6], 13	; 0000000dH
  011ec	0f 85 94 03 00
	00		 jne	 $endbsmo$71635

; 976  : 				pDphsettar->durtran = NF130MS;
; 977  : 		}
; 978  : 	}
; 979  : 	/* BACKWARD SMOOTH:  B1, B2, B3 */
; 980  : 	else if (pDphsettar->par_type IS_FORM_BW)

  011f2	e9 89 03 00 00	 jmp	 $L72004
$L71607:
  011f7	3c 04		 cmp	 al, 4
  011f9	0f 85 2e 01 00
	00		 jne	 $L71611

; 981  : 	{
; 982  : 		pDphsettar->durtran = NF40MS;
; 983  : 		if ((feacur & FVOICD) IS_PLUS)

  011ff	8a 44 24 1c	 mov	 al, BYTE PTR _feacur$[esp+12]
  01203	b1 02		 mov	 cl, 2
  01205	84 c1		 test	 al, cl
  01207	66 c7 46 06 06
	00		 mov	 WORD PTR [esi+6], 6
  0120d	bd 08 00 00 00	 mov	 ebp, 8
  01212	74 38		 je	 SHORT $L71612

; 984  : 		{
; 985  : 			/* Glottis opens early before -voice C, widen B1 */
; 986  : 			if (pDphsettar->np == &PB1)

  01214	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  01217	8d 93 b4 00 00
	00		 lea	 edx, DWORD PTR [ebx+180]
  0121d	3b c2		 cmp	 eax, edx
  0121f	75 31		 jne	 SHORT $L71616

; 987  : 			{
; 988  : 				if ((feanex & FVOICD) IS_MINUS)

  01221	84 4c 24 20	 test	 BYTE PTR _feanex$[esp+12], cl
  01225	75 2b		 jne	 SHORT $L71616

; 989  : 				{
; 990  : 					pDphsettar->durtran = NF50MS;

  01227	66 89 6e 06	 mov	 WORD PTR [esi+6], bp

; 991  : 					/* More increase for low vowels (F1 high) */
; 992  : 					pDphsettar->bouval = pDphsettar->np->tarend + (PF1.tarcur >> 3);

  0122b	66 8b 4b 24	 mov	 cx, WORD PTR [ebx+36]
  0122f	66 c1 f9 03	 sar	 cx, 3
  01233	66 03 48 1a	 add	 cx, WORD PTR [eax+26]
  01237	66 89 0e	 mov	 WORD PTR [esi], cx

; 993  : 					/* Effect is greater for a female voice */
; 994  : 					if (pDph_t->malfem == FEMALE)

  0123a	66 83 bb b0 11
	00 00 00	 cmp	 WORD PTR [ebx+4528], 0
  01242	75 0e		 jne	 SHORT $L71616

; 995  : 					{
; 996  : 						pDphsettar->durtran = NF100MS;

  01244	66 c7 46 06 10
	00		 mov	 WORD PTR [esi+6], 16	; 00000010H

; 997  : 					}
; 998  : 				}
; 999  : 			}
; 1000 : 		}
; 1001 : 		else

  0124a	eb 06		 jmp	 SHORT $L71616
$L71612:

; 1002 : 		{
; 1003 : 			pDphsettar->durtran = NF20MS;

  0124c	66 c7 46 06 03
	00		 mov	 WORD PTR [esi+6], 3
$L71616:

; 1004 : 		}
; 1005 : 		/* Treat boundary with silence */
; 1006 : 		/* OUT ??? */
; 1007 : 		if (pDphsettar->phonex == SIL)

  01252	66 83 7e 0a 00	 cmp	 WORD PTR [esi+10], 0
  01257	75 2c		 jne	 SHORT $L71617

; 1008 : 		{
; 1009 : 			pDphsettar->bouval = pDphsettar->np->tarend + ((&PB3 - pDphsettar->np) * 50);

  01259	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0125c	8b cb		 mov	 ecx, ebx
  0125e	2b cf		 sub	 ecx, edi
  01260	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  01265	81 c1 fc 00 00
	00		 add	 ecx, 252		; 000000fcH
  0126b	f7 e9		 imul	 ecx
  0126d	c1 fa 03	 sar	 edx, 3
  01270	8b c2		 mov	 eax, edx
  01272	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  01275	03 d0		 add	 edx, eax
  01277	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  0127a	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  0127d	d1 e1		 shl	 ecx, 1
  0127f	66 03 4f 1a	 add	 cx, WORD PTR [edi+26]

; 1010 : 			pDphsettar->durtran = NF50MS;
; 1011 : 		}
; 1012 : 		else if (pDphsettar->phcur == SIL)

  01283	eb 31		 jmp	 SHORT $L72005
$L71617:
  01285	66 83 7e 18 00	 cmp	 WORD PTR [esi+24], 0
  0128a	75 31		 jne	 SHORT $L71619

; 1013 : 		{
; 1014 : 			pDphsettar->bouval = pDphsettar->np->tarnex + ((&PB3 - pDphsettar->np) * 50);

  0128c	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0128f	8b cb		 mov	 ecx, ebx
  01291	2b cf		 sub	 ecx, edi
  01293	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  01298	81 c1 fc 00 00
	00		 add	 ecx, 252		; 000000fcH
  0129e	f7 e9		 imul	 ecx
  012a0	c1 fa 03	 sar	 edx, 3
  012a3	8b c2		 mov	 eax, edx
  012a5	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  012a8	03 d0		 add	 edx, eax
  012aa	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  012ad	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  012b0	d1 e1		 shl	 ecx, 1
  012b2	66 03 4f 16	 add	 cx, WORD PTR [edi+22]
$L72005:
  012b6	66 89 0e	 mov	 WORD PTR [esi], cx

; 1015 : 			pDphsettar->durtran = NF50MS;

  012b9	66 89 6e 06	 mov	 WORD PTR [esi+6], bp
$L71619:

; 1016 : 		}
; 1017 : 		/* BW1 widen, to nasalize transition into next nasal */
; 1018 : 		if ((feanex & FNASAL) IS_PLUS)

  012bd	f6 44 24 20 80	 test	 BYTE PTR _feanex$[esp+12], -128 ; ffffff80H
  012c2	74 53		 je	 SHORT $L71623

; 1019 : 		{
; 1020 : 			pDphsettar->bouval = pDphsettar->np->tarend;

  012c4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 1021 : 			/* Except F2 of [n], which is wider before a non-front vowel */
; 1022 : 			if ((pDphsettar->np == &PB2) && ((pDphsettar->phonex == N) || (pDphsettar->phonex == EN))
; 1023 : 				&& (endtyp[pDphsettar->phcur] != 1))

  012c7	8d 93 d8 00 00
	00		 lea	 edx, DWORD PTR [ebx+216]
  012cd	3b c2		 cmp	 eax, edx
  012cf	66 8b 48 1a	 mov	 cx, WORD PTR [eax+26]
  012d3	66 89 0e	 mov	 WORD PTR [esi], cx
  012d6	75 2b		 jne	 SHORT $L71621
  012d8	66 8b 56 0a	 mov	 dx, WORD PTR [esi+10]
  012dc	66 83 fa 20	 cmp	 dx, 32			; 00000020H
  012e0	74 06		 je	 SHORT $L71622
  012e2	66 83 fa 24	 cmp	 dx, 36			; 00000024H
  012e6	75 1b		 jne	 SHORT $L71621
$L71622:
  012e8	0f bf 56 18	 movsx	 edx, WORD PTR [esi+24]
  012ec	66 83 3c 55 00
	00 00 00 01	 cmp	 WORD PTR _endtyp[edx*2], 1
  012f5	74 0c		 je	 SHORT $L71621

; 1024 : 			{
; 1025 : 				pDphsettar->bouval += 60;

  012f7	83 c1 3c	 add	 ecx, 60			; 0000003cH

; 1026 : 				pDphsettar->durtran = NF60MS;

  012fa	66 c7 46 06 09
	00		 mov	 WORD PTR [esi+6], 9
  01300	66 89 0e	 mov	 WORD PTR [esi], cx
$L71621:

; 1027 : 			}
; 1028 : 			if (pDphsettar->np == &PB1)

  01303	8d 8b b4 00 00
	00		 lea	 ecx, DWORD PTR [ebx+180]
  01309	3b c1		 cmp	 eax, ecx
  0130b	75 0a		 jne	 SHORT $L71623

; 1029 : 			{
; 1030 : 				pDphsettar->durtran = NF100MS;
; 1031 : 				pDphsettar->bouval += 100;

  0130d	66 83 06 64	 add	 WORD PTR [esi], 100	; 00000064H
  01311	66 c7 46 06 10
	00		 mov	 WORD PTR [esi+6], 16	; 00000010H
$L71623:

; 1032 : 			}
; 1033 : 		}
; 1034 : 		/* Nasals have constant bandwidths at target values */
; 1035 : 		if ((feacur & FNASAL) IS_PLUS)

  01317	f6 44 24 1c 80	 test	 BYTE PTR _feacur$[esp+12], -128 ; ffffff80H
  0131c	0f 84 64 02 00
	00		 je	 $endbsmo$71635

; 1036 : 		{
; 1037 : 			pDphsettar->durtran = 0;

  01322	66 c7 46 06 00
	00		 mov	 WORD PTR [esi+6], 0

; 1038 : 			//debugfackward (" Nasal has const. par val", pDphsettar->np);
; 1039 : 		}
; 1040 : 	}
; 1041 : 	/* BACKWARD SMOOTH:  AV, AP, A2, A3, A4, A5, A6, AB */
; 1042 : 	else if ((pDphsettar->par_type IS_PARALLEL_FORM_AMP)

  01328	e9 59 02 00 00	 jmp	 $endbsmo$71635
$L71611:

; 1043 : 			 || (pDphsettar->par_type IS_AV_OR_AH))

  0132d	33 ff		 xor	 edi, edi
  0132f	3c 02		 cmp	 al, 2
  01331	74 08		 je	 SHORT $L71627
  01333	84 c0		 test	 al, al
  01335	0f 85 4b 02 00
	00		 jne	 $endbsmo$71635
$L71627:

; 1044 : 	{
; 1045 : 		/* See if onset, i.e. source intensity increasing */
; 1046 : 		temp = pDphsettar->np->tarnex - 10;

  0133b	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  0133e	66 8b 45 16	 mov	 ax, WORD PTR [ebp+22]
  01342	66 2d 0a 00	 sub	 ax, 10			; 0000000aH

; 1047 : 		if (pDphsettar->bouval < temp)

  01346	66 39 06	 cmp	 WORD PTR [esi], ax
  01349	7d 0f		 jge	 SHORT $L71629

; 1048 : 		{
; 1049 : 			pDphsettar->bouval = temp;
; 1050 : 			/* Onset of an init fricative or /h/ is very gradual */
; 1051 : 			if (pDphsettar->phcur == SIL)

  0134b	66 39 7e 18	 cmp	 WORD PTR [esi+24], di
  0134f	66 89 06	 mov	 WORD PTR [esi], ax
  01352	75 06		 jne	 SHORT $L71629

; 1052 : 			{
; 1053 : 				pDphsettar->durtran = NF70MS;

  01354	66 c7 46 06 0b
	00		 mov	 WORD PTR [esi+6], 11	; 0000000bH
$L71629:

; 1054 : 			}
; 1055 : 			//debugfackward (" Onset", pDphsettar->np);
; 1056 : 		}
; 1057 : 		/* Voicing is special:  onset is abrupt, except if a voiced fric */
; 1058 : 		if ((pDphsettar->np == &PAV) && (pDphsettar->bouval < pDphsettar->np->tarnex)
; 1059 : 			&& (pDphsettar->phcur != V) && (pDphsettar->phcur != DH)
; 1060 : 			&& (pDphsettar->phcur != JH) && (pDphsettar->phcur != ZH) && (pDphsettar->phcur != Z))

  0135a	8b 4c 24 1c	 mov	 ecx, DWORD PTR _feacur$[esp+12]
  0135e	8d 83 20 01 00
	00		 lea	 eax, DWORD PTR [ebx+288]
  01364	3b e8		 cmp	 ebp, eax
  01366	75 5d		 jne	 SHORT $L71631
  01368	66 8b 16	 mov	 dx, WORD PTR [esi]
  0136b	66 3b 55 16	 cmp	 dx, WORD PTR [ebp+22]
  0136f	7d 54		 jge	 SHORT $L71631
  01371	66 8b 46 18	 mov	 ax, WORD PTR [esi+24]
  01375	66 3d 26 00	 cmp	 ax, 38			; 00000026H
  01379	74 4a		 je	 SHORT $L71631
  0137b	66 3d 28 00	 cmp	 ax, 40			; 00000028H
  0137f	74 44		 je	 SHORT $L71631
  01381	66 3d 37 00	 cmp	 ax, 55			; 00000037H
  01385	74 3e		 je	 SHORT $L71631
  01387	66 3d 2c 00	 cmp	 ax, 44			; 0000002cH
  0138b	74 38		 je	 SHORT $L71631
  0138d	66 3d 2a 00	 cmp	 ax, 42			; 0000002aH
  01391	74 32		 je	 SHORT $L71631

; 1061 : 		{
; 1062 : 			pDphsettar->durtran = 0;
; 1063 : 			//debugfackward (" Make next onset abrupt", pDphsettar->np);
; 1064 : 			/* Voicebar dies out in a voiced plosive */
; 1065 : 			if (((feacur & FPLOSV) IS_PLUS) || (pDphsettar->phcur == CH))

  01393	f6 c1 40	 test	 cl, 64			; 00000040H
  01396	66 89 7e 06	 mov	 WORD PTR [esi+6], di
  0139a	75 06		 jne	 SHORT $L71632
  0139c	66 3d 36 00	 cmp	 ax, 54			; 00000036H
  013a0	75 23		 jne	 SHORT $L71631
$L71632:

; 1066 : 			{
; 1067 : 				if ((feacur & FVOICD) IS_PLUS)

  013a2	f6 c1 02	 test	 cl, 2
  013a5	74 16		 je	 SHORT $L71633

; 1068 : 				{
; 1069 : 					pDphsettar->bouval = pDphsettar->np->tarend - 3;

  013a7	66 8b 45 1a	 mov	 ax, WORD PTR [ebp+26]

; 1070 : 					pDphsettar->durtran = NF45MS;

  013ab	66 c7 46 06 07
	00		 mov	 WORD PTR [esi+6], 7
  013b1	66 2d 03 00	 sub	 ax, 3
  013b5	66 89 06	 mov	 WORD PTR [esi], ax

; 1071 : 					//debugfackward (" Voicebar dies out", pDphsettar->np);
; 1072 : 				}
; 1073 : 				/* Do not allow prevoicing in a voiceless plosive */
; 1074 : 				else

  013b8	e9 c9 01 00 00	 jmp	 $endbsmo$71635
$L71633:

; 1075 : 				{
; 1076 : 					pDphsettar->bouval = 0;

  013bd	66 89 3e	 mov	 WORD PTR [esi], di

; 1077 : 				}
; 1078 : 				goto endbsmo;

  013c0	e9 c1 01 00 00	 jmp	 $endbsmo$71635
$L71631:

; 1079 : 			}
; 1080 : 		}
; 1081 : 		/* If next nasal, & curr phone is voiced, set AV const */
; 1082 : 		if (((feanex & FNASAL) IS_PLUS)
; 1083 : 			&& ((feacur & FVOICD) IS_PLUS))

  013c5	8a 54 24 20	 mov	 dl, BYTE PTR _feanex$[esp+12]
  013c9	f6 c2 80	 test	 dl, -128		; ffffff80H
  013cc	74 09		 je	 SHORT $L71636
  013ce	f6 c1 02	 test	 cl, 2
  013d1	74 04		 je	 SHORT $L71636

; 1084 : 		{
; 1085 : 			pDphsettar->durtran = 0;

  013d3	66 89 7e 06	 mov	 WORD PTR [esi+6], di
$L71636:

; 1086 : 			//debugforward (" AV const in voiced to  nasal", pDphsettar->np);
; 1087 : 		}
; 1088 : 		/* If curr phone nasal, and next is voiced non-obst, AV const */
; 1089 : 		if ((feacur & FNASAL) IS_PLUS)

  013d7	8b 7c 24 24	 mov	 edi, DWORD PTR _strucnex$[esp+12]
  013db	8b c1		 mov	 eax, ecx
  013dd	25 80 00 00 00	 and	 eax, 128		; 00000080H
  013e2	66 85 c0	 test	 ax, ax
  013e5	89 44 24 18	 mov	 DWORD PTR 12+[esp+12], eax
  013e9	74 23		 je	 SHORT $L71639

; 1090 : 		{
; 1091 : 			if (((feanex & FVOICD) IS_PLUS)
; 1092 : 				&& ((feanex & FOBST) IS_MINUS)
; 1093 : 				&& ((strucnex & FDUMMY_VOWEL) IS_MINUS))

  013eb	f6 c2 02	 test	 dl, 2
  013ee	74 18		 je	 SHORT $L71638
  013f0	f6 c2 20	 test	 dl, 32			; 00000020H
  013f3	75 13		 jne	 SHORT $L71638
  013f5	8b cf		 mov	 ecx, edi
  013f7	81 e1 00 08 00
	00		 and	 ecx, 2048		; 00000800H
  013fd	66 85 c9	 test	 cx, cx
  01400	75 06		 jne	 SHORT $L71638

; 1094 : 			{
; 1095 : 				pDphsettar->durtran = 0;

  01402	66 89 4e 06	 mov	 WORD PTR [esi+6], cx

; 1096 : 				//debugfackward (" Make murmur const AV", pDphsettar->np);
; 1097 : 			}
; 1098 : 			else

  01406	eb 06		 jmp	 SHORT $L71639
$L71638:

; 1099 : 			{
; 1100 : 				pDphsettar->durtran = NF40MS;

  01408	66 c7 46 06 06
	00		 mov	 WORD PTR [esi+6], 6
$L71639:

; 1101 : 			}
; 1102 : 		}
; 1103 : 		/* See if offset, i.e. source intensity decreasing */
; 1104 : 		temp = pDphsettar->np->tarend - 10;

  0140e	66 8b 45 1a	 mov	 ax, WORD PTR [ebp+26]

; 1105 : 		/* Plosive burst does not get attenuated during offset */
; 1106 : 		if (pDphsettar->phcur >= P)

  01412	66 8b 4e 18	 mov	 cx, WORD PTR [esi+24]
  01416	66 2d 0a 00	 sub	 ax, 10			; 0000000aH
  0141a	66 83 f9 2d	 cmp	 cx, 45			; 0000002dH
  0141e	7c 10		 jl	 SHORT $L71641

; 1107 : 		{
; 1108 : 			pDphsettar->durtran = NF15MS;
; 1109 : 			if (pDphsettar->phcur < CH)

  01420	66 83 f9 36	 cmp	 cx, 54			; 00000036H
  01424	66 c7 46 06 02
	00		 mov	 WORD PTR [esi+6], 2
  0142a	7d 04		 jge	 SHORT $L71641

; 1110 : 			{
; 1111 : 				temp = pDphsettar->np->tarend;

  0142c	66 8b 45 1a	 mov	 ax, WORD PTR [ebp+26]
$L71641:

; 1112 : 			}
; 1113 : 		}
; 1114 : 		if (pDphsettar->bouval < temp)

  01430	66 39 06	 cmp	 WORD PTR [esi], ax
  01433	7d 0c		 jge	 SHORT $L71642

; 1115 : 		{							   /* Or does it ??? */
; 1116 : 			pDphsettar->bouval = temp - 3;

  01435	8d 50 fd	 lea	 edx, DWORD PTR [eax-3]

; 1117 : 			pDphsettar->durtran = NF20MS;

  01438	66 c7 46 06 03
	00		 mov	 WORD PTR [esi+6], 3
  0143e	66 89 16	 mov	 WORD PTR [esi], dx
$L71642:

; 1118 : 		}
; 1119 : 		/* Voicing amp falls gradually at end of phrase */
; 1120 : 		/* (Source sudden offset, or next seg is a dummy vowel) */
; 1121 : 		if (pDphsettar->np == &PAV)

  01441	8d 93 20 01 00
	00		 lea	 edx, DWORD PTR [ebx+288]
  01447	3b ea		 cmp	 ebp, edx
  01449	75 4f		 jne	 SHORT $L71646

; 1122 : 		{
; 1123 : 			if ((pDphsettar->bouval < temp) || ((temp > 0)
; 1124 : 												&& (pDphsettar->np == &PAV) && ((strucnex & FDUMMY_VOWEL) IS_PLUS)))

  0144b	66 39 06	 cmp	 WORD PTR [esi], ax
  0144e	7c 2c		 jl	 SHORT $L71645
  01450	66 85 c0	 test	 ax, ax
  01453	7e 0d		 jle	 SHORT $L71644
  01455	8b d7		 mov	 edx, edi
  01457	81 e2 00 08 00
	00		 and	 edx, 2048		; 00000800H
  0145d	66 85 d2	 test	 dx, dx
  01460	75 1a		 jne	 SHORT $L71645
$L71644:

; 1131 : 				}
; 1132 : 			}
; 1133 : 			else if (pDphsettar->np == &PAP)

  01462	8d 83 44 01 00
	00		 lea	 eax, DWORD PTR [ebx+324]
  01468	3b e8		 cmp	 ebp, eax
  0146a	75 2e		 jne	 SHORT $L71646

; 1134 : 				pDphsettar->bouval = PAP.tarend - 6;

  0146c	66 8b 93 5e 01
	00 00		 mov	 dx, WORD PTR [ebx+350]
  01473	66 83 ea 06	 sub	 dx, 6
  01477	66 89 16	 mov	 WORD PTR [esi], dx
  0147a	eb 1e		 jmp	 SHORT $L71646
$L71645:

; 1125 : 			{
; 1126 : 				pDphsettar->bouval = temp + 3;

  0147c	83 c0 03	 add	 eax, 3

; 1127 : 				if ((pDphsettar->phonex == SIL)
; 1128 : 					|| ((strucnex & FDUMMY_VOWEL) IS_PLUS))

  0147f	66 83 7e 0a 00	 cmp	 WORD PTR [esi+10], 0
  01484	66 89 06	 mov	 WORD PTR [esi], ax
  01487	74 0b		 je	 SHORT $L71647
  01489	81 e7 00 08 00
	00		 and	 edi, 2048		; 00000800H
  0148f	66 85 ff	 test	 di, di
  01492	74 06		 je	 SHORT $L71646
$L71647:

; 1129 : 				{
; 1130 : 					pDphsettar->durtran = NF75MS;

  01494	66 c7 46 06 0c
	00		 mov	 WORD PTR [esi+6], 12	; 0000000cH
$L71646:

; 1135 : 			//debugfackward (" Offset to noise", pDphsettar->np);
; 1136 : 		}
; 1137 : 		/* No smoothing of source amps if next segment has burst */
; 1138 : 		if ((pDphsettar->phonex >= P)
; 1139 : 			&& (((feacur & FNASAL) IS_MINUS) || (pDphsettar->np != &PAV)))

  0149a	66 8b 7e 0a	 mov	 di, WORD PTR [esi+10]
  0149e	66 83 ff 2d	 cmp	 di, 45			; 0000002dH
  014a2	7c 18		 jl	 SHORT $L71650
  014a4	66 83 7c 24 18
	00		 cmp	 WORD PTR 12+[esp+12], 0
  014aa	74 0a		 je	 SHORT $L71651
  014ac	8d 83 20 01 00
	00		 lea	 eax, DWORD PTR [ebx+288]
  014b2	3b e8		 cmp	 ebp, eax
  014b4	74 06		 je	 SHORT $L71650
$L71651:

; 1140 : 		{
; 1141 : 			pDphsettar->durtran = 0;

  014b6	66 c7 46 06 00
	00		 mov	 WORD PTR [esi+6], 0
$L71650:

; 1142 : 			//debugfackward (" Stop closure next", pDphsettar->np);
; 1143 : 		}
; 1144 : 		/* Onset of a vowel from voiceless open vocal tract is breathy */
; 1145 : 		if (pDphsettar->np == &PAP)

  014bc	8d 83 44 01 00
	00		 lea	 eax, DWORD PTR [ebx+324]
  014c2	3b e8		 cmp	 ebp, eax
  014c4	75 50		 jne	 SHORT $L72002

; 1146 : 		{
; 1147 : 			if (
; 1148 : 			/* OUT                    (pDphsettar->phcur == SIL) ||                         END OUT */
; 1149 : 				   (pDphsettar->phcur == F) || (pDphsettar->phcur == TH)
; 1150 : 				   || (pDphsettar->phcur == S) || (pDphsettar->phcur == SH))

  014c6	66 83 f9 25	 cmp	 cx, 37			; 00000025H
  014ca	74 12		 je	 SHORT $L71654
  014cc	66 83 f9 27	 cmp	 cx, 39			; 00000027H
  014d0	74 0c		 je	 SHORT $L71654
  014d2	66 83 f9 29	 cmp	 cx, 41			; 00000029H
  014d6	74 06		 je	 SHORT $L71654
  014d8	66 83 f9 2b	 cmp	 cx, 43			; 0000002bH
  014dc	75 19		 jne	 SHORT $L72000
$L71654:

; 1151 : 			{
; 1152 : 				if (((feanex & FVOICD) IS_PLUS)
; 1153 : 					&& ((feanex & FOBST) IS_MINUS))

  014de	8b 44 24 20	 mov	 eax, DWORD PTR _feanex$[esp+12]
  014e2	a8 02		 test	 al, 2
  014e4	74 15		 je	 SHORT $L71655
  014e6	a8 20		 test	 al, 32			; 00000020H
  014e8	75 11		 jne	 SHORT $L71655

; 1154 : 				{
; 1155 : 					pDphsettar->bouval = 52;

  014ea	66 c7 06 34 00	 mov	 WORD PTR [esi], 52	; 00000034H

; 1156 : 					pDphsettar->durtran = NF40MS;

  014ef	66 c7 46 06 06
	00		 mov	 WORD PTR [esi+6], 6
  014f5	eb 04		 jmp	 SHORT $L71655
$L72000:
  014f7	8b 44 24 20	 mov	 eax, DWORD PTR _feanex$[esp+12]
$L71655:

; 1157 : 				}
; 1158 : 			}
; 1159 : 			/* Offset of a vowel into silence is breathy */
; 1160 : 			if (((feacur & FSYLL) IS_PLUS)
; 1161 : 				&& (pDphsettar->phonex == SIL))

  014fb	8b 54 24 1c	 mov	 edx, DWORD PTR _feacur$[esp+12]
  014ff	f6 c2 01	 test	 dl, 1
  01502	74 1a		 je	 SHORT $L71656
  01504	66 85 ff	 test	 di, di
  01507	75 15		 jne	 SHORT $L71656

; 1162 : 			{
; 1163 : 				pDphsettar->bouval = 52;

  01509	66 c7 06 34 00	 mov	 WORD PTR [esi], 52	; 00000034H

; 1164 : 				pDphsettar->durtran = NF130MS;

  0150e	66 c7 46 06 14
	00		 mov	 WORD PTR [esi+6], 20	; 00000014H
  01514	eb 08		 jmp	 SHORT $L71656
$L72002:
  01516	8b 54 24 1c	 mov	 edx, DWORD PTR _feacur$[esp+12]
  0151a	8b 44 24 20	 mov	 eax, DWORD PTR _feanex$[esp+12]
$L71656:

; 1165 : 			}
; 1166 : 		}
; 1167 : 		/* BACKWARD SMOOTH:  TLT */
; 1168 : 
; 1169 : 		/* Tilt parameter jumps to target values near stops and silence */
; 1170 : 		if (pDphsettar->np == &PTILT)

  0151e	8d bb 40 02 00
	00		 lea	 edi, DWORD PTR [ebx+576]
  01524	3b ef		 cmp	 ebp, edi
  01526	75 5e		 jne	 SHORT $endbsmo$71635

; 1171 : 		{
; 1172 : 			pDphsettar->durtran = NF25MS;
; 1173 : 			if (pDphsettar->phonex == SIL)

  01528	66 8b 7e 0a	 mov	 di, WORD PTR [esi+10]
  0152c	66 c7 46 06 04
	00		 mov	 WORD PTR [esi+6], 4
  01532	66 85 ff	 test	 di, di
  01535	75 07		 jne	 SHORT $L71658

; 1174 : 			{
; 1175 : 				pDphsettar->bouval = pDphsettar->np->tarend;

  01537	66 8b 6d 1a	 mov	 bp, WORD PTR [ebp+26]
  0153b	66 89 2e	 mov	 WORD PTR [esi], bp
$L71658:

; 1176 : 			}
; 1177 : 			if (pDphsettar->phcur == SIL)

  0153e	66 85 c9	 test	 cx, cx
  01541	75 0a		 jne	 SHORT $L71659

; 1178 : 			{
; 1179 : 				pDphsettar->bouval = pDphsettar->np->tarnex;

  01543	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  01546	66 8b 49 16	 mov	 cx, WORD PTR [ecx+22]
  0154a	66 89 0e	 mov	 WORD PTR [esi], cx
$L71659:

; 1180 : 			}
; 1181 : 			if (((feanex & FSTOP) IS_PLUS)
; 1182 : 				|| ((feacur & FSTOP) IS_PLUS))

  0154d	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  01552	66 85 c0	 test	 ax, ax
  01555	75 0c		 jne	 SHORT $L71661
  01557	8b c2		 mov	 eax, edx
  01559	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  0155e	66 85 c0	 test	 ax, ax
  01561	74 06		 je	 SHORT $L71660
$L71661:

; 1183 : 			{
; 1184 : 				pDphsettar->durtran = 0;

  01563	66 c7 46 06 00
	00		 mov	 WORD PTR [esi+6], 0
$L71660:

; 1185 : 			}
; 1186 : 			/* Long breathy offset into silence */
; 1187 : 			if (((feacur & FVOICD) IS_PLUS)
; 1188 : 				&& ((feacur & FNASAL) IS_MINUS))

  01569	f6 c2 02	 test	 dl, 2
  0156c	74 18		 je	 SHORT $endbsmo$71635
  0156e	66 83 7c 24 18
	00		 cmp	 WORD PTR 12+[esp+12], 0
  01574	75 10		 jne	 SHORT $endbsmo$71635

; 1189 : 			{
; 1190 : 				if (pDphsettar->phonex == SIL)

  01576	66 85 ff	 test	 di, di
  01579	75 0b		 jne	 SHORT $endbsmo$71635

; 1191 : 				{
; 1192 : 					pDphsettar->bouval = 15;

  0157b	66 c7 06 0f 00	 mov	 WORD PTR [esi], 15	; 0000000fH
$L72004:

; 1193 : 					pDphsettar->durtran = NF130MS;

  01580	66 c7 46 06 14
	00		 mov	 WORD PTR [esi+6], 20	; 00000014H
$endbsmo$71635:

; 1194 : 				}
; 1195 : 			}
; 1196 : 		}
; 1197 : 	}
; 1198 : 	/* Truncate back transition so as not to exceed 20 frames */
; 1199 :   endbsmo:
; 1200 : 	if (pDphsettar->durtran > NF130MS)

  01586	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0158b	66 39 46 06	 cmp	 WORD PTR [esi+6], ax
  0158f	7e 04		 jle	 SHORT $L71664

; 1201 : 		pDphsettar->durtran = NF130MS;

  01591	66 89 46 06	 mov	 WORD PTR [esi+6], ax
$L71664:

; 1202 : 	/* Truncate backward tran so as not to exceed dur of phone */
; 1203 : 	if (pDphsettar->durtran > pDph_t->durfon)

  01595	66 8b 83 ac 11
	00 00		 mov	 ax, WORD PTR [ebx+4524]
  0159c	66 39 46 06	 cmp	 WORD PTR [esi+6], ax
  015a0	7e 04		 jle	 SHORT $L71665

; 1204 : 		pDphsettar->durtran = pDph_t->durfon;

  015a2	66 89 46 06	 mov	 WORD PTR [esi+6], ax
$L71665:

; 1205 : 	pDphsettar->np->tbacktr = pDph_t->durfon - pDphsettar->durtran;

  015a6	66 8b 8b ac 11
	00 00		 mov	 cx, WORD PTR [ebx+4524]
  015ad	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  015b0	66 2b 4e 06	 sub	 cx, WORD PTR [esi+6]
  015b4	66 89 4a 10	 mov	 WORD PTR [edx+16], cx

; 1206 : 	/* No parameter can take on negative values */
; 1207 : 	if (pDphsettar->bouval < 0)

  015b8	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  015bc	7d 05		 jge	 SHORT $L71666

; 1208 : 		pDphsettar->bouval = 0;

  015be	66 c7 06 00 00	 mov	 WORD PTR [esi], 0
$L71666:
  015c3	5f		 pop	 edi
  015c4	5e		 pop	 esi
  015c5	5d		 pop	 ebp
  015c6	5b		 pop	 ebx

; 1209 : }

  015c7	c3		 ret	 0
_back_smooth_rules ENDP
_TEXT	ENDS
EXTRN	_mstofr:NEAR
EXTRN	_burdr:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_fealas$ = 12
_feacur$ = 16
_feanex$ = 20
_struclm2$ = 24
_struccur$ = 28
_special_rules PROC NEAR

; 1238 : 	short                   bdur, vot; /* MVP made as a local variable */
; 1239 : 	short                   closure_dur;	/* MVP made as a local variable */
; 1240 : 	
; 1241 : 
; 1242 : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  015d0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  015d4	53		 push	 ebx

; 1243 : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 1244 : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;
; 1245 : 
; 1246 : 	/* SPECIAL RULE 1: Burst duration for plosives and affricates             */
; 1247 : 
; 1248 : 	bdur = burdr[pDphsettar->phcur];   /* Look up inher. burst dur in msec in table */
; 1249 : 
; 1250 : 	if ((feacur & FBURST) IS_PLUS)

  015d5	8b 5c 24 10	 mov	 ebx, DWORD PTR _feacur$[esp]
  015d9	55		 push	 ebp
  015da	56		 push	 esi
  015db	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  015de	57		 push	 edi
  015df	8b eb		 mov	 ebp, ebx
  015e1	8b be 48 28 00
	00		 mov	 edi, DWORD PTR [esi+10312]
  015e7	81 e5 00 08 00
	00		 and	 ebp, 2048		; 00000800H
  015ed	66 85 ed	 test	 bp, bp
  015f0	0f bf 4f 18	 movsx	 ecx, WORD PTR [edi+24]
  015f4	89 6c 24 14	 mov	 DWORD PTR 8+[esp+12], ebp
  015f8	66 8b 04 4d 00
	00 00 00	 mov	 ax, WORD PTR _burdr[ecx*2]
  01600	0f 84 ad 00 00
	00		 je	 $L71702

; 1251 : 	{
; 1252 : 		bdur = mstofr (bdur);		   /* Convert to frames         */

  01606	0f bf d0	 movsx	 edx, ax
  01609	52		 push	 edx
  0160a	e8 00 00 00 00	 call	 _mstofr

; 1253 : 
; 1254 : 		/* Don't release burst in homorganic plosiv-nasal & plos-plos sequence */
; 1255 : 		if ((feanex & (FNASAL | FPLOSV)) IS_PLUS)

  0160f	8a 4c 24 24	 mov	 cl, BYTE PTR _feanex$[esp+16]
  01613	83 c4 04	 add	 esp, 4
  01616	f6 c1 c0	 test	 cl, -64			; ffffffc0H
  01619	74 1e		 je	 SHORT $L71692

; 1256 : 		{
; 1257 : 			if (place[pDphsettar->phcur] == place[pDphsettar->phonex])

  0161b	0f bf 57 18	 movsx	 edx, WORD PTR [edi+24]
  0161f	0f bf 4f 0a	 movsx	 ecx, WORD PTR [edi+10]
  01623	66 8b 14 55 00
	00 00 00	 mov	 dx, WORD PTR _place[edx*2]
  0162b	66 3b 14 4d 00
	00 00 00	 cmp	 dx, WORD PTR _place[ecx*2]
  01633	75 04		 jne	 SHORT $L71692

; 1258 : 			{						   /* Was >= */
; 1259 : 				bdur = 0;

  01635	33 c0		 xor	 eax, eax

; 1260 : 			}
; 1261 : 		}
; 1262 : 
; 1263 : 	
; 1264 : 
; 1265 : 
; 1266 : 		if (bdur > 1)

  01637	eb 1d		 jmp	 SHORT $L71696
$L71692:
  01639	66 3d 01 00	 cmp	 ax, 1
  0163d	7e 17		 jle	 SHORT $L71696

; 1267 : 		{
; 1268 : 			if (((feacur & FPLOSV) IS_PLUS)
; 1269 : 				&& ((feanex & FOBST) IS_PLUS))

  0163f	f6 c3 40	 test	 bl, 64			; 00000040H
  01642	74 07		 je	 SHORT $L71694
  01644	f6 44 24 20 20	 test	 BYTE PTR _feanex$[esp+12], 32 ; 00000020H

; 1270 : 			{
; 1271 : 				bdur--;				   /* Shorten burst before obst by 6 ms */
; 1272 : 			}
; 1273 : 			else if (pDph_t->durfon < NF50MS)

  01649	75 0a		 jne	 SHORT $L72015
$L71694:
  0164b	66 83 be ac 11
	00 00 08	 cmp	 WORD PTR [esi+4524], 8
  01653	7d 01		 jge	 SHORT $L71696
$L72015:

; 1274 : 			{
; 1275 : 				bdur--;				   /* Shorten burst if closure short */

  01655	48		 dec	 eax
$L71696:

; 1276 : 			}
; 1277 : 		}
; 1278 : 
; 1279 : 		closure_dur = pDph_t->durfon - bdur;

  01656	66 8b 8e ac 11
	00 00		 mov	 cx, WORD PTR [esi+4524]
  0165d	66 2b c8	 sub	 cx, ax

; 1280 : 
; 1281 : 		if ((pDphsettar->phcur == CH) || (pDphsettar->phcur == JH))

  01660	66 8b 47 18	 mov	 ax, WORD PTR [edi+24]
  01664	66 3d 36 00	 cmp	 ax, 54			; 00000036H
  01668	74 06		 je	 SHORT $L71698
  0166a	66 3d 37 00	 cmp	 ax, 55			; 00000037H
  0166e	75 0b		 jne	 SHORT $L71699
$L71698:

; 1282 : 		{
; 1283 : 			if (closure_dur > NF80MS)

  01670	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  01674	7e 05		 jle	 SHORT $L71699

; 1284 : 				closure_dur = NF80MS;

  01676	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
$L71699:

; 1285 : 		}
; 1286 : 		for (pDphsettar->np = &PA2; pDphsettar->np <= &PAB; pDphsettar->np++)

  0167b	8d 96 68 01 00
	00		 lea	 edx, DWORD PTR [esi+360]
  01681	8d 86 1c 02 00
	00		 lea	 eax, DWORD PTR [esi+540]
  01687	3b d0		 cmp	 edx, eax
  01689	89 57 10	 mov	 DWORD PTR [edi+16], edx
  0168c	77 25		 ja	 SHORT $L71702
  0168e	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
$L71700:

; 1287 : 		{							   /* All fric gains to */
; 1288 : 			pDphsettar->np->tspesh = closure_dur;	/* zero during closur */

  01693	8b 6f 10	 mov	 ebp, DWORD PTR [edi+16]
  01696	66 89 4d 12	 mov	 WORD PTR [ebp+18], cx

; 1289 : 			pDphsettar->np->pspesh = 0;

  0169a	8b 6f 10	 mov	 ebp, DWORD PTR [edi+16]
  0169d	66 c7 45 14 00
	00		 mov	 WORD PTR [ebp+20], 0
  016a3	8b 6f 10	 mov	 ebp, DWORD PTR [edi+16]
  016a6	03 ea		 add	 ebp, edx
  016a8	3b e8		 cmp	 ebp, eax
  016aa	89 6f 10	 mov	 DWORD PTR [edi+16], ebp
  016ad	76 e4		 jbe	 SHORT $L71700

; 1285 : 		}
; 1286 : 		for (pDphsettar->np = &PA2; pDphsettar->np <= &PAB; pDphsettar->np++)

  016af	8b 6c 24 14	 mov	 ebp, DWORD PTR 8+[esp+12]
$L71702:

; 1290 : 		}
; 1291 : 	}
; 1292 : 	/* SPECIAL RULE 2: Voice onset time for aspirated plosives */
; 1293 : 
; 1294 : 	vot = 0;
; 1295 : 	if ((((fealas & FPLOSV) IS_PLUS)
; 1296 : 		 && ((fealas & FVOICD) IS_MINUS)
; 1297 : 		 && ((feacur & FSONOR) IS_PLUS ))) 

  016b3	8a 44 24 18	 mov	 al, BYTE PTR _fealas$[esp+12]
  016b7	a8 40		 test	 al, 64			; 00000040H
  016b9	0f 84 35 01 00
	00		 je	 $L71703
  016bf	a8 02		 test	 al, 2
  016c1	0f 85 2d 01 00
	00		 jne	 $L71703
  016c7	f6 c3 10	 test	 bl, 16			; 00000010H
  016ca	0f 84 24 01 00
	00		 je	 $L71703

; 1298 : 	{
; 1299 : 		PAP.pspesh = 57-5;			   /* Amplitude of aspiration in dB     */

  016d0	66 c7 86 58 01
	00 00 34 00	 mov	 WORD PTR [esi+344], 52	; 00000034H

; 1300 : 		if (begtyp[pDphsettar->phonex] != 1)

  016d9	0f bf 47 0a	 movsx	 eax, WORD PTR [edi+10]
  016dd	66 83 3c 45 00
	00 00 00 01	 cmp	 WORD PTR _begtyp[eax*2], 1
  016e6	74 09		 je	 SHORT $L71704

; 1301 : 		{
; 1302 : 			PAP.pspesh = 61-6;		   /* Stronger asp before +back */

  016e8	66 c7 86 58 01
	00 00 37 00	 mov	 WORD PTR [esi+344], 55	; 00000037H
$L71704:

; 1303 : 		}
; 1304 : 		PAV.pspesh = 0;				   /* Amplitude of voicing during aspir */
; 1305 : 
; 1306 : 
; 1307 : 		vot = NF40MS;				   /* Asp dur for /p,t,k/ before stressed sonor */
; 1308 : 		if ((struccur & FSTRESS_1) IS_MINUS)

  016f1	8b 6c 24 28	 mov	 ebp, DWORD PTR _struccur$[esp+12]
  016f5	66 c7 86 34 01
	00 00 00 00	 mov	 WORD PTR [esi+308], 0
  016fe	83 e5 01	 and	 ebp, 1
  01701	b8 06 00 00 00	 mov	 eax, 6
  01706	66 85 ed	 test	 bp, bp
  01709	75 0d		 jne	 SHORT $L71705

; 1309 : 		{
; 1310 : 			vot = NF25MS;			   /* Vot shorter if vowel not stressed */
; 1311 : 			PAP.pspesh -= 3;

  0170b	66 83 86 58 01
	00 00 fd	 add	 WORD PTR [esi+344], -3	; fffffffdH
  01713	b8 04 00 00 00	 mov	 eax, 4
$L71705:

; 1312 : 		}
; 1313 : 		if (((feacur & FSONCON) IS_PLUS) || (pDphsettar->phcur == RR))

  01718	8b cb		 mov	 ecx, ebx
  0171a	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  01720	66 85 c9	 test	 cx, cx
  01723	75 07		 jne	 SHORT $L71707
  01725	66 83 7f 18 0f	 cmp	 WORD PTR [edi+24], 15	; 0000000fH
  0172a	75 08		 jne	 SHORT $L71706
$L71707:

; 1314 : 		{
; 1315 : 			PAP.pspesh += 3;		   /* Aspiration stronger in sonor cons */

  0172c	66 83 86 58 01
	00 00 03	 add	 WORD PTR [esi+344], 3
$L71706:

; 1316 : 		}
; 1317 : 
; 1318 : 		/* eab 2/6/976 Found code that was causing after Murhty port. Vlaue of pholm2
; 1319 : 		was not being retained- substituted global variables that already exsist
; 1320 : 		after release the old and I think vestigal variables need to be removed
; 1321 : 		this problem affect all languages but in fact the code didn't exist in German
; 1322 : 		at all but was needed don't know is struclm2 is working either*/
; 1323 : 
; 1324 : 		if ( featb[pDph_t->allophons[pDph_t->nphone -2]] == (FOBST+FCONSON ))          

  01734	0f bf 96 1c 20
	00 00		 movsx	 edx, WORD PTR [esi+8220]
  0173b	0f bf 8c 56 fe
	02 00 00	 movsx	 ecx, WORD PTR [esi+edx*2+766]
  01743	66 81 3c 4d 00
	00 00 00 20 01	 cmp	 WORD PTR _featb[ecx*2], 288 ; 00000120H
  0174d	75 16		 jne	 SHORT $L71708

; 1325 : 		{
; 1326 : 			if ((struclm2 & FBOUNDARY) IS_MINUS )

  0174f	8b 54 24 24	 mov	 edx, DWORD PTR _struclm2$[esp+12]
  01753	81 e2 e0 01 00
	00		 and	 edx, 480		; 000001e0H
  01759	66 85 d2	 test	 dx, dx
  0175c	75 0f		 jne	 SHORT $L71711

; 1327 : 			{
; 1328 : 				vot = NF15MS;	   

  0175e	b8 02 00 00 00	 mov	 eax, 2

; 1329 : 			}
; 1330 : 		}
; 1331 : 		else if (((feacur & FSYLL) IS_MINUS))

  01763	eb 08		 jmp	 SHORT $L71711
$L71708:
  01765	f6 c3 01	 test	 bl, 1
  01768	75 03		 jne	 SHORT $L71711

; 1332 : 		{
; 1333 : 			vot += NF20MS;			   /* Vot longer in a sonorant consonant */

  0176a	83 c0 03	 add	 eax, 3
$L71711:

; 1334 : 		}
; 1335 : 		if (vot >= pDph_t->durfon)

  0176d	66 8b 8e ac 11
	00 00		 mov	 cx, WORD PTR [esi+4524]
  01774	66 3b c1	 cmp	 ax, cx
  01777	7c 03		 jl	 SHORT $L71712

; 1336 : 		{
; 1337 : 			vot = pDph_t->durfon - 1;

  01779	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
$L71712:

; 1338 : 			
; 1339 : 		}
; 1340 : 		/* Vot cannot exceed 1/2 duration of a stressed vowel */
; 1341 : 		if ((vot > (pDph_t->durfon >> 1))
; 1342 : 			&& ((feacur & FSYLL) IS_PLUS)
; 1343 : 			&& ((struccur & FSTRESS_1) IS_PLUS))

  0177c	66 8b d1	 mov	 dx, cx
  0177f	66 d1 fa	 sar	 dx, 1
  01782	66 3b c2	 cmp	 ax, dx
  01785	7e 0c		 jle	 SHORT $L71713
  01787	f6 c3 01	 test	 bl, 1
  0178a	74 07		 je	 SHORT $L71713
  0178c	66 85 ed	 test	 bp, bp
  0178f	74 02		 je	 SHORT $L71713

; 1344 : 		{
; 1345 : 			vot = pDph_t->durfon >> 1;

  01791	8b c2		 mov	 eax, edx
$L71713:

; 1346 : 		}
; 1347 : 		/* A dummy vowel is used to release a voiceless plosive into silence */
; 1348 : 		if ((struccur & FDUMMY_VOWEL) IS_PLUS)

  01793	8b 54 24 28	 mov	 edx, DWORD PTR _struccur$[esp+12]
  01797	81 e2 00 08 00
	00		 and	 edx, 2048		; 00000800H
  0179d	66 85 d2	 test	 dx, dx
  017a0	74 0a		 je	 SHORT $L71714

; 1349 : 		{
; 1350 : 			vot = pDph_t->durfon;
; 1351 : 			PAP.pspesh -= 3;

  017a2	66 83 86 58 01
	00 00 fd	 add	 WORD PTR [esi+344], -3	; fffffffdH
  017aa	8b c1		 mov	 eax, ecx
$L71714:

; 1352 : 		}
; 1353 : 		/* eab in fast mode we simply when to model a much reduced faster
; 1354 : 		release--no time to build up large pressures*/
; 1355 : 
; 1356 : #ifdef FASTTYPING_MODE
; 1357 : 		if(phTTS->bInTypingMode == TRUE || pKsd_t->sprate >300)
; 1358 : 		{
; 1359 : 			
; 1360 : 			vot=vot>>2;
; 1361 : 			if(vot == 0)
; 1362 : 				vot=1;
; 1363 : 		
; 1364 : 
; 1365 : 		PAV.pspesh += 20;
; 1366 : 		PAP.pspesh -=5;
; 1367 : 		}
; 1368 : #endif
; 1369 : 		PAV.tspesh = vot;
; 1370 : 		PAP.tspesh = vot;/* have aspiration continue into vowel*/
; 1371 : 
; 1372 : 		/* Widen 1st and 2nd formant bws when glottis open for aspir */
; 1373 : 		PB1.tspesh = vot;
; 1374 : 		PB2.tspesh = vot;
; 1375 : 		PB1.pspesh = PB1.tarcur + 250;
; 1376 : 		PB2.pspesh = PB2.tarcur + 70;

  017ac	66 8b 8e d8 00
	00 00		 mov	 cx, WORD PTR [esi+216]
  017b3	8b 6c 24 14	 mov	 ebp, DWORD PTR 8+[esp+12]
  017b7	66 89 86 32 01
	00 00		 mov	 WORD PTR [esi+306], ax
  017be	66 89 86 56 01
	00 00		 mov	 WORD PTR [esi+342], ax
  017c5	66 89 86 c6 00
	00 00		 mov	 WORD PTR [esi+198], ax
  017cc	66 89 86 ea 00
	00 00		 mov	 WORD PTR [esi+234], ax
  017d3	66 8b 86 b4 00
	00 00		 mov	 ax, WORD PTR [esi+180]
  017da	66 05 fa 00	 add	 ax, 250			; 000000faH
  017de	66 83 c1 46	 add	 cx, 70			; 00000046H
  017e2	66 89 86 c8 00
	00 00		 mov	 WORD PTR [esi+200], ax
  017e9	8a 44 24 18	 mov	 al, BYTE PTR _fealas$[esp+12]
  017ed	66 89 8e ec 00
	00 00		 mov	 WORD PTR [esi+236], cx
$L71703:

; 1377 : 	}
; 1378 : 	/* SPECIAL RULE 3: Create realistic voicebar, avoid pops and clicks */
; 1379 : 	/* Amp of voicebar set here, AV target in table invalid */
; 1380 : 	/* Set AV=0 for last 12.8 ms, let AV die out, thus avoid click */
; 1381 : 	/* Set to under 250 to signal voicebar */
; 1382 :   
; 1383 : 	/* Problem: spectrum has too much F4 if f2,3 are high, as in [i] */
; 1384 : 	if (((feacur & FBURST) IS_PLUS)
; 1385 : 		&& ((feacur & FVOICD) IS_PLUS)
; 1386 : 		&& ((fealas & FVOICD) IS_PLUS)
; 1387 : 		&& ((feanex & FVOICD) IS_MINUS)		/* Voicebar only if next -V */
; 1388 : 		&& (pDphsettar->phcur != TX))

  017f4	66 85 ed	 test	 bp, bp
  017f7	74 62		 je	 SHORT $L71715
  017f9	f6 c3 02	 test	 bl, 2
  017fc	74 5d		 je	 SHORT $L71715
  017fe	a8 02		 test	 al, 2
  01800	74 59		 je	 SHORT $L71715
  01802	f6 44 24 20 02	 test	 BYTE PTR _feanex$[esp+12], 2
  01807	75 52		 jne	 SHORT $L71715
  01809	66 83 7f 18 34	 cmp	 WORD PTR [edi+24], 52	; 00000034H
  0180e	74 4b		 je	 SHORT $L71715

; 1389 : 	{
; 1390 : 		PAV.tspesh = pDph_t->durfon - NF15MS;

  01810	66 8b 86 ac 11
	00 00		 mov	 ax, WORD PTR [esi+4524]

; 1391 : 		PB1.tspesh = pDph_t->durfon;
; 1392 : 		PB2.tspesh = pDph_t->durfon;
; 1393 : 		PB3.tspesh = pDph_t->durfon;
; 1394 : 		PAV.pspesh = 10;			   /* Large since low-pass TILT attenuates it 

  01817	66 c7 86 34 01
	00 00 0a 00	 mov	 WORD PTR [esi+308], 10	; 0000000aH
  01820	66 89 86 c6 00
	00 00		 mov	 WORD PTR [esi+198], ax
  01827	66 89 86 ea 00
	00 00		 mov	 WORD PTR [esi+234], ax
  0182e	8d 50 fe	 lea	 edx, DWORD PTR [eax-2]
  01831	66 89 86 0e 01
	00 00		 mov	 WORD PTR [esi+270], ax

; 1395 : 							eab voicebars can be trouble and are not really perceptual*/
; 1396 : 		PB1.pspesh = 1000;

  01838	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  0183d	66 89 96 32 01
	00 00		 mov	 WORD PTR [esi+306], dx
  01844	66 89 86 c8 00
	00 00		 mov	 WORD PTR [esi+200], ax

; 1397 : 		PB2.pspesh = 1000;

  0184b	66 89 86 ec 00
	00 00		 mov	 WORD PTR [esi+236], ax

; 1398 : 		PB3.pspesh = 1500;

  01852	66 c7 86 10 01
	00 00 dc 05	 mov	 WORD PTR [esi+272], 1500 ; 000005dcH
$L71715:
  0185b	5f		 pop	 edi
  0185c	5e		 pop	 esi
  0185d	5d		 pop	 ebp
  0185e	5b		 pop	 ebx

; 1399 : 	}
; 1400 : }

  0185f	c3		 ret	 0
_special_rules ENDP
_TEXT	ENDS
EXTRN	_plocu:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_nfonobst$ = 12
_nfonsonor$ = 16
_initfinso$ = 20
_nfonvowel$ = 24
_fonobst$ = -24
_fonsonor$ = -16
_fonvowel$ = -12
_typso$ = -28
_f2backaffil$ = -4
_curval$ = -20
_prcnt$ = 16
_setloc	PROC NEAR

; 70   : 	/* Automatic variables */
; 71   : 	short                   fonobst, fonsonor, fonvowel, typob, typso, f2backaffil, curval, tarvowel;
; 72   : 	short                   sontyx, ploc, locus, prcnt, delta_freq;
; 73   : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  01860	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  01864	83 ec 1c	 sub	 esp, 28			; 0000001cH
  01867	53		 push	 ebx
  01868	55		 push	 ebp
  01869	56		 push	 esi
  0186a	8b 70 18	 mov	 esi, DWORD PTR [eax+24]

; 74   : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 75   : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;
; 76   : 
; 77   : 	/* Convert phoneme pointers into phoneme names */
; 78   : 	fonobst = get_phone (pDph_t, nfonobst);

  0186d	66 8b 44 24 30	 mov	 ax, WORD PTR _nfonobst$[esp+36]
  01872	33 ed		 xor	 ebp, ebp
  01874	57		 push	 edi
  01875	8b be 48 28 00
	00		 mov	 edi, DWORD PTR [esi+10312]
  0187b	66 3b c5	 cmp	 ax, bp
  0187e	7c 1a		 jl	 SHORT $L72017
  01880	66 3b 86 ae 11
	00 00		 cmp	 ax, WORD PTR [esi+4526]
  01887	7d 11		 jge	 SHORT $L72017
  01889	0f bf c8	 movsx	 ecx, ax
  0188c	66 8b 84 4e 02
	03 00 00	 mov	 ax, WORD PTR [esi+ecx*2+770]
  01894	89 44 24 14	 mov	 DWORD PTR _fonobst$[esp+44], eax
  01898	eb 06		 jmp	 SHORT $L72018
$L72017:
  0189a	89 6c 24 14	 mov	 DWORD PTR _fonobst$[esp+44], ebp
  0189e	8b c5		 mov	 eax, ebp
$L72018:

; 79   : 	fonsonor = get_phone (pDph_t, nfonsonor);

  018a0	8b 54 24 38	 mov	 edx, DWORD PTR _nfonsonor$[esp+40]
  018a4	66 3b d5	 cmp	 dx, bp
  018a7	7c 1a		 jl	 SHORT $L72019
  018a9	66 3b 96 ae 11
	00 00		 cmp	 dx, WORD PTR [esi+4526]
  018b0	7d 11		 jge	 SHORT $L72019
  018b2	0f bf ca	 movsx	 ecx, dx
  018b5	66 8b 8c 4e 02
	03 00 00	 mov	 cx, WORD PTR [esi+ecx*2+770]
  018bd	89 4c 24 1c	 mov	 DWORD PTR _fonsonor$[esp+44], ecx
  018c1	eb 06		 jmp	 SHORT $L72020
$L72019:
  018c3	89 6c 24 1c	 mov	 DWORD PTR _fonsonor$[esp+44], ebp
  018c7	8b cd		 mov	 ecx, ebp
$L72020:

; 80   : 	fonvowel = get_phone (pDph_t, nfonvowel);

  018c9	8b 5c 24 40	 mov	 ebx, DWORD PTR _nfonvowel$[esp+40]
  018cd	66 3b dd	 cmp	 bx, bp
  018d0	7c 1b		 jl	 SHORT $L72021
  018d2	66 3b 9e ae 11
	00 00		 cmp	 bx, WORD PTR [esi+4526]
  018d9	7d 12		 jge	 SHORT $L72021
  018db	0f bf db	 movsx	 ebx, bx
  018de	66 8b 9c 5e 02
	03 00 00	 mov	 bx, WORD PTR [esi+ebx*2+770]
  018e6	66 89 5c 24 20	 mov	 WORD PTR _fonvowel$[esp+44], bx
  018eb	eb 04		 jmp	 SHORT $L72022
$L72021:
  018ed	89 6c 24 20	 mov	 DWORD PTR _fonvowel$[esp+44], ebp
$L72022:

; 81   : 	/* Use values at beginning of the sonorant */
; 82   : 	if (initfinso == 'i')

  018f1	8a 5c 24 3c	 mov	 bl, BYTE PTR _initfinso$[esp+40]

; 83   : 	{
; 84   : 		typob = endtyp[fonobst];

  018f5	0f bf e8	 movsx	 ebp, ax
  018f8	80 fb 69	 cmp	 bl, 105			; 00000069H
  018fb	8d 44 2d 00	 lea	 eax, DWORD PTR [ebp+ebp]
  018ff	89 44 24 24	 mov	 DWORD PTR -8+[esp+44], eax
  01903	75 15		 jne	 SHORT $L71746
  01905	66 8b 80 00 00
	00 00		 mov	 ax, WORD PTR _endtyp[eax]

; 85   : 		typso = begtyp[fonsonor];

  0190c	0f bf d9	 movsx	 ebx, cx
  0190f	d1 e3		 shl	 ebx, 1
  01911	66 8b 8b 00 00
	00 00		 mov	 cx, WORD PTR _begtyp[ebx]

; 86   : 	}
; 87   : 	else

  01918	eb 13		 jmp	 SHORT $L72024
$L71746:

; 88   : 	{								   /* Or at the end of the sonorant */
; 89   : 		typob = begtyp[fonobst];

  0191a	66 8b 80 00 00
	00 00		 mov	 ax, WORD PTR _begtyp[eax]

; 90   : 		typso = endtyp[fonsonor];

  01921	0f bf d9	 movsx	 ebx, cx
  01924	d1 e3		 shl	 ebx, 1
  01926	66 8b 8b 00 00
	00 00		 mov	 cx, WORD PTR _endtyp[ebx]
$L72024:
  0192d	66 89 4c 24 10	 mov	 WORD PTR _typso$[esp+44], cx

; 91   : 	}
; 92   : 
; 93   : 	if ((pDphsettar->np > &PF3) || (typob != OBSTRUENT) || (typso == OBSTRUENT))

  01932	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  01935	39 4f 10	 cmp	 DWORD PTR [edi+16], ecx
  01938	0f 87 45 02 00
	00		 ja	 $L71749
  0193e	66 3d 04 00	 cmp	 ax, 4
  01942	0f 85 3b 02 00
	00		 jne	 $L71749
  01948	66 39 44 24 10	 cmp	 WORD PTR _typso$[esp+44], ax
  0194d	0f 84 30 02 00
	00		 je	 $L71749

; 96   : 	}
; 97   : 	if (initfinso == 'i')

  01953	8a 44 24 3c	 mov	 al, BYTE PTR _initfinso$[esp+40]
  01957	3c 69		 cmp	 al, 105			; 00000069H

; 98   : 	{
; 99   : 		f2backaffil = place[fonsonor] & F2BACKI;

  01959	8a 83 00 00 00
	00		 mov	 al, BYTE PTR _place[ebx]
  0195f	75 14		 jne	 SHORT $L71750

; 100  : 		curval = getbegtar (phTTS, nfonsonor);

  01961	8b 4c 24 30	 mov	 ecx, DWORD PTR _phTTS$[esp+40]
  01965	83 e0 40	 and	 eax, 64			; 00000040H
  01968	52		 push	 edx
  01969	51		 push	 ecx
  0196a	89 44 24 30	 mov	 DWORD PTR _f2backaffil$[esp+52], eax
  0196e	e8 00 00 00 00	 call	 _getbegtar

; 101  : 	}
; 102  : 	else

  01973	eb 14		 jmp	 SHORT $L72025
$L71750:

; 103  : 	{								   /* Or at the end of the sonorant */
; 104  : 		f2backaffil = place[fonsonor] & F2BACKF;
; 105  : 		curval = getendtar (phTTS, nfonsonor);

  01975	8b 4c 24 30	 mov	 ecx, DWORD PTR _phTTS$[esp+40]
  01979	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0197e	52		 push	 edx
  0197f	51		 push	 ecx
  01980	89 44 24 30	 mov	 DWORD PTR _f2backaffil$[esp+52], eax
  01984	e8 00 00 00 00	 call	 _getendtar
$L72025:
  01989	89 44 24 20	 mov	 DWORD PTR _curval$[esp+52], eax

; 106  : 	}
; 107  : 	sontyx = typso;

  0198d	8b 44 24 18	 mov	 eax, DWORD PTR _typso$[esp+52]
  01991	83 c4 08	 add	 esp, 8

; 108  : #ifdef ENGLISH
; 109  : 	if (typso == ROUNDED_SONOR_CONS)   /* If sonorant is rounded conson, */

  01994	66 3d 05 00	 cmp	 ax, 5
  01998	75 05		 jne	 SHORT $L71752

; 110  : 		sontyx = BACK_ROUNDED_VOWEL;   /* use C locus for rounded vowel */

  0199a	b8 03 00 00 00	 mov	 eax, 3
$L71752:

; 111  : #endif
; 112  : #ifdef GERMAN
; 113  : 	if (typso == ROUNDED_SONOR_CONS)
; 114  : 	{								   /* If sonorant is rounded conson, */
; 115  : 		/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 116  : 		/* use BACK_VOWEL instead of BACK_ROUNDED_VOWEL           
; 117  : 		
; 118  : 
; 119  : 		/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 120  : 		sontyx = BACK_VOWEL;		   /* use locus for back vowel %%%%%%% */
; 121  : 	}
; 122  : 	/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 123  : 	/* 'low' class is fourth entry in plocu              */
; 124  : 	/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 125  : 	if (typso == LOW_VOWEL)
; 126  : 	{								   /* If sonorant is low vowel */
; 127  : 		sontyx = 2;					   /* use back instead */
; 128  : 	}
; 129  : 	/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 130  : 	/* Pointer into locus data comes from one of 4 tables for        */
; 131  : 	/* front-unrounded, back, front-rounded, low vowels.     */
; 132  : 	/* sontyx now equals 1, 2, 3, or 4                   */
; 133  : 	/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 134  : #endif
; 135  : 
; 136  : 	/* Pointer into locus data comes from one of 3 tables for front, back, */
; 137  : 	/* and rounded vowels, sontyx now equals 1,2, or 3 */
; 138  : 	ploc = plocu[(fonobst + (SIZTARTAB * (sontyx - 1)))];

  0199f	0f bf c0	 movsx	 eax, ax
  019a2	8d 14 c0	 lea	 edx, DWORD PTR [eax+eax*8]
  019a5	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  019a8	8d 4c 45 00	 lea	 ecx, DWORD PTR [ebp+eax*2]
  019ac	03 c1		 add	 eax, ecx
  019ae	66 8b 2c 45 8e
	ff ff ff	 mov	 bp, WORD PTR _plocu[eax*2-114]

; 139  : 	if (ploc == 0)					   /* Pointer to locus, zero means */

  019b6	66 85 ed	 test	 bp, bp

; 140  : 		return (0);					   /* no locus, use default calc  */

  019b9	0f 84 c4 01 00
	00		 je	 $L71749

; 141  : 	ploc = ploc + (3 * (pDphsettar->np - &PF1));	/* Table has 3 entries/formant  */

  019bf	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  019c2	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  019c7	2b ce		 sub	 ecx, esi
  019c9	83 e9 24	 sub	 ecx, 36			; 00000024H
  019cc	f7 e9		 imul	 ecx
  019ce	c1 fa 03	 sar	 edx, 3
  019d1	8b c2		 mov	 eax, edx
  019d3	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  019d6	03 d0		 add	 edx, eax
  019d8	8d 0c 2a	 lea	 ecx, DWORD PTR [edx+ebp]
  019db	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]

; 142  : 	locus = pDph_t->p_locus[ploc];	   /* First entry is locus freq   */

  019de	8b 8e b4 11 00
	00		 mov	 ecx, DWORD PTR [esi+4532]
  019e4	0f bf c0	 movsx	 eax, ax
  019e7	66 8b 2c 41	 mov	 bp, WORD PTR [ecx+eax*2]

; 143  : 	prcnt = pDph_t->p_locus[ploc + 1]; /* Second entry is % toward V  */

  019eb	66 8b 54 41 02	 mov	 dx, WORD PTR [ecx+eax*2+2]

; 144  : 	pDphsettar->durtran = mstofr (pDph_t->p_locus[ploc + 2]);	/* 3rd is tran dur in msec  */

  019f0	0f bf 44 41 04	 movsx	 eax, WORD PTR [ecx+eax*2+4]
  019f5	50		 push	 eax
  019f6	66 89 54 24 3c	 mov	 WORD PTR _prcnt$[esp+44], dx
  019fb	e8 00 00 00 00	 call	 _mstofr
  01a00	83 c4 04	 add	 esp, 4

; 145  : /*#ifdef ENGLISH 1/3/97 eab I think this should apply generally*/
; 146  : 	/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 147  : 	/* take transition reduction out for german DECtalk      */
; 148  : 	/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 149  : 	/* Reduce F2 and F3 transition in a sonor conson adj to nonpalatal obst */
; 150  : 	if ((typso == ROUNDED_SONOR_CONS) && (pDphsettar->np > &PF1)
; 151  : 		&& ((place[fonobst] & (FPALATL | FDENTAL)) IS_MINUS))

  01a03	66 83 7c 24 10
	05		 cmp	 WORD PTR _typso$[esp+44], 5
  01a09	66 89 47 06	 mov	 WORD PTR [edi+6], ax
  01a0d	75 28		 jne	 SHORT $L72023
  01a0f	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  01a12	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  01a15	3b d1		 cmp	 edx, ecx
  01a17	76 1e		 jbe	 SHORT $L72023
  01a19	8b 54 24 24	 mov	 edx, DWORD PTR -8+[esp+44]
  01a1d	f6 82 00 00 00
	00 06		 test	 BYTE PTR _place[edx], 6
  01a24	75 11		 jne	 SHORT $L72023

; 152  : 	{
; 153  : 		prcnt = (prcnt >> 1) + 50;

  01a26	66 8b 4c 24 38	 mov	 cx, WORD PTR _prcnt$[esp+40]
  01a2b	66 d1 f9	 sar	 cx, 1
  01a2e	83 c1 32	 add	 ecx, 50			; 00000032H
  01a31	89 4c 24 38	 mov	 DWORD PTR _prcnt$[esp+40], ecx
  01a35	eb 04		 jmp	 SHORT $L71754
$L72023:
  01a37	8b 4c 24 38	 mov	 ecx, DWORD PTR _prcnt$[esp+40]
$L71754:

; 154  : 	} 
; 155  : 	
; 156  : 	/* @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ */
; 157  : /*#endif*/
; 158  : 	/* Ditto for vowel/sonor with F2 assoc with back cavity, e.g. [iy] */
; 159  : 	if ((f2backaffil IS_PLUS) && (pDphsettar->np == &PF2))

  01a3b	66 83 7c 24 28
	00		 cmp	 WORD PTR _f2backaffil$[esp+44], 0
  01a41	74 27		 je	 SHORT $L71755
  01a43	8d 56 48	 lea	 edx, DWORD PTR [esi+72]
  01a46	39 57 10	 cmp	 DWORD PTR [edi+16], edx
  01a49	75 1f		 jne	 SHORT $L71755

; 160  : 	{
; 161  : 		prcnt += (25 - (prcnt >> 2));  /* Reduce trans extent by 1/4 */

  01a4b	66 c1 f9 02	 sar	 cx, 2
  01a4f	ba 19 00 00 00	 mov	 edx, 25			; 00000019H
  01a54	2b d1		 sub	 edx, ecx
  01a56	8b 4c 24 38	 mov	 ecx, DWORD PTR _prcnt$[esp+40]

; 162  : 		pDphsettar->durtran = (pDphsettar->durtran >> 1) + 2;	/* And shorten tran dur */

  01a5a	66 d1 f8	 sar	 ax, 1
  01a5d	03 ca		 add	 ecx, edx
  01a5f	83 c0 02	 add	 eax, 2
  01a62	89 4c 24 38	 mov	 DWORD PTR _prcnt$[esp+40], ecx
  01a66	66 89 47 06	 mov	 WORD PTR [edi+6], ax
$L71755:

; 163  : 	}
; 164  : 	/* Let bouval = locus + ((prcnt * (curval-locus)) / 100); */
; 165  : 	/* Old approximation (no divides):                       */
; 166  : 	/* delta_freq = (prcnt * (curval-locus)) >> 7;            */
; 167  : 	/* bouval = locus + delta_freq + (delta_freq >> 2);    */
; 168  : 	/* End of old approximation                              */
; 169  : 	pDph_t->arg1 = prcnt;
; 170  : #ifdef ENGLISH_UK
; 171  : 	
; 172  : 	/*eab 11/19/97  first cut just for ch but probably should be for all plos*/
; 173  : 	if (initfinso != 'i' && fonobst == 54)
; 174  : 	{
; 175  : 		pDph_t->arg1 = prcnt+40;
; 176  : 		if(pDph_t->arg1 >100 )
; 177  : 			pDph_t->arg1=100;
; 178  : 	}
; 179  : #endif
; 180  : 
; 181  : 	pDph_t->arg2 = curval - locus;

  01a6a	8b 44 24 18	 mov	 eax, DWORD PTR _curval$[esp+44]
  01a6e	66 89 8e c4 11
	00 00		 mov	 WORD PTR [esi+4548], cx
  01a75	2b c5		 sub	 eax, ebp

; 182  : 	pDph_t->arg3 = 100;

  01a77	66 c7 86 c8 11
	00 00 64 00	 mov	 WORD PTR [esi+4552], 100 ; 00000064H
  01a80	0f bf d1	 movsx	 edx, cx

; 183  : 	delta_freq = muldv (pDph_t->arg1, pDph_t->arg2, pDph_t->arg3);
; 184  : 	pDphsettar->bouval = locus + delta_freq;

  01a83	0f bf c8	 movsx	 ecx, ax
  01a86	0f af ca	 imul	 ecx, edx
  01a89	66 89 86 c6 11
	00 00		 mov	 WORD PTR [esi+4550], ax
  01a90	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  01a95	89 54 24 28	 mov	 DWORD PTR -4+[esp+44], edx
  01a99	f7 e9		 imul	 ecx
  01a9b	c1 fa 05	 sar	 edx, 5
  01a9e	8b c2		 mov	 eax, edx
  01aa0	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  01aa3	03 d0		 add	 edx, eax
  01aa5	03 d5		 add	 edx, ebp
  01aa7	66 89 17	 mov	 WORD PTR [edi], dx

; 185  : 
; 186  : #ifdef   DEBUG_TARGETS
; 187  : 	printf ("locus %d delta_freq %d \n", locus, delta_freq);
; 188  : 	printf ("pDphsettar->bouval %d \n", pDphsettar->bouval);
; 189  : #endif
; 190  : 	/* V-V coarticulation across an obst consonant: */
; 191  : 	if (((featb[fonsonor] & FVOWEL) IS_PLUS)
; 192  : 		&& ((featb[fonvowel] & FVOWEL) IS_PLUS)
; 193  : 		&& (pDphsettar->np == &PF2))

  01aaa	8a 83 00 00 00
	00		 mov	 al, BYTE PTR _featb[ebx]
  01ab0	a8 04		 test	 al, 4
  01ab2	0f 84 bf 00 00
	00		 je	 $L71756
  01ab8	0f bf 4c 24 20	 movsx	 ecx, WORD PTR _fonvowel$[esp+44]
  01abd	f6 04 4d 00 00
	00 00 04	 test	 BYTE PTR _featb[ecx*2], 4
  01ac5	0f 84 ac 00 00
	00		 je	 $L71756
  01acb	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  01ace	8d 56 48	 lea	 edx, DWORD PTR [esi+72]
  01ad1	3b c2		 cmp	 eax, edx
  01ad3	0f 85 9e 00 00
	00		 jne	 $L71756

; 194  : 	{
; 195  : 		/* Find target values for both vowels */
; 196  : 		if (initfinso == 'i')

  01ad9	80 7c 24 3c 69	 cmp	 BYTE PTR _initfinso$[esp+40], 105 ; 00000069H
  01ade	75 11		 jne	 SHORT $L71757

; 197  : 		{
; 198  : 			tarvowel = getendtar (phTTS, nfonvowel);

  01ae0	8b 44 24 40	 mov	 eax, DWORD PTR _nfonvowel$[esp+40]
  01ae4	8b 4c 24 30	 mov	 ecx, DWORD PTR _phTTS$[esp+40]
  01ae8	50		 push	 eax
  01ae9	51		 push	 ecx
  01aea	e8 00 00 00 00	 call	 _getendtar

; 199  : 		}
; 200  : 		else

  01aef	eb 0f		 jmp	 SHORT $L72026
$L71757:

; 201  : 		{
; 202  : 			tarvowel = getbegtar (phTTS, nfonvowel);

  01af1	8b 54 24 40	 mov	 edx, DWORD PTR _nfonvowel$[esp+40]
  01af5	8b 44 24 30	 mov	 eax, DWORD PTR _phTTS$[esp+40]
  01af9	52		 push	 edx
  01afa	50		 push	 eax
  01afb	e8 00 00 00 00	 call	 _getbegtar
$L72026:

; 203  : 		}
; 204  : 		/* Set vvbouval, the offset to boundary value due to the remote vowel */
; 205  : 		vv_coartic_across_c (pDph_t, fonvowel, tarvowel, fonsonor, curval,
; 206  : 							 fonobst, pDph_t->allodurs[nfonobst]);

  01b00	0f bf 4c 24 3c	 movsx	 ecx, WORD PTR _nfonobst$[esp+48]
  01b05	8b 5c 24 20	 mov	 ebx, DWORD PTR _curval$[esp+52]
  01b09	83 c4 08	 add	 esp, 8
  01b0c	66 8b 94 4e 48
	0a 00 00	 mov	 dx, WORD PTR [esi+ecx*2+2632]
  01b14	8b 4c 24 14	 mov	 ecx, DWORD PTR _fonobst$[esp+44]
  01b18	52		 push	 edx
  01b19	8b 54 24 20	 mov	 edx, DWORD PTR _fonsonor$[esp+48]
  01b1d	51		 push	 ecx
  01b1e	53		 push	 ebx
  01b1f	52		 push	 edx
  01b20	50		 push	 eax
  01b21	8b 44 24 34	 mov	 eax, DWORD PTR _fonvowel$[esp+64]
  01b25	50		 push	 eax
  01b26	56		 push	 esi
  01b27	e8 00 00 00 00	 call	 _vv_coartic_across_c

; 207  : 		/* Now recompute boundary value taking into account this offset */
; 208  : 		curval += pDphsettar->vvbouval;

  01b2c	66 8b 4f 04	 mov	 cx, WORD PTR [edi+4]

; 209  : 		pDph_t->arg1 = prcnt;

  01b30	66 8b 54 24 54	 mov	 dx, WORD PTR _prcnt$[esp+68]
  01b35	03 d9		 add	 ebx, ecx
  01b37	66 89 96 c4 11
	00 00		 mov	 WORD PTR [esi+4548], dx

; 210  : 		pDph_t->arg2 = curval - locus;

  01b3e	8b c3		 mov	 eax, ebx

; 211  : 		pDph_t->arg3 = 100;

  01b40	66 c7 86 c8 11
	00 00 64 00	 mov	 WORD PTR [esi+4552], 100 ; 00000064H
  01b49	2b c5		 sub	 eax, ebp
  01b4b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 212  : 		delta_freq = muldv (pDph_t->arg1, pDph_t->arg2, pDph_t->arg3);
; 213  : 		pDphsettar->bouval = locus + delta_freq;
; 214  : 		pDphsettar->bouval -= pDphsettar->vvbouval;		/* pDphsettar->vvbouval will be added in phdraw */

  01b4e	0f bf c8	 movsx	 ecx, ax
  01b51	0f af 4c 24 28	 imul	 ecx, DWORD PTR -4+[esp+44]
  01b56	66 89 86 c6 11
	00 00		 mov	 WORD PTR [esi+4550], ax
  01b5d	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  01b62	f7 e9		 imul	 ecx
  01b64	c1 fa 05	 sar	 edx, 5
  01b67	8b c2		 mov	 eax, edx
  01b69	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  01b6c	03 d0		 add	 edx, eax
  01b6e	66 2b 57 04	 sub	 dx, WORD PTR [edi+4]
  01b72	03 d5		 add	 edx, ebp
  01b74	66 89 17	 mov	 WORD PTR [edi], dx
$L71756:
  01b77	5f		 pop	 edi
  01b78	5e		 pop	 esi
  01b79	5d		 pop	 ebp

; 215  : 	}
; 216  : 
; 217  : #ifdef DEBUG_TARGETS
; 218  : 	printf ("\t\t\t      (vtar = %4d  locus[%d] = %4d Hz  prcnt = %3d)\n",
; 219  : 			curval, ploc, locus, pDph_t->p_locus[ploc + 1]);
; 220  : #endif
; 221  : 
; 222  : 	return (1);						   /* Indicate success */

  01b7a	66 b8 01 00	 mov	 ax, 1
  01b7e	5b		 pop	 ebx

; 223  : }

  01b7f	83 c4 1c	 add	 esp, 28			; 0000001cH
  01b82	c3		 ret	 0
$L71749:
  01b83	5f		 pop	 edi
  01b84	5e		 pop	 esi
  01b85	5d		 pop	 ebp

; 94   : 	{
; 95   : 		return (0);					   /* Not obstruent-sonorant tran, as assumed */

  01b86	66 33 c0	 xor	 ax, ax
  01b89	5b		 pop	 ebx

; 223  : }

  01b8a	83 c4 1c	 add	 esp, 28			; 0000001cH
  01b8d	c3		 ret	 0
_setloc	ENDP
_pDph_t$ = 8
_remotetar$ = 16
_currenttar$ = 24
_dur_cons$ = 32
_vv_coartic_across_c PROC NEAR

; 253  : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;

  01b90	8b 54 24 04	 mov	 edx, DWORD PTR _pDph_t$[esp-4]

; 254  : 
; 255  : 	if (dur_cons > NF100MS)

  01b94	8b 4c 24 1c	 mov	 ecx, DWORD PTR _dur_cons$[esp-4]
  01b98	56		 push	 esi
  01b99	66 83 f9 10	 cmp	 cx, 16			; 00000010H
  01b9d	8b b2 48 28 00
	00		 mov	 esi, DWORD PTR [edx+10312]
  01ba3	7e 0c		 jle	 SHORT $L71775

; 256  : 	{
; 257  : 		pDphsettar->vvbouval = 0;

  01ba5	33 c0		 xor	 eax, eax
  01ba7	66 89 46 04	 mov	 WORD PTR [esi+4], ax

; 258  : 		pDphsettar->vvdurtran = 0;

  01bab	66 89 46 08	 mov	 WORD PTR [esi+8], ax
  01baf	5e		 pop	 esi

; 266  : 	}
; 267  : 
; 268  : #ifdef DEBUG_TARGETS
; 269  : 	printf ("\t -> BV=%d TC=%d\n", pDphsettar->vvbouval, pDphsettar->vvdurtran);
; 270  : #endif
; 271  : }

  01bb0	c3		 ret	 0
$L71775:

; 259  : 	}
; 260  : 	else
; 261  : 	{
; 262  : 		pDph_t->arg1 = (remotetar - currenttar) * (NF100MS - dur_cons);

  01bb1	8b 44 24 10	 mov	 eax, DWORD PTR _remotetar$[esp]
  01bb5	57		 push	 edi
  01bb6	8b 7c 24 1c	 mov	 edi, DWORD PTR _currenttar$[esp+4]

; 263  : 		pDph_t->arg2 = 460;			   /* 45% of pDph_t->arg1, also divided by 16 frames */

  01bba	66 c7 82 c6 11
	00 00 cc 01	 mov	 WORD PTR [edx+4550], 460 ; 000001ccH
  01bc3	2b c7		 sub	 eax, edi
  01bc5	bf 10 00 00 00	 mov	 edi, 16			; 00000010H
  01bca	2b f9		 sub	 edi, ecx
  01bcc	0f af c7	 imul	 eax, edi
  01bcf	66 89 82 c4 11
	00 00		 mov	 WORD PTR [edx+4548], ax
  01bd6	5f		 pop	 edi

; 264  : 		pDphsettar->vvbouval = mlsh1 (pDph_t->arg1, pDph_t->arg2);

  01bd7	0f bf d0	 movsx	 edx, ax

; 265  : 		pDphsettar->vvdurtran = NF80MS - (dur_cons >> 2);

  01bda	66 c1 f9 02	 sar	 cx, 2
  01bde	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  01be1	c1 e0 03	 shl	 eax, 3
  01be4	2b c2		 sub	 eax, edx
  01be6	ba 0d 00 00 00	 mov	 edx, 13			; 0000000dH
  01beb	2b d1		 sub	 edx, ecx
  01bed	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  01bf0	66 89 56 08	 mov	 WORD PTR [esi+8], dx
  01bf4	c1 e0 02	 shl	 eax, 2
  01bf7	c1 f8 0e	 sar	 eax, 14			; 0000000eH
  01bfa	66 89 46 04	 mov	 WORD PTR [esi+4], ax
  01bfe	5e		 pop	 esi

; 266  : 	}
; 267  : 
; 268  : #ifdef DEBUG_TARGETS
; 269  : 	printf ("\t -> BV=%d TC=%d\n", pDphsettar->vvbouval, pDphsettar->vvdurtran);
; 270  : #endif
; 271  : }

  01bff	c3		 ret	 0
_vv_coartic_across_c ENDP
_phTTS$ = 8
_nfone$ = 12
_getbegtar PROC NEAR

; 872  : 	short                   temp, temp1;
; 873  : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  01c00	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  01c04	53		 push	 ebx
  01c05	55		 push	 ebp

; 874  : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 875  : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;
; 876  : 
; 877  : 	temp = gettar (phTTS, nfone);

  01c06	8b 6c 24 10	 mov	 ebp, DWORD PTR _nfone$[esp+4]
  01c0a	56		 push	 esi
  01c0b	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  01c0e	57		 push	 edi
  01c0f	55		 push	 ebp
  01c10	8b 9e 48 28 00
	00		 mov	 ebx, DWORD PTR [esi+10312]
  01c16	50		 push	 eax
  01c17	e8 00 00 00 00	 call	 _gettar
  01c1c	83 c4 08	 add	 esp, 8

; 878  : 	if (temp < -1)

  01c1f	66 3d ff ff	 cmp	 ax, -1
  01c23	7d 28		 jge	 SHORT $L71846

; 879  : 	{                                                                  /* If next seg diphthong, */
; 880  : 		temp = pDph_t->p_diph[-temp];  /* use diph first value  */

  01c25	8b 8e b8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4536]
  01c2b	0f bf c0	 movsx	 eax, ax
  01c2e	d1 e0		 shl	 eax, 1
  01c30	2b c8		 sub	 ecx, eax

; 881  : 		/* Special coarticulation rules to change (vowel) target */
; 882  : 		if (pDphsettar->par_type IS_FORM_FREQ)

  01c32	8a 43 14	 mov	 al, BYTE PTR [ebx+20]
  01c35	3c 03		 cmp	 al, 3
  01c37	66 8b 39	 mov	 di, WORD PTR [ecx]
  01c3a	75 0e		 jne	 SHORT $L72029

; 883  : 		{
; 884  : 			temp1 = special_coartic (pDph_t, nfone, 0);

  01c3c	6a 00		 push	 0
  01c3e	55		 push	 ebp
  01c3f	56		 push	 esi
  01c40	e8 00 00 00 00	 call	 _special_coartic
  01c45	83 c4 0c	 add	 esp, 12			; 0000000cH

; 885  : 			temp += temp1;

  01c48	03 f8		 add	 edi, eax
$L72029:

; 886  : 		}
; 887  : 	}
; 888  : 	return (temp);

  01c4a	66 8b c7	 mov	 ax, di
$L71846:
  01c4d	5f		 pop	 edi
  01c4e	5e		 pop	 esi
  01c4f	5d		 pop	 ebp
  01c50	5b		 pop	 ebx

; 889  : }

  01c51	c3		 ret	 0
_getbegtar ENDP
_pDph_t$ = 8
_nfon$ = 12
_diphpos$ = 16
_temp$ = 8
_special_coartic PROC NEAR

; 326  : 	/* Note: Gen coartic of 5% with adjacent segs elsewhere, so stuff here is big */
; 327  : 	/* This routine is only called if the current segment is diph (i.e. a vowel) */
; 328  : 
; 329  : 	short                   temp, fonnex, foncur, fonlas;
; 330  : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;
; 331  : 
; 332  : 	temp = 0;
; 333  : 	foncur = get_phone(pDph_t, nfon);

  01c60	66 8b 44 24 08	 mov	 ax, WORD PTR _nfon$[esp-4]
  01c65	53		 push	 ebx
  01c66	55		 push	 ebp
  01c67	56		 push	 esi
  01c68	57		 push	 edi
  01c69	8b 7c 24 14	 mov	 edi, DWORD PTR _pDph_t$[esp+12]
  01c6d	66 85 c0	 test	 ax, ax
  01c70	8b 97 48 28 00
	00		 mov	 edx, DWORD PTR [edi+10312]
  01c76	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _temp$[esp+12], 0
  01c7e	7c 16		 jl	 SHORT $L72032
  01c80	66 3b 87 ae 11
	00 00		 cmp	 ax, WORD PTR [edi+4526]
  01c87	7d 0d		 jge	 SHORT $L72032
  01c89	0f bf c8	 movsx	 ecx, ax
  01c8c	66 8b 8c 4f 02
	03 00 00	 mov	 cx, WORD PTR [edi+ecx*2+770]
  01c94	eb 02		 jmp	 SHORT $L72033
$L72032:
  01c96	33 c9		 xor	 ecx, ecx
$L72033:

; 334  : 	fonnex = get_phone(pDph_t, nfon + 1);

  01c98	0f bf e8	 movsx	 ebp, ax
  01c9b	8d 45 01	 lea	 eax, DWORD PTR [ebp+1]
  01c9e	85 c0		 test	 eax, eax
  01ca0	7c 15		 jl	 SHORT $L72034
  01ca2	0f bf b7 ae 11
	00 00		 movsx	 esi, WORD PTR [edi+4526]
  01ca9	3b c6		 cmp	 eax, esi
  01cab	7d 0a		 jge	 SHORT $L72034
  01cad	66 8b 9c 6f 04
	03 00 00	 mov	 bx, WORD PTR [edi+ebp*2+772]
  01cb5	eb 02		 jmp	 SHORT $L72035
$L72034:
  01cb7	33 db		 xor	 ebx, ebx
$L72035:

; 335  : 	fonlas = get_phone(pDph_t, nfon - 1);

  01cb9	8d 45 ff	 lea	 eax, DWORD PTR [ebp-1]
  01cbc	85 c0		 test	 eax, eax
  01cbe	7c 15		 jl	 SHORT $L72036
  01cc0	0f bf b7 ae 11
	00 00		 movsx	 esi, WORD PTR [edi+4526]
  01cc7	3b c6		 cmp	 eax, esi
  01cc9	7d 0a		 jge	 SHORT $L72036
  01ccb	66 8b b4 6f 00
	03 00 00	 mov	 si, WORD PTR [edi+ebp*2+768]
  01cd3	eb 02		 jmp	 SHORT $L72037
$L72036:
  01cd5	33 f6		 xor	 esi, esi
$L72037:

; 336  : 
; 337  : 	/* F3 target of selected vowels */
; 338  : 	if (pDphsettar->np == &PF3)

  01cd7	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  01cda	8d 57 6c	 lea	 edx, DWORD PTR [edi+108]
  01cdd	3b c2		 cmp	 eax, edx
  01cdf	75 3f		 jne	 SHORT $L71425

; 339  : 	{
; 340  : 		if (((featb[foncur] & FVOWEL) IS_PLUS) && (foncur != RR))

  01ce1	0f bf d1	 movsx	 edx, cx
  01ce4	f6 04 55 00 00
	00 00 04	 test	 BYTE PTR _featb[edx*2], 4
  01cec	74 32		 je	 SHORT $L71425
  01cee	66 83 f9 0f	 cmp	 cx, 15			; 0000000fH
  01cf2	74 2c		 je	 SHORT $L71425

; 341  : 		{
; 342  : 			if (((fonlas == W) || (fonlas == R) || (fonlas == RX))
; 343  : 				|| ((fonnex == W) || (fonnex == R) || (fonnex == RX)))

  01cf4	66 83 fe 18	 cmp	 si, 24			; 00000018H
  01cf8	74 1e		 je	 SHORT $L71427
  01cfa	66 83 fe 1a	 cmp	 si, 26			; 0000001aH
  01cfe	74 18		 je	 SHORT $L71427
  01d00	66 83 fe 1d	 cmp	 si, 29			; 0000001dH
  01d04	74 12		 je	 SHORT $L71427
  01d06	66 83 fb 18	 cmp	 bx, 24			; 00000018H
  01d0a	74 0c		 je	 SHORT $L71427
  01d0c	66 83 fb 1a	 cmp	 bx, 26			; 0000001aH
  01d10	74 06		 je	 SHORT $L71427
  01d12	66 83 fb 1d	 cmp	 bx, 29			; 0000001dH
  01d16	75 08		 jne	 SHORT $L71425
$L71427:

; 344  : 			{
; 345  : 				temp = -150;

  01d18	c7 44 24 14 6a
	ff ff ff	 mov	 DWORD PTR _temp$[esp+12], -150 ; ffffff6aH
$L71425:

; 346  : 			}
; 347  : 		}
; 348  : 	}
; 349  : 	/* F2 target of selected vowels */
; 350  : 	if (pDphsettar->np == &PF2)

  01d20	8d 57 48	 lea	 edx, DWORD PTR [edi+72]
  01d23	3b c2		 cmp	 eax, edx
  01d25	0f 85 3d 01 00
	00		 jne	 $L72040

; 351  : 	{
; 352  : 		/* Front vowel F2 target lowered before [LX] */
; 353  : 		if (fonnex == LX)

  01d2b	66 8b 54 24 1c	 mov	 dx, WORD PTR _diphpos$[esp+12]
  01d30	66 83 fb 1e	 cmp	 bx, 30			; 0000001eH
  01d34	75 4e		 jne	 SHORT $L71435

; 354  : 		{
; 355  : 			if (((foncur >= IY) && (foncur <= AE)) || (foncur == IX))

  01d36	66 83 f9 01	 cmp	 cx, 1
  01d3a	7c 06		 jl	 SHORT $L71432
  01d3c	66 83 f9 05	 cmp	 cx, 5
  01d40	7e 06		 jle	 SHORT $L71431
$L71432:
  01d42	66 83 f9 12	 cmp	 cx, 18			; 00000012H
  01d46	75 08		 jne	 SHORT $L71430
$L71431:

; 356  : 			{
; 357  : 				temp = -150;

  01d48	c7 44 24 14 6a
	ff ff ff	 mov	 DWORD PTR _temp$[esp+12], -150 ; ffffff6aH
$L71430:

; 358  : 			}
; 359  : 			if (((foncur == AY) || (foncur == OY))
; 360  : 				&& (diphpos == 1))

  01d50	66 83 f9 07	 cmp	 cx, 7
  01d54	74 06		 je	 SHORT $L71434
  01d56	66 83 f9 0c	 cmp	 cx, 12			; 0000000cH
  01d5a	75 0e		 jne	 SHORT $L71433
$L71434:
  01d5c	66 83 fa 01	 cmp	 dx, 1
  01d60	75 08		 jne	 SHORT $L71433

; 361  : 			{
; 362  : 				temp = -250;

  01d62	c7 44 24 14 06
	ff ff ff	 mov	 DWORD PTR _temp$[esp+12], -250 ; ffffff06H
$L71433:

; 363  : 			}
; 364  : 			if (((foncur == AY) || (foncur == OY))
; 365  : 				&& (diphpos > 1))

  01d6a	66 83 f9 07	 cmp	 cx, 7
  01d6e	74 06		 je	 SHORT $L71436
  01d70	66 83 f9 0c	 cmp	 cx, 12			; 0000000cH
  01d74	75 0e		 jne	 SHORT $L71435
$L71436:
  01d76	66 83 fa 01	 cmp	 dx, 1
  01d7a	7e 08		 jle	 SHORT $L71435

; 366  : 			{
; 367  : 				temp = -350;

  01d7c	c7 44 24 14 a2
	fe ff ff	 mov	 DWORD PTR _temp$[esp+12], -350 ; fffffea2H
$L71435:

; 368  : 
; 369  : 			}
; 370  : 		}
; 371  : 		/* Front vowel F2 target lowered after [W], [L] (DO ALSO FOR F3 of [W] */
; 372  : 		if ((fonlas == W) || (fonlas == LL) || (fonlas == LX))

  01d84	66 83 fe 18	 cmp	 si, 24			; 00000018H
  01d88	74 0c		 je	 SHORT $L71438
  01d8a	66 83 fe 1b	 cmp	 si, 27			; 0000001bH
  01d8e	74 06		 je	 SHORT $L71438
  01d90	66 83 fe 1e	 cmp	 si, 30			; 0000001eH
  01d94	75 1a		 jne	 SHORT $L71439
$L71438:

; 373  : 		{
; 374  : 			if (((foncur >= IY) && (foncur <= AE)) || (foncur == IX))

  01d96	66 83 f9 01	 cmp	 cx, 1
  01d9a	7c 06		 jl	 SHORT $L71441
  01d9c	66 83 f9 05	 cmp	 cx, 5
  01da0	7e 06		 jle	 SHORT $L71440
$L71441:
  01da2	66 83 f9 12	 cmp	 cx, 18			; 00000012H
  01da6	75 08		 jne	 SHORT $L71439
$L71440:

; 375  : 			{
; 376  : 				temp = -150;		   /* las and nex effects not cumulative */

  01da8	c7 44 24 14 6a
	ff ff ff	 mov	 DWORD PTR _temp$[esp+12], -150 ; ffffff6aH
$L71439:

; 377  : 			}
; 378  : 		}
; 379  : 		/* [UW] F2 target raised adjacent to an alveolar */
; 380  : 		if (foncur == UW)

  01db0	66 83 f9 0e	 cmp	 cx, 14			; 0000000eH
  01db4	b0 08		 mov	 al, 8
  01db6	75 16		 jne	 SHORT $L72038

; 381  : 		{
; 382  : 			if ((place[fonlas] & FALVEL) IS_PLUS)

  01db8	0f bf f6	 movsx	 esi, si
  01dbb	84 04 75 00 00
	00 00		 test	 BYTE PTR _place[esi*2], al
  01dc2	74 15		 je	 SHORT $L71445

; 383  : 			{
; 384  : 				temp = 200;

  01dc4	c7 44 24 14 c8
	00 00 00	 mov	 DWORD PTR _temp$[esp+12], 200 ; 000000c8H

; 385  : 			}
; 386  : 		}
; 387  : 		if ((foncur == UW)
; 388  : 			|| ((foncur == YU) && (diphpos > 0)))

  01dcc	eb 0b		 jmp	 SHORT $L71445
$L72038:
  01dce	66 83 f9 10	 cmp	 cx, 16			; 00000010H
  01dd2	75 19		 jne	 SHORT $L71446
  01dd4	66 85 d2	 test	 dx, dx
  01dd7	7e 14		 jle	 SHORT $L71446
$L71445:

; 389  : 		{
; 390  : 			if ((place[fonnex] & FALVEL) IS_PLUS)

  01dd9	0f bf f3	 movsx	 esi, bx
  01ddc	84 04 75 00 00
	00 00		 test	 BYTE PTR _place[esi*2], al
  01de3	74 08		 je	 SHORT $L71446

; 391  : 			{
; 392  : 				temp += 200;

  01de5	81 44 24 14 c8
	00 00 00	 add	 DWORD PTR _temp$[esp+12], 200 ; 000000c8H
$L71446:

; 393  : 			}
; 394  : 		}
; 395  : 		/* Effects are greater for unstressed vowels */
; 396  : 		if ((pDph_t->allofeats[nfon] & FSTRESS) IS_MINUS)

  01ded	8b 84 af 70 05
	00 00		 mov	 eax, DWORD PTR [edi+ebp*4+1392]
  01df4	a8 03		 test	 al, 3
  01df6	75 2f		 jne	 SHORT $L71447

; 397  : 		{
; 398  : 			temp += (temp >> 1);

  01df8	66 8b 44 24 14	 mov	 ax, WORD PTR _temp$[esp+12]
  01dfd	8b 74 24 14	 mov	 esi, DWORD PTR _temp$[esp+12]
  01e01	66 d1 f8	 sar	 ax, 1
  01e04	03 f0		 add	 esi, eax

; 399  : 
; 400  : 			/* Unstressed YU has a fronted U part */
; 401  : 			if ((foncur == YU) && (diphpos > 0))

  01e06	66 83 f9 10	 cmp	 cx, 16			; 00000010H
  01e0a	89 74 24 14	 mov	 DWORD PTR _temp$[esp+12], esi
  01e0e	75 2d		 jne	 SHORT $L72041
  01e10	66 85 d2	 test	 dx, dx
  01e13	7e 28		 jle	 SHORT $L72041
  01e15	5f		 pop	 edi

; 402  : 			{
; 403  : 				temp = 400;

  01e16	c7 44 24 10 90
	01 00 00	 mov	 DWORD PTR _temp$[esp+8], 400 ; 00000190H

; 416  : 	}
; 417  : 
; 418  : 	return (temp);

  01e1e	66 8b 44 24 10	 mov	 ax, WORD PTR _temp$[esp+8]
  01e23	5e		 pop	 esi
  01e24	5d		 pop	 ebp
  01e25	5b		 pop	 ebx

; 419  : }

  01e26	c3		 ret	 0
$L71447:

; 404  : 			}
; 405  : 		}
; 406  : 		/* Reduce effects for phrase-final stressed vowels */
; 407  : 		else if ((pDph_t->allofeats[nfon] & FBOUNDARY) >= FVPNEXT)

  01e27	25 e0 01 00 00	 and	 eax, 480		; 000001e0H
  01e2c	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  01e31	72 0a		 jb	 SHORT $L72041

; 408  : 		{
; 409  : 			temp = temp >> 1;

  01e33	66 8b 44 24 14	 mov	 ax, WORD PTR _temp$[esp+12]
  01e38	66 d1 f8	 sar	 ax, 1
  01e3b	eb 05		 jmp	 SHORT $L71450
$L72041:
  01e3d	66 8b 44 24 14	 mov	 ax, WORD PTR _temp$[esp+12]
$L71450:

; 410  : 		}
; 411  : 		/* Maximum change should not be excessive */
; 412  : 		if (temp > 400)

  01e42	66 3d 90 01	 cmp	 ax, 400			; 00000190H
  01e46	7e 12		 jle	 SHORT $L71451
  01e48	5f		 pop	 edi

; 413  : 			temp = 400;

  01e49	c7 44 24 10 90
	01 00 00	 mov	 DWORD PTR _temp$[esp+8], 400 ; 00000190H

; 416  : 	}
; 417  : 
; 418  : 	return (temp);

  01e51	66 8b 44 24 10	 mov	 ax, WORD PTR _temp$[esp+8]
  01e56	5e		 pop	 esi
  01e57	5d		 pop	 ebp
  01e58	5b		 pop	 ebx

; 419  : }

  01e59	c3		 ret	 0
$L71451:

; 414  : 		if (temp < -400)

  01e5a	66 3d 70 fe	 cmp	 ax, -400		; fffffe70H
  01e5e	7d 0d		 jge	 SHORT $L71452

; 415  : 			temp = -400;

  01e60	c7 44 24 14 70
	fe ff ff	 mov	 DWORD PTR _temp$[esp+12], -400 ; fffffe70H
$L72040:

; 416  : 	}
; 417  : 
; 418  : 	return (temp);

  01e68	66 8b 44 24 14	 mov	 ax, WORD PTR _temp$[esp+12]
$L71452:
  01e6d	5f		 pop	 edi
  01e6e	5e		 pop	 esi
  01e6f	5d		 pop	 ebp
  01e70	5b		 pop	 ebx

; 419  : }

  01e71	c3		 ret	 0
_special_coartic ENDP
_phTTS$ = 8
_nfone$ = 12
_getendtar PROC NEAR

; 910  : 	short                   temp, temp1;
; 911  : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  01e80	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  01e84	53		 push	 ebx
  01e85	55		 push	 ebp

; 912  : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 913  : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;
; 914  : 
; 915  : 	temp = gettar (phTTS, nfone);

  01e86	8b 6c 24 10	 mov	 ebp, DWORD PTR _nfone$[esp+4]
  01e8a	56		 push	 esi
  01e8b	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  01e8e	57		 push	 edi
  01e8f	55		 push	 ebp
  01e90	8b 9e 48 28 00
	00		 mov	 ebx, DWORD PTR [esi+10312]
  01e96	50		 push	 eax
  01e97	e8 00 00 00 00	 call	 _gettar
  01e9c	83 c4 08	 add	 esp, 8

; 916  : 	if (temp < -1)

  01e9f	66 3d ff ff	 cmp	 ax, -1
  01ea3	7d 3d		 jge	 SHORT $L71861

; 917  : 	{
; 918  : 		temp = -temp;                              /* Vowel tar is diphth */
; 919  : 		while (pDph_t->p_diph[temp] != -1)

  01ea5	8b 8e b8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4536]
  01eab	f7 d8		 neg	 eax
  01ead	0f bf d0	 movsx	 edx, ax
  01eb0	66 83 3c 51 ff	 cmp	 WORD PTR [ecx+edx*2], -1
  01eb5	74 0b		 je	 SHORT $L71860
$L71859:

; 920  : 		{
; 921  : 			temp++;

  01eb7	40		 inc	 eax
  01eb8	0f bf d0	 movsx	 edx, ax
  01ebb	66 83 3c 51 ff	 cmp	 WORD PTR [ecx+edx*2], -1
  01ec0	75 f5		 jne	 SHORT $L71859
$L71860:

; 922  : 		}
; 923  : 		temp = pDph_t->p_diph[temp - 1];        /* Last val of diph */

  01ec2	0f bf c0	 movsx	 eax, ax
  01ec5	66 8b 7c 41 fe	 mov	 di, WORD PTR [ecx+eax*2-2]

; 924  : 		/* Special coarticulation rules to change (vowel) target */
; 925  : 		if (pDphsettar->par_type IS_FORM_FREQ)

  01eca	8a 43 14	 mov	 al, BYTE PTR [ebx+20]
  01ecd	3c 03		 cmp	 al, 3
  01ecf	75 0e		 jne	 SHORT $L72051

; 926  : 		{
; 927  : 			temp1 = special_coartic (pDph_t, nfone, 1);

  01ed1	6a 01		 push	 1
  01ed3	55		 push	 ebp
  01ed4	56		 push	 esi
  01ed5	e8 00 00 00 00	 call	 _special_coartic
  01eda	83 c4 0c	 add	 esp, 12			; 0000000cH

; 928  : 			temp += temp1;

  01edd	03 f8		 add	 edi, eax
$L72051:

; 929  : 		}
; 930  : 	}
; 931  : 	return (temp);

  01edf	66 8b c7	 mov	 ax, di
$L71861:
  01ee2	5f		 pop	 edi
  01ee3	5e		 pop	 esi
  01ee4	5d		 pop	 ebp
  01ee5	5b		 pop	 ebx

; 932  : }

  01ee6	c3		 ret	 0
_getendtar ENDP
_pDph_t$ = 8
_pdip$ = 12
_inhdr_frames$ = 16
_shrink$ = 20
_ppsNdips$ = 28
_dip_pos$ = -12
_dipsw$ = -16
_oldvalue$ = 28
_newvalue$ = 8
_oldtime$ = -8
_make_dip PROC NEAR

; 959  : {

  01ef0	83 ec 10	 sub	 esp, 16			; 00000010H
  01ef3	53		 push	 ebx
  01ef4	55		 push	 ebp

; 960  : 	short                   temp, dip_pos;
; 961  : 
; 962  : 	/* MVP :List of variables made local                      */
; 963  : 	short                   dipsw;
; 964  : 	short                   oldvalue, newvalue, oldtime, newtime;
; 965  : 
; 966  : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;
; 967  : 
; 968  : 	pDphsettar->np->ndip = *ppsNdips;  /* Start of diph info for this par in dipspec[] */

  01ef5	8b 6c 24 30	 mov	 ebp, DWORD PTR _ppsNdips$[esp+20]
  01ef9	56		 push	 esi
  01efa	8b 74 24 20	 mov	 esi, DWORD PTR _pDph_t$[esp+24]
  01efe	57		 push	 edi
  01eff	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  01f02	8b be 48 28 00
	00		 mov	 edi, DWORD PTR [esi+10312]

; 969  : 
; 970  : 	oldvalue = pDph_t->p_diph[pdip];   /* cccc Initial value of first straight line */

  01f08	0f bf 54 24 28	 movsx	 edx, WORD PTR _pdip$[esp+28]
  01f0d	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  01f10	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  01f13	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  01f19	66 8b 1c 50	 mov	 bx, WORD PTR [eax+edx*2]

; 971  : 
; 972  : 	/* Formant frequency coarticulation rules */
; 973  : 	if (pDphsettar->par_type IS_FORM_FREQ)

  01f1d	8a 47 14	 mov	 al, BYTE PTR [edi+20]
  01f20	3c 03		 cmp	 al, 3
  01f22	89 5c 24 38	 mov	 DWORD PTR _oldvalue$[esp+28], ebx
  01f26	75 51		 jne	 SHORT $L71883

; 974  : 	{
; 975  : 		/* General rule: prev. phone changes init. vowel tar toward phlas */
; 976  : 		pDphsettar->gencoartic = N10PRCNT;
; 977  : 		if ((struccur & FSTRESS) IS_MINUS)
; 978  : 		{
; 979  : 			/* Increased coarticulation, especially F2, if unstressed */
; 980  : 			/* OUT         gencoartic = N15PRCNT; if (pDphsettar->np == &PF2) { gencoartic = N25PRCNT; } END OUT */
; 981  : 		}
; 982  : 		pDph_t->arg1 = pDphsettar->np->tarlas - oldvalue;

  01f28	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  01f2b	66 c7 47 0c 66
	06		 mov	 WORD PTR [edi+12], 1638	; 00000666H

; 983  : 		pDph_t->arg2 = pDphsettar->gencoartic;
; 984  : 		oldvalue += mlsh1 (pDph_t->arg1, pDph_t->arg2);
; 985  : 		/* Special rule: (see subroutine) */
; 986  : 		dip_pos = 0;
; 987  : 		oldvalue += special_coartic (pDph_t, pDph_t->nphone, dip_pos);

  01f31	6a 00		 push	 0
  01f33	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _dip_pos$[esp+36], 0
  01f3b	66 8b 51 18	 mov	 dx, WORD PTR [ecx+24]
  01f3f	66 2b d3	 sub	 dx, bx
  01f42	66 89 96 c4 11
	00 00		 mov	 WORD PTR [esi+4548], dx
  01f49	66 8b 47 0c	 mov	 ax, WORD PTR [edi+12]
  01f4d	66 89 86 c6 11
	00 00		 mov	 WORD PTR [esi+4550], ax
  01f54	0f bf c0	 movsx	 eax, ax
  01f57	0f bf ca	 movsx	 ecx, dx
  01f5a	0f af c1	 imul	 eax, ecx
  01f5d	66 8b 96 1c 20
	00 00		 mov	 dx, WORD PTR [esi+8220]
  01f64	c1 f8 0e	 sar	 eax, 14			; 0000000eH
  01f67	52		 push	 edx
  01f68	56		 push	 esi
  01f69	03 d8		 add	 ebx, eax
  01f6b	e8 00 00 00 00	 call	 _special_coartic
  01f70	83 c4 0c	 add	 esp, 12			; 0000000cH
  01f73	03 d8		 add	 ebx, eax
  01f75	89 5c 24 38	 mov	 DWORD PTR _oldvalue$[esp+28], ebx
$L71883:

; 988  : 
; 989  : #ifdef DEBUG_targetS
; 990  : 		printf (
; 991  : 				   " tarbeg=%4d  (from 10%% tarlas=%4d, 90%% tarbeg=%d)\n",
; 992  : 				   oldvalue, pDphsettar->np->tarlas, pDph_t->p_diph[pdip]);
; 993  : #endif
; 994  : 	}
; 995  : 	pDphsettar->np->tarcur = oldvalue;

  01f79	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  01f7c	66 89 18	 mov	 WORD PTR [eax], bx

; 996  : 
; 997  : 	/* Current value of time */
; 998  : 	oldtime = 0;

  01f7f	33 c0		 xor	 eax, eax
  01f81	89 44 24 18	 mov	 DWORD PTR _oldtime$[esp+32], eax

; 999  : 
; 1000 : 	/* Process each <value,time> of diph definition */
; 1001 : 	dipsw = 0;

  01f85	89 44 24 10	 mov	 DWORD PTR _dipsw$[esp+32], eax
  01f89	eb 04		 jmp	 SHORT $L71885
$L72056:
  01f8b	8b 5c 24 38	 mov	 ebx, DWORD PTR _oldvalue$[esp+28]
$L71885:

; 1002 : 	do
; 1003 : 	{
; 1004 : 		if (dipsw == 0)

  01f8f	66 83 7c 24 10
	00		 cmp	 WORD PTR _dipsw$[esp+32], 0
  01f95	75 1a		 jne	 SHORT $L71888

; 1005 : 		{
; 1006 : 			newvalue = oldvalue;
; 1007 : 			dipsw++;
; 1008 : 			pdip++;

  01f97	8b 44 24 28	 mov	 eax, DWORD PTR _pdip$[esp+28]
  01f9b	89 5c 24 24	 mov	 DWORD PTR _newvalue$[esp+28], ebx
  01f9f	40		 inc	 eax
  01fa0	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _dipsw$[esp+32], 1
  01fa8	89 44 24 28	 mov	 DWORD PTR _pdip$[esp+28], eax

; 1009 : 		}
; 1010 : 		else

  01fac	e9 81 00 00 00	 jmp	 $L71890
$L71888:

; 1011 : 		{
; 1012 : 			newvalue = pDph_t->p_diph[pdip++];

  01fb1	8b 44 24 28	 mov	 eax, DWORD PTR _pdip$[esp+28]
  01fb5	8b 96 b8 11 00
	00		 mov	 edx, DWORD PTR [esi+4536]
  01fbb	0f bf c8	 movsx	 ecx, ax
  01fbe	40		 inc	 eax
  01fbf	66 8b 0c 4a	 mov	 cx, WORD PTR [edx+ecx*2]
  01fc3	89 44 24 28	 mov	 DWORD PTR _pdip$[esp+28], eax

; 1013 : 
; 1014 : 			/* Formant frequency coarticulation rules */
; 1015 : 			if (pDphsettar->par_type IS_FORM_FREQ)

  01fc7	8a 47 14	 mov	 al, BYTE PTR [edi+20]
  01fca	66 89 4c 24 24	 mov	 WORD PTR _newvalue$[esp+28], cx
  01fcf	3c 03		 cmp	 al, 3
  01fd1	75 5f		 jne	 SHORT $L71890

; 1016 : 			{
; 1017 : 				/* General rule: next phone changes vowel tar toward phnex */
; 1018 : 				if (pDphsettar->np->tarnex > 0)

  01fd3	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  01fd6	66 8b 42 16	 mov	 ax, WORD PTR [edx+22]
  01fda	66 85 c0	 test	 ax, ax
  01fdd	7e 2e		 jle	 SHORT $L71891

; 1019 : 				{
; 1020 : 					pDph_t->arg1 = pDphsettar->np->tarnex - newvalue;

  01fdf	8b 4c 24 24	 mov	 ecx, DWORD PTR _newvalue$[esp+28]
  01fe3	2b c1		 sub	 eax, ecx
  01fe5	66 89 86 c4 11
	00 00		 mov	 WORD PTR [esi+4548], ax

; 1021 : 					pDph_t->arg2 = pDphsettar->gencoartic;

  01fec	66 8b 47 0c	 mov	 ax, WORD PTR [edi+12]

; 1022 : 					newvalue += mlsh1 (pDph_t->arg1, pDph_t->arg2);

  01ff0	0f bf 96 c4 11
	00 00		 movsx	 edx, WORD PTR [esi+4548]
  01ff7	66 89 86 c6 11
	00 00		 mov	 WORD PTR [esi+4550], ax
  01ffe	0f bf c0	 movsx	 eax, ax
  02001	0f af c2	 imul	 eax, edx
  02004	c1 f8 0e	 sar	 eax, 14			; 0000000eH
  02007	03 c8		 add	 ecx, eax
  02009	89 4c 24 24	 mov	 DWORD PTR _newvalue$[esp+28], ecx
$L71891:

; 1023 : 				}
; 1024 : 				/* Special rule: (see subroutine) */
; 1025 : 				newvalue += special_coartic (pDph_t, pDph_t->nphone, ++dip_pos);

  0200d	8b 44 24 14	 mov	 eax, DWORD PTR _dip_pos$[esp+32]
  02011	40		 inc	 eax
  02012	89 44 24 14	 mov	 DWORD PTR _dip_pos$[esp+32], eax
  02016	50		 push	 eax
  02017	66 8b 86 1c 20
	00 00		 mov	 ax, WORD PTR [esi+8220]
  0201e	50		 push	 eax
  0201f	56		 push	 esi
  02020	e8 00 00 00 00	 call	 _special_coartic
  02025	8b 4c 24 30	 mov	 ecx, DWORD PTR _newvalue$[esp+40]
  02029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0202c	03 c8		 add	 ecx, eax
  0202e	89 4c 24 24	 mov	 DWORD PTR _newvalue$[esp+28], ecx
$L71890:

; 1026 : 
; 1027 : #ifdef DEBUG_targetS
; 1028 : 				printf (
; 1029 : 						   "%d diph tarend=%4d   (from 10%% tarnex=%4d, 90%% tarend=%d)\n",
; 1030 : 						   (pDphsettar->np - &PF1), newvalue, pDphsettar->np->tarnex, pDph_t->p_diph[pdip - 1]);
; 1031 : #endif
; 1032 : 			}
; 1033 : 		}
; 1034 : #ifdef ENGLISH
; 1035 : 		if (NSAMP_FRAME == 128)
; 1036 : 			newtime = pDph_t->p_diph[pdip] >> 1;    /* eab ccc for 1/2 samp */
; 1037 : 		else
; 1038 : #endif
; 1039 : 			newtime = pDph_t->p_diph[pdip];

  02032	0f bf 44 24 28	 movsx	 eax, WORD PTR _pdip$[esp+28]
  02037	8b 8e b8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4536]
  0203d	d1 e0		 shl	 eax, 1
  0203f	89 44 24 1c	 mov	 DWORD PTR -4+[esp+32], eax
  02043	66 8b 0c 08	 mov	 cx, WORD PTR [eax+ecx]

; 1040 : 		if (newtime != -1)

  02047	66 83 f9 ff	 cmp	 cx, -1
  0204b	74 1c		 je	 SHORT $L71894

; 1041 : 		{
; 1042 : 			/* Adjust newtime as f(shrink), i.e. make tran dur semi-invariant */
; 1043 : 			newtime = shrdur (pDph_t, newtime, inhdr_frames, shrink);

  0204d	8b 54 24 30	 mov	 edx, DWORD PTR _shrink$[esp+28]
  02051	8b 44 24 2c	 mov	 eax, DWORD PTR _inhdr_frames$[esp+28]
  02055	52		 push	 edx
  02056	50		 push	 eax
  02057	51		 push	 ecx
  02058	56		 push	 esi
  02059	e8 00 00 00 00	 call	 _shrdur
  0205e	8b d8		 mov	 ebx, eax

; 1044 : 		}
; 1045 : 		else

  02060	8b 44 24 2c	 mov	 eax, DWORD PTR -4+[esp+48]
  02064	83 c4 10	 add	 esp, 16			; 00000010H
  02067	eb 07		 jmp	 SHORT $L71895
$L71894:

; 1046 : 		{
; 1047 : 			/* Desired time is end of segment */
; 1048 : 			newtime = pDph_t->durfon;

  02069	66 8b 9e ac 11
	00 00		 mov	 bx, WORD PTR [esi+4524]
$L71895:

; 1049 : 		}
; 1050 : 		*(*ppsNdips)++ = newtime;

  02070	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  02073	66 89 19	 mov	 WORD PTR [ecx], bx
  02076	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  02079	83 c1 02	 add	 ecx, 2
  0207c	89 4d 00	 mov	 DWORD PTR [ebp], ecx
  0207f	8b d1		 mov	 edx, ecx

; 1051 : 
; 1052 : 		/* Compute increment/frame during transition */
; 1053 : 		temp = newtime - oldtime;

  02081	8b cb		 mov	 ecx, ebx
  02083	2b 4c 24 18	 sub	 ecx, DWORD PTR _oldtime$[esp+32]

; 1054 : 		if (temp == 0)

  02087	66 85 c9	 test	 cx, cx
  0208a	75 05		 jne	 SHORT $L71896

; 1055 : 		{
; 1056 : 			*(*ppsNdips) = 0;

  0208c	66 89 0a	 mov	 WORD PTR [edx], cx

; 1057 : 		}
; 1058 : 		else

  0208f	eb 63		 jmp	 SHORT $L71897
$L71896:

; 1059 : 		{
; 1060 : 			/* No divide if possible (for speed) */
; 1061 : 			pDph_t->arg2 = (newvalue - oldvalue) << 3;

  02091	8b 44 24 24	 mov	 eax, DWORD PTR _newvalue$[esp+28]
  02095	8b 54 24 38	 mov	 edx, DWORD PTR _oldvalue$[esp+28]
  02099	2b c2		 sub	 eax, edx
  0209b	c1 e0 03	 shl	 eax, 3

; 1062 : 			if (temp < 50)

  0209e	66 83 f9 32	 cmp	 cx, 50			; 00000032H
  020a2	66 89 86 c6 11
	00 00		 mov	 WORD PTR [esi+4550], ax
  020a9	7d 2a		 jge	 SHORT $L71898

; 1063 : 			{
; 1064 : 				pDph_t->arg1 = divtab[temp];

  020ab	0f bf d1	 movsx	 edx, cx

; 1065 : 				*(*ppsNdips) = mlsh1 (pDph_t->arg1, pDph_t->arg2);

  020ae	0f bf 8e c6 11
	00 00		 movsx	 ecx, WORD PTR [esi+4550]
  020b5	66 8b 04 55 00
	00 00 00	 mov	 ax, WORD PTR _divtab[edx*2]
  020bd	0f bf d0	 movsx	 edx, ax
  020c0	0f af ca	 imul	 ecx, edx
  020c3	66 89 86 c4 11
	00 00		 mov	 WORD PTR [esi+4548], ax
  020ca	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  020cd	c1 f9 0e	 sar	 ecx, 14			; 0000000eH
  020d0	66 89 08	 mov	 WORD PTR [eax], cx

; 1066 : 			}
; 1067 : 			else

  020d3	eb 0f		 jmp	 SHORT $L71899
$L71898:

; 1068 : 			{
; 1069 : 				*(*ppsNdips) = pDph_t->arg2 / temp;

  020d5	0f bf c0	 movsx	 eax, ax
  020d8	0f bf c9	 movsx	 ecx, cx
  020db	99		 cdq
  020dc	f7 f9		 idiv	 ecx
  020de	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  020e1	66 89 02	 mov	 WORD PTR [edx], ax
$L71899:

; 1070 : 			}
; 1071 : 			oldvalue = newvalue;

  020e4	8b 44 24 24	 mov	 eax, DWORD PTR _newvalue$[esp+28]

; 1072 : 			oldtime = newtime;

  020e8	89 5c 24 18	 mov	 DWORD PTR _oldtime$[esp+32], ebx
  020ec	89 44 24 38	 mov	 DWORD PTR _oldvalue$[esp+28], eax
  020f0	8b 44 24 1c	 mov	 eax, DWORD PTR -4+[esp+32]
$L71897:

; 1073 : 		}
; 1074 : 		(*ppsNdips)++;

  020f4	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]

; 1075 : 
; 1076 : 	}
; 1077 : 	while (pDph_t->p_diph[pdip++] != -1);

  020f7	8b 5c 24 28	 mov	 ebx, DWORD PTR _pdip$[esp+28]
  020fb	83 c1 02	 add	 ecx, 2
  020fe	43		 inc	 ebx
  020ff	89 4d 00	 mov	 DWORD PTR [ebp], ecx
  02102	8b 8e b8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4536]
  02108	89 5c 24 28	 mov	 DWORD PTR _pdip$[esp+28], ebx
  0210c	66 83 3c 08 ff	 cmp	 WORD PTR [eax+ecx], -1
  02111	0f 85 74 fe ff
	ff		 jne	 $L72056

; 1078 : 
; 1079 : 	/* Set final value of diph tran, first increment and duration in frames */
; 1080 : 	pDphsettar->np->tarend = newvalue; /* Code more transparent: use getendtar() */

  02117	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  0211a	66 8b 44 24 24	 mov	 ax, WORD PTR _newvalue$[esp+28]
  0211f	66 89 42 1a	 mov	 WORD PTR [edx+26], ax

; 1081 : 	pDphsettar->np->durlin = *pDphsettar->np->ndip++;

  02123	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  02126	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  02129	66 8b 11	 mov	 dx, WORD PTR [ecx]
  0212c	b9 02 00 00 00	 mov	 ecx, 2
  02131	66 89 50 02	 mov	 WORD PTR [eax+2], dx
  02135	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  02138	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0213b	03 d1		 add	 edx, ecx
  0213d	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 1082 : 	pDphsettar->np->deldip = *pDphsettar->np->ndip++;

  02140	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  02143	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  02146	66 8b 12	 mov	 dx, WORD PTR [edx]
  02149	66 89 50 04	 mov	 WORD PTR [eax+4], dx
  0214d	8b 7f 10	 mov	 edi, DWORD PTR [edi+16]
  02150	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  02153	03 c1		 add	 eax, ecx
  02155	89 47 1c	 mov	 DWORD PTR [edi+28], eax
  02158	5f		 pop	 edi
  02159	5e		 pop	 esi
  0215a	5d		 pop	 ebp
  0215b	5b		 pop	 ebx

; 1083 : }

  0215c	83 c4 10	 add	 esp, 16			; 00000010H
  0215f	c3		 ret	 0
_make_dip ENDP
_pDph_t$ = 8
_durin$ = 12
_inhdr_frames$ = 16
_shrink$ = 20
_shrdur	PROC NEAR

; 301  : 	short halfinhdr, halfmaxdur, foldswitch, localinhdr;
; 302  : 	PDPHSETTAR_ST pDphsettar = pDph_t->pSTphsettar;
; 303  : 
; 304  : 	/* Convert from ms to number of frames * 64 */
; 305  : 	durin = (durin * 10) + 5;

  02160	8b 44 24 08	 mov	 eax, DWORD PTR _durin$[esp-4]
  02164	53		 push	 ebx

; 306  : 	localinhdr = inhdr_frames * NSAMP_FRAME;
; 307  : 	halfinhdr = inhdr_frames * NSAMP_FRAME >> 1;

  02165	8b 5c 24 10	 mov	 ebx, DWORD PTR _inhdr_frames$[esp]
  02169	55		 push	 ebp
  0216a	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0216d	56		 push	 esi

; 308  : 	pDph_t->arg1 = halfinhdr;

  0216e	8b 74 24 10	 mov	 esi, DWORD PTR _pDph_t$[esp+8]
  02172	57		 push	 edi
  02173	8d 54 00 05	 lea	 edx, DWORD PTR [eax+eax+5]

; 309  : 	pDph_t->arg2 = shrink;
; 310  : 	halfmaxdur = mlsh1 (pDph_t->arg1, pDph_t->arg2);
; 311  : 
; 312  : 	/* Fold durin over about halfinhdr */
; 313  : 	foldswitch = 0;

  02177	33 ed		 xor	 ebp, ebp
  02179	0f bf c3	 movsx	 eax, bx
  0217c	8d 0c c0	 lea	 ecx, DWORD PTR [eax+eax*8]
  0217f	c1 e1 03	 shl	 ecx, 3
  02182	2b c8		 sub	 ecx, eax
  02184	8b c1		 mov	 eax, ecx
  02186	66 8b 4c 24 20	 mov	 cx, WORD PTR _shrink$[esp+12]
  0218b	d1 f8		 sar	 eax, 1
  0218d	66 89 8e c6 11
	00 00		 mov	 WORD PTR [esi+4550], cx
  02194	66 89 86 c4 11
	00 00		 mov	 WORD PTR [esi+4548], ax
  0219b	0f bf f9	 movsx	 edi, cx
  0219e	0f bf c8	 movsx	 ecx, ax
  021a1	0f af cf	 imul	 ecx, edi
  021a4	c1 f9 0e	 sar	 ecx, 14			; 0000000eH

; 314  : 	if (durin > halfinhdr)

  021a7	66 3b d0	 cmp	 dx, ax
  021aa	7e 13		 jle	 SHORT $L71791
  021ac	8d 2c db	 lea	 ebp, DWORD PTR [ebx+ebx*8]
  021af	c1 e5 03	 shl	 ebp, 3
  021b2	2b eb		 sub	 ebp, ebx
  021b4	8b dd		 mov	 ebx, ebp

; 315  : 	{
; 316  : 		durin = localinhdr - durin;
; 317  : 		foldswitch = 1;

  021b6	bd 01 00 00 00	 mov	 ebp, 1
  021bb	2b da		 sub	 ebx, edx
  021bd	8b d3		 mov	 edx, ebx
$L71791:

; 318  : 	}
; 319  : 	/* Turn time around (measure from middle of inhdur */
; 320  : 	durin = halfinhdr - durin;
; 321  : 
; 322  : 	/* Shrink this time by less than full requested shrinkage */
; 323  : 	pDph_t->arg2 = ((unsigned) shrink + FRAC_ONE) >> 1;

  021bf	81 c7 00 40 00
	00		 add	 edi, 16384		; 00004000H
  021c5	2b c2		 sub	 eax, edx
  021c7	d1 ef		 shr	 edi, 1

; 324  : 	pDph_t->arg1 = durin;

  021c9	66 89 86 c4 11
	00 00		 mov	 WORD PTR [esi+4548], ax
  021d0	66 89 be c6 11
	00 00		 mov	 WORD PTR [esi+4550], di

; 325  : 	durin = mlsh1 (pDph_t->arg1, pDph_t->arg2);

  021d7	0f bf c0	 movsx	 eax, ax
  021da	0f bf d7	 movsx	 edx, di
  021dd	0f af c2	 imul	 eax, edx
  021e0	c1 f8 0e	 sar	 eax, 14			; 0000000eH

; 326  : 
; 327  : 	/* See that this time does not exceed halfmaxdur */
; 328  : 	if (durin > halfmaxdur)

  021e3	66 3b c1	 cmp	 ax, cx
  021e6	7e 02		 jle	 SHORT $L71793

; 329  : 		durin = halfmaxdur;

  021e8	8b c1		 mov	 eax, ecx
$L71793:

; 330  : 
; 331  : 	/* Convert back to true time */
; 332  : 	durin = halfmaxdur - durin;

  021ea	8b d1		 mov	 edx, ecx
  021ec	5f		 pop	 edi
  021ed	2b d0		 sub	 edx, eax
  021ef	5e		 pop	 esi

; 333  : 	if (foldswitch == 1)

  021f0	66 83 fd 01	 cmp	 bp, 1
  021f4	5d		 pop	 ebp
  021f5	5b		 pop	 ebx
  021f6	75 09		 jne	 SHORT $L71794

; 334  : 		durin = halfmaxdur + halfmaxdur - durin;

  021f8	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  021fb	8b c8		 mov	 ecx, eax
  021fd	2b ca		 sub	 ecx, edx
  021ff	8b d1		 mov	 edx, ecx
$L71794:

; 335  : 
; 336  : 	/* Minimum value is one */
; 337  : 	if (durin < NSAMP_FRAME)

  02201	66 83 fa 47	 cmp	 dx, 71			; 00000047H
  02205	7d 05		 jge	 SHORT $L71795

; 338  : 		durin = NSAMP_FRAME;

  02207	ba 47 00 00 00	 mov	 edx, 71			; 00000047H
$L71795:

; 339  : 
; 340  : 	return (durin >> 6);

  0220c	0f bf c2	 movsx	 eax, dx
  0220f	c1 f8 06	 sar	 eax, 6

; 341  : }

  02212	c3		 ret	 0
_shrdur	ENDP
_TEXT	ENDS
EXTRN	_inhdr:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_psInhdr_frames$ = 12
_psShrink$ = 16
_psShrif$ = 20
_psShrib$ = 24
_psPholas$ = 28
_psFealas$ = 32
_psFeacur$ = 36
_psFeanex$ = 40
_psStruclm2$ = 44
_psStruclas$ = 48
_psStruccur$ = 52
_psStrucnex$ = 56
_ppsNdips$ = 60
_psPhonp2$ = 64
_init_variables PROC NEAR

; 1245 : {

  02220	53		 push	 ebx
  02221	55		 push	 ebp

; 1246 : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  02222	8b 6c 24 0c	 mov	 ebp, DWORD PTR _phTTS$[esp+4]
  02226	56		 push	 esi
  02227	57		 push	 edi
  02228	8b 75 18	 mov	 esi, DWORD PTR [ebp+24]

; 1247 : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 1248 : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;
; 1249 : 
; 1250 : 	if (pDph_t->nphone == 0)

  0222b	66 8b 86 1c 20
	00 00		 mov	 ax, WORD PTR [esi+8220]
  02232	8b be 48 28 00
	00		 mov	 edi, DWORD PTR [esi+10312]
  02238	66 85 c0	 test	 ax, ax
  0223b	75 52		 jne	 SHORT $L71934

; 1251 : 	{
; 1252 : 		*psStruclm2 = 0;

  0223d	8b 44 24 38	 mov	 eax, DWORD PTR _psStruclm2$[esp+12]

; 1253 : 		*psPholas = SIL;

  02241	8b 4c 24 28	 mov	 ecx, DWORD PTR _psPholas$[esp+12]
  02245	66 c7 00 00 00	 mov	 WORD PTR [eax], 0
  0224a	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0

; 1254 : 		if (pDphsettar->initsw == 0)

  0224f	66 83 7f 0e 00	 cmp	 WORD PTR [edi+14], 0
  02254	75 72		 jne	 SHORT $L71939

; 1255 : 		{
; 1256 : 			pDphsettar->initsw++;
; 1257 : 			for (pDphsettar->np = &PF1; pDphsettar->np <= &PTILT; pDphsettar->np++)

  02256	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
  02259	8d 9e 40 02 00
	00		 lea	 ebx, DWORD PTR [esi+576]
  0225f	3b c3		 cmp	 eax, ebx
  02261	66 c7 47 0e 01
	00		 mov	 WORD PTR [edi+14], 1
  02267	89 47 10	 mov	 DWORD PTR [edi+16], eax
  0226a	77 5c		 ja	 SHORT $L71939
$L71936:

; 1258 : 			{
; 1259 : 				pDphsettar->np->tarend = getbegtar (phTTS, 0);

  0226c	6a 00		 push	 0
  0226e	55		 push	 ebp
  0226f	e8 00 00 00 00	 call	 _getbegtar
  02274	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  02277	83 c4 08	 add	 esp, 8
  0227a	66 89 42 1a	 mov	 WORD PTR [edx+26], ax
  0227e	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  02281	83 c1 24	 add	 ecx, 36			; 00000024H
  02284	8b c1		 mov	 eax, ecx
  02286	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  02289	3b c3		 cmp	 eax, ebx
  0228b	76 df		 jbe	 SHORT $L71936

; 1260 : 			}
; 1261 : 		}
; 1262 : 	}
; 1263 : 	else

  0228d	eb 39		 jmp	 SHORT $L71939
$L71934:

; 1264 : 	{
; 1265 : 		if (pDph_t->nphone > 1)

  0228f	66 3d 01 00	 cmp	 ax, 1
  02293	7e 12		 jle	 SHORT $L71940

; 1266 : 			*psStruclm2 = pDph_t->allofeats[pDph_t->nphone - 2];

  02295	8b 54 24 38	 mov	 edx, DWORD PTR _psStruclm2$[esp+12]
  02299	0f bf c0	 movsx	 eax, ax
  0229c	66 8b 8c 86 68
	05 00 00	 mov	 cx, WORD PTR [esi+eax*4+1384]
  022a4	66 89 0a	 mov	 WORD PTR [edx], cx
$L71940:

; 1267 : 		*psPholas = pDphsettar->phcur;

  022a7	8b 4c 24 28	 mov	 ecx, DWORD PTR _psPholas$[esp+12]
  022ab	66 8b 47 18	 mov	 ax, WORD PTR [edi+24]
  022af	66 89 01	 mov	 WORD PTR [ecx], ax

; 1268 : 		*psStruclas = pDph_t->allofeats[pDph_t->nphone - 1];

  022b2	8b 4c 24 3c	 mov	 ecx, DWORD PTR _psStruclas$[esp+12]
  022b6	0f bf 96 1c 20
	00 00		 movsx	 edx, WORD PTR [esi+8220]
  022bd	66 8b 84 96 6c
	05 00 00	 mov	 ax, WORD PTR [esi+edx*4+1388]
  022c5	66 89 01	 mov	 WORD PTR [ecx], ax
$L71939:

; 1269 : 	}
; 1270 : 	/* Begin normal initialization of variables for new phoneme */
; 1271 : 
; 1272 : 	pDphsettar->phcur = pDph_t->allophons[pDph_t->nphone];

  022c8	0f bf 96 1c 20
	00 00		 movsx	 edx, WORD PTR [esi+8220]
  022cf	66 8b 84 56 02
	03 00 00	 mov	 ax, WORD PTR [esi+edx*2+770]
  022d7	66 89 47 18	 mov	 WORD PTR [edi+24], ax

; 1273 : 	*psStruccur = pDph_t->allofeats[pDph_t->nphone];

  022db	8b 44 24 40	 mov	 eax, DWORD PTR _psStruccur$[esp+12]
  022df	0f bf 8e 1c 20
	00 00		 movsx	 ecx, WORD PTR [esi+8220]
  022e6	66 8b 94 8e 70
	05 00 00	 mov	 dx, WORD PTR [esi+ecx*4+1392]
  022ee	66 89 10	 mov	 WORD PTR [eax], dx

; 1274 : 
; 1275 : 	if (pDph_t->nphone < (pDph_t->nallotot - 1))

  022f1	0f bf 8e ae 11
	00 00		 movsx	 ecx, WORD PTR [esi+4526]
  022f8	0f bf 86 1c 20
	00 00		 movsx	 eax, WORD PTR [esi+8220]
  022ff	49		 dec	 ecx
  02300	3b c1		 cmp	 eax, ecx
  02302	7d 24		 jge	 SHORT $L71941

; 1276 : 	{
; 1277 : 		pDphsettar->phonex = pDph_t->allophons[pDph_t->nphone + 1];

  02304	66 8b 94 46 04
	03 00 00	 mov	 dx, WORD PTR [esi+eax*2+772]
  0230c	66 89 57 0a	 mov	 WORD PTR [edi+10], dx

; 1278 : 		*psStrucnex = pDph_t->allofeats[pDph_t->nphone + 1];

  02310	8b 54 24 44	 mov	 edx, DWORD PTR _psStrucnex$[esp+12]
  02314	0f bf 86 1c 20
	00 00		 movsx	 eax, WORD PTR [esi+8220]
  0231b	66 8b 8c 86 74
	05 00 00	 mov	 cx, WORD PTR [esi+eax*4+1396]
  02323	66 89 0a	 mov	 WORD PTR [edx], cx

; 1279 : 	}
; 1280 : 	else

  02326	eb 0f		 jmp	 SHORT $L71942
$L71941:

; 1281 : 	{
; 1282 : 		pDphsettar->phonex = SIL;
; 1283 : 		*psStrucnex = 0;

  02328	8b 44 24 44	 mov	 eax, DWORD PTR _psStrucnex$[esp+12]
  0232c	66 c7 47 0a 00
	00		 mov	 WORD PTR [edi+10], 0
  02332	66 c7 00 00 00	 mov	 WORD PTR [eax], 0
$L71942:

; 1284 : 	}
; 1285 : 	/* MVP:The below if..else is invalid as the value of phonp2 is never used */
; 1286 : 	/* Hence, the code is commented out(#ifdef IF_ED_OUT_CODE ) */
; 1287 :    /* back in, phonp2 is used in german */
; 1288 :    if (pDph_t->nphone < (pDph_t->nallotot - 2))

  02337	0f bf 8e ae 11
	00 00		 movsx	 ecx, WORD PTR [esi+4526]
  0233e	0f bf 86 1c 20
	00 00		 movsx	 eax, WORD PTR [esi+8220]
  02345	83 e9 02	 sub	 ecx, 2
  02348	3b c1		 cmp	 eax, ecx
  0234a	7d 11		 jge	 SHORT $L71943

; 1289 :    {
; 1290 :       *psPhonp2 = pDph_t->allophons[pDph_t->nphone + 2];

  0234c	66 8b 94 46 06
	03 00 00	 mov	 dx, WORD PTR [esi+eax*2+774]
  02354	8b 44 24 4c	 mov	 eax, DWORD PTR _psPhonp2$[esp+12]
  02358	66 89 10	 mov	 WORD PTR [eax], dx

; 1291 :    }
; 1292 :    else

  0235b	eb 09		 jmp	 SHORT $L71944
$L71943:

; 1293 :    {
; 1294 :       *psPhonp2 = SIL;

  0235d	8b 4c 24 4c	 mov	 ecx, DWORD PTR _psPhonp2$[esp+12]
  02361	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0
$L71944:

; 1295 :    }
; 1296 : 
; 1297 : 	*ppsNdips = &(pDph_t->dipspec[1]); /* Initialize pointer to diph info for phone */

  02366	8b 44 24 48	 mov	 eax, DWORD PTR _ppsNdips$[esp+12]

; 1298 : 
; 1299 : 	/* Precompute often-used variables */
; 1300 : 
; 1301 : 	*psFealas = featb[*psPholas];

  0236a	8b 4c 24 28	 mov	 ecx, DWORD PTR _psPholas$[esp+12]
  0236e	8d 96 c2 1f 00
	00		 lea	 edx, DWORD PTR [esi+8130]

; 1302 : 	*psFeacur = featb[pDphsettar->phcur];

  02374	8b 5c 24 30	 mov	 ebx, DWORD PTR _psFeacur$[esp+12]
  02378	89 10		 mov	 DWORD PTR [eax], edx
  0237a	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  0237d	8b 4c 24 2c	 mov	 ecx, DWORD PTR _psFealas$[esp+12]
  02381	66 8b 04 55 00
	00 00 00	 mov	 ax, WORD PTR _featb[edx*2]
  02389	66 89 01	 mov	 WORD PTR [ecx], ax
  0238c	0f bf 57 18	 movsx	 edx, WORD PTR [edi+24]
  02390	66 8b 04 55 00
	00 00 00	 mov	 ax, WORD PTR _featb[edx*2]
  02398	66 89 03	 mov	 WORD PTR [ebx], ax

; 1303 : 	*psFeanex = featb[pDphsettar->phonex];

  0239b	8b 44 24 34	 mov	 eax, DWORD PTR _psFeanex$[esp+12]
  0239f	0f bf 4f 0a	 movsx	 ecx, WORD PTR [edi+10]
  023a3	66 8b 14 4d 00
	00 00 00	 mov	 dx, WORD PTR _featb[ecx*2]
  023ab	66 89 10	 mov	 WORD PTR [eax], dx

; 1304 : 
; 1305 : 	*psInhdr_frames = mstofr (inhdr[pDphsettar->phcur]);    /* Inherent dur in frames */

  023ae	0f bf 4f 18	 movsx	 ecx, WORD PTR [edi+24]
  023b2	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR _inhdr[ecx*2]
  023ba	52		 push	 edx
  023bb	e8 00 00 00 00	 call	 _mstofr
  023c0	8b 6c 24 1c	 mov	 ebp, DWORD PTR _psInhdr_frames$[esp+16]
  023c4	83 c4 04	 add	 esp, 4
  023c7	66 89 45 00	 mov	 WORD PTR [ebp], ax

; 1306 : 
; 1307 : 	/* Transition durs are shorter if phone dur is short rel to inherent dur */
; 1308 : 	/* Compute change in duration rel. to inherent dur if a sonorant */
; 1309 : 	if (((*psFeacur & FOBST) IS_MINUS) && (pDphsettar->phcur != SIL))

  023cb	8a 0b		 mov	 cl, BYTE PTR [ebx]
  023cd	f6 c1 20	 test	 cl, 32			; 00000020H
  023d0	75 74		 jne	 SHORT $L72065
  023d2	33 db		 xor	 ebx, ebx
  023d4	66 39 5f 18	 cmp	 WORD PTR [edi+24], bx
  023d8	74 6e		 je	 SHORT $L71945

; 1310 : 	{
; 1311 : 		/* Shrink,shrif,shrib only apply to sonorants */
; 1312 : 		if (pDph_t->durfon < (*psInhdr_frames << 1))

  023da	66 8b 8e ac 11
	00 00		 mov	 cx, WORD PTR [esi+4524]
  023e1	0f bf c0	 movsx	 eax, ax
  023e4	0f bf d1	 movsx	 edx, cx
  023e7	d1 e0		 shl	 eax, 1
  023e9	3b d0		 cmp	 edx, eax
  023eb	7d 2f		 jge	 SHORT $L71946

; 1313 : 		{                                                          /* durfon can't exceed 2*inhd */
; 1314 : 			pDph_t->arg1 = FRAC_ONE;

  023ed	66 c7 86 c4 11
	00 00 00 40	 mov	 WORD PTR [esi+4548], 16384 ; 00004000H

; 1315 : 			pDph_t->arg2 = pDph_t->durfon;

  023f6	66 89 8e c6 11
	00 00		 mov	 WORD PTR [esi+4550], cx

; 1316 : 			pDph_t->arg3 = *psInhdr_frames;

  023fd	66 8b 4d 00	 mov	 cx, WORD PTR [ebp]

; 1317 : 			*psShrink = muldv (pDph_t->arg1, pDph_t->arg2, pDph_t->arg3);   /* = FRAC_ONE, i.e. 16384 if no */

  02401	8b c2		 mov	 eax, edx
  02403	66 89 8e c8 11
	00 00		 mov	 WORD PTR [esi+4552], cx
  0240a	c1 e0 0e	 shl	 eax, 14			; 0000000eH
  0240d	0f bf c9	 movsx	 ecx, cx
  02410	99		 cdq
  02411	f7 f9		 idiv	 ecx
  02413	8b 4c 24 1c	 mov	 ecx, DWORD PTR _psShrink$[esp+12]
  02417	66 89 01	 mov	 WORD PTR [ecx], ax

; 1318 : 		}
; 1319 : 		else

  0241a	eb 09		 jmp	 SHORT $L71947
$L71946:

; 1320 : 		{
; 1321 : 			*psShrink = FRAC_ONE + (FRAC_ONE - 1);  /* IS THIS AN ERROR ??? */

  0241c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _psShrink$[esp+12]
  02420	66 c7 01 ff 7f	 mov	 WORD PTR [ecx], 32767	; 00007fffH
$L71947:

; 1322 : 		}
; 1323 : 		/* Shrinkage factor for formant transitions inside sonorants */
; 1324 : 		*psShrif = (*psShrink >> 1) + FRAC_HALF;

  02425	66 8b 11	 mov	 dx, WORD PTR [ecx]
  02428	8b 4c 24 20	 mov	 ecx, DWORD PTR _psShrif$[esp+12]
  0242c	66 d1 fa	 sar	 dx, 1
  0242f	8d 82 00 20 00
	00		 lea	 eax, DWORD PTR [edx+8192]

; 1325 : 		/* Ditto for backward transition, which is slightly (15%) faster */
; 1326 : 		*psShrib = *psShrif - 1600;

  02435	8b 54 24 24	 mov	 edx, DWORD PTR _psShrib$[esp+12]
  02439	66 89 01	 mov	 WORD PTR [ecx], ax
  0243c	05 c0 f9 ff ff	 add	 eax, -1600		; fffff9c0H
  02441	66 89 02	 mov	 WORD PTR [edx], ax
  02444	eb 02		 jmp	 SHORT $L71945
$L72065:
  02446	33 db		 xor	 ebx, ebx
$L71945:

; 1327 : 	}
; 1328 : 	PAV.tspesh = 0;                                    /* Default case: set 'end time' of special  */

  02448	66 89 9e 32 01
	00 00		 mov	 WORD PTR [esi+306], bx

; 1329 : 	PAP.tspesh = 0;                                    /* constant override of computed parameter */

  0244f	66 89 9e 56 01
	00 00		 mov	 WORD PTR [esi+342], bx

; 1330 : 	PF1.tspesh = 0;

  02456	66 89 5e 36	 mov	 WORD PTR [esi+54], bx

; 1331 : 	PB1.tspesh = 0;                                    /* value to zero, i.e. no special override */

  0245a	66 89 9e c6 00
	00 00		 mov	 WORD PTR [esi+198], bx

; 1332 : 	PB2.tspesh = 0;                                    /* for this phone.                          */

  02461	66 89 9e ea 00
	00 00		 mov	 WORD PTR [esi+234], bx

; 1333 : 	PB3.tspesh = 0;

  02468	66 89 9e 0e 01
	00 00		 mov	 WORD PTR [esi+270], bx

; 1334 : 	PA2.tspesh = 0;

  0246f	66 89 9e 7a 01
	00 00		 mov	 WORD PTR [esi+378], bx

; 1335 : 	PA3.tspesh = 0;                                    /* If rules below set to non-zero, substitute */

  02476	66 89 9e 9e 01
	00 00		 mov	 WORD PTR [esi+414], bx

; 1336 : 	PA4.tspesh = 0;                                    /* pspesh for computed value over time       */

  0247d	66 89 9e c2 01
	00 00		 mov	 WORD PTR [esi+450], bx

; 1337 : 	PA5.tspesh = 0;                                    /* interval from beginning of phone (done   */

  02484	66 89 9e e6 01
	00 00		 mov	 WORD PTR [esi+486], bx

; 1338 : 	PA6.tspesh = 0;                                    /* in PH_DRAW.C                      */

  0248b	66 89 9e 0a 02
	00 00		 mov	 WORD PTR [esi+522], bx

; 1339 : 	PAB.tspesh = 0;

  02492	66 89 9e 2e 02
	00 00		 mov	 WORD PTR [esi+558], bx

; 1340 : 	PTILT.tspesh = 0;

  02499	66 89 9e 52 02
	00 00		 mov	 WORD PTR [esi+594], bx
  024a0	5f		 pop	 edi
  024a1	5e		 pop	 esi
  024a2	5d		 pop	 ebp
  024a3	5b		 pop	 ebx

; 1341 : 
; 1342 : }

  024a4	c3		 ret	 0
_init_variables ENDP
_TEXT	ENDS
END
