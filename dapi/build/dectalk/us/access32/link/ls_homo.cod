	TITLE	D:\work\Product\dapi\src\Lts\ls_homo.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_homo_table
_DATA	SEGMENT
_homo_table DD	080H
	DD	00H
	DD	00H
	DD	0400H
	DD	080H
	DD	04H
	DD	01H
	DD	00H
	DD	0200H
	DD	00H
	DD	00H
	DD	0400H
	DD	0200H
	DD	04H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	00H
	DD	020001H
	DD	00H
	DD	00H
	DD	0400H
	DD	020400H
	DD	00H
	DD	00H
	DD	01H
	DD	0401H
	DD	00H
	DD	00H
	DD	020000H
	DD	00H
	DD	020H
	DD	01H
	DD	00H
	DD	00H
	DD	0100000H
	DD	020000H
	DD	00H
	DD	00H
	DD	010000H
	DD	020000H
	DD	00H
	DD	00H
	DD	040000H
	DD	00H
	DD	0400H
	DD	00H
	DD	0100H
	DD	080H
	DD	00H
	DD	00H
	DD	020H
	DD	080H
	DD	00H
	DD	00H
	DD	010H
	DD	080H
	DD	00H
	DD	00H
	DD	08H
	DD	020000H
	DD	00H
	DD	00H
	DD	0100H
	DD	020000H
	DD	00H
	DD	00H
	DD	020H
	DD	020000H
	DD	00H
	DD	00H
	DD	010H
	DD	020000H
	DD	00H
	DD	00H
	DD	02000H
	DD	020000H
	DD	00H
	DD	00H
	DD	01000H
	DD	00H
	DD	020000H
	DD	00H
	DD	04H
	DD	00H
	DD	020000H
	DD	00H
	DD	04H
	DD	0400H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	020000H
	DD	00H
	DD	01H
	DD	0400H
	DD	00H
	DD	00H
	DD	020000H
	DD	0400H
	DD	00H
	DD	00H
	DD	0800H
	DD	0400H
	DD	00H
_DATA	ENDS
PUBLIC	_ls_homo_homo
EXTRN	__imp__fprintf:NEAR
EXTRN	__imp__printf:NEAR
_DATA	SEGMENT
$SG71835 DB	0aH, 'HOMO:(%d)', 00H
	ORG $+1
$SG71836 DB	0aH, 'HOMO:(%d)', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_index$ = 12
_i$ = 8
_pLts_t$ = -4
_pKsd_t$ = -8
_ls_homo_homo PROC NEAR

; 83   : {

  00000	83 ec 08	 sub	 esp, 8

; 84   : 	struct dic_entry far *entry_temporary;
; 85   : 	struct dic_entry far *entry_primary;
; 86   : 	struct dic_entry far *entry_secondary;
; 87   : 	int	i,try_other; 
; 88   : 	PLTS_T	pLts_t;
; 89   : 	PKSD_T	pKsd_t;
; 90   : 
; 91   : 
; 92   : 	pLts_t = phTTS->pLTSThreadData;

  00003	8b 44 24 0c	 mov	 eax, DWORD PTR _phTTS$[esp+4]
  00007	53		 push	 ebx
  00008	55		 push	 ebp

; 93   : 	pKsd_t = phTTS->pKernelShareData;   
; 94   : 
; 95   : 	/*
; 96   : 	 *  homograph is either right before this or right after ...
; 97   : 	 */
; 98   : 
; 99   : 	entry_primary = DICT_ACCESS(index-1);

  00009	8b 6c 24 18	 mov	 ebp, DWORD PTR _index$[esp+12]
  0000d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00010	56		 push	 esi
  00011	89 4c 24 10	 mov	 DWORD PTR _pLts_t$[esp+20], ecx
  00015	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00018	57		 push	 edi
  00019	89 4c 24 10	 mov	 DWORD PTR _pKsd_t$[esp+24], ecx
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	8b 59 1c	 mov	 ebx, DWORD PTR [ecx+28]

; 100  : 	entry_secondary = DICT_ACCESS(index);

  00022	8b fb		 mov	 edi, ebx
  00024	8b 04 aa	 mov	 eax, DWORD PTR [edx+ebp*4]
  00027	8b 74 aa fc	 mov	 esi, DWORD PTR [edx+ebp*4-4]
  0002b	03 f8		 add	 edi, eax
  0002d	03 f3		 add	 esi, ebx

; 101  : 	try_other = true;
; 102  : 
; 103  : 	if(DES.fc & FC_HOMOGRAPH)

  0002f	f7 07 00 00 00
	80		 test	 DWORD PTR [edi], -2147483648 ; 80000000H
  00035	74 45		 je	 SHORT $L71893

; 104  : 	{
; 105  : 		for(i=0;DES.text[i];i++)

  00037	8a 4f 04	 mov	 cl, BYTE PTR [edi+4]
  0003a	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  0003d	84 c9		 test	 cl, cl
  0003f	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _i$[esp+20], 0
  00047	74 1d		 je	 SHORT $L71899
  00049	8b ee		 mov	 ebp, esi
  0004b	2b ef		 sub	 ebp, edi
$L71788:

; 106  : 		{
; 107  : 			if(DEP.text[i] != DES.text[i])

  0004d	38 0c 28	 cmp	 BYTE PTR [eax+ebp], cl
  00050	75 10		 jne	 SHORT $L71895
  00052	8b 4c 24 1c	 mov	 ecx, DWORD PTR _i$[esp+20]
  00056	41		 inc	 ecx
  00057	40		 inc	 eax
  00058	89 4c 24 1c	 mov	 DWORD PTR _i$[esp+20], ecx
  0005c	8a 08		 mov	 cl, BYTE PTR [eax]
  0005e	84 c9		 test	 cl, cl
  00060	75 eb		 jne	 SHORT $L71788
$L71895:

; 104  : 	{
; 105  : 		for(i=0;DES.text[i];i++)

  00062	8b 6c 24 20	 mov	 ebp, DWORD PTR _index$[esp+20]
$L71899:

; 108  : 			{
; 109  : #ifdef HDEBUG
; 110  : 				printf("at2 %d %d \n",entry_primary,entry_secondary);
; 111  :     			printf("landed incor \n");
; 112  : #endif
; 113  : 				break;
; 114  : 			}
; 115  : 		}
; 116  : 		if(DEP.text[i] == '\0' && DES.text[i] == '\0')

  00066	8b 44 24 1c	 mov	 eax, DWORD PTR _i$[esp+20]
  0006a	8b 4c 24 10	 mov	 ecx, DWORD PTR _pKsd_t$[esp+24]
  0006e	80 7c 30 04 00	 cmp	 BYTE PTR [eax+esi+4], 0
  00073	75 07		 jne	 SHORT $L71893
  00075	80 7c 38 04 00	 cmp	 BYTE PTR [eax+edi+4], 0

; 117  : 		{
; 118  : #ifdef HDEBUG
; 119  : 			printf("landed cor \n");
; 120  : #endif
; 121  : 
; 122  : 			try_other = false;
; 123  : 		}
; 124  : 	}
; 125  : 	if(try_other)

  0007a	74 62		 je	 SHORT $L71804
$L71893:

; 126  : 	{
; 127  : 		index++;
; 128  : 		entry_primary = DICT_ACCESS(index-1);

  0007c	8b 34 aa	 mov	 esi, DWORD PTR [edx+ebp*4]

; 129  : 		entry_secondary = DICT_ACCESS(index);

  0007f	8b 54 aa 04	 mov	 edx, DWORD PTR [edx+ebp*4+4]
  00083	45		 inc	 ebp
  00084	03 f3		 add	 esi, ebx

; 130  : 		if(DES.fc & FC_HOMOGRAPH)

  00086	8b 2c 13	 mov	 ebp, DWORD PTR [ebx+edx]
  00089	8d 3c 13	 lea	 edi, DWORD PTR [ebx+edx]
  0008c	f7 c5 00 00 00
	80		 test	 ebp, -2147483648	; 80000000H
  00092	0f 84 9a 02 00
	00		 je	 $L71894

; 131  : 		{
; 132  : 
; 133  : 			for(i=0;DES.text[i];i++)

  00098	8a 57 04	 mov	 dl, BYTE PTR [edi+4]
  0009b	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  0009e	33 db		 xor	 ebx, ebx
  000a0	84 d2		 test	 dl, dl
  000a2	74 18		 je	 SHORT $L71885

; 134  : 			{
; 135  : 				if(DEP.text[i] != DES.text[i])

  000a4	8a ca		 mov	 cl, dl
  000a6	8b d6		 mov	 edx, esi
  000a8	2b d7		 sub	 edx, edi
$L71797:
  000aa	38 0c 10	 cmp	 BYTE PTR [eax+edx], cl
  000ad	75 09		 jne	 SHORT $L71898
  000af	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  000b2	43		 inc	 ebx
  000b3	40		 inc	 eax
  000b4	84 c9		 test	 cl, cl
  000b6	75 f2		 jne	 SHORT $L71797
$L71898:

; 131  : 		{
; 132  : 
; 133  : 			for(i=0;DES.text[i];i++)

  000b8	8b 4c 24 10	 mov	 ecx, DWORD PTR _pKsd_t$[esp+24]
$L71885:

; 136  : 				{
; 137  : #ifdef HDEBUG
; 138  : 					printf("plus and minus failed???");
; 139  : #endif
; 140  : 					break;
; 141  : 
; 142  : 				}
; 143  : 			}
; 144  : 			if(DEP.text[i] == '\0' && DES.text[i] == '\0')

  000bc	8a 44 33 04	 mov	 al, BYTE PTR [ebx+esi+4]
  000c0	84 c0		 test	 al, al
  000c2	0f 85 6a 02 00
	00		 jne	 $L71894
  000c8	8a 44 3b 04	 mov	 al, BYTE PTR [ebx+edi+4]
  000cc	84 c0		 test	 al, al
  000ce	0f 85 5e 02 00
	00		 jne	 $L71894

; 145  : 			{
; 146  : 				/*match on + code so primnary=index+1 */
; 147  : #ifdef HDEBUG
; 148  : 				printf("gtcha. reversing.");
; 149  : #endif
; 150  : 				if(DES.fc & FC_CHARACTER)

  000d4	f7 c5 00 00 00
	02		 test	 ebp, 33554432		; 02000000H
  000da	74 02		 je	 SHORT $L71804

; 151  : 				{
; 152  : 
; 153  : 					entry_primary = entry_secondary;

  000dc	8b f7		 mov	 esi, edi
$L71804:

; 154  : 					entry_secondary = DICT_ACCESS(index);
; 155  : #ifdef HDEBUG
; 156  : 
; 157  : 		printf("rever again");
; 158  : #endif
; 159  : 				}	
; 160  : 				try_other = false;
; 161  : 			}
; 162  : 		}
; 163  : 			
; 164  : 	}
; 165  : 
; 166  : 	/* GL 09/29/98, remove the FC_CHARACTER which is used as primary homo indicator */
; 167  : #if 0 //This code is dumb. MGS 07/14/00
; 168  : 	if(DEP.fc & FC_CHARACTER)
; 169  : 	{
; 170  : 
; 171  : 	    DEP.fc = DEP.fc & ~FC_CHARACTER;
; 172  : 	}
; 173  : #endif
; 174  : 	
; 175  : 	if(try_other)
; 176  : 	{
; 177  : 		return(entry_primary);
; 178  : 	}
; 179  : 
; 180  : 	/*
; 181  : 	 *  set the primary and secondary field correctly ...
; 182  : 	 */
; 183  : 
; 184  : 	/*
; 185  : 	 *  change 5/12/96, GL
; 186  : 	 *  both primary and alternate only apply to next word only.
; 187  : 	 */
; 188  : 	
; 189  :         if(pKsd_t->pronflag & PRON_DIC_PRIMARY)

  000de	8b 81 cc 03 00
	00		 mov	 eax, DWORD PTR [ecx+972]
  000e4	a8 01		 test	 al, 1
  000e6	74 12		 je	 SHORT $L71805

; 190  :         {
; 191  :                 pKsd_t->pronflag &= (~PRON_DIC_PRIMARY);

  000e8	24 fe		 and	 al, -2			; fffffffeH
  000ea	5f		 pop	 edi
  000eb	89 81 cc 03 00
	00		 mov	 DWORD PTR [ecx+972], eax

; 365  : 	}
; 366  : 
; 367  : 	return(entry_primary);

  000f1	8b c6		 mov	 eax, esi
  000f3	5e		 pop	 esi
  000f4	5d		 pop	 ebp
  000f5	5b		 pop	 ebx

; 368  : 
; 369  : }

  000f6	83 c4 08	 add	 esp, 8
  000f9	c3		 ret	 0
$L71805:

; 192  :                 return(entry_primary);
; 193  :         }
; 194  :         if(pKsd_t->pronflag & PRON_DIC_ALTERNATE)

  000fa	a8 02		 test	 al, 2
  000fc	74 12		 je	 SHORT $L71806

; 195  :         {
; 196  :                 pKsd_t->pronflag &= (~PRON_DIC_ALTERNATE);

  000fe	24 fd		 and	 al, -3			; fffffffdH
  00100	89 81 cc 03 00
	00		 mov	 DWORD PTR [ecx+972], eax

; 197  :                 return(entry_secondary);

  00106	8b c7		 mov	 eax, edi
  00108	5f		 pop	 edi
  00109	5e		 pop	 esi
  0010a	5d		 pop	 ebp
  0010b	5b		 pop	 ebx

; 368  : 
; 369  : }

  0010c	83 c4 08	 add	 esp, 8
  0010f	c3		 ret	 0
$L71806:

; 198  : 		}
; 199  : 
; 200  : 
; 201  : 		if(pKsd_t->pronflag & PRON_DIC_NOUN)

  00110	a8 08		 test	 al, 8
  00112	74 28		 je	 SHORT $L71807

; 202  :         {
; 203  : 			pKsd_t->pronflag &= (~PRON_DIC_NOUN);

  00114	24 f7		 and	 al, -9			; fffffff7H
  00116	89 81 cc 03 00
	00		 mov	 DWORD PTR [ecx+972], eax

; 204  : 			if(DEP.fc & FC_NOUN)

  0011c	8b 06		 mov	 eax, DWORD PTR [esi]
  0011e	f6 c4 04	 test	 ah, 4

; 205  : 				return(entry_primary);

  00121	0f 85 0b 02 00
	00		 jne	 $L71894

; 206  : 			if(DES.fc & FC_NOUN)

  00127	8b 07		 mov	 eax, DWORD PTR [edi]
  00129	f6 c4 04	 test	 ah, 4
  0012c	0f 84 00 02 00
	00		 je	 $L71894

; 207  : 				return(entry_secondary);

  00132	8b c7		 mov	 eax, edi
  00134	5f		 pop	 edi
  00135	5e		 pop	 esi
  00136	5d		 pop	 ebp
  00137	5b		 pop	 ebx

; 368  : 
; 369  : }

  00138	83 c4 08	 add	 esp, 8
  0013b	c3		 ret	 0
$L71807:

; 208  : 			return(entry_primary);
; 209  :         }
; 210  : 		if(pKsd_t->pronflag & PRON_DIC_VERB)

  0013c	a8 10		 test	 al, 16			; 00000010H
  0013e	74 2b		 je	 SHORT $L71810

; 211  :         {
; 212  : 			pKsd_t->pronflag &= (~PRON_DIC_VERB);

  00140	24 ef		 and	 al, -17			; ffffffefH
  00142	89 81 cc 03 00
	00		 mov	 DWORD PTR [ecx+972], eax

; 213  : 			if(DEP.fc & FC_VERB)

  00148	8b 06		 mov	 eax, DWORD PTR [esi]
  0014a	a9 00 00 02 00	 test	 eax, 131072		; 00020000H

; 214  : 				return(entry_primary);

  0014f	0f 85 dd 01 00
	00		 jne	 $L71894

; 215  : 			if(DES.fc & FC_VERB)

  00155	f7 07 00 00 02
	00		 test	 DWORD PTR [edi], 131072	; 00020000H
  0015b	0f 84 d1 01 00
	00		 je	 $L71894

; 216  : 				return(entry_secondary);

  00161	8b c7		 mov	 eax, edi
  00163	5f		 pop	 edi
  00164	5e		 pop	 esi
  00165	5d		 pop	 ebp
  00166	5b		 pop	 ebx

; 368  : 
; 369  : }

  00167	83 c4 08	 add	 esp, 8
  0016a	c3		 ret	 0
$L71810:

; 217  : 			return(entry_primary);
; 218  :         }
; 219  : 		if(pKsd_t->pronflag & PRON_DIC_ADJECTIVE)

  0016b	a8 20		 test	 al, 32			; 00000020H
  0016d	74 25		 je	 SHORT $L71813

; 220  :         {
; 221  : 			pKsd_t->pronflag &= (~PRON_DIC_ADJECTIVE);

  0016f	24 df		 and	 al, -33			; ffffffdfH
  00171	89 81 cc 03 00
	00		 mov	 DWORD PTR [ecx+972], eax

; 222  : 			if(DEP.fc & FC_ADJ)

  00177	8a 06		 mov	 al, BYTE PTR [esi]
  00179	a8 01		 test	 al, 1

; 223  : 				return(entry_primary);

  0017b	0f 85 b1 01 00
	00		 jne	 $L71894

; 224  : 			if(DES.fc & FC_ADJ)

  00181	f6 07 01	 test	 BYTE PTR [edi], 1
  00184	0f 84 a8 01 00
	00		 je	 $L71894

; 225  : 				return(entry_secondary);

  0018a	8b c7		 mov	 eax, edi
  0018c	5f		 pop	 edi
  0018d	5e		 pop	 esi
  0018e	5d		 pop	 ebp
  0018f	5b		 pop	 ebx

; 368  : 
; 369  : }

  00190	83 c4 08	 add	 esp, 8
  00193	c3		 ret	 0
$L71813:

; 226  : 			return(entry_primary);
; 227  :         }
; 228  : 		if(pKsd_t->pronflag & PRON_DIC_FUNCTION)

  00194	a8 40		 test	 al, 64			; 00000040H
  00196	74 2b		 je	 SHORT $L71816

; 229  :         {
; 230  : 			pKsd_t->pronflag &= (~PRON_DIC_FUNCTION);

  00198	24 bf		 and	 al, -65			; ffffffbfH
  0019a	89 81 cc 03 00
	00		 mov	 DWORD PTR [ecx+972], eax

; 231  : 			if(DEP.fc & FC_FUNC)			/*?? NAL I don't think FUNC (for functor?) is the same as SAPI's "function" */

  001a0	8b 06		 mov	 eax, DWORD PTR [esi]
  001a2	a9 00 00 80 00	 test	 eax, 8388608		; 00800000H

; 232  : 				return(entry_primary);

  001a7	0f 85 85 01 00
	00		 jne	 $L71894

; 233  : 			if(DES.fc & FC_FUNC)

  001ad	f7 07 00 00 80
	00		 test	 DWORD PTR [edi], 8388608 ; 00800000H
  001b3	0f 84 79 01 00
	00		 je	 $L71894

; 234  : 				return(entry_secondary);

  001b9	8b c7		 mov	 eax, edi
  001bb	5f		 pop	 edi
  001bc	5e		 pop	 esi
  001bd	5d		 pop	 ebp
  001be	5b		 pop	 ebx

; 368  : 
; 369  : }

  001bf	83 c4 08	 add	 esp, 8
  001c2	c3		 ret	 0
$L71816:

; 235  : 			return(entry_primary);
; 236  :         }
; 237  : 		if(pKsd_t->pronflag & PRON_DIC_INTERJECTION)

  001c3	a8 80		 test	 al, 128			; 00000080H
  001c5	74 2b		 je	 SHORT $L71819

; 238  :         {
; 239  : 			pKsd_t->pronflag &= (~PRON_DIC_INTERJECTION);

  001c7	24 7f		 and	 al, 127			; 0000007fH
  001c9	89 81 cc 03 00
	00		 mov	 DWORD PTR [ecx+972], eax

; 240  : 			if(DEP.fc & FC_INTER)

  001cf	8b 06		 mov	 eax, DWORD PTR [esi]
  001d1	a9 00 00 10 00	 test	 eax, 1048576		; 00100000H

; 241  : 				return(entry_primary);

  001d6	0f 85 56 01 00
	00		 jne	 $L71894

; 242  : 			if(DES.fc & FC_INTER)

  001dc	f7 07 00 00 10
	00		 test	 DWORD PTR [edi], 1048576 ; 00100000H
  001e2	0f 84 4a 01 00
	00		 je	 $L71894

; 243  : 				return(entry_secondary);

  001e8	8b c7		 mov	 eax, edi
  001ea	5f		 pop	 edi
  001eb	5e		 pop	 esi
  001ec	5d		 pop	 ebp
  001ed	5b		 pop	 ebx

; 368  : 
; 369  : }

  001ee	83 c4 08	 add	 esp, 8
  001f1	c3		 ret	 0
$L71819:

; 244  : 			return(entry_primary);
; 245  :         }
; 246  : 
; 247  :         /*
; 248  :            force the first word to pick up the verb. this may not be 100% right but is better
; 249  :            then dangling there
; 250  : 		   GL 11/04/1996, change to pick up the primary for first word. This could also
; 251  : 		   break some other word since we have no idea which formclass we should use.
; 252  : 		   we ned to lookahead the formclass of next word someday..
; 253  : 		   GL 1/31/1997, actually only "wind" will be the problem for "first word verb"
; 254  : 		   rule.  So force to pick up the primary for "wind" only.
; 255  : 		   can't use strnicmp() in DECtalk kernel
; 256  :            GL 10/22/1997, wind is set to primary in dictionary, so first word always
; 257  : 		   is primary as the way V42C work(for NWS only)
; 258  : 		   EAB 3/21/0000 This is an incorrect assumption in fact tony tried to code it so that the primary
; 259  : 		   entry was the best default.
; 260  : 		*/
; 261  :         if(pLts_t->fc_index == 1)

  001f2	8b 6c 24 14	 mov	 ebp, DWORD PTR _pLts_t$[esp+24]
  001f6	8b 85 bc 08 00
	00		 mov	 eax, DWORD PTR [ebp+2236]
  001fc	83 f8 01	 cmp	 eax, 1

; 262  :         {
; 263  : 
; 264  :            		return(entry_primary);

  001ff	0f 84 2d 01 00
	00		 je	 $L71894

; 265  : 
; 266  : 
; 267  : 
; 268  :         }
; 269  : 
; 270  :     /*
; 271  : 	   GL 07/08/1998 BATS#705 set the previous wordclass to noun if
; 272  : 	                          it is unknown.  Since we did some dictionary
; 273  : 							  reduction for "noun" word for dual language
; 274  : 							  (US+SP) express, this guess should provide
; 275  : 							  the formclass information for these words
; 276  : 							  which got removed.
; 277  : 	*/
; 278  :     if (pLts_t->fc_struct[pLts_t->fc_index-1] == 0)

  00205	8b 94 85 b8 04
	00 00		 mov	 edx, DWORD PTR [ebp+eax*4+1208]
  0020c	85 d2		 test	 edx, edx
  0020e	75 0b		 jne	 SHORT $L71823

; 279  :          pLts_t->fc_struct[pLts_t->fc_index-1] = 0x400;

  00210	c7 84 85 b8 04
	00 00 00 04 00
	00		 mov	 DWORD PTR [ebp+eax*4+1208], 1024 ; 00000400H
$L71823:

; 280  : 
; 281  : 
; 282  : 
; 283  : 	/*
; 284  : 	 *  Now run through the list and try to pick one ...
; 285  : 	 */
; 286  : 
; 287  : 	for(i=0;i<MAX_HOMO_RULE;i++)

  0021b	bb 04 00 00 00	 mov	 ebx, OFFSET FLAT:_homo_table+4
  00220	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _i$[esp+20], 0
  00228	89 5c 24 20	 mov	 DWORD PTR 12+[esp+20], ebx
$L71824:

; 288  : 	{
; 289  : 		/*
; 290  : 		 *  First, if there is no suffix for this rule or the suffix matches a
; 291  : 		 *  stripped suffix ...
; 292  : 		 */
; 293  : 		if(HTAB.h_suffix == 0 || ((HTAB.h_suffix & pLts_t->fc_struct[pLts_t->fc_index]) == (unsigned int)HTAB.h_suffix)) // NAL warning removal

  0022c	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]
  0022f	85 c0		 test	 eax, eax
  00231	74 17		 je	 SHORT $L71829
  00233	8b 95 bc 08 00
	00		 mov	 edx, DWORD PTR [ebp+2236]
  00239	8b 94 95 bc 04
	00 00		 mov	 edx, DWORD PTR [ebp+edx*4+1212]
  00240	23 d0		 and	 edx, eax
  00242	3b d0		 cmp	 edx, eax
  00244	0f 85 9b 00 00
	00		 jne	 $L71825
$L71829:

; 294  : 		{
; 295  : 		    /* GL 3/3/1997 check the word before previous word if
; 296  : 		       previous word is a Adv. */
; 297  : 			if(HTAB.h_context == 0 ||
; 298  : 			  (HTAB.h_context & pLts_t->fc_struct[pLts_t->fc_index-1]) ||
; 299  : 			  ((pLts_t->fc_index >= 3) &&
; 300  : 			   (FC_ADV & pLts_t->fc_struct[pLts_t->fc_index-1]) &&
; 301  : 			   (HTAB.h_context & pLts_t->fc_struct[pLts_t->fc_index-2])))

  0024a	8b 13		 mov	 edx, DWORD PTR [ebx]
  0024c	85 d2		 test	 edx, edx
  0024e	74 28		 je	 SHORT $L71831
  00250	8b 85 bc 08 00
	00		 mov	 eax, DWORD PTR [ebp+2236]
  00256	8b 9c 85 b8 04
	00 00		 mov	 ebx, DWORD PTR [ebp+eax*4+1208]
  0025d	85 d3		 test	 edx, ebx
  0025f	75 13		 jne	 SHORT $L71902
  00261	83 f8 03	 cmp	 eax, 3
  00264	7c 7b		 jl	 SHORT $L71903
  00266	f6 c3 02	 test	 bl, 2
  00269	74 76		 je	 SHORT $L71903
  0026b	85 94 85 b4 04
	00 00		 test	 DWORD PTR [ebp+eax*4+1204], edx
  00272	74 6d		 je	 SHORT $L71903
$L71902:
  00274	8b 5c 24 20	 mov	 ebx, DWORD PTR 12+[esp+20]
$L71831:

; 302  : 			{
; 303  : 				/* debug switch */
; 304  : 				if (DT_DBG(LTS_DBG,0x020))

  00278	66 8b 81 40 06
	00 00		 mov	 ax, WORD PTR [ecx+1600]
  0027f	f6 c4 40	 test	 ah, 64			; 00000040H
  00282	74 3d		 je	 SHORT $L71832
  00284	a8 20		 test	 al, 32			; 00000020H
  00286	74 39		 je	 SHORT $L71832

; 305  : 				{
; 306  : #ifndef MSDOS
; 307  : 					if (pKsd_t->dbglog)			/*mfg 04/28/98 added debug support*/

  00288	8b 81 44 06 00
	00		 mov	 eax, DWORD PTR [ecx+1604]
  0028e	85 c0		 test	 eax, eax
  00290	74 14		 je	 SHORT $L71833

; 308  : 					fprintf((FILE *)pKsd_t->dbglog,"\nHOMO:(%d)",i);

  00292	8b 4c 24 1c	 mov	 ecx, DWORD PTR _i$[esp+20]
  00296	51		 push	 ecx
  00297	68 00 00 00 00	 push	 OFFSET FLAT:$SG71835
  0029c	50		 push	 eax
  0029d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  002a3	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71833:

; 309  : #endif    
; 310  : 			   		printf("\nHOMO:(%d)",i);

  002a6	8b 54 24 1c	 mov	 edx, DWORD PTR _i$[esp+20]
  002aa	52		 push	 edx
  002ab	68 00 00 00 00	 push	 OFFSET FLAT:$SG71836
  002b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  002b6	8b 4c 24 18	 mov	 ecx, DWORD PTR _pKsd_t$[esp+32]
  002ba	8b 6c 24 1c	 mov	 ebp, DWORD PTR _pLts_t$[esp+32]
  002be	83 c4 08	 add	 esp, 8
$L71832:

; 311  : 				}
; 312  : #ifdef HDEBUG
; 313  : 				printf(" got context at %d \n",i);
; 314  : #endif
; 315  : 
; 316  : 				if(HTAB.h_select)

  002c1	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  002c4	85 c0		 test	 eax, eax
  002c6	74 08		 je	 SHORT $L71839

; 317  : 				{
; 318  : /*					if( (HTAB.h_select & DEP.fc) == 0)
; 319  : 						{
; 320  : 						break;
; 321  : 						} */						
; 322  : 					/* GL, 10/01/1996, if match the primary formclass then should get out of loop */
; 323  : 					if (HTAB.h_select & DEP.fc)

  002c8	85 06		 test	 eax, DWORD PTR [esi]
  002ca	75 41		 jne	 SHORT $L71826

; 324  : 					{
; 325  : 						break;
; 326  : 					}						
; 327  : 					if(HTAB.h_select & DES.fc)

  002cc	85 07		 test	 eax, DWORD PTR [edi]
  002ce	75 3b		 jne	 SHORT $L71887
$L71839:

; 328  : 					{
; 329  : #ifdef HDEBUG
; 330  : 						printf("changing primary to secondary1. rule i %d\n",i);
; 331  : 						printf(" %d %d \n",entry_primary,entry_secondary);
; 332  : #endif
; 333  : 
; 334  : 						entry_temporary = entry_primary;
; 335  : 						entry_primary = entry_secondary;
; 336  : 						entry_secondary = entry_temporary;
; 337  : 
; 338  : 						break;
; 339  : 
; 340  : 					}
; 341  : 				}
; 342  : 				if(HTAB.h_elim)

  002d0	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  002d3	85 c0		 test	 eax, eax
  002d5	74 0e		 je	 SHORT $L71825

; 343  : 				{
; 344  : 					if(HTAB.h_elim & DES.fc)

  002d7	85 07		 test	 eax, DWORD PTR [edi]
  002d9	75 32		 jne	 SHORT $L71826

; 345  : 						break;
; 346  : 					if(HTAB.h_elim & DEP.fc)

  002db	85 06		 test	 eax, DWORD PTR [esi]
  002dd	75 2c		 jne	 SHORT $L71887
  002df	eb 04		 jmp	 SHORT $L71825
$L71903:
  002e1	8b 5c 24 20	 mov	 ebx, DWORD PTR 12+[esp+20]
$L71825:

; 280  : 
; 281  : 
; 282  : 
; 283  : 	/*
; 284  : 	 *  Now run through the list and try to pick one ...
; 285  : 	 */
; 286  : 
; 287  : 	for(i=0;i<MAX_HOMO_RULE;i++)

  002e5	8b 44 24 1c	 mov	 eax, DWORD PTR _i$[esp+20]
  002e9	83 c3 10	 add	 ebx, 16			; 00000010H
  002ec	40		 inc	 eax
  002ed	81 fb b4 01 00
	00		 cmp	 ebx, OFFSET FLAT:_homo_table+436
  002f3	89 44 24 1c	 mov	 DWORD PTR _i$[esp+20], eax
  002f7	89 5c 24 20	 mov	 DWORD PTR 12+[esp+20], ebx
  002fb	0f 8c 2b ff ff
	ff		 jl	 $L71824

; 365  : 	}
; 366  : 
; 367  : 	return(entry_primary);

  00301	8b c6		 mov	 eax, esi
  00303	5f		 pop	 edi
  00304	5e		 pop	 esi
  00305	5d		 pop	 ebp
  00306	5b		 pop	 ebx

; 368  : 
; 369  : }

  00307	83 c4 08	 add	 esp, 8
  0030a	c3		 ret	 0
$L71887:

; 347  : 					{
; 348  : #ifdef HDEBUG
; 349  : 						printf("changing primary to secondary2. rule %d\n",i);
; 350  : #endif
; 351  : 
; 352  : 						entry_temporary = entry_primary;
; 353  : 						entry_primary = entry_secondary;

  0030b	8b f7		 mov	 esi, edi
$L71826:

; 354  : 						entry_secondary = entry_temporary;
; 355  : 						break;
; 356  : 					}
; 357  : 				}
; 358  : 			}
; 359  : 		}
; 360  : 	}
; 361  : 
; 362  : 	if((i < MAX_HOMO_RULE) && HTAB.h_suffix)

  0030d	8b 44 24 1c	 mov	 eax, DWORD PTR _i$[esp+20]
  00311	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  00314	7d 1c		 jge	 SHORT $L71894
  00316	c1 e0 04	 shl	 eax, 4
  00319	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _homo_table[eax]
  0031f	85 c9		 test	 ecx, ecx
  00321	74 0f		 je	 SHORT $L71894

; 363  : 	{
; 364  : 		pLts_t->fc_struct[pLts_t->fc_index] = DEP.fc;

  00323	8b 85 bc 08 00
	00		 mov	 eax, DWORD PTR [ebp+2236]
  00329	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0032b	89 8c 85 bc 04
	00 00		 mov	 DWORD PTR [ebp+eax*4+1212], ecx
$L71894:

; 365  : 	}
; 366  : 
; 367  : 	return(entry_primary);

  00332	8b c6		 mov	 eax, esi
  00334	5f		 pop	 edi
  00335	5e		 pop	 esi
  00336	5d		 pop	 ebp
  00337	5b		 pop	 ebx

; 368  : 
; 369  : }

  00338	83 c4 08	 add	 esp, 8
  0033b	c3		 ret	 0
_ls_homo_homo ENDP
_TEXT	ENDS
PUBLIC	_ls_homo_sapi_homo
_DATA	SEGMENT
	ORG $+1
$SG71867 DB	0aH, 'HOMO:(%d)', 00H
	ORG $+1
$SG71868 DB	0aH, 'HOMO:(%d)', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_fc1$ = 12
_fc2$ = 16
_pKsd_t$ = 8
_ls_homo_sapi_homo PROC NEAR

; 379  : 	unsigned long TEMPfc;
; 380  : #endif
; 381  : 	int i=0;
; 382  : 
; 383  : 	PLTS_T	pLts_t;
; 384  : 	PKSD_T	pKsd_t;
; 385  : 
; 386  : 	pLts_t = phTTS->pLTSThreadData;

  00340	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00344	53		 push	 ebx
  00345	55		 push	 ebp
  00346	8b 6c 24 10	 mov	 ebp, DWORD PTR _fc1$[esp+4]
  0034a	56		 push	 esi
  0034b	57		 push	 edi
  0034c	8b 78 10	 mov	 edi, DWORD PTR [eax+16]

; 387  : 	pKsd_t = phTTS->pKernelShareData;   

  0034f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00352	89 44 24 14	 mov	 DWORD PTR _pKsd_t$[esp+12], eax

; 388  : 
; 389  : 	for(i=0;i<MAX_HOMO_RULE;i++)

  00356	33 db		 xor	 ebx, ebx
  00358	be 04 00 00 00	 mov	 esi, OFFSET FLAT:_homo_table+4
$L71856:

; 390  : 	{
; 391  : 		/*
; 392  : 		 *  First, if there is no suffix for this rule or the suffix matches a
; 393  : 		 *  stripped suffix ...
; 394  : 		 */
; 395  : 		if(HTAB.h_suffix == 0 || ((HTAB.h_suffix & pLts_t->fc_struct[pLts_t->fc_index]) == (unsigned int)HTAB.h_suffix)) // NAL warning removal

  0035d	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00360	85 c0		 test	 eax, eax
  00362	74 17		 je	 SHORT $L71861
  00364	8b 8f bc 08 00
	00		 mov	 ecx, DWORD PTR [edi+2236]
  0036a	8b 94 8f bc 04
	00 00		 mov	 edx, DWORD PTR [edi+ecx*4+1212]
  00371	23 d0		 and	 edx, eax
  00373	3b d0		 cmp	 edx, eax
  00375	0f 85 8f 00 00
	00		 jne	 $L71857
$L71861:

; 396  : 		{
; 397  : 		    /* GL 3/3/1997 check the word before previous word if
; 398  : 		       previous word is a Adv. */
; 399  : 			if(HTAB.h_context == 0 ||
; 400  : 			  (HTAB.h_context & pLts_t->fc_struct[pLts_t->fc_index-1]) ||
; 401  : 			  ((pLts_t->fc_index >= 3) &&
; 402  : 			   (FC_ADV & pLts_t->fc_struct[pLts_t->fc_index-1]) &&
; 403  : 			   (HTAB.h_context & pLts_t->fc_struct[pLts_t->fc_index-2])))

  0037b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0037d	85 c9		 test	 ecx, ecx
  0037f	74 24		 je	 SHORT $L71863
  00381	8b 87 bc 08 00
	00		 mov	 eax, DWORD PTR [edi+2236]
  00387	8b 94 87 b8 04
	00 00		 mov	 edx, DWORD PTR [edi+eax*4+1208]
  0038e	85 ca		 test	 ecx, edx
  00390	75 13		 jne	 SHORT $L71863
  00392	83 f8 03	 cmp	 eax, 3
  00395	7c 73		 jl	 SHORT $L71857
  00397	f6 c2 02	 test	 dl, 2
  0039a	74 6e		 je	 SHORT $L71857
  0039c	85 8c 87 b4 04
	00 00		 test	 DWORD PTR [edi+eax*4+1204], ecx
  003a3	74 65		 je	 SHORT $L71857
$L71863:

; 404  : 			{
; 405  : 				/* debug switch */
; 406  : 				if (DT_DBG(LTS_DBG,0x020))

  003a5	8b 4c 24 14	 mov	 ecx, DWORD PTR _pKsd_t$[esp+12]
  003a9	66 8b 81 40 06
	00 00		 mov	 ax, WORD PTR [ecx+1600]
  003b0	f6 c4 40	 test	 ah, 64			; 00000040H
  003b3	74 2d		 je	 SHORT $L71864
  003b5	a8 20		 test	 al, 32			; 00000020H
  003b7	74 29		 je	 SHORT $L71864

; 407  : 				{
; 408  : #ifndef MSDOS
; 409  : 					if (pKsd_t->dbglog)			/*mfg 04/28/98 added debug support*/

  003b9	8b 81 44 06 00
	00		 mov	 eax, DWORD PTR [ecx+1604]
  003bf	85 c0		 test	 eax, eax
  003c1	74 10		 je	 SHORT $L71865

; 410  : 					fprintf((FILE *)pKsd_t->dbglog,"\nHOMO:(%d)",i);

  003c3	53		 push	 ebx
  003c4	68 00 00 00 00	 push	 OFFSET FLAT:$SG71867
  003c9	50		 push	 eax
  003ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  003d0	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71865:

; 411  : #endif    
; 412  : 			   		printf("\nHOMO:(%d)",i);

  003d3	53		 push	 ebx
  003d4	68 00 00 00 00	 push	 OFFSET FLAT:$SG71868
  003d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  003df	83 c4 08	 add	 esp, 8
$L71864:

; 413  : 				}
; 414  : #ifdef HDEBUG
; 415  : 				printf(" got context at %d \n",i);
; 416  : #endif
; 417  : 
; 418  : 				if(HTAB.h_select)

  003e2	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  003e5	85 c0		 test	 eax, eax
  003e7	74 0e		 je	 SHORT $L71916

; 419  : 				{
; 420  : 					if (HTAB.h_select & fc1)

  003e9	85 c5		 test	 eax, ebp
  003eb	75 36		 jne	 SHORT $L71858

; 421  : 					{
; 422  : 						break;
; 423  : 					}						
; 424  : 					if(HTAB.h_select & fc2)

  003ed	8b 4c 24 1c	 mov	 ecx, DWORD PTR _fc2$[esp+12]
  003f1	85 c1		 test	 eax, ecx
  003f3	75 2c		 jne	 SHORT $L71909
  003f5	eb 04		 jmp	 SHORT $L71871
$L71916:
  003f7	8b 4c 24 1c	 mov	 ecx, DWORD PTR _fc2$[esp+12]
$L71871:

; 425  : 					{
; 426  : 						TEMPfc = fc1;
; 427  : 						fc1 = fc2;
; 428  : 						fc2 = TEMPfc;
; 429  : 						break;
; 430  : 					}
; 431  : 				}
; 432  : 				if(HTAB.h_elim)

  003fb	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  003fe	85 c0		 test	 eax, eax
  00400	74 08		 je	 SHORT $L71857

; 433  : 				{
; 434  : 					if(HTAB.h_elim & fc2)

  00402	85 c1		 test	 eax, ecx
  00404	75 1d		 jne	 SHORT $L71858

; 435  : 						break;
; 436  : 					if(HTAB.h_elim & fc1)

  00406	85 c5		 test	 eax, ebp
  00408	75 17		 jne	 SHORT $L71909
$L71857:

; 388  : 
; 389  : 	for(i=0;i<MAX_HOMO_RULE;i++)

  0040a	83 c6 10	 add	 esi, 16			; 00000010H
  0040d	43		 inc	 ebx
  0040e	81 fe b4 01 00
	00		 cmp	 esi, OFFSET FLAT:_homo_table+436
  00414	0f 8c 43 ff ff
	ff		 jl	 $L71856
  0041a	5f		 pop	 edi

; 451  : 	}
; 452  : 
; 453  : 	return(fc1);

  0041b	8b c5		 mov	 eax, ebp
  0041d	5e		 pop	 esi
  0041e	5d		 pop	 ebp
  0041f	5b		 pop	 ebx

; 454  : 
; 455  : }

  00420	c3		 ret	 0
$L71909:

; 437  : 					{
; 438  : 						TEMPfc = fc1;
; 439  : 						fc1 = fc2;

  00421	8b e9		 mov	 ebp, ecx
$L71858:

; 440  : 						fc2 = fc1;
; 441  : 						break;
; 442  : 					}
; 443  : 				}
; 444  : 			}
; 445  : 		}
; 446  : 	}
; 447  : 
; 448  : 	if((i < MAX_HOMO_RULE) && HTAB.h_suffix)

  00423	83 fb 1b	 cmp	 ebx, 27			; 0000001bH
  00426	7d 1a		 jge	 SHORT $L71913
  00428	c1 e3 04	 shl	 ebx, 4
  0042b	8b 83 00 00 00
	00		 mov	 eax, DWORD PTR _homo_table[ebx]
  00431	85 c0		 test	 eax, eax
  00433	74 0d		 je	 SHORT $L71913

; 449  : 	{
; 450  : 		pLts_t->fc_struct[pLts_t->fc_index] = fc1;

  00435	8b 87 bc 08 00
	00		 mov	 eax, DWORD PTR [edi+2236]
  0043b	89 ac 87 bc 04
	00 00		 mov	 DWORD PTR [edi+eax*4+1212], ebp
$L71913:
  00442	5f		 pop	 edi

; 451  : 	}
; 452  : 
; 453  : 	return(fc1);

  00443	8b c5		 mov	 eax, ebp
  00445	5e		 pop	 esi
  00446	5d		 pop	 ebp
  00447	5b		 pop	 ebx

; 454  : 
; 455  : }

  00448	c3		 ret	 0
_ls_homo_sapi_homo ENDP
_TEXT	ENDS
END
