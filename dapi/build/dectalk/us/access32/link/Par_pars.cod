	TITLE	D:\work\Product\dapi\src\Cmd\Par_pars.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DP@EDMP@par_get_return_level?$DLno?5place?5to@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT _par_get_return_level
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _par_set_return_level
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _par_copy_index_list
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _par_copy_index
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _par_is_index_set
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_char_type_table
PUBLIC	_par_status_string
PUBLIC	_par_check_word_string
PUBLIC	_par_save_string
PUBLIC	_par_insert_string
PUBLIC	_par_compound_break
PUBLIC	_par_replace_string
PUBLIC	_par_delete_string
PUBLIC	_par_dom_dict_search
PUBLIC	_ERROR_func1
PUBLIC	_ERROR_func2
PUBLIC	_perform_action_funcs
_DATA	SEGMENT
_char_type_table DD 00H
	DD	01000H
	DD	08H
	DD	010H
	DD	0800H
	DD	0200H
	DD	04H
	DD	080H
	DD	0400H
	DD	04000H
	DD	040H
	DD	02H
	DD	0100H
	DD	02000H
	DD	020H
	DD	01H
_perform_action_funcs DD FLAT:_ERROR_func2
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func2
	DD	FLAT:_par_delete_string
	DD	FLAT:_ERROR_func2
	DD	FLAT:_par_save_string
	DD	FLAT:_ERROR_func2
	DD	FLAT:_par_replace_string
	DD	FLAT:_par_insert_string
	DD	FLAT:_par_compound_break
	DD	FLAT:_ERROR_func2
	DD	FLAT:_par_dom_dict_search
	DD	FLAT:_par_status_string
	DD	FLAT:_par_check_word_string
$SG71438 DB	'I am a pud-fart. ', 00H
_DATA	ENDS
_TEXT	SEGMENT
_output_array$ = 16
_ret_value$ = 32
_ERROR_func1 PROC NEAR

; 583  : 	strcpy(output_array+ret_value->output_pos,"I am a pud-fart. ");

  00000	8b 44 24 1c	 mov	 eax, DWORD PTR _ret_value$[esp-4]
  00004	8b 54 24 0c	 mov	 edx, DWORD PTR _output_array$[esp-4]
  00008	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000b	03 ca		 add	 ecx, edx
  0000d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR $SG71438
  00013	89 11		 mov	 DWORD PTR [ecx], edx
  00015	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR $SG71438+4
  0001b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0001e	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR $SG71438+8
  00024	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00027	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR $SG71438+12
  0002d	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00030	66 8b 15 10 00
	00 00		 mov	 dx, WORD PTR $SG71438+16
  00037	66 89 51 10	 mov	 WORD PTR [ecx+16], dx

; 584  : 	ret_value->output_offset=strlen("I am a pud-fart. ");

  0003b	c7 40 0c 11 00
	00 00		 mov	 DWORD PTR [eax+12], 17	; 00000011H

; 585  : 	return;
; 586  : }

  00042	c3		 ret	 0
_ERROR_func1 ENDP
_ERROR_func2 PROC NEAR

; 605  : 	return;
; 606  : }

  00050	c3		 ret	 0
_ERROR_func2 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DP@EDMP@par_get_return_level?$DLno?5place?5to@ ; `string'
PUBLIC	??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@ ; `string'
PUBLIC	_par_copy_word_to_output
PUBLIC	_par_skip_white_space
PUBLIC	_par_match_rule
PUBLIC	_par_process_input
EXTRN	_cm_util_flush_init:NEAR
EXTRN	_num_rule_sections:DWORD
EXTRN	_rule_sections:BYTE
EXTRN	_num_rules:DWORD
EXTRN	_rule_index_table:BYTE
EXTRN	_rule_data_table:BYTE
EXTRN	_parser_char_types:BYTE
EXTRN	__imp__printf:NEAR
_DATA	SEGMENT
	ORG $+2
$SG71587 DB	'par_process_input; no such rule section %d', 0aH, 00H
$SG71588 DB	'Invalid rule section. ', 00H
	ORG $+1
$SG71618 DB	'special rule value is out of range', 0aH, 00H
$SG71653 DB	'rule number is R%d', 0aH, 00H
$SG71671 DB	'Rule hit:R%d', 0aH, 00H
_DATA	ENDS
;	COMDAT ??_C@_0DP@EDMP@par_get_return_level?$DLno?5place?5to@
; File D:\work\Product\dapi\src\Cmd\par_pars1.c
_DATA	SEGMENT
??_C@_0DP@EDMP@par_get_return_level?$DLno?5place?5to@ DB 'par_get_return_'
	DB	'level;no place to go to, going to next rule %d', 0aH, 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@
_DATA	SEGMENT
??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@ DB 'par_set_return_'
	DB	'level;too many levels of gorets throwing away %d', 0aH, 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_input_array$ = 12
_new_input$ = 16
_output_array$ = 20
_dict_hit_array$ = 24
_input_indexes$ = 28
_new_input_indexes$ = 32
_output_indexes$ = 36
_in_lang_flag$ = 40
_in_mode_flag$ = 44
_rule$ = 48
_go_until$ = 52
_match_array$ = 56
_ret_value$ = 60
_new_ret$ = -180
_hit_ret$ = -72
_save_ret$ = -112
_current_rule_R_value$ = -128
_cur_rule_next_hit$ = -136
_cur_rule_next_miss$ = -188
_cur_rule_next_go_hit$ = -120
_cur_rule_next_go_miss$ = -192
_cur_rule_copy_hit$ = -196
_done$ = -184
_j$ = -188
_current_rule_number$ = -200
_return_rule$ = -40
_return_level$ = -204
_input_length$ = -76
_new_input_diff$ = -132
_do_not_copy_next_word$ = -124
_pCmd_t$ = -140
_pKsd_t$ = -148
_par_process_input PROC NEAR

; 968  : {

  00060	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH

; 969  : /* 
; 970  :  *	this structure holds the information about where the
; 971  :  *	current search left off in the search of the array
; 972  : 	*/
; 973  : 	/* GL 02/08/1997  add one more item for parser_flag */
; 974  : #ifndef NEW_PARSER_FILE_LOADING
; 975  : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0 }; 
; 976  : 	return_value_t		hit_ret = { 0,0,0,0,0,0,0,0 }; 
; 977  : 	return_value_t		save_ret = { 0,0,0,0,0,0,0,0 };
; 978  : #else
; 979  : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0,NULL }; 
; 980  : 	return_value_t		hit_ret = { 0,0,0,0,0,0,0,0,NULL }; 
; 981  : 	return_value_t		save_ret = { 0,0,0,0,0,0,0,0,NULL };
; 982  : #endif
; 983  : 	U8 *		 		current_rule;	/* a pointer to the current rule */
; 984  : #if (defined DISPLAY_RULES_HIT) || !(defined PARSER_STANDALONE_DEBUG)
; 985  : 	unsigned int		current_rule_R_value=0;
; 986  : #endif
; 987  : 	int 				cur_rule_next_hit;
; 988  : 	int					cur_rule_next_miss;
; 989  : 	int					cur_rule_next_go_hit;
; 990  : 	int					cur_rule_next_go_miss;
; 991  : 	int					cur_rule_copy_hit;
; 992  : 	unsigned int		current_value;
; 993  : 	int  				done=0;
; 994  : 	int 				i;
; 995  : 	int					j;
; 996  : 	int					k;
; 997  : 	int					last_rule_was_hit=0;
; 998  : 	int 				current_rule_number=0;
; 999  : 	int					return_rule[PAR_MAX_RETURN_LEVEL];
; 1000 : 	int					return_level=0;
; 1001 : 	int					input_length=0;
; 1002 : 	int					new_input_diff=0;
; 1003 : 	int					input_size,output_size,size_diff;
; 1004 : 	int					rule_p;
; 1005 : 	int					temp,do_not_copy_next_word=0;
; 1006 : 	U32 *				rule_modes;
; 1007 : 	U16	*				rule_flags;
; 1008 : 	
; 1009 : #ifndef PARSER_STANDALONE_DEBUG
; 1010 : 	PCMD_T pCmd_t;
; 1011 : 	PKSD_T  pKsd_t;
; 1012 : 	pCmd_t=phTTS->pCMDThreadData;

  00066	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR _phTTS$[esp+200]
  0006d	53		 push	 ebx

; 1013 : 	pKsd_t=phTTS->pKernelShareData;
; 1014 : #endif
; 1015 : 	
; 1016 : #ifdef DEBUG
; 1017 : 	printf("entering par_process_input\n");
; 1018 : #endif
; 1019 : 	new_ret.input_pos=ret_value->input_pos+ret_value->input_offset;	

  0006e	8b 9c 24 08 01
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+204]
  00075	55		 push	 ebp
  00076	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00079	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0007c	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0007f	56		 push	 esi
  00080	8b 33		 mov	 esi, DWORD PTR [ebx]
  00082	89 54 24 44	 mov	 DWORD PTR _pKsd_t$[esp+216], edx

; 1020 : 	new_ret.input_offset=0;
; 1021 : 	new_ret.output_pos=ret_value->output_pos+ret_value->output_offset;

  00086	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  00089	03 c6		 add	 eax, esi
  0008b	89 44 24 24	 mov	 DWORD PTR _new_ret$[esp+216], eax
  0008f	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00092	03 c2		 add	 eax, edx
  00094	89 4c 24 4c	 mov	 DWORD PTR _pCmd_t$[esp+216], ecx

; 1022 : 	new_ret.output_offset=0;                 
; 1023 : 	/* GL 02/08/1997 set the initial parser_flag value */
; 1024 : 	new_ret.parser_flag = ret_value->parser_flag;
; 1025 : #ifdef NEW_PARSER_FILE_LOADING
; 1026 : #ifdef PARSER_STANDALONE_DEBUG
; 1027 : 	new_ret.phTTS=NULL;
; 1028 : #else
; 1029 : 	new_ret.phTTS=phTTS;
; 1030 : #endif
; 1031 : #endif
; 1032 : 	
; 1033 : 	if (rule>num_rule_sections)

  00098	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _num_rule_sections
  0009e	89 44 24 2c	 mov	 DWORD PTR _new_ret$[esp+224], eax
  000a2	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  000a5	33 ed		 xor	 ebp, ebp
  000a7	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+244], eax
  000ab	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR _rule$[esp+212]
  000b2	3b c1		 cmp	 eax, ecx
  000b4	57		 push	 edi
  000b5	89 6c 24 38	 mov	 DWORD PTR _new_ret$[esp+236], ebp
  000b9	89 6c 24 3c	 mov	 DWORD PTR _new_ret$[esp+240], ebp
  000bd	89 6c 24 40	 mov	 DWORD PTR _new_ret$[esp+244], ebp
  000c1	89 ac 24 94 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+220], ebp
  000c8	89 ac 24 98 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+224], ebp
  000cf	89 ac 24 9c 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+228], ebp
  000d6	89 ac 24 a0 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+232], ebp
  000dd	89 ac 24 a4 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+236], ebp
  000e4	89 ac 24 a8 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+240], ebp
  000eb	89 ac 24 ac 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+244], ebp
  000f2	89 ac 24 b0 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+248], ebp
  000f9	89 6c 24 5c	 mov	 DWORD PTR _current_rule_R_value$[esp+220], ebp
  000fd	89 6c 24 24	 mov	 DWORD PTR _done$[esp+220], ebp
  00101	89 6c 24 10	 mov	 DWORD PTR _return_level$[esp+220], ebp
  00105	89 6c 24 58	 mov	 DWORD PTR _new_input_diff$[esp+220], ebp
  00109	89 6c 24 60	 mov	 DWORD PTR _do_not_copy_next_word$[esp+220], ebp
  0010d	89 6c 24 2c	 mov	 DWORD PTR _new_ret$[esp+224], ebp
  00111	89 6c 24 34	 mov	 DWORD PTR _new_ret$[esp+232], ebp
  00115	7e 32		 jle	 SHORT $L71586

; 1034 : 	{
; 1035 : 		printf("par_process_input; no such rule section %d\n",rule);

  00117	50		 push	 eax
  00118	68 00 00 00 00	 push	 OFFSET FLAT:$SG71587
  0011d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf

; 1036 : 		strcpy(output_array,"Invalid rule section. ");

  00123	8b bc 24 f4 00
	00 00		 mov	 edi, DWORD PTR _output_array$[esp+224]
  0012a	b9 05 00 00 00	 mov	 ecx, 5
  0012f	be 00 00 00 00	 mov	 esi, OFFSET FLAT:$SG71588
  00134	83 c4 08	 add	 esp, 8
  00137	f3 a5		 rep movsd
  00139	66 a5		 movsw
  0013b	a4		 movsb
  0013c	5f		 pop	 edi
  0013d	5e		 pop	 esi

; 1650 : #ifdef DEBUG
; 1651 : 	printf("leaving par_process_input\n");
; 1652 : #endif
; 1653 : 	return(ret_value);

  0013e	8b c3		 mov	 eax, ebx
  00140	5d		 pop	 ebp
  00141	5b		 pop	 ebx

; 1654 : }                       

  00142	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00148	c3		 ret	 0
$L71586:

; 1037 : 		return(ret_value);
; 1038 : 	}
; 1039 : 	memset(return_rule,-1,sizeof(return_rule));
; 1040 : 
; 1041 : 	input_length=strlen(input_array);

  00149	8b b4 24 e4 00
	00 00		 mov	 esi, DWORD PTR _input_array$[esp+216]
  00150	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00155	83 c8 ff	 or	 eax, -1
  00158	8d bc 24 b4 00
	00 00		 lea	 edi, DWORD PTR _return_rule$[esp+220]
  0015f	f3 ab		 rep stosd
  00161	8b fe		 mov	 edi, esi
  00163	83 c9 ff	 or	 ecx, -1
  00166	33 c0		 xor	 eax, eax
  00168	f2 ae		 repne scasb
  0016a	f7 d1		 not	 ecx
  0016c	49		 dec	 ecx

; 1042 : 	
; 1043 : 	strcpy(new_input,input_array);

  0016d	8b fe		 mov	 edi, esi
  0016f	8b d1		 mov	 edx, ecx
  00171	83 c9 ff	 or	 ecx, -1
  00174	f2 ae		 repne scasb
  00176	f7 d1		 not	 ecx
  00178	2b f9		 sub	 edi, ecx
  0017a	8b c1		 mov	 eax, ecx
  0017c	8b f7		 mov	 esi, edi
  0017e	8b bc 24 e8 00
	00 00		 mov	 edi, DWORD PTR _new_input$[esp+216]
  00185	c1 e9 02	 shr	 ecx, 2
  00188	f3 a5		 rep movsd
  0018a	8b c8		 mov	 ecx, eax
  0018c	83 e1 03	 and	 ecx, 3
  0018f	f3 a4		 rep movsb

; 1044 : 	memcpy(new_input_indexes,input_indexes,input_length*sizeof(index_data_t));

  00191	8b b4 24 f4 00
	00 00		 mov	 esi, DWORD PTR _input_indexes$[esp+216]
  00198	8b bc 24 f8 00
	00 00		 mov	 edi, DWORD PTR _new_input_indexes$[esp+216]
  0019f	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]

; 1045 : 	
; 1046 : 	input_length=(input_length*2)/3; /* input_length * 2/3 */

  001a2	03 d2		 add	 edx, edx
  001a4	d1 e1		 shl	 ecx, 1
  001a6	8b c1		 mov	 eax, ecx
  001a8	c1 e9 02	 shr	 ecx, 2
  001ab	f3 a5		 rep movsd
  001ad	8b c8		 mov	 ecx, eax
  001af	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  001b4	f7 ea		 imul	 edx
  001b6	83 e1 03	 and	 ecx, 3
  001b9	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+224]
  001bd	f3 a4		 rep movsb
  001bf	8b b4 24 e8 00
	00 00		 mov	 esi, DWORD PTR _new_input$[esp+216]
  001c6	8b ca		 mov	 ecx, edx
  001c8	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  001cb	03 d1		 add	 edx, ecx
  001cd	bf 01 00 00 00	 mov	 edi, 1
  001d2	89 94 24 90 00
	00 00		 mov	 DWORD PTR _input_length$[esp+220], edx
$L71591:

; 1047 : 	/* copy the input array to a temporary location for hit next rules */
; 1048 :     
; 1049 :     while (((new_input[new_ret.input_pos+new_ret.input_offset]!='\0') && (go_until==0)) ||    	   
; 1050 :     	   (((new_ret.input_pos+new_ret.input_offset-new_input_diff)<input_length) && (go_until==1) ) )

  001d9	8b 4c 24 28	 mov	 ecx, DWORD PTR _new_ret$[esp+220]
  001dd	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]
  001e0	80 3c 32 00	 cmp	 BYTE PTR [edx+esi], 0
  001e4	74 09		 je	 SHORT $L71594
  001e6	39 ac 24 0c 01
	00 00		 cmp	 DWORD PTR _go_until$[esp+216], ebp
  001ed	74 24		 je	 SHORT $L71593
$L71594:
  001ef	8b 54 24 58	 mov	 edx, DWORD PTR _new_input_diff$[esp+220]
  001f3	2b c2		 sub	 eax, edx
  001f5	03 c1		 add	 eax, ecx
  001f7	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _input_length$[esp+220]
  001fe	3b c1		 cmp	 eax, ecx
  00200	0f 8d fd 09 00
	00		 jge	 $L71592
  00206	39 bc 24 0c 01
	00 00		 cmp	 DWORD PTR _go_until$[esp+216], edi
  0020d	0f 85 f0 09 00
	00		 jne	 $L71592
$L71593:

; 1051 : 	{
; 1052 : #ifndef PARSER_STANDALONE_DEBUG
; 1053 : 		/* checking cmd_flushing */
; 1054 : 		if (pKsd_t->text_flush || (pKsd_t->cmd_flush == CMD_flush_toss))

  00213	8b 44 24 48	 mov	 eax, DWORD PTR _pKsd_t$[esp+220]
  00217	39 a8 30 03 00
	00		 cmp	 DWORD PTR [eax+816], ebp
  0021d	0f 85 72 09 00
	00		 jne	 $L71596
  00223	39 b8 2c 03 00
	00		 cmp	 DWORD PTR [eax+812], edi
  00229	0f 84 66 09 00
	00		 je	 $L71596

; 1055 : 		{
; 1056 : 			cm_util_flush_init(phTTS);
; 1057 : 			return(&pCmd_t->ret_value);
; 1058 : 		}              
; 1059 : #endif
; 1060 : 		if (par_skip_white_space(new_input,new_input_indexes,output_array,output_indexes,&new_ret)== -1)

  0022f	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR _output_indexes$[esp+216]
  00236	8b 94 24 ec 00
	00 00		 mov	 edx, DWORD PTR _output_array$[esp+216]
  0023d	8d 44 24 28	 lea	 eax, DWORD PTR _new_ret$[esp+220]
  00241	50		 push	 eax
  00242	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR _new_input_indexes$[esp+220]
  00249	51		 push	 ecx
  0024a	52		 push	 edx
  0024b	50		 push	 eax
  0024c	56		 push	 esi
  0024d	e8 00 00 00 00	 call	 _par_skip_white_space
  00252	83 c4 14	 add	 esp, 20			; 00000014H
  00255	83 f8 ff	 cmp	 eax, -1
  00258	75 04		 jne	 SHORT $L71597

; 1061 : 			/* skip whitespace between words */		
; 1062 : 			/* copies one whitespace to the output array */
; 1063 : 			/* if there is an index, an extra space may end up in the output */
; 1064 : 		{
; 1065 : 			done=1;

  0025a	89 7c 24 24	 mov	 DWORD PTR _done$[esp+220], edi
$L71597:

; 1066 : 		}  	               
; 1067 : 		par_copy_return_value(&save_ret,&new_ret);	/* save the values if the matching ends on a non white */
; 1068 : 		current_rule=NULL;                     
; 1069 : 		current_rule_number=rule_sections[rule];
; 1070 : 		last_rule_was_hit=0;
; 1071 : #ifdef DEBUG
; 1072 : 		par_print_rule_error("par_process_input;1 the input is",new_input,new_ret.input_pos+new_ret.input_offset);
; 1073 : 		par_print_rule_error("par_process_input;1 the output is",output_array,new_ret.output_pos+new_ret.output_offset);
; 1074 : #endif
; 1075 : 		while (!done)

  0025e	8b 44 24 24	 mov	 eax, DWORD PTR _done$[esp+220]
  00262	b9 08 00 00 00	 mov	 ecx, 8
  00267	8d 74 24 28	 lea	 esi, DWORD PTR _new_ret$[esp+220]
  0026b	8d 7c 24 6c	 lea	 edi, DWORD PTR _save_ret$[esp+220]
  0026f	f3 a5		 rep movsd
  00271	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR _rule$[esp+216]
  00278	33 ed		 xor	 ebp, ebp
  0027a	85 c0		 test	 eax, eax
  0027c	8b 1c 8d 00 00
	00 00		 mov	 ebx, DWORD PTR _rule_sections[ecx*4]
  00283	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00287	0f 85 89 08 00
	00		 jne	 $L71608
$L71601:

; 1076 : 		{  	
; 1077 : #ifndef PARSER_STANDALONE_DEBUG
; 1078 : 			/* checking cmd_flushing */
; 1079 : 			if (pKsd_t->text_flush || (pKsd_t->cmd_flush == CMD_flush_toss))

  0028d	8b 54 24 48	 mov	 edx, DWORD PTR _pKsd_t$[esp+220]
  00291	8b 82 30 03 00
	00		 mov	 eax, DWORD PTR [edx+816]
  00297	85 c0		 test	 eax, eax
  00299	0f 85 3f 09 00
	00		 jne	 $L71604
  0029f	83 ba 2c 03 00
	00 01		 cmp	 DWORD PTR [edx+812], 1
  002a6	0f 84 32 09 00
	00		 je	 $L71604

; 1083 : 			}              
; 1084 : #endif
; 1085 : 			/* MGS commented out for speed */
; 1086 : 			//			par_initialize_arrays(match_array);
; 1087 : //			memset(match_array->array_lengths,0,sizeof(match_array->array_lengths));
; 1088 : 			current_rule=&(rule_data_table[rule_index_table[current_rule_number]]); /* this line will change for the new rule tables */

  002ac	8b 3c 9d 00 00
	00 00		 mov	 edi, DWORD PTR _rule_index_table[ebx*4]

; 1089 : 			rule_p=0;
; 1090 : #ifdef DEBUG
; 1091 : 			par_print_rule_error("par_process_input;2 the input is",new_input,new_ret.input_pos+new_ret.input_offset);
; 1092 : 			par_print_rule_error("par_process_input;2 the output is",output_array,new_ret.input_pos+new_ret.output_offset);
; 1093 : #endif
; 1094 : 			/* 
; 1095 : 			* check for stop. if the last rule was a hit rule, 
; 1096 : 			* put the old values for the input and output back
; 1097 : 			*/
; 1098 : 			rule_flags=(U16 *)current_rule;
; 1099 : 			current_value=*rule_flags;

  002b3	33 c9		 xor	 ecx, ecx
  002b5	81 c7 00 00 00
	00		 add	 edi, OFFSET FLAT:_rule_data_table
  002bb	66 8b 0f	 mov	 cx, WORD PTR [edi]

; 1100 : //			current_value=(*((U16 *)(current_rule)));
; 1101 : 			if (current_value & BIN_SPECIAL_RULE_MASK)

  002be	8b c1		 mov	 eax, ecx
  002c0	25 00 e0 00 00	 and	 eax, 57344		; 0000e000H
  002c5	0f 84 a4 00 00
	00		 je	 $L71606

; 1102 : 			{
; 1103 : 				switch (current_value & BIN_SPECIAL_RULE_MASK)
; 1104 : 				{

  002cb	3d 00 a0 00 00	 cmp	 eax, 40960		; 0000a000H
  002d0	77 4f		 ja	 SHORT $L72915
  002d2	0f 84 88 00 00
	00		 je	 $L71615
  002d8	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  002dd	0f 84 05 08 00
	00		 je	 $L71611
  002e3	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  002e8	0f 85 1a 08 00
	00		 jne	 $L72979

; 1119 : 				case BIN_RETURN:
; 1120 : 					current_rule_number=par_get_return_level(return_rule,&return_level,current_rule_number);

  002ee	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  002f2	85 c0		 test	 eax, eax
  002f4	7e 12		 jle	 SHORT $L72918
  002f6	8b 9c 84 b0 00
	00 00		 mov	 ebx, DWORD PTR _return_rule$[esp+eax*4+216]
  002fd	48		 dec	 eax
  002fe	89 44 24 10	 mov	 DWORD PTR _return_level$[esp+220], eax
  00302	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00306	eb 85		 jmp	 SHORT $L71601
$L72918:
  00308	53		 push	 ebx
  00309	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@EDMP@par_get_return_level?$DLno?5place?5to@ ; `string'
  0030e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00314	83 c4 08	 add	 esp, 8
  00317	43		 inc	 ebx
  00318	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx

; 1121 : 					continue;

  0031c	e9 6c ff ff ff	 jmp	 $L71601
$L72915:

; 1102 : 			{
; 1103 : 				switch (current_value & BIN_SPECIAL_RULE_MASK)
; 1104 : 				{

  00321	3d 00 c0 00 00	 cmp	 eax, 49152		; 0000c000H
  00326	0f 85 dc 07 00
	00		 jne	 $L72979

; 1122 : 				case BIN_GOTO:
; 1123 : //					current_rule_number=(*((U16 *)(current_rule+2)));
; 1124 : 					current_rule_number=*(rule_flags+1);
; 1125 : 					continue;
; 1126 : 					/* put in goret and return here */
; 1127 : 				case BIN_GORET:
; 1128 : 					par_set_return_level(return_rule,&return_level,current_rule_number+1);

  0032c	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  00330	43		 inc	 ebx
  00331	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00334	7d 1b		 jge	 SHORT $L72923
  00336	89 9c 84 b4 00
	00 00		 mov	 DWORD PTR _return_rule$[esp+eax*4+220], ebx
  0033d	40		 inc	 eax

; 1129 : 					current_rule_number=*(rule_flags+1);

  0033e	33 db		 xor	 ebx, ebx
  00340	89 44 24 10	 mov	 DWORD PTR _return_level$[esp+220], eax
  00344	66 8b 5f 02	 mov	 bx, WORD PTR [edi+2]
  00348	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx

; 1130 : // 					current_rule_number=(*((U16 *)(current_rule+2)));
; 1131 : 					continue;

  0034c	e9 3c ff ff ff	 jmp	 $L71601

; 1122 : 				case BIN_GOTO:
; 1123 : //					current_rule_number=(*((U16 *)(current_rule+2)));
; 1124 : 					current_rule_number=*(rule_flags+1);
; 1125 : 					continue;
; 1126 : 					/* put in goret and return here */
; 1127 : 				case BIN_GORET:
; 1128 : 					par_set_return_level(return_rule,&return_level,current_rule_number+1);

$L72923:
  00351	53		 push	 ebx
  00352	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@ ; `string'
  00357	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0035d	83 c4 08	 add	 esp, 8
$L71615:

; 1129 : 					current_rule_number=*(rule_flags+1);

  00360	33 db		 xor	 ebx, ebx
  00362	66 8b 5f 02	 mov	 bx, WORD PTR [edi+2]
  00366	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx

; 1130 : // 					current_rule_number=(*((U16 *)(current_rule+2)));
; 1131 : 					continue;

  0036a	e9 1e ff ff ff	 jmp	 $L71601
$L71606:

; 1134 : 					break;
; 1135 : 				}
; 1136 : 				break;
; 1137 : 			}
; 1138 : /* GL 04/16/98  add this for rule number caculation under debug mode */
; 1139 : /*              keep the debug setting for DISPLAY_RULES_HIT         */
; 1140 : #ifndef PARSER_STANDALONE_DEBUG
; 1141 : 			if (DT_DBG(CMD_DBG,0x0010))

  0036f	66 8b 82 40 06
	00 00		 mov	 ax, WORD PTR [edx+1600]
  00376	f6 c4 80	 test	 ah, -128		; ffffff80H
  00379	74 0e		 je	 SHORT $L71619
  0037b	a8 10		 test	 al, 16			; 00000010H
  0037d	74 0a		 je	 SHORT $L71619

; 1142 : 			{
; 1143 : 				rule_p+=2; /* advance past the special rule value flags */
; 1144 : 				current_rule_R_value=(*((U16 *)(current_rule+rule_p)));

  0037f	33 c0		 xor	 eax, eax
  00381	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  00385	89 44 24 5c	 mov	 DWORD PTR _current_rule_R_value$[esp+220], eax
$L71619:

; 1145 : 				rule_p+=2;;
; 1146 : 			}
; 1147 : 			else
; 1148 : 			{
; 1149 : 				rule_p+=4;
; 1150 : 			}
; 1151 : #endif
; 1152 : #ifdef DISPLAY_RULES_HIT
; 1153 : 			rule_p+=2; /* advance past the special rule value flags */
; 1154 : 			current_rule_R_value=(*((U16 *)(current_rule+rule_p)));
; 1155 : 			rule_p+=2;;
; 1156 : //#else
; 1157 : //			rule_p+=4;
; 1158 : #endif
; 1159 : 
; 1160 : //			new_ret.rule=0;
; 1161 : 			new_ret.value=FAIL;
; 1162 : //			i=0;
; 1163 : 			/* check the language tag */
; 1164 : 			/* get the language flag */
; 1165 : 			rule_modes=(U32 *)(current_rule+rule_p);
; 1166 : #ifdef DEBUG
; 1167 : 			printf("the language flag is 0x%08X\n",*rule_modes);
; 1168 : #endif
; 1169 : 			/* check the language flag against the kernel langauge flag for the correct langauage */
; 1170 : 			
; 1171 : 			if ((last_rule_was_hit==0) && (((*rule_modes) & in_lang_flag)==0))

  00389	85 ed		 test	 ebp, ebp
  0038b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR _new_ret$[esp+240], 0
  00393	75 36		 jne	 SHORT $L71626
  00395	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR _in_lang_flag$[esp+216]
  0039c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0039f	85 c2		 test	 eax, edx
  003a1	75 17		 jne	 SHORT $L72986
$L73000:

; 1172 : 			{
; 1173 : 				current_rule_number++;	/* go to the next rule */
; 1174 : 				if (current_rule_number>=num_rules)		

  003a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _num_rules
  003a8	43		 inc	 ebx
  003a9	3b d8		 cmp	 ebx, eax
  003ab	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  003af	0f 8d 61 07 00
	00		 jge	 $L71608

; 1175 : 					done=1;
; 1176 : 				continue;

  003b5	e9 d3 fe ff ff	 jmp	 $L71601
$L72986:

; 1177 : 			}                                          
; 1178 : 			/* check the rule mode here */
; 1179 : #ifdef DEBUG
; 1180 : 			printf("the mode flag is 0x%08X\n",rule_modes[1]);
; 1181 : #endif
; 1182 : 			/*	044	MGS		09/24/1997	BATS#469 Fix for NWS parser problem */
; 1183 : 			if (last_rule_was_hit==0)
; 1184 : 			{
; 1185 : 				if ((rule_modes[1] != 0xFFFFFFFF) &&
; 1186 : 					((rule_modes[1] & in_mode_flag)==0))	

  003ba	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  003bd	83 f8 ff	 cmp	 eax, -1
  003c0	74 09		 je	 SHORT $L71626
  003c2	85 84 24 04 01
	00 00		 test	 DWORD PTR _in_mode_flag$[esp+216], eax

; 1187 : 				{
; 1188 : 					current_rule_number++;	/* go to the next rule */
; 1189 : 					if (current_rule_number>=num_rules)		
; 1190 : 						done=1;
; 1191 : 					continue;

  003c9	74 d8		 je	 SHORT $L73000
$L71626:

; 1192 : 				}
; 1193 : 			}
; 1194 : 			rule_p+=8;
; 1195 : 			if ((current_value & (BIN_DICT_HIT | BIN_DICT_MISS)))

  003cb	f6 c1 c0	 test	 cl, 192			; 000000c0H
  003ce	be 0c 00 00 00	 mov	 esi, 12			; 0000000cH
  003d3	74 57		 je	 SHORT $L71635

; 1196 : 			{
; 1197 : 				if ((current_value & BIN_DICT_HIT) && 
; 1198 : 					(dict_hit_array[new_ret.input_pos+new_ret.input_offset]!=DICT_MISS_VALUE))

  003d5	f6 c1 80	 test	 cl, 128			; 00000080H
  003d8	74 17		 je	 SHORT $L71629
  003da	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+224]
  003de	8b 54 24 28	 mov	 edx, DWORD PTR _new_ret$[esp+220]
  003e2	03 c2		 add	 eax, edx
  003e4	8b 94 24 f0 00
	00 00		 mov	 edx, DWORD PTR _dict_hit_array$[esp+216]
  003eb	80 3c 10 00	 cmp	 BYTE PTR [eax+edx], 0
  003ef	75 3b		 jne	 SHORT $L71635
$L71629:

; 1199 : 				{
; 1200 : #ifdef DEBUG
; 1201 : 					printf("processing rule because of dictionary HIT on the word\n");
; 1202 : #endif				
; 1203 : 				}
; 1204 : 				else
; 1205 : 				{
; 1206 : 					if ((current_value & BIN_DICT_MISS) && 
; 1207 : 						(dict_hit_array[new_ret.input_pos+new_ret.input_offset]==DICT_MISS_VALUE))

  003f1	f6 c1 40	 test	 cl, 64			; 00000040H
  003f4	74 17		 je	 SHORT $L71631
  003f6	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+224]
  003fa	8b 54 24 28	 mov	 edx, DWORD PTR _new_ret$[esp+220]
  003fe	03 c2		 add	 eax, edx
  00400	8b 94 24 f0 00
	00 00		 mov	 edx, DWORD PTR _dict_hit_array$[esp+216]
  00407	80 3c 10 00	 cmp	 BYTE PTR [eax+edx], 0
  0040b	74 1f		 je	 SHORT $L71635
$L71631:

; 1208 : 					{
; 1209 : #ifdef DEBUG
; 1210 : 						printf("processing rule because of dictionary MISS on the word\n");
; 1211 : #endif
; 1212 : 					}
; 1213 : 					else
; 1214 : 					{
; 1215 : 						current_rule_number++;
; 1216 : 						if (current_rule_number>=num_rules)		

  0040d	a1 00 00 00 00	 mov	 eax, DWORD PTR _num_rules
  00412	43		 inc	 ebx
  00413	3b d8		 cmp	 ebx, eax
  00415	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00419	0f 8d f7 06 00
	00		 jge	 $L71608

; 1217 : 							done=1;
; 1218 : 						else
; 1219 : 							done= -1;
; 1220 : 					}
; 1221 : 				}
; 1222 : 			} /* if (current_rule->dict_flag!=UNSET_PARAM) */
; 1223 : 			if (done)
; 1224 : 			{
; 1225 : 				if (done<0)
; 1226 : 					done=0;

  0041f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _done$[esp+220], 0

; 1227 : 				continue;

  00427	e9 61 fe ff ff	 jmp	 $L71601
$L71635:

; 1228 : 			}
; 1229 : 			
; 1230 : 			if (current_value & BIN_NEXT_HIT)

  0042c	f6 c5 10	 test	 ch, 16			; 00000010H
  0042f	74 14		 je	 SHORT $L71637

; 1231 : 			{
; 1232 : 				cur_rule_next_hit = *((U16 *)(current_rule+rule_p));

  00431	33 c0		 xor	 eax, eax

; 1233 : 				rule_p+=2;

  00433	be 0e 00 00 00	 mov	 esi, 14			; 0000000eH
  00438	66 8b 47 0c	 mov	 ax, WORD PTR [edi+12]

; 1234 : 			}
; 1235 : 			else

  0043c	83 ca ff	 or	 edx, -1
  0043f	89 44 24 54	 mov	 DWORD PTR _cur_rule_next_hit$[esp+220], eax
  00443	eb 07		 jmp	 SHORT $L71639
$L71637:

; 1236 : 			{
; 1237 : 				cur_rule_next_hit=-1;

  00445	83 ca ff	 or	 edx, -1
  00448	89 54 24 54	 mov	 DWORD PTR _cur_rule_next_hit$[esp+220], edx
$L71639:

; 1238 : 			}
; 1239 : 			if (current_value & BIN_NEXT_MISS)

  0044c	f6 c5 08	 test	 ch, 8
  0044f	74 0f		 je	 SHORT $L71640

; 1240 : 			{
; 1241 : 				cur_rule_next_miss = *((U16 *)(current_rule+rule_p));

  00451	33 c0		 xor	 eax, eax
  00453	66 8b 04 3e	 mov	 ax, WORD PTR [esi+edi]

; 1242 : 				rule_p+=2;

  00457	83 c6 02	 add	 esi, 2
  0045a	89 44 24 20	 mov	 DWORD PTR _cur_rule_next_miss$[esp+220], eax

; 1243 : 			}
; 1244 : 			else

  0045e	eb 04		 jmp	 SHORT $L71642
$L71640:

; 1245 : 			{
; 1246 : 				cur_rule_next_miss=-1;

  00460	89 54 24 20	 mov	 DWORD PTR _cur_rule_next_miss$[esp+220], edx
$L71642:

; 1247 : 			}
; 1248 : 			if (current_value & BIN_GORET_HIT)

  00464	f6 c5 04	 test	 ch, 4
  00467	74 0f		 je	 SHORT $L71643

; 1249 : 			{
; 1250 : 				cur_rule_next_go_hit = *((U16 *)(current_rule+rule_p));

  00469	33 c0		 xor	 eax, eax
  0046b	66 8b 04 3e	 mov	 ax, WORD PTR [esi+edi]

; 1251 : 				rule_p+=2;

  0046f	83 c6 02	 add	 esi, 2
  00472	89 44 24 64	 mov	 DWORD PTR _cur_rule_next_go_hit$[esp+220], eax

; 1252 : 			}
; 1253 : 			else

  00476	eb 04		 jmp	 SHORT $L71645
$L71643:

; 1254 : 			{
; 1255 : 				cur_rule_next_go_hit=-1;

  00478	89 54 24 64	 mov	 DWORD PTR _cur_rule_next_go_hit$[esp+220], edx
$L71645:

; 1256 : 			}
; 1257 : 			if (current_value & BIN_GORET_MISS)

  0047c	f6 c5 02	 test	 ch, 2
  0047f	74 0f		 je	 SHORT $L71646

; 1258 : 			{
; 1259 : 				cur_rule_next_go_miss = *((U16 *)(current_rule+rule_p));

  00481	33 c0		 xor	 eax, eax
  00483	66 8b 04 3e	 mov	 ax, WORD PTR [esi+edi]

; 1260 : 				rule_p+=2;

  00487	83 c6 02	 add	 esi, 2
  0048a	89 44 24 1c	 mov	 DWORD PTR _cur_rule_next_go_miss$[esp+220], eax

; 1261 : 			}
; 1262 : 			else

  0048e	eb 04		 jmp	 SHORT $L71648
$L71646:

; 1263 : 			{
; 1264 : 				cur_rule_next_go_miss=-1;

  00490	89 54 24 1c	 mov	 DWORD PTR _cur_rule_next_go_miss$[esp+220], edx
$L71648:

; 1265 : 			}
; 1266 : 			if (current_value & BIN_COPY_HIT)

  00494	f6 c5 01	 test	 ch, 1
  00497	74 0f		 je	 SHORT $L71649

; 1267 : 			{
; 1268 : 				cur_rule_copy_hit = *((U16 *)(current_rule+rule_p));

  00499	33 c0		 xor	 eax, eax
  0049b	66 8b 04 3e	 mov	 ax, WORD PTR [esi+edi]

; 1269 : 				rule_p+=2;

  0049f	83 c6 02	 add	 esi, 2
  004a2	89 44 24 18	 mov	 DWORD PTR _cur_rule_copy_hit$[esp+220], eax

; 1270 : 			}
; 1271 : 			else

  004a6	eb 04		 jmp	 SHORT $L71651
$L71649:

; 1272 : 			{
; 1273 : 				cur_rule_copy_hit=-1;

  004a8	89 54 24 18	 mov	 DWORD PTR _cur_rule_copy_hit$[esp+220], edx
$L71651:

; 1274 : 			}
; 1275 : 			
; 1276 : #ifdef DEBUG_RULES
; 1277 : #ifdef PARSER_STANDALONE_DEBUG
; 1278 : 			fprintf(stderr,"rule number is R%d\n",current_rule_R_value);
; 1279 : 			fprintf(stderr,"next hit rule is %d\n",cur_rule_next_hit);
; 1280 : 			fprintf(stderr,"next_miss_rule is %d\n",cur_rule_next_miss);
; 1281 : #else
; 1282 : 			printf("rule number is R%d\n",current_rule_R_value);
; 1283 : 			printf("next hit rule is %d\n",cur_rule_next_hit);
; 1284 : 			printf("next_miss_rule is %d\n",cur_rule_next_miss);
; 1285 : #endif
; 1286 : #endif
; 1287 : 			
; 1288 : 			
; 1289 : #ifdef DISPLAY_RULES_TESTED
; 1290 : #ifdef OUTPUT_HITS_NORMAL
; 1291 : 			printf("rule number is R%d\n",current_rule_R_value);
; 1292 : #else
; 1293 : 			fprintf(stderr,"rule number is R%d\n",current_rule_R_value);
; 1294 : #endif
; 1295 : #endif
; 1296 : #ifndef PARSER_STANDALONE_DEBUG
; 1297 : 			if (DT_DBG(CMD_DBG,0x0200))

  004ac	8b 44 24 48	 mov	 eax, DWORD PTR _pKsd_t$[esp+220]
  004b0	66 8b 80 40 06
	00 00		 mov	 ax, WORD PTR [eax+1600]
  004b7	f6 c4 80	 test	 ah, -128		; ffffff80H
  004ba	74 18		 je	 SHORT $L71652
  004bc	f6 c4 02	 test	 ah, 2
  004bf	74 13		 je	 SHORT $L71652

; 1298 : 			{
; 1299 : 				printf("rule number is R%d\n",current_rule_R_value);

  004c1	8b 4c 24 5c	 mov	 ecx, DWORD PTR _current_rule_R_value$[esp+220]
  004c5	51		 push	 ecx
  004c6	68 00 00 00 00	 push	 OFFSET FLAT:$SG71653
  004cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  004d1	83 c4 08	 add	 esp, 8
$L71652:

; 1300 : 				//par_print_rule_error("input before match",new_input,new_ret.input_pos+new_ret.input_offset);
; 1301 : 			}
; 1302 : #endif
; 1303 : 
; 1304 : 			
; 1305 : #ifdef DEBUG
; 1306 : 			par_print_rule_error("par_process_input; before par_match_rule",current_rule,new_ret.rule);
; 1307 : #endif
; 1308 : 			
; 1309 : #ifndef PARSER_STANDALONE_DEBUG
; 1310 : 			/* checking cmd_flushing */
; 1311 : 			if (pKsd_t->text_flush || (pKsd_t->cmd_flush == CMD_flush_toss))

  004d4	8b 44 24 48	 mov	 eax, DWORD PTR _pKsd_t$[esp+220]
  004d8	8b 88 30 03 00
	00		 mov	 ecx, DWORD PTR [eax+816]
  004de	85 c9		 test	 ecx, ecx
  004e0	0f 85 d3 06 00
	00		 jne	 $L71655
  004e6	83 b8 2c 03 00
	00 01		 cmp	 DWORD PTR [eax+812], 1
  004ed	0f 84 c6 06 00
	00		 je	 $L71655

; 1315 : 			}              
; 1316 : #endif
; 1317 : 			new_ret.rule=rule_p;
; 1318 : 			par_match_rule(current_rule,BIN_END_OF_RULE,new_input,output_array,new_input_indexes,output_indexes,match_array,&new_ret,0);

  004f3	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR _match_array$[esp+216]
  004fa	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR _output_indexes$[esp+216]
  00501	8b ac 24 e8 00
	00 00		 mov	 ebp, DWORD PTR _new_input$[esp+216]
  00508	8d 54 24 28	 lea	 edx, DWORD PTR _new_ret$[esp+220]
  0050c	6a 00		 push	 0
  0050e	52		 push	 edx
  0050f	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR _new_input_indexes$[esp+224]
  00516	50		 push	 eax
  00517	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR _output_array$[esp+228]
  0051e	51		 push	 ecx
  0051f	52		 push	 edx
  00520	50		 push	 eax
  00521	55		 push	 ebp
  00522	6a 00		 push	 0
  00524	57		 push	 edi
  00525	89 74 24 5c	 mov	 DWORD PTR _new_ret$[esp+272], esi
  00529	e8 00 00 00 00	 call	 _par_match_rule

; 1319 : 			
; 1320 : #ifndef PARSER_STANDALONE_DEBUG
; 1321 : 			/* checking cmd_flushing */
; 1322 : 			if (pKsd_t->text_flush || (pKsd_t->cmd_flush == CMD_flush_toss))

  0052e	8b 74 24 6c	 mov	 esi, DWORD PTR _pKsd_t$[esp+256]
  00532	83 c4 24	 add	 esp, 36			; 00000024H
  00535	8b 86 30 03 00
	00		 mov	 eax, DWORD PTR [esi+816]
  0053b	85 c0		 test	 eax, eax
  0053d	0f 85 52 06 00
	00		 jne	 $L71596
  00543	8b 8e 2c 03 00
	00		 mov	 ecx, DWORD PTR [esi+812]
  00549	b8 01 00 00 00	 mov	 eax, 1
  0054e	3b c8		 cmp	 ecx, eax
  00550	0f 84 3f 06 00
	00		 je	 $L71596

; 1326 : 			}              
; 1327 : #endif
; 1328 : 			//printf("C parser_flag is %d\n",new_ret.parser_flag);
; 1329 :             /* GL 02/08/1997, set the parser_flag back to the caller */
; 1330 : 			ret_value->parser_flag = new_ret.parser_flag;

  00556	8b 94 24 14 01
	00 00		 mov	 edx, DWORD PTR _ret_value$[esp+216]
  0055d	8b 4c 24 44	 mov	 ecx, DWORD PTR _new_ret$[esp+248]
  00561	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 1331 : 			
; 1332 : 			/* 
; 1333 : 			* at this point in the matching, either a rule has hit and was processed or the 
; 1334 : 			* current word has to be copied to the output 
; 1335 : 			*/
; 1336 : 			if (new_ret.value == SUCCESS)

  00564	8b 4c 24 3c	 mov	 ecx, DWORD PTR _new_ret$[esp+240]
  00568	3b c8		 cmp	 ecx, eax
  0056a	0f 85 f5 04 00
	00		 jne	 $L71658

; 1337 : 			{         
; 1338 : 				/*	check to be sure the matching left off at the end of a word */
; 1339 : 				temp=new_ret.input_pos+new_ret.input_offset;

  00570	8b 44 24 28	 mov	 eax, DWORD PTR _new_ret$[esp+220]
  00574	8b 4c 24 2c	 mov	 ecx, DWORD PTR _new_ret$[esp+224]

; 1340 : 			//	temp1=parser_char_types[new_input[temp]];
; 1341 : 				if (!((new_input[temp]=='\0') ||
; 1342 : 				      ((parser_char_types[new_input[temp]] & (TYPE_white))!=0) ||
; 1343 : 				      (((parser_char_types[new_input[temp]] & (TYPE_clause))!=0) &&
; 1344 : 				       ((new_input[temp+1]=='\0') || 
; 1345 : 				        (parser_char_types[new_input[temp+1]] & (TYPE_white))!=0)) ||
; 1346 : 				      (((parser_char_types[output_array[new_ret.output_pos+new_ret.output_offset-1]] & (TYPE_white))!=0) &&
; 1347 : 					   /*((parser_char_types[new_input[temp]] & (TYPE_white))==0) && */ (do_not_copy_next_word=1))
; 1348 : 					 
; 1349 : 					 
; 1350 : 					 
; 1351 : 					 
; 1352 : 					 ))

  00578	8b 54 24 34	 mov	 edx, DWORD PTR _new_ret$[esp+232]
  0057c	03 c8		 add	 ecx, eax
  0057e	8a 04 29	 mov	 al, BYTE PTR [ecx+ebp]
  00581	84 c0		 test	 al, al
  00583	74 53		 je	 SHORT $L71659
  00585	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0058a	66 8b 04 45 00
	00 00 00	 mov	 ax, WORD PTR _parser_char_types[eax*2]
  00592	a8 20		 test	 al, 32			; 00000020H
  00594	75 42		 jne	 SHORT $L71659
  00596	f6 c4 08	 test	 ah, 8
  00599	74 17		 je	 SHORT $L71660
  0059b	8a 44 29 01	 mov	 al, BYTE PTR [ecx+ebp+1]
  0059f	84 c0		 test	 al, al
  005a1	74 35		 je	 SHORT $L71659
  005a3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005a8	f6 04 45 00 00
	00 00 20	 test	 BYTE PTR _parser_char_types[eax*2], 32 ; 00000020H
  005b0	75 26		 jne	 SHORT $L71659
$L71660:
  005b2	8b 44 24 30	 mov	 eax, DWORD PTR _new_ret$[esp+228]
  005b6	8b bc 24 ec 00
	00 00		 mov	 edi, DWORD PTR _output_array$[esp+216]
  005bd	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  005c0	33 c0		 xor	 eax, eax
  005c2	8a 44 39 ff	 mov	 al, BYTE PTR [ecx+edi-1]
  005c6	f6 04 45 00 00
	00 00 20	 test	 BYTE PTR _parser_char_types[eax*2], 32 ; 00000020H
  005ce	74 5d		 je	 SHORT $L71661
  005d0	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR _do_not_copy_next_word$[esp+220], 1
$L71659:

; 1392 : 						{
; 1393 : 							current_rule_number=cur_rule_next_miss;
; 1394 : 							last_rule_was_hit= -1;				/* reset the last_rule_was_hit flag */
; 1395 : 						}
; 1396 : 						else
; 1397 : 						{
; 1398 : 							current_rule_number++;      		/* go to the next rule in the rule table */
; 1399 : 							last_rule_was_hit=0;				/* reset the last_rule_was_hit flag */
; 1400 : 						}
; 1401 : 					}
; 1402 : 					
; 1403 : 				} /* if (((new_input[new_ret.input_pos+new_ret.input_offset]!='\0') && */
; 1404 : 				else                      
; 1405 : 				{
; 1406 : 					/* here is where next hit rules have to be done */
; 1407 : 					/* 	
; 1408 : 					*	the amount of data that was writen o the output array if the difference 
; 1409 : 					*	between new_ret.output_offset and save_ret.output_offset
; 1410 : 					*	The amount of data read is the difference between new_ret.input_offset
; 1411 : 					*	and save_ret.input_offset
; 1412 : 					*/          
; 1413 : 					/*  
; 1414 : 					*	the data in the output starting at save_ret.output_offset has to be 
; 1415 : 					*	copied into new_input starting at save_ret.input_offset
; 1416 : 					*/ 
; 1417 : 					/*	if the output is larger than the input, move the input over output-input characters
; 1418 : 					*	if the output is the same size as the input, overwrite the input with the output
; 1419 : 					*	if the output is smaller than the input, place the output input-output 
; 1420 : 					*		characters to the right
; 1421 : 					*/
; 1422 : 					/* debug switch */
; 1423 : #ifndef PARSER_STANDALONE_DEBUG
; 1424 : 					if (DT_DBG(CMD_DBG,0x0010))

  005d8	66 8b 86 40 06
	00 00		 mov	 ax, WORD PTR [esi+1600]
  005df	f6 c4 80	 test	 ah, -128		; ffffff80H
  005e2	74 1b		 je	 SHORT $L71670
  005e4	a8 10		 test	 al, 16			; 00000010H
  005e6	74 17		 je	 SHORT $L71670

; 1425 : 					{
; 1426 : 						printf("Rule hit:R%d\n",current_rule_R_value);

  005e8	8b 54 24 5c	 mov	 edx, DWORD PTR _current_rule_R_value$[esp+220]
  005ec	52		 push	 edx
  005ed	68 00 00 00 00	 push	 OFFSET FLAT:$SG71671
  005f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  005f8	8b 54 24 3c	 mov	 edx, DWORD PTR _new_ret$[esp+240]
  005fc	83 c4 08	 add	 esp, 8
$L71670:

; 1427 : 					}
; 1428 : #endif
; 1429 : #ifdef DISPLAY_RULES_HIT
; 1430 : #ifdef PARSER_STANDALONE_DEBUG
; 1431 : #ifdef OUTPUT_HITS_NORMAL
; 1432 : 					fprintf(stderr,"H");
; 1433 : 					printf("the rule hit was R%d\n",current_rule_R_value);
; 1434 : 					printf("output array=%s\n",output_array);
; 1435 : #else
; 1436 : 					fprintf(stderr,"the rule hit was R%d\n",current_rule_R_value);
; 1437 : 					printf("output array=%s\n",output_array);
; 1438 : #endif
; 1439 : #else
; 1440 : 					printf("the rule hit was R%d\n",current_rule_R_value);
; 1441 : #endif
; 1442 : 
; 1443 : #endif
; 1444 : 					 
; 1445 : #if 0
; 1446 : 					if (((parser_char_types[output_array[new_ret.output_pos+new_ret.output_offset-1]] & (TYPE_white))!=0) &&
; 1447 : 					   ((temp1 & (TYPE_white))==0))
; 1448 : 					{
; 1449 : 						do_not_copy_next_word=1;
; 1450 : 					}
; 1451 : #endif
; 1452 : 					if (cur_rule_copy_hit!=-1)

  005ff	8b 4c 24 18	 mov	 ecx, DWORD PTR _cur_rule_copy_hit$[esp+220]
  00603	83 c8 ff	 or	 eax, -1
  00606	3b c8		 cmp	 ecx, eax
  00608	0f 84 cc 00 00
	00		 je	 $L71672

; 1453 : 					{
; 1454 : 						last_rule_was_hit=1;
; 1455 : 						current_rule_number=cur_rule_copy_hit;

  0060e	8b d9		 mov	 ebx, ecx

; 1456 : 						par_copy_return_value(&save_ret,&new_ret);

  00610	b9 08 00 00 00	 mov	 ecx, 8
  00615	8d 74 24 28	 lea	 esi, DWORD PTR _new_ret$[esp+220]
  00619	8d 7c 24 6c	 lea	 edi, DWORD PTR _save_ret$[esp+220]
  0061d	bd 01 00 00 00	 mov	 ebp, 1
  00622	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00626	f3 a5		 rep movsd

; 1457 : 					}
; 1458 : 					else

  00628	e9 a2 04 00 00	 jmp	 $L71699
$L71661:

; 1353 : 
; 1354 : 
; 1355 : 
; 1356 : /*				if (
; 1357 : 					(
; 1358 : 					 (new_input[new_ret.input_pos+new_ret.input_offset]!='\0') &&					
; 1359 : 					 !(
; 1360 : 					  ((parser_char_types[new_input[new_ret.input_pos+new_ret.input_offset]] & (TYPE_white))!=0)  ||
; 1361 : 					  (
; 1362 : 					   ((parser_char_types[new_input[new_ret.input_pos+new_ret.input_offset]] & (TYPE_clause))!=0) &&
; 1363 : 					   ( 
; 1364 : 					    (new_input[new_ret.input_pos+new_ret.input_offset+1]=='\0') ||
; 1365 : 					    ((parser_char_types[new_input[new_ret.input_pos+new_ret.input_offset+1]] & (TYPE_white))!=0) 
; 1366 : 					   )
; 1367 : 					  )
; 1368 : 					 )
; 1369 : 					) 
; 1370 : 				   )
; 1371 : */
; 1372 : 				{
; 1373 : 					par_copy_return_value(&new_ret,&save_ret);
; 1374 : 					if (cur_rule_next_go_miss!= -1)

  0062d	8b 44 24 1c	 mov	 eax, DWORD PTR _cur_rule_next_go_miss$[esp+220]
  00631	b9 08 00 00 00	 mov	 ecx, 8
  00636	8d 74 24 6c	 lea	 esi, DWORD PTR _save_ret$[esp+220]
  0063a	8d 7c 24 28	 lea	 edi, DWORD PTR _new_ret$[esp+220]
  0063e	83 f8 ff	 cmp	 eax, -1
  00641	f3 a5		 rep movsd
  00643	74 7a		 je	 SHORT $L71663

; 1375 : 					{
; 1376 : 						if (cur_rule_next_miss!= -1)

  00645	8b 4c 24 20	 mov	 ecx, DWORD PTR _cur_rule_next_miss$[esp+220]
  00649	83 f9 ff	 cmp	 ecx, -1
  0064c	74 2c		 je	 SHORT $L71664

; 1377 : 						{
; 1378 : 							par_set_return_level(return_rule,&return_level,cur_rule_next_miss);

  0064e	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  00652	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00655	7d 1c		 jge	 SHORT $L72929

; 1384 : 							//return_rule[return_level++]=current_rule_number+1;
; 1385 : 						}
; 1386 : 						current_rule_number=cur_rule_next_go_miss;

  00657	8b 5c 24 1c	 mov	 ebx, DWORD PTR _cur_rule_next_go_miss$[esp+220]
  0065b	89 8c 84 b4 00
	00 00		 mov	 DWORD PTR _return_rule$[esp+eax*4+220], ecx
  00662	40		 inc	 eax
  00663	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00667	89 44 24 10	 mov	 DWORD PTR _return_level$[esp+220], eax

; 1387 : 						last_rule_was_hit= -1;

  0066b	83 cd ff	 or	 ebp, -1

; 1388 : 					}
; 1389 : 					else

  0066e	e9 5c 04 00 00	 jmp	 $L71699

; 1377 : 						{
; 1378 : 							par_set_return_level(return_rule,&return_level,cur_rule_next_miss);

$L72929:
  00673	8b 4c 24 20	 mov	 ecx, DWORD PTR _cur_rule_next_miss$[esp+220]
  00677	51		 push	 ecx

; 1379 : 							//return_rule[return_level++]=next_miss_rule;
; 1380 : 						}
; 1381 : 						else

  00678	eb 27		 jmp	 SHORT $L73007
$L71664:

; 1382 : 						{
; 1383 : 							par_set_return_level(return_rule,&return_level,current_rule_number+1);

  0067a	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  0067e	43		 inc	 ebx
  0067f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00682	7d 1c		 jge	 SHORT $L72971
$L73008:
  00684	89 9c 84 b4 00
	00 00		 mov	 DWORD PTR _return_rule$[esp+eax*4+220], ebx

; 1384 : 							//return_rule[return_level++]=current_rule_number+1;
; 1385 : 						}
; 1386 : 						current_rule_number=cur_rule_next_go_miss;

  0068b	8b 5c 24 1c	 mov	 ebx, DWORD PTR _cur_rule_next_go_miss$[esp+220]
  0068f	40		 inc	 eax
  00690	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00694	89 44 24 10	 mov	 DWORD PTR _return_level$[esp+220], eax

; 1387 : 						last_rule_was_hit= -1;

  00698	83 cd ff	 or	 ebp, -1

; 1388 : 					}
; 1389 : 					else

  0069b	e9 2f 04 00 00	 jmp	 $L71699

; 1593 : 					{
; 1594 : 						par_set_return_level(return_rule,&return_level,current_rule_number+1);

$L72971:

; 1382 : 						{
; 1383 : 							par_set_return_level(return_rule,&return_level,current_rule_number+1);

  006a0	53		 push	 ebx
$L73007:
  006a1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@ ; `string'
  006a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf

; 1384 : 							//return_rule[return_level++]=current_rule_number+1;
; 1385 : 						}
; 1386 : 						current_rule_number=cur_rule_next_go_miss;

  006ac	8b 5c 24 24	 mov	 ebx, DWORD PTR _cur_rule_next_go_miss$[esp+228]
  006b0	83 c4 08	 add	 esp, 8
  006b3	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx

; 1387 : 						last_rule_was_hit= -1;

  006b7	83 cd ff	 or	 ebp, -1

; 1388 : 					}
; 1389 : 					else

  006ba	e9 10 04 00 00	 jmp	 $L71699
$L71663:

; 1390 : 					{
; 1391 : 						if (cur_rule_next_miss!= -1)	/* this is also a miss */

  006bf	8b 44 24 20	 mov	 eax, DWORD PTR _cur_rule_next_miss$[esp+220]
  006c3	83 f8 ff	 cmp	 eax, -1
  006c6	0f 84 fc 03 00
	00		 je	 $L71667

; 1602 : 					{
; 1603 : 						current_rule_number=cur_rule_next_miss;

  006cc	8b d8		 mov	 ebx, eax
  006ce	83 cd ff	 or	 ebp, -1
  006d1	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  006d5	e9 f5 03 00 00	 jmp	 $L71699
$L71672:

; 1459 : 
; 1460 : 					if ((cur_rule_next_hit!= -1) || (cur_rule_next_go_hit!= -1))

  006da	39 44 24 54	 cmp	 DWORD PTR _cur_rule_next_hit$[esp+220], eax
  006de	75 13		 jne	 SHORT $L71676
  006e0	39 44 24 64	 cmp	 DWORD PTR _cur_rule_next_go_hit$[esp+220], eax
  006e4	75 0d		 jne	 SHORT $L71676

; 1575 : 					} /* if ((current_rule->next_hit_rule!= -1) || (current_rule->next_goret_hit!= -1)) */
; 1576 : 					else
; 1577 : 					{
; 1578 : 						done=1;

  006e6	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR _done$[esp+220], 1

; 1579 : 						last_rule_was_hit=0;

  006ee	e9 da 03 00 00	 jmp	 $L73003
$L71676:

; 1461 : 					{
; 1462 : 						par_copy_return_value(&hit_ret,&new_ret);
; 1463 : 						input_size=new_ret.input_offset-save_ret.input_offset;

  006f3	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+224]

; 1464 : 						output_size=new_ret.output_offset-save_ret.output_offset;

  006f7	8b 5c 24 78	 mov	 ebx, DWORD PTR _save_ret$[esp+232]
  006fb	b9 08 00 00 00	 mov	 ecx, 8
  00700	8d 74 24 28	 lea	 esi, DWORD PTR _new_ret$[esp+220]
  00704	8d bc 24 94 00
	00 00		 lea	 edi, DWORD PTR _hit_ret$[esp+220]
  0070b	2b d3		 sub	 edx, ebx
  0070d	f3 a5		 rep movsd
  0070f	8b 74 24 70	 mov	 esi, DWORD PTR _save_ret$[esp+224]
  00713	2b c6		 sub	 eax, esi

; 1465 : 						if (output_size>input_size)

  00715	3b c2		 cmp	 eax, edx
  00717	0f 8d e8 01 00
	00		 jge	 $L73004

; 1466 : 						{
; 1467 : #ifdef DEBUG
; 1468 : 							printf("par_process_input;the output is larger than the input\n");
; 1469 : #endif
; 1470 : 							size_diff=output_size-input_size;

  0071d	8b ea		 mov	 ebp, edx
  0071f	2b e8		 sub	 ebp, eax

; 1471 : 							/* should check for overrunning the new input array */
; 1472 : 							/* copy the input to its new location */
; 1473 : #ifdef NEW_DEBUG
; 1474 : 							par_print_rule_error("the input_array before moving, changing",new_input,new_ret.input_pos+new_ret.input_offset);
; 1475 : 							par_print_rule_error("the output_array before moving, changing",output_array,new_ret.output_pos+new_ret.output_offset);
; 1476 : #endif
; 1477 : 							
; 1478 : 							if (save_ret.input_offset > size_diff)

  00721	8b c6		 mov	 eax, esi
  00723	3b c5		 cmp	 eax, ebp
  00725	7e 75		 jle	 SHORT $L71679

; 1479 : 							{
; 1480 : 								memcpy(new_input+(save_ret.input_pos+save_ret.input_offset-size_diff),output_array+(save_ret.output_offset+save_ret.output_pos),output_size);

  00727	8b 44 24 74	 mov	 eax, DWORD PTR _save_ret$[esp+228]
  0072b	8b ce		 mov	 ecx, esi
  0072d	8b 74 24 6c	 mov	 esi, DWORD PTR _save_ret$[esp+220]
  00731	2b cd		 sub	 ecx, ebp
  00733	8b ac 24 e8 00
	00 00		 mov	 ebp, DWORD PTR _new_input$[esp+216]
  0073a	89 4c 24 1c	 mov	 DWORD PTR -192+[esp+220], ecx
  0073e	8d 3c 31	 lea	 edi, DWORD PTR [ecx+esi]
  00741	8b b4 24 ec 00
	00 00		 mov	 esi, DWORD PTR _output_array$[esp+216]
  00748	89 7c 24 18	 mov	 DWORD PTR -196+[esp+220], edi
  0074c	8b ca		 mov	 ecx, edx
  0074e	03 fd		 add	 edi, ebp
  00750	03 c3		 add	 eax, ebx
  00752	8b e9		 mov	 ebp, ecx
  00754	03 f0		 add	 esi, eax
  00756	c1 e9 02	 shr	 ecx, 2
  00759	f3 a5		 rep movsd
  0075b	8b cd		 mov	 ecx, ebp
  0075d	83 e1 03	 and	 ecx, 3
  00760	f3 a4		 rep movsb

; 1481 : 								/* copy the index data */
; 1482 : 								// MGS 04/05/2000 fixed problem with "this is com2" pronounced as "this is c om 2" with indexing
; 1483 : 								par_copy_index_list(new_input_indexes,(save_ret.input_pos+save_ret.input_offset-size_diff),output_indexes,(save_ret.output_offset+save_ret.output_pos),output_size);

  00762	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  00765	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00768	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR _output_indexes$[esp+216]
  0076f	d1 e1		 shl	 ecx, 1
  00771	8d 34 50	 lea	 esi, DWORD PTR [eax+edx*2]
  00774	8b 44 24 18	 mov	 eax, DWORD PTR -196+[esp+220]
  00778	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0077b	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR _new_input_indexes$[esp+216]
  00782	8d 3c 50	 lea	 edi, DWORD PTR [eax+edx*2]
  00785	8b d1		 mov	 edx, ecx
  00787	c1 e9 02	 shr	 ecx, 2
  0078a	f3 a5		 rep movsd

; 1484 : 								/* hit_ret.input_offset+=size_diff; */
; 1485 : 								new_ret.input_offset=save_ret.input_offset-size_diff;

  0078c	8b 44 24 1c	 mov	 eax, DWORD PTR -192+[esp+220]
  00790	8b ca		 mov	 ecx, edx
  00792	83 e1 03	 and	 ecx, 3
  00795	f3 a4		 rep movsb

; 1486 : 								new_ret.output_offset=save_ret.output_offset;
; 1487 : 								save_ret.input_offset-=size_diff;
; 1488 : 							}
; 1489 : 							else

  00797	e9 3a 02 00 00	 jmp	 $L73005
$L71679:

; 1490 : 							{
; 1491 : 								j=new_ret.input_offset+new_ret.input_pos;

  0079c	8b 4c 24 2c	 mov	 ecx, DWORD PTR _new_ret$[esp+224]
  007a0	8b 44 24 28	 mov	 eax, DWORD PTR _new_ret$[esp+220]

; 1492 : 								for (i=strlen(new_input)+size_diff;i>j;i--)

  007a4	8b bc 24 e8 00
	00 00		 mov	 edi, DWORD PTR _new_input$[esp+216]
  007ab	03 c8		 add	 ecx, eax
  007ad	89 4c 24 20	 mov	 DWORD PTR _j$[esp+220], ecx
  007b1	83 c9 ff	 or	 ecx, -1
  007b4	33 c0		 xor	 eax, eax
  007b6	f2 ae		 repne scasb
  007b8	8b 44 24 20	 mov	 eax, DWORD PTR _j$[esp+220]
  007bc	f7 d1		 not	 ecx
  007be	49		 dec	 ecx
  007bf	8b f1		 mov	 esi, ecx
  007c1	03 f5		 add	 esi, ebp
  007c3	3b f0		 cmp	 esi, eax
  007c5	0f 8e a6 00 00
	00		 jle	 $L71683
  007cb	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR _dict_hit_array$[esp+216]
  007d2	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR _new_input$[esp+216]
  007d9	8d 5c 6d 00	 lea	 ebx, DWORD PTR [ebp+ebp*2]
  007dd	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  007e0	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  007e3	d1 e1		 shl	 ecx, 1
  007e5	d1 e3		 shl	 ebx, 1
  007e7	2b 84 24 f0 00
	00 00		 sub	 eax, DWORD PTR _dict_hit_array$[esp+216]
  007ee	89 7c 24 1c	 mov	 DWORD PTR -192+[esp+220], edi
  007f2	89 4c 24 18	 mov	 DWORD PTR -196+[esp+220], ecx
  007f6	89 9c 24 8c 00
	00 00		 mov	 DWORD PTR -80+[esp+220], ebx
  007fd	89 44 24 68	 mov	 DWORD PTR -116+[esp+220], eax
  00801	eb 07		 jmp	 SHORT $L71681
$L72994:
  00803	8b 9c 24 8c 00
	00 00		 mov	 ebx, DWORD PTR -80+[esp+220]
$L71681:

; 1493 : 								{
; 1494 : 									k=i-size_diff;

  0080a	2b cb		 sub	 ecx, ebx

; 1495 : #ifdef DEBUG
; 1496 : 									printf("process_input;copying new_input[%d]%c(%0X)=new_input[%d]%c(%0X)\n",i,new_input[i],new_input[i],k,new_input[k],new_input[k]);
; 1497 : #endif
; 1498 : 									new_input[i]=new_input[k];

  0080c	8b 5c 24 68	 mov	 ebx, DWORD PTR -116+[esp+220]
  00810	8b c6		 mov	 eax, esi
  00812	89 4c 24 4c	 mov	 DWORD PTR -144+[esp+220], ecx
  00816	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR _new_input$[esp+216]
  0081d	2b c5		 sub	 eax, ebp
  0081f	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  00822	88 0c 3b	 mov	 BYTE PTR [ebx+edi], cl

; 1499 : 									par_copy_index(new_input_indexes,i,new_input_indexes,k);

  00825	8b 7c 24 4c	 mov	 edi, DWORD PTR -144+[esp+220]
  00829	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR _new_input_indexes$[esp+216]
  00830	8b 5c 24 18	 mov	 ebx, DWORD PTR -196+[esp+220]
  00834	03 f9		 add	 edi, ecx
  00836	03 d9		 add	 ebx, ecx
  00838	4e		 dec	 esi
  00839	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0083b	89 0b		 mov	 DWORD PTR [ebx], ecx
  0083d	66 8b 4f 04	 mov	 cx, WORD PTR [edi+4]

; 1500 : 									dict_hit_array[i]=dict_hit_array[k];

  00841	8b 7c 24 1c	 mov	 edi, DWORD PTR -192+[esp+220]
  00845	66 89 4b 04	 mov	 WORD PTR [ebx+4], cx
  00849	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR _dict_hit_array$[esp+216]
  00850	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  00853	8b 4c 24 18	 mov	 ecx, DWORD PTR -196+[esp+220]
  00857	88 07		 mov	 BYTE PTR [edi], al
  00859	8b 44 24 20	 mov	 eax, DWORD PTR _j$[esp+220]
  0085d	83 e9 06	 sub	 ecx, 6
  00860	4f		 dec	 edi
  00861	3b f0		 cmp	 esi, eax
  00863	89 4c 24 18	 mov	 DWORD PTR -196+[esp+220], ecx
  00867	89 7c 24 1c	 mov	 DWORD PTR -192+[esp+220], edi
  0086b	7f 96		 jg	 SHORT $L72994

; 1492 : 								for (i=strlen(new_input)+size_diff;i>j;i--)

  0086d	8b 5c 24 78	 mov	 ebx, DWORD PTR _save_ret$[esp+232]
$L71683:

; 1501 : 									
; 1502 : 								}
; 1503 : 								new_input_diff+=size_diff;

  00871	8b 4c 24 58	 mov	 ecx, DWORD PTR _new_input_diff$[esp+220]

; 1504 : #ifdef DEBUG
; 1505 : 								par_print_rule_error("111 input",new_input,new_ret.input_pos+new_ret.input_offset);
; 1506 : 								par_print_rule_error("111 output",output_array,new_ret.output_pos+new_ret.output_offset);
; 1507 : #endif
; 1508 : 								/* copy the changed data */
; 1509 : 								memcpy(new_input+(save_ret.input_offset+save_ret.input_pos),output_array+(save_ret.output_offset+save_ret.output_pos),output_size);

  00875	8b 74 24 70	 mov	 esi, DWORD PTR _save_ret$[esp+224]
  00879	03 cd		 add	 ecx, ebp
  0087b	89 4c 24 58	 mov	 DWORD PTR _new_input_diff$[esp+220], ecx
  0087f	8b 4c 24 74	 mov	 ecx, DWORD PTR _save_ret$[esp+228]
  00883	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  00886	8b 4c 24 6c	 mov	 ecx, DWORD PTR _save_ret$[esp+220]
  0088a	89 44 24 4c	 mov	 DWORD PTR -144+[esp+220], eax
  0088e	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  00891	8b b4 24 ec 00
	00 00		 mov	 esi, DWORD PTR _output_array$[esp+216]
  00898	03 f0		 add	 esi, eax
  0089a	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR _new_input$[esp+216]
  008a1	89 7c 24 18	 mov	 DWORD PTR -196+[esp+220], edi
  008a5	8b ca		 mov	 ecx, edx
  008a7	03 f8		 add	 edi, eax
  008a9	8b c1		 mov	 eax, ecx
  008ab	c1 e9 02	 shr	 ecx, 2
  008ae	f3 a5		 rep movsd
  008b0	8b c8		 mov	 ecx, eax

; 1510 : 								/* copy the index data */
; 1511 : 								par_copy_index_list(new_input_indexes,(save_ret.input_offset+save_ret.input_pos),output_indexes,(save_ret.output_offset+save_ret.output_pos),output_size);

  008b2	8b 44 24 4c	 mov	 eax, DWORD PTR -144+[esp+220]
  008b6	83 e1 03	 and	 ecx, 3
  008b9	f3 a4		 rep movsb
  008bb	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  008be	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  008c1	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR _output_indexes$[esp+216]
  008c8	d1 e1		 shl	 ecx, 1
  008ca	8d 34 50	 lea	 esi, DWORD PTR [eax+edx*2]
  008cd	8b 44 24 18	 mov	 eax, DWORD PTR -196+[esp+220]
  008d1	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  008d4	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR _new_input_indexes$[esp+216]
  008db	8d 3c 50	 lea	 edi, DWORD PTR [eax+edx*2]
  008de	8b d1		 mov	 edx, ecx
  008e0	c1 e9 02	 shr	 ecx, 2
  008e3	f3 a5		 rep movsd

; 1512 : 								hit_ret.input_offset+=size_diff;

  008e5	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR _hit_ret$[esp+224]
  008ec	8b ca		 mov	 ecx, edx
  008ee	83 e1 03	 and	 ecx, 3
  008f1	03 c5		 add	 eax, ebp
  008f3	89 84 24 98 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+224], eax

; 1513 : 								new_ret.input_offset=save_ret.input_offset;

  008fa	8b 44 24 70	 mov	 eax, DWORD PTR _save_ret$[esp+224]
  008fe	f3 a4		 rep movsb

; 1514 : 								new_ret.output_offset=save_ret.output_offset;
; 1515 : 							}
; 1516 : #ifdef DEBUG
; 1517 : 							par_print_rule_error("222 input",new_input,new_ret.input_pos+new_ret.input_offset);
; 1518 : 							par_print_rule_error("222 output",output_array,new_ret.output_pos+new_ret.output_offset);
; 1519 : #endif
; 1520 : #ifdef NEW_DEBUG
; 1521 : 							par_print_rule_error("the input_array after moving, changing",new_input,new_ret.input_pos+new_ret.input_offset);
; 1522 : 							par_print_rule_error("the output_array after moving, changing",output_array,new_ret.output_pos+new_ret.output_offset);
; 1523 : #endif
; 1524 : 						} /* if (output_size>input_size) */
; 1525 : 						else

  00900	e9 d1 00 00 00	 jmp	 $L73005
$L73004:

; 1526 : 						{
; 1527 : 							if (input_size==output_size)

  00905	75 64		 jne	 SHORT $L71685

; 1528 : 							{
; 1529 : #ifdef DEBUG
; 1530 : 								printf("par_process_input;the output is the same size as the input\n");
; 1531 : #endif              
; 1532 : 								/* overwrite the input with the output */
; 1533 : 								memcpy(new_input+save_ret.input_offset+save_ret.input_pos,output_array+save_ret.output_offset+save_ret.output_pos,input_size);

  00907	8b 4c 24 74	 mov	 ecx, DWORD PTR _save_ret$[esp+228]
  0090b	8d 14 0b	 lea	 edx, DWORD PTR [ebx+ecx]
  0090e	8b 4c 24 6c	 mov	 ecx, DWORD PTR _save_ret$[esp+220]
  00912	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  00915	8b b4 24 ec 00
	00 00		 mov	 esi, DWORD PTR _output_array$[esp+216]
  0091c	89 7c 24 18	 mov	 DWORD PTR -196+[esp+220], edi
  00920	8b c8		 mov	 ecx, eax
  00922	03 fd		 add	 edi, ebp
  00924	8b e9		 mov	 ebp, ecx
  00926	03 f2		 add	 esi, edx

; 1534 : 								/* overwrite the index data with the output index data */
; 1535 : 								par_copy_index_list(new_input_indexes,save_ret.input_offset+save_ret.input_pos,output_indexes,save_ret.output_offset+save_ret.output_pos,input_size);

  00928	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  0092b	c1 e9 02	 shr	 ecx, 2
  0092e	f3 a5		 rep movsd
  00930	8b cd		 mov	 ecx, ebp
  00932	83 e1 03	 and	 ecx, 3
  00935	f3 a4		 rep movsb
  00937	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0093a	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR _output_indexes$[esp+216]
  00941	d1 e1		 shl	 ecx, 1
  00943	8d 34 50	 lea	 esi, DWORD PTR [eax+edx*2]
  00946	8b 44 24 18	 mov	 eax, DWORD PTR -196+[esp+220]
  0094a	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0094d	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR _new_input_indexes$[esp+216]
  00954	8d 3c 50	 lea	 edi, DWORD PTR [eax+edx*2]
  00957	8b d1		 mov	 edx, ecx
  00959	c1 e9 02	 shr	 ecx, 2
  0095c	f3 a5		 rep movsd

; 1536 : 								new_ret.input_offset=save_ret.input_offset;

  0095e	8b 44 24 70	 mov	 eax, DWORD PTR _save_ret$[esp+224]
  00962	8b ca		 mov	 ecx, edx
  00964	83 e1 03	 and	 ecx, 3
  00967	f3 a4		 rep movsb

; 1537 : 								new_ret.output_offset=save_ret.output_offset;
; 1538 : 							} /* if (input_size==output_size) */
; 1539 : 							else

  00969	eb 6b		 jmp	 SHORT $L73005
$L71685:

; 1540 : 							{
; 1541 : #ifdef DEBUG
; 1542 : 								printf("par_process_input;the output is smaller than the input\n");
; 1543 : #endif                                   
; 1544 : 								/* 
; 1545 : 								* place the output in the input array so the end of the output
; 1546 : 								* matches up with the end of the input that was just processed 
; 1547 : 								*/
; 1548 : 								size_diff=input_size-output_size;

  0096b	2b c2		 sub	 eax, edx
  0096d	8b c8		 mov	 ecx, eax

; 1549 : 								/* copy the output to the proper place in the input */
; 1550 : 								memcpy(new_input+save_ret.input_offset+save_ret.input_pos+size_diff,output_array+save_ret.output_offset+save_ret.output_pos,output_size);

  0096f	8b 44 24 74	 mov	 eax, DWORD PTR _save_ret$[esp+228]
  00973	03 ce		 add	 ecx, esi
  00975	8b 74 24 6c	 mov	 esi, DWORD PTR _save_ret$[esp+220]
  00979	89 4c 24 68	 mov	 DWORD PTR -116+[esp+220], ecx
  0097d	03 c3		 add	 eax, ebx
  0097f	8d 3c 31	 lea	 edi, DWORD PTR [ecx+esi]
  00982	8b b4 24 ec 00
	00 00		 mov	 esi, DWORD PTR _output_array$[esp+216]
  00989	89 7c 24 4c	 mov	 DWORD PTR -144+[esp+220], edi
  0098d	8b ca		 mov	 ecx, edx
  0098f	03 fd		 add	 edi, ebp
  00991	8b e9		 mov	 ebp, ecx
  00993	03 f0		 add	 esi, eax
  00995	c1 e9 02	 shr	 ecx, 2
  00998	f3 a5		 rep movsd
  0099a	8b cd		 mov	 ecx, ebp
  0099c	83 e1 03	 and	 ecx, 3
  0099f	f3 a4		 rep movsb

; 1551 : 								/* copy the indexes into their new home */
; 1552 : 								par_copy_index_list(new_input_indexes,save_ret.input_offset+save_ret.input_pos+size_diff,output_indexes,save_ret.output_offset+save_ret.output_pos,output_size);

  009a1	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  009a4	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  009a7	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR _output_indexes$[esp+216]
  009ae	d1 e1		 shl	 ecx, 1
  009b0	8d 34 50	 lea	 esi, DWORD PTR [eax+edx*2]
  009b3	8b 44 24 4c	 mov	 eax, DWORD PTR -144+[esp+220]
  009b7	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  009ba	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR _new_input_indexes$[esp+216]
  009c1	8d 3c 50	 lea	 edi, DWORD PTR [eax+edx*2]
  009c4	8b d1		 mov	 edx, ecx
  009c6	c1 e9 02	 shr	 ecx, 2
  009c9	f3 a5		 rep movsd

; 1553 : 								new_ret.input_offset=save_ret.input_offset+size_diff;

  009cb	8b 44 24 68	 mov	 eax, DWORD PTR -116+[esp+220]
  009cf	8b ca		 mov	 ecx, edx
  009d1	83 e1 03	 and	 ecx, 3
  009d4	f3 a4		 rep movsb
$L73005:

; 1554 : 								new_ret.output_offset=save_ret.output_offset;

  009d6	89 5c 24 34	 mov	 DWORD PTR _new_ret$[esp+232], ebx

; 1555 : 							} /* if (input_size==output_size) */
; 1556 : 						} /* if (output_size>input_size) */
; 1557 : 						if (cur_rule_next_go_hit!= -1)

  009da	8b 5c 24 64	 mov	 ebx, DWORD PTR _cur_rule_next_go_hit$[esp+220]
  009de	83 fb ff	 cmp	 ebx, -1
  009e1	89 44 24 2c	 mov	 DWORD PTR _new_ret$[esp+224], eax
  009e5	74 60		 je	 SHORT $L71687

; 1558 : 						{
; 1559 : 							if (cur_rule_next_hit!= -1)

  009e7	8b 4c 24 54	 mov	 ecx, DWORD PTR _cur_rule_next_hit$[esp+220]
  009eb	83 f9 ff	 cmp	 ecx, -1
  009ee	74 28		 je	 SHORT $L71688

; 1560 : 							{
; 1561 : 								par_set_return_level(return_rule,&return_level,cur_rule_next_hit);

  009f0	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  009f4	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  009f7	7d 0e		 jge	 SHORT $L72955
  009f9	89 8c 84 b4 00
	00 00		 mov	 DWORD PTR _return_rule$[esp+eax*4+220], ecx
  00a00	40		 inc	 eax
  00a01	89 44 24 10	 mov	 DWORD PTR _return_level$[esp+220], eax
  00a05	eb 44		 jmp	 SHORT $L72961
$L72955:
  00a07	51		 push	 ecx

; 1562 : 							}
; 1563 : 							else
; 1564 : 							{
; 1565 : 								par_set_return_level(return_rule,&return_level,current_rule_number+1);

  00a08	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@ ; `string'
  00a0d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00a13	83 c4 08	 add	 esp, 8

; 1566 : 							}
; 1567 : 							current_rule_number=cur_rule_next_go_hit;
; 1568 : 						}
; 1569 : 						else

  00a16	eb 33		 jmp	 SHORT $L72961
$L71688:

; 1562 : 							}
; 1563 : 							else
; 1564 : 							{
; 1565 : 								par_set_return_level(return_rule,&return_level,current_rule_number+1);

  00a18	8b 4c 24 14	 mov	 ecx, DWORD PTR _current_rule_number$[esp+220]
  00a1c	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00a1f	8b 4c 24 10	 mov	 ecx, DWORD PTR _return_level$[esp+220]
  00a23	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00a26	7d 0e		 jge	 SHORT $L72960
  00a28	89 84 8c b4 00
	00 00		 mov	 DWORD PTR _return_rule$[esp+ecx*4+220], eax
  00a2f	41		 inc	 ecx
  00a30	89 4c 24 10	 mov	 DWORD PTR _return_level$[esp+220], ecx
  00a34	eb 15		 jmp	 SHORT $L72961
$L72960:
  00a36	50		 push	 eax
  00a37	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@ ; `string'
  00a3c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00a42	83 c4 08	 add	 esp, 8

; 1566 : 							}
; 1567 : 							current_rule_number=cur_rule_next_go_hit;
; 1568 : 						}
; 1569 : 						else

  00a45	eb 04		 jmp	 SHORT $L72961
$L71687:

; 1570 : 						{						
; 1571 : 							current_rule_number=cur_rule_next_hit;         

  00a47	8b 5c 24 54	 mov	 ebx, DWORD PTR _cur_rule_next_hit$[esp+220]

; 1562 : 							}
; 1563 : 							else
; 1564 : 							{
; 1565 : 								par_set_return_level(return_rule,&return_level,current_rule_number+1);

$L72961:

; 1572 : 						}
; 1573 : 						par_copy_return_value(&save_ret,&new_ret);

  00a4b	b9 08 00 00 00	 mov	 ecx, 8
  00a50	8d 74 24 28	 lea	 esi, DWORD PTR _new_ret$[esp+220]
  00a54	8d 7c 24 6c	 lea	 edi, DWORD PTR _save_ret$[esp+220]
  00a58	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00a5c	f3 a5		 rep movsd

; 1574 : 						last_rule_was_hit=1;

  00a5e	bd 01 00 00 00	 mov	 ebp, 1

; 1580 : 					} /* if ((current_rule->next_hit_rule!= -1) || (current_rule->next_goret_hit!= -1)) */
; 1581 : 				} /* if (((new_input[new_ret.input_pos+new_ret.input_offset]!='\0') && */
; 1582 : 			} /* if (new_ret.value == SUCCESS) */
; 1583 : 			else                  

  00a63	eb 6a		 jmp	 SHORT $L71699
$L71658:

; 1584 : 			{
; 1585 : 				/* next miss rules are done here */
; 1586 : 				if (cur_rule_next_go_miss!= -1)

  00a65	83 7c 24 1c ff	 cmp	 DWORD PTR _cur_rule_next_go_miss$[esp+220], -1
  00a6a	74 48		 je	 SHORT $L71694

; 1587 : 				{
; 1588 : 					if (cur_rule_next_miss!= -1)

  00a6c	8b 4c 24 20	 mov	 ecx, DWORD PTR _cur_rule_next_miss$[esp+220]
  00a70	83 f9 ff	 cmp	 ecx, -1
  00a73	74 2c		 je	 SHORT $L71695

; 1589 : 					{
; 1590 : 						par_set_return_level(return_rule,&return_level,cur_rule_next_miss);

  00a75	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  00a79	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00a7c	7d 19		 jge	 SHORT $L72966
  00a7e	8b 5c 24 1c	 mov	 ebx, DWORD PTR _cur_rule_next_go_miss$[esp+220]
  00a82	89 8c 84 b4 00
	00 00		 mov	 DWORD PTR _return_rule$[esp+eax*4+220], ecx
  00a89	40		 inc	 eax
  00a8a	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00a8e	89 44 24 10	 mov	 DWORD PTR _return_level$[esp+220], eax
  00a92	83 cd ff	 or	 ebp, -1
  00a95	eb 38		 jmp	 SHORT $L71699
$L72966:
  00a97	8b 54 24 20	 mov	 edx, DWORD PTR _cur_rule_next_miss$[esp+220]
  00a9b	52		 push	 edx

; 1591 : 					}
; 1592 : 					else

  00a9c	e9 00 fc ff ff	 jmp	 $L73007
$L71695:

; 1593 : 					{
; 1594 : 						par_set_return_level(return_rule,&return_level,current_rule_number+1);

  00aa1	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  00aa5	43		 inc	 ebx
  00aa6	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00aa9	0f 8d f1 fb ff
	ff		 jge	 $L72971

; 1595 : 					}
; 1596 : 					current_rule_number=cur_rule_next_go_miss;
; 1597 : 					last_rule_was_hit= -1;
; 1598 : 				}
; 1599 : 				else

  00aaf	e9 d0 fb ff ff	 jmp	 $L73008
$L71694:

; 1600 : 				{
; 1601 : 					if (cur_rule_next_miss!= -1)	/* this is also a miss */

  00ab4	8b 44 24 20	 mov	 eax, DWORD PTR _cur_rule_next_miss$[esp+220]
  00ab8	83 f8 ff	 cmp	 eax, -1
  00abb	74 0b		 je	 SHORT $L71667

; 1602 : 					{
; 1603 : 						current_rule_number=cur_rule_next_miss;

  00abd	8b d8		 mov	 ebx, eax
  00abf	83 cd ff	 or	 ebp, -1
  00ac2	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00ac6	eb 07		 jmp	 SHORT $L71699
$L71667:

; 1604 : 						last_rule_was_hit= -1;				/* reset the last_rule_was_hit flag */
; 1605 : 					}
; 1606 : 					else
; 1607 : 					{
; 1608 : 						current_rule_number++;      		/* go to the next rule in the rule table */

  00ac8	43		 inc	 ebx
  00ac9	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
$L73003:

; 1609 : 						last_rule_was_hit=0;				/* reset the last_rule_was_hit flag */

  00acd	33 ed		 xor	 ebp, ebp
$L71699:

; 1610 : 					}
; 1611 : 				}
; 1612 : 			} /* if (new_ret.value == SUCCESS) */
; 1613 : 			  /*
; 1614 : 			  * the processing has tried all the rules and either the
; 1615 : 			  * last rule has hit or none of them hit 
; 1616 : 			*/
; 1617 : 			if ((current_rule_number>=num_rules) || (current_rule_number<0))

  00acf	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR _num_rules
  00ad5	7d 3f		 jge	 SHORT $L71608
  00ad7	85 db		 test	 ebx, ebx
  00ad9	7c 3b		 jl	 SHORT $L71608
  00adb	8b 44 24 24	 mov	 eax, DWORD PTR _done$[esp+220]
  00adf	85 c0		 test	 eax, eax
  00ae1	75 33		 jne	 SHORT $L71608

; 1066 : 		}  	               
; 1067 : 		par_copy_return_value(&save_ret,&new_ret);	/* save the values if the matching ends on a non white */
; 1068 : 		current_rule=NULL;                     
; 1069 : 		current_rule_number=rule_sections[rule];
; 1070 : 		last_rule_was_hit=0;
; 1071 : #ifdef DEBUG
; 1072 : 		par_print_rule_error("par_process_input;1 the input is",new_input,new_ret.input_pos+new_ret.input_offset);
; 1073 : 		par_print_rule_error("par_process_input;1 the output is",output_array,new_ret.output_pos+new_ret.output_offset);
; 1074 : #endif
; 1075 : 		while (!done)

  00ae3	e9 a5 f7 ff ff	 jmp	 $L71601
$L71611:

; 1105 : 				case BIN_STOP:
; 1106 : 					done=1;
; 1107 : 					/* 
; 1108 : 					* potential bug if the matching is down a return level and 
; 1109 : 					* encounters a stop, the return level is left in place and could start
; 1110 : 					* to overwrite memory 
; 1111 : 					*/
; 1112 : 					return_level=0;
; 1113 : 					if (last_rule_was_hit>0)

  00ae8	85 ed		 test	 ebp, ebp
  00aea	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _return_level$[esp+220], 0
  00af2	7e 22		 jle	 SHORT $L71608

; 1114 : 					{
; 1115 : 						//new_ret.output_offset=hit_ret.output_offset;
; 1116 : 						par_copy_return_value(&new_ret,&hit_ret);

  00af4	b9 08 00 00 00	 mov	 ecx, 8
  00af9	8d b4 24 94 00
	00 00		 lea	 esi, DWORD PTR _hit_ret$[esp+220]
  00b00	8d 7c 24 28	 lea	 edi, DWORD PTR _new_ret$[esp+220]
  00b04	f3 a5		 rep movsd

; 1117 : 					}
; 1118 : 					continue;          

  00b06	eb 0e		 jmp	 SHORT $L71608
$L72979:

; 1132 : 				default:
; 1133 : 					printf("special rule value is out of range\n");

  00b08	68 00 00 00 00	 push	 OFFSET FLAT:$SG71618
  00b0d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00b13	83 c4 04	 add	 esp, 4
$L71608:

; 1618 : 				done=1;         
; 1619 : #ifdef DEBUG
; 1620 : 			printf("process_input done = %d\n",done);
; 1621 : #endif
; 1622 : 			
; 1623 : 		}	/* while (!done) */
; 1624 : 		/* copy the word to the output */
; 1625 : 		/* this copies the data from the current position in the input until it hits a whitespace */
; 1626 : 		/* -1 signals that the end of the input string has been reached */
; 1627 : 		/* should check for overrunning the output array */
; 1628 : 		if (do_not_copy_next_word==1)

  00b16	83 7c 24 60 01	 cmp	 DWORD PTR _do_not_copy_next_word$[esp+220], 1
  00b1b	75 28		 jne	 SHORT $L71702

; 1629 : 		{
; 1630 : 			do_not_copy_next_word=0;
; 1631 : 			done=0;
; 1632 : 		}
; 1633 : 		else

  00b1d	8b 9c 24 14 01
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+216]
  00b24	8b b4 24 e8 00
	00 00		 mov	 esi, DWORD PTR _new_input$[esp+216]
  00b2b	33 c0		 xor	 eax, eax
  00b2d	bf 01 00 00 00	 mov	 edi, 1
  00b32	89 44 24 60	 mov	 DWORD PTR _do_not_copy_next_word$[esp+220], eax
  00b36	89 44 24 24	 mov	 DWORD PTR _done$[esp+220], eax
  00b3a	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+224]
  00b3e	33 ed		 xor	 ebp, ebp
  00b40	e9 94 f6 ff ff	 jmp	 $L71591
$L71702:

; 1634 : 		{
; 1635 : 			if (par_copy_word_to_output(new_input,output_array,new_input_indexes,output_indexes,&new_ret)== -1)

  00b45	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR _output_indexes$[esp+216]
  00b4c	8b 94 24 f8 00
	00 00		 mov	 edx, DWORD PTR _new_input_indexes$[esp+216]
  00b53	8b b4 24 e8 00
	00 00		 mov	 esi, DWORD PTR _new_input$[esp+216]
  00b5a	8d 44 24 28	 lea	 eax, DWORD PTR _new_ret$[esp+220]
  00b5e	50		 push	 eax
  00b5f	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR _output_array$[esp+220]
  00b66	51		 push	 ecx
  00b67	52		 push	 edx
  00b68	50		 push	 eax
  00b69	56		 push	 esi
  00b6a	e8 00 00 00 00	 call	 _par_copy_word_to_output

; 1636 : 			{
; 1637 : 				done=1;
; 1638 : 			}
; 1639 : 			else
; 1640 : 			{
; 1641 : 				done=0;
; 1642 : 			}
; 1643 : 		}
; 1644 : 		
; 1645 : 	}	/* while (new_input[]!='\0') */

  00b6f	8b 9c 24 28 01
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+236]
  00b76	83 c4 14	 add	 esp, 20			; 00000014H
  00b79	33 c9		 xor	 ecx, ecx
  00b7b	83 f8 ff	 cmp	 eax, -1
  00b7e	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+224]
  00b82	bf 01 00 00 00	 mov	 edi, 1
  00b87	0f 94 c1	 sete	 cl
  00b8a	89 4c 24 24	 mov	 DWORD PTR _done$[esp+220], ecx
  00b8e	33 ed		 xor	 ebp, ebp
  00b90	e9 44 f6 ff ff	 jmp	 $L71591
$L71596:

; 1323 : 			{
; 1324 : 				cm_util_flush_init(phTTS);

  00b95	8b 94 24 e0 00
	00 00		 mov	 edx, DWORD PTR _phTTS$[esp+216]
  00b9c	52		 push	 edx
  00b9d	e8 00 00 00 00	 call	 _cm_util_flush_init

; 1325 : 				return(&pCmd_t->ret_value);

  00ba2	8b 44 24 54	 mov	 eax, DWORD PTR _pCmd_t$[esp+224]
  00ba6	83 c4 04	 add	 esp, 4
  00ba9	05 74 57 00 00	 add	 eax, 22388		; 00005774H
  00bae	5f		 pop	 edi
  00baf	5e		 pop	 esi
  00bb0	5d		 pop	 ebp
  00bb1	5b		 pop	 ebx

; 1654 : }                       

  00bb2	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00bb8	c3		 ret	 0
$L71655:

; 1312 : 			{
; 1313 : 				cm_util_flush_init(phTTS);

  00bb9	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR _phTTS$[esp+216]
  00bc0	51		 push	 ecx
  00bc1	e8 00 00 00 00	 call	 _cm_util_flush_init

; 1314 : 				return(&pCmd_t->ret_value);

  00bc6	8b 54 24 54	 mov	 edx, DWORD PTR _pCmd_t$[esp+224]
  00bca	83 c4 04	 add	 esp, 4
  00bcd	5f		 pop	 edi
  00bce	5e		 pop	 esi
  00bcf	5d		 pop	 ebp
  00bd0	8d 82 74 57 00
	00		 lea	 eax, DWORD PTR [edx+22388]
  00bd6	5b		 pop	 ebx

; 1654 : }                       

  00bd7	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00bdd	c3		 ret	 0
$L71604:

; 1080 : 			{
; 1081 : 				cm_util_flush_init(phTTS);

  00bde	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR _phTTS$[esp+216]
  00be5	50		 push	 eax
  00be6	e8 00 00 00 00	 call	 _cm_util_flush_init

; 1082 : 				return(&pCmd_t->ret_value);

  00beb	8b 4c 24 54	 mov	 ecx, DWORD PTR _pCmd_t$[esp+224]
  00bef	83 c4 04	 add	 esp, 4
  00bf2	5f		 pop	 edi
  00bf3	5e		 pop	 esi
  00bf4	5d		 pop	 ebp
  00bf5	8d 81 74 57 00
	00		 lea	 eax, DWORD PTR [ecx+22388]
  00bfb	5b		 pop	 ebx

; 1654 : }                       

  00bfc	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00c02	c3		 ret	 0
$L71592:

; 1646 : 	output_array[new_ret.output_pos+new_ret.output_offset]='\0';

  00c03	8b 4c 24 30	 mov	 ecx, DWORD PTR _new_ret$[esp+228]
  00c07	8b 44 24 34	 mov	 eax, DWORD PTR _new_ret$[esp+232]
  00c0b	03 c1		 add	 eax, ecx
  00c0d	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR _output_array$[esp+216]
  00c14	5f		 pop	 edi
  00c15	5e		 pop	 esi
  00c16	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1647 : 	
; 1648 : 	ret_value->input_offset=new_ret.input_offset-new_input_diff;	 /* the offsets are the change from the current pos */

  00c1a	8b 44 24 24	 mov	 eax, DWORD PTR _new_ret$[esp+216]

; 1649 : 	ret_value->output_offset=new_ret.output_offset; /* so add the values to the callers offsets */

  00c1e	8b 4c 24 2c	 mov	 ecx, DWORD PTR _new_ret$[esp+224]
  00c22	2b c2		 sub	 eax, edx
  00c24	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00c27	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx

; 1650 : #ifdef DEBUG
; 1651 : 	printf("leaving par_process_input\n");
; 1652 : #endif
; 1653 : 	return(ret_value);

  00c2a	8b c3		 mov	 eax, ebx
  00c2c	5d		 pop	 ebp
  00c2d	5b		 pop	 ebx

; 1654 : }                       

  00c2e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00c34	c3		 ret	 0
_par_process_input ENDP
_TEXT	ENDS
PUBLIC	_par_print_rule_error
PUBLIC	_par_copy_string_data
PUBLIC	_par_match_string
_DATA	SEGMENT
	ORG $+2
$SG71836 DB	'par_match_rule;end of state slash not found', 00H
_DATA	ENDS
_TEXT	SEGMENT
_current_rule$ = 8
_state$ = 12
_input_array$ = 16
_output_array$ = 20
_input_indexes$ = 24
_output_indexes$ = 28
_match_array$ = 32
_ret_value$ = 36
_dict_state_flag$ = 40
_new_ret$ = -32
_save_state_num$ = -60
_range_value$ = -48
_in_rule_index$ = 36
_length_of_input$ = -56
_insert_operation_flags$ = -52
_end_of_match$ = -64
_par_match_rule PROC NEAR

; 1930 : {

  00c40	83 ec 40	 sub	 esp, 64			; 00000040H
  00c43	53		 push	 ebx

; 1931 : 	
; 1932 : 	//	int end_marker=End_Is_Slash;			/* used to store the end of state marker for comparison */
; 1933 : 	return_value_t	new_ret;				/* the return_value data */
; 1934 : 	int new_operation=BIN_END_OF_RULE;		/* the current_operation */
; 1935 : 	int num_chars_matched=0; 				/* the number of characters matched by par_match_string */
; 1936 : 	int save_state_num=0;					/* the number of the array to save the matching result into or
; 1937 : 											 * the dictionary number */
; 1938 : 	range_value_t range_value = {0,0,0,0};	/* 
; 1939 : 											*	a structure to store the minimum and maximum values of 
; 1940 : 											* 	a digit range find 
; 1941 : 											*/
; 1942 : 	U8 *new_rule;
; 1943 : 	int in_rule_index;
; 1944 : 	int next_rule_number,rule_p;
; 1945 : 	//int length=0;
; 1946 : 	int length_of_input;
; 1947 : 	int temp;
; 1948 : #ifdef GERMAN_COMPOUND_NOUNS
; 1949 : 	int insert_operation_flags=0;
; 1950 : #endif
; 1951 : 	U8 end_of_match=0;
; 1952 : //	U8 end_of_action;
; 1953 : //	U8 end_of_hit;
; 1954 : 											
; 1955 : #ifdef DEBUG
; 1956 : 	printf("entering par_match_rule state=%d\n",state);
; 1957 : #endif
; 1958 : #ifdef SANITY_CHECKING
; 1959 : 	/* check the inputs or bail out at this point */                                      
; 1960 : 	if (ret_value==NULL) /* there was no input structure,  bail and return NULL */
; 1961 : 	{
; 1962 : #ifdef DEBUG
; 1963 : 		printf("leaving par_match_rule ret_value is NULL\n");
; 1964 : #endif
; 1965 : 		return;
; 1966 : 	}	
; 1967 : 	if (current_rule==NULL || input_array==NULL || output_array==NULL || match_array==NULL)
; 1968 : 	{	/* return a failed value */
; 1969 : 		ret_value->value=FATAL_FAIL;
; 1970 : #ifdef DEBUG
; 1971 : 		printf("leaving par_match_rule some input is NULL returning FAIL\n");
; 1972 : #endif
; 1973 : 		return;
; 1974 : 	}
; 1975 : #endif
; 1976 : 	length_of_input=strlen(input_array);

  00c44	8b 5c 24 50	 mov	 ebx, DWORD PTR _input_array$[esp+64]
  00c48	55		 push	 ebp
  00c49	56		 push	 esi
  00c4a	57		 push	 edi
  00c4b	8b fb		 mov	 edi, ebx
  00c4d	83 c9 ff	 or	 ecx, -1
  00c50	33 c0		 xor	 eax, eax
  00c52	33 ed		 xor	 ebp, ebp

; 1977 : 
; 1978 : 	/* update the state information and pointer to ret_value for par_look_ahead */                   
; 1979 : 	new_ret.input_pos=ret_value->input_pos+ret_value->input_offset;	

  00c54	8b 74 24 70	 mov	 esi, DWORD PTR _ret_value$[esp+76]
  00c58	f2 ae		 repne scasb
  00c5a	8b 06		 mov	 eax, DWORD PTR [esi]

; 1980 : 	new_ret.input_offset=0;
; 1981 : 	new_ret.output_pos=ret_value->output_pos+ret_value->output_offset;

  00c5c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00c5f	f7 d1		 not	 ecx
  00c61	49		 dec	 ecx

; 1982 : 	new_ret.output_offset=0;
; 1983 : 	new_ret.value=SUCCESS;
; 1984 : 	/* GL 02/08/1997 set the initial parser_flag */
; 1985 : 	new_ret.parser_flag = ret_value->parser_flag;   
; 1986 : #ifdef NEW_PARSER_FILE_LOADING
; 1987 : 	new_ret.phTTS=ret_value->phTTS;
; 1988 : #endif
; 1989 : 
; 1990 : 	/* 
; 1991 : 	*	NULL_STATE is used for the first call to the par_match_rule function to 
; 1992 : 	*	tell it to go into COPY_STATE and that the end of state marker is a NULL 
; 1993 : 	*/
; 1994 : 	new_ret.rule=in_rule_index=ret_value->rule;
; 1995 : 	if (state==BIN_END_OF_RULE) 	

  00c62	8b 7c 24 58	 mov	 edi, DWORD PTR _state$[esp+76]
  00c66	89 4c 24 18	 mov	 DWORD PTR _length_of_input$[esp+80], ecx
  00c6a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00c6d	03 c1		 add	 eax, ecx
  00c6f	b9 01 00 00 00	 mov	 ecx, 1
  00c74	89 44 24 30	 mov	 DWORD PTR _new_ret$[esp+80], eax
  00c78	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00c7b	03 d0		 add	 edx, eax
  00c7d	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00c80	89 44 24 4c	 mov	 DWORD PTR _new_ret$[esp+108], eax
  00c84	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00c87	85 ff		 test	 edi, edi
  00c89	89 6c 24 14	 mov	 DWORD PTR _save_state_num$[esp+80], ebp
  00c8d	89 6c 24 20	 mov	 DWORD PTR _range_value$[esp+80], ebp
  00c91	89 6c 24 24	 mov	 DWORD PTR _range_value$[esp+84], ebp
  00c95	89 6c 24 28	 mov	 DWORD PTR _range_value$[esp+88], ebp
  00c99	89 6c 24 2c	 mov	 DWORD PTR _range_value$[esp+92], ebp
  00c9d	89 6c 24 1c	 mov	 DWORD PTR _insert_operation_flags$[esp+80], ebp
  00ca1	c6 44 24 10 00	 mov	 BYTE PTR _end_of_match$[esp+80], 0
  00ca6	89 6c 24 34	 mov	 DWORD PTR _new_ret$[esp+84], ebp
  00caa	89 54 24 38	 mov	 DWORD PTR _new_ret$[esp+88], edx
  00cae	89 6c 24 3c	 mov	 DWORD PTR _new_ret$[esp+92], ebp
  00cb2	89 4c 24 44	 mov	 DWORD PTR _new_ret$[esp+100], ecx
  00cb6	89 44 24 70	 mov	 DWORD PTR _in_rule_index$[esp+76], eax
  00cba	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
  00cbe	75 31		 jne	 SHORT $L71787

; 1996 : 	{
; 1997 : 		//		state=BIN_COPY;
; 1998 : 		end_of_match=255;

  00cc0	c6 44 24 10 ff	 mov	 BYTE PTR _end_of_match$[esp+80], 255 ; 000000ffH
$L71788:

; 2010 : 	{
; 2011 : 		new_ret.optional=ret_value->optional;

  00cc5	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]

; 2012 : 	}
; 2013 : 	/* 
; 2014 : 	* copy the return value data from the input to the temporary location for the
; 2015 : 	* children of this function to use 
; 2016 : 	*/
; 2017 : 	/*
; 2018 : 	*	if this is in save state the array number has to be retrieved here to 
; 2019 : 	*  know which array to place the data into 
; 2020 : 	*/
; 2021 : 	if (state==BIN_SAVE)

  00cc8	83 ff 17	 cmp	 edi, 23			; 00000017H
  00ccb	89 4c 24 48	 mov	 DWORD PTR _new_ret$[esp+104], ecx

; 2022 : 	{
; 2023 : 		/* get the number from the rule to save the result in */
; 2024 : 		new_ret.rule++;	/* skip the operation */
; 2025 : 		save_state_num=current_rule[new_ret.rule];
; 2026 : 	}
; 2027 : 	if (state==BIN_DICTIONARY)

  00ccf	74 05		 je	 SHORT $L73037
  00cd1	83 ff 1d	 cmp	 edi, 29			; 0000001dH
  00cd4	75 29		 jne	 SHORT $L71791
$L73037:

; 2028 : 	{
; 2029 : 		new_ret.rule++;

  00cd6	8b 44 24 70	 mov	 eax, DWORD PTR _in_rule_index$[esp+76]

; 2030 : 		save_state_num=current_rule[new_ret.rule];

  00cda	8b 7c 24 54	 mov	 edi, DWORD PTR _current_rule$[esp+76]
  00cde	40		 inc	 eax
  00cdf	33 c9		 xor	 ecx, ecx
  00ce1	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
  00ce5	8a 0c 38	 mov	 cl, BYTE PTR [eax+edi]
  00ce8	89 4c 24 14	 mov	 DWORD PTR _save_state_num$[esp+80], ecx

; 2031 : 	}
; 2032 : #ifdef GERMAN_COMPOUND_NOUNS
; 2033 : 	if (state==BIN_INSERT)

  00cec	e9 2d 01 00 00	 jmp	 $L73016
$L71787:

; 1999 : 	}
; 2000 : 
; 2001 : 	/* set the optional flag if the state is optional */
; 2002 : 	if (state==BIN_OPTIONAL)

  00cf1	83 ff 16	 cmp	 edi, 22			; 00000016H
  00cf4	75 cf		 jne	 SHORT $L71788

; 2003 : 	{                                         
; 2004 : #ifdef DEBUG
; 2005 : 		printf("set optional to 1\n");
; 2006 : #endif
; 2007 : 		new_ret.optional=1;

  00cf6	89 4c 24 48	 mov	 DWORD PTR _new_ret$[esp+104], ecx

; 2008 : 	}     
; 2009 : 	else

  00cfa	e9 1f 01 00 00	 jmp	 $L73016
$L71791:

; 2031 : 	}
; 2032 : #ifdef GERMAN_COMPOUND_NOUNS
; 2033 : 	if (state==BIN_INSERT)

  00cff	83 ff 1a	 cmp	 edi, 26			; 0000001aH
  00d02	75 1a		 jne	 SHORT $L71792

; 2034 : 	{
; 2035 : 		insert_operation_flags=current_rule[new_ret.rule];

  00d04	8b 7c 24 70	 mov	 edi, DWORD PTR _in_rule_index$[esp+76]
  00d08	8b 5c 24 54	 mov	 ebx, DWORD PTR _current_rule$[esp+76]
  00d0c	33 c9		 xor	 ecx, ecx
  00d0e	8a 0c 1f	 mov	 cl, BYTE PTR [edi+ebx]

; 2036 : 	}
; 2037 : #endif
; 2038 : 	if (state==BIN_MACRO)

  00d11	8b 5c 24 5c	 mov	 ebx, DWORD PTR _input_array$[esp+76]
  00d15	89 4c 24 1c	 mov	 DWORD PTR _insert_operation_flags$[esp+80], ecx
  00d19	e9 00 01 00 00	 jmp	 $L73016
$L71792:
  00d1e	83 ff 18	 cmp	 edi, 24			; 00000018H
  00d21	0f 85 f2 00 00
	00		 jne	 $L71793

; 2039 : 	{
; 2040 : 		rule_p=new_ret.rule;
; 2041 : 		rule_p++; /* skip state identifier */

  00d27	8b 54 24 70	 mov	 edx, DWORD PTR _in_rule_index$[esp+76]

; 2042 : 		next_rule_number=get_short(&current_rule[rule_p]);

  00d2b	8b 44 24 54	 mov	 eax, DWORD PTR _current_rule$[esp+76]
  00d2f	33 c9		 xor	 ecx, ecx
  00d31	8a 6c 10 02	 mov	 ch, BYTE PTR [eax+edx+2]
  00d35	8d 6a 01	 lea	 ebp, DWORD PTR [edx+1]
  00d38	8a 0c 28	 mov	 cl, BYTE PTR [eax+ebp]

; 2043 : 		rule_p+=2;

  00d3b	83 c5 02	 add	 ebp, 2
  00d3e	8b c1		 mov	 eax, ecx

; 2044 : 		
; 2045 : 		new_rule=(&(rule_data_table[rule_index_table[next_rule_number]]));
; 2046 : 		new_ret.rule=0;

  00d40	33 c9		 xor	 ecx, ecx
  00d42	89 4c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ecx
  00d46	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _rule_index_table[eax*4]
  00d4d	05 00 00 00 00	 add	 eax, OFFSET FLAT:_rule_data_table

; 2047 : 		if (new_rule[0] & BIN_NEXT_HIT)	 new_ret.rule+=2;

  00d52	84 08		 test	 BYTE PTR [eax], cl
  00d54	74 3c		 je	 SHORT $L71801
  00d56	b9 02 00 00 00	 mov	 ecx, 2
  00d5b	89 4c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ecx

; 2048 : 		if (new_rule[0] & BIN_NEXT_MISS)  new_ret.rule+=2;

  00d5f	8a 10		 mov	 dl, BYTE PTR [eax]
  00d61	f6 c2 00	 test	 dl, 0
  00d64	74 2c		 je	 SHORT $L71801
  00d66	03 c9		 add	 ecx, ecx
  00d68	89 4c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ecx

; 2049 : 		if (new_rule[0] & BIN_GORET_HIT)  new_ret.rule+=2;

  00d6c	8a 10		 mov	 dl, BYTE PTR [eax]
  00d6e	f6 c2 00	 test	 dl, 0
  00d71	74 1f		 je	 SHORT $L71801
  00d73	83 c1 02	 add	 ecx, 2
  00d76	89 4c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ecx

; 2050 : 		if (new_rule[0] & BIN_GORET_MISS) new_ret.rule+=2;

  00d7a	8a 10		 mov	 dl, BYTE PTR [eax]
  00d7c	f6 c2 00	 test	 dl, 0
  00d7f	74 11		 je	 SHORT $L71801
  00d81	83 c1 02	 add	 ecx, 2
  00d84	89 4c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ecx

; 2051 : 		if (new_rule[0] & BIN_COPY_HIT) new_ret.rule+=2;

  00d88	8a 10		 mov	 dl, BYTE PTR [eax]
  00d8a	f6 c2 00	 test	 dl, 0
  00d8d	74 03		 je	 SHORT $L71801
  00d8f	83 c1 02	 add	 ecx, 2
$L71801:

; 2052 : 		new_ret.rule+=12;

  00d92	83 c1 0c	 add	 ecx, 12			; 0000000cH

; 2053 : 		
; 2054 : 		par_match_rule(new_rule,BIN_END_OF_RULE,input_array,output_array,input_indexes,output_indexes,match_array,&new_ret,0);

  00d95	8d 54 24 30	 lea	 edx, DWORD PTR _new_ret$[esp+80]
  00d99	89 4c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ecx
  00d9d	8b 4c 24 6c	 mov	 ecx, DWORD PTR _match_array$[esp+76]
  00da1	6a 00		 push	 0
  00da3	52		 push	 edx
  00da4	8b 54 24 70	 mov	 edx, DWORD PTR _output_indexes$[esp+84]
  00da8	51		 push	 ecx
  00da9	8b 4c 24 70	 mov	 ecx, DWORD PTR _input_indexes$[esp+88]
  00dad	52		 push	 edx
  00dae	8b 54 24 70	 mov	 edx, DWORD PTR _output_array$[esp+92]
  00db2	51		 push	 ecx
  00db3	52		 push	 edx
  00db4	53		 push	 ebx
  00db5	6a 00		 push	 0
  00db7	50		 push	 eax
  00db8	e8 00 00 00 00	 call	 _par_match_rule

; 2055 : 		/* fixed macro state */
; 2056 : 		new_ret.rule=rule_p;
; 2057 : 		if ((new_ret.input_pos+new_ret.input_offset > length_of_input)) 

  00dbd	8b 4c 24 54	 mov	 ecx, DWORD PTR _new_ret$[esp+116]
  00dc1	8b 54 24 58	 mov	 edx, DWORD PTR _new_ret$[esp+120]
  00dc5	03 d1		 add	 edx, ecx
  00dc7	8b 4c 24 3c	 mov	 ecx, DWORD PTR _length_of_input$[esp+116]
  00dcb	83 c4 24	 add	 esp, 36			; 00000024H
  00dce	8b c5		 mov	 eax, ebp
  00dd0	3b d1		 cmp	 edx, ecx
  00dd2	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
  00dd6	7e 1a		 jle	 SHORT $L71804

; 2058 : 		{
; 2059 : 			if (new_ret.optional==1)

  00dd8	83 7c 24 48 01	 cmp	 DWORD PTR _new_ret$[esp+104], 1
  00ddd	0f 85 5a 02 00
	00		 jne	 $L71803

; 2060 : 			{
; 2061 : //				new_ret.optional= -1;
; 2062 : 				ret_value->value=OPT_FAIL;

  00de3	c7 46 14 02 00
	00 00		 mov	 DWORD PTR [esi+20], 2
  00dea	5f		 pop	 edi
  00deb	5e		 pop	 esi
  00dec	5d		 pop	 ebp
  00ded	5b		 pop	 ebx

; 2327 : #ifdef DEBUG
; 2328 : 	printf("leaving par_match_rule success\n");
; 2329 : #endif
; 2330 : }

  00dee	83 c4 40	 add	 esp, 64			; 00000040H
  00df1	c3		 ret	 0
$L71804:

; 2063 : //				ret_value->rule=rule_p;
; 2064 : 				return;
; 2065 : 			}
; 2066 : 			else
; 2067 : 			{
; 2068 : //				new_ret.value=END_OF_STRING;
; 2069 : 				ret_value->value=END_OF_STRING;
; 2070 : 				return;
; 2071 : 			}
; 2072 : 		}
; 2073 : 		if ((new_ret.value==FAIL) && (new_ret.optional))

  00df2	8b 4c 24 44	 mov	 ecx, DWORD PTR _new_ret$[esp+100]
  00df6	85 c9		 test	 ecx, ecx
  00df8	0f 85 0a 02 00
	00		 jne	 $L73021
  00dfe	8b 44 24 48	 mov	 eax, DWORD PTR _new_ret$[esp+104]
  00e02	85 c0		 test	 eax, eax
  00e04	0f 84 c7 01 00
	00		 je	 $L73020

; 2074 : 		{
; 2075 : //			new_ret.optional= -1;
; 2076 : 			ret_value->value=OPT_FAIL;

  00e0a	c7 46 14 02 00
	00 00		 mov	 DWORD PTR [esi+20], 2
  00e11	5f		 pop	 edi
  00e12	5e		 pop	 esi
  00e13	5d		 pop	 ebp
  00e14	5b		 pop	 ebx

; 2327 : #ifdef DEBUG
; 2328 : 	printf("leaving par_match_rule success\n");
; 2329 : #endif
; 2330 : }

  00e15	83 c4 40	 add	 esp, 64			; 00000040H
  00e18	c3		 ret	 0
$L71793:

; 2077 : //			ret_value->rule=new_ret.rule;
; 2078 : 			return;
; 2079 : 		}                                                                 
; 2080 : 	}
; 2081 : 	else
; 2082 : 	{
; 2083 : 		/* extract the state data */
; 2084 : 		if (state>=BIN_COPY)

  00e19	83 ff 14	 cmp	 edi, 20			; 00000014H
  00e1c	7c 59		 jl	 SHORT $L73011
$L73016:

; 2085 : 		{
; 2086 : 			new_ret.rule++;	/* skip the operation */
; 2087 : 			end_of_match=current_rule[new_ret.rule];

  00e1e	8b 4c 24 54	 mov	 ecx, DWORD PTR _current_rule$[esp+76]
  00e22	40		 inc	 eax
  00e23	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
  00e27	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]

; 2088 : 			new_ret.rule++;

  00e2a	40		 inc	 eax
  00e2b	88 4c 24 10	 mov	 BYTE PTR _end_of_match$[esp+80], cl

; 2089 : #ifndef GERMAN_COMPOUND_NOUNS
; 2090 : 			if (state>=BIN_REPLACE && state <=BIN_BEFORE)
; 2091 : #else
; 2092 : 			if (state>=BIN_REPLACE && state <=BIN_INSERT)

  00e2f	8b 4c 24 58	 mov	 ecx, DWORD PTR _state$[esp+76]
  00e33	83 f9 19	 cmp	 ecx, 25			; 00000019H
  00e36	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
  00e3a	7c 23		 jl	 SHORT $L71808
  00e3c	83 f9 1a	 cmp	 ecx, 26			; 0000001aH
  00e3f	7f 1e		 jg	 SHORT $L71808

; 2093 : #endif
; 2094 : 			{
; 2095 : 				new_ret.rule++;
; 2096 : 				if (current_rule[in_rule_index] & BIN_CONDITIONAL_REPLACE)

  00e41	8b 4c 24 70	 mov	 ecx, DWORD PTR _in_rule_index$[esp+76]
  00e45	8b 7c 24 54	 mov	 edi, DWORD PTR _current_rule$[esp+76]
  00e49	40		 inc	 eax
  00e4a	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
  00e4e	f6 04 39 80	 test	 BYTE PTR [ecx+edi], 128	; 00000080H
  00e52	74 1f		 je	 SHORT $L73024

; 2097 : 				{
; 2098 : 					new_ret.rule+=current_rule[new_ret.rule];
; 2099 : 					new_ret.rule++; /* add 1 for the conditional number */

  00e54	33 c9		 xor	 ecx, ecx
  00e56	8a 0c 38	 mov	 cl, BYTE PTR [eax+edi]
  00e59	8d 44 08 01	 lea	 eax, DWORD PTR [eax+ecx+1]

; 2100 : 				}
; 2101 : 			}
; 2102 : 			else

  00e5d	eb 10		 jmp	 SHORT $L73038
$L71808:

; 2103 : 			{
; 2104 : 				if (state==BIN_DICTIONARY)

  00e5f	83 f9 1d	 cmp	 ecx, 29			; 0000001dH
  00e62	75 05		 jne	 SHORT $L71811

; 2105 : 				{
; 2106 : 					new_ret.rule+=2;

  00e64	83 c0 02	 add	 eax, 2

; 2107 : 				}
; 2108 : 				else

  00e67	eb 06		 jmp	 SHORT $L73038
$L71811:

; 2109 : 				{
; 2110 : 					if (state==BIN_STATUS)

  00e69	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  00e6c	75 05		 jne	 SHORT $L73024

; 2111 : 					{
; 2112 : 						new_ret.rule++;

  00e6e	40		 inc	 eax
$L73038:
  00e6f	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
$L73024:

; 2100 : 				}
; 2101 : 			}
; 2102 : 			else

  00e73	8b 7c 24 58	 mov	 edi, DWORD PTR _state$[esp+76]
$L73011:

; 2113 : 					}
; 2114 : 				}
; 2115 : 			}
; 2116 : 		}
; 2117 : 		
; 2118 : 		/* 
; 2119 : 		* decide whether the string in the position being processed is another rule 
; 2120 : 		* or if it is a character type or string to be matched.
; 2121 : 		*/
; 2122 : #if 0
; 2123 : 		while ((current_rule[new_ret.rule]!=0) && (new_ret.rule <= end_of_match) && (new_ret.optional!=-1) &&
; 2124 : 			(new_ret.value!=FATAL_FAIL) && (new_ret.value!=FAIL) && (new_ret.value!=END_OF_STRING)) /* && */
; 2125 : #endif
; 2126 : 
; 2127 : 		
; 2128 : 		while ((new_ret.rule <= end_of_match) && ((temp=current_rule[new_ret.rule])!=0) &&  (new_ret.value==SUCCESS))

  00e77	8b 4c 24 10	 mov	 ecx, DWORD PTR _end_of_match$[esp+80]
  00e7b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00e81	3b c1		 cmp	 eax, ecx
  00e83	89 4c 24 5c	 mov	 DWORD PTR 16+[esp+76], ecx
  00e87	0f 8f ca 01 00
	00		 jg	 $L73030
$L71815:
  00e8d	8b 7c 24 54	 mov	 edi, DWORD PTR _current_rule$[esp+76]
  00e91	33 c9		 xor	 ecx, ecx
  00e93	8a 0c 38	 mov	 cl, BYTE PTR [eax+edi]
  00e96	85 c9		 test	 ecx, ecx
  00e98	0f 84 f9 00 00
	00		 je	 $L71816
  00e9e	83 7c 24 44 01	 cmp	 DWORD PTR _new_ret$[esp+100], 1
  00ea3	0f 85 ee 00 00
	00		 jne	 $L71816

; 2129 : 			/*(new_ret.input_pos+new_ret.input_offset < (int)strlen(input_array))*/ 	/* slow ?? */
; 2130 : 			/* process all the data in this action state that is before the ending slash */
; 2131 : 		{
; 2132 : 			new_operation=temp & BIN_OPERATION_MASK;

  00ea9	83 e1 1f	 and	 ecx, 31			; 0000001fH

; 2133 : 			if ((new_operation <= BIN_SETS))
; 2134 : 			{
; 2135 : 				num_chars_matched=par_match_string(current_rule,new_operation,input_array,match_array,&new_ret,&range_value,1,0);

  00eac	6a 00		 push	 0
  00eae	8b c1		 mov	 eax, ecx
  00eb0	83 f8 13	 cmp	 eax, 19			; 00000013H
  00eb3	7f 74		 jg	 SHORT $L71817
  00eb5	8d 54 24 24	 lea	 edx, DWORD PTR _range_value$[esp+84]
  00eb9	6a 01		 push	 1
  00ebb	52		 push	 edx
  00ebc	8b 54 24 78	 mov	 edx, DWORD PTR _match_array$[esp+88]
  00ec0	8d 4c 24 3c	 lea	 ecx, DWORD PTR _new_ret$[esp+92]
  00ec4	51		 push	 ecx
  00ec5	52		 push	 edx
  00ec6	53		 push	 ebx
  00ec7	50		 push	 eax
  00ec8	8b 44 24 70	 mov	 eax, DWORD PTR _current_rule$[esp+104]
  00ecc	50		 push	 eax
  00ecd	e8 00 00 00 00	 call	 _par_match_string
  00ed2	8b f8		 mov	 edi, eax
  00ed4	83 c4 20	 add	 esp, 32			; 00000020H

; 2136 : 				
; 2137 : 				/* copy matched data to the output string */
; 2138 : 				if (num_chars_matched== -1)

  00ed7	83 ff ff	 cmp	 edi, -1
  00eda	0f 84 c1 00 00
	00		 je	 $L73012

; 2151 : 						return;
; 2152 : 					}
; 2153 : 				}
; 2154 : 				if (num_chars_matched== 0 && new_ret.optional)

  00ee0	85 ff		 test	 edi, edi
  00ee2	75 0c		 jne	 SHORT $L71821
  00ee4	8b 44 24 48	 mov	 eax, DWORD PTR _new_ret$[esp+104]
  00ee8	85 c0		 test	 eax, eax
  00eea	0f 85 67 02 00
	00		 jne	 $L73022
$L71821:

; 2155 : 				{
; 2156 : 					new_ret.value=OPT_FAIL;
; 2157 : 					break;
; 2158 : 				}
; 2159 : #ifdef DEBUG
; 2160 : 				par_print_rule_error("after par_match_string",current_rule,new_ret.rule);
; 2161 : #endif
; 2162 : 				par_copy_string_data(input_array,input_indexes,output_array,output_indexes,num_chars_matched,&new_ret);

  00ef0	8b 54 24 68	 mov	 edx, DWORD PTR _output_indexes$[esp+76]
  00ef4	8b 44 24 60	 mov	 eax, DWORD PTR _output_array$[esp+76]
  00ef8	8d 4c 24 30	 lea	 ecx, DWORD PTR _new_ret$[esp+80]
  00efc	51		 push	 ecx
  00efd	8b 4c 24 68	 mov	 ecx, DWORD PTR _input_indexes$[esp+80]
  00f01	57		 push	 edi
  00f02	52		 push	 edx
  00f03	50		 push	 eax
  00f04	51		 push	 ecx
  00f05	53		 push	 ebx
  00f06	e8 00 00 00 00	 call	 _par_copy_string_data

; 2163 : 				/* update new_ret output_offset */
; 2164 : 				new_ret.output_offset+=num_chars_matched;

  00f0b	8b 6c 24 54	 mov	 ebp, DWORD PTR _new_ret$[esp+116]

; 2165 : 				new_ret.input_offset+=num_chars_matched; 

  00f0f	8b 44 24 4c	 mov	 eax, DWORD PTR _new_ret$[esp+108]
  00f13	83 c4 18	 add	 esp, 24			; 00000018H
  00f16	03 ef		 add	 ebp, edi
  00f18	03 c7		 add	 eax, edi
  00f1a	89 6c 24 3c	 mov	 DWORD PTR _new_ret$[esp+92], ebp
  00f1e	89 44 24 34	 mov	 DWORD PTR _new_ret$[esp+84], eax

; 2166 : 			}
; 2167 : 			else

  00f22	b8 03 00 00 00	 mov	 eax, 3
  00f27	eb 39		 jmp	 SHORT $L71825
$L71817:

; 2168 : 			{
; 2169 : 					/* recursively call the par_match_rule function with the new action state */
; 2170 : 				par_match_rule(current_rule,new_operation,input_array,output_array,input_indexes,output_indexes,match_array,&new_ret,0);

  00f29	8b 4c 24 70	 mov	 ecx, DWORD PTR _match_array$[esp+80]
  00f2d	8d 54 24 34	 lea	 edx, DWORD PTR _new_ret$[esp+84]
  00f31	52		 push	 edx
  00f32	8b 54 24 70	 mov	 edx, DWORD PTR _output_indexes$[esp+84]
  00f36	51		 push	 ecx
  00f37	8b 4c 24 70	 mov	 ecx, DWORD PTR _input_indexes$[esp+88]
  00f3b	52		 push	 edx
  00f3c	8b 54 24 70	 mov	 edx, DWORD PTR _output_array$[esp+92]
  00f40	51		 push	 ecx
  00f41	52		 push	 edx
  00f42	53		 push	 ebx
  00f43	50		 push	 eax
  00f44	8b 44 24 74	 mov	 eax, DWORD PTR _current_rule$[esp+108]
  00f48	50		 push	 eax
  00f49	e8 00 00 00 00	 call	 _par_match_rule

; 2171 : 				
; 2172 : #ifdef DEBUG
; 2173 : 				par_print_rule_error("after par_match_rule",current_rule,new_ret.rule);
; 2174 : #endif
; 2175 : 				if (new_ret.value==END_OF_STRING)

  00f4e	8b 4c 24 68	 mov	 ecx, DWORD PTR _new_ret$[esp+136]
  00f52	b8 03 00 00 00	 mov	 eax, 3
  00f57	83 c4 24	 add	 esp, 36			; 00000024H
  00f5a	3b c8		 cmp	 ecx, eax
  00f5c	74 5d		 je	 SHORT $L73014
  00f5e	8b 6c 24 3c	 mov	 ebp, DWORD PTR _new_ret$[esp+92]
$L71825:

; 2188 : 						return;
; 2189 : 					}
; 2190 : 				}
; 2191 : 				/* the matched expression should already be in the output buffer */
; 2192 : 			}                              
; 2193 : 			/* processing continues here after a call to either par_match_string() or to par_match_rule() */
; 2194 : 			if ((new_ret.input_pos+new_ret.input_offset > length_of_input)) 

  00f62	8b 4c 24 30	 mov	 ecx, DWORD PTR _new_ret$[esp+80]
  00f66	8b 54 24 34	 mov	 edx, DWORD PTR _new_ret$[esp+84]
  00f6a	03 d1		 add	 edx, ecx
  00f6c	8b 4c 24 18	 mov	 ecx, DWORD PTR _length_of_input$[esp+80]
  00f70	3b d1		 cmp	 edx, ecx
  00f72	7e 0f		 jle	 SHORT $L71828

; 2195 : 			{
; 2196 : 				if (new_ret.optional==1)

  00f74	83 7c 24 48 01	 cmp	 DWORD PTR _new_ret$[esp+104], 1
  00f79	0f 84 dc 01 00
	00		 je	 $L73023

; 2197 : 				{
; 2198 : 					new_ret.value=OPT_FAIL;
; 2199 : 					break;
; 2200 : 				}
; 2201 : 				else
; 2202 : 				{
; 2203 : 					new_ret.value=END_OF_STRING;

  00f7f	89 44 24 44	 mov	 DWORD PTR _new_ret$[esp+100], eax
$L71828:

; 2113 : 					}
; 2114 : 				}
; 2115 : 			}
; 2116 : 		}
; 2117 : 		
; 2118 : 		/* 
; 2119 : 		* decide whether the string in the position being processed is another rule 
; 2120 : 		* or if it is a character type or string to be matched.
; 2121 : 		*/
; 2122 : #if 0
; 2123 : 		while ((current_rule[new_ret.rule]!=0) && (new_ret.rule <= end_of_match) && (new_ret.optional!=-1) &&
; 2124 : 			(new_ret.value!=FATAL_FAIL) && (new_ret.value!=FAIL) && (new_ret.value!=END_OF_STRING)) /* && */
; 2125 : #endif
; 2126 : 
; 2127 : 		
; 2128 : 		while ((new_ret.rule <= end_of_match) && ((temp=current_rule[new_ret.rule])!=0) &&  (new_ret.value==SUCCESS))

  00f83	8b 44 24 40	 mov	 eax, DWORD PTR _new_ret$[esp+96]
  00f87	8b 4c 24 5c	 mov	 ecx, DWORD PTR 16+[esp+76]

; 2195 : 			{
; 2196 : 				if (new_ret.optional==1)

  00f8b	8b 54 24 38	 mov	 edx, DWORD PTR _new_ret$[esp+88]
  00f8f	3b c1		 cmp	 eax, ecx
  00f91	0f 8e f6 fe ff
	ff		 jle	 $L71815
$L71816:

; 2204 : 				}
; 2205 : 			}
; 2206 : 		}
; 2207 : 	}
; 2208 : 	/* the end of state slash marker was found or there was a failure in the matching */
; 2209 : 	if (new_ret.value==FAIL)

  00f97	8b 4c 24 44	 mov	 ecx, DWORD PTR _new_ret$[esp+100]
  00f9b	85 c9		 test	 ecx, ecx
  00f9d	75 73		 jne	 SHORT $L73029
  00f9f	eb 38		 jmp	 SHORT $L73017
$L73012:

; 2139 : 				{
; 2140 : #ifdef DEBUG
; 2141 : 					printf("leaving par_match_rule; end of string reached in string\n");
; 2142 : #endif
; 2143 : 					if (new_ret.optional==1)

  00fa1	83 7c 24 48 01	 cmp	 DWORD PTR _new_ret$[esp+104], 1

; 2144 : 					{
; 2145 : 						new_ret.value=OPT_FAIL;
; 2146 : 						break;

  00fa6	0f 84 ab 01 00
	00		 je	 $L73022

; 2147 : 					}
; 2148 : 					else
; 2149 : 					{
; 2150 : 						ret_value->value=END_OF_STRING;                         

  00fac	c7 46 14 03 00
	00 00		 mov	 DWORD PTR [esi+20], 3
  00fb3	5f		 pop	 edi
  00fb4	5e		 pop	 esi
  00fb5	5d		 pop	 ebp
  00fb6	5b		 pop	 ebx

; 2327 : #ifdef DEBUG
; 2328 : 	printf("leaving par_match_rule success\n");
; 2329 : #endif
; 2330 : }

  00fb7	83 c4 40	 add	 esp, 64			; 00000040H
  00fba	c3		 ret	 0
$L73014:

; 2176 : 				{
; 2177 : #ifdef DEBUG
; 2178 : 					printf("leaving par_match_rule; end of string reached in rule\n");
; 2179 : #endif
; 2180 : 					if (new_ret.optional==1)

  00fbb	83 7c 24 48 01	 cmp	 DWORD PTR _new_ret$[esp+104], 1

; 2181 : 					{
; 2182 : 						new_ret.value=OPT_FAIL;
; 2183 : 						break;

  00fc0	0f 84 91 01 00
	00		 je	 $L73022

; 2184 : 					}
; 2185 : 					else						
; 2186 : 					{
; 2187 : 						ret_value->value=END_OF_STRING;

  00fc6	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00fc9	5f		 pop	 edi
  00fca	5e		 pop	 esi
  00fcb	5d		 pop	 ebp
  00fcc	5b		 pop	 ebx

; 2327 : #ifdef DEBUG
; 2328 : 	printf("leaving par_match_rule success\n");
; 2329 : #endif
; 2330 : }

  00fcd	83 c4 40	 add	 esp, 64			; 00000040H
  00fd0	c3		 ret	 0
$L73020:

; 2204 : 				}
; 2205 : 			}
; 2206 : 		}
; 2207 : 	}
; 2208 : 	/* the end of state slash marker was found or there was a failure in the matching */
; 2209 : 	if (new_ret.value==FAIL)

  00fd1	8b 6c 24 3c	 mov	 ebp, DWORD PTR _new_ret$[esp+92]
  00fd5	8b 54 24 38	 mov	 edx, DWORD PTR _new_ret$[esp+88]
$L73017:

; 2210 : 	{
; 2211 : 	/* on failure of a rule just send back FAIL. the caller will then send FAIL back to its caller
; 2212 : 	* and so on, until the outer loop is reached with FAIL.  The original ret_value array 
; 2213 : 	* should remain unchanged for the following rules to use 
; 2214 : 		*/
; 2215 : 		ret_value->value=FAIL;

  00fd9	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2216 : #ifdef INDEX_DEBUG2
; 2217 : 		printf("cleared indexes from %d to %d in the output, failure\n",new_ret.output_pos,new_ret.output_pos+new_ret.output_offset);
; 2218 : #endif
; 2219 : 		memset(output_indexes+new_ret.output_pos,0,new_ret.output_offset*sizeof(index_data_t));

  00fe0	8b 74 24 68	 mov	 esi, DWORD PTR _output_indexes$[esp+76]
  00fe4	8d 4c 6d 00	 lea	 ecx, DWORD PTR [ebp+ebp*2]
  00fe8	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  00feb	d1 e1		 shl	 ecx, 1
  00fed	8d 3c 56	 lea	 edi, DWORD PTR [esi+edx*2]
  00ff0	8b d1		 mov	 edx, ecx
  00ff2	33 c0		 xor	 eax, eax
  00ff4	c1 e9 02	 shr	 ecx, 2
  00ff7	f3 ab		 rep stosd
  00ff9	8b ca		 mov	 ecx, edx
  00ffb	83 e1 03	 and	 ecx, 3
  00ffe	f3 aa		 rep stosb
  01000	5f		 pop	 edi
  01001	5e		 pop	 esi
  01002	5d		 pop	 ebp
  01003	5b		 pop	 ebx

; 2327 : #ifdef DEBUG
; 2328 : 	printf("leaving par_match_rule success\n");
; 2329 : #endif
; 2330 : }

  01004	83 c4 40	 add	 esp, 64			; 00000040H
  01007	c3		 ret	 0
$L73021:

; 2220 : #ifdef DEBUG
; 2221 : 		printf("leaving par_match_rule failure of the rule\n");
; 2222 : #endif
; 2223 : 		
; 2224 : 		return;

  01008	8b 6c 24 3c	 mov	 ebp, DWORD PTR _new_ret$[esp+92]
  0100c	8b 54 24 38	 mov	 edx, DWORD PTR _new_ret$[esp+88]
  01010	eb 04		 jmp	 SHORT $L71829
$L73029:
  01012	8b 7c 24 58	 mov	 edi, DWORD PTR _state$[esp+76]
$L71829:

; 2225 : 	}
; 2226 : 	if (new_ret.value==END_OF_STRING)

  01016	83 7c 24 44 03	 cmp	 DWORD PTR _new_ret$[esp+100], 3
  0101b	75 2f		 jne	 SHORT $L71831

; 2227 : 	{
; 2228 : 		/* on finding the end of the string, return END_OF_STRING to the caller */
; 2229 : #ifdef INDEX_DEBUG2
; 2230 : 		printf("cleared indexes from %d to %d in the output, end_of_string\n",new_ret.output_pos,new_ret.output_pos+new_ret.output_offset);
; 2231 : #endif
; 2232 : 		memset(output_indexes+new_ret.output_pos,0,new_ret.output_offset*sizeof(index_data_t));

  0101d	8b 7c 24 68	 mov	 edi, DWORD PTR _output_indexes$[esp+76]
  01021	8d 4c 6d 00	 lea	 ecx, DWORD PTR [ebp+ebp*2]
  01025	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  01028	33 c0		 xor	 eax, eax
  0102a	d1 e1		 shl	 ecx, 1
  0102c	8d 3c 57	 lea	 edi, DWORD PTR [edi+edx*2]
  0102f	8b d1		 mov	 edx, ecx
  01031	c1 e9 02	 shr	 ecx, 2
  01034	f3 ab		 rep stosd
  01036	8b ca		 mov	 ecx, edx
  01038	83 e1 03	 and	 ecx, 3
  0103b	f3 aa		 rep stosb
$L71803:

; 2233 : 		ret_value->value=END_OF_STRING;

  0103d	c7 46 14 03 00
	00 00		 mov	 DWORD PTR [esi+20], 3
  01044	5f		 pop	 edi
  01045	5e		 pop	 esi
  01046	5d		 pop	 ebp
  01047	5b		 pop	 ebx

; 2327 : #ifdef DEBUG
; 2328 : 	printf("leaving par_match_rule success\n");
; 2329 : #endif
; 2330 : }

  01048	83 c4 40	 add	 esp, 64			; 00000040H
  0104b	c3		 ret	 0
$L71831:

; 2234 : #ifdef DEBUG
; 2235 : 		printf("leaving par_match_rule; the end of the string was encountered\n");
; 2236 : #endif
; 2237 : 		return;
; 2238 : 	}
; 2239 : 	
; 2240 : 	/* this should be the ending slash of the state */
; 2241 : 	if (new_ret.value!=OPT_FAIL)

  0104c	83 7c 24 44 02	 cmp	 DWORD PTR _new_ret$[esp+100], 2
  01051	0f 84 08 01 00
	00		 je	 $L71833
$L73030:
  01057	8b 4c 24 10	 mov	 ecx, DWORD PTR _end_of_match$[esp+80]

; 2242 : 	{
; 2243 : 		if ((state!=BIN_END_OF_RULE) && (state!=BIN_MACRO))

  0105b	85 ff		 test	 edi, edi
  0105d	0f 84 80 00 00
	00		 je	 $L71837
  01063	83 ff 18	 cmp	 edi, 24			; 00000018H
  01066	74 2d		 je	 SHORT $L71835

; 2244 : 		{
; 2245 : 			if (new_ret.rule!=(end_of_match+1))

  01068	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0106e	41		 inc	 ecx
  0106f	3b c1		 cmp	 eax, ecx
  01071	74 22		 je	 SHORT $L71835

; 2246 : 			{
; 2247 : 				par_print_rule_error("par_match_rule;end of state slash not found",current_rule,new_ret.rule);

  01073	50		 push	 eax
  01074	8b 44 24 58	 mov	 eax, DWORD PTR _current_rule$[esp+80]
  01078	50		 push	 eax
  01079	68 00 00 00 00	 push	 OFFSET FLAT:$SG71836
  0107e	e8 00 00 00 00	 call	 _par_print_rule_error
  01083	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2248 : 				ret_value->value=FATAL_FAIL;

  01086	c7 46 14 04 00
	00 00		 mov	 DWORD PTR [esi+20], 4
  0108d	5f		 pop	 edi
  0108e	5e		 pop	 esi
  0108f	5d		 pop	 ebp
  01090	5b		 pop	 ebx

; 2327 : #ifdef DEBUG
; 2328 : 	printf("leaving par_match_rule success\n");
; 2329 : #endif
; 2330 : }

  01091	83 c4 40	 add	 esp, 64			; 00000040H
  01094	c3		 ret	 0
$L71835:

; 2249 : 				return;
; 2250 : 			}
; 2251 : 		}
; 2252 : 		/* performing the action of this state */  
; 2253 : #ifdef DEBUG
; 2254 : 		printf("the current output is:%s\n",output_array);
; 2255 : 		printf("output_pos=%d output_offset=%d\n",new_ret.output_pos,new_ret.output_offset);
; 2256 : #endif
; 2257 : 		if (state!=BIN_END_OF_RULE)
; 2258 : 		{
; 2259 : #ifndef GERMAN_COMPOUND_NOUNS
; 2260 : 			(perform_action_funcs[state])(current_rule,input_array,output_array,input_indexes,output_indexes,match_array,&new_ret,&range_value,save_state_num,dict_state_flag,in_rule_index);
; 2261 : #else
; 2262 : 			(perform_action_funcs[state])(current_rule,input_array,output_array,input_indexes,output_indexes,match_array,&new_ret,&range_value,save_state_num,dict_state_flag,in_rule_index,insert_operation_flags);

  01095	8b 4c 24 1c	 mov	 ecx, DWORD PTR _insert_operation_flags$[esp+80]
  01099	8b 54 24 70	 mov	 edx, DWORD PTR _in_rule_index$[esp+76]
  0109d	8b 44 24 74	 mov	 eax, DWORD PTR _dict_state_flag$[esp+76]
  010a1	51		 push	 ecx
  010a2	8b 4c 24 18	 mov	 ecx, DWORD PTR _save_state_num$[esp+84]
  010a6	52		 push	 edx
  010a7	50		 push	 eax
  010a8	8d 54 24 2c	 lea	 edx, DWORD PTR _range_value$[esp+92]
  010ac	51		 push	 ecx
  010ad	8b 4c 24 7c	 mov	 ecx, DWORD PTR _match_array$[esp+92]
  010b1	8d 44 24 40	 lea	 eax, DWORD PTR _new_ret$[esp+96]
  010b5	52		 push	 edx
  010b6	8b 54 24 7c	 mov	 edx, DWORD PTR _output_indexes$[esp+96]
  010ba	50		 push	 eax
  010bb	8b 44 24 7c	 mov	 eax, DWORD PTR _input_indexes$[esp+100]
  010bf	51		 push	 ecx
  010c0	8b 4c 24 7c	 mov	 ecx, DWORD PTR _output_array$[esp+104]
  010c4	52		 push	 edx
  010c5	8b 54 24 74	 mov	 edx, DWORD PTR _current_rule$[esp+108]
  010c9	50		 push	 eax
  010ca	51		 push	 ecx
  010cb	53		 push	 ebx
  010cc	52		 push	 edx
  010cd	ff 14 bd 00 00
	00 00		 call	 DWORD PTR _perform_action_funcs[edi*4]
  010d4	8b 44 24 70	 mov	 eax, DWORD PTR _new_ret$[esp+144]
  010d8	8b 6c 24 6c	 mov	 ebp, DWORD PTR _new_ret$[esp+140]
  010dc	8b 54 24 68	 mov	 edx, DWORD PTR _new_ret$[esp+136]
  010e0	83 c4 30	 add	 esp, 48			; 00000030H
$L71837:

; 2263 : #endif
; 2264 : 		}
; 2265 : 
; 2266 : 		//printf("B parser_flag is %d\n",new_ret.parser_flag);
; 2267 : 		/* GL 02/08/1997 set the parser_flag to caller */
; 2268 : 		ret_value->parser_flag = new_ret.parser_flag;

  010e3	8b 4c 24 4c	 mov	 ecx, DWORD PTR _new_ret$[esp+108]
  010e7	89 4e 1c	 mov	 DWORD PTR [esi+28], ecx

; 2269 : 		
; 2270 : 		/* updating ret_value */
; 2271 : 		/* only the value of offset is updated with the change in the offset */
; 2272 : 		/* pos values have the value of what they were at the beginning of the rule matching */
; 2273 : #ifdef DEBUG
; 2274 : 		printf("par_match_rule;the output after the action has been performed\n is %s\n",output_array);
; 2275 : #endif
; 2276 : 		if (new_ret.value==FATAL_FAIL)

  010ea	8b 4c 24 44	 mov	 ecx, DWORD PTR _new_ret$[esp+100]
  010ee	83 f9 04	 cmp	 ecx, 4
  010f1	75 0b		 jne	 SHORT $L71838

; 2277 : 		{
; 2278 : 			ret_value->value=FATAL_FAIL;

  010f3	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  010f6	5f		 pop	 edi
  010f7	5e		 pop	 esi
  010f8	5d		 pop	 ebp
  010f9	5b		 pop	 ebx

; 2327 : #ifdef DEBUG
; 2328 : 	printf("leaving par_match_rule success\n");
; 2329 : #endif
; 2330 : }

  010fa	83 c4 40	 add	 esp, 64			; 00000040H
  010fd	c3		 ret	 0
$L71838:

; 2279 : #ifdef DEBUG
; 2280 : 			printf("leaving par_match_rule fatal failure of the rule\n");
; 2281 : #endif
; 2282 : 			return;
; 2283 : 		}
; 2284 : 		if (new_ret.value==FAIL)

  010fe	85 c9		 test	 ecx, ecx
  01100	75 2f		 jne	 SHORT $L71839

; 2285 : 		{
; 2286 : #ifdef INDEX_DEBUG2
; 2287 : 			printf("cleared indexes from %d to %d in the output, fail-fail\n",new_ret.output_pos,new_ret.output_pos+new_ret.output_offset);
; 2288 : #endif
; 2289 : 			memset(output_indexes+new_ret.output_pos,0,new_ret.output_offset*sizeof(index_data_t));

  01102	8b 7c 24 68	 mov	 edi, DWORD PTR _output_indexes$[esp+76]
  01106	8d 4c 6d 00	 lea	 ecx, DWORD PTR [ebp+ebp*2]
  0110a	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  0110d	33 c0		 xor	 eax, eax
  0110f	d1 e1		 shl	 ecx, 1
  01111	8d 3c 57	 lea	 edi, DWORD PTR [edi+edx*2]
  01114	8b d1		 mov	 edx, ecx
  01116	c1 e9 02	 shr	 ecx, 2
  01119	f3 ab		 rep stosd
  0111b	8b ca		 mov	 ecx, edx
  0111d	83 e1 03	 and	 ecx, 3
  01120	f3 aa		 rep stosb

; 2290 : 			ret_value->value=FAIL;

  01122	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  01129	5f		 pop	 edi
  0112a	5e		 pop	 esi
  0112b	5d		 pop	 ebp
  0112c	5b		 pop	 ebx

; 2327 : #ifdef DEBUG
; 2328 : 	printf("leaving par_match_rule success\n");
; 2329 : #endif
; 2330 : }

  0112d	83 c4 40	 add	 esp, 64			; 00000040H
  01130	c3		 ret	 0
$L71839:

; 2291 : #ifdef DEBUG
; 2292 : 			printf("leaving par_match_rule failure of the rule\n");
; 2293 : #endif
; 2294 : 			return;
; 2295 : 
; 2296 : 		}
; 2297 : 		ret_value->value=SUCCESS;
; 2298 : 		/* 
; 2299 : 		*	make the callers return value atructure know how much data was processed 
; 2300 : 		*/
; 2301 : 		/* 	
; 2302 : 		*	these have to be changed with the change in the input value because 
; 2303 : 		*	offsets may have been non zero when the call to this function was made 
; 2304 : 		*/
; 2305 : 		ret_value->input_offset+=new_ret.input_offset;	 /* the offsets are the change from the current pos */

  01131	8b 4c 24 34	 mov	 ecx, DWORD PTR _new_ret$[esp+84]
  01135	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  01138	03 d1		 add	 edx, ecx

; 2306 : 		ret_value->output_offset+=new_ret.output_offset; /* so add the values to the callers offsets */

  0113a	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0113d	03 cd		 add	 ecx, ebp
  0113f	c7 46 14 01 00
	00 00		 mov	 DWORD PTR [esi+20], 1
  01146	89 56 04	 mov	 DWORD PTR [esi+4], edx
  01149	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx

; 2324 : 	}
; 2325 : 	/* ret_value->rule should be pointing to the character afterh the rule now */
; 2326 : 	ret_value->rule=new_ret.rule;

  0114c	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0114f	5f		 pop	 edi
  01150	5e		 pop	 esi
  01151	5d		 pop	 ebp
  01152	5b		 pop	 ebx

; 2327 : #ifdef DEBUG
; 2328 : 	printf("leaving par_match_rule success\n");
; 2329 : #endif
; 2330 : }

  01153	83 c4 40	 add	 esp, 64			; 00000040H
  01156	c3		 ret	 0
$L73022:

; 2307 : 	}
; 2308 : 	else

  01157	8b 6c 24 3c	 mov	 ebp, DWORD PTR _new_ret$[esp+92]
$L73023:
  0115b	8b 54 24 38	 mov	 edx, DWORD PTR _new_ret$[esp+88]
$L71833:

; 2309 : 	{
; 2310 : #ifdef DEBUG
; 2311 : 		printf("par_match_rule;optional set to OPT_FAIL\n");
; 2312 : #endif
; 2313 : #ifdef INDEX_DEBUG2
; 2314 : 		printf("cleared indexes from %d to %d in the output, opt_fail\n",new_ret.output_pos,new_ret.output_pos+new_ret.output_offset);
; 2315 : #endif
; 2316 : 		memset(output_indexes+new_ret.output_pos,0,new_ret.output_offset*sizeof(index_data_t));

  0115f	8b 7c 24 68	 mov	 edi, DWORD PTR _output_indexes$[esp+76]
  01163	8d 4c 6d 00	 lea	 ecx, DWORD PTR [ebp+ebp*2]
  01167	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  0116a	33 c0		 xor	 eax, eax
  0116c	d1 e1		 shl	 ecx, 1
  0116e	8d 3c 57	 lea	 edi, DWORD PTR [edi+edx*2]
  01171	8b d1		 mov	 edx, ecx
  01173	c1 e9 02	 shr	 ecx, 2
  01176	f3 ab		 rep stosd
  01178	8b ca		 mov	 ecx, edx
  0117a	83 e1 03	 and	 ecx, 3
  0117d	f3 aa		 rep stosb

; 2317 : 		if (state==BIN_OPTIONAL)

  0117f	83 7c 24 58 16	 cmp	 DWORD PTR _state$[esp+76], 22 ; 00000016H
  01184	75 1c		 jne	 SHORT $L71843

; 2318 : 		{
; 2319 : 			ret_value->rule=end_of_match+1;

  01186	8b 44 24 10	 mov	 eax, DWORD PTR _end_of_match$[esp+80]

; 2320 : 			ret_value->value=SUCCESS;

  0118a	c7 46 14 01 00
	00 00		 mov	 DWORD PTR [esi+20], 1
  01191	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01196	5f		 pop	 edi
  01197	40		 inc	 eax
  01198	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0119b	5e		 pop	 esi
  0119c	5d		 pop	 ebp
  0119d	5b		 pop	 ebx

; 2327 : #ifdef DEBUG
; 2328 : 	printf("leaving par_match_rule success\n");
; 2329 : #endif
; 2330 : }

  0119e	83 c4 40	 add	 esp, 64			; 00000040H
  011a1	c3		 ret	 0
$L71843:

; 2321 : 			return;
; 2322 : 		}
; 2323 : 		ret_value->value=OPT_FAIL;

  011a2	8b 44 24 40	 mov	 eax, DWORD PTR _new_ret$[esp+96]
  011a6	c7 46 14 02 00
	00 00		 mov	 DWORD PTR [esi+20], 2

; 2324 : 	}
; 2325 : 	/* ret_value->rule should be pointing to the character afterh the rule now */
; 2326 : 	ret_value->rule=new_ret.rule;

  011ad	89 46 10	 mov	 DWORD PTR [esi+16], eax
  011b0	5f		 pop	 edi
  011b1	5e		 pop	 esi
  011b2	5d		 pop	 ebp
  011b3	5b		 pop	 ebx

; 2327 : #ifdef DEBUG
; 2328 : 	printf("leaving par_match_rule success\n");
; 2329 : #endif
; 2330 : }

  011b4	83 c4 40	 add	 esp, 64			; 00000040H
  011b7	c3		 ret	 0
_par_match_rule ENDP
_output_array$ = 16
_output_indexes$ = 24
_ret_value$ = 32
_par_delete_string PROC NEAR

; 2535 : 	int	i,j,save_offset=0;
; 2536 : //055	MGS		10/14/1999	BATS#900 Fixed indexing in spanish phone numbers
; 2537 : 	index_data_t temp_index;
; 2538 : #ifdef DEBUG
; 2539 : 	printf("entering par_delete_string\n");
; 2540 : #endif
; 2541 : 	/*
; 2542 : 	*	check the inputs for valid data 
; 2543 : 	*/
; 2544 : #ifdef SANITY_CHECKING
; 2545 : 	if (ret_value==NULL)
; 2546 : 	{
; 2547 : #ifdef DEBUG
; 2548 : 		printf("leaving par_delete_string ret_value is NULL\n");
; 2549 : #endif
; 2550 : 		return;
; 2551 : 	}
; 2552 : 	if ((output_array==NULL))
; 2553 : 	{
; 2554 : 		ret_value->value=FATAL_FAIL;
; 2555 : #ifdef DEBUG
; 2556 : 		printf("leaving par_delete_string input is NULL\n");
; 2557 : #endif
; 2558 : 		return;
; 2559 : 	}                 
; 2560 : #endif
; 2561 : 	//055	MGS		10/14/1999	BATS#900 Fixed indexing in spanish phone numbers
; 2562 : 	save_offset=ret_value->output_offset+ret_value->output_pos;             

  011c0	8b 54 24 1c	 mov	 edx, DWORD PTR _ret_value$[esp-4]
  011c4	53		 push	 ebx

; 2563 : 	/* blank out the data being deleted */
; 2564 : 	memset((output_array+(ret_value->output_pos)),0,ret_value->output_offset);                              

  011c5	8b 5c 24 10	 mov	 ebx, DWORD PTR _output_array$[esp]
  011c9	55		 push	 ebp
  011ca	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  011cd	56		 push	 esi
  011ce	57		 push	 edi
  011cf	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
  011d2	33 c0		 xor	 eax, eax
  011d4	8d 34 0f	 lea	 esi, DWORD PTR [edi+ecx]
  011d7	8b e9		 mov	 ebp, ecx
  011d9	03 fb		 add	 edi, ebx
  011db	c1 e9 02	 shr	 ecx, 2
  011de	f3 ab		 rep stosd
  011e0	8b cd		 mov	 ecx, ebp
  011e2	83 e1 03	 and	 ecx, 3
  011e5	f3 aa		 rep stosb

; 2565 : 	/* set the ouput_offset to 0 to logically delete the data from processing */
; 2566 : 	memset(&temp_index,0,sizeof(temp_index));
; 2567 : 	ret_value->output_offset=0;
; 2568 : 	for (j=i=ret_value->output_pos;i<save_offset;i++)

  011e7	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  011ea	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
  011f1	3b ce		 cmp	 ecx, esi
  011f3	7d 5b		 jge	 SHORT $L71875
  011f5	8b 7c 24 24	 mov	 edi, DWORD PTR _output_indexes$[esp+12]
  011f9	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  011fc	03 d9		 add	 ebx, ecx
  011fe	2b f1		 sub	 esi, ecx
  01200	8d 04 47	 lea	 eax, DWORD PTR [edi+eax*2]
  01203	89 74 24 2c	 mov	 DWORD PTR 32+[esp+12], esi
  01207	8b f8		 mov	 edi, eax
$L71873:

; 2569 : 	{
; 2570 : 		if (par_is_index_set(output_indexes,i))

  01209	66 83 38 00	 cmp	 WORD PTR [eax], 0
  0120d	75 0e		 jne	 SHORT $L73043
  0120f	66 83 78 02 00	 cmp	 WORD PTR [eax+2], 0
  01214	75 07		 jne	 SHORT $L73043
  01216	66 83 78 04 00	 cmp	 WORD PTR [eax+4], 0
  0121b	74 25		 je	 SHORT $L71874
$L73043:

; 2571 : 		{
; 2572 : #ifdef INDEX_DEBUG
; 2573 : 			printf("copying index in delete state from %d to %d\n",i,j);
; 2574 : #endif
; 2575 : 			par_copy_index(output_indexes,j,output_indexes,i);

  0121d	8b c8		 mov	 ecx, eax
  0121f	8b f7		 mov	 esi, edi

; 2576 : 			/* kill the old index */
; 2577 : 			par_copy_index(output_indexes,i,&temp_index,0);
; 2578 : 			output_array[j]=PAR_INDEX_DUMMY_CHAR;
; 2579 : 			j++;

  01221	83 c7 06	 add	 edi, 6
  01224	8b 29		 mov	 ebp, DWORD PTR [ecx]
  01226	89 2e		 mov	 DWORD PTR [esi], ebp
  01228	66 8b 49 04	 mov	 cx, WORD PTR [ecx+4]
  0122c	66 89 4e 04	 mov	 WORD PTR [esi+4], cx
  01230	8b f0		 mov	 esi, eax
  01232	33 c9		 xor	 ecx, ecx
  01234	43		 inc	 ebx
  01235	89 0e		 mov	 DWORD PTR [esi], ecx
  01237	66 89 4e 04	 mov	 WORD PTR [esi+4], cx
  0123b	c6 43 ff 82	 mov	 BYTE PTR [ebx-1], 130	; 00000082H

; 2580 : 			ret_value->output_offset++;

  0123f	ff 42 0c	 inc	 DWORD PTR [edx+12]
$L71874:
  01242	8b 4c 24 2c	 mov	 ecx, DWORD PTR 32+[esp+12]
  01246	83 c0 06	 add	 eax, 6
  01249	49		 dec	 ecx
  0124a	89 4c 24 2c	 mov	 DWORD PTR 32+[esp+12], ecx
  0124e	75 b9		 jne	 SHORT $L71873
$L71875:
  01250	5f		 pop	 edi
  01251	5e		 pop	 esi
  01252	5d		 pop	 ebp
  01253	5b		 pop	 ebx

; 2581 : 		}
; 2582 : 	}
; 2583 : #ifdef DEBUG
; 2584 : 	printf("leaving par_delete_string string deleted\n");
; 2585 : #endif
; 2586 : }

  01254	c3		 ret	 0
_par_delete_string ENDP
_TEXT	ENDS
PUBLIC	_par_build_string_from_rule
_TEXT	SEGMENT
_current_rule$ = 8
_output_array$ = 16
_output_indexes$ = 24
_match_array$ = 28
_ret_value$ = 32
_range_value$ = 36
_in_rule_index$ = 48
_length$ = -708
_buf$ = -700
_temp_index$ = -600
_par_replace_string PROC NEAR

; 2627 : {

  01260	81 ec c4 02 00
	00		 sub	 esp, 708		; 000002c4H

; 2628 : 	int length;
; 2629 : 	int i,j;
; 2630 : 	unsigned char buf[100];
; 2631 : 	index_data_t  temp_index[100];
; 2632 : 	
; 2633 : 	
; 2634 : #if defined (DEBUG) || defined (INDEX_DEBUG)
; 2635 : 	printf("entering par_replace_string\n");
; 2636 : #endif
; 2637 : 	
; 2638 : 	memset(temp_index,0,100*sizeof(index_data_t));
; 2639 : 	/* 
; 2640 : 	*	check the inputs for valid data 
; 2641 : 	*/
; 2642 : #ifdef SANITY_CHECKING
; 2643 : 	if (ret_value==NULL)
; 2644 : 	{
; 2645 : #ifdef DEBUG
; 2646 : 		printf("leaving par_replace_string ret_value is NULL\n");
; 2647 : #endif
; 2648 : 		return;
; 2649 : 	}
; 2650 : 	if ((current_rule==NULL) || (output_array==NULL) || (match_array==NULL))
; 2651 : 	{
; 2652 : 		ret_value->value=FATAL_FAIL;
; 2653 : #ifdef DEBUG
; 2654 : 		printf("leaving par_replace_string inputs are invalid\n");
; 2655 : #endif
; 2656 : 		return;
; 2657 : 	}
; 2658 : #endif
; 2659 : 	/* 
; 2660 : 	*	build the string that is going to replace the current string bounded by
; 2661 : 	*	by output_pos and output_offset
; 2662 : 	*	then just copy the string built (null and all) on top of the current string
; 2663 : 	*/
; 2664 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_REPLACE,&length,in_rule_index);

  01266	8b 94 24 e4 02
	00 00		 mov	 edx, DWORD PTR _range_value$[esp+704]
  0126d	b9 96 00 00 00	 mov	 ecx, 150		; 00000096H
  01272	33 c0		 xor	 eax, eax
  01274	53		 push	 ebx
  01275	56		 push	 esi
  01276	57		 push	 edi
  01277	8b 9c 24 ec 02
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+716]
  0127e	8d 7c 24 78	 lea	 edi, DWORD PTR _temp_index$[esp+720]
  01282	f3 ab		 rep stosd
  01284	8b 84 24 fc 02
	00 00		 mov	 eax, DWORD PTR _in_rule_index$[esp+716]
  0128b	8d 4c 24 0c	 lea	 ecx, DWORD PTR _length$[esp+720]
  0128f	50		 push	 eax
  01290	8b 84 24 ec 02
	00 00		 mov	 eax, DWORD PTR _match_array$[esp+720]
  01297	51		 push	 ecx
  01298	8b 8c 24 e4 02
	00 00		 mov	 ecx, DWORD PTR _output_array$[esp+724]
  0129f	6a 19		 push	 25			; 00000019H
  012a1	52		 push	 edx
  012a2	53		 push	 ebx
  012a3	50		 push	 eax
  012a4	8b 84 24 ec 02
	00 00		 mov	 eax, DWORD PTR _current_rule$[esp+740]
  012ab	8d 54 24 2c	 lea	 edx, DWORD PTR _buf$[esp+744]
  012af	51		 push	 ecx
  012b0	52		 push	 edx
  012b1	50		 push	 eax
  012b2	e8 00 00 00 00	 call	 _par_build_string_from_rule

; 2665 : 		/* have to do something with indexes so they don't appear in the middle of a word */
; 2666 : 	for (j=0,i=ret_value->output_pos;i<ret_value->output_pos+ret_value->output_offset;i++)

  012b7	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  012ba	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  012bd	03 ce		 add	 ecx, esi
  012bf	83 c4 24	 add	 esp, 36			; 00000024H
  012c2	33 c0		 xor	 eax, eax
  012c4	3b f1		 cmp	 esi, ecx
  012c6	7d 7b		 jge	 SHORT $L71910
  012c8	8b bc 24 e4 02
	00 00		 mov	 edi, DWORD PTR _output_indexes$[esp+716]
  012cf	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  012d2	2b ce		 sub	 ecx, esi
  012d4	55		 push	 ebp
  012d5	8d 14 57	 lea	 edx, DWORD PTR [edi+edx*2]
  012d8	8b 7c 24 10	 mov	 edi, DWORD PTR _length$[esp+724]
  012dc	89 4c 24 14	 mov	 DWORD PTR -704+[esp+724], ecx
$L71908:

; 2667 : 	{
; 2668 : 		if (par_is_index_set(output_indexes,i))

  012e0	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  012e4	75 0e		 jne	 SHORT $L73060
  012e6	66 83 7a 02 00	 cmp	 WORD PTR [edx+2], 0
  012eb	75 07		 jne	 SHORT $L73060
  012ed	66 83 7a 04 00	 cmp	 WORD PTR [edx+4], 0
  012f2	74 39		 je	 SHORT $L71909
$L73060:

; 2669 : 		{
; 2670 : 			/* find a space if there is one */
; 2671 : 			for (;j<length && buf[j]!=' ';j++);

  012f4	3b c7		 cmp	 eax, edi
  012f6	7d 10		 jge	 SHORT $L71915
$L71912:
  012f8	80 7c 04 18 20	 cmp	 BYTE PTR _buf$[esp+eax+724], 32 ; 00000020H
  012fd	0f 84 a6 00 00
	00		 je	 $L71914
  01303	40		 inc	 eax
  01304	3b c7		 cmp	 eax, edi
  01306	7c f0		 jl	 SHORT $L71912
$L71915:

; 2683 : 			{
; 2684 : 				/* use the dummy character for the moved index */
; 2685 : 				buf[j]=PAR_INDEX_DUMMY_CHAR;
; 2686 : 				buf[j+1]='\0';     
; 2687 : #ifdef INDEX_DEBUG
; 2688 : 				printf("copying index in replace 2 from %d to buf %d\n",i,j);
; 2689 : #endif
; 2690 : 				par_copy_index(temp_index,j,output_indexes,i);

  01308	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0130b	8b da		 mov	 ebx, edx
  0130d	c6 44 04 18 82	 mov	 BYTE PTR _buf$[esp+eax+724], 130 ; 00000082H
  01312	c6 44 04 19 00	 mov	 BYTE PTR _buf$[esp+eax+725], 0
  01317	8b 2b		 mov	 ebp, DWORD PTR [ebx]
  01319	8d 4c 4c 7c	 lea	 ecx, DWORD PTR _temp_index$[esp+ecx*2+724]

; 2691 : 				j++;

  0131d	40		 inc	 eax

; 2692 : 				length++;

  0131e	47		 inc	 edi
  0131f	66 8b 5b 04	 mov	 bx, WORD PTR [ebx+4]
  01323	89 29		 mov	 DWORD PTR [ecx], ebp
  01325	89 7c 24 10	 mov	 DWORD PTR _length$[esp+724], edi
  01329	66 89 59 04	 mov	 WORD PTR [ecx+4], bx
$L71909:
  0132d	8b 4c 24 14	 mov	 ecx, DWORD PTR -704+[esp+724]
  01331	83 c2 06	 add	 edx, 6
  01334	49		 dec	 ecx
  01335	89 4c 24 14	 mov	 DWORD PTR -704+[esp+724], ecx
  01339	75 a5		 jne	 SHORT $L71908
  0133b	8b 9c 24 f0 02
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+720]
  01342	5d		 pop	 ebp
$L71910:

; 2693 : 			}       
; 2694 : 		}
; 2695 : 	}
; 2696 : 								
; 2697 : 	strcpy((output_array+(ret_value->output_pos)),buf);

  01343	8b 94 24 dc 02
	00 00		 mov	 edx, DWORD PTR _output_array$[esp+716]
  0134a	8d 7c 24 14	 lea	 edi, DWORD PTR _buf$[esp+720]
  0134e	83 c9 ff	 or	 ecx, -1
  01351	33 c0		 xor	 eax, eax
  01353	03 d6		 add	 edx, esi
  01355	f2 ae		 repne scasb
  01357	f7 d1		 not	 ecx
  01359	2b f9		 sub	 edi, ecx
  0135b	8b c1		 mov	 eax, ecx
  0135d	8b f7		 mov	 esi, edi
  0135f	8b fa		 mov	 edi, edx
  01361	c1 e9 02	 shr	 ecx, 2
  01364	f3 a5		 rep movsd
  01366	8b c8		 mov	 ecx, eax
  01368	83 e1 03	 and	 ecx, 3
  0136b	f3 a4		 rep movsb

; 2698 : 	/* copy the indexes too */
; 2699 : 	par_copy_index_list(output_indexes,ret_value->output_pos,temp_index,0,length);

  0136d	8b 44 24 0c	 mov	 eax, DWORD PTR _length$[esp+720]
  01371	8d 74 24 78	 lea	 esi, DWORD PTR _temp_index$[esp+720]
  01375	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  01378	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0137b	d1 e1		 shl	 ecx, 1
  0137d	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  01380	8b 84 24 e4 02
	00 00		 mov	 eax, DWORD PTR _output_indexes$[esp+716]
  01387	8d 3c 50	 lea	 edi, DWORD PTR [eax+edx*2]
  0138a	8b d1		 mov	 edx, ecx
  0138c	c1 e9 02	 shr	 ecx, 2
  0138f	f3 a5		 rep movsd
  01391	8b ca		 mov	 ecx, edx
  01393	83 e1 03	 and	 ecx, 3
  01396	f3 a4		 rep movsb

; 2700 : 	/* 
; 2701 : 	* the output offset is now the length of of the new output string 
; 2702 : 	*/
; 2703 : #ifdef DEBUG
; 2704 : 	printf("par_replace_string; length=%d\n",length);
; 2705 : #endif	
; 2706 : 	ret_value->output_offset=length;

  01398	8b 44 24 0c	 mov	 eax, DWORD PTR _length$[esp+720]
  0139c	5f		 pop	 edi
  0139d	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  013a0	5e		 pop	 esi
  013a1	5b		 pop	 ebx

; 2707 : 	//	ret_value->rule++;
; 2708 : #ifdef DEBUG
; 2709 : 	printf("leaving replace_state replacement is successful\n");
; 2710 : #endif
; 2711 : }

  013a2	81 c4 c4 02 00
	00		 add	 esp, 708		; 000002c4H
  013a8	c3		 ret	 0
$L71914:

; 2672 : 			if (j<length)

  013a9	3b c7		 cmp	 eax, edi
  013ab	0f 8d 57 ff ff
	ff		 jge	 $L71915

; 2673 : 			{
; 2674 : #ifdef INDEX_DEBUG
; 2675 : 				printf("copying index in replace 1 from %d to buf %d\n",i,j);
; 2676 : #endif
; 2677 : 				par_copy_index(temp_index,j,output_indexes,i);

  013b1	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  013b4	8b da		 mov	 ebx, edx

; 2678 : 				//055	MGS		10/14/1999	BATS#900 Fixed indexing in spanish phone numbers
; 2679 : 				buf[j]=PAR_INDEX_DUMMY_CHAR;
; 2680 : 				j++;

  013b6	40		 inc	 eax
  013b7	8b 2b		 mov	 ebp, DWORD PTR [ebx]
  013b9	8d 4c 4c 7c	 lea	 ecx, DWORD PTR _temp_index$[esp+ecx*2+724]
  013bd	66 8b 5b 04	 mov	 bx, WORD PTR [ebx+4]
  013c1	89 29		 mov	 DWORD PTR [ecx], ebp
  013c3	c6 44 04 17 82	 mov	 BYTE PTR _buf$[esp+eax+723], 130 ; 00000082H
  013c8	66 89 59 04	 mov	 WORD PTR [ecx+4], bx

; 2681 : 			}
; 2682 : 			else

  013cc	e9 5c ff ff ff	 jmp	 $L71909
_par_replace_string ENDP
_TEXT	ENDS
PUBLIC	_par_break_down_word
EXTRN	_noun_num_character_in_mapping:DWORD
_TEXT	SEGMENT
_output_array$ = 16
_ret_value$ = 32
_new_input$ = -200
_new_output$ = -100
_par_compound_break PROC NEAR

; 2727 : 	int num_matched;
; 2728 : 	char new_input[100];
; 2729 : 	char new_output[100];
; 2730 : 
; 2731 : #ifdef DEBUG
; 2732 : 	printf("entering par_compound_break\n");
; 2733 : #endif
; 2734 : 
; 2735 : 	if (noun_num_character_in_mapping==0)

  013e0	a1 00 00 00 00	 mov	 eax, DWORD PTR _noun_num_character_in_mapping
  013e5	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  013eb	85 c0		 test	 eax, eax
  013ed	53		 push	 ebx
  013ee	55		 push	 ebp
  013ef	56		 push	 esi
  013f0	57		 push	 edi
  013f1	0f 84 93 00 00
	00		 je	 $L71948

; 2736 : 	{
; 2737 : #ifdef DEBUG
; 2738 : 		printf("leaving par_compound_break, no table loaded\n");
; 2739 : #endif
; 2740 : 		return;
; 2741 : 	}
; 2742 : 
; 2743 : 	memcpy(new_input,output_array+ret_value->output_pos,ret_value->output_offset);

  013f7	8b ac 24 f4 00
	00 00		 mov	 ebp, DWORD PTR _ret_value$[esp+212]
  013fe	8b 9c 24 e4 00
	00 00		 mov	 ebx, DWORD PTR _output_array$[esp+212]
  01405	8b f3		 mov	 esi, ebx
  01407	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
  0140a	8b 7d 08	 mov	 edi, DWORD PTR [ebp+8]
  0140d	8b c8		 mov	 ecx, eax
  0140f	03 f7		 add	 esi, edi
  01411	8b d1		 mov	 edx, ecx
  01413	8d 7c 24 10	 lea	 edi, DWORD PTR _new_input$[esp+216]
  01417	c1 e9 02	 shr	 ecx, 2
  0141a	f3 a5		 rep movsd
  0141c	8b ca		 mov	 ecx, edx
  0141e	83 e1 03	 and	 ecx, 3
  01421	f3 a4		 rep movsb

; 2744 : 	new_input[ret_value->output_offset]='\0';

  01423	c6 44 04 10 00	 mov	 BYTE PTR _new_input$[esp+eax+216], 0

; 2745 : 	memset(new_output,0,100);

  01428	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  0142d	33 c0		 xor	 eax, eax
  0142f	8d 7c 24 74	 lea	 edi, DWORD PTR _new_output$[esp+216]
  01433	f3 ab		 rep stosd

; 2746 : 
; 2747 : 	num_matched=par_break_down_word(new_input,new_output);

  01435	8d 44 24 74	 lea	 eax, DWORD PTR _new_output$[esp+216]
  01439	8d 4c 24 10	 lea	 ecx, DWORD PTR _new_input$[esp+216]
  0143d	50		 push	 eax
  0143e	51		 push	 ecx
  0143f	e8 00 00 00 00	 call	 _par_break_down_word
  01444	83 c4 08	 add	 esp, 8

; 2748 : 
; 2749 : 	if (num_matched>0)

  01447	85 c0		 test	 eax, eax
  01449	7e 29		 jle	 SHORT $L71946

; 2750 : 	{
; 2751 : 		memcpy(output_array+ret_value->output_pos,new_output,num_matched);

  0144b	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  0144e	8b fb		 mov	 edi, ebx
  01450	8b c8		 mov	 ecx, eax
  01452	03 fa		 add	 edi, edx
  01454	8b d1		 mov	 edx, ecx
  01456	8d 74 24 74	 lea	 esi, DWORD PTR _new_output$[esp+216]
  0145a	c1 e9 02	 shr	 ecx, 2
  0145d	f3 a5		 rep movsd
  0145f	8b ca		 mov	 ecx, edx
  01461	83 e1 03	 and	 ecx, 3
  01464	f3 a4		 rep movsb
  01466	5f		 pop	 edi

; 2752 : 		ret_value->output_offset=num_matched;

  01467	89 45 0c	 mov	 DWORD PTR [ebp+12], eax
  0146a	5e		 pop	 esi
  0146b	5d		 pop	 ebp
  0146c	5b		 pop	 ebx

; 2765 : 		}
; 2766 : 	}
; 2767 : 
; 2768 : #ifdef DEBUG
; 2769 : 	printf("leaving par_compound_break\n");
; 2770 : #endif
; 2771 : 
; 2772 : 	/* rewrite the word breaker code and the word finder code */
; 2773 : 	/* the word breaker should return the number of characters
; 2774 : 	   that are in the output if successful, or -1 if failed */
; 2775 : 	/* create a new header file for the structure used in here */
; 2776 : 
; 2777 : 
; 2778 : 	/* write a file loader */
; 2779 : 	/* the file loader has to be load the file for german, and not for any other language */
; 2780 : 	/* the file loader has to globally allocate the memory, and the other threads
; 2781 : 	   have to use it */
; 2782 : }

  0146d	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  01473	c3		 ret	 0
$L71946:

; 2753 : 	}
; 2754 : 	else
; 2755 : 	{
; 2756 : 
; 2757 : 		ret_value->value=FAIL;
; 2758 : 
; 2759 : 		if (ret_value->optional==1)

  01474	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  01477	c7 45 14 00 00
	00 00		 mov	 DWORD PTR [ebp+20], 0
  0147e	83 f8 01	 cmp	 eax, 1
  01481	75 07		 jne	 SHORT $L71948

; 2760 : 		{
; 2761 : #ifdef DEBUG
; 2762 : 			printf("set optional to opt_fail\n");
; 2763 : #endif
; 2764 : 			ret_value->value=OPT_FAIL;

  01483	c7 45 14 02 00
	00 00		 mov	 DWORD PTR [ebp+20], 2
$L71948:
  0148a	5f		 pop	 edi
  0148b	5e		 pop	 esi
  0148c	5d		 pop	 ebp
  0148d	5b		 pop	 ebx

; 2765 : 		}
; 2766 : 	}
; 2767 : 
; 2768 : #ifdef DEBUG
; 2769 : 	printf("leaving par_compound_break\n");
; 2770 : #endif
; 2771 : 
; 2772 : 	/* rewrite the word breaker code and the word finder code */
; 2773 : 	/* the word breaker should return the number of characters
; 2774 : 	   that are in the output if successful, or -1 if failed */
; 2775 : 	/* create a new header file for the structure used in here */
; 2776 : 
; 2777 : 
; 2778 : 	/* write a file loader */
; 2779 : 	/* the file loader has to be load the file for german, and not for any other language */
; 2780 : 	/* the file loader has to globally allocate the memory, and the other threads
; 2781 : 	   have to use it */
; 2782 : }

  0148e	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  01494	c3		 ret	 0
_par_compound_break ENDP
_TEXT	ENDS
PUBLIC	_par_find_word_in_dict
EXTRN	_par_upper:BYTE
EXTRN	_noun_number_of_conjunctions:DWORD
EXTRN	_noun_conjunction:BYTE
_TEXT	SEGMENT
_input$ = 8
_output$ = 12
_i$ = -56
_j$ = 12
_number_of_pos$ = -48
_positions$ = -40
_par_break_down_word PROC NEAR

; 2785 : {

  014a0	83 ec 38	 sub	 esp, 56			; 00000038H

; 2786 : 	int i,j;
; 2787 : 	int head=1;
; 2788 : 	int number_of_pos=0;
; 2789 : 	int positions[10];
; 2790 : 	int result;
; 2791 : 
; 2792 : #ifdef DEBUG
; 2793 : 	printf("entering par_break_down_word %s\n",input);
; 2794 : #endif
; 2795 : 	result=par_find_word_in_dict(head,input,positions,0,&number_of_pos);

  014a3	8b 54 24 3c	 mov	 edx, DWORD PTR _input$[esp+52]
  014a7	53		 push	 ebx
  014a8	55		 push	 ebp
  014a9	56		 push	 esi
  014aa	8d 44 24 14	 lea	 eax, DWORD PTR _number_of_pos$[esp+68]
  014ae	57		 push	 edi
  014af	50		 push	 eax
  014b0	8d 4c 24 24	 lea	 ecx, DWORD PTR _positions$[esp+76]
  014b4	6a 00		 push	 0
  014b6	51		 push	 ecx
  014b7	52		 push	 edx
  014b8	6a 01		 push	 1
  014ba	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _number_of_pos$[esp+92], 0
  014c2	e8 00 00 00 00	 call	 _par_find_word_in_dict
  014c7	83 c4 14	 add	 esp, 20			; 00000014H

; 2796 : 	if (result==0)

  014ca	85 c0		 test	 eax, eax

; 2797 : 	{
; 2798 : #ifdef DEBUG
; 2799 : 		printf("leaving par_break_down_word no matches\n");
; 2800 : #endif
; 2801 : 		return(-1);

  014cc	0f 84 07 01 00
	00		 je	 $L71963

; 2802 : 	}
; 2803 : 	for (i=number_of_pos-1;i>=0;i--)

  014d2	8b 44 24 18	 mov	 eax, DWORD PTR _number_of_pos$[esp+72]
  014d6	48		 dec	 eax
  014d7	85 c0		 test	 eax, eax
  014d9	89 44 24 10	 mov	 DWORD PTR _i$[esp+72], eax
  014dd	0f 8c f6 00 00
	00		 jl	 $L71963
  014e3	8b 6c 24 50	 mov	 ebp, DWORD PTR _output$[esp+68]
  014e7	8d 5c 84 20	 lea	 ebx, DWORD PTR _positions$[esp+eax*4+72]
  014eb	89 5c 24 14	 mov	 DWORD PTR -52+[esp+72], ebx
$L71961:

; 2804 : 	{
; 2805 : 		memcpy(output,input,positions[i]);

  014ef	8b 03		 mov	 eax, DWORD PTR [ebx]
  014f1	8b 74 24 4c	 mov	 esi, DWORD PTR _input$[esp+68]
  014f5	8b c8		 mov	 ecx, eax
  014f7	8b fd		 mov	 edi, ebp
  014f9	8b d1		 mov	 edx, ecx
  014fb	c1 e9 02	 shr	 ecx, 2
  014fe	f3 a5		 rep movsd
  01500	8b ca		 mov	 ecx, edx
  01502	83 e1 03	 and	 ecx, 3
  01505	f3 a4		 rep movsb

; 2806 : 		/* MGS make the first character of the new word uppercase */
; 2807 : 		output[0]=par_upper[output[0]];

  01507	33 c9		 xor	 ecx, ecx

; 2808 : 		output[positions[i]]='\0';
; 2809 : 		output[positions[i]+1]='\0';
; 2810 : 		if (input[positions[i]]=='\0')

  01509	8b 7c 24 4c	 mov	 edi, DWORD PTR _input$[esp+68]
  0150d	8a 4d 00	 mov	 cl, BYTE PTR [ebp]
  01510	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR _par_upper[ecx]
  01516	88 55 00	 mov	 BYTE PTR [ebp], dl
  01519	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
  0151d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0151f	c6 44 28 01 00	 mov	 BYTE PTR [eax+ebp+1], 0
  01524	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  01526	80 3c 39 00	 cmp	 BYTE PTR [ecx+edi], 0
  0152a	0f 84 b4 00 00
	00		 je	 $L73086

; 2813 : 		}
; 2814 : 		if (noun_number_of_conjunctions>0)

  01530	a1 00 00 00 00	 mov	 eax, DWORD PTR _noun_number_of_conjunctions
  01535	85 c0		 test	 eax, eax
  01537	0f 8e 84 00 00
	00		 jle	 $L71962

; 2815 : 		{
; 2816 : 			for (j=0;j<noun_number_of_conjunctions;j++)

  0153d	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_noun_conjunction
  01542	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR _j$[esp+68], 0
  0154a	89 74 24 1c	 mov	 DWORD PTR -44+[esp+72], esi
  0154e	eb 04		 jmp	 SHORT $L71966
$L73093:
  01550	8b 7c 24 4c	 mov	 edi, DWORD PTR _input$[esp+68]
$L71966:

; 2817 : 			{
; 2818 : 				if (noun_conjunction[j].length==0)

  01554	8b 06		 mov	 eax, DWORD PTR [esi]
  01556	85 c0		 test	 eax, eax
  01558	75 1c		 jne	 SHORT $L71969

; 2819 : 				{
; 2820 : 					result=par_break_down_word(input+positions[i],output+positions[i]+1);

  0155a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0155c	8d 54 28 01	 lea	 edx, DWORD PTR [eax+ebp+1]
  01560	03 c7		 add	 eax, edi
  01562	52		 push	 edx
  01563	50		 push	 eax
  01564	e8 00 00 00 00	 call	 _par_break_down_word
  01569	83 c4 08	 add	 esp, 8

; 2821 : 					if (result>0)

  0156c	85 c0		 test	 eax, eax
  0156e	0f 8f 80 00 00
	00		 jg	 $L73084

; 2828 : 					}
; 2829 : 				}
; 2830 : 				else

  01574	eb 2d		 jmp	 SHORT $L71967
$L71969:

; 2831 : 				{
; 2832 : 					if (memcmp(noun_conjunction[j].conj,input+positions[i],noun_conjunction[j].length)==0)

  01576	8b 13		 mov	 edx, DWORD PTR [ebx]
  01578	83 c6 04	 add	 esi, 4
  0157b	03 fa		 add	 edi, edx
  0157d	8b c8		 mov	 ecx, eax
  0157f	33 db		 xor	 ebx, ebx
  01581	f3 a6		 repe cmpsb
  01583	75 1a		 jne	 SHORT $L73090

; 2833 : 					{
; 2834 : 						result=par_break_down_word(input+positions[i]+noun_conjunction[j].length,output+positions[i]+noun_conjunction[j].length+1);

  01585	03 c2		 add	 eax, edx
  01587	8b 54 24 4c	 mov	 edx, DWORD PTR _input$[esp+68]
  0158b	8d 4c 28 01	 lea	 ecx, DWORD PTR [eax+ebp+1]
  0158f	03 c2		 add	 eax, edx
  01591	51		 push	 ecx
  01592	50		 push	 eax
  01593	e8 00 00 00 00	 call	 _par_break_down_word
  01598	83 c4 08	 add	 esp, 8

; 2835 : 						if (result>0)

  0159b	85 c0		 test	 eax, eax
  0159d	7f 73		 jg	 SHORT $L73085
$L73090:
  0159f	8b 5c 24 14	 mov	 ebx, DWORD PTR -52+[esp+72]
$L71967:

; 2815 : 		{
; 2816 : 			for (j=0;j<noun_number_of_conjunctions;j++)

  015a3	8b 44 24 50	 mov	 eax, DWORD PTR _j$[esp+68]
  015a7	8b 74 24 1c	 mov	 esi, DWORD PTR -44+[esp+72]
  015ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _noun_number_of_conjunctions
  015b1	40		 inc	 eax
  015b2	83 c6 08	 add	 esi, 8
  015b5	3b c1		 cmp	 eax, ecx
  015b7	89 44 24 50	 mov	 DWORD PTR _j$[esp+68], eax
  015bb	89 74 24 1c	 mov	 DWORD PTR -44+[esp+72], esi
  015bf	7c 8f		 jl	 SHORT $L73093
$L71962:

; 2802 : 	}
; 2803 : 	for (i=number_of_pos-1;i>=0;i--)

  015c1	8b 44 24 10	 mov	 eax, DWORD PTR _i$[esp+72]
  015c5	83 eb 04	 sub	 ebx, 4
  015c8	48		 dec	 eax
  015c9	89 5c 24 14	 mov	 DWORD PTR -52+[esp+72], ebx
  015cd	85 c0		 test	 eax, eax
  015cf	89 44 24 10	 mov	 DWORD PTR _i$[esp+72], eax
  015d3	0f 8d 16 ff ff
	ff		 jge	 $L71961
$L71963:
  015d9	5f		 pop	 edi
  015da	5e		 pop	 esi
  015db	5d		 pop	 ebp

; 2844 : 						}
; 2845 : 					}
; 2846 : 				}
; 2847 : 			}
; 2848 : 		}
; 2849 : 		/* insert code for connecting characters here */
; 2850 : 		/* remove the connections in reverse order from longest to shortest */
; 2851 : 	}
; 2852 : #ifdef DEBUG
; 2853 : 	printf("leaving par_break_down_word failure %s %s\n",input,output);
; 2854 : #endif
; 2855 : 	return(-1);

  015dc	83 c8 ff	 or	 eax, -1
  015df	5b		 pop	 ebx

; 2856 : 
; 2857 : }

  015e0	83 c4 38	 add	 esp, 56			; 00000038H
  015e3	c3		 ret	 0
$L73086:

; 2811 : 		{
; 2812 : 			return(positions[i]);

  015e4	8b 44 24 10	 mov	 eax, DWORD PTR _i$[esp+72]
  015e8	5f		 pop	 edi
  015e9	5e		 pop	 esi
  015ea	5d		 pop	 ebp
  015eb	8b 44 84 14	 mov	 eax, DWORD PTR _positions$[esp+eax*4+60]
  015ef	5b		 pop	 ebx

; 2856 : 
; 2857 : }

  015f0	83 c4 38	 add	 esp, 56			; 00000038H
  015f3	c3		 ret	 0
$L73084:

; 2822 : 					{
; 2823 : 						output[positions[i]]='-';

  015f4	8b 4c 24 10	 mov	 ecx, DWORD PTR _i$[esp+72]
  015f8	5f		 pop	 edi
  015f9	5e		 pop	 esi
  015fa	8b 54 8c 18	 mov	 edx, DWORD PTR _positions$[esp+ecx*4+64]
  015fe	8d 4c 8c 18	 lea	 ecx, DWORD PTR _positions$[esp+ecx*4+64]
  01602	c6 04 2a 2d	 mov	 BYTE PTR [edx+ebp], 45	; 0000002dH

; 2824 : #ifdef DEBUG
; 2825 : 						printf("leaving par_break_down_word no conj %s %s %d\n",input,output,result+positions[i]+1);
; 2826 : #endif
; 2827 : 						return(result+positions[i]+1);

  01606	8b 09		 mov	 ecx, DWORD PTR [ecx]
  01608	5d		 pop	 ebp
  01609	5b		 pop	 ebx
  0160a	8d 44 08 01	 lea	 eax, DWORD PTR [eax+ecx+1]

; 2856 : 
; 2857 : }

  0160e	83 c4 38	 add	 esp, 56			; 00000038H
  01611	c3		 ret	 0
$L73085:

; 2836 : 						{
; 2837 : 							memcpy(output+positions[i],noun_conjunction[j].conj,noun_conjunction[j].length);

  01612	8b 74 24 50	 mov	 esi, DWORD PTR _j$[esp+68]
  01616	8b 4c 24 10	 mov	 ecx, DWORD PTR _i$[esp+72]
  0161a	8b fd		 mov	 edi, ebp
  0161c	03 7c 8c 20	 add	 edi, DWORD PTR _positions$[esp+ecx*4+72]
  01620	8d 14 f5 00 00
	00 00		 lea	 edx, DWORD PTR _noun_conjunction[esi*8]
  01627	8d 5c 8c 20	 lea	 ebx, DWORD PTR _positions$[esp+ecx*4+72]
  0162b	8d 34 f5 04 00
	00 00		 lea	 esi, DWORD PTR _noun_conjunction[esi*8+4]
  01632	8b 0a		 mov	 ecx, DWORD PTR [edx]
  01634	89 5c 24 4c	 mov	 DWORD PTR 8+[esp+68], ebx
  01638	8b d9		 mov	 ebx, ecx
  0163a	c1 e9 02	 shr	 ecx, 2
  0163d	f3 a5		 rep movsd
  0163f	8b cb		 mov	 ecx, ebx
  01641	83 e1 03	 and	 ecx, 3
  01644	f3 a4		 rep movsb

; 2838 : 							output[positions[i]+noun_conjunction[j].length]='-';

  01646	8b 4c 24 4c	 mov	 ecx, DWORD PTR 8+[esp+68]
  0164a	8b 3a		 mov	 edi, DWORD PTR [edx]
  0164c	03 ef		 add	 ebp, edi
  0164e	5f		 pop	 edi
  0164f	8b 31		 mov	 esi, DWORD PTR [ecx]
  01651	c6 04 2e 2d	 mov	 BYTE PTR [esi+ebp], 45	; 0000002dH

; 2839 : 
; 2840 : #ifdef DEBUG
; 2841 : 							printf("leaving par_break_down_word conj %s %s %d\n",input,output,result+positions[i]+1);
; 2842 : #endif
; 2843 : 							return(result+positions[i]+noun_conjunction[j].length+1);

  01655	8b 32		 mov	 esi, DWORD PTR [edx]
  01657	8b 11		 mov	 edx, DWORD PTR [ecx]
  01659	03 c6		 add	 eax, esi
  0165b	5e		 pop	 esi
  0165c	5d		 pop	 ebp
  0165d	8d 44 10 01	 lea	 eax, DWORD PTR [eax+edx+1]
  01661	5b		 pop	 ebx

; 2856 : 
; 2857 : }

  01662	83 c4 38	 add	 esp, 56			; 00000038H
  01665	c3		 ret	 0
_par_break_down_word ENDP
_TEXT	ENDS
EXTRN	_noun_character_mapping_table:BYTE
EXTRN	_noun_index_table:BYTE
EXTRN	_noun_data_table:BYTE
_TEXT	SEGMENT
_head$ = 8
_word$ = 12
_positions$ = 16
_depth$ = 20
_num_pos$ = 24
_par_find_word_in_dict PROC NEAR

; 2861 : 	//removed unused vairable 
; 2862 : 	int i;
; 2863 : 	comp_noun_table_entry *cur;
; 2864 : 	if (head==NOUN_UNUSED_ENTRY)

  01670	8b 44 24 04	 mov	 eax, DWORD PTR _head$[esp-4]
  01674	53		 push	 ebx
  01675	55		 push	 ebp
  01676	8b 6c 24 1c	 mov	 ebp, DWORD PTR _num_pos$[esp+4]
  0167a	56		 push	 esi
  0167b	83 f8 ff	 cmp	 eax, -1
  0167e	57		 push	 edi
  0167f	0f 84 a8 00 00
	00		 je	 $L73100
  01685	8b 74 24 18	 mov	 esi, DWORD PTR _word$[esp+12]
$L73095:

; 2865 : 	{
; 2866 : 		if (*num_pos>0)
; 2867 : 		{
; 2868 : 			return(1);
; 2869 : 		}
; 2870 : 		else
; 2871 : 		{
; 2872 : 			return(0);
; 2873 : 		}
; 2874 : 	}
; 2875 : 	if (head==0)

  01689	85 c0		 test	 eax, eax
  0168b	0f 84 ab 00 00
	00		 je	 $L73101

; 2880 : 	}
; 2881 : 	cur= (comp_noun_table_entry *)(&(noun_data_table[noun_index_table[head]]));

  01691	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _noun_index_table[eax*4]
  01698	05 00 00 00 00	 add	 eax, OFFSET FLAT:_noun_data_table

; 2882 : 	if (cur->word_ending & 1)

  0169d	f6 00 01	 test	 BYTE PTR [eax], 1
  016a0	74 15		 je	 SHORT $L71992

; 2883 : 	{
; 2884 : 		positions[*num_pos]=depth;

  016a2	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  016a5	8b 54 24 1c	 mov	 edx, DWORD PTR _positions$[esp+12]
  016a9	8b 7c 24 20	 mov	 edi, DWORD PTR _depth$[esp+12]
  016ad	89 3c 8a	 mov	 DWORD PTR [edx+ecx*4], edi

; 2885 : 		(*num_pos)++;

  016b0	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  016b3	41		 inc	 ecx
  016b4	89 4d 00	 mov	 DWORD PTR [ebp], ecx
$L71992:

; 2886 : 	}
; 2887 : 	if (cur->word_ending & 2)

  016b7	8a 18		 mov	 bl, BYTE PTR [eax]
  016b9	f6 c3 02	 test	 bl, 2
  016bc	0f 85 99 00 00
	00		 jne	 $L73102

; 2894 : 		}
; 2895 : 		else
; 2896 : 		{
; 2897 : 			if (*num_pos>0)
; 2898 : 			{
; 2899 : 				return(1);
; 2900 : 			}
; 2901 : 			else
; 2902 : 			{
; 2903 : 				return(0);
; 2904 : 			}
; 2905 : 		}
; 2906 : 	}
; 2907 : 	if (word[0]=='\0')

  016c2	8a 16		 mov	 dl, BYTE PTR [esi]
  016c4	84 d2		 test	 dl, dl
  016c6	74 65		 je	 SHORT $L73100

; 2908 : 	{
; 2909 : 		if (*num_pos>0)
; 2910 : 		{
; 2911 : 			return(1);
; 2912 : 		}
; 2913 : 		else
; 2914 : 		{
; 2915 : 			return(0);
; 2916 : 		}
; 2917 : 	}
; 2918 : 	if (noun_character_mapping_table[word[0]]==NOUN_UNUSED_ENTRY)

  016c8	8b ca		 mov	 ecx, edx
  016ca	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  016d0	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _noun_character_mapping_table[ecx*4]
  016d7	83 f9 ff	 cmp	 ecx, -1
  016da	74 51		 je	 SHORT $L73100

; 2919 : 	{
; 2920 : 		if (*num_pos>0)
; 2921 : 		{
; 2922 : 			return(1);
; 2923 : 		}
; 2924 : 		else
; 2925 : 		{
; 2926 : 			return(0);
; 2927 : 		}
; 2928 : 	}
; 2929 : 	if (cur->word_ending & 4)

  016dc	f6 c3 04	 test	 bl, 4
  016df	74 2c		 je	 SHORT $L72010

; 2930 : 	{
; 2931 : 		for (i=0;i<cur->length;i++)

  016e1	0f be 58 01	 movsx	 ebx, BYTE PTR [eax+1]
  016e5	33 c9		 xor	 ecx, ecx
  016e7	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$L72005:
  016ea	3b cb		 cmp	 ecx, ebx
  016ec	7d 3f		 jge	 SHORT $L73100

; 2932 : 		{
; 2933 : 			if (word[0]==(cur->foo.sentry[i].character))

  016ee	3a 17		 cmp	 dl, BYTE PTR [edi]
  016f0	74 06		 je	 SHORT $L73099
  016f2	41		 inc	 ecx
  016f3	83 c7 03	 add	 edi, 3
  016f6	eb f2		 jmp	 SHORT $L72005
$L73099:

; 2934 : 			{
; 2935 : 				return(par_find_word_in_dict(cur->foo.sentry[i].entry,word+1,positions,depth+1,num_pos));

  016f8	8b 7c 24 20	 mov	 edi, DWORD PTR _depth$[esp+12]
  016fc	8d 54 48 02	 lea	 edx, DWORD PTR [eax+ecx*2+2]
  01700	47		 inc	 edi
  01701	46		 inc	 esi
  01702	0f bf 44 11 01	 movsx	 eax, WORD PTR [ecx+edx+1]
  01707	89 7c 24 20	 mov	 DWORD PTR _depth$[esp+12], edi
  0170b	eb 17		 jmp	 SHORT $L73106
$L72010:

; 2936 : 			}
; 2937 : 		}
; 2938 : 		if (*num_pos>0)
; 2939 : 		{
; 2940 : 			return(1);
; 2941 : 		}
; 2942 : 		else
; 2943 : 		{
; 2944 : 			return(0);
; 2945 : 		}		
; 2946 : 	}
; 2947 : 	if (noun_character_mapping_table[word[0]]>(cur->length))

  0170d	0f be 50 01	 movsx	 edx, BYTE PTR [eax+1]
  01711	3b ca		 cmp	 ecx, edx
  01713	7f 18		 jg	 SHORT $L73100

; 2950 : 		{
; 2951 : 			return(1);
; 2952 : 		}
; 2953 : 		else
; 2954 : 		{
; 2955 : 			return(0);
; 2956 : 		}
; 2957 : 	}
; 2958 : 	return(par_find_word_in_dict(cur->foo.entries[noun_character_mapping_table[word[0]]],word+1,positions,depth+1,num_pos));

  01715	8b 54 24 20	 mov	 edx, DWORD PTR _depth$[esp+12]
  01719	0f bf 44 48 02	 movsx	 eax, WORD PTR [eax+ecx*2+2]
  0171e	42		 inc	 edx
  0171f	46		 inc	 esi
  01720	89 54 24 20	 mov	 DWORD PTR _depth$[esp+12], edx
$L73106:

; 2861 : 	//removed unused vairable 
; 2862 : 	int i;
; 2863 : 	comp_noun_table_entry *cur;
; 2864 : 	if (head==NOUN_UNUSED_ENTRY)

  01724	83 f8 ff	 cmp	 eax, -1
  01727	0f 85 5c ff ff
	ff		 jne	 $L73095
$L73100:

; 2948 : 	{
; 2949 : 		if (*num_pos>0)

  0172d	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  01730	33 c0		 xor	 eax, eax
  01732	5f		 pop	 edi
  01733	5e		 pop	 esi
  01734	85 c9		 test	 ecx, ecx
  01736	5d		 pop	 ebp
  01737	5b		 pop	 ebx
  01738	0f 9f c0	 setg	 al

; 2959 : }

  0173b	c3		 ret	 0
$L73101:

; 2876 : 	{
; 2877 : 		positions[*num_pos]=depth;

  0173c	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0173f	8b 54 24 1c	 mov	 edx, DWORD PTR _positions$[esp+12]
  01743	8b 4c 24 20	 mov	 ecx, DWORD PTR _depth$[esp+12]
  01747	5f		 pop	 edi
  01748	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx

; 2878 : 		(*num_pos)++;

  0174b	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0174e	40		 inc	 eax
  0174f	5e		 pop	 esi
  01750	89 45 00	 mov	 DWORD PTR [ebp], eax
  01753	5d		 pop	 ebp

; 2879 : 		return(1);

  01754	b8 01 00 00 00	 mov	 eax, 1
  01759	5b		 pop	 ebx

; 2959 : }

  0175a	c3		 ret	 0
$L73102:

; 2888 : 	{
; 2889 : 	  if (memcmp(word,cur->foo.rest_of_word,cur->length)==0)

  0175b	0f be 50 01	 movsx	 edx, BYTE PTR [eax+1]
  0175f	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
  01762	8b ca		 mov	 ecx, edx
  01764	33 c0		 xor	 eax, eax
  01766	f3 a6		 repe cmpsb
  01768	75 c3		 jne	 SHORT $L73100

; 2890 : 		{
; 2891 : 			positions[*num_pos]=depth+cur->length;

  0176a	8b 4c 24 20	 mov	 ecx, DWORD PTR _depth$[esp+12]
  0176e	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  01771	03 d1		 add	 edx, ecx
  01773	8b 4c 24 1c	 mov	 ecx, DWORD PTR _positions$[esp+12]
  01777	5f		 pop	 edi
  01778	5e		 pop	 esi
  01779	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 2892 : 			(*num_pos)++;

  0177c	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0177f	40		 inc	 eax
  01780	89 45 00	 mov	 DWORD PTR [ebp], eax
  01783	5d		 pop	 ebp

; 2893 : 			return(1);

  01784	b8 01 00 00 00	 mov	 eax, 1
  01789	5b		 pop	 ebx

; 2959 : }

  0178a	c3		 ret	 0
_par_find_word_in_dict ENDP
_TEXT	ENDS
PUBLIC	_par_insert_string_before
PUBLIC	_par_insert_string_after
_TEXT	SEGMENT
_current_rule$ = 8
_input_array$ = 12
_output_array$ = 16
_input_indexes$ = 20
_output_indexes$ = 24
_match_array$ = 28
_ret_value$ = 32
_range_value$ = 36
_save_num$ = 40
_dict_state_flag$ = 44
_in_rule_index$ = 48
_insert_operation_flags$ = 52
_buf$ = -100
_length$ = 48
_new_length$ = 16
_temp_index$ = -108
_par_insert_string PROC NEAR

; 3004 : {

  01790	83 ec 6c	 sub	 esp, 108		; 0000006cH

; 3005 : 	unsigned char buf[100];
; 3006 : 	int length,new_length;
; 3007 : 	int pos,new_loc,off;
; 3008 : 	//055	MGS		10/14/1999	BATS#900 Fixed indexing in spanish phone numbers
; 3009 : 	int i;
; 3010 : 	index_data_t temp_index={{0,0,0}};

  01793	33 c0		 xor	 eax, eax
  01795	66 89 44 24 00	 mov	 WORD PTR _temp_index$[esp+108], ax
  0179a	66 89 44 24 02	 mov	 WORD PTR _temp_index$[esp+110], ax
  0179f	66 89 44 24 04	 mov	 WORD PTR _temp_index$[esp+112], ax

; 3011 : 	
; 3012 : #ifdef GERMAN_COMPOUND_NOUNS
; 3013 : 	if (insert_operation_flags & BIN_AFTER_FLAG)

  017a4	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR _insert_operation_flags$[esp+104]
  017ab	a8 40		 test	 al, 64			; 00000040H
  017ad	74 65		 je	 SHORT $L72047

; 3014 : 	{
; 3015 : 		par_insert_string_after(current_rule,input_array,output_array,input_indexes,output_indexes,match_array,ret_value,range_value,save_num,dict_state_flag,in_rule_index,insert_operation_flags);

  017af	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _dict_state_flag$[esp+104]
  017b6	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR _save_num$[esp+104]
  017bd	50		 push	 eax
  017be	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR _in_rule_index$[esp+108]
  017c5	50		 push	 eax
  017c6	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _range_value$[esp+112]
  017cd	51		 push	 ecx
  017ce	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _ret_value$[esp+116]
  017d5	52		 push	 edx
  017d6	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR _match_array$[esp+120]
  017dd	50		 push	 eax
  017de	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _output_indexes$[esp+124]
  017e5	51		 push	 ecx
  017e6	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _input_indexes$[esp+128]
  017ed	52		 push	 edx
  017ee	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR _output_array$[esp+132]
  017f5	50		 push	 eax
  017f6	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _input_array$[esp+136]
  017fd	51		 push	 ecx
  017fe	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _current_rule$[esp+140]
  01805	52		 push	 edx
  01806	50		 push	 eax
  01807	51		 push	 ecx
  01808	e8 00 00 00 00	 call	 _par_insert_string_after
  0180d	83 c4 30	 add	 esp, 48			; 00000030H

; 3088 : 
; 3089 : #ifdef DEBUG
; 3090 : 	printf("leaving par_insert_string; insert is done\n");
; 3091 : #endif
; 3092 : 	return;
; 3093 : }

  01810	83 c4 6c	 add	 esp, 108		; 0000006cH
  01813	c3		 ret	 0
$L72047:

; 3016 : 		return;
; 3017 : 	}
; 3018 : 	if (insert_operation_flags & BIN_BEFORE_FLAG)

  01814	a8 20		 test	 al, 32			; 00000020H
  01816	74 65		 je	 SHORT $L72048

; 3019 : 	{
; 3020 : 		par_insert_string_before(current_rule,input_array,output_array,input_indexes,output_indexes,match_array,ret_value,range_value,save_num,dict_state_flag,in_rule_index,insert_operation_flags);

  01818	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR _in_rule_index$[esp+104]
  0181f	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _save_num$[esp+104]
  01826	50		 push	 eax
  01827	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR _dict_state_flag$[esp+108]
  0182e	52		 push	 edx
  0182f	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR _range_value$[esp+112]
  01836	50		 push	 eax
  01837	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _ret_value$[esp+116]
  0183e	51		 push	 ecx
  0183f	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _match_array$[esp+120]
  01846	52		 push	 edx
  01847	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR _output_indexes$[esp+124]
  0184e	50		 push	 eax
  0184f	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _input_indexes$[esp+128]
  01856	51		 push	 ecx
  01857	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _output_array$[esp+132]
  0185e	52		 push	 edx
  0185f	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR _input_array$[esp+136]
  01866	50		 push	 eax
  01867	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _current_rule$[esp+140]
  0186e	51		 push	 ecx
  0186f	52		 push	 edx
  01870	50		 push	 eax
  01871	e8 00 00 00 00	 call	 _par_insert_string_before
  01876	83 c4 30	 add	 esp, 48			; 00000030H

; 3088 : 
; 3089 : #ifdef DEBUG
; 3090 : 	printf("leaving par_insert_string; insert is done\n");
; 3091 : #endif
; 3092 : 	return;
; 3093 : }

  01879	83 c4 6c	 add	 esp, 108		; 0000006cH
  0187c	c3		 ret	 0
$L72048:

; 3021 : 		return;
; 3022 : 	}
; 3023 : #endif
; 3024 : #ifdef DEBUG
; 3025 : 	printf("entering par_insert_string\n");
; 3026 : #endif
; 3027 : 	/* 
; 3028 : 	*	check the inputs for valid data 
; 3029 : 	*/
; 3030 : #ifdef SANITY_CHECKING
; 3031 : 	if (ret_value==NULL)
; 3032 : 	{
; 3033 : #ifdef DEBUG
; 3034 : 		printf("leaving par_insert_string ret_value is NULL\n");
; 3035 : #endif
; 3036 : 		return;
; 3037 : 	}
; 3038 : 	if ((current_rule==NULL) || (output_array==NULL) || (match_array==NULL))
; 3039 : 	{
; 3040 : 		ret_value->value=FATAL_FAIL;
; 3041 : #ifdef DEBUG
; 3042 : 		printf("leaving par_insert_string; inputs are invalid\n");
; 3043 : #endif
; 3044 : 		return;
; 3045 : 	}
; 3046 : #endif /* SANITY_CHECKING */
; 3047 : 	/* 
; 3048 : 	*	build the string that is going to be inserted 
; 3049 : 	*/
; 3050 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_INSERT,&length,in_rule_index);

  0187d	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR _in_rule_index$[esp+104]
  01884	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR _range_value$[esp+104]
  0188b	55		 push	 ebp
  0188c	8b 6c 24 7c	 mov	 ebp, DWORD PTR _output_array$[esp+108]
  01890	56		 push	 esi
  01891	57		 push	 edi
  01892	8b bc 24 94 00
	00 00		 mov	 edi, DWORD PTR _ret_value$[esp+116]
  01899	8d 94 24 a4 00
	00 00		 lea	 edx, DWORD PTR _length$[esp+116]
  018a0	51		 push	 ecx
  018a1	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _match_array$[esp+120]
  018a8	52		 push	 edx
  018a9	6a 1a		 push	 26			; 0000001aH
  018ab	50		 push	 eax
  018ac	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR _current_rule$[esp+132]
  018b3	57		 push	 edi
  018b4	51		 push	 ecx
  018b5	8d 54 24 2c	 lea	 edx, DWORD PTR _buf$[esp+144]
  018b9	55		 push	 ebp
  018ba	52		 push	 edx
  018bb	50		 push	 eax
  018bc	e8 00 00 00 00	 call	 _par_build_string_from_rule

; 3051 : 	/* 
; 3052 : 	*	the new length of the ouput string is
; 3053 : 	*	the number of characters inserted into minus 1 (the insert is only between)
; 3054 : 	*	times the length of the string to be inserted plus one (the original character)
; 3055 : 	*	plus one (the last character)
; 3056 : 	*/
; 3057 : 	new_length=(ret_value->output_offset-1)*(length+1)+1;

  018c1	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  018c4	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR _length$[esp+152]
  018cb	83 c4 24	 add	 esp, 36			; 00000024H
  018ce	42		 inc	 edx
  018cf	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]

; 3058 : 	
; 3059 : 	/* pos is the current position */
; 3060 : 	pos=ret_value->output_pos;

  018d2	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  018d5	0f af ca	 imul	 ecx, edx
  018d8	41		 inc	 ecx

; 3061 : 	/* off is the pos plus the offset minus 1 (the offset is positioned for the next insert) */
; 3062 : 	off=ret_value->output_offset+ret_value->output_pos-1;

  018d9	8d 54 06 ff	 lea	 edx, DWORD PTR [esi+eax-1]

; 3063 : 	/* new is the place where the last character of the inserted string will be placed */
; 3064 : 	new_loc=new_length+ret_value->output_pos-1;
; 3065 : 	while (pos<off) /* go until the offset if equal to the position */

  018dd	3b f2		 cmp	 esi, edx
  018df	89 8c 24 84 00
	00 00		 mov	 DWORD PTR _new_length$[esp+116], ecx
  018e6	89 b4 24 90 00
	00 00		 mov	 DWORD PTR 28+[esp+116], esi
  018ed	8d 44 0e ff	 lea	 eax, DWORD PTR [esi+ecx-1]
  018f1	0f 8d d6 00 00
	00		 jge	 $L72051
  018f7	8b b4 24 8c 00
	00 00		 mov	 esi, DWORD PTR _output_indexes$[esp+116]
  018fe	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  01901	53		 push	 ebx
  01902	8d 34 4e	 lea	 esi, DWORD PTR [esi+ecx*2]
  01905	eb 07		 jmp	 SHORT $L72050
$L73125:

; 3021 : 		return;
; 3022 : 	}
; 3023 : #endif
; 3024 : #ifdef DEBUG
; 3025 : 	printf("entering par_insert_string\n");
; 3026 : #endif
; 3027 : 	/* 
; 3028 : 	*	check the inputs for valid data 
; 3029 : 	*/
; 3030 : #ifdef SANITY_CHECKING
; 3031 : 	if (ret_value==NULL)
; 3032 : 	{
; 3033 : #ifdef DEBUG
; 3034 : 		printf("leaving par_insert_string ret_value is NULL\n");
; 3035 : #endif
; 3036 : 		return;
; 3037 : 	}
; 3038 : 	if ((current_rule==NULL) || (output_array==NULL) || (match_array==NULL))
; 3039 : 	{
; 3040 : 		ret_value->value=FATAL_FAIL;
; 3041 : #ifdef DEBUG
; 3042 : 		printf("leaving par_insert_string; inputs are invalid\n");
; 3043 : #endif
; 3044 : 		return;
; 3045 : 	}
; 3046 : #endif /* SANITY_CHECKING */
; 3047 : 	/* 
; 3048 : 	*	build the string that is going to be inserted 
; 3049 : 	*/
; 3050 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_INSERT,&length,in_rule_index);

  01907	8b b4 24 9c 00
	00 00		 mov	 esi, DWORD PTR 36+[esp+120]
$L72050:

; 3066 : 	{
; 3067 : 		/* copy the character in the current string into its new location */
; 3068 : 		output_array[new_loc]=output_array[off];                                

  0190e	8a 0c 2a	 mov	 cl, BYTE PTR [edx+ebp]

; 3069 : 		par_copy_index(output_indexes,new_loc,output_indexes,off);

  01911	8b bc 24 90 00
	00 00		 mov	 edi, DWORD PTR _output_indexes$[esp+120]
  01918	88 0c 28	 mov	 BYTE PTR [eax+ebp], cl
  0191b	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0191e	8d 0c 4f	 lea	 ecx, DWORD PTR [edi+ecx*2]
  01921	8b fe		 mov	 edi, esi
  01923	8b 1f		 mov	 ebx, DWORD PTR [edi]
  01925	89 19		 mov	 DWORD PTR [ecx], ebx
  01927	66 8b 7f 04	 mov	 di, WORD PTR [edi+4]
  0192b	66 89 79 04	 mov	 WORD PTR [ecx+4], di

; 3070 : 		par_copy_index(output_indexes,off,output_indexes,PAR_MAX_OUTPUT_ARRAY-1);

  0192f	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _output_indexes$[esp+120]
  01936	81 c1 12 15 00
	00		 add	 ecx, 5394		; 00001512H
  0193c	8b fe		 mov	 edi, esi

; 3071 : 		/* move off back to the previous character */
; 3072 : 		off--;                                       

  0193e	83 ee 06	 sub	 esi, 6
  01941	4a		 dec	 edx
  01942	8b 19		 mov	 ebx, DWORD PTR [ecx]
  01944	89 b4 24 9c 00
	00 00		 mov	 DWORD PTR 36+[esp+120], esi
  0194b	89 1f		 mov	 DWORD PTR [edi], ebx

; 3073 : 		/* move new back for the insert of the inset string */
; 3074 : 		new_loc-=length;                                          
; 3075 : 		/* copy the insert string to new */
; 3076 : 		memcpy(output_array+new_loc,buf,length);

  0194d	8d 74 24 18	 lea	 esi, DWORD PTR _buf$[esp+124]
  01951	66 8b 49 04	 mov	 cx, WORD PTR [ecx+4]
  01955	66 89 4f 04	 mov	 WORD PTR [edi+4], cx
  01959	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR _length$[esp+120]
  01960	2b c1		 sub	 eax, ecx
  01962	8b d9		 mov	 ebx, ecx
  01964	c1 e9 02	 shr	 ecx, 2
  01967	8d 3c 28	 lea	 edi, DWORD PTR [eax+ebp]
  0196a	f3 a5		 rep movsd
  0196c	8b cb		 mov	 ecx, ebx
  0196e	83 e1 03	 and	 ecx, 3
  01971	f3 a4		 rep movsb

; 3077 : 		//055	MGS		10/14/1999	BATS#900 Fixed indexing in spanish phone numbers
; 3078 : 		/* blank the indexes in the inserted range */
; 3079 : 		for (i=new_loc;i<new_loc+length;i++)

  01973	8b b4 24 a8 00
	00 00		 mov	 esi, DWORD PTR _length$[esp+120]
  0197a	8b c8		 mov	 ecx, eax
  0197c	03 f0		 add	 esi, eax
  0197e	3b c6		 cmp	 eax, esi
  01980	7d 2c		 jge	 SHORT $L72054

; 3080 : 		{
; 3081 : 			par_copy_index(output_indexes,new_loc,&temp_index,0);

  01982	8b bc 24 90 00
	00 00		 mov	 edi, DWORD PTR _output_indexes$[esp+120]
  01989	8d 34 40	 lea	 esi, DWORD PTR [eax+eax*2]
  0198c	8d 34 77	 lea	 esi, DWORD PTR [edi+esi*2]
$L72052:
  0198f	8b 5c 24 10	 mov	 ebx, DWORD PTR _temp_index$[esp+124]
  01993	8b fe		 mov	 edi, esi
  01995	41		 inc	 ecx
  01996	89 1f		 mov	 DWORD PTR [edi], ebx
  01998	66 8b 5c 24 14	 mov	 bx, WORD PTR _temp_index$[esp+128]
  0199d	66 89 5f 04	 mov	 WORD PTR [edi+4], bx
  019a1	8b bc 24 a8 00
	00 00		 mov	 edi, DWORD PTR _length$[esp+120]
  019a8	03 f8		 add	 edi, eax
  019aa	3b cf		 cmp	 ecx, edi
  019ac	7c e1		 jl	 SHORT $L72052
$L72054:

; 3063 : 	/* new is the place where the last character of the inserted string will be placed */
; 3064 : 	new_loc=new_length+ret_value->output_pos-1;
; 3065 : 	while (pos<off) /* go until the offset if equal to the position */

  019ae	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR 28+[esp+120]

; 3082 : 		}
; 3083 : 		/* move new back one character */
; 3084 : 		new_loc--;

  019b5	48		 dec	 eax
  019b6	3b d1		 cmp	 edx, ecx
  019b8	0f 8f 49 ff ff
	ff		 jg	 $L73125
  019be	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR _new_length$[esp+120]
  019c5	8b bc 24 98 00
	00 00		 mov	 edi, DWORD PTR _ret_value$[esp+120]
  019cc	5b		 pop	 ebx
$L72051:

; 3085 : 	}                                    
; 3086 : 	/* the output offset is equal to the total length of the new string */
; 3087 : 	ret_value->output_offset=new_length;

  019cd	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  019d0	5f		 pop	 edi
  019d1	5e		 pop	 esi
  019d2	5d		 pop	 ebp

; 3088 : 
; 3089 : #ifdef DEBUG
; 3090 : 	printf("leaving par_insert_string; insert is done\n");
; 3091 : #endif
; 3092 : 	return;
; 3093 : }

  019d3	83 c4 6c	 add	 esp, 108		; 0000006cH
  019d6	c3		 ret	 0
_par_insert_string ENDP
_current_rule$ = 8
_output_array$ = 16
_match_array$ = 28
_ret_value$ = 32
_range_value$ = 36
_in_rule_index$ = 48
_length$ = 48
_buf$ = -100
_par_insert_string_after PROC NEAR

; 3135 : 	int length;
; 3136 : 	unsigned char buf[100];
; 3137 : 	
; 3138 : #ifdef DEBUG
; 3139 : 	printf("entering par_insert_string_after\n");
; 3140 : #endif
; 3141 : 	/*
; 3142 : 	*	check the input values
; 3143 : 	*/
; 3144 : #ifdef SANITY_CHECKING
; 3145 : 	if (ret_value==NULL)
; 3146 : 	{
; 3147 : #ifdef DEBUG
; 3148 : 		printf("leaving par_insert_string_after ret_value is NULL\n");
; 3149 : #endif
; 3150 : 		return;
; 3151 : 	}
; 3152 : 	if ((current_rule==NULL) || (output_array==NULL) || (match_array==NULL))
; 3153 : 	{
; 3154 : 		ret_value->value=FATAL_FAIL;
; 3155 : #ifdef DEBUG
; 3156 : 		printf("leaving par_insert_string_after inputs are invalid\n");
; 3157 : #endif
; 3158 : 		return;
; 3159 : 	}
; 3160 : #endif
; 3161 : 	/*
; 3162 : 	*	build the string for the insert after 
; 3163 : 	*/
; 3164 : #ifndef GERMAN_COMPOUND_NOUNS
; 3165 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_AFTER,&length,in_rule_index);
; 3166 : #else
; 3167 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_INSERT | BIN_AFTER_FLAG,&length,in_rule_index);

  019e0	8b 44 24 2c	 mov	 eax, DWORD PTR _in_rule_index$[esp-4]
  019e4	83 ec 64	 sub	 esp, 100		; 00000064H
  019e7	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR _range_value$[esp+96]
  019ee	8d 8c 24 90 00
	00 00		 lea	 ecx, DWORD PTR _length$[esp+96]
  019f5	53		 push	 ebx
  019f6	8b 9c 24 84 00
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+100]
  019fd	55		 push	 ebp
  019fe	8b 6c 24 78	 mov	 ebp, DWORD PTR _output_array$[esp+104]
  01a02	56		 push	 esi
  01a03	57		 push	 edi
  01a04	50		 push	 eax
  01a05	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR _match_array$[esp+116]
  01a0c	51		 push	 ecx
  01a0d	6a 5a		 push	 90			; 0000005aH
  01a0f	52		 push	 edx
  01a10	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR _current_rule$[esp+128]
  01a17	53		 push	 ebx
  01a18	50		 push	 eax
  01a19	8d 4c 24 28	 lea	 ecx, DWORD PTR _buf$[esp+140]
  01a1d	55		 push	 ebp
  01a1e	51		 push	 ecx
  01a1f	52		 push	 edx
  01a20	e8 00 00 00 00	 call	 _par_build_string_from_rule

; 3168 : #endif
; 3169 : 	/* copy the inserted string into its place */
; 3170 : 	/* the indexes will have been copied by copy_string _data */
; 3171 : 	strcpy((output_array+(ret_value->output_pos+ret_value->output_offset)),buf);

  01a25	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  01a28	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  01a2b	03 d5		 add	 edx, ebp
  01a2d	8d 7c 24 34	 lea	 edi, DWORD PTR _buf$[esp+152]
  01a31	03 d1		 add	 edx, ecx
  01a33	83 c9 ff	 or	 ecx, -1
  01a36	33 c0		 xor	 eax, eax
  01a38	83 c4 24	 add	 esp, 36			; 00000024H
  01a3b	f2 ae		 repne scasb
  01a3d	f7 d1		 not	 ecx
  01a3f	2b f9		 sub	 edi, ecx
  01a41	8b c1		 mov	 eax, ecx
  01a43	8b f7		 mov	 esi, edi
  01a45	8b fa		 mov	 edi, edx
  01a47	c1 e9 02	 shr	 ecx, 2
  01a4a	f3 a5		 rep movsd
  01a4c	8b c8		 mov	 ecx, eax
  01a4e	83 e1 03	 and	 ecx, 3
  01a51	f3 a4		 rep movsb

; 3172 : 	memcpy((output_array+(ret_value->output_pos+ret_value->output_offset)),buf,length);

  01a53	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _length$[esp+112]
  01a5a	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  01a5d	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  01a60	03 fd		 add	 edi, ebp
  01a62	8b d1		 mov	 edx, ecx
  01a64	8d 74 24 10	 lea	 esi, DWORD PTR _buf$[esp+116]
  01a68	03 f8		 add	 edi, eax
  01a6a	c1 e9 02	 shr	 ecx, 2
  01a6d	f3 a5		 rep movsd
  01a6f	8b ca		 mov	 ecx, edx
  01a71	83 e1 03	 and	 ecx, 3
  01a74	f3 a4		 rep movsb

; 3173 : 	/* add the length of the inserted atring to the offset */
; 3174 : 	ret_value->output_offset+=length;

  01a76	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _length$[esp+112]
  01a7d	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  01a80	03 c8		 add	 ecx, eax
  01a82	5f		 pop	 edi
  01a83	5e		 pop	 esi
  01a84	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx
  01a87	5d		 pop	 ebp
  01a88	5b		 pop	 ebx

; 3175 : #ifdef DEBUG
; 3176 : 	printf("leaving par_insert_string_after insert after is done\n");
; 3177 : #endif
; 3178 : 	return;
; 3179 : }                                                                             

  01a89	83 c4 64	 add	 esp, 100		; 00000064H
  01a8c	c3		 ret	 0
_par_insert_string_after ENDP
_current_rule$ = 8
_output_array$ = 16
_output_indexes$ = 24
_match_array$ = 28
_ret_value$ = 32
_range_value$ = 36
_in_rule_index$ = 48
_length$ = 48
_buf$ = -100
_par_insert_string_before PROC NEAR

; 3223 : 	int length;
; 3224 : 	int i,j;
; 3225 : 	unsigned char buf[100];           
; 3226 : 	
; 3227 : #ifdef DEBUG
; 3228 : 	printf("entering par_insert_string_before\n");
; 3229 : #endif
; 3230 : 	/*
; 3231 : 	*	check the input values
; 3232 : 	*/
; 3233 : #ifdef SANITY_CHECKING
; 3234 : 	if (ret_value==NULL)
; 3235 : 	{
; 3236 : #ifdef DEBUG
; 3237 : 		printf("leaving par_insert_string_before ret_value is NULL\n");
; 3238 : #endif
; 3239 : 		return;
; 3240 : 	}
; 3241 : 	if ((current_rule==NULL) || (output_array==NULL) || (match_array==NULL))
; 3242 : 	{
; 3243 : 		ret_value->value=FATAL_FAIL;
; 3244 : #ifdef DEBUG
; 3245 : 		printf("leaving par_insert_string_before; inputs are invalid\n");
; 3246 : #endif
; 3247 : 		return;
; 3248 : 	}
; 3249 : #endif
; 3250 : 	
; 3251 : 	/* build the string to be inserted before the input string */
; 3252 : #ifndef GERMAN_COMPOUND_NOUNS
; 3253 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_BEFORE,&length,in_rule_index);
; 3254 : #else
; 3255 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_INSERT | BIN_BEFORE_FLAG,&length,in_rule_index);

  01a90	8b 44 24 2c	 mov	 eax, DWORD PTR _in_rule_index$[esp-4]
  01a94	83 ec 64	 sub	 esp, 100		; 00000064H
  01a97	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR _range_value$[esp+96]
  01a9e	8d 8c 24 90 00
	00 00		 lea	 ecx, DWORD PTR _length$[esp+96]
  01aa5	53		 push	 ebx
  01aa6	8b 9c 24 84 00
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+100]
  01aad	55		 push	 ebp
  01aae	8b 6c 24 78	 mov	 ebp, DWORD PTR _output_array$[esp+104]
  01ab2	56		 push	 esi
  01ab3	57		 push	 edi
  01ab4	50		 push	 eax
  01ab5	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR _match_array$[esp+116]
  01abc	51		 push	 ecx
  01abd	6a 3a		 push	 58			; 0000003aH
  01abf	52		 push	 edx
  01ac0	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR _current_rule$[esp+128]
  01ac7	53		 push	 ebx
  01ac8	50		 push	 eax
  01ac9	8d 4c 24 28	 lea	 ecx, DWORD PTR _buf$[esp+140]
  01acd	55		 push	 ebp
  01ace	51		 push	 ecx
  01acf	52		 push	 edx
  01ad0	e8 00 00 00 00	 call	 _par_build_string_from_rule

; 3256 : #endif
; 3257 : 	/* move the current string length characters to the right to make room for the insert string */
; 3258 : 	j=ret_value->output_pos+ret_value->output_offset;

  01ad5	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 3259 : 	for (i=j-1;i>=ret_value->output_pos;i--)

  01ad8	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  01adb	8b 94 24 ac 00
	00 00		 mov	 edx, DWORD PTR _output_indexes$[esp+148]
  01ae2	83 c4 24	 add	 esp, 36			; 00000024H
  01ae5	8d 44 01 ff	 lea	 eax, DWORD PTR [ecx+eax-1]
  01ae9	3b c1		 cmp	 eax, ecx
  01aeb	7c 45		 jl	 SHORT $L72113
  01aed	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  01af0	8d 34 4a	 lea	 esi, DWORD PTR [edx+ecx*2]
$L72111:

; 3260 : 	{
; 3261 : 		output_array[i+length]=output_array[i];

  01af3	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _length$[esp+112]
  01afa	8d 3c 08	 lea	 edi, DWORD PTR [eax+ecx]
  01afd	8a 0c 28	 mov	 cl, BYTE PTR [eax+ebp]
  01b00	88 0c 2f	 mov	 BYTE PTR [edi+ebp], cl

; 3262 : 		par_copy_index(output_indexes,i+length,output_indexes,i);

  01b03	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _length$[esp+112]
  01b0a	03 c8		 add	 ecx, eax
  01b0c	48		 dec	 eax
  01b0d	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  01b10	8d 14 4a	 lea	 edx, DWORD PTR [edx+ecx*2]
  01b13	8b ce		 mov	 ecx, esi
  01b15	83 ee 06	 sub	 esi, 6
  01b18	8b 39		 mov	 edi, DWORD PTR [ecx]
  01b1a	89 3a		 mov	 DWORD PTR [edx], edi
  01b1c	66 8b 49 04	 mov	 cx, WORD PTR [ecx+4]
  01b20	66 89 4a 04	 mov	 WORD PTR [edx+4], cx
  01b24	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  01b27	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR _output_indexes$[esp+112]
  01b2e	3b c1		 cmp	 eax, ecx
  01b30	7d c1		 jge	 SHORT $L72111
$L72113:

; 3263 : 	}
; 3264 : 	/* insert the string */
; 3265 : 	memcpy((output_array+(ret_value->output_pos)),buf,length);

  01b32	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _length$[esp+112]
  01b39	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  01b3c	8b c1		 mov	 eax, ecx
  01b3e	8d 74 24 10	 lea	 esi, DWORD PTR _buf$[esp+116]
  01b42	03 fd		 add	 edi, ebp
  01b44	c1 e9 02	 shr	 ecx, 2
  01b47	f3 a5		 rep movsd
  01b49	8b c8		 mov	 ecx, eax
  01b4b	83 e1 03	 and	 ecx, 3
  01b4e	f3 a4		 rep movsb

; 3266 : 	for (i=0;i<length;i++)

  01b50	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _length$[esp+112]
  01b57	33 c9		 xor	 ecx, ecx
  01b59	85 c0		 test	 eax, eax
  01b5b	7e 2b		 jle	 SHORT $L73143

; 3267 : 	{
; 3268 : 		par_copy_index(output_indexes,ret_value->output_pos+i,output_indexes,PAR_MAX_OUTPUT_ARRAY-1);

  01b5d	8d b2 12 15 00
	00		 lea	 esi, DWORD PTR [edx+5394]
$L72114:
  01b63	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  01b66	8b fe		 mov	 edi, esi
  01b68	03 c1		 add	 eax, ecx
  01b6a	41		 inc	 ecx
  01b6b	8b 2f		 mov	 ebp, DWORD PTR [edi]
  01b6d	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  01b70	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  01b73	89 28		 mov	 DWORD PTR [eax], ebp
  01b75	66 8b 7f 04	 mov	 di, WORD PTR [edi+4]
  01b79	66 89 78 04	 mov	 WORD PTR [eax+4], di
  01b7d	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _length$[esp+112]
  01b84	3b c8		 cmp	 ecx, eax
  01b86	7c db		 jl	 SHORT $L72114
$L73143:

; 3269 : 	}
; 3270 : 	/* add the length of the inserted string to the offset */
; 3271 : 	ret_value->output_offset+=length;

  01b88	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  01b8b	5f		 pop	 edi
  01b8c	03 c8		 add	 ecx, eax
  01b8e	5e		 pop	 esi
  01b8f	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx
  01b92	5d		 pop	 ebp
  01b93	5b		 pop	 ebx

; 3272 : 	//	ret_value->rule++;
; 3273 : #ifdef DEBUG
; 3274 : 	printf("leaving par_insert_string_before; insert before is done\n");
; 3275 : #endif
; 3276 : 	return;
; 3277 : }    

  01b94	83 c4 64	 add	 esp, 100		; 00000064H
  01b97	c3		 ret	 0
_par_insert_string_before ENDP
_output_array$ = 16
_match_array$ = 28
_ret_value$ = 32
_save_num$ = 40
_par_save_string PROC NEAR

; 3317 : 	/* this should be the last thing in the output array, but to be sure strncpy is used */
; 3318 : #ifdef DEBUG
; 3319 : 	printf("entering par_save_string\n");
; 3320 : #endif
; 3321 : 	/* 
; 3322 : 	*	check the input values 
; 3323 : 	*/
; 3324 : #ifdef SANITY_CHECKING
; 3325 : 	if (ret_value==NULL)
; 3326 : 	{
; 3327 : #ifdef DEBUG
; 3328 : 		printf("leaving par_save_string ret_value is NULL\n");
; 3329 : #endif
; 3330 : 		return;
; 3331 : 	}
; 3332 : 	if ((output_array==NULL) || (match_array==NULL))
; 3333 : 	{
; 3334 : 		ret_value->value=FATAL_FAIL;
; 3335 : #ifdef DEBUG
; 3336 : 		printf("leaving par_save_string; inputs are invalid\n");
; 3337 : #endif
; 3338 : 		return;
; 3339 : 	}
; 3340 : 	if (save_num<0 || save_num >PAR_MAX_ARRAYS)
; 3341 : 	{
; 3342 : 		printf("$%d is out of range\n",save_num);
; 3343 : 		ret_value->value=FATAL_FAIL;
; 3344 : 		return;
; 3345 : 	}
; 3346 : #endif
; 3347 : 	
; 3348 : 	/* MGS BATS #449 */
; 3349 : 	if (ret_value->output_offset>=PAR_MAX_MATCH_ARRAY)

  01ba0	8b 54 24 1c	 mov	 edx, DWORD PTR _ret_value$[esp-4]
  01ba4	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  01ba7	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  01baa	7c 08		 jl	 SHORT $L72142

; 3350 : 	{
; 3351 : 		ret_value->value=FATAL_FAIL;

  01bac	c7 42 14 04 00
	00 00		 mov	 DWORD PTR [edx+20], 4

; 3359 : #ifdef DEBUG
; 3360 : 	printf("leaving par_save_string; string is saved in array %d\n",save_num);
; 3361 : #endif
; 3362 : 	return;
; 3363 : }

  01bb3	c3		 ret	 0
$L72142:
  01bb4	53		 push	 ebx

; 3352 : 		return;
; 3353 : 	}
; 3354 : 	/* copy the output string to the temporoar array num */
; 3355 : 	memcpy(match_array->array[save_num],(output_array+(ret_value->output_pos)),ret_value->output_offset);

  01bb5	8b 5c 24 28	 mov	 ebx, DWORD PTR _save_num$[esp]
  01bb9	55		 push	 ebp
  01bba	56		 push	 esi
  01bbb	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  01bbe	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  01bc1	57		 push	 edi
  01bc2	8b 7c 24 1c	 mov	 edi, DWORD PTR _output_array$[esp+12]
  01bc6	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  01bc9	03 f7		 add	 esi, edi
  01bcb	8b 7c 24 28	 mov	 edi, DWORD PTR _match_array$[esp+12]
  01bcf	8b e9		 mov	 ebp, ecx
  01bd1	d1 e0		 shl	 eax, 1
  01bd3	c1 e9 02	 shr	 ecx, 2
  01bd6	8d 7c 38 28	 lea	 edi, DWORD PTR [eax+edi+40]
  01bda	f3 a5		 rep movsd
  01bdc	8b cd		 mov	 ecx, ebp
  01bde	83 e1 03	 and	 ecx, 3
  01be1	f3 a4		 rep movsb

; 3356 : 	match_array->array_lengths[save_num]=ret_value->output_offset;

  01be3	8b 4c 24 28	 mov	 ecx, DWORD PTR _match_array$[esp+12]
  01be7	8b 72 0c	 mov	 esi, DWORD PTR [edx+12]

; 3357 : 	/* null terminate the string */
; 3358 : 	match_array->array[save_num][ret_value->output_offset]='\0';

  01bea	03 c1		 add	 eax, ecx
  01bec	5f		 pop	 edi
  01bed	89 34 99	 mov	 DWORD PTR [ecx+ebx*4], esi
  01bf0	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  01bf3	5e		 pop	 esi
  01bf4	5d		 pop	 ebp
  01bf5	c6 44 08 28 00	 mov	 BYTE PTR [eax+ecx+40], 0
  01bfa	5b		 pop	 ebx

; 3359 : #ifdef DEBUG
; 3360 : 	printf("leaving par_save_string; string is saved in array %d\n",save_num);
; 3361 : #endif
; 3362 : 	return;
; 3363 : }

  01bfb	c3		 ret	 0
_par_save_string ENDP
_TEXT	ENDS
PUBLIC	_par_search_for_word
_TEXT	SEGMENT
_current_rule$ = 8
_input_array$ = 12
_output_array$ = 16
_input_indexes$ = 20
_output_indexes$ = 24
_match_array$ = 28
_ret_value$ = 32
_dict_num$ = 40
_dict_state_flag$ = 44
_in_rule_index$ = 48
_par_dom_dict_search PROC NEAR

; 3408 : {

  01c00	53		 push	 ebx
  01c01	55		 push	 ebp

; 3409 : 	int	ipos,opos;
; 3410 : 	int	result=FAIL;
; 3411 : #ifdef DEBUG
; 3412 : 	printf("entering par_dom_dict_search\n");
; 3413 : #endif
; 3414 : 	ipos=ret_value->input_pos;
; 3415 : 	opos=ret_value->output_pos;

  01c02	8b 6c 24 24	 mov	 ebp, DWORD PTR _ret_value$[esp+4]
  01c06	56		 push	 esi
  01c07	57		 push	 edi

; 3416 : 	
; 3417 : 	/* MGS BATS #449 */
; 3418 : 	if (ret_value->input_offset>=PAR_MAX_MATCH_ARRAY)

  01c08	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  01c0b	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  01c0e	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  01c11	7c 0c		 jl	 SHORT $L72171
  01c13	5f		 pop	 edi

; 3419 : 	{
; 3420 : 		ret_value->value=FATAL_FAIL;

  01c14	c7 45 14 04 00
	00 00		 mov	 DWORD PTR [ebp+20], 4
  01c1b	5e		 pop	 esi
  01c1c	5d		 pop	 ebp
  01c1d	5b		 pop	 ebx

; 3515 : 	}       
; 3516 : #ifdef DEBUG
; 3517 : 	printf("leaving par_dom_dict_search\n");
; 3518 : 	par_print_rule_error("",current_rule,ret_value->rule);
; 3519 : #endif
; 3520 : }

  01c1e	c3		 ret	 0
$L72171:

; 3421 : #ifdef DEBUG
; 3422 : 		printf("leaving par_dom_dict_search fatal failure of the rule\n");
; 3423 : #endif
; 3424 : 		return;
; 3425 : 	}
; 3426 : 	if (ret_value->output_offset>=PAR_MAX_MATCH_ARRAY)

  01c1f	83 7d 0c 1e	 cmp	 DWORD PTR [ebp+12], 30	; 0000001eH
  01c23	7c 0c		 jl	 SHORT $L72172
  01c25	5f		 pop	 edi

; 3427 : 	{
; 3428 : 		ret_value->value=FATAL_FAIL;

  01c26	c7 45 14 04 00
	00 00		 mov	 DWORD PTR [ebp+20], 4
  01c2d	5e		 pop	 esi
  01c2e	5d		 pop	 ebp
  01c2f	5b		 pop	 ebx

; 3515 : 	}       
; 3516 : #ifdef DEBUG
; 3517 : 	printf("leaving par_dom_dict_search\n");
; 3518 : 	par_print_rule_error("",current_rule,ret_value->rule);
; 3519 : #endif
; 3520 : }

  01c30	c3		 ret	 0
$L72172:

; 3429 : #ifdef DEBUG
; 3430 : 		printf("leaving par_dom_dict_search fatal failure of the rule\n");
; 3431 : #endif
; 3432 : 		return;
; 3433 : 	}
; 3434 : 	memcpy(match_array->array[7],input_array+ipos,ret_value->input_offset);

  01c31	8b 75 00	 mov	 esi, DWORD PTR [ebp]
  01c34	8b 7c 24 18	 mov	 edi, DWORD PTR _input_array$[esp+12]
  01c38	8b 5c 24 28	 mov	 ebx, DWORD PTR _match_array$[esp+12]
  01c3c	8b c1		 mov	 eax, ecx
  01c3e	03 f7		 add	 esi, edi
  01c40	8d bb fa 00 00
	00		 lea	 edi, DWORD PTR [ebx+250]
  01c46	c1 e9 02	 shr	 ecx, 2
  01c49	f3 a5		 rep movsd
  01c4b	8b c8		 mov	 ecx, eax
  01c4d	83 e1 03	 and	 ecx, 3
  01c50	f3 a4		 rep movsb

; 3435 : 	match_array->array[7][ret_value->input_offset]='\0';

  01c52	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]

; 3436 : 	match_array->array_lengths[7]=ret_value->input_offset;
; 3437 : 	memcpy(match_array->array[8],output_array+opos,ret_value->output_offset);

  01c55	8b 74 24 1c	 mov	 esi, DWORD PTR _output_array$[esp+12]
  01c59	03 f2		 add	 esi, edx
  01c5b	c6 84 19 fa 00
	00 00 00	 mov	 BYTE PTR [ecx+ebx+250], 0
  01c63	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  01c66	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  01c69	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01c6c	8d 83 18 01 00
	00		 lea	 eax, DWORD PTR [ebx+280]
  01c72	8b d1		 mov	 edx, ecx
  01c74	8b f8		 mov	 edi, eax
  01c76	c1 e9 02	 shr	 ecx, 2
  01c79	f3 a5		 rep movsd
  01c7b	8b ca		 mov	 ecx, edx
  01c7d	83 e1 03	 and	 ecx, 3
  01c80	f3 a4		 rep movsb

; 3438 : 	match_array->array[8][ret_value->output_offset]='\0';

  01c82	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]

; 3439 : 	match_array->array_lengths[8]=ret_value->output_offset;
; 3440 : 	result=par_search_for_word(match_array->array[8],ret_value->output_offset,match_array->array[9],dict_num,dict_state_flag);

  01c85	8b 74 24 38	 mov	 esi, DWORD PTR _dict_state_flag$[esp+12]
  01c89	8d bb 36 01 00
	00		 lea	 edi, DWORD PTR [ebx+310]
  01c8f	56		 push	 esi
  01c90	c6 84 19 18 01
	00 00 00	 mov	 BYTE PTR [ecx+ebx+280], 0
  01c98	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01c9b	8b 4c 24 38	 mov	 ecx, DWORD PTR _dict_num$[esp+16]
  01c9f	89 53 20	 mov	 DWORD PTR [ebx+32], edx
  01ca2	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01ca5	51		 push	 ecx
  01ca6	57		 push	 edi
  01ca7	52		 push	 edx
  01ca8	50		 push	 eax
  01ca9	e8 00 00 00 00	 call	 _par_search_for_word

; 3441 : 	if (dict_state_flag)

  01cae	33 d2		 xor	 edx, edx
  01cb0	83 c4 14	 add	 esp, 20			; 00000014H
  01cb3	3b f2		 cmp	 esi, edx
  01cb5	74 14		 je	 SHORT $L72173

; 3442 : 	{
; 3443 : 		if (result)

  01cb7	3b c2		 cmp	 eax, edx
  01cb9	0f 84 c1 00 00
	00		 je	 $L72179
  01cbf	5f		 pop	 edi

; 3444 : 		{
; 3445 : #ifdef DEBUG
; 3446 : 			printf("leaving par_dom_dict_search 1 success\n");
; 3447 : #endif
; 3448 : 			ret_value->value=SUCCESS;

  01cc0	c7 45 14 01 00
	00 00		 mov	 DWORD PTR [ebp+20], 1
  01cc7	5e		 pop	 esi
  01cc8	5d		 pop	 ebp
  01cc9	5b		 pop	 ebx

; 3515 : 	}       
; 3516 : #ifdef DEBUG
; 3517 : 	printf("leaving par_dom_dict_search\n");
; 3518 : 	par_print_rule_error("",current_rule,ret_value->rule);
; 3519 : #endif
; 3520 : }

  01cca	c3		 ret	 0
$L72173:

; 3449 : 			return;
; 3450 : 		}
; 3451 : #ifdef DEBUG
; 3452 : 		printf("leaving par_dom_dict_search 1 failure\n");
; 3453 : #endif
; 3454 : 		return;		
; 3455 : 	}
; 3456 : 	if (result==1)

  01ccb	83 f8 01	 cmp	 eax, 1
  01cce	75 6e		 jne	 SHORT $L72175

; 3457 : 	{
; 3458 : 		match_array->array_lengths[9]=strlen(match_array->array[9]);

  01cd0	83 c9 ff	 or	 ecx, -1
  01cd3	33 c0		 xor	 eax, eax
  01cd5	f2 ae		 repne scasb

; 3459 : 		if (current_rule[in_rule_index] & BIN_DICT_HIT_FAIL)

  01cd7	8b 74 24 14	 mov	 esi, DWORD PTR _current_rule$[esp+12]
  01cdb	8b 7c 24 3c	 mov	 edi, DWORD PTR _in_rule_index$[esp+12]
  01cdf	f7 d1		 not	 ecx
  01ce1	49		 dec	 ecx
  01ce2	89 4b 24	 mov	 DWORD PTR [ebx+36], ecx
  01ce5	8a 04 3e	 mov	 al, BYTE PTR [esi+edi]
  01ce8	a8 80		 test	 al, 128			; 00000080H
  01cea	74 1b		 je	 SHORT $L72178
$L73147:

; 3460 : 		{
; 3461 : 			ret_value->value=FAIL;
; 3462 : 			if (ret_value->optional==1)

  01cec	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  01cef	89 55 14	 mov	 DWORD PTR [ebp+20], edx
  01cf2	83 f8 01	 cmp	 eax, 1
  01cf5	0f 85 85 00 00
	00		 jne	 $L72179
  01cfb	5f		 pop	 edi

; 3463 : 			{
; 3464 : #ifdef DEBUG
; 3465 : 				printf("par_dom_dict_search hit set optinal to -1\n");
; 3466 : #endif
; 3467 : //				ret_value->optional= -1;
; 3468 : 				ret_value->value=OPT_FAIL;

  01cfc	c7 45 14 02 00
	00 00		 mov	 DWORD PTR [ebp+20], 2
  01d03	5e		 pop	 esi
  01d04	5d		 pop	 ebp
  01d05	5b		 pop	 ebx

; 3515 : 	}       
; 3516 : #ifdef DEBUG
; 3517 : 	printf("leaving par_dom_dict_search\n");
; 3518 : 	par_print_rule_error("",current_rule,ret_value->rule);
; 3519 : #endif
; 3520 : }

  01d06	c3		 ret	 0
$L72178:

; 3469 : 				return;
; 3470 : 			}
; 3471 : 			else
; 3472 : 			{
; 3473 : #ifdef DEBUG
; 3474 : 				par_print_rule_error("",current_rule,ret_value->rule);
; 3475 : 				printf("leaving par_dom_dict_search because of a fail hit_action\n");
; 3476 : #endif
; 3477 : 				return;
; 3478 : 			}
; 3479 : 		}
; 3480 : 		ret_value->input_offset=0;	/* reset for rematching */
; 3481 : 		ret_value->output_offset=0; /* reset for rematching */
; 3482 : 		par_match_rule(current_rule,BIN_COPY,input_array,output_array,input_indexes,output_indexes,match_array,ret_value,dict_state_flag);

  01d07	8b 44 24 24	 mov	 eax, DWORD PTR _output_indexes$[esp+12]
  01d0b	8b 4c 24 20	 mov	 ecx, DWORD PTR _input_indexes$[esp+12]
  01d0f	52		 push	 edx
  01d10	55		 push	 ebp
  01d11	89 55 04	 mov	 DWORD PTR [ebp+4], edx
  01d14	89 55 0c	 mov	 DWORD PTR [ebp+12], edx
  01d17	8b 54 24 24	 mov	 edx, DWORD PTR _output_array$[esp+20]
  01d1b	53		 push	 ebx
  01d1c	50		 push	 eax
  01d1d	8b 44 24 28	 mov	 eax, DWORD PTR _input_array$[esp+28]
  01d21	51		 push	 ecx
  01d22	52		 push	 edx
  01d23	50		 push	 eax
  01d24	6a 14		 push	 20			; 00000014H
  01d26	56		 push	 esi
  01d27	e8 00 00 00 00	 call	 _par_match_rule

; 3483 : #ifdef DEBUG
; 3484 : 		printf("input_off = %d output_off =%d\n",ret_value->input_offset,ret_value->output_offset);
; 3485 : #endif
; 3486 : 		/* skip the miss_action */ /* copy the code for this from the compiler */
; 3487 : 		ret_value->rule=current_rule[in_rule_index+4]+1;

  01d2c	33 c9		 xor	 ecx, ecx
  01d2e	83 c4 24	 add	 esp, 36			; 00000024H
  01d31	8a 4c 3e 04	 mov	 cl, BYTE PTR [esi+edi+4]
  01d35	41		 inc	 ecx
  01d36	5f		 pop	 edi
  01d37	89 4d 10	 mov	 DWORD PTR [ebp+16], ecx
  01d3a	5e		 pop	 esi
  01d3b	5d		 pop	 ebp
  01d3c	5b		 pop	 ebx

; 3515 : 	}       
; 3516 : #ifdef DEBUG
; 3517 : 	printf("leaving par_dom_dict_search\n");
; 3518 : 	par_print_rule_error("",current_rule,ret_value->rule);
; 3519 : #endif
; 3520 : }

  01d3d	c3		 ret	 0
$L72175:

; 3488 : 	}
; 3489 : 	else    /* if (result==1) */
; 3490 : 	{
; 3491 : 		ret_value->rule=current_rule[in_rule_index+3]+1;

  01d3e	8b 44 24 14	 mov	 eax, DWORD PTR _current_rule$[esp+12]
  01d42	8b 74 24 3c	 mov	 esi, DWORD PTR _in_rule_index$[esp+12]
  01d46	33 c9		 xor	 ecx, ecx
  01d48	8a 4c 30 03	 mov	 cl, BYTE PTR [eax+esi+3]
  01d4c	41		 inc	 ecx
  01d4d	89 4d 10	 mov	 DWORD PTR [ebp+16], ecx

; 3492 : 		
; 3493 : 		/* skip the hit action state */ /* copy the code for this from the compiler */
; 3494 : 		if (current_rule[in_rule_index] & BIN_DICT_MISS_FAIL)

  01d50	8a 0c 30	 mov	 cl, BYTE PTR [eax+esi]
  01d53	f6 c1 40	 test	 cl, 64			; 00000040H

; 3495 : 		{
; 3496 : 			ret_value->value=FAIL;
; 3497 : 			if (ret_value->optional==1)
; 3498 : 			{
; 3499 : #ifdef DEBUG
; 3500 : 				printf("par_dom_dict_search miss set optinal to -1\n");
; 3501 : #endif
; 3502 : //				ret_value->optional= -1;
; 3503 : 				ret_value->value=OPT_FAIL;
; 3504 : 				return;

  01d56	75 94		 jne	 SHORT $L73147

; 3505 : 			}
; 3506 : #ifdef DEBUG
; 3507 : 			printf("leaving par_dom_dict_search because of a fail miss_action\n");
; 3508 : 			par_print_rule_error("",current_rule,ret_value->rule);
; 3509 : #endif
; 3510 : 			return;
; 3511 : 		}
; 3512 : 		ret_value->input_offset=0;	/* reset for rematching */
; 3513 : 		ret_value->output_offset=0; /* reset for rematching */
; 3514 : 		par_match_rule(current_rule,BIN_COPY,input_array,output_array,input_indexes,output_indexes,match_array,ret_value,dict_state_flag);

  01d58	8b 4c 24 20	 mov	 ecx, DWORD PTR _input_indexes$[esp+12]
  01d5c	89 55 04	 mov	 DWORD PTR [ebp+4], edx
  01d5f	89 55 0c	 mov	 DWORD PTR [ebp+12], edx
  01d62	52		 push	 edx
  01d63	8b 54 24 28	 mov	 edx, DWORD PTR _output_indexes$[esp+16]
  01d67	55		 push	 ebp
  01d68	53		 push	 ebx
  01d69	52		 push	 edx
  01d6a	8b 54 24 2c	 mov	 edx, DWORD PTR _output_array$[esp+28]
  01d6e	51		 push	 ecx
  01d6f	8b 4c 24 2c	 mov	 ecx, DWORD PTR _input_array$[esp+32]
  01d73	52		 push	 edx
  01d74	51		 push	 ecx
  01d75	6a 14		 push	 20			; 00000014H
  01d77	50		 push	 eax
  01d78	e8 00 00 00 00	 call	 _par_match_rule
  01d7d	83 c4 24	 add	 esp, 36			; 00000024H
$L72179:
  01d80	5f		 pop	 edi
  01d81	5e		 pop	 esi
  01d82	5d		 pop	 ebp
  01d83	5b		 pop	 ebx

; 3515 : 	}       
; 3516 : #ifdef DEBUG
; 3517 : 	printf("leaving par_dom_dict_search\n");
; 3518 : 	par_print_rule_error("",current_rule,ret_value->rule);
; 3519 : #endif
; 3520 : }

  01d84	c3		 ret	 0
_par_dom_dict_search ENDP
_TEXT	ENDS
PUBLIC	_par_look_ahead_dictionary
_TEXT	SEGMENT
_current_rule$ = 8
_input_array$ = 12
_match_array$ = 16
_ret_value$ = 20
_temp_output$ = -700
_temp_indexes$ = -600
_par_look_ahead_dictionary PROC NEAR

; 3548 : {           

  01d90	81 ec bc 02 00
	00		 sub	 esp, 700		; 000002bcH

; 3549 : 	unsigned char temp_output[100];
; 3550 : 	index_data_t temp_indexes[100]; 
; 3551 : #ifdef DEBUG
; 3552 : 	printf("entering par_look_ahead_dictionary\n");
; 3553 : #endif
; 3554 : 	ret_value->output_pos=0;

  01d96	33 c0		 xor	 eax, eax

; 3555 : 	ret_value->output_offset=0;
; 3556 : 	ret_value->value=SUCCESS;	
; 3557 : 	par_match_rule(current_rule,BIN_DICTIONARY,input_array,temp_output,temp_indexes,temp_indexes,match_array,ret_value,1);

  01d98	8d 4c 24 64	 lea	 ecx, DWORD PTR _temp_indexes$[esp+700]
  01d9c	8d 54 24 64	 lea	 edx, DWORD PTR _temp_indexes$[esp+700]
  01da0	56		 push	 esi
  01da1	8b b4 24 d0 02
	00 00		 mov	 esi, DWORD PTR _ret_value$[esp+700]
  01da8	6a 01		 push	 1
  01daa	56		 push	 esi
  01dab	89 46 08	 mov	 DWORD PTR [esi+8], eax
  01dae	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  01db1	8b 84 24 d4 02
	00 00		 mov	 eax, DWORD PTR _match_array$[esp+708]
  01db8	c7 46 14 01 00
	00 00		 mov	 DWORD PTR [esi+20], 1
  01dbf	50		 push	 eax
  01dc0	51		 push	 ecx
  01dc1	8b 8c 24 d8 02
	00 00		 mov	 ecx, DWORD PTR _input_array$[esp+716]
  01dc8	8d 44 24 14	 lea	 eax, DWORD PTR _temp_output$[esp+720]
  01dcc	52		 push	 edx
  01dcd	8b 94 24 d8 02
	00 00		 mov	 edx, DWORD PTR _current_rule$[esp+720]
  01dd4	50		 push	 eax
  01dd5	51		 push	 ecx
  01dd6	6a 1d		 push	 29			; 0000001dH
  01dd8	52		 push	 edx
  01dd9	e8 00 00 00 00	 call	 _par_match_rule

; 3558 : 	if (ret_value->value==SUCCESS)

  01dde	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  01de1	83 c4 24	 add	 esp, 36			; 00000024H
  01de4	33 c0		 xor	 eax, eax
  01de6	83 f9 01	 cmp	 ecx, 1
  01de9	0f 94 c0	 sete	 al
  01dec	5e		 pop	 esi

; 3559 : 	{
; 3560 : #ifdef DEBUG
; 3561 : 		printf("leaving par_look_ahead_dictionary success\n");
; 3562 : #endif
; 3563 : 		return(1);
; 3564 : 	}
; 3565 : #ifdef DEBUG
; 3566 : 	printf("leaving par_look_ahead_dictionary failure\n");
; 3567 : #endif                                                    
; 3568 : 	return(0);
; 3569 : }

  01ded	81 c4 bc 02 00
	00		 add	 esp, 700		; 000002bcH
  01df3	c3		 ret	 0
_par_look_ahead_dictionary ENDP
_TEXT	ENDS
EXTRN	_dict_point:BYTE
EXTRN	_dict_index_table:BYTE
EXTRN	_dict_data_table:BYTE
EXTRN	__imp___stricmp:NEAR
_TEXT	SEGMENT
_input$ = 8
_input_length$ = 12
_output$ = 16
_dict_num$ = 20
_dict_state_flag$ = 24
_high$ = 20
_npos$ = -4
_par_search_for_word PROC NEAR

; 3601 : {

  01e00	51		 push	 ecx

; 3602 : 	int high,low,pos=0;
; 3603 : 	int dict_number;
; 3604 : 	int value=0;
; 3605 : 	int rev_same=0,for_same=0,npos=0;
; 3606 : 	int save_for;
; 3607 : #ifdef DEBUG
; 3608 : 	printf("entering par_search_for_word\n");
; 3609 : #endif                        
; 3610 : 	dict_number=dict_num-1;	

  01e01	8b 4c 24 14	 mov	 ecx, DWORD PTR _dict_num$[esp]
  01e05	53		 push	 ebx
  01e06	55		 push	 ebp
  01e07	56		 push	 esi

; 3611 : 	low=dict_point[dict_number].start;

  01e08	8b 2c cd f8 ff
	ff ff		 mov	 ebp, DWORD PTR _dict_point[ecx*8-8]

; 3612 : 	rev_same=low;
; 3613 : 	high=dict_point[dict_number].end;

  01e0f	8b 0c cd fc ff
	ff ff		 mov	 ecx, DWORD PTR _dict_point[ecx*8-4]
  01e16	33 c0		 xor	 eax, eax
  01e18	33 f6		 xor	 esi, esi
  01e1a	57		 push	 edi

; 3614 : 	for_same=high;
; 3615 : 	while (rev_same<=for_same)

  01e1b	3b e9		 cmp	 ebp, ecx
  01e1d	89 44 24 10	 mov	 DWORD PTR _npos$[esp+20], eax
  01e21	8b fd		 mov	 edi, ebp
  01e23	89 4c 24 24	 mov	 DWORD PTR _high$[esp+16], ecx
  01e27	8b d9		 mov	 ebx, ecx
  01e29	7f 36		 jg	 SHORT $L73155
$L72215:

; 3616 : 	{
; 3617 : 		pos=((rev_same+for_same)>>1); /* divide the offset by 2 */

  01e2b	8d 34 3b	 lea	 esi, DWORD PTR [ebx+edi]

; 3618 : #ifdef DEBUG
; 3619 : 		printf("comparing %s to %d %s\n",input,pos,(unsigned char *)(dict_data_table+dict_index_table[pos]));
; 3620 : #endif
; 3621 : 		if ((value=_stricmp(input,(unsigned char *)(dict_data_table+dict_index_table[pos])))==0)

  01e2e	8b 4c 24 18	 mov	 ecx, DWORD PTR _input$[esp+16]
  01e32	d1 fe		 sar	 esi, 1
  01e34	8b 04 b5 00 00
	00 00		 mov	 eax, DWORD PTR _dict_index_table[esi*4]
  01e3b	05 00 00 00 00	 add	 eax, OFFSET FLAT:_dict_data_table
  01e40	50		 push	 eax
  01e41	51		 push	 ecx
  01e42	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___stricmp
  01e48	83 c4 08	 add	 esp, 8
  01e4b	85 c0		 test	 eax, eax
  01e4d	74 0e		 je	 SHORT $L73167

; 3622 : 		{
; 3623 : 			break;
; 3624 : 		}
; 3625 : 		else
; 3626 : 		{
; 3627 : 			if (value<0)

  01e4f	7d 05		 jge	 SHORT $L72220

; 3628 : 			{
; 3629 : 				for_same=pos-1;;

  01e51	8d 5e ff	 lea	 ebx, DWORD PTR [esi-1]

; 3630 : 			}
; 3631 : 			else

  01e54	eb 03		 jmp	 SHORT $L72221
$L72220:

; 3632 : 			{
; 3633 : 				rev_same=pos+1;

  01e56	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]
$L72221:

; 3614 : 	for_same=high;
; 3615 : 	while (rev_same<=for_same)

  01e59	3b fb		 cmp	 edi, ebx
  01e5b	7e ce		 jle	 SHORT $L72215
$L73167:
  01e5d	8b 4c 24 24	 mov	 ecx, DWORD PTR _high$[esp+16]
$L73155:

; 3634 : 			}
; 3635 : 		}
; 3636 : 	}
; 3637 : 	if (dict_state_flag)

  01e61	8b 54 24 28	 mov	 edx, DWORD PTR _dict_state_flag$[esp+16]
  01e65	85 d2		 test	 edx, edx
  01e67	74 13		 je	 SHORT $L72223

; 3638 : 	{
; 3639 : 		if (value==0)

  01e69	85 c0		 test	 eax, eax
  01e6b	0f 85 6d 01 00
	00		 jne	 $L73160
  01e71	5f		 pop	 edi
  01e72	5e		 pop	 esi
  01e73	5d		 pop	 ebp

; 3640 : 		{
; 3641 : #ifdef DEBUG
; 3642 : 			printf("leaving par_search_for_word in dict and short search\n");
; 3643 : #endif
; 3644 : 			return(1);

  01e74	b8 01 00 00 00	 mov	 eax, 1
  01e79	5b		 pop	 ebx

; 3723 : #ifdef DEBUG
; 3724 : 	printf("leaving par_search_for_word failure\n");
; 3725 : #endif
; 3726 : }

  01e7a	59		 pop	 ecx
  01e7b	c3		 ret	 0
$L72223:

; 3645 : 		}
; 3646 : 	}                                    
; 3647 : 	if (value!=0)

  01e7c	85 c0		 test	 eax, eax

; 3648 : 	{
; 3649 : #ifdef DEBUG
; 3650 : 		printf("leaving par_search_for_word not in dic\n");
; 3651 : #endif
; 3652 : 		return(0);

  01e7e	0f 85 5a 01 00
	00		 jne	 $L73160

; 3653 : 	}
; 3654 : 	/* do the case sensitive part of the search */
; 3655 : 	rev_same=pos-1;

  01e84	8d 5e ff	 lea	 ebx, DWORD PTR [esi-1]

; 3656 : 	while ((rev_same>=low) && (_stricmp(input,(unsigned char *)(dict_data_table+dict_index_table[rev_same]))==0))

  01e87	3b dd		 cmp	 ebx, ebp
  01e89	7c 2e		 jl	 SHORT $L72228

; 3653 : 	}
; 3654 : 	/* do the case sensitive part of the search */
; 3655 : 	rev_same=pos-1;

  01e8b	8d 3c 9d 00 00
	00 00		 lea	 edi, DWORD PTR _dict_index_table[ebx*4]
$L72227:

; 3656 : 	while ((rev_same>=low) && (_stricmp(input,(unsigned char *)(dict_data_table+dict_index_table[rev_same]))==0))

  01e92	8b 17		 mov	 edx, DWORD PTR [edi]
  01e94	8b 44 24 18	 mov	 eax, DWORD PTR _input$[esp+16]
  01e98	81 c2 00 00 00
	00		 add	 edx, OFFSET FLAT:_dict_data_table
  01e9e	52		 push	 edx
  01e9f	50		 push	 eax
  01ea0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___stricmp
  01ea6	83 c4 08	 add	 esp, 8
  01ea9	85 c0		 test	 eax, eax
  01eab	75 08		 jne	 SHORT $L73169

; 3657 : 	{
; 3658 : 		rev_same--;

  01ead	4b		 dec	 ebx
  01eae	83 ef 04	 sub	 edi, 4
  01eb1	3b dd		 cmp	 ebx, ebp
  01eb3	7d dd		 jge	 SHORT $L72227
$L73169:

; 3656 : 	while ((rev_same>=low) && (_stricmp(input,(unsigned char *)(dict_data_table+dict_index_table[rev_same]))==0))

  01eb5	8b 4c 24 24	 mov	 ecx, DWORD PTR _high$[esp+16]
$L72228:

; 3659 : 	}                  
; 3660 : 	for_same=pos+1;

  01eb9	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]

; 3661 : 	/* BATS 895 Fixed problem with spanish phone numbers with 9 */
; 3662 : 	while ((for_same<=high) && (_stricmp(input,(unsigned char *)(dict_data_table+dict_index_table[for_same]))==0))

  01ebc	3b f9		 cmp	 edi, ecx
  01ebe	7f 2e		 jg	 SHORT $L72232

; 3659 : 	}                  
; 3660 : 	for_same=pos+1;

  01ec0	8d 34 bd 00 00
	00 00		 lea	 esi, DWORD PTR _dict_index_table[edi*4]
$L72231:

; 3661 : 	/* BATS 895 Fixed problem with spanish phone numbers with 9 */
; 3662 : 	while ((for_same<=high) && (_stricmp(input,(unsigned char *)(dict_data_table+dict_index_table[for_same]))==0))

  01ec7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  01ec9	8b 54 24 18	 mov	 edx, DWORD PTR _input$[esp+16]
  01ecd	81 c1 00 00 00
	00		 add	 ecx, OFFSET FLAT:_dict_data_table
  01ed3	51		 push	 ecx
  01ed4	52		 push	 edx
  01ed5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___stricmp
  01edb	83 c4 08	 add	 esp, 8
  01ede	85 c0		 test	 eax, eax
  01ee0	75 0c		 jne	 SHORT $L72232
  01ee2	8b 44 24 24	 mov	 eax, DWORD PTR _high$[esp+16]

; 3663 : 	{
; 3664 : 		for_same++;

  01ee6	47		 inc	 edi
  01ee7	83 c6 04	 add	 esi, 4
  01eea	3b f8		 cmp	 edi, eax
  01eec	7e d9		 jle	 SHORT $L72231
$L72232:

; 3665 : 	}                  
; 3666 : 	rev_same++;

  01eee	43		 inc	 ebx

; 3667 : 	for_same--;    

  01eef	4f		 dec	 edi

; 3668 : 	low=rev_same;
; 3669 : 	save_for=for_same;	/* take the last insensitive match, it will be lower case it any are */
; 3670 : 	while ((for_same!=rev_same) && !(parser_char_types[dict_data_table[dict_index_table[for_same]]] & TYPE_upper))

  01ef0	3b fb		 cmp	 edi, ebx
  01ef2	8b f7		 mov	 esi, edi
  01ef4	74 28		 je	 SHORT $L73161
  01ef6	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR _dict_index_table[edi*4]
  01efd	b1 02		 mov	 cl, 2
  01eff	89 44 24 24	 mov	 DWORD PTR 20+[esp+16], eax
$L72234:
  01f03	8b 28		 mov	 ebp, DWORD PTR [eax]
  01f05	33 d2		 xor	 edx, edx
  01f07	8a 95 00 00 00
	00		 mov	 dl, BYTE PTR _dict_data_table[ebp]
  01f0d	84 0c 55 00 00
	00 00		 test	 BYTE PTR _parser_char_types[edx*2], cl
  01f14	75 44		 jne	 SHORT $L72235

; 3671 : 	{
; 3672 : 		for_same--;

  01f16	4f		 dec	 edi
  01f17	83 e8 04	 sub	 eax, 4
  01f1a	3b fb		 cmp	 edi, ebx
  01f1c	75 e5		 jne	 SHORT $L72234
$L73161:

; 3705 : 			{
; 3706 : #ifdef DEBUG
; 3707 : 				printf("leaving par_dom_dict_search capitilization doesn't match\n");
; 3708 : #endif
; 3709 : 				return(0);
; 3710 : 			}
; 3711 : 		}
; 3712 : 	}
; 3713 : 	if (value==0)
; 3714 : 	{
; 3715 : //		strcpy(output,((unsigned char *)(dict_data_table+dict_index_table[save_for]))+(strlen((unsigned char *)(dict_data_table+dict_index_table[save_for]))+1));
; 3716 : 		strcpy(output,((unsigned char *)(dict_data_table+dict_index_table[save_for]))+(input_length+1));

  01f1e	8b 04 b5 00 00
	00 00		 mov	 eax, DWORD PTR _dict_index_table[esi*4]
  01f25	8b 4c 24 1c	 mov	 ecx, DWORD PTR _input_length$[esp+16]
  01f29	8d bc 08 01 00
	00 00		 lea	 edi, DWORD PTR _dict_data_table[eax+ecx+1]
  01f30	83 c9 ff	 or	 ecx, -1
  01f33	33 c0		 xor	 eax, eax
  01f35	f2 ae		 repne scasb
  01f37	f7 d1		 not	 ecx
  01f39	2b f9		 sub	 edi, ecx

; 3717 : #ifdef DEBUG
; 3718 : 		printf("leaving par_search_for_word success\n");
; 3719 : #endif
; 3720 : 		return(1);

  01f3b	b8 01 00 00 00	 mov	 eax, 1
  01f40	8b d1		 mov	 edx, ecx
  01f42	8b f7		 mov	 esi, edi
  01f44	8b 7c 24 20	 mov	 edi, DWORD PTR _output$[esp+16]
  01f48	c1 e9 02	 shr	 ecx, 2
  01f4b	f3 a5		 rep movsd
  01f4d	8b ca		 mov	 ecx, edx
  01f4f	83 e1 03	 and	 ecx, 3
  01f52	f3 a4		 rep movsb
  01f54	5f		 pop	 edi
  01f55	5e		 pop	 esi
  01f56	5d		 pop	 ebp
  01f57	5b		 pop	 ebx

; 3723 : #ifdef DEBUG
; 3724 : 	printf("leaving par_search_for_word failure\n");
; 3725 : #endif
; 3726 : }

  01f58	59		 pop	 ecx
  01f59	c3		 ret	 0
$L72235:

; 3673 : 	}
; 3674 : 	if (rev_same!=for_same)

  01f5a	3b df		 cmp	 ebx, edi
  01f5c	74 c0		 je	 SHORT $L73161

; 3675 : 	{
; 3676 : 		while (rev_same<=for_same)

  01f5e	7f 60		 jg	 SHORT $L73162
$L72238:

; 3677 : 		{
; 3678 : 			npos=((rev_same+for_same)>>1); /* divide the offset by 2 */
; 3679 : #ifdef DEBUG
; 3680 : 			printf("comapring case %s to %d %s\n",input,npos,(unsigned char *)(dict_data_table+dict_index_table[npos]));
; 3681 : #endif
; 3682 : 			if ((value=strcmp(input,(unsigned char *)(dict_data_table+dict_index_table[npos])))==0)

  01f60	8b 74 24 18	 mov	 esi, DWORD PTR _input$[esp+16]
  01f64	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  01f67	d1 f8		 sar	 eax, 1
  01f69	89 44 24 10	 mov	 DWORD PTR _npos$[esp+20], eax
  01f6d	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _dict_index_table[eax*4]
  01f74	05 00 00 00 00	 add	 eax, OFFSET FLAT:_dict_data_table
$L73163:
  01f79	8a 16		 mov	 dl, BYTE PTR [esi]
  01f7b	8a ca		 mov	 cl, dl
  01f7d	3a 10		 cmp	 dl, BYTE PTR [eax]
  01f7f	75 1c		 jne	 SHORT $L73164
  01f81	84 c9		 test	 cl, cl
  01f83	74 14		 je	 SHORT $L73165
  01f85	8a 56 01	 mov	 dl, BYTE PTR [esi+1]
  01f88	8a ca		 mov	 cl, dl
  01f8a	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  01f8d	75 0e		 jne	 SHORT $L73164
  01f8f	83 c6 02	 add	 esi, 2
  01f92	83 c0 02	 add	 eax, 2
  01f95	84 c9		 test	 cl, cl
  01f97	75 e0		 jne	 SHORT $L73163
$L73165:
  01f99	33 c0		 xor	 eax, eax
  01f9b	eb 05		 jmp	 SHORT $L73166
$L73164:
  01f9d	1b c0		 sbb	 eax, eax
  01f9f	83 d8 ff	 sbb	 eax, -1
$L73166:
  01fa2	85 c0		 test	 eax, eax
  01fa4	74 1a		 je	 SHORT $L73162

; 3683 : 			{
; 3684 : 				break;
; 3685 : 			}
; 3686 : 			else
; 3687 : 			{
; 3688 : 				if (value<0)

  01fa6	7d 09		 jge	 SHORT $L72243

; 3689 : 				{
; 3690 : 					for_same=npos-1;

  01fa8	8b 4c 24 10	 mov	 ecx, DWORD PTR _npos$[esp+20]
  01fac	8d 79 ff	 lea	 edi, DWORD PTR [ecx-1]

; 3691 : 				}
; 3692 : 				else

  01faf	eb 07		 jmp	 SHORT $L72244
$L72243:

; 3693 : 				{
; 3694 : 					rev_same=npos+1;

  01fb1	8b 54 24 10	 mov	 edx, DWORD PTR _npos$[esp+20]
  01fb5	8d 5a 01	 lea	 ebx, DWORD PTR [edx+1]
$L72244:

; 3675 : 	{
; 3676 : 		while (rev_same<=for_same)

  01fb8	3b df		 cmp	 ebx, edi
  01fba	7e a4		 jle	 SHORT $L72238

; 3695 : 				}
; 3696 : 			}
; 3697 : 		}
; 3698 : 		if (value==0)

  01fbc	85 c0		 test	 eax, eax
  01fbe	75 09		 jne	 SHORT $L72245
$L73162:

; 3699 : 		{
; 3700 : 			save_for=npos;

  01fc0	8b 74 24 10	 mov	 esi, DWORD PTR _npos$[esp+20]

; 3701 : 		}
; 3702 : 		else

  01fc4	e9 55 ff ff ff	 jmp	 $L73161
$L72245:

; 3703 : 		{
; 3704 : 			if ((parser_char_types[dict_data_table[dict_index_table[save_for]]] & TYPE_upper))

  01fc9	8b 44 24 24	 mov	 eax, DWORD PTR 20+[esp+16]
  01fcd	33 d2		 xor	 edx, edx
  01fcf	8b 08		 mov	 ecx, DWORD PTR [eax]
  01fd1	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR _dict_data_table[ecx]
  01fd7	8a 04 55 00 00
	00 00		 mov	 al, BYTE PTR _parser_char_types[edx*2]
$L73160:
  01fde	5f		 pop	 edi
  01fdf	5e		 pop	 esi
  01fe0	5d		 pop	 ebp

; 3721 : 	}             
; 3722 : 	return(0);

  01fe1	33 c0		 xor	 eax, eax
  01fe3	5b		 pop	 ebx

; 3723 : #ifdef DEBUG
; 3724 : 	printf("leaving par_search_for_word failure\n");
; 3725 : #endif
; 3726 : }

  01fe4	59		 pop	 ecx
  01fe5	c3		 ret	 0
_par_search_for_word ENDP
_output_array$ = 16
_ret_value$ = 32
_par_check_word_string PROC NEAR

; 3765 : 	register int i;
; 3766 : 	int has_cons=0,has_vowel=0;
; 3767 : 	int temp;
; 3768 : #ifdef DEBUG
; 3769 : 	printf("entering par_check_word_string\n");
; 3770 : #endif
; 3771 : 	/*
; 3772 : 	*	check the inputs for valid data 
; 3773 : 	*/
; 3774 : #ifdef SANITY_CHECKING
; 3775 : 	if (ret_value==NULL)
; 3776 : 	{
; 3777 : #ifdef DEBUG
; 3778 : 		printf("leaving par_check_word_string ret_value is NULL\n");
; 3779 : #endif
; 3780 : 		return;
; 3781 : 	}
; 3782 : 	if ((output_array==NULL))
; 3783 : 	{
; 3784 : 		ret_value->value=FATAL_FAIL;
; 3785 : #ifdef DEBUG
; 3786 : 		printf("leaving par_check_word_string input is NULL\n");
; 3787 : #endif
; 3788 : 		return;
; 3789 : 	}                 
; 3790 : #endif
; 3791 : 	i=ret_value->output_pos;		

  01ff0	8b 54 24 1c	 mov	 edx, DWORD PTR _ret_value$[esp-4]
  01ff4	53		 push	 ebx
  01ff5	55		 push	 ebp
  01ff6	56		 push	 esi
  01ff7	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  01ffa	57		 push	 edi

; 3792 : 	/* BATS 874 MGS 03/03/1999 fixed word state */
; 3793 : 	while (i<(ret_value->output_offset+ret_value->output_pos) && ((has_cons & has_vowel)==0))

  01ffb	8b 7a 0c	 mov	 edi, DWORD PTR [edx+12]
  01ffe	33 f6		 xor	 esi, esi
  02000	03 f9		 add	 edi, ecx
  02002	33 ed		 xor	 ebp, ebp
  02004	3b cf		 cmp	 ecx, edi
  02006	7d 44		 jge	 SHORT $L72287
$L72280:
  02008	85 ee		 test	 ebp, esi
  0200a	75 32		 jne	 SHORT $L72281

; 3794 : 	{
; 3795 : 		temp=parser_char_types[output_array[i]];

  0200c	8b 5c 24 1c	 mov	 ebx, DWORD PTR _output_array$[esp+12]
  02010	33 c0		 xor	 eax, eax
  02012	8a 04 19	 mov	 al, BYTE PTR [ecx+ebx]
  02015	8b d8		 mov	 ebx, eax
  02017	33 c0		 xor	 eax, eax
  02019	66 8b 04 5d 00
	00 00 00	 mov	 ax, WORD PTR _parser_char_types[ebx*2]

; 3796 : 		if (temp & TYPE_consonant)

  02021	f6 c4 02	 test	 ah, 2
  02024	74 05		 je	 SHORT $L72282

; 3797 : 		{
; 3798 : 			has_cons=1;

  02026	be 01 00 00 00	 mov	 esi, 1
$L72282:

; 3799 : 		}
; 3800 : 		if (temp & TYPE_vowel)

  0202b	f6 c4 01	 test	 ah, 1
  0202e	74 05		 je	 SHORT $L72283

; 3801 : 		{
; 3802 : 			has_vowel=1;

  02030	bd 01 00 00 00	 mov	 ebp, 1
$L72283:

; 3803 : 		}                                
; 3804 : 		if ((temp & TYPE_alpha) == 0)

  02035	a8 08		 test	 al, 8
  02037	74 26		 je	 SHORT $L73179

; 3807 : 			{
; 3808 : 				ret_value->value=OPT_FAIL;
; 3809 : 			}
; 3810 : 			else
; 3811 : 			{	
; 3812 : 				ret_value->value=FAIL;
; 3813 : 			}
; 3814 : #ifdef DEBUG
; 3815 : 			printf("the output is not a word\n");
; 3816 : #endif
; 3817 : 			return;
; 3818 : 		}			
; 3819 : 		i++;

  02039	41		 inc	 ecx
  0203a	3b cf		 cmp	 ecx, edi
  0203c	7c ca		 jl	 SHORT $L72280
$L72281:

; 3820 : 	}
; 3821 : 	/* BATS 874 MGS 03/03/1999 fixed word state */
; 3822 : 	if (has_cons && has_vowel && (ret_value->output_offset)>=2)

  0203e	85 f6		 test	 esi, esi
  02040	74 0a		 je	 SHORT $L72287
  02042	85 ed		 test	 ebp, ebp
  02044	74 06		 je	 SHORT $L72287
  02046	83 7a 0c 02	 cmp	 DWORD PTR [edx+12], 2
  0204a	7d 2d		 jge	 SHORT $L72290
$L72287:

; 3823 : 	{
; 3824 : #ifdef DEBUG
; 3825 : 		printf("the output may be a word\n");
; 3826 : #endif
; 3827 : 	}         
; 3828 : 	else
; 3829 : 	{
; 3830 : 		if (ret_value->optional)

  0204c	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0204f	85 c0		 test	 eax, eax
  02051	74 1f		 je	 SHORT $L72285
  02053	5f		 pop	 edi
  02054	5e		 pop	 esi
  02055	5d		 pop	 ebp

; 3831 : 		{
; 3832 : 			ret_value->value=OPT_FAIL;

  02056	c7 42 14 02 00
	00 00		 mov	 DWORD PTR [edx+20], 2
  0205d	5b		 pop	 ebx

; 3837 : 		}
; 3838 : #ifdef DEBUG
; 3839 : 		printf("the output is not a word\n");
; 3840 : #endif
; 3841 : 	}
; 3842 : #ifdef DEBUG
; 3843 : 	printf("leaving par_check_word_string\n");
; 3844 : #endif
; 3845 : 	return;
; 3846 : }

  0205e	c3		 ret	 0
$L73179:

; 3805 : 		{
; 3806 : 			if (ret_value->optional)

  0205f	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  02062	85 c0		 test	 eax, eax
  02064	74 0c		 je	 SHORT $L72285
  02066	5f		 pop	 edi
  02067	5e		 pop	 esi
  02068	5d		 pop	 ebp

; 3831 : 		{
; 3832 : 			ret_value->value=OPT_FAIL;

  02069	c7 42 14 02 00
	00 00		 mov	 DWORD PTR [edx+20], 2
  02070	5b		 pop	 ebx

; 3837 : 		}
; 3838 : #ifdef DEBUG
; 3839 : 		printf("the output is not a word\n");
; 3840 : #endif
; 3841 : 	}
; 3842 : #ifdef DEBUG
; 3843 : 	printf("leaving par_check_word_string\n");
; 3844 : #endif
; 3845 : 	return;
; 3846 : }

  02071	c3		 ret	 0
$L72285:

; 3833 : 		}
; 3834 : 		else
; 3835 : 		{	
; 3836 : 			ret_value->value=FAIL;

  02072	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0
$L72290:
  02079	5f		 pop	 edi
  0207a	5e		 pop	 esi
  0207b	5d		 pop	 ebp
  0207c	5b		 pop	 ebx

; 3837 : 		}
; 3838 : #ifdef DEBUG
; 3839 : 		printf("the output is not a word\n");
; 3840 : #endif
; 3841 : 	}
; 3842 : #ifdef DEBUG
; 3843 : 	printf("leaving par_check_word_string\n");
; 3844 : #endif
; 3845 : 	return;
; 3846 : }

  0207d	c3		 ret	 0
_par_check_word_string ENDP
_TEXT	ENDS
EXTRN	__imp__atoi:NEAR
_TEXT	SEGMENT
_current_rule$ = 8
_output_array$ = 16
_match_array$ = 28
_ret_value$ = 32
_range_value$ = 36
_in_rule_index$ = 48
_length$ = -16
_buf$ = -12
_par_status_string PROC NEAR

; 3865 : {

  02080	83 ec 10	 sub	 esp, 16			; 00000010H

; 3866 : 	int length=0;
; 3867 : 	unsigned char buf[10];
; 3868 : 
; 3869 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_STATUS,&length,in_rule_index);

  02083	8b 44 24 3c	 mov	 eax, DWORD PTR _in_rule_index$[esp+12]
  02087	8b 54 24 30	 mov	 edx, DWORD PTR _range_value$[esp+12]
  0208b	56		 push	 esi
  0208c	8b 74 24 30	 mov	 esi, DWORD PTR _ret_value$[esp+16]
  02090	8d 4c 24 04	 lea	 ecx, DWORD PTR _length$[esp+20]
  02094	50		 push	 eax
  02095	8b 44 24 30	 mov	 eax, DWORD PTR _match_array$[esp+20]
  02099	51		 push	 ecx
  0209a	8b 4c 24 28	 mov	 ecx, DWORD PTR _output_array$[esp+24]
  0209e	6a 1e		 push	 30			; 0000001eH
  020a0	52		 push	 edx
  020a1	56		 push	 esi
  020a2	50		 push	 eax
  020a3	8b 44 24 30	 mov	 eax, DWORD PTR _current_rule$[esp+40]
  020a7	8d 54 24 20	 lea	 edx, DWORD PTR _buf$[esp+44]
  020ab	51		 push	 ecx
  020ac	52		 push	 edx
  020ad	50		 push	 eax
  020ae	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _length$[esp+56], 0
  020b6	e8 00 00 00 00	 call	 _par_build_string_from_rule

; 3870 : 	ret_value->parser_flag = atoi(buf);

  020bb	8d 4c 24 2c	 lea	 ecx, DWORD PTR _buf$[esp+56]
  020bf	51		 push	 ecx
  020c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  020c6	83 c4 28	 add	 esp, 40			; 00000028H
  020c9	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  020cc	5e		 pop	 esi

; 3871 : }

  020cd	83 c4 10	 add	 esp, 16			; 00000010H
  020d0	c3		 ret	 0
_par_status_string ENDP
_TEXT	ENDS
PUBLIC	_par_convert_number_new2
_TEXT	SEGMENT
_current_rule$ = 8
_buf$ = 12
_output_array$ = 16
_match_array$ = 20
_ret_value$ = 24
_range_value$ = 28
_state$ = 32
_length$ = 36
_in_rule_index$ = 40
_buf_ind$ = -8
_end_of_action$ = -4
_end_of_build$ = 8
_par_build_string_from_rule PROC NEAR

; 3923 : {

  020e0	83 ec 08	 sub	 esp, 8
  020e3	53		 push	 ebx
  020e4	55		 push	 ebp

; 3924 : 	int is_cond=0;						/* is the current replacement conditional */
; 3925 : 	int cond_num=0;						/* what number conditioal thing to replace with */
; 3926 : 	int rule_p;							/* a temporary rule pointer */
; 3927 : 	int buf_ind=0;						/* the current index into the temp buffer */
; 3928 : 	int match_l=0;						/* the length of the string in the save array */
; 3929 : 	int match_num;						/* the index of the save array to be used */
; 3930 : 	U8 end_of_action;
; 3931 : 	U8 end_of_build;
; 3932 : 	
; 3933 : #ifdef DEBUG
; 3934 : 	printf("entering par_build_string_from_rule\n");
; 3935 : #endif
; 3936 : 	/*
; 3937 : 	*	check input values
; 3938 : 	*/
; 3939 : #ifdef SANITY_CHECKING
; 3940 : 	if (ret_value==NULL)
; 3941 : 	{
; 3942 : #ifdef DEBUG
; 3943 : 		printf("leaving par_build_string_from_rule ret_value is NULL\n");
; 3944 : #endif
; 3945 : 		return(NULL);
; 3946 : 	}
; 3947 : 	if ((current_rule==NULL) || (buf == NULL) || (match_array == NULL) ||
; 3948 : 		(state == BIN_END_OF_RULE) || (length==NULL))
; 3949 : 	{
; 3950 : #ifdef DEBUG
; 3951 : 		printf("leaving par_build_string_from_rule; inputs are invalid\n");
; 3952 : #endif
; 3953 : 		ret_value->value=FATAL_FAIL;
; 3954 : 		return(NULL);
; 3955 : 	}
; 3956 : #endif
; 3957 : 	
; 3958 : 	rule_p=ret_value->rule;
; 3959 : 	end_of_action=current_rule[in_rule_index+2];

  020e5	8b 6c 24 14	 mov	 ebp, DWORD PTR _current_rule$[esp+12]
  020e9	56		 push	 esi
  020ea	8b 74 24 38	 mov	 esi, DWORD PTR _in_rule_index$[esp+16]
  020ee	8b 4c 24 28	 mov	 ecx, DWORD PTR _ret_value$[esp+16]
  020f2	57		 push	 edi
  020f3	33 ff		 xor	 edi, edi
  020f5	8b 59 10	 mov	 ebx, DWORD PTR [ecx+16]
  020f8	8d 44 2e 02	 lea	 eax, DWORD PTR [esi+ebp+2]
  020fc	89 44 24 3c	 mov	 DWORD PTR 40+[esp+20], eax
  02100	89 7c 24 10	 mov	 DWORD PTR _buf_ind$[esp+24], edi
  02104	8a 00		 mov	 al, BYTE PTR [eax]
  02106	88 44 24 14	 mov	 BYTE PTR _end_of_action$[esp+24], al

; 3960 : 	end_of_build=end_of_action;

  0210a	88 44 24 1c	 mov	 BYTE PTR _end_of_build$[esp+20], al

; 3961 : #ifdef DEBUG
; 3962 : 	printf("current_rule[%d]=%c\n",rule_p,current_rule[rule_p]);
; 3963 : 	if (current_rule[rule_p]==BIN_EXACT)
; 3964 : 		printf("found an exact character delimiter\n");
; 3965 : #endif
; 3966 : 	buf[0]='\0';	/* clear buf just in case */

  0210e	8b 44 24 20	 mov	 eax, DWORD PTR _buf$[esp+20]
  02112	c6 00 00	 mov	 BYTE PTR [eax], 0

; 3967 : 	/* build the string until a '/' is hit */
; 3968 : 	
; 3969 : 	if (current_rule[in_rule_index] & BIN_CONDITIONAL_REPLACE)

  02115	8a 04 2e	 mov	 al, BYTE PTR [esi+ebp]
  02118	a8 80		 test	 al, 128			; 00000080H
  0211a	0f 84 ed 00 00
	00		 je	 $L73187

; 3970 : 	{
; 3971 : 		is_cond=-1;
; 3972 : #ifndef GERMAN_COMPOUND_NOUNS
; 3973 : 		switch (state)
; 3974 : #else
; 3975 : 		switch(state & BIN_OPERATION_MASK)
; 3976 : #endif
; 3977 : 		{

  02120	8b 44 24 34	 mov	 eax, DWORD PTR _state$[esp+20]
  02124	8b d0		 mov	 edx, eax
  02126	83 e2 1f	 and	 edx, 31			; 0000001fH
  02129	80 fa 1a	 cmp	 dl, 26			; 0000001aH
  0212c	75 65		 jne	 SHORT $L72356

; 3978 : #ifndef GERMAN_COMPOUND_NOUNS
; 3979 : 			/* MGS fixed this, it was BIN_INSERT but it should be BIN_BEFORE */
; 3980 : 		case BIN_BEFORE:
; 3981 : #endif
; 3982 : #ifdef GERMAN_COMPOUND_NOUNS
; 3983 : 		case BIN_INSERT:
; 3984 : 			if (state & BIN_BEFORE_FLAG)

  0212e	a8 20		 test	 al, 32			; 00000020H
  02130	74 2d		 je	 SHORT $L72351

; 3985 : 			{
; 3986 : #endif
; 3987 : 			/* read the first character in the output range */
; 3988 : 			if (range_value->range_set==2)

  02132	8b 44 24 30	 mov	 eax, DWORD PTR _range_value$[esp+20]
  02136	83 78 0c 02	 cmp	 DWORD PTR [eax+12], 2
  0213a	75 07		 jne	 SHORT $L72352

; 3989 : 			{
; 3990 : 				cond_num=range_value->start;

  0213c	8b 00		 mov	 eax, DWORD PTR [eax]

; 3991 : 			}
; 3992 : 			else

  0213e	e9 88 00 00 00	 jmp	 $L72364
$L72352:

; 3993 : 			{
; 3994 : 				cond_num=output_array[ret_value->output_pos]-'0';

  02143	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  02146	8b 54 24 24	 mov	 edx, DWORD PTR _output_array$[esp+20]
  0214a	33 c9		 xor	 ecx, ecx
  0214c	8a 0c 10	 mov	 cl, BYTE PTR [eax+edx]
  0214f	8b c1		 mov	 eax, ecx
  02151	83 e8 30	 sub	 eax, 48			; 00000030H

; 3995 : 				if (cond_num<0 || cond_num>9)

  02154	78 39		 js	 SHORT $L72355
  02156	83 f8 09	 cmp	 eax, 9
  02159	7e 70		 jle	 SHORT $L72364

; 3996 : 					cond_num=0;

  0215b	33 c0		 xor	 eax, eax

; 3997 : 			}
; 3998 : 			break;

  0215d	eb 6c		 jmp	 SHORT $L72364
$L72351:

; 3999 : #ifndef GERMAN_COMPOUND_NOUNS
; 4000 : 		case BIN_AFTER:
; 4001 : #else
; 4002 : 			}
; 4003 : 			if (state & BIN_AFTER_FLAG)

  0215f	a8 40		 test	 al, 64			; 00000040H
  02161	74 30		 je	 SHORT $L72356

; 4004 : 			{
; 4005 : #endif
; 4006 : 			/* convert the last character in the range */
; 4007 : 			if (range_value->range_set==2)

  02163	8b 44 24 30	 mov	 eax, DWORD PTR _range_value$[esp+20]
  02167	83 78 0c 02	 cmp	 DWORD PTR [eax+12], 2
  0216b	75 04		 jne	 SHORT $L72357

; 4008 : 			{
; 4009 : 				cond_num=range_value->start;

  0216d	8b 00		 mov	 eax, DWORD PTR [eax]

; 4010 : 			}
; 4011 : 			else

  0216f	eb 5a		 jmp	 SHORT $L72364
$L72357:

; 4012 : 			{
; 4013 : 				cond_num=output_array[ret_value->output_pos+ret_value->output_offset-1]-'0';

  02171	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  02174	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  02177	03 c2		 add	 eax, edx
  02179	8b 54 24 24	 mov	 edx, DWORD PTR _output_array$[esp+20]
  0217d	33 c9		 xor	 ecx, ecx
  0217f	8a 4c 10 ff	 mov	 cl, BYTE PTR [eax+edx-1]
  02183	8b c1		 mov	 eax, ecx
  02185	83 e8 30	 sub	 eax, 48			; 00000030H

; 4014 : 				if (cond_num<0 || cond_num>9)

  02188	78 05		 js	 SHORT $L72355
  0218a	83 f8 09	 cmp	 eax, 9
  0218d	7e 3c		 jle	 SHORT $L72364
$L72355:

; 4015 : 					cond_num=0;

  0218f	33 c0		 xor	 eax, eax

; 4016 : 			}
; 4017 : 			break;

  02191	eb 38		 jmp	 SHORT $L72364
$L72356:

; 4018 : #ifdef GERMAN_COMPOUND_NOUNS
; 4019 : 			}
; 4020 : 			/* for GERMAN_COMPOUND_NOUNS, it is intended to not have a break after 
; 4021 : 			   the case for BIN_INSERT so it can do the right thing */
; 4022 : #endif
; 4023 : 
; 4024 : 		default:
; 4025 : 			if (range_value->range_set==2)

  02193	8b 44 24 30	 mov	 eax, DWORD PTR _range_value$[esp+20]
  02197	83 78 0c 02	 cmp	 DWORD PTR [eax+12], 2
  0219b	75 04		 jne	 SHORT $L72362

; 4026 : 			{
; 4027 : 				cond_num=range_value->start;

  0219d	8b 00		 mov	 eax, DWORD PTR [eax]

; 4028 : 			}
; 4029 : 			else

  0219f	eb 2a		 jmp	 SHORT $L72364
$L72362:

; 4030 : 			{
; 4031 : 				/* convert all the character in the range */
; 4032 : 				/*	a range_value->range_set == -1 cant have any fancy conditionals
; 4033 : 				so it just does the normal stuff of converting the digits
; 4034 : 				*/
; 4035 : 				output_array[ret_value->output_offset+ret_value->output_pos]='\0';

  021a1	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  021a4	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  021a7	03 d0		 add	 edx, eax
  021a9	8b 44 24 24	 mov	 eax, DWORD PTR _output_array$[esp+20]
  021ad	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 4036 : 				cond_num=par_convert_number_new2(output_array+ret_value->output_pos);

  021b1	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  021b4	03 c8		 add	 ecx, eax
  021b6	51		 push	 ecx
  021b7	e8 00 00 00 00	 call	 _par_convert_number_new2

; 4037 : 				if (range_value->range_set==1)

  021bc	8b 4c 24 34	 mov	 ecx, DWORD PTR _range_value$[esp+24]
  021c0	83 c4 04	 add	 esp, 4
  021c3	83 79 0c 01	 cmp	 DWORD PTR [ecx+12], 1
  021c7	75 02		 jne	 SHORT $L72364

; 4038 : 				{
; 4039 : 					cond_num-=range_value->start;

  021c9	2b 01		 sub	 eax, DWORD PTR [ecx]
$L72364:

; 4040 : 				}
; 4041 : 			}
; 4042 : 		}
; 4043 : 		if (cond_num > (current_rule[in_rule_index+3]))

  021cb	33 c9		 xor	 ecx, ecx
  021cd	8a 4c 2e 03	 mov	 cl, BYTE PTR [esi+ebp+3]
  021d1	3b c1		 cmp	 eax, ecx

; 4044 : 		{
; 4045 : 			cond_num=0;
; 4046 : 		}
; 4047 : 		if (cond_num==0)

  021d3	7f 04		 jg	 SHORT $L73188
  021d5	85 c0		 test	 eax, eax
  021d7	75 06		 jne	 SHORT $L72366
$L73188:

; 4048 : 		{
; 4049 : 			end_of_build=current_rule[in_rule_index+4];

  021d9	8a 54 2e 04	 mov	 dl, BYTE PTR [esi+ebp+4]

; 4050 : 		}
; 4051 : 		else

  021dd	eb 26		 jmp	 SHORT $L73193
$L72366:

; 4052 : 		{
; 4053 : 			if (cond_num == (current_rule[in_rule_index+3]))

  021df	3b c1		 cmp	 eax, ecx
  021e1	75 15		 jne	 SHORT $L72368

; 4054 : 			{
; 4055 : 				rule_p=current_rule[in_rule_index+3+cond_num]+1;

  021e3	03 c5		 add	 eax, ebp
  021e5	33 db		 xor	 ebx, ebx
  021e7	8a 5c 30 03	 mov	 bl, BYTE PTR [eax+esi+3]

; 4056 : 				end_of_build=current_rule[in_rule_index+2];

  021eb	8b 44 24 3c	 mov	 eax, DWORD PTR 40+[esp+20]
  021ef	43		 inc	 ebx
  021f0	8a 08		 mov	 cl, BYTE PTR [eax]
  021f2	88 4c 24 1c	 mov	 BYTE PTR _end_of_build$[esp+20], cl

; 4057 : 			}
; 4058 : 			else

  021f6	eb 11		 jmp	 SHORT $L73194
$L72368:

; 4059 : 			{
; 4060 : 				rule_p=current_rule[in_rule_index+3+cond_num]+1;

  021f8	03 c5		 add	 eax, ebp
  021fa	33 db		 xor	 ebx, ebx
  021fc	03 f0		 add	 esi, eax
  021fe	8a 5e 03	 mov	 bl, BYTE PTR [esi+3]

; 4061 : 				end_of_build=current_rule[in_rule_index+4+cond_num];

  02201	8a 56 04	 mov	 dl, BYTE PTR [esi+4]
  02204	43		 inc	 ebx
$L73193:
  02205	88 54 24 1c	 mov	 BYTE PTR _end_of_build$[esp+20], dl
$L73194:
  02209	8b 4c 24 2c	 mov	 ecx, DWORD PTR _ret_value$[esp+20]
$L73187:

; 4062 : 			}
; 4063 : 		}
; 4064 : 		
; 4065 : 	}
; 4066 : 	while (rule_p<=end_of_build)

  0220d	8b 44 24 1c	 mov	 eax, DWORD PTR _end_of_build$[esp+20]
  02211	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  02216	3b d8		 cmp	 ebx, eax
  02218	89 44 24 30	 mov	 DWORD PTR 28+[esp+20], eax
  0221c	0f 8f 9d 00 00
	00		 jg	 $L72372
$L72371:

; 4067 : 	{
; 4068 : 		/* build the string until either a slash is found or a conditional is found */
; 4069 : 		switch (current_rule[rule_p] & BIN_OPERATION_MASK)
; 4070 : 		{

  02222	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02225	83 e0 1f	 and	 eax, 31			; 0000001fH
  02228	83 e8 10	 sub	 eax, 16			; 00000010H
  0222b	74 58		 je	 SHORT $L72377
  0222d	48		 dec	 eax
  0222e	74 41		 je	 SHORT $L72379
  02230	48		 dec	 eax
  02231	0f 85 ac 00 00
	00		 jne	 $L72380

; 4078 : 			break;
; 4079 : 		case BIN_RESTORE:						/* a $# sequence was found. */
; 4080 : 			rule_p++;
; 4081 : 			match_num=current_rule[rule_p];
; 4082 : 			match_l=match_array->array_lengths[match_num];	/* get the length of the strig in the array */

  02237	8b 74 24 28	 mov	 esi, DWORD PTR _match_array$[esp+20]
  0223b	43		 inc	 ebx
  0223c	33 c0		 xor	 eax, eax
  0223e	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02241	8b 14 86	 mov	 edx, DWORD PTR [esi+eax*4]

; 4083 : 			memcpy(buf+buf_ind,match_array->array[match_num],match_l);

  02244	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  02247	8b ca		 mov	 ecx, edx
  02249	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0224c	8d 74 46 28	 lea	 esi, DWORD PTR [esi+eax*2+40]
  02250	8b 44 24 20	 mov	 eax, DWORD PTR _buf$[esp+20]
  02254	03 f8		 add	 edi, eax
  02256	8b c1		 mov	 eax, ecx
  02258	c1 e9 02	 shr	 ecx, 2
  0225b	f3 a5		 rep movsd
  0225d	8b c8		 mov	 ecx, eax
  0225f	83 e1 03	 and	 ecx, 3
  02262	f3 a4		 rep movsb

; 4084 : 			buf_ind+=match_l;   		/* add the length of the string in the array to buff_ind */

  02264	8b 4c 24 10	 mov	 ecx, DWORD PTR _buf_ind$[esp+24]
  02268	03 ca		 add	 ecx, edx

; 4085 : 			rule_p++;

  0226a	43		 inc	 ebx
  0226b	89 4c 24 10	 mov	 DWORD PTR _buf_ind$[esp+24], ecx

; 4086 : 			break;

  0226f	eb 3a		 jmp	 SHORT $L73195
$L72379:

; 4087 : 		case BIN_HEXADECIMAL:
; 4088 : 			/* a hexadecimal value was found */
; 4089 : 			/* hexadecimal values have to be specified in the format 0xab */
; 4090 : 			/* they must have 2 legal letters after the x */
; 4091 : 			rule_p++;
; 4092 : 			buf[buf_ind]=current_rule[rule_p]; /* put the value into the buffer array */

  02271	8b 54 24 20	 mov	 edx, DWORD PTR _buf$[esp+20]
  02275	8a 4c 2b 01	 mov	 cl, BYTE PTR [ebx+ebp+1]
  02279	43		 inc	 ebx
  0227a	88 0c 17	 mov	 BYTE PTR [edi+edx], cl

; 4093 : 			buf_ind++;

  0227d	47		 inc	 edi
  0227e	89 7c 24 10	 mov	 DWORD PTR _buf_ind$[esp+24], edi

; 4094 : 			rule_p++;

  02282	43		 inc	 ebx

; 4095 : 			break;

  02283	eb 2a		 jmp	 SHORT $L72374
$L72377:

; 4071 : 		case BIN_EXACT:		/* an exact string was found */
; 4072 : 			rule_p++;
; 4073 : 			match_l=current_rule[rule_p];
; 4074 : 			rule_p++;
; 4075 : 			memcpy(&buf[buf_ind],&current_rule[rule_p],match_l);

  02285	8b 54 24 20	 mov	 edx, DWORD PTR _buf$[esp+20]
  02289	43		 inc	 ebx
  0228a	33 c0		 xor	 eax, eax
  0228c	03 fa		 add	 edi, edx
  0228e	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02291	43		 inc	 ebx
  02292	8b c8		 mov	 ecx, eax
  02294	8b d1		 mov	 edx, ecx
  02296	8d 34 2b	 lea	 esi, DWORD PTR [ebx+ebp]
  02299	c1 e9 02	 shr	 ecx, 2
  0229c	f3 a5		 rep movsd
  0229e	8b ca		 mov	 ecx, edx

; 4076 : 			rule_p+=match_l;

  022a0	03 d8		 add	 ebx, eax
  022a2	83 e1 03	 and	 ecx, 3
  022a5	f3 a4		 rep movsb

; 4077 : 			buf_ind+=match_l;

  022a7	01 44 24 10	 add	 DWORD PTR _buf_ind$[esp+24], eax
$L73195:
  022ab	8b 7c 24 10	 mov	 edi, DWORD PTR _buf_ind$[esp+24]
$L72374:

; 4062 : 			}
; 4063 : 		}
; 4064 : 		
; 4065 : 	}
; 4066 : 	while (rule_p<=end_of_build)

  022af	8b 44 24 30	 mov	 eax, DWORD PTR 28+[esp+20]
  022b3	8b 4c 24 2c	 mov	 ecx, DWORD PTR _ret_value$[esp+20]
  022b7	3b d8		 cmp	 ebx, eax
  022b9	0f 8e 63 ff ff
	ff		 jle	 $L72371
$L72372:

; 4103 : 		}
; 4104 : 	}
; 4105 : 	/* the end of the rule has been hit */
; 4106 : 	buf[buf_ind]='\0';

  022bf	8b 44 24 20	 mov	 eax, DWORD PTR _buf$[esp+20]

; 4107 : 	*length=buf_ind;

  022c3	8b 54 24 38	 mov	 edx, DWORD PTR _length$[esp+20]
  022c7	c6 04 07 00	 mov	 BYTE PTR [edi+eax], 0
  022cb	89 3a		 mov	 DWORD PTR [edx], edi

; 4108 : 	ret_value->rule=end_of_action+1;

  022cd	8b 54 24 14	 mov	 edx, DWORD PTR _end_of_action$[esp+24]
  022d1	5f		 pop	 edi
  022d2	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  022d8	5e		 pop	 esi
  022d9	42		 inc	 edx
  022da	5d		 pop	 ebp
  022db	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  022de	5b		 pop	 ebx

; 4109 : #ifdef DEBUG2
; 4110 : 	par_print_rule_error("no error, just debugging output position",current_rule,rule_p);
; 4111 : #endif
; 4112 : #ifdef 	DEBUG
; 4113 : 	printf("leaving par_build_string_from_rule buf=%s\n",buf);
; 4114 : #endif
; 4115 : 	return(buf);
; 4116 : }

  022df	83 c4 08	 add	 esp, 8
  022e2	c3		 ret	 0
$L72380:
  022e3	5f		 pop	 edi
  022e4	5e		 pop	 esi
  022e5	5d		 pop	 ebp

; 4096 : 		default:
; 4097 : 			/* the current character is not a recognized type */
; 4098 : #ifdef DEBUG
; 4099 : 			par_print_rule_error("build_string;unrecognized delimiter",current_rule,rule_p);
; 4100 : #endif
; 4101 : 			ret_value->value=FATAL_FAIL;

  022e6	c7 41 14 04 00
	00 00		 mov	 DWORD PTR [ecx+20], 4

; 4102 : 			return(NULL);

  022ed	33 c0		 xor	 eax, eax
  022ef	5b		 pop	 ebx

; 4109 : #ifdef DEBUG2
; 4110 : 	par_print_rule_error("no error, just debugging output position",current_rule,rule_p);
; 4111 : #endif
; 4112 : #ifdef 	DEBUG
; 4113 : 	printf("leaving par_build_string_from_rule buf=%s\n",buf);
; 4114 : #endif
; 4115 : 	return(buf);
; 4116 : }

  022f0	83 c4 08	 add	 esp, 8
  022f3	c3		 ret	 0
_par_build_string_from_rule ENDP
_TEXT	ENDS
PUBLIC	_par_match_sets_with_ranges
PUBLIC	_par_match_digits
PUBLIC	_par_match_standard
EXTRN	_par_lower:BYTE
_TEXT	SEGMENT
_current_rule$ = 8
_char_type$ = 12
_input_array$ = 16
_match_array$ = 20
_ret_value$ = 24
_range_value$ = 28
_lookahead$ = 32
_break_on_min_match$ = 36
_par_match_string PROC NEAR

; 4162 : 	register int rule_p;
; 4163 : 	register int ipos;
; 4164 : 	int length=0;
; 4165 : 	int value;
; 4166 : 	
; 4167 : 	
; 4168 : #ifdef DEBUG
; 4169 : 	printf("entering par_match_string\n");
; 4170 : #endif
; 4171 : 	
; 4172 : 
; 4173 : 	
; 4174 : 	rule_p=ret_value->rule;
; 4175 : 	ipos=ret_value->input_pos+ret_value->input_offset;
; 4176 : 	
; 4177 : 	if (char_type<=BIN_DIGIT)

  02300	8b 44 24 08	 mov	 eax, DWORD PTR _char_type$[esp-4]
  02304	53		 push	 ebx
  02305	55		 push	 ebp
  02306	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ret_value$[esp+4]
  0230a	56		 push	 esi
  0230b	57		 push	 edi
  0230c	8b 75 04	 mov	 esi, DWORD PTR [ebp+4]
  0230f	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02312	8b 4d 10	 mov	 ecx, DWORD PTR [ebp+16]
  02315	03 f3		 add	 esi, ebx
  02317	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0231a	8b d1		 mov	 edx, ecx
  0231c	7f 50		 jg	 SHORT $L72403

; 4178 : 	{
; 4179 : 		if (current_rule[rule_p] & BIN_DIGIT_RANGE)

  0231e	8b 4c 24 14	 mov	 ecx, DWORD PTR _current_rule$[esp+12]
  02322	f6 04 0a 20	 test	 BYTE PTR [edx+ecx], 32	; 00000020H
  02326	74 25		 je	 SHORT $L72404

; 4180 : 		{
; 4181 : 			/* check for the special digit type and if it is there */
; 4182 : 			/* use the special digit matching function. */
; 4183 : 			/* use the normal one otherwise */
; 4184 : 			length=par_match_digits(current_rule,input_array,match_array,ret_value,range_value,lookahead,break_on_min_match);

  02328	8b 44 24 30	 mov	 eax, DWORD PTR _break_on_min_match$[esp+12]
  0232c	8b 54 24 2c	 mov	 edx, DWORD PTR _lookahead$[esp+12]
  02330	50		 push	 eax
  02331	8b 44 24 2c	 mov	 eax, DWORD PTR _range_value$[esp+16]
  02335	52		 push	 edx
  02336	8b 54 24 28	 mov	 edx, DWORD PTR _match_array$[esp+20]
  0233a	50		 push	 eax
  0233b	8b 44 24 28	 mov	 eax, DWORD PTR _input_array$[esp+24]
  0233f	55		 push	 ebp
  02340	52		 push	 edx
  02341	50		 push	 eax
  02342	51		 push	 ecx
  02343	e8 00 00 00 00	 call	 _par_match_digits

; 4185 : 		}
; 4186 : 		else

  02348	e9 49 01 00 00	 jmp	 $L73204
$L72404:

; 4187 : 		{
; 4188 : 			length=par_match_standard(current_rule,char_type,input_array,match_array,ret_value,lookahead,break_on_min_match);

  0234d	8b 54 24 30	 mov	 edx, DWORD PTR _break_on_min_match$[esp+12]
  02351	52		 push	 edx
  02352	8b 54 24 30	 mov	 edx, DWORD PTR _lookahead$[esp+16]
  02356	52		 push	 edx
  02357	8b 54 24 28	 mov	 edx, DWORD PTR _match_array$[esp+20]
  0235b	55		 push	 ebp
  0235c	52		 push	 edx
  0235d	8b 54 24 2c	 mov	 edx, DWORD PTR _input_array$[esp+28]
  02361	52		 push	 edx
  02362	50		 push	 eax
  02363	51		 push	 ecx
  02364	e8 00 00 00 00	 call	 _par_match_standard

; 4189 : 		}
; 4190 : 		rule_p=ret_value->rule;
; 4191 : 	}
; 4192 : 	else	/* if (char_type<=BIN_DIGIT) */

  02369	e9 28 01 00 00	 jmp	 $L73204
$L72403:

; 4193 : 	{
; 4194 : 		if (char_type<=BIN_HEXADECIMAL)

  0236e	83 f8 11	 cmp	 eax, 17			; 00000011H
  02371	0f 8f a6 00 00
	00		 jg	 $L72407

; 4195 : 		{
; 4196 : 			
; 4197 : 			if (char_type==BIN_EXACT)

  02377	83 f8 10	 cmp	 eax, 16			; 00000010H
  0237a	75 6e		 jne	 SHORT $L72408

; 4198 : 			{
; 4199 : 				rule_p++;
; 4200 : 				length=0;
; 4201 : 				value=current_rule[rule_p];

  0237c	8b 7c 24 14	 mov	 edi, DWORD PTR _current_rule$[esp+12]
  02380	42		 inc	 edx
  02381	33 db		 xor	 ebx, ebx
  02383	33 c0		 xor	 eax, eax
  02385	8a 1c 3a	 mov	 bl, BYTE PTR [edx+edi]

; 4202 : 				rule_p++;

  02388	42		 inc	 edx

; 4203 : 				if (current_rule[ret_value->rule] & BIN_CASE_INSEN)

  02389	f6 04 39 20	 test	 BYTE PTR [ecx+edi], 32	; 00000020H
  0238d	74 3b		 je	 SHORT $L72409

; 4204 : 				{
; 4205 : 					while (length<value)

  0238f	85 db		 test	 ebx, ebx
  02391	0f 8e 09 01 00
	00		 jle	 $L73200
  02397	8b 4c 24 1c	 mov	 ecx, DWORD PTR _input_array$[esp+12]
  0239b	03 f1		 add	 esi, ecx
  0239d	89 74 24 1c	 mov	 DWORD PTR 16+[esp+12], esi
$L72411:

; 4206 : 					{
; 4207 : 						if (par_lower[current_rule[rule_p]]!=par_lower[input_array[ipos+length]])

  023a1	8b 74 24 1c	 mov	 esi, DWORD PTR 16+[esp+12]
  023a5	33 c9		 xor	 ecx, ecx
  023a7	8a 0c 06	 mov	 cl, BYTE PTR [esi+eax]
  023aa	8b f1		 mov	 esi, ecx
  023ac	33 c9		 xor	 ecx, ecx
  023ae	8a 0c 3a	 mov	 cl, BYTE PTR [edx+edi]
  023b1	8a 89 00 00 00
	00		 mov	 cl, BYTE PTR _par_lower[ecx]
  023b7	3a 8e 00 00 00
	00		 cmp	 cl, BYTE PTR _par_lower[esi]
  023bd	75 3c		 jne	 SHORT $L73198

; 4208 : 						{
; 4209 : #ifdef DEBUG
; 4210 : 							printf("leaving par_match_string; exact characters dont match\n");
; 4211 : #endif
; 4212 : 							if (ret_value->optional==1)
; 4213 : 							{
; 4214 : #ifdef DEBUG
; 4215 : 								printf("par_match_string; exact optional set to -1\n");
; 4216 : #endif
; 4217 : //								ret_value->optional= -1;
; 4218 : 								ret_value->value=OPT_FAIL;
; 4219 : 							}
; 4220 : 							else
; 4221 : 							{
; 4222 : 								ret_value->value=FAIL;
; 4223 : 							}
; 4224 : 							return(0);
; 4225 : 						}
; 4226 : 						length++;

  023bf	40		 inc	 eax

; 4227 : 						rule_p++;

  023c0	42		 inc	 edx
  023c1	3b c3		 cmp	 eax, ebx
  023c3	7c dc		 jl	 SHORT $L72411

; 4206 : 					{
; 4207 : 						if (par_lower[current_rule[rule_p]]!=par_lower[input_array[ipos+length]])

  023c5	e9 d2 00 00 00	 jmp	 $L72431
$L72409:

; 4228 : 					}
; 4229 : 				}
; 4230 : 				else
; 4231 : 				{
; 4232 : 					if (current_rule[rule_p]!=input_array[ipos])

  023ca	8b 44 24 1c	 mov	 eax, DWORD PTR _input_array$[esp+12]
  023ce	8a 0c 17	 mov	 cl, BYTE PTR [edi+edx]
  023d1	03 fa		 add	 edi, edx
  023d3	03 f0		 add	 esi, eax
  023d5	3a 0e		 cmp	 cl, BYTE PTR [esi]

; 4233 : 					{
; 4234 : #ifdef DEBUG
; 4235 : 						printf("leaving par_match_string; exact characters dont match\n");
; 4236 : #endif
; 4237 : 						if (ret_value->optional==1)
; 4238 : 						{
; 4239 : #ifdef DEBUG
; 4240 : 							printf("par_match_string; exact optional set to -1\n");
; 4241 : #endif
; 4242 : 							//ret_value->optional= -1;
; 4243 : 							ret_value->value=OPT_FAIL;
; 4244 : 						}
; 4245 : 						else

  023d7	75 22		 jne	 SHORT $L73198

; 4246 : 						{
; 4247 : 							ret_value->value=FAIL;
; 4248 : 						}
; 4249 : 						return(0);
; 4250 : 					}
; 4251 : 					if (memcmp(input_array+ipos,current_rule+rule_p,value)!=0)

  023d9	8b cb		 mov	 ecx, ebx
  023db	33 c0		 xor	 eax, eax
  023dd	f3 a6		 repe cmpsb

; 4252 : 					{
; 4253 : #ifdef DEBUG
; 4254 : 						printf("leaving par_match_string; exact characters dont match\n");
; 4255 : #endif
; 4256 : 						if (ret_value->optional==1)
; 4257 : 						{
; 4258 : #ifdef DEBUG
; 4259 : 							printf("par_match_string; exact optional set to -1\n");
; 4260 : #endif
; 4261 : 			//				ret_value->optional= -1;
; 4262 : 							ret_value->value=OPT_FAIL;
; 4263 : 							
; 4264 : 						}
; 4265 : 						else

  023df	75 1a		 jne	 SHORT $L73198

; 4266 : 						{
; 4267 : 							ret_value->value=FAIL;
; 4268 : 						}
; 4269 : 						return(0);
; 4270 : 					}
; 4271 : 					rule_p+=value;

  023e1	03 d3		 add	 edx, ebx

; 4272 : 					length=value;

  023e3	8b c3		 mov	 eax, ebx

; 4273 : 				}
; 4274 : 			}
; 4275 : 			else /* if (char_type==BIN_EXACT) */

  023e5	e9 b2 00 00 00	 jmp	 $L72431
$L72408:

; 4276 : 			{
; 4277 : 				/* BIN_HEXADECIMAL */
; 4278 : 				rule_p++;
; 4279 : 				if (input_array[ipos]!=current_rule[rule_p])

  023ea	8b 4c 24 1c	 mov	 ecx, DWORD PTR _input_array$[esp+12]
  023ee	42		 inc	 edx
  023ef	8a 04 0e	 mov	 al, BYTE PTR [esi+ecx]
  023f2	8b 4c 24 14	 mov	 ecx, DWORD PTR _current_rule$[esp+12]
  023f6	3a 04 0a	 cmp	 al, BYTE PTR [edx+ecx]
  023f9	74 14		 je	 SHORT $L72424
$L73198:

; 4280 : 				{
; 4281 : 					if (ret_value->optional==1)

  023fb	83 7d 18 01	 cmp	 DWORD PTR [ebp+24], 1
  023ff	75 60		 jne	 SHORT $L72425
  02401	5f		 pop	 edi

; 4282 : 					{
; 4283 : #ifdef DEBUG
; 4284 : 						printf("par_match_string; hex optional set to -1\n");
; 4285 : #endif
; 4286 : 		//				ret_value->optional= -1;
; 4287 : 						ret_value->value=OPT_FAIL;

  02402	c7 45 14 02 00
	00 00		 mov	 DWORD PTR [ebp+20], 2
  02409	5e		 pop	 esi
  0240a	5d		 pop	 ebp

; 4322 : 					return(0);

  0240b	33 c0		 xor	 eax, eax
  0240d	5b		 pop	 ebx

; 4363 : #ifdef DEBUG
; 4364 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4365 : #endif
; 4366 : 	return(length);
; 4367 : }

  0240e	c3		 ret	 0
$L72424:

; 4288 : 					}
; 4289 : 					else
; 4290 : 					{
; 4291 : 						ret_value->value=FAIL;
; 4292 : 					}
; 4293 : #ifdef DEBUG
; 4294 : 					printf("leaving par_match_string hexadecimal value %02X mismatch\n",value);
; 4295 : #endif
; 4296 : 					return(0);
; 4297 : 				}
; 4298 : 				length=1;
; 4299 : 				rule_p++;

  0240f	42		 inc	 edx
  02410	5f		 pop	 edi

; 4361 : 	}
; 4362 : 	ret_value->rule=rule_p;

  02411	89 55 10	 mov	 DWORD PTR [ebp+16], edx
  02414	5e		 pop	 esi
  02415	5d		 pop	 ebp
  02416	b8 01 00 00 00	 mov	 eax, 1
  0241b	5b		 pop	 ebx

; 4363 : #ifdef DEBUG
; 4364 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4365 : #endif
; 4366 : 	return(length);
; 4367 : }

  0241c	c3		 ret	 0
$L72407:

; 4300 : 			}
; 4301 : 		}
; 4302 : 		else /* if (char_type<=BIN_HEXADECIMAL) */
; 4303 : 		{
; 4304 : 			if (char_type==BIN_RESTORE)

  0241d	83 f8 12	 cmp	 eax, 18			; 00000012H
  02420	75 50		 jne	 SHORT $L72428

; 4305 : 			{
; 4306 : 				rule_p++;
; 4307 : 				value=current_rule[rule_p];					/* get the array number */

  02422	8b 4c 24 14	 mov	 ecx, DWORD PTR _current_rule$[esp+12]

; 4308 : 				length=match_array->array_lengths[value];	/* get the length of the strig in the array */

  02426	8b 5c 24 20	 mov	 ebx, DWORD PTR _match_array$[esp+12]
  0242a	42		 inc	 edx
  0242b	33 c0		 xor	 eax, eax
  0242d	8a 04 0a	 mov	 al, BYTE PTR [edx+ecx]
  02430	8b f8		 mov	 edi, eax
  02432	8b 04 bb	 mov	 eax, DWORD PTR [ebx+edi*4]

; 4309 : 				if ((memcmp(input_array+ipos,match_array->array[value],length)!=0))

  02435	8d 3c 7f	 lea	 edi, DWORD PTR [edi+edi*2]
  02438	8b c8		 mov	 ecx, eax
  0243a	8d 3c bf	 lea	 edi, DWORD PTR [edi+edi*4]
  0243d	8d 7c 7b 28	 lea	 edi, DWORD PTR [ebx+edi*2+40]
  02441	8b 5c 24 1c	 mov	 ebx, DWORD PTR _input_array$[esp+12]
  02445	03 f3		 add	 esi, ebx
  02447	33 db		 xor	 ebx, ebx
  02449	f3 a6		 repe cmpsb
  0244b	74 22		 je	 SHORT $L72429

; 4310 : 				{
; 4311 : 					if (ret_value->optional==1)

  0244d	83 7d 18 01	 cmp	 DWORD PTR [ebp+24], 1
  02451	75 0e		 jne	 SHORT $L72425
  02453	5f		 pop	 edi

; 4312 : 					{
; 4313 : #ifdef DEBUG
; 4314 : 						printf("par_match_string; save optional set to -1\n");
; 4315 : #endif
; 4316 : //						ret_value->optional= -1;
; 4317 : 						ret_value->value=OPT_FAIL;

  02454	c7 45 14 02 00
	00 00		 mov	 DWORD PTR [ebp+20], 2
  0245b	5e		 pop	 esi
  0245c	5d		 pop	 ebp

; 4318 : 						return(0);

  0245d	33 c0		 xor	 eax, eax
  0245f	5b		 pop	 ebx

; 4363 : #ifdef DEBUG
; 4364 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4365 : #endif
; 4366 : 	return(length);
; 4367 : }

  02460	c3		 ret	 0
$L72425:
  02461	5f		 pop	 edi

; 4319 : 
; 4320 : 					}
; 4321 : 					ret_value->value=FAIL;

  02462	c7 45 14 00 00
	00 00		 mov	 DWORD PTR [ebp+20], 0
  02469	5e		 pop	 esi
  0246a	5d		 pop	 ebp

; 4322 : 					return(0);

  0246b	33 c0		 xor	 eax, eax
  0246d	5b		 pop	 ebx

; 4363 : #ifdef DEBUG
; 4364 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4365 : #endif
; 4366 : 	return(length);
; 4367 : }

  0246e	c3		 ret	 0
$L72429:

; 4323 : 				}
; 4324 : 				rule_p++;

  0246f	42		 inc	 edx

; 4325 : 			}
; 4326 : 			else /* if (char_type==BIN_RESTORE) */

  02470	eb 2a		 jmp	 SHORT $L72431
$L72428:

; 4327 : 			{
; 4328 : 				/* BIN_SETS */	
; 4329 : 				length=par_match_sets_with_ranges(current_rule,input_array,match_array,ret_value,range_value,lookahead,break_on_min_match);

  02472	8b 54 24 30	 mov	 edx, DWORD PTR _break_on_min_match$[esp+12]
  02476	8b 44 24 2c	 mov	 eax, DWORD PTR _lookahead$[esp+12]
  0247a	8b 4c 24 28	 mov	 ecx, DWORD PTR _range_value$[esp+12]
  0247e	52		 push	 edx
  0247f	8b 54 24 24	 mov	 edx, DWORD PTR _match_array$[esp+16]
  02483	50		 push	 eax
  02484	8b 44 24 24	 mov	 eax, DWORD PTR _input_array$[esp+20]
  02488	51		 push	 ecx
  02489	8b 4c 24 20	 mov	 ecx, DWORD PTR _current_rule$[esp+24]
  0248d	55		 push	 ebp
  0248e	52		 push	 edx
  0248f	50		 push	 eax
  02490	51		 push	 ecx
  02491	e8 00 00 00 00	 call	 _par_match_sets_with_ranges
$L73204:

; 4330 : 				rule_p=ret_value->rule;

  02496	8b 55 10	 mov	 edx, DWORD PTR [ebp+16]
  02499	83 c4 1c	 add	 esp, 28			; 0000001cH
$L72431:

; 4331 : 				/* find the { */ /* } */
; 4332 : 				/* find the first thing to search for */
; 4333 : 				/* save the rule pointer for multiple matches */
; 4334 : 				/* loop calling par_match_string pointing to each thing to match before the comma
; 4335 : 				and if all of them are successful, return the total nubmer of characters matched
; 4336 : 				if not, go on to the next section */
; 4337 : 				/* the ret_value structure passed is the same one that is passed to the current
; 4338 : 				par_match_string, so the rule field will be corrupted */
; 4339 : 				/* repeat the loop for each time iteration of the <#> thing */
; 4340 : 				/* set the range if only one is found */
; 4341 : 			} /* if (char_type==BIN_RESTORE) */
; 4342 : 		} /* if (char_type<=BIN_HEXADECIMAL) */
; 4343 : 	} /* if (char_type<=BIN_DIGIT) */
; 4344 : 
; 4345 : 
; 4346 : 
; 4347 : 	if (length==0)

  0249c	85 c0		 test	 eax, eax
  0249e	75 24		 jne	 SHORT $L72434
$L73200:

; 4348 : 	{
; 4349 : 		if (ret_value->optional==1)

  024a0	83 7d 18 01	 cmp	 DWORD PTR [ebp+24], 1
  024a4	75 0f		 jne	 SHORT $L72433
  024a6	5f		 pop	 edi

; 4350 : 		{
; 4351 : 			ret_value->value=OPT_FAIL;

  024a7	c7 45 14 02 00
	00 00		 mov	 DWORD PTR [ebp+20], 2

; 4361 : 	}
; 4362 : 	ret_value->rule=rule_p;

  024ae	89 55 10	 mov	 DWORD PTR [ebp+16], edx
  024b1	5e		 pop	 esi
  024b2	5d		 pop	 ebp
  024b3	5b		 pop	 ebx

; 4363 : #ifdef DEBUG
; 4364 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4365 : #endif
; 4366 : 	return(length);
; 4367 : }

  024b4	c3		 ret	 0
$L72433:
  024b5	5f		 pop	 edi

; 4352 : 		}
; 4353 : 		else
; 4354 : 		{
; 4355 : 			ret_value->value=FAIL;

  024b6	c7 45 14 00 00
	00 00		 mov	 DWORD PTR [ebp+20], 0

; 4361 : 	}
; 4362 : 	ret_value->rule=rule_p;

  024bd	89 55 10	 mov	 DWORD PTR [ebp+16], edx
  024c0	5e		 pop	 esi
  024c1	5d		 pop	 ebp
  024c2	5b		 pop	 ebx

; 4363 : #ifdef DEBUG
; 4364 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4365 : #endif
; 4366 : 	return(length);
; 4367 : }

  024c3	c3		 ret	 0
$L72434:

; 4356 : 		}
; 4357 : 	}
; 4358 : 	if (length==-2)

  024c4	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  024c7	75 02		 jne	 SHORT $L72435

; 4359 : 	{
; 4360 : 		length=0;

  024c9	33 c0		 xor	 eax, eax
$L72435:
  024cb	5f		 pop	 edi

; 4361 : 	}
; 4362 : 	ret_value->rule=rule_p;

  024cc	89 55 10	 mov	 DWORD PTR [ebp+16], edx
  024cf	5e		 pop	 esi
  024d0	5d		 pop	 ebp
  024d1	5b		 pop	 ebx

; 4363 : #ifdef DEBUG
; 4364 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4365 : #endif
; 4366 : 	return(length);
; 4367 : }

  024d2	c3		 ret	 0
_par_match_string ENDP
_input_array$ = 8
_input_indexes$ = 12
_output_array$ = 16
_output_indexes$ = 20
_num_chars$ = 24
_ret_value$ = 28
_par_copy_string_data PROC NEAR

; 4400 : #ifdef DEBUG
; 4401 : 	printf("entering par_copy_string_data\n");
; 4402 : #endif
; 4403 : 	memcpy(&output_array[ret_value->output_pos+ret_value->output_offset],&input_array[ret_value->input_pos+ret_value->input_offset],num_chars);

  024e0	8b 44 24 18	 mov	 eax, DWORD PTR _ret_value$[esp-4]
  024e4	53		 push	 ebx
  024e5	8b 5c 24 08	 mov	 ebx, DWORD PTR _input_array$[esp]
  024e9	56		 push	 esi
  024ea	8b 30		 mov	 esi, DWORD PTR [eax]
  024ec	8b 54 24 1c	 mov	 edx, DWORD PTR _num_chars$[esp+4]
  024f0	57		 push	 edi
  024f1	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  024f4	03 f3		 add	 esi, ebx
  024f6	8b 5c 24 18	 mov	 ebx, DWORD PTR _output_array$[esp+8]
  024fa	03 f7		 add	 esi, edi
  024fc	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  024ff	03 fb		 add	 edi, ebx
  02501	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]
  02504	8b ca		 mov	 ecx, edx
  02506	03 fb		 add	 edi, ebx
  02508	8b d9		 mov	 ebx, ecx
  0250a	c1 e9 02	 shr	 ecx, 2
  0250d	f3 a5		 rep movsd
  0250f	8b cb		 mov	 ecx, ebx
  02511	83 e1 03	 and	 ecx, 3
  02514	f3 a4		 rep movsb

; 4404 : 	
; 4405 : 	par_copy_index_list(output_indexes,ret_value->output_pos+ret_value->output_offset,input_indexes,ret_value->input_pos+ret_value->input_offset,num_chars);

  02516	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  02519	8b 74 24 14	 mov	 esi, DWORD PTR _input_indexes$[esp+8]
  0251d	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  02520	8b 10		 mov	 edx, DWORD PTR [eax]
  02522	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  02525	03 d3		 add	 edx, ebx
  02527	d1 e1		 shl	 ecx, 1
  02529	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  0252c	8d 34 56	 lea	 esi, DWORD PTR [esi+edx*2]
  0252f	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  02532	03 d7		 add	 edx, edi
  02534	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  02537	8b 54 24 1c	 mov	 edx, DWORD PTR _output_indexes$[esp+8]
  0253b	8d 3c 42	 lea	 edi, DWORD PTR [edx+eax*2]
  0253e	8b c1		 mov	 eax, ecx
  02540	c1 e9 02	 shr	 ecx, 2
  02543	f3 a5		 rep movsd
  02545	8b c8		 mov	 ecx, eax
  02547	83 e1 03	 and	 ecx, 3
  0254a	f3 a4		 rep movsb
  0254c	5f		 pop	 edi
  0254d	5e		 pop	 esi
  0254e	5b		 pop	 ebx

; 4406 : 	/* turn this into two memcpy's */
; 4407 : #if 0
; 4408 : 	for (i=0;i<num_chars;i++)
; 4409 : 	{
; 4410 : 		output_array[ret_value->output_pos+ret_value->output_offset+i]=input_array[ret_value->input_pos+ret_value->input_offset+i];
; 4411 : 		par_copy_index(output_indexes,ret_value->output_pos+ret_value->output_offset+i,input_indexes,ret_value->input_pos+ret_value->input_offset+i);
; 4412 : 	}
; 4413 : #endif
; 4414 : #ifdef DEBUG
; 4415 : 	printf("leaving par_copy_string_data\n");
; 4416 : #endif
; 4417 : }

  0254f	c3		 ret	 0
_par_copy_string_data ENDP
_TEXT	ENDS
PUBLIC	_par_convert_number
_TEXT	SEGMENT
_string$ = 8
_num$ = 12
_par_convert_number PROC NEAR

; 4441 : {

  02550	56		 push	 esi

; 4442 : 	register int i,total=0,temp;
; 4443 : 	
; 4444 : 	for (i=0;i<num;i++)

  02551	8b 74 24 0c	 mov	 esi, DWORD PTR _num$[esp]
  02555	33 c0		 xor	 eax, eax
  02557	33 d2		 xor	 edx, edx
  02559	85 f6		 test	 esi, esi
  0255b	57		 push	 edi
  0255c	7e 1e		 jle	 SHORT $L72454
  0255e	8b 7c 24 0c	 mov	 edi, DWORD PTR _string$[esp+4]
$L72458:

; 4445 : 	{
; 4446 : 		temp=string[i]-'0';

  02562	33 c9		 xor	 ecx, ecx
  02564	8a 0c 3a	 mov	 cl, BYTE PTR [edx+edi]
  02567	83 e9 30	 sub	 ecx, 48			; 00000030H

; 4447 : 		if ((temp<0) || (temp>9))

  0256a	78 10		 js	 SHORT $L72454
  0256c	83 f9 09	 cmp	 ecx, 9
  0256f	7f 0b		 jg	 SHORT $L72454

; 4448 : 			return(total);
; 4449 : 		total=total*10+temp;

  02571	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  02574	42		 inc	 edx
  02575	3b d6		 cmp	 edx, esi
  02577	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0257a	7c e6		 jl	 SHORT $L72458
$L72454:
  0257c	5f		 pop	 edi
  0257d	5e		 pop	 esi

; 4450 : 	}
; 4451 : 	return(total);
; 4452 : }

  0257e	c3		 ret	 0
_par_convert_number ENDP
_string$ = 8
_par_convert_number_new2 PROC NEAR

; 4479 : 	register int i,total=0,temp;
; 4480 : 	
; 4481 : 	for (i=0;;i++)
; 4482 : 	{
; 4483 : 		temp=string[i]-'0';

  02580	8b 54 24 04	 mov	 edx, DWORD PTR _string$[esp-4]
  02584	33 c9		 xor	 ecx, ecx
  02586	33 c0		 xor	 eax, eax
  02588	8a 0a		 mov	 cl, BYTE PTR [edx]
  0258a	83 e9 30	 sub	 ecx, 48			; 00000030H

; 4484 : 		if ((temp<0) || (temp>9))

  0258d	78 15		 js	 SHORT $L73218
$L72469:
  0258f	83 f9 09	 cmp	 ecx, 9
  02592	7f 10		 jg	 SHORT $L73218

; 4485 : 			return(total);
; 4486 : 		total=total*10+temp;

  02594	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  02597	42		 inc	 edx
  02598	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0259b	33 c9		 xor	 ecx, ecx
  0259d	8a 0a		 mov	 cl, BYTE PTR [edx]
  0259f	83 e9 30	 sub	 ecx, 48			; 00000030H
  025a2	79 eb		 jns	 SHORT $L72469
$L73218:

; 4487 : 	}
; 4488 : 	return(total);
; 4489 : }

  025a4	c3		 ret	 0
_par_convert_number_new2 ENDP
_TEXT	ENDS
PUBLIC	_par_get_int_length
_TEXT	SEGMENT
_i$ = 8
_par_get_int_length PROC NEAR

; 4511 : 	if (i<10)

  025b0	8b 44 24 04	 mov	 eax, DWORD PTR _i$[esp-4]
  025b4	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  025b7	7d 06		 jge	 SHORT $L72477

; 4512 : 		return(1);

  025b9	b8 01 00 00 00	 mov	 eax, 1

; 4518 : 		return(4);
; 4519 : 	else
; 4520 : 		return(5);
; 4521 : 
; 4522 : 
; 4523 : #if 0
; 4524 : 	register int j;
; 4525 : #ifdef DEBUG
; 4526 : 	printf("entering par_get_int_length\n");
; 4527 : #endif
; 4528 : 	if (i==0)
; 4529 : 	{
; 4530 : #ifdef DEBUG
; 4531 : 		printf("leaving par_get_int_length length=1\n");
; 4532 : #endif
; 4533 : 		return(1);
; 4534 : 	}
; 4535 : 	for (j=0;i;j++)
; 4536 : 		i/=10;
; 4537 : #ifdef DEBUG
; 4538 : 	printf("leaving par_get_int_length length=%d\n",j);
; 4539 : #endif
; 4540 : 	return(j);
; 4541 : #endif
; 4542 : }

  025be	c3		 ret	 0
$L72477:

; 4513 : 	else if (i<100)

  025bf	83 f8 64	 cmp	 eax, 100		; 00000064H
  025c2	7d 06		 jge	 SHORT $L72479

; 4514 : 		return(2);

  025c4	b8 02 00 00 00	 mov	 eax, 2

; 4518 : 		return(4);
; 4519 : 	else
; 4520 : 		return(5);
; 4521 : 
; 4522 : 
; 4523 : #if 0
; 4524 : 	register int j;
; 4525 : #ifdef DEBUG
; 4526 : 	printf("entering par_get_int_length\n");
; 4527 : #endif
; 4528 : 	if (i==0)
; 4529 : 	{
; 4530 : #ifdef DEBUG
; 4531 : 		printf("leaving par_get_int_length length=1\n");
; 4532 : #endif
; 4533 : 		return(1);
; 4534 : 	}
; 4535 : 	for (j=0;i;j++)
; 4536 : 		i/=10;
; 4537 : #ifdef DEBUG
; 4538 : 	printf("leaving par_get_int_length length=%d\n",j);
; 4539 : #endif
; 4540 : 	return(j);
; 4541 : #endif
; 4542 : }

  025c9	c3		 ret	 0
$L72479:

; 4515 : 	else if (i<1000)

  025ca	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  025cf	7d 06		 jge	 SHORT $L72481

; 4516 : 		return(3);

  025d1	b8 03 00 00 00	 mov	 eax, 3

; 4518 : 		return(4);
; 4519 : 	else
; 4520 : 		return(5);
; 4521 : 
; 4522 : 
; 4523 : #if 0
; 4524 : 	register int j;
; 4525 : #ifdef DEBUG
; 4526 : 	printf("entering par_get_int_length\n");
; 4527 : #endif
; 4528 : 	if (i==0)
; 4529 : 	{
; 4530 : #ifdef DEBUG
; 4531 : 		printf("leaving par_get_int_length length=1\n");
; 4532 : #endif
; 4533 : 		return(1);
; 4534 : 	}
; 4535 : 	for (j=0;i;j++)
; 4536 : 		i/=10;
; 4537 : #ifdef DEBUG
; 4538 : 	printf("leaving par_get_int_length length=%d\n",j);
; 4539 : #endif
; 4540 : 	return(j);
; 4541 : #endif
; 4542 : }

  025d6	c3		 ret	 0
$L72481:

; 4517 : 	else if (i<10000)

  025d7	33 c9		 xor	 ecx, ecx
  025d9	3d 10 27 00 00	 cmp	 eax, 10000		; 00002710H
  025de	0f 9d c1	 setge	 cl
  025e1	83 c1 04	 add	 ecx, 4
  025e4	8b c1		 mov	 eax, ecx

; 4518 : 		return(4);
; 4519 : 	else
; 4520 : 		return(5);
; 4521 : 
; 4522 : 
; 4523 : #if 0
; 4524 : 	register int j;
; 4525 : #ifdef DEBUG
; 4526 : 	printf("entering par_get_int_length\n");
; 4527 : #endif
; 4528 : 	if (i==0)
; 4529 : 	{
; 4530 : #ifdef DEBUG
; 4531 : 		printf("leaving par_get_int_length length=1\n");
; 4532 : #endif
; 4533 : 		return(1);
; 4534 : 	}
; 4535 : 	for (j=0;i;j++)
; 4536 : 		i/=10;
; 4537 : #ifdef DEBUG
; 4538 : 	printf("leaving par_get_int_length length=%d\n",j);
; 4539 : #endif
; 4540 : 	return(j);
; 4541 : #endif
; 4542 : }

  025e6	c3		 ret	 0
_par_get_int_length ENDP
_TEXT	ENDS
PUBLIC	_par_look_ahead
_TEXT	SEGMENT
_current_rule$ = 8
_input_array$ = 12
_ipos$ = 16
_find_index$ = 20
_match_array$ = 24
_ret_value$ = 28
_new_ret$ = -32
_range_value$ = -48
_par_look_ahead PROC NEAR

; 4580 : {

  025f0	83 ec 30	 sub	 esp, 48			; 00000030H

; 4581 : #ifndef NEW_PARSER_FILE_LOADING
; 4582 : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0 };
; 4583 : #else
; 4584 : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0,NULL };
; 4585 : #endif
; 4586 : 	range_value_t		range_value = {0,0,0,0};
; 4587 : 	int char_length=0;
; 4588 : 	int value;
; 4589 : 	register int rule_p;
; 4590 : 	int char_type;
; 4591 : 
; 4592 : 	rule_p=find_index;
; 4593 : #ifdef DEBUG
; 4594 : 	printf("entering par_look_ahead\n");
; 4595 : 	par_print_rule_error("par_look_ahead; the current position is",current_rule,ret_value->rule);
; 4596 : #endif
; 4597 : 	char_type=current_rule[find_index] & BIN_OPERATION_MASK;

  025f3	8b 54 24 34	 mov	 edx, DWORD PTR _current_rule$[esp+44]
  025f7	53		 push	 ebx
  025f8	56		 push	 esi
  025f9	8b 74 24 48	 mov	 esi, DWORD PTR _find_index$[esp+52]
  025fd	57		 push	 edi
  025fe	33 db		 xor	 ebx, ebx
  02600	8a 0c 32	 mov	 cl, BYTE PTR [edx+esi]
  02603	89 5c 24 1c	 mov	 DWORD PTR _new_ret$[esp+60], ebx
  02607	8a c1		 mov	 al, cl
  02609	89 5c 24 20	 mov	 DWORD PTR _new_ret$[esp+64], ebx
  0260d	83 e0 1f	 and	 eax, 31			; 0000001fH
  02610	89 5c 24 24	 mov	 DWORD PTR _new_ret$[esp+68], ebx
  02614	8b f8		 mov	 edi, eax
  02616	89 5c 24 28	 mov	 DWORD PTR _new_ret$[esp+72], ebx

; 4598 : 
; 4599 : 	if (char_type==BIN_EXACT)

  0261a	83 ff 10	 cmp	 edi, 16			; 00000010H
  0261d	89 5c 24 2c	 mov	 DWORD PTR _new_ret$[esp+76], ebx
  02621	89 5c 24 30	 mov	 DWORD PTR _new_ret$[esp+80], ebx
  02625	89 5c 24 34	 mov	 DWORD PTR _new_ret$[esp+84], ebx
  02629	89 5c 24 38	 mov	 DWORD PTR _new_ret$[esp+88], ebx
  0262d	89 5c 24 0c	 mov	 DWORD PTR _range_value$[esp+60], ebx
  02631	89 5c 24 10	 mov	 DWORD PTR _range_value$[esp+64], ebx
  02635	89 5c 24 14	 mov	 DWORD PTR _range_value$[esp+68], ebx
  02639	89 5c 24 18	 mov	 DWORD PTR _range_value$[esp+72], ebx
  0263d	0f 85 a1 00 00
	00		 jne	 $L72504

; 4600 : 	{
; 4601 : 		rule_p++;			/* skip the single quote */

  02643	46		 inc	 esi

; 4602 : 		value=current_rule[rule_p]+ipos;

  02644	33 c0		 xor	 eax, eax
  02646	8a 04 16	 mov	 al, BYTE PTR [esi+edx]
  02649	8b f8		 mov	 edi, eax
  0264b	8b 44 24 48	 mov	 eax, DWORD PTR _ipos$[esp+56]
  0264f	03 f8		 add	 edi, eax

; 4603 : 		rule_p++;

  02651	46		 inc	 esi

; 4604 : 		if (current_rule[find_index] & BIN_CASE_INSEN)

  02652	f6 c1 20	 test	 cl, 32			; 00000020H

; 4605 : 		{
; 4606 : 			if (par_lower[current_rule[rule_p]]!=par_lower[input_array[ipos]])

  02655	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  02658	74 53		 je	 SHORT $L72505
  0265a	8b 74 24 44	 mov	 esi, DWORD PTR _input_array$[esp+56]
  0265e	8a 19		 mov	 bl, BYTE PTR [ecx]
  02660	33 d2		 xor	 edx, edx
  02662	8a 14 06	 mov	 dl, BYTE PTR [esi+eax]
  02665	8a 9b 00 00 00
	00		 mov	 bl, BYTE PTR _par_lower[ebx]
  0266b	3a 9a 00 00 00
	00		 cmp	 bl, BYTE PTR _par_lower[edx]
  02671	74 09		 je	 SHORT $L73224
$L73227:
  02673	5f		 pop	 edi
  02674	5e		 pop	 esi

; 4607 : 			{
; 4608 : #ifdef DEBUG
; 4609 : 				printf("leaving par_look_ahead; exact failure\n");
; 4610 : #endif
; 4611 : 				return(0);

  02675	33 c0		 xor	 eax, eax
  02677	5b		 pop	 ebx

; 4768 : 					
; 4769 : 				} /* (char_type==BIN_RESTORE) */
; 4770 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4771 : 		} /* if (char_type<=BIN_DIGIT) */
; 4772 : 	} /* if (char_type==BIN_EXACT) */
; 4773 : 
; 4774 : #ifdef DEBUG
; 4775 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4776 : #endif
; 4777 : 	return(0);
; 4778 : 	
; 4779 : }

  02678	83 c4 30	 add	 esp, 48			; 00000030H
  0267b	c3		 ret	 0
$L73224:

; 4612 : 			}
; 4613 : 			while (ipos<value)

  0267c	3b c7		 cmp	 eax, edi
  0267e	0f 8d 39 01 00
	00		 jge	 $L72515
$L72508:

; 4614 : 			{
; 4615 : 				if (par_lower[current_rule[rule_p]]!=par_lower[input_array[ipos]])

  02684	33 db		 xor	 ebx, ebx
  02686	33 d2		 xor	 edx, edx
  02688	8a 19		 mov	 bl, BYTE PTR [ecx]
  0268a	8a 14 06	 mov	 dl, BYTE PTR [esi+eax]
  0268d	8a 9b 00 00 00
	00		 mov	 bl, BYTE PTR _par_lower[ebx]
  02693	3a 9a 00 00 00
	00		 cmp	 bl, BYTE PTR _par_lower[edx]
  02699	75 d8		 jne	 SHORT $L73227

; 4616 : 				{
; 4617 : #ifdef DEBUG
; 4618 : 					printf("leaving par_look_ahead; exact failure\n");
; 4619 : #endif
; 4620 : 					return(0);
; 4621 : 				}
; 4622 : 				ipos++;

  0269b	40		 inc	 eax

; 4623 : 				rule_p++;

  0269c	41		 inc	 ecx
  0269d	3b c7		 cmp	 eax, edi
  0269f	7c e3		 jl	 SHORT $L72508
  026a1	5f		 pop	 edi
  026a2	5e		 pop	 esi

; 4739 : 					{
; 4740 : 						if (match_array->array[value][0]!='\0')
; 4741 : 						{
; 4742 : #ifdef DEBUG
; 4743 : 							printf("leaving par_look_ahead; par_save_string success\n");
; 4744 : #endif
; 4745 : 							return(1);

  026a3	b8 01 00 00 00	 mov	 eax, 1
  026a8	5b		 pop	 ebx

; 4768 : 					
; 4769 : 				} /* (char_type==BIN_RESTORE) */
; 4770 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4771 : 		} /* if (char_type<=BIN_DIGIT) */
; 4772 : 	} /* if (char_type==BIN_EXACT) */
; 4773 : 
; 4774 : #ifdef DEBUG
; 4775 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4776 : #endif
; 4777 : 	return(0);
; 4778 : 	
; 4779 : }

  026a9	83 c4 30	 add	 esp, 48			; 00000030H
  026ac	c3		 ret	 0
$L72505:

; 4624 : 			}
; 4625 : #ifdef DEBUG
; 4626 : 			printf("leaving par_look_ahead; exact success\n");
; 4627 : #endif
; 4628 : 			return(1);
; 4629 : 		}
; 4630 : 		else /* if (current_rule[find_index] & BIN_CASE_INSEN) */
; 4631 : 		{
; 4632 : 			if (current_rule[rule_p]!=input_array[ipos])

  026ad	8b 74 24 44	 mov	 esi, DWORD PTR _input_array$[esp+56]
  026b1	8a 11		 mov	 dl, BYTE PTR [ecx]
  026b3	3a 14 06	 cmp	 dl, BYTE PTR [esi+eax]
  026b6	74 09		 je	 SHORT $L73225
  026b8	5f		 pop	 edi
  026b9	5e		 pop	 esi

; 4633 : 			{
; 4634 : #ifdef DEBUG
; 4635 : 				printf("leaving par_look_ahead; exact failure\n");
; 4636 : #endif
; 4637 : 				return(0);

  026ba	33 c0		 xor	 eax, eax
  026bc	5b		 pop	 ebx

; 4768 : 					
; 4769 : 				} /* (char_type==BIN_RESTORE) */
; 4770 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4771 : 		} /* if (char_type<=BIN_DIGIT) */
; 4772 : 	} /* if (char_type==BIN_EXACT) */
; 4773 : 
; 4774 : #ifdef DEBUG
; 4775 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4776 : #endif
; 4777 : 	return(0);
; 4778 : 	
; 4779 : }

  026bd	83 c4 30	 add	 esp, 48			; 00000030H
  026c0	c3		 ret	 0
$L73225:

; 4638 : 			}
; 4639 : 
; 4640 : 			while (ipos<value)

  026c1	3b c7		 cmp	 eax, edi
  026c3	0f 8d f4 00 00
	00		 jge	 $L72515
$L72514:

; 4641 : 			{
; 4642 : 				if (current_rule[rule_p]!=input_array[ipos])

  026c9	8a 11		 mov	 dl, BYTE PTR [ecx]
  026cb	8a 1c 06	 mov	 bl, BYTE PTR [esi+eax]
  026ce	3a d3		 cmp	 dl, bl
  026d0	75 a1		 jne	 SHORT $L73227

; 4643 : 				{
; 4644 : #ifdef DEBUG
; 4645 : 					printf("leaving par_look_ahead; exact failure\n");
; 4646 : #endif
; 4647 : 					return(0);
; 4648 : 				}
; 4649 : 				ipos++;

  026d2	40		 inc	 eax

; 4650 : 				rule_p++;

  026d3	41		 inc	 ecx
  026d4	3b c7		 cmp	 eax, edi
  026d6	7c f1		 jl	 SHORT $L72514
  026d8	5f		 pop	 edi
  026d9	5e		 pop	 esi

; 4739 : 					{
; 4740 : 						if (match_array->array[value][0]!='\0')
; 4741 : 						{
; 4742 : #ifdef DEBUG
; 4743 : 							printf("leaving par_look_ahead; par_save_string success\n");
; 4744 : #endif
; 4745 : 							return(1);

  026da	b8 01 00 00 00	 mov	 eax, 1
  026df	5b		 pop	 ebx

; 4768 : 					
; 4769 : 				} /* (char_type==BIN_RESTORE) */
; 4770 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4771 : 		} /* if (char_type<=BIN_DIGIT) */
; 4772 : 	} /* if (char_type==BIN_EXACT) */
; 4773 : 
; 4774 : #ifdef DEBUG
; 4775 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4776 : #endif
; 4777 : 	return(0);
; 4778 : 	
; 4779 : }

  026e0	83 c4 30	 add	 esp, 48			; 00000030H
  026e3	c3		 ret	 0
$L72504:

; 4651 : 			}
; 4652 : #ifdef DEBUG
; 4653 : 			printf("leaving par_look_ahead; exact success\n");
; 4654 : #endif
; 4655 : 			return(1);
; 4656 : 		}
; 4657 : #ifdef DEBUG
; 4658 : 		printf("leaving par_look_ahead; exact failure\n");
; 4659 : #endif
; 4660 : 		return(0);
; 4661 : 	}
; 4662 : 	else /* if (char_type==BIN_EXACT) */
; 4663 : 	{
; 4664 : 		if (char_type<=BIN_DIGIT)

  026e4	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  026e7	7f 78		 jg	 SHORT $L72518

; 4665 : 		{
; 4666 : 			if (current_rule[find_index] & BIN_DIGIT_RANGE)
; 4667 : 			{
; 4668 : 				/* check for the special digit type and if it is there */
; 4669 : 				/* use the special digit matching function. */
; 4670 : 				/* use the normal one otherwise */
; 4671 : 				new_ret.rule= find_index;

  026e9	89 74 24 2c	 mov	 DWORD PTR _new_ret$[esp+76], esi

; 4672 : 				new_ret.value=SUCCESS;

  026ed	be 01 00 00 00	 mov	 esi, 1
  026f2	f6 c1 20	 test	 cl, 32			; 00000020H
  026f5	89 74 24 30	 mov	 DWORD PTR _new_ret$[esp+80], esi
  026f9	74 44		 je	 SHORT $L72519

; 4673 : 				new_ret.input_pos=ipos;

  026fb	8b 44 24 48	 mov	 eax, DWORD PTR _ipos$[esp+56]

; 4674 : 				char_length=par_match_digits(current_rule,input_array,match_array,&new_ret,&range_value,0,1);

  026ff	56		 push	 esi
  02700	89 44 24 20	 mov	 DWORD PTR _new_ret$[esp+64], eax
  02704	8d 4c 24 10	 lea	 ecx, DWORD PTR _range_value$[esp+64]
  02708	53		 push	 ebx
  02709	8d 44 24 24	 lea	 eax, DWORD PTR _new_ret$[esp+68]
  0270d	51		 push	 ecx
  0270e	8b 4c 24 5c	 mov	 ecx, DWORD PTR _match_array$[esp+68]
  02712	50		 push	 eax
  02713	8b 44 24 54	 mov	 eax, DWORD PTR _input_array$[esp+72]
  02717	51		 push	 ecx
  02718	50		 push	 eax
  02719	52		 push	 edx
  0271a	e8 00 00 00 00	 call	 _par_match_digits
$L73232:

; 4675 : 				if (new_ret.value==SUCCESS)

  0271f	8b 4c 24 4c	 mov	 ecx, DWORD PTR _new_ret$[esp+108]
  02723	83 c4 1c	 add	 esp, 28			; 0000001cH
  02726	3b ce		 cmp	 ecx, esi
  02728	0f 85 45 ff ff
	ff		 jne	 $L73227

; 4676 : 				{
; 4677 : 					if (char_length>0)

  0272e	3b c3		 cmp	 eax, ebx
  02730	0f 8e 3d ff ff
	ff		 jle	 $L73227

; 4678 : 					{
; 4679 : #ifdef DEBUG
; 4680 : 						printf("leaving par_look_ahead;digit range success\n");
; 4681 : #endif
; 4682 : 						return(1);

  02736	8b c6		 mov	 eax, esi
  02738	5f		 pop	 edi
  02739	5e		 pop	 esi
  0273a	5b		 pop	 ebx

; 4768 : 					
; 4769 : 				} /* (char_type==BIN_RESTORE) */
; 4770 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4771 : 		} /* if (char_type<=BIN_DIGIT) */
; 4772 : 	} /* if (char_type==BIN_EXACT) */
; 4773 : 
; 4774 : #ifdef DEBUG
; 4775 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4776 : #endif
; 4777 : 	return(0);
; 4778 : 	
; 4779 : }

  0273b	83 c4 30	 add	 esp, 48			; 00000030H
  0273e	c3		 ret	 0
$L72519:

; 4683 : 					}
; 4684 : 				}
; 4685 : #ifdef DEBUG
; 4686 : 				printf("leaving par_look_ahead;digit range fail\n");
; 4687 : #endif
; 4688 : 				return(0);
; 4689 : 			}
; 4690 : 			else
; 4691 : 			{	/* most types */
; 4692 : 				
; 4693 : 				new_ret.rule= find_index;
; 4694 : 				new_ret.value=SUCCESS;
; 4695 : 				new_ret.input_pos=ipos;

  0273f	8b 4c 24 48	 mov	 ecx, DWORD PTR _ipos$[esp+56]

; 4696 : 				char_length=par_match_standard(current_rule,char_type ,input_array,match_array,&new_ret,0,1);

  02743	56		 push	 esi
  02744	8d 44 24 20	 lea	 eax, DWORD PTR _new_ret$[esp+64]
  02748	89 4c 24 20	 mov	 DWORD PTR _new_ret$[esp+64], ecx
  0274c	8b 4c 24 54	 mov	 ecx, DWORD PTR _match_array$[esp+60]
  02750	53		 push	 ebx
  02751	50		 push	 eax
  02752	8b 44 24 50	 mov	 eax, DWORD PTR _input_array$[esp+68]
  02756	51		 push	 ecx
  02757	50		 push	 eax
  02758	57		 push	 edi
  02759	52		 push	 edx
  0275a	e8 00 00 00 00	 call	 _par_match_standard

; 4697 : 				if (new_ret.value==SUCCESS)
; 4698 : 				{
; 4699 : 					if (char_length>0)
; 4700 : 					{
; 4701 : #ifdef DEBUG
; 4702 : 						printf("leaving par_look_ahead;standard success\n");
; 4703 : #endif
; 4704 : 						return(1);

  0275f	eb be		 jmp	 SHORT $L73232
$L72518:

; 4705 : 					}
; 4706 : 				}
; 4707 : #ifdef DEBUG
; 4708 : 				printf("leaving par_look_ahead;standard fail\n");
; 4709 : #endif
; 4710 : 				return(0);
; 4711 : 			}
; 4712 : 			
; 4713 : 		}
; 4714 : 		else /* if (char_type<=BIN_DIGIT) */
; 4715 : 		{
; 4716 : 			if (char_type==BIN_HEXADECIMAL)

  02761	83 ff 11	 cmp	 edi, 17			; 00000011H
  02764	75 1d		 jne	 SHORT $L72526

; 4717 : 			{
; 4718 : 				rule_p++;
; 4719 : 				if (input_array[ipos]==current_rule[rule_p])

  02766	8b 4c 24 48	 mov	 ecx, DWORD PTR _ipos$[esp+56]
  0276a	8b 44 24 44	 mov	 eax, DWORD PTR _input_array$[esp+56]
  0276e	8a 5c 32 01	 mov	 bl, BYTE PTR [edx+esi+1]
  02772	5f		 pop	 edi
  02773	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  02776	33 c0		 xor	 eax, eax
  02778	3a cb		 cmp	 cl, bl
  0277a	5e		 pop	 esi
  0277b	0f 94 c0	 sete	 al
  0277e	5b		 pop	 ebx

; 4768 : 					
; 4769 : 				} /* (char_type==BIN_RESTORE) */
; 4770 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4771 : 		} /* if (char_type<=BIN_DIGIT) */
; 4772 : 	} /* if (char_type==BIN_EXACT) */
; 4773 : 
; 4774 : #ifdef DEBUG
; 4775 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4776 : #endif
; 4777 : 	return(0);
; 4778 : 	
; 4779 : }

  0277f	83 c4 30	 add	 esp, 48			; 00000030H
  02782	c3		 ret	 0
$L72526:

; 4720 : 				{
; 4721 : #ifdef DEBUG
; 4722 : 					printf("leaving par_look_ahead; hex number success\n");
; 4723 : #endif
; 4724 : 					return(1);
; 4725 : 				}
; 4726 : #ifdef DEBUG
; 4727 : 				printf("leaving par_look_ahead; hex number failure\n");
; 4728 : #endif
; 4729 : 				return(0);
; 4730 : 			}
; 4731 : 			else /* if (char_type==BIN_HEXADECIMAL) */
; 4732 : 			{
; 4733 : 				if (char_type==BIN_RESTORE)

  02783	83 ff 12	 cmp	 edi, 18			; 00000012H
  02786	75 41		 jne	 SHORT $L72529

; 4734 : 				{
; 4735 : 					rule_p++;
; 4736 : 					value=current_rule[rule_p];		/* get the array number */

  02788	33 c0		 xor	 eax, eax
  0278a	8a 44 32 01	 mov	 al, BYTE PTR [edx+esi+1]

; 4737 : 					char_length=match_array->array_lengths[value];	/* get the length of the strig in the array */
; 4738 : 					if ((memcmp(input_array+ipos,match_array->array[value],char_length)==0))

  0278e	8b 74 24 44	 mov	 esi, DWORD PTR _input_array$[esp+56]
  02792	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  02795	8d 14 89	 lea	 edx, DWORD PTR [ecx+ecx*4]

; 4758 : 					{
; 4759 : #ifdef DEBUG
; 4760 : 						printf("par_look_ahead;dictionary_state dict entry found\n");
; 4761 : #endif
; 4762 : 						return(1);
; 4763 : 					}
; 4764 : #ifdef DEBUG
; 4765 : 					printf("par_look_ahead;dictionary_state dict entry not found\n");
; 4766 : #endif
; 4767 : 					return(0);			   

  02798	8b 4c 24 50	 mov	 ecx, DWORD PTR _match_array$[esp+56]
  0279c	8d 54 51 28	 lea	 edx, DWORD PTR [ecx+edx*2+40]
  027a0	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  027a3	8b 44 24 48	 mov	 eax, DWORD PTR _ipos$[esp+56]
  027a7	8b fa		 mov	 edi, edx
  027a9	03 f0		 add	 esi, eax
  027ab	33 c0		 xor	 eax, eax
  027ad	f3 a6		 repe cmpsb
  027af	0f 85 be fe ff
	ff		 jne	 $L73227
  027b5	38 1a		 cmp	 BYTE PTR [edx], bl
  027b7	0f 84 b6 fe ff
	ff		 je	 $L73227
$L72515:
  027bd	5f		 pop	 edi
  027be	5e		 pop	 esi

; 4739 : 					{
; 4740 : 						if (match_array->array[value][0]!='\0')
; 4741 : 						{
; 4742 : #ifdef DEBUG
; 4743 : 							printf("leaving par_look_ahead; par_save_string success\n");
; 4744 : #endif
; 4745 : 							return(1);

  027bf	b8 01 00 00 00	 mov	 eax, 1
  027c4	5b		 pop	 ebx

; 4768 : 					
; 4769 : 				} /* (char_type==BIN_RESTORE) */
; 4770 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4771 : 		} /* if (char_type<=BIN_DIGIT) */
; 4772 : 	} /* if (char_type==BIN_EXACT) */
; 4773 : 
; 4774 : #ifdef DEBUG
; 4775 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4776 : #endif
; 4777 : 	return(0);
; 4778 : 	
; 4779 : }

  027c5	83 c4 30	 add	 esp, 48			; 00000030H
  027c8	c3		 ret	 0
$L72529:

; 4746 : 						}
; 4747 : 					}
; 4748 : #ifdef DEBUG
; 4749 : 					printf("leaving par_look_ahead; par_save_string failure\n");
; 4750 : #endif
; 4751 : 					return(0);
; 4752 : 				}
; 4753 : 				else /* (char_type==BIN_RESTORE) */
; 4754 : 				{	/* BIN_DICTIONARY */
; 4755 : 					par_copy_return_value(&new_ret,ret_value);			  

  027c9	8b 74 24 54	 mov	 esi, DWORD PTR _ret_value$[esp+56]
  027cd	b9 08 00 00 00	 mov	 ecx, 8
  027d2	8d 7c 24 1c	 lea	 edi, DWORD PTR _new_ret$[esp+60]

; 4756 : 					new_ret.input_pos=ipos;
; 4757 : 					if (par_look_ahead_dictionary(current_rule,input_array,match_array,&new_ret))

  027d6	8d 44 24 1c	 lea	 eax, DWORD PTR _new_ret$[esp+60]
  027da	f3 a5		 rep movsd
  027dc	8b 4c 24 48	 mov	 ecx, DWORD PTR _ipos$[esp+56]
  027e0	50		 push	 eax
  027e1	8b 44 24 48	 mov	 eax, DWORD PTR _input_array$[esp+60]
  027e5	89 4c 24 20	 mov	 DWORD PTR _new_ret$[esp+64], ecx
  027e9	8b 4c 24 54	 mov	 ecx, DWORD PTR _match_array$[esp+60]
  027ed	51		 push	 ecx
  027ee	50		 push	 eax
  027ef	52		 push	 edx
  027f0	e8 00 00 00 00	 call	 _par_look_ahead_dictionary
  027f5	83 c4 10	 add	 esp, 16			; 00000010H
  027f8	f7 d8		 neg	 eax
  027fa	1b c0		 sbb	 eax, eax
  027fc	5f		 pop	 edi
  027fd	5e		 pop	 esi
  027fe	5b		 pop	 ebx
  027ff	f7 d8		 neg	 eax

; 4768 : 					
; 4769 : 				} /* (char_type==BIN_RESTORE) */
; 4770 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4771 : 		} /* if (char_type<=BIN_DIGIT) */
; 4772 : 	} /* if (char_type==BIN_EXACT) */
; 4773 : 
; 4774 : #ifdef DEBUG
; 4775 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4776 : #endif
; 4777 : 	return(0);
; 4778 : 	
; 4779 : }

  02801	83 c4 30	 add	 esp, 48			; 00000030H
  02804	c3		 ret	 0
_par_look_ahead ENDP
_input_array$ = 8
_output_array$ = 12
_input_indexes$ = 16
_output_indexes$ = 20
_ret_value$ = 24
_par_copy_word_to_output PROC NEAR

; 4807 : {

  02810	53		 push	 ebx
  02811	55		 push	 ebp

; 4808 : 	int i,ipos,opos;
; 4809 : 	
; 4810 : #ifdef DEBUG
; 4811 : 	printf("entering par_copy_word_to_output\n");
; 4812 : #endif
; 4813 : 	if ((ret_value==NULL) || (input_array==NULL) || (output_array==NULL))

  02812	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ret_value$[esp+4]
  02816	85 ed		 test	 ebp, ebp
  02818	0f 84 cb 00 00
	00		 je	 $L72553
  0281e	8b 5c 24 0c	 mov	 ebx, DWORD PTR _input_array$[esp+4]
  02822	85 db		 test	 ebx, ebx
  02824	0f 84 bf 00 00
	00		 je	 $L72553
  0282a	8b 44 24 10	 mov	 eax, DWORD PTR _output_array$[esp+4]
  0282e	85 c0		 test	 eax, eax
  02830	0f 84 b3 00 00
	00		 je	 $L72553

; 4819 : 	}                      
; 4820 : 	ipos=ret_value->input_pos+ret_value->input_offset;

  02836	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  02839	56		 push	 esi
  0283a	8b 75 04	 mov	 esi, DWORD PTR [ebp+4]

; 4821 : 	opos=ret_value->output_pos+ret_value->output_offset;

  0283d	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  02840	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
  02843	03 f1		 add	 esi, ecx
  02845	57		 push	 edi
  02846	03 d0		 add	 edx, eax

; 4822 : 	i=0;
; 4823 : 	/* this function only copies non whitespace, so it never has to check for indexes */
; 4824 : 	while (((parser_char_types[(int)(input_array[ipos+i])] & TYPE_white)==0) && (input_array[ipos+i]!='\0'))

  02848	8a 0c 1e	 mov	 cl, BYTE PTR [esi+ebx]
  0284b	33 c0		 xor	 eax, eax
  0284d	8b f9		 mov	 edi, ecx
  0284f	81 e7 ff 00 00
	00		 and	 edi, 255		; 000000ffH
  02855	f6 04 7d 00 00
	00 00 20	 test	 BYTE PTR _parser_char_types[edi*2], 32 ; 00000020H
  0285d	75 69		 jne	 SHORT $L72557
  0285f	8b 5c 24 20	 mov	 ebx, DWORD PTR _output_indexes$[esp+12]
  02863	8d 3c 52	 lea	 edi, DWORD PTR [edx+edx*2]
  02866	8d 3c 7b	 lea	 edi, DWORD PTR [ebx+edi*2]
  02869	8b 5c 24 1c	 mov	 ebx, DWORD PTR _input_indexes$[esp+12]
  0286d	89 7c 24 20	 mov	 DWORD PTR 20+[esp+12], edi
  02871	8d 3c 76	 lea	 edi, DWORD PTR [esi+esi*2]
  02874	8d 3c 7b	 lea	 edi, DWORD PTR [ebx+edi*2]
  02877	8b 5c 24 14	 mov	 ebx, DWORD PTR _input_array$[esp+12]
$L72556:
  0287b	84 c9		 test	 cl, cl
  0287d	74 49		 je	 SHORT $L72557

; 4825 : 	{
; 4826 : 		output_array[opos+i]=input_array[ipos+i];        

  0287f	8b 6c 24 18	 mov	 ebp, DWORD PTR _output_array$[esp+12]
  02883	8d 1c 10	 lea	 ebx, DWORD PTR [eax+edx]

; 4827 : 		/* copy the index anyway even if it isn't there */
; 4828 : 		par_copy_index(output_indexes,opos+i,input_indexes,ipos+i);
; 4829 : #ifdef DEBUG
; 4830 : 		printf("output_array[%d]=%c ",opos+i,output_array[opos+i]);
; 4831 : #endif
; 4832 : 		i++;

  02886	40		 inc	 eax
  02887	88 0c 2b	 mov	 BYTE PTR [ebx+ebp], cl
  0288a	8b 5c 24 20	 mov	 ebx, DWORD PTR 20+[esp+12]
  0288e	8b cf		 mov	 ecx, edi
  02890	83 c7 06	 add	 edi, 6
  02893	8b 29		 mov	 ebp, DWORD PTR [ecx]
  02895	89 2b		 mov	 DWORD PTR [ebx], ebp
  02897	66 8b 49 04	 mov	 cx, WORD PTR [ecx+4]
  0289b	66 89 4b 04	 mov	 WORD PTR [ebx+4], cx
  0289f	8b cb		 mov	 ecx, ebx
  028a1	8b 5c 24 14	 mov	 ebx, DWORD PTR _input_array$[esp+12]
  028a5	83 c1 06	 add	 ecx, 6
  028a8	89 4c 24 20	 mov	 DWORD PTR 20+[esp+12], ecx
  028ac	8d 0c 1e	 lea	 ecx, DWORD PTR [esi+ebx]
  028af	8a 0c 01	 mov	 cl, BYTE PTR [ecx+eax]
  028b2	8b e9		 mov	 ebp, ecx
  028b4	81 e5 ff 00 00
	00		 and	 ebp, 255		; 000000ffH
  028ba	f6 04 6d 00 00
	00 00 20	 test	 BYTE PTR _parser_char_types[ebp*2], 32 ; 00000020H
  028c2	8b 6c 24 24	 mov	 ebp, DWORD PTR _ret_value$[esp+12]
  028c6	74 b3		 je	 SHORT $L72556
$L72557:

; 4833 : 	}
; 4834 : 	ret_value->input_offset+=i;

  028c8	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]

; 4835 : 	ret_value->output_offset+=i;

  028cb	8b 7d 0c	 mov	 edi, DWORD PTR [ebp+12]
  028ce	03 c8		 add	 ecx, eax
  028d0	03 f8		 add	 edi, eax

; 4836 : 	if (input_array[ipos+i]=='\0')

  028d2	03 c6		 add	 eax, esi
  028d4	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  028d7	89 7d 0c	 mov	 DWORD PTR [ebp+12], edi
  028da	5f		 pop	 edi
  028db	8a 04 18	 mov	 al, BYTE PTR [eax+ebx]
  028de	5e		 pop	 esi
  028df	f6 d8		 neg	 al
  028e1	1b c0		 sbb	 eax, eax
  028e3	5d		 pop	 ebp
  028e4	f7 d8		 neg	 eax
  028e6	48		 dec	 eax
  028e7	5b		 pop	 ebx

; 4837 : 	{
; 4838 : #ifdef DEBUG
; 4839 : 		printf("leaving par_copy_word_to_output b -1\n");
; 4840 : #endif
; 4841 : 		return(-1);
; 4842 : 	}
; 4843 : #ifdef DEBUG
; 4844 : 	printf("leaving par_copy_word_to_output b \n");
; 4845 : #endif
; 4846 : 	return(0);
; 4847 : }

  028e8	c3		 ret	 0
$L72553:
  028e9	5d		 pop	 ebp

; 4814 : 	{
; 4815 : #ifdef DEBUG
; 4816 : 		printf("leaving par_copy_word_to_output a 0\n");
; 4817 : #endif
; 4818 : 		return(0);

  028ea	33 c0		 xor	 eax, eax
  028ec	5b		 pop	 ebx

; 4837 : 	{
; 4838 : #ifdef DEBUG
; 4839 : 		printf("leaving par_copy_word_to_output b -1\n");
; 4840 : #endif
; 4841 : 		return(-1);
; 4842 : 	}
; 4843 : #ifdef DEBUG
; 4844 : 	printf("leaving par_copy_word_to_output b \n");
; 4845 : #endif
; 4846 : 	return(0);
; 4847 : }

  028ed	c3		 ret	 0
_par_copy_word_to_output ENDP
_input_array$ = 8
_input_indexes$ = 12
_output_array$ = 16
_output_indexes$ = 20
_ret_value$ = 24
_ipos$ = -4
_par_skip_white_space PROC NEAR

; 4876 : {

  028f0	83 ec 08	 sub	 esp, 8
  028f3	55		 push	 ebp

; 4877 : 	int i,ipos,opos,j;
; 4878 : 	
; 4879 : #ifdef DEBUG
; 4880 : 	printf("entering par_skip_white_space\n");
; 4881 : #endif
; 4882 : 	if ((ret_value==NULL) || (input_array==NULL) || (output_array==NULL))

  028f4	8b 6c 24 20	 mov	 ebp, DWORD PTR _ret_value$[esp+8]
  028f8	85 ed		 test	 ebp, ebp
  028fa	0f 84 10 01 00
	00		 je	 $L72578
  02900	8b 44 24 10	 mov	 eax, DWORD PTR _input_array$[esp+8]
  02904	85 c0		 test	 eax, eax
  02906	0f 84 04 01 00
	00		 je	 $L72578
  0290c	8b 4c 24 18	 mov	 ecx, DWORD PTR _output_array$[esp+8]
  02910	85 c9		 test	 ecx, ecx
  02912	0f 84 f8 00 00
	00		 je	 $L72578

; 4888 : 	}
; 4889 : 	ipos=ret_value->input_pos+ret_value->input_offset;
; 4890 : 	opos=ret_value->output_pos+ret_value->output_offset;

  02918	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  0291b	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  0291e	53		 push	 ebx
  0291f	8b 5d 04	 mov	 ebx, DWORD PTR [ebp+4]
  02922	56		 push	 esi
  02923	8b 75 00	 mov	 esi, DWORD PTR [ebp]
  02926	03 de		 add	 ebx, esi
  02928	03 ca		 add	 ecx, edx

; 4891 : 	i=0;                                             
; 4892 : 	j=0;
; 4893 : 	while (((parser_char_types[(int)(input_array[ipos+i])] & TYPE_white)!=0) && (input_array[ipos+i]!='\0'))

  0292a	03 c3		 add	 eax, ebx
  0292c	33 d2		 xor	 edx, edx
  0292e	89 44 24 0c	 mov	 DWORD PTR -8+[esp+20], eax
  02932	57		 push	 edi
  02933	8a 10		 mov	 dl, BYTE PTR [eax]
  02935	33 f6		 xor	 esi, esi
  02937	33 ff		 xor	 edi, edi
  02939	89 5c 24 14	 mov	 DWORD PTR _ipos$[esp+24], ebx
  0293d	f6 04 55 00 00
	00 00 20	 test	 BYTE PTR _parser_char_types[edx*2], 32 ; 00000020H
  02945	0f 84 9e 00 00
	00		 je	 $L72582
  0294b	8b 54 24 28	 mov	 edx, DWORD PTR _output_indexes$[esp+20]
  0294f	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  02952	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  02955	8d 14 5b	 lea	 edx, DWORD PTR [ebx+ebx*2]
  02958	89 44 24 28	 mov	 DWORD PTR 20+[esp+20], eax
  0295c	8b 44 24 20	 mov	 eax, DWORD PTR _input_indexes$[esp+20]
  02960	8d 44 50 04	 lea	 eax, DWORD PTR [eax+edx*2+4]
$L72581:
  02964	8b 54 24 10	 mov	 edx, DWORD PTR -8+[esp+24]
  02968	8a 14 32	 mov	 dl, BYTE PTR [edx+esi]
  0296b	84 d2		 test	 dl, dl
  0296d	74 7a		 je	 SHORT $L72582

; 4894 : 	{
; 4895 : 		if (i==0 || par_is_index_set(input_indexes,ipos+i))

  0296f	85 f6		 test	 esi, esi
  02971	74 14		 je	 SHORT $L73245
  02973	66 83 78 fc 00	 cmp	 WORD PTR [eax-4], 0
  02978	75 0d		 jne	 SHORT $L73245
  0297a	66 83 78 fe 00	 cmp	 WORD PTR [eax-2], 0
  0297f	75 06		 jne	 SHORT $L73245
  02981	66 83 38 00	 cmp	 WORD PTR [eax], 0
  02985	74 43		 je	 SHORT $L72586
$L73245:

; 4896 : 		{
; 4897 : 			output_array[opos+j]=input_array[ipos+i];

  02987	8b 6c 24 24	 mov	 ebp, DWORD PTR _output_array$[esp+20]
  0298b	8d 1c 0f	 lea	 ebx, DWORD PTR [edi+ecx]
  0298e	88 14 2b	 mov	 BYTE PTR [ebx+ebp], dl

; 4898 : 			if (par_is_index_set(input_indexes,ipos+i))

  02991	66 83 78 fc 00	 cmp	 WORD PTR [eax-4], 0
  02996	75 0d		 jne	 SHORT $L73252
  02998	66 83 78 fe 00	 cmp	 WORD PTR [eax-2], 0
  0299d	75 06		 jne	 SHORT $L73252
  0299f	66 83 38 00	 cmp	 WORD PTR [eax], 0
  029a3	74 15		 je	 SHORT $L72585
$L73252:

; 4899 : 			{                                       
; 4900 : #ifdef INDEX_DEBUG
; 4901 : 				printf("copying index from %d to %d\n",ipos+i,opos+j);
; 4902 : #endif
; 4903 : 				par_copy_index(output_indexes,opos+j,input_indexes,ipos+i);

  029a5	8b 54 24 28	 mov	 edx, DWORD PTR 20+[esp+20]
  029a9	8b 68 fc	 mov	 ebp, DWORD PTR [eax-4]
  029ac	8b da		 mov	 ebx, edx

; 4904 : 				j++;

  029ae	47		 inc	 edi
  029af	89 2b		 mov	 DWORD PTR [ebx], ebp
  029b1	66 8b 28	 mov	 bp, WORD PTR [eax]
  029b4	66 89 6b 04	 mov	 WORD PTR [ebx+4], bp

; 4905 : 			}
; 4906 : 			else

  029b8	eb 05		 jmp	 SHORT $L73264
$L72585:

; 4907 : 			{
; 4908 : 				j++;

  029ba	8b 54 24 28	 mov	 edx, DWORD PTR 20+[esp+20]
  029be	47		 inc	 edi
$L73264:
  029bf	8b 6c 24 2c	 mov	 ebp, DWORD PTR _ret_value$[esp+20]
  029c3	83 c2 06	 add	 edx, 6
  029c6	89 54 24 28	 mov	 DWORD PTR 20+[esp+20], edx
$L72586:
  029ca	8b 5c 24 10	 mov	 ebx, DWORD PTR -8+[esp+24]

; 4909 : 			}
; 4910 : #ifdef INDEX_DEBUG
; 4911 : 			if (i!=0)
; 4912 : 			{
; 4913 : 				printf("copied extra space because of index\n");
; 4914 : 			}
; 4915 : 			printf("output_array[%d]=%c\n",opos+i,output_array[opos+i]);
; 4916 : #endif
; 4917 : 		}
; 4918 : 		i++;

  029ce	46		 inc	 esi
  029cf	33 d2		 xor	 edx, edx
  029d1	83 c0 06	 add	 eax, 6
  029d4	8a 14 33	 mov	 dl, BYTE PTR [ebx+esi]
  029d7	f6 04 55 00 00
	00 00 20	 test	 BYTE PTR _parser_char_types[edx*2], 32 ; 00000020H
  029df	8b 5c 24 14	 mov	 ebx, DWORD PTR _ipos$[esp+24]
  029e3	0f 85 7b ff ff
	ff		 jne	 $L72581
$L72582:

; 4919 : 	}
; 4920 : 	ret_value->input_offset+=i;

  029e9	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  029ec	03 ce		 add	 ecx, esi

; 4921 : 	if (i>0)

  029ee	85 f6		 test	 esi, esi
  029f0	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  029f3	7e 03		 jle	 SHORT $L72587

; 4922 : 		ret_value->output_offset+=j;

  029f5	01 7d 0c	 add	 DWORD PTR [ebp+12], edi
$L72587:

; 4923 : 	if (input_array[ipos+i]=='\0')

  029f8	8b 44 24 1c	 mov	 eax, DWORD PTR _input_array$[esp+20]
  029fc	03 f3		 add	 esi, ebx
  029fe	5f		 pop	 edi
  029ff	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  02a02	5e		 pop	 esi
  02a03	f6 d8		 neg	 al
  02a05	1b c0		 sbb	 eax, eax
  02a07	5b		 pop	 ebx
  02a08	f7 d8		 neg	 eax
  02a0a	48		 dec	 eax
  02a0b	5d		 pop	 ebp

; 4924 : 	{
; 4925 : #ifdef DEBUG
; 4926 : 		printf("leaving par_skip_white_space b -1\n");
; 4927 : #endif
; 4928 : 		return(-1);
; 4929 : 	}
; 4930 : #ifdef DEBUG
; 4931 : 	printf("leaving par_skip_white_space b 0\n");
; 4932 : #endif
; 4933 : 	return(0);
; 4934 : }

  02a0c	83 c4 08	 add	 esp, 8
  02a0f	c3		 ret	 0
$L72578:

; 4883 : 	{
; 4884 : #ifdef DEBUG
; 4885 : 		printf("leaving par_skip_white_space a 0\n");
; 4886 : #endif
; 4887 : 		return(0);

  02a10	33 c0		 xor	 eax, eax
  02a12	5d		 pop	 ebp

; 4924 : 	{
; 4925 : #ifdef DEBUG
; 4926 : 		printf("leaving par_skip_white_space b -1\n");
; 4927 : #endif
; 4928 : 		return(-1);
; 4929 : 	}
; 4930 : #ifdef DEBUG
; 4931 : 	printf("leaving par_skip_white_space b 0\n");
; 4932 : #endif
; 4933 : 	return(0);
; 4934 : }

  02a13	83 c4 08	 add	 esp, 8
  02a16	c3		 ret	 0
_par_skip_white_space ENDP
_TEXT	ENDS
_DATA	SEGMENT
$SG72597 DB	'%s', 0aH, 00H
$SG72598 DB	'error in rule at position %d', 0aH, 00H
	ORG $+2
$SG72599 DB	'rule, %s', 0aH, 00H
	ORG $+2
$SG72600 DB	'      ', 00H
	ORG $+1
$SG72604 DB	' ', 00H
	ORG $+2
$SG72605 DB	'^', 0aH, 00H
_DATA	ENDS
_TEXT	SEGMENT
_message$ = 8
_current_rule$ = 12
_pos$ = 16
_par_print_rule_error PROC NEAR

; 4960 : 	int i;
; 4961 : 	printf("%s\n",message);

  02a20	8b 44 24 04	 mov	 eax, DWORD PTR _message$[esp-4]
  02a24	56		 push	 esi
  02a25	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__printf
  02a2b	57		 push	 edi
  02a2c	50		 push	 eax
  02a2d	68 00 00 00 00	 push	 OFFSET FLAT:$SG72597
  02a32	ff d6		 call	 esi

; 4962 : 	printf("error in rule at position %d\n",pos);

  02a34	8b 7c 24 1c	 mov	 edi, DWORD PTR _pos$[esp+12]
  02a38	57		 push	 edi
  02a39	68 00 00 00 00	 push	 OFFSET FLAT:$SG72598
  02a3e	ff d6		 call	 esi

; 4963 : 	printf("rule, %s\n",current_rule);

  02a40	8b 4c 24 20	 mov	 ecx, DWORD PTR _current_rule$[esp+20]
  02a44	51		 push	 ecx
  02a45	68 00 00 00 00	 push	 OFFSET FLAT:$SG72599
  02a4a	ff d6		 call	 esi

; 4964 : 	printf("      ");

  02a4c	68 00 00 00 00	 push	 OFFSET FLAT:$SG72600
  02a51	ff d6		 call	 esi
  02a53	83 c4 1c	 add	 esp, 28			; 0000001cH

; 4965 : 	for (i=0;i<pos;i++)

  02a56	85 ff		 test	 edi, edi
  02a58	7e 0d		 jle	 SHORT $L72603
$L72601:

; 4966 : 	{
; 4967 : 		printf(" ");

  02a5a	68 00 00 00 00	 push	 OFFSET FLAT:$SG72604
  02a5f	ff d6		 call	 esi
  02a61	83 c4 04	 add	 esp, 4
  02a64	4f		 dec	 edi
  02a65	75 f3		 jne	 SHORT $L72601
$L72603:

; 4968 : 	}
; 4969 : 	printf("^\n");

  02a67	68 00 00 00 00	 push	 OFFSET FLAT:$SG72605
  02a6c	ff d6		 call	 esi
  02a6e	83 c4 04	 add	 esp, 4
  02a71	5f		 pop	 edi
  02a72	5e		 pop	 esi

; 4970 : }

  02a73	c3		 ret	 0
_par_print_rule_error ENDP
_current_rule$ = 8
_char_type$ = 12
_input_array$ = 16
_match_array$ = 20
_ret_value$ = 24
_lookahead$ = 28
_break_on_min_match$ = 32
_rule_p$ = 12
_length$ = -52
_ipos$ = -20
_min_range$ = -40
_match_is_over$ = -48
_satisfied_min_cond$ = -32
_new_char_type$ = -8
_i$ = -44
_counter$ = 8
_match_non_match$ = -12
_in_rule_p$ = -4
_next_type$ = -36
_num_desc$ = -28
_large_desc$ = -16
_par_match_standard PROC NEAR

; 5033 : {

  02a80	83 ec 34	 sub	 esp, 52			; 00000034H

; 5034 : 	int rule_p;
; 5035 : 	int length=0;
; 5036 : 	int ipos;
; 5037 : 	int min_range= -1,max_range= -1;
; 5038 : 	int match_is_over=0;
; 5039 : 	int satisfied_min_cond= -1;
; 5040 :     int new_char_type;
; 5041 : 	int i=0,counter;          
; 5042 : 	int match_non_match=1;         /* 1 is match 0 is non-match */
; 5043 : //	int find_type= -2;
; 5044 : 	int temp;
; 5045 : 	int temp2;
; 5046 : 	int in_rule_p;
; 5047 : 	int next_type=0;
; 5048 : 	int num_desc;
; 5049 : 	int large_desc=0;
; 5050 : 	
; 5051 : 	
; 5052 : #ifdef DEBUG
; 5053 : 	printf("entering par_match_standard\n");
; 5054 : #endif
; 5055 : #ifdef SANITY_CHECKING
; 5056 : 	if (ret_value==NULL)
; 5057 : 	{
; 5058 : #ifdef DEBUG
; 5059 : 		printf("leaving par_match_standard a 0\n");
; 5060 : #endif
; 5061 : 		return(0);
; 5062 : 	}
; 5063 : 	if ((current_rule==NULL) || (input_array==NULL))
; 5064 : 	{
; 5065 : 		ret_value->value=FATAL_FAIL;
; 5066 : #ifdef DEBUG
; 5067 : 		printf("leaving par_match_standard b 0\n");
; 5068 : #endif
; 5069 : 		return(0);
; 5070 : 	}
; 5071 : #endif
; 5072 : 	rule_p=ret_value->rule;

  02a83	8b 44 24 48	 mov	 eax, DWORD PTR _ret_value$[esp+48]
  02a87	53		 push	 ebx
  02a88	55		 push	 ebp

; 5073 : 	in_rule_p=rule_p;
; 5074 : 	ipos=ret_value->input_pos+ret_value->input_offset;
; 5075 : 	/* skip past the type delimiter */
; 5076 : 	new_char_type=char_type_table[char_type];
; 5077 : 	if (current_rule[rule_p] & BIN_LOOK_FROM_DISABLE)

  02a89	8b 6c 24 40	 mov	 ebp, DWORD PTR _current_rule$[esp+56]
  02a8d	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]
  02a90	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  02a93	56		 push	 esi
  02a94	57		 push	 edi
  02a95	8b 38		 mov	 edi, DWORD PTR [eax]
  02a97	8b 44 24 4c	 mov	 eax, DWORD PTR _char_type$[esp+64]
  02a9b	33 f6		 xor	 esi, esi
  02a9d	b9 01 00 00 00	 mov	 ecx, 1
  02aa2	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _char_type_table[eax*4]
  02aa9	03 d7		 add	 edx, edi
  02aab	89 44 24 3c	 mov	 DWORD PTR _new_char_type$[esp+68], eax
  02aaf	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02ab2	a8 40		 test	 al, 64			; 00000040H
  02ab4	89 74 24 10	 mov	 DWORD PTR _length$[esp+68], esi
  02ab8	89 74 24 14	 mov	 DWORD PTR _match_is_over$[esp+68], esi
  02abc	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR _satisfied_min_cond$[esp+68], -1
  02ac4	89 74 24 18	 mov	 DWORD PTR _i$[esp+68], esi
  02ac8	89 4c 24 38	 mov	 DWORD PTR _match_non_match$[esp+68], ecx
  02acc	89 74 24 20	 mov	 DWORD PTR _next_type$[esp+68], esi
  02ad0	89 74 24 34	 mov	 DWORD PTR _large_desc$[esp+68], esi
  02ad4	89 5c 24 40	 mov	 DWORD PTR _in_rule_p$[esp+68], ebx
  02ad8	89 54 24 30	 mov	 DWORD PTR _ipos$[esp+68], edx
  02adc	74 04		 je	 SHORT $L72638

; 5078 : 	{
; 5079 : 		lookahead=0;

  02ade	89 74 24 5c	 mov	 DWORD PTR _lookahead$[esp+64], esi
$L72638:

; 5080 : #ifdef DEBUG
; 5081 : 		printf("match_standard set no lookahead\n");
; 5082 : #endif
; 5083 : 	}
; 5084 : 	rule_p++; /* move past operation */

  02ae2	43		 inc	 ebx

; 5085 : 	temp=current_rule[rule_p];

  02ae3	33 c0		 xor	 eax, eax
  02ae5	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]

; 5086 : 	if (temp & BIN_COMPLIMENT)

  02ae8	a8 80		 test	 al, -128		; ffffff80H
  02aea	74 04		 je	 SHORT $L72639

; 5087 : 	{
; 5088 : #ifdef DEBUG
; 5089 : 		printf("match_standard set to non matches\n");
; 5090 : #endif
; 5091 : 		match_non_match=0;

  02aec	89 74 24 38	 mov	 DWORD PTR _match_non_match$[esp+68], esi
$L72639:

; 5092 : 	}
; 5093 : 	if (temp & BIN_LARGE_DESC)

  02af0	a8 40		 test	 al, 64			; 00000040H
  02af2	74 04		 je	 SHORT $L72640

; 5094 : 	{
; 5095 : 		large_desc=1;

  02af4	89 4c 24 34	 mov	 DWORD PTR _large_desc$[esp+68], ecx
$L72640:

; 5096 : #ifdef DEBUG
; 5097 : 		printf("match_standard using large descriptors\n");
; 5098 : #endif
; 5099 : 	}
; 5100 : 	num_desc=(temp & BIN_SIZE_DESC_MASK);

  02af8	83 e0 3f	 and	 eax, 63			; 0000003fH

; 5101 : 	counter=0;
; 5102 : 	rule_p++; /* move past number of descrpitors */

  02afb	43		 inc	 ebx
  02afc	8b f8		 mov	 edi, eax

; 5103 : 	if (lookahead!=0)

  02afe	8b 44 24 5c	 mov	 eax, DWORD PTR _lookahead$[esp+64]
  02b02	85 c0		 test	 eax, eax
  02b04	89 7c 24 28	 mov	 DWORD PTR _num_desc$[esp+68], edi
  02b08	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR _counter$[esp+64], 0
  02b10	74 0a		 je	 SHORT $L73269

; 5104 : 	{
; 5105 : 		next_type=current_rule[rule_p];

  02b12	33 c9		 xor	 ecx, ecx
  02b14	8a 0c 2b	 mov	 cl, BYTE PTR [ebx+ebp]

; 5106 : 		rule_p++; /* move past next type */

  02b17	43		 inc	 ebx
  02b18	89 4c 24 20	 mov	 DWORD PTR _next_type$[esp+68], ecx
$L73269:

; 5107 : 	}
; 5108 : 	/* either there is a number or there is a star of a plus */ 
; 5109 : 	while ((counter<num_desc) && (match_is_over==0))

  02b1c	85 ff		 test	 edi, edi
  02b1e	0f 8e af 02 00
	00		 jle	 $L73281
$L72643:
  02b24	8b 44 24 14	 mov	 eax, DWORD PTR _match_is_over$[esp+68]
  02b28	85 c0		 test	 eax, eax
  02b2a	0f 85 9a 02 00
	00		 jne	 $L73278

; 5110 : 	{
; 5111 : 		if (large_desc)

  02b30	8b 44 24 34	 mov	 eax, DWORD PTR _large_desc$[esp+68]
  02b34	85 c0		 test	 eax, eax
  02b36	74 65		 je	 SHORT $L72645

; 5112 : 		{
; 5113 : 			temp=get_short(current_rule+rule_p);
; 5114 : 			rule_p+=2;
; 5115 : 			counter++;

  02b38	8b 4c 24 48	 mov	 ecx, DWORD PTR _counter$[esp+64]
  02b3c	33 c0		 xor	 eax, eax
  02b3e	8a 64 2b 01	 mov	 ah, BYTE PTR [ebx+ebp+1]
  02b42	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02b45	83 c3 02	 add	 ebx, 2
  02b48	41		 inc	 ecx
  02b49	89 5c 24 4c	 mov	 DWORD PTR _rule_p$[esp+64], ebx
  02b4d	89 4c 24 48	 mov	 DWORD PTR _counter$[esp+64], ecx

; 5116 : 			min_range = temp & BIN_MAX_LARGE_DESC;

  02b51	8b c8		 mov	 ecx, eax
  02b53	81 e1 ff 3f 00
	00		 and	 ecx, 16383		; 00003fffH

; 5117 : 			max_range=min_range;
; 5118 : 			if (temp & BIN_LARGE_ANY_NUMBER)

  02b59	f6 c4 80	 test	 ah, -128		; ffffff80H
  02b5c	89 4c 24 1c	 mov	 DWORD PTR _min_range$[esp+68], ecx
  02b60	8b f9		 mov	 edi, ecx
  02b62	74 07		 je	 SHORT $L72649

; 5119 : 			{
; 5120 : 				max_range=INT_MAX;

  02b64	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH

; 5121 : 			}
; 5122 : 			else

  02b69	eb 7b		 jmp	 SHORT $L72660
$L72649:

; 5123 : 			{
; 5124 : 				if (temp & BIN_LARGE_CONTINUE)

  02b6b	f6 c4 40	 test	 ah, 64			; 00000040H
  02b6e	74 76		 je	 SHORT $L72660

; 5125 : 				{
; 5126 : 					temp=get_short(current_rule+rule_p);
; 5127 : 					rule_p+=2;
; 5128 : 					counter++;

  02b70	8b 7c 24 48	 mov	 edi, DWORD PTR _counter$[esp+64]
  02b74	33 c0		 xor	 eax, eax
  02b76	8a 64 2b 01	 mov	 ah, BYTE PTR [ebx+ebp+1]
  02b7a	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02b7d	83 c3 02	 add	 ebx, 2
  02b80	47		 inc	 edi
  02b81	89 5c 24 4c	 mov	 DWORD PTR _rule_p$[esp+64], ebx
  02b85	89 7c 24 48	 mov	 DWORD PTR _counter$[esp+64], edi

; 5129 : 					max_range = temp & BIN_MAX_LARGE_DESC;

  02b89	8b f8		 mov	 edi, eax
  02b8b	81 e7 ff 3f 00
	00		 and	 edi, 16383		; 00003fffH

; 5130 : 					if (temp & BIN_LARGE_ANY_NUMBER)

  02b91	f6 c4 80	 test	 ah, -128		; ffffff80H
  02b94	74 50		 je	 SHORT $L72660

; 5131 : 					{
; 5132 : 						max_range=INT_MAX;

  02b96	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH

; 5133 : 					}
; 5134 : 				}
; 5135 : 			}
; 5136 : 		}
; 5137 : 		else

  02b9b	eb 49		 jmp	 SHORT $L72660
$L72645:

; 5138 : 		{
; 5139 : 			temp=current_rule[rule_p];
; 5140 : 			rule_p++;
; 5141 : 			counter++;

  02b9d	8b 7c 24 48	 mov	 edi, DWORD PTR _counter$[esp+64]
  02ba1	33 c0		 xor	 eax, eax
  02ba3	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02ba6	43		 inc	 ebx
  02ba7	47		 inc	 edi
  02ba8	89 5c 24 4c	 mov	 DWORD PTR _rule_p$[esp+64], ebx
  02bac	89 7c 24 48	 mov	 DWORD PTR _counter$[esp+64], edi

; 5142 : 			min_range = temp & BIN_MAX_SMALL_DESC;

  02bb0	8b f8		 mov	 edi, eax
  02bb2	83 e7 3f	 and	 edi, 63			; 0000003fH

; 5143 : 			max_range=min_range;
; 5144 : 			if (temp & BIN_SMALL_ANY_NUMBER)

  02bb5	a8 80		 test	 al, -128		; ffffff80H
  02bb7	89 7c 24 1c	 mov	 DWORD PTR _min_range$[esp+68], edi

; 5145 : 			{
; 5146 : 				max_range=INT_MAX;
; 5147 : 			}
; 5148 : 			else

  02bbb	75 20		 jne	 SHORT $L73298

; 5149 : 			{
; 5150 : 				if (temp & BIN_SMALL_CONTINUE)

  02bbd	a8 40		 test	 al, 64			; 00000040H
  02bbf	74 21		 je	 SHORT $L73286

; 5151 : 				{
; 5152 : 					temp=current_rule[rule_p];
; 5153 : 					rule_p++;
; 5154 : 					counter++;

  02bc1	8b 7c 24 48	 mov	 edi, DWORD PTR _counter$[esp+64]
  02bc5	33 c0		 xor	 eax, eax
  02bc7	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02bca	43		 inc	 ebx
  02bcb	47		 inc	 edi
  02bcc	89 5c 24 4c	 mov	 DWORD PTR _rule_p$[esp+64], ebx
  02bd0	89 7c 24 48	 mov	 DWORD PTR _counter$[esp+64], edi

; 5155 : 					max_range = temp & BIN_MAX_SMALL_DESC;

  02bd4	8b f8		 mov	 edi, eax
  02bd6	83 e7 3f	 and	 edi, 63			; 0000003fH

; 5156 : 					if (temp & BIN_SMALL_ANY_NUMBER)

  02bd9	a8 80		 test	 al, -128		; ffffff80H
  02bdb	74 05		 je	 SHORT $L73286
$L73298:

; 5157 : 					{
; 5158 : 						max_range=INT_MAX;

  02bdd	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
$L73286:
  02be2	8b 4c 24 1c	 mov	 ecx, DWORD PTR _min_range$[esp+68]
$L72660:

; 5159 : 					}
; 5160 : 				}
; 5161 : 			}
; 5162 : 		}
; 5163 : 		
; 5164 : 		
; 5165 : 		
; 5166 : 		/* do the character matching starting at length until min_length */
; 5167 : 		/* then match from min_length to max_length */
; 5168 : 		/* once min_length is reached, do lookahead for the next char type if necessary */
; 5169 : 		if (min_range==0)

  02be6	85 c9		 test	 ecx, ecx
  02be8	75 3f		 jne	 SHORT $L72664

; 5170 : 		{
; 5171 : 			/* signal that there could be success on a zero length string */
; 5172 : 			/* or the end of string could be successful too */
; 5173 : 			satisfied_min_cond= -2;                          
; 5174 : 			if (length==0)

  02bea	85 f6		 test	 esi, esi
  02bec	c7 44 24 24 fe
	ff ff ff	 mov	 DWORD PTR _satisfied_min_cond$[esp+68], -2 ; fffffffeH
  02bf4	75 2f		 jne	 SHORT $L73287

; 5175 : 			{
; 5176 : 				if (lookahead)

  02bf6	8b 44 24 5c	 mov	 eax, DWORD PTR _lookahead$[esp+64]
  02bfa	85 c0		 test	 eax, eax
  02bfc	74 27		 je	 SHORT $L73287

; 5177 : 				{
; 5178 : 					if ((par_look_ahead(current_rule,input_array,ipos,next_type,match_array,ret_value)==1))

  02bfe	8b 44 24 58	 mov	 eax, DWORD PTR _ret_value$[esp+64]
  02c02	8b 4c 24 54	 mov	 ecx, DWORD PTR _match_array$[esp+64]
  02c06	50		 push	 eax
  02c07	8b 44 24 24	 mov	 eax, DWORD PTR _next_type$[esp+72]
  02c0b	51		 push	 ecx
  02c0c	8b 4c 24 58	 mov	 ecx, DWORD PTR _input_array$[esp+72]
  02c10	50		 push	 eax
  02c11	52		 push	 edx
  02c12	51		 push	 ecx
  02c13	55		 push	 ebp
  02c14	e8 00 00 00 00	 call	 _par_look_ahead
  02c19	83 c4 18	 add	 esp, 24			; 00000018H
  02c1c	83 f8 01	 cmp	 eax, 1
  02c1f	0f 84 c1 01 00
	00		 je	 $L73283
$L73287:
  02c25	8b 54 24 30	 mov	 edx, DWORD PTR _ipos$[esp+68]
$L72664:

; 5179 : 					{
; 5180 : 						break;
; 5181 : 					}
; 5182 : 				}
; 5183 : 			}
; 5184 : 		}
; 5185 : 		if (match_non_match==1)

  02c29	8b 44 24 38	 mov	 eax, DWORD PTR _match_non_match$[esp+68]

; 5186 : 		{
; 5187 : 			
; 5188 : 			for (i=length;i<max_range;i++)

  02c2d	89 74 24 18	 mov	 DWORD PTR _i$[esp+68], esi
  02c31	83 f8 01	 cmp	 eax, 1
  02c34	0f 85 bc 00 00
	00		 jne	 $L72665
  02c3a	3b f7		 cmp	 esi, edi
  02c3c	0f 8d 74 01 00
	00		 jge	 $L72679
  02c42	8b 4c 24 50	 mov	 ecx, DWORD PTR _input_array$[esp+64]
  02c46	8d 5e 01	 lea	 ebx, DWORD PTR [esi+1]
  02c49	03 f2		 add	 esi, edx
  02c4b	b8 01 00 00 00	 mov	 eax, 1
  02c50	03 f1		 add	 esi, ecx
  02c52	2b c1		 sub	 eax, ecx
  02c54	89 44 24 2c	 mov	 DWORD PTR -24+[esp+68], eax
$L72666:

; 5189 : 			{
; 5190 : 				temp2=input_array[ipos+i];
; 5191 : 				
; 5192 : 				if ((((parser_char_types[temp2]) & new_char_type)==0) || (temp2=='\0'))

  02c58	8b 4c 24 3c	 mov	 ecx, DWORD PTR _new_char_type$[esp+68]
  02c5c	33 c0		 xor	 eax, eax
  02c5e	8a 06		 mov	 al, BYTE PTR [esi]
  02c60	33 d2		 xor	 edx, edx
  02c62	66 8b 14 45 00
	00 00 00	 mov	 dx, WORD PTR _parser_char_types[eax*2]
  02c6a	85 d1		 test	 edx, ecx
  02c6c	0f 84 34 01 00
	00		 je	 $L73274
  02c72	85 c0		 test	 eax, eax
  02c74	0f 84 2c 01 00
	00		 je	 $L73274

; 5193 : 				{   
; 5194 : 					/* the matching failed in the section between the last range and the current range */
; 5195 : 					/* return length as the number of character matched */
; 5196 : 					match_is_over=1;
; 5197 : 					break;
; 5198 : 				}
; 5199 : 				temp=i+1;
; 5200 : 				if ((temp)>=min_range)

  02c7a	3b 5c 24 1c	 cmp	 ebx, DWORD PTR _min_range$[esp+68]
  02c7e	7c 5e		 jl	 SHORT $L72667

; 5201 : 				{
; 5202 : 					satisfied_min_cond=length=temp;
; 5203 : 					if (break_on_min_match==1)

  02c80	8b 4c 24 60	 mov	 ecx, DWORD PTR _break_on_min_match$[esp+64]
  02c84	b8 01 00 00 00	 mov	 eax, 1
  02c89	3b c8		 cmp	 ecx, eax
  02c8b	89 5c 24 10	 mov	 DWORD PTR _length$[esp+68], ebx
  02c8f	89 5c 24 24	 mov	 DWORD PTR _satisfied_min_cond$[esp+68], ebx
  02c93	0f 84 07 01 00
	00		 je	 $L73273

; 5204 : 					{
; 5205 : 						match_is_over=1;
; 5206 : 						break;
; 5207 : 					}					    
; 5208 : 					if ((lookahead) && ((counter<num_desc) || ( ((temp)<max_range))))

  02c99	8b 44 24 5c	 mov	 eax, DWORD PTR _lookahead$[esp+64]
  02c9d	85 c0		 test	 eax, eax
  02c9f	74 3d		 je	 SHORT $L72667
  02ca1	8b 54 24 28	 mov	 edx, DWORD PTR _num_desc$[esp+68]
  02ca5	8b 44 24 48	 mov	 eax, DWORD PTR _counter$[esp+64]
  02ca9	3b c2		 cmp	 eax, edx
  02cab	7c 04		 jl	 SHORT $L72674
  02cad	3b df		 cmp	 ebx, edi
  02caf	7d 2d		 jge	 SHORT $L72667
$L72674:

; 5209 : 					{
; 5210 : 						if (par_look_ahead(current_rule,input_array,ipos+temp,next_type,match_array,ret_value)==1)

  02cb1	8b 44 24 58	 mov	 eax, DWORD PTR _ret_value$[esp+64]
  02cb5	8b 4c 24 54	 mov	 ecx, DWORD PTR _match_array$[esp+64]
  02cb9	8b 54 24 20	 mov	 edx, DWORD PTR _next_type$[esp+68]
  02cbd	50		 push	 eax
  02cbe	8b 44 24 30	 mov	 eax, DWORD PTR -24+[esp+72]
  02cc2	51		 push	 ecx
  02cc3	8b 4c 24 58	 mov	 ecx, DWORD PTR _input_array$[esp+72]
  02cc7	03 c6		 add	 eax, esi
  02cc9	52		 push	 edx
  02cca	50		 push	 eax
  02ccb	51		 push	 ecx
  02ccc	55		 push	 ebp
  02ccd	e8 00 00 00 00	 call	 _par_look_ahead
  02cd2	83 c4 18	 add	 esp, 24			; 00000018H
  02cd5	83 f8 01	 cmp	 eax, 1
  02cd8	0f 84 c8 00 00
	00		 je	 $L73274
$L72667:

; 5186 : 		{
; 5187 : 			
; 5188 : 			for (i=length;i<max_range;i++)

  02cde	8b 44 24 18	 mov	 eax, DWORD PTR _i$[esp+68]
  02ce2	40		 inc	 eax
  02ce3	46		 inc	 esi
  02ce4	43		 inc	 ebx
  02ce5	3b c7		 cmp	 eax, edi
  02ce7	89 44 24 18	 mov	 DWORD PTR _i$[esp+68], eax
  02ceb	0f 8c 67 ff ff
	ff		 jl	 $L72666

; 5177 : 				{
; 5178 : 					if ((par_look_ahead(current_rule,input_array,ipos,next_type,match_array,ret_value)==1))

  02cf1	e9 b8 00 00 00	 jmp	 $L73297
$L72665:

; 5211 : 						{
; 5212 : 							match_is_over=1;
; 5213 : 							break;
; 5214 : 						}
; 5215 : 					}
; 5216 : 				}
; 5217 : 			}
; 5218 : 		}
; 5219 : 		else
; 5220 : 		{
; 5221 : 			for (i=length;i<max_range;i++)

  02cf6	3b f7		 cmp	 esi, edi
  02cf8	0f 8d b8 00 00
	00		 jge	 $L72679
  02cfe	8b 4c 24 50	 mov	 ecx, DWORD PTR _input_array$[esp+64]
  02d02	8d 5e 01	 lea	 ebx, DWORD PTR [esi+1]
  02d05	03 f2		 add	 esi, edx
  02d07	b8 01 00 00 00	 mov	 eax, 1
  02d0c	03 f1		 add	 esi, ecx
  02d0e	2b c1		 sub	 eax, ecx
  02d10	89 44 24 2c	 mov	 DWORD PTR -24+[esp+68], eax
$L72677:

; 5222 : 			{
; 5223 : 				temp2=input_array[ipos+i];
; 5224 : 				
; 5225 : 				if ((((parser_char_types[temp2]) & new_char_type)!=0) || (temp2=='\0'))

  02d14	8b 4c 24 3c	 mov	 ecx, DWORD PTR _new_char_type$[esp+68]
  02d18	33 c0		 xor	 eax, eax
  02d1a	8a 06		 mov	 al, BYTE PTR [esi]
  02d1c	33 d2		 xor	 edx, edx
  02d1e	66 8b 14 45 00
	00 00 00	 mov	 dx, WORD PTR _parser_char_types[eax*2]
  02d26	85 d1		 test	 edx, ecx
  02d28	75 7c		 jne	 SHORT $L73274
  02d2a	85 c0		 test	 eax, eax
  02d2c	74 78		 je	 SHORT $L73274

; 5230 : 					break;
; 5231 : 				}
; 5232 : 				temp=i+1;
; 5233 : 				if ((temp)>=min_range)

  02d2e	3b 5c 24 1c	 cmp	 ebx, DWORD PTR _min_range$[esp+68]
  02d32	7c 57		 jl	 SHORT $L72678

; 5234 : 				{
; 5235 : 					satisfied_min_cond=length=temp;
; 5236 : 					if (break_on_min_match==1)

  02d34	8b 4c 24 60	 mov	 ecx, DWORD PTR _break_on_min_match$[esp+64]
  02d38	b8 01 00 00 00	 mov	 eax, 1
  02d3d	3b c8		 cmp	 ecx, eax
  02d3f	89 5c 24 10	 mov	 DWORD PTR _length$[esp+68], ebx
  02d43	89 5c 24 24	 mov	 DWORD PTR _satisfied_min_cond$[esp+68], ebx
  02d47	74 57		 je	 SHORT $L73273

; 5240 : 					}					    
; 5241 : 					if ((lookahead) && ((counter<num_desc) || (((temp)<max_range))))

  02d49	8b 44 24 5c	 mov	 eax, DWORD PTR _lookahead$[esp+64]
  02d4d	85 c0		 test	 eax, eax
  02d4f	74 3a		 je	 SHORT $L72678
  02d51	8b 54 24 28	 mov	 edx, DWORD PTR _num_desc$[esp+68]
  02d55	8b 44 24 48	 mov	 eax, DWORD PTR _counter$[esp+64]
  02d59	3b c2		 cmp	 eax, edx
  02d5b	7c 04		 jl	 SHORT $L72685
  02d5d	3b df		 cmp	 ebx, edi
  02d5f	7d 2a		 jge	 SHORT $L72678
$L72685:

; 5242 : 					{
; 5243 : 						if (par_look_ahead(current_rule,input_array,ipos+temp,next_type,match_array,ret_value)==1)

  02d61	8b 44 24 58	 mov	 eax, DWORD PTR _ret_value$[esp+64]
  02d65	8b 4c 24 54	 mov	 ecx, DWORD PTR _match_array$[esp+64]
  02d69	8b 54 24 20	 mov	 edx, DWORD PTR _next_type$[esp+68]
  02d6d	50		 push	 eax
  02d6e	8b 44 24 30	 mov	 eax, DWORD PTR -24+[esp+72]
  02d72	51		 push	 ecx
  02d73	52		 push	 edx
  02d74	8b 54 24 5c	 mov	 edx, DWORD PTR _input_array$[esp+76]
  02d78	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  02d7b	51		 push	 ecx
  02d7c	52		 push	 edx
  02d7d	55		 push	 ebp
  02d7e	e8 00 00 00 00	 call	 _par_look_ahead
  02d83	83 c4 18	 add	 esp, 24			; 00000018H
  02d86	83 f8 01	 cmp	 eax, 1
  02d89	74 1b		 je	 SHORT $L73274
$L72678:

; 5211 : 						{
; 5212 : 							match_is_over=1;
; 5213 : 							break;
; 5214 : 						}
; 5215 : 					}
; 5216 : 				}
; 5217 : 			}
; 5218 : 		}
; 5219 : 		else
; 5220 : 		{
; 5221 : 			for (i=length;i<max_range;i++)

  02d8b	8b 44 24 18	 mov	 eax, DWORD PTR _i$[esp+68]
  02d8f	40		 inc	 eax
  02d90	46		 inc	 esi
  02d91	43		 inc	 ebx
  02d92	3b c7		 cmp	 eax, edi
  02d94	89 44 24 18	 mov	 DWORD PTR _i$[esp+68], eax
  02d98	0f 8c 76 ff ff
	ff		 jl	 $L72677

; 5177 : 				{
; 5178 : 					if ((par_look_ahead(current_rule,input_array,ipos,next_type,match_array,ret_value)==1))

  02d9e	eb 0e		 jmp	 SHORT $L73297
$L73273:

; 5237 : 					{
; 5238 : 						match_is_over=1;

  02da0	89 44 24 14	 mov	 DWORD PTR _match_is_over$[esp+68], eax

; 5239 : 						break;

  02da4	eb 08		 jmp	 SHORT $L73297
$L73274:

; 5226 : 				{   
; 5227 : 					/* the matching failed in the section between the last range and the current range */
; 5228 : 					/* return length as the number of character matched */
; 5229 : 					match_is_over=1;

  02da6	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _match_is_over$[esp+68], 1
$L73297:
  02dae	8b 74 24 10	 mov	 esi, DWORD PTR _length$[esp+68]
  02db2	8b 5c 24 4c	 mov	 ebx, DWORD PTR _rule_p$[esp+64]
$L72679:
  02db6	8b 7c 24 28	 mov	 edi, DWORD PTR _num_desc$[esp+68]
  02dba	8b 44 24 48	 mov	 eax, DWORD PTR _counter$[esp+64]
  02dbe	8b 54 24 30	 mov	 edx, DWORD PTR _ipos$[esp+68]
  02dc2	3b c7		 cmp	 eax, edi
  02dc4	0f 8c 5a fd ff
	ff		 jl	 $L72643
$L73278:

; 5244 : 						{
; 5245 : 							match_is_over=1;
; 5246 : 							break;
; 5247 : 						}
; 5248 : 					}
; 5249 : 				}
; 5250 : 			}
; 5251 : 		}
; 5252 : 	}
; 5253 : #ifdef DEBUG
; 5254 : 	printf("par_match_standard;rule_p=%d\n",rule_p);
; 5255 : #endif
; 5256 : 	/* look for the next format type specifier */
; 5257 : 	/* look up in the table of ambiguity to know whether or not to do the lookahead parsing */
; 5258 : 	/* start mathcing the string */
; 5259 : 	/* once the minimum requirement for the type is met, start checking for the next type if required */
; 5260 : 	/* end the matching once the lookahead is successful or the current match hits the maximum 
; 5261 : 	number of characters */                
; 5262 : 	if (satisfied_min_cond== -1)

  02dca	8b 44 24 24	 mov	 eax, DWORD PTR _satisfied_min_cond$[esp+68]
  02dce	83 f8 ff	 cmp	 eax, -1
  02dd1	75 0a		 jne	 SHORT $L72687
$L73281:
  02dd3	5f		 pop	 edi
  02dd4	5e		 pop	 esi
  02dd5	5d		 pop	 ebp

; 5263 : 	{   /* changed for speed */ 
; 5264 : //		ret_value->value=FAIL;
; 5265 : 		return(0);

  02dd6	33 c0		 xor	 eax, eax
  02dd8	5b		 pop	 ebx

; 5305 : }

  02dd9	83 c4 34	 add	 esp, 52			; 00000034H
  02ddc	c3		 ret	 0
$L72687:

; 5266 : 	}
; 5267 : 	if (satisfied_min_cond== -2)

  02ddd	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  02de0	75 37		 jne	 SHORT $L72688

; 5268 : 	{
; 5269 : 		if (length==0)

  02de2	85 f6		 test	 esi, esi
  02de4	75 10		 jne	 SHORT $L72692
$L73283:

; 5270 : 		{
; 5271 : 			length= -2;
; 5272 : 		}
; 5273 : 	}
; 5274 : 	else

  02de6	8b 7c 24 28	 mov	 edi, DWORD PTR _num_desc$[esp+68]
  02dea	c7 44 24 10 fe
	ff ff ff	 mov	 DWORD PTR _length$[esp+68], -2 ; fffffffeH
  02df2	8b 74 24 10	 mov	 esi, DWORD PTR _length$[esp+68]
$L72692:

; 5281 : 			}
; 5282 : 		}                                        
; 5283 : 	}
; 5284 : 	if (counter!=num_desc)

  02df6	39 7c 24 48	 cmp	 DWORD PTR _counter$[esp+64], edi
  02dfa	74 44		 je	 SHORT $L72693

; 5285 : 	{
; 5286 : 		temp=in_rule_p;
; 5287 : 		temp+=2;

  02dfc	8b 54 24 40	 mov	 edx, DWORD PTR _in_rule_p$[esp+68]

; 5288 : 		if (lookahead)

  02e00	8b 4c 24 5c	 mov	 ecx, DWORD PTR _lookahead$[esp+64]
  02e04	85 c9		 test	 ecx, ecx
  02e06	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  02e09	74 01		 je	 SHORT $L72694

; 5289 : 			temp++;

  02e0b	40		 inc	 eax
$L72694:

; 5290 : 		if (large_desc)

  02e0c	8b 4c 24 34	 mov	 ecx, DWORD PTR _large_desc$[esp+68]
  02e10	85 c9		 test	 ecx, ecx
  02e12	74 24		 je	 SHORT $L72695

; 5291 : 		{
; 5292 : 			temp+=num_desc<<1;

  02e14	8d 04 78	 lea	 eax, DWORD PTR [eax+edi*2]

; 5293 : 		}
; 5294 : 		else

  02e17	eb 21		 jmp	 SHORT $L72696
$L72688:

; 5275 : 	{
; 5276 : 		if (input_array[ipos+i]=='\0')

  02e19	8b 44 24 18	 mov	 eax, DWORD PTR _i$[esp+68]
  02e1d	8b 4c 24 50	 mov	 ecx, DWORD PTR _input_array$[esp+64]
  02e21	03 d0		 add	 edx, eax
  02e23	80 3c 0a 00	 cmp	 BYTE PTR [edx+ecx], 0
  02e27	75 cd		 jne	 SHORT $L72692

; 5277 : 		{
; 5278 : 			if (length==0)

  02e29	85 f6		 test	 esi, esi
  02e2b	75 c9		 jne	 SHORT $L72692
  02e2d	5f		 pop	 edi
  02e2e	5e		 pop	 esi
  02e2f	5d		 pop	 ebp

; 5279 : 			{	/* changed for speed */
; 5280 : 				return(-1);

  02e30	83 c8 ff	 or	 eax, -1
  02e33	5b		 pop	 ebx

; 5305 : }

  02e34	83 c4 34	 add	 esp, 52			; 00000034H
  02e37	c3		 ret	 0
$L72695:

; 5295 : 		{
; 5296 : 			temp+=num_desc;

  02e38	03 c7		 add	 eax, edi
$L72696:

; 5297 : 		}
; 5298 : 		rule_p=temp;

  02e3a	89 44 24 4c	 mov	 DWORD PTR _rule_p$[esp+64], eax
  02e3e	8b d8		 mov	 ebx, eax
$L72693:

; 5299 : 	}
; 5300 : 	ret_value->rule=rule_p;

  02e40	8b 44 24 58	 mov	 eax, DWORD PTR _ret_value$[esp+64]
  02e44	5f		 pop	 edi
  02e45	89 58 10	 mov	 DWORD PTR [eax+16], ebx

; 5301 : #ifdef DEBUG
; 5302 : 	printf("leaving par_match_standard length=%d ret_value->value=%d\n",length,ret_value->value);
; 5303 : #endif
; 5304 : 	return(length);

  02e48	8b c6		 mov	 eax, esi
  02e4a	5e		 pop	 esi
  02e4b	5d		 pop	 ebp
  02e4c	5b		 pop	 ebx

; 5305 : }

  02e4d	83 c4 34	 add	 esp, 52			; 00000034H
  02e50	c3		 ret	 0
_par_match_standard ENDP
_range_value$ = 24
_lookahead$ = 28
_break_on_min_match$ = 32
_length$ = -24
_ipos$ = -28
_max_range$ = -8
_match_is_over$ = -36
_satisfied_min_cond$ = -16
_satisfied_start$ = -12
_temp_num$ = -40
_i$ = -44
_counter$ = 8
_in_rule_p$ = -4
_next_type$ = -20
_num_desc$ = -48
_large_desc$ = -32
_current_rule$ = 8
_input_array$ = 12
_match_array$ = 16
_ret_value$ = 20
_par_match_digits PROC NEAR

; 5342 : {

  02e60	83 ec 30	 sub	 esp, 48			; 00000030H

; 5343 : 	int rule_p;							/* a temproary rule pointer */
; 5344 : 	int	length=0;						/* the length of the matched characters */
; 5345 : 	int	ipos;							/* the input_pos+input_offset from ret_value */
; 5346 : 	int min_range= -1;					/* the minimum value of the current range */
; 5347 : 	int	max_range= -1;					/* the maximum value of the range */
; 5348 : 	int	match_is_over=0;				/* a flag to signal that the matching has failed */
; 5349 : 	int	satisfied_min_cond= -1;			/* holds the value of the largest number that

  02e63	83 c8 ff	 or	 eax, -1
  02e66	53		 push	 ebx
  02e67	89 44 24 24	 mov	 DWORD PTR _satisfied_min_cond$[esp+52], eax

; 5350 : 										* is still in the range found so far */
; 5351 : 	int	satisfied_start= -1;			/* holds the starting value of the number in satisfied_min_cond */

  02e6b	89 44 24 28	 mov	 DWORD PTR _satisfied_start$[esp+52], eax

; 5352 : 	int temp_num=0;						/* a temporary variable to hold the current number being processes */
; 5353 : 	//int end_of_type=0;					/* flag that signals the end of the type specifier has been reached in the rule */
; 5354 : 	register int i=0;
; 5355 : 	int counter;          
; 5356 : 	//int find_type= -2;						/* the type that par_look_ahead found */
; 5357 : 	int temp;
; 5358 : 	int in_rule_p;
; 5359 : 	int next_type=0;
; 5360 : 	int num_desc;
; 5361 : 	int new_char_type;
; 5362 : 	int large_desc=0;
; 5363 : 	
; 5364 : 	
; 5365 : #ifdef DEBUG
; 5366 : 	printf("entering par_match_digits\n");
; 5367 : #endif            
; 5368 : #ifdef SANITY_CHECKING
; 5369 : 	if (ret_value==NULL)
; 5370 : 	{
; 5371 : #ifdef DEBUG
; 5372 : 		printf("leaving par_match_digits a 0\n");
; 5373 : #endif
; 5374 : 		return(0);
; 5375 : 	}
; 5376 : 	if ((current_rule==NULL) || (input_array==NULL) ||
; 5377 : 		(range_value==NULL))
; 5378 : 	{
; 5379 : 		ret_value->value=FATAL_FAIL;
; 5380 : #ifdef DEBUG
; 5381 : 		printf("leaving par_match_digits b 0\n");
; 5382 : #endif
; 5383 : 		return(0);
; 5384 : 	}
; 5385 : #endif
; 5386 : 	
; 5387 : 	rule_p=ret_value->rule;

  02e6f	8b 44 24 44	 mov	 eax, DWORD PTR _ret_value$[esp+48]
  02e73	55		 push	 ebp

; 5388 : 	in_rule_p=rule_p;
; 5389 : 	ipos=ret_value->input_pos+ret_value->input_offset;
; 5390 : 	/* skip past the type delimiter */
; 5391 : 	new_char_type=char_type_table[BIN_DIGIT];
; 5392 : 	if (current_rule[rule_p] & BIN_LOOK_FROM_DISABLE)

  02e74	8b 6c 24 3c	 mov	 ebp, DWORD PTR _current_rule$[esp+52]
  02e78	56		 push	 esi
  02e79	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  02e7c	8b 10		 mov	 edx, DWORD PTR [eax]
  02e7e	57		 push	 edi
  02e7f	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  02e82	33 f6		 xor	 esi, esi
  02e84	03 ca		 add	 ecx, edx
  02e86	8a 04 2f	 mov	 al, BYTE PTR [edi+ebp]
  02e89	89 74 24 28	 mov	 DWORD PTR _length$[esp+64], esi
  02e8d	a8 40		 test	 al, 64			; 00000040H
  02e8f	89 74 24 1c	 mov	 DWORD PTR _match_is_over$[esp+64], esi
  02e93	89 74 24 18	 mov	 DWORD PTR _temp_num$[esp+64], esi
  02e97	89 74 24 14	 mov	 DWORD PTR _i$[esp+64], esi
  02e9b	89 74 24 2c	 mov	 DWORD PTR _next_type$[esp+64], esi
  02e9f	89 74 24 20	 mov	 DWORD PTR _large_desc$[esp+64], esi
  02ea3	89 7c 24 3c	 mov	 DWORD PTR _in_rule_p$[esp+64], edi
  02ea7	89 4c 24 24	 mov	 DWORD PTR _ipos$[esp+64], ecx
  02eab	74 04		 je	 SHORT $L72729

; 5393 : 	{
; 5394 : 		lookahead=0;

  02ead	89 74 24 58	 mov	 DWORD PTR _lookahead$[esp+60], esi
$L72729:

; 5395 : #ifdef DEBUG
; 5396 : 		printf("match_standard set no lookahead\n");
; 5397 : #endif
; 5398 : 	}
; 5399 : 	rule_p++; /* move past operation */
; 5400 : 	if (current_rule[rule_p] & BIN_LARGE_DESC)

  02eb1	8a 44 2f 01	 mov	 al, BYTE PTR [edi+ebp+1]
  02eb5	47		 inc	 edi
  02eb6	a8 40		 test	 al, 64			; 00000040H

; 5401 : 	{
; 5402 : 		large_desc=1;

  02eb8	ba 01 00 00 00	 mov	 edx, 1
  02ebd	74 04		 je	 SHORT $L72730
  02ebf	89 54 24 20	 mov	 DWORD PTR _large_desc$[esp+64], edx
$L72730:

; 5403 : #ifdef DEBUG
; 5404 : 		printf("match_standard using large descriptors\n");
; 5405 : #endif
; 5406 : 	}
; 5407 : 	num_desc=(current_rule[rule_p] & BIN_SIZE_DESC_MASK);
; 5408 : 	counter=0;
; 5409 : 	rule_p++; /* move past number of descrpitors */
; 5410 : 	if (lookahead!=0)

  02ec3	8b 4c 24 58	 mov	 ecx, DWORD PTR _lookahead$[esp+60]
  02ec7	83 e0 3f	 and	 eax, 63			; 0000003fH
  02eca	47		 inc	 edi
  02ecb	3b ce		 cmp	 ecx, esi
  02ecd	89 44 24 10	 mov	 DWORD PTR _num_desc$[esp+64], eax
  02ed1	89 74 24 44	 mov	 DWORD PTR _counter$[esp+60], esi
  02ed5	74 0a		 je	 SHORT $L73300

; 5411 : 	{
; 5412 : 		next_type=current_rule[rule_p];

  02ed7	33 c9		 xor	 ecx, ecx
  02ed9	8a 0c 2f	 mov	 cl, BYTE PTR [edi+ebp]

; 5413 : 		rule_p++; /* move past next type */

  02edc	47		 inc	 edi
  02edd	89 4c 24 2c	 mov	 DWORD PTR _next_type$[esp+64], ecx
$L73300:

; 5414 : 	}
; 5415 : 	/* either there is a number or there is a star of a plus */ 
; 5416 : 	
; 5417 : 	while ((counter<num_desc) && (match_is_over==0))

  02ee1	8b 5c 24 54	 mov	 ebx, DWORD PTR _range_value$[esp+60]
  02ee5	3b c6		 cmp	 eax, esi
  02ee7	0f 8e 03 02 00
	00		 jle	 $L73304
  02eed	eb 0b		 jmp	 SHORT $L72733
$L73308:
  02eef	8b 44 24 10	 mov	 eax, DWORD PTR _num_desc$[esp+64]
  02ef3	ba 01 00 00 00	 mov	 edx, 1
  02ef8	33 f6		 xor	 esi, esi
$L72733:
  02efa	39 74 24 1c	 cmp	 DWORD PTR _match_is_over$[esp+64], esi
  02efe	0f 85 ec 01 00
	00		 jne	 $L73304

; 5418 : 	{
; 5419 : 		if (large_desc)

  02f04	39 74 24 20	 cmp	 DWORD PTR _large_desc$[esp+64], esi
  02f08	74 4c		 je	 SHORT $L72735

; 5420 : 		{
; 5421 : 			temp=get_short(current_rule+rule_p);
; 5422 : 			rule_p+=2;
; 5423 : 			counter++;

  02f0a	8b 44 24 44	 mov	 eax, DWORD PTR _counter$[esp+60]
  02f0e	33 c9		 xor	 ecx, ecx
  02f10	8a 6c 2f 01	 mov	 ch, BYTE PTR [edi+ebp+1]
  02f14	8a 0c 2f	 mov	 cl, BYTE PTR [edi+ebp]
  02f17	83 c7 02	 add	 edi, 2
  02f1a	40		 inc	 eax
  02f1b	89 44 24 44	 mov	 DWORD PTR _counter$[esp+60], eax

; 5424 : 			min_range = temp & BIN_MAX_LARGE_DESC;

  02f1f	8b c1		 mov	 eax, ecx
  02f21	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH

; 5425 : 			max_range=min_range;
; 5426 : 			if (temp & BIN_LARGE_ANY_NUMBER)

  02f26	f6 c5 80	 test	 ch, -128		; ffffff80H
  02f29	8b f0		 mov	 esi, eax

; 5427 : 			{
; 5428 : 				max_range=INT_MAX;
; 5429 : 			}
; 5430 : 			else

  02f2b	75 62		 jne	 SHORT $L73317

; 5431 : 			{
; 5432 : 				if (temp & BIN_LARGE_CONTINUE)

  02f2d	f6 c5 40	 test	 ch, 64			; 00000040H
  02f30	74 62		 je	 SHORT $L72750

; 5433 : 				{
; 5434 : 					temp=get_short(current_rule+rule_p);
; 5435 : 					rule_p+=2;
; 5436 : 					counter++;

  02f32	8b 74 24 44	 mov	 esi, DWORD PTR _counter$[esp+60]
  02f36	33 c9		 xor	 ecx, ecx
  02f38	8a 6c 2f 01	 mov	 ch, BYTE PTR [edi+ebp+1]
  02f3c	8a 0c 2f	 mov	 cl, BYTE PTR [edi+ebp]
  02f3f	83 c7 02	 add	 edi, 2
  02f42	46		 inc	 esi
  02f43	89 74 24 44	 mov	 DWORD PTR _counter$[esp+60], esi

; 5437 : 					max_range = temp & BIN_MAX_LARGE_DESC;

  02f47	8b f1		 mov	 esi, ecx
  02f49	81 e6 ff 3f 00
	00		 and	 esi, 16383		; 00003fffH

; 5438 : 					if (temp & BIN_LARGE_ANY_NUMBER)

  02f4f	f6 c5 80	 test	 ch, -128		; ffffff80H
  02f52	74 40		 je	 SHORT $L72750

; 5439 : 					{
; 5440 : 						max_range=INT_MAX;
; 5441 : 					}
; 5442 : 				}
; 5443 : 			}
; 5444 : 		}
; 5445 : 		else

  02f54	eb 39		 jmp	 SHORT $L73317
$L72735:

; 5446 : 		{
; 5447 : 			temp=current_rule[rule_p];
; 5448 : 			rule_p++;
; 5449 : 			counter++;

  02f56	8b 44 24 44	 mov	 eax, DWORD PTR _counter$[esp+60]
  02f5a	33 c9		 xor	 ecx, ecx
  02f5c	8a 0c 2f	 mov	 cl, BYTE PTR [edi+ebp]
  02f5f	47		 inc	 edi
  02f60	40		 inc	 eax
  02f61	89 44 24 44	 mov	 DWORD PTR _counter$[esp+60], eax

; 5450 : 			min_range = temp & BIN_MAX_SMALL_DESC;

  02f65	8b c1		 mov	 eax, ecx
  02f67	83 e0 3f	 and	 eax, 63			; 0000003fH

; 5451 : 			max_range=min_range;
; 5452 : 			if (temp & BIN_SMALL_ANY_NUMBER)

  02f6a	f6 c1 80	 test	 cl, -128		; ffffff80H
  02f6d	8b f0		 mov	 esi, eax

; 5453 : 			{
; 5454 : 				max_range=INT_MAX;
; 5455 : 			}
; 5456 : 			else

  02f6f	75 1e		 jne	 SHORT $L73317

; 5457 : 			{
; 5458 : 				if (temp & BIN_SMALL_CONTINUE)

  02f71	f6 c1 40	 test	 cl, 64			; 00000040H
  02f74	74 1e		 je	 SHORT $L72750

; 5459 : 				{
; 5460 : 					temp=current_rule[rule_p];
; 5461 : 					rule_p++;
; 5462 : 					counter++;

  02f76	8b 74 24 44	 mov	 esi, DWORD PTR _counter$[esp+60]
  02f7a	33 c9		 xor	 ecx, ecx
  02f7c	8a 0c 2f	 mov	 cl, BYTE PTR [edi+ebp]
  02f7f	47		 inc	 edi
  02f80	46		 inc	 esi
  02f81	89 74 24 44	 mov	 DWORD PTR _counter$[esp+60], esi

; 5463 : 					max_range = temp & BIN_MAX_SMALL_DESC;

  02f85	8b f1		 mov	 esi, ecx
  02f87	83 e6 3f	 and	 esi, 63			; 0000003fH

; 5464 : 					if (temp & BIN_SMALL_ANY_NUMBER)

  02f8a	f6 c1 80	 test	 cl, -128		; ffffff80H
  02f8d	74 05		 je	 SHORT $L72750
$L73317:

; 5465 : 					{
; 5466 : 						max_range=INT_MAX;

  02f8f	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
$L72750:

; 5467 : 					}
; 5468 : 				}
; 5469 : 			}
; 5470 : 		}
; 5471 : 		
; 5472 : 		/* do the character matching starting at length until min_length */
; 5473 : 		/* then match from min_length to max_length */
; 5474 : 		/* once min_length is reached, do lookahead for the next char type if necessary */
; 5475 : 		/* this is the conversion from actual number to number lengths */
; 5476 : 		if (range_value->range_set==0)

  02f94	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  02f97	85 c9		 test	 ecx, ecx
  02f99	75 07		 jne	 SHORT $L72751

; 5477 : 		{
; 5478 : 			range_value->range_set=1;

  02f9b	89 53 0c	 mov	 DWORD PTR [ebx+12], edx

; 5479 : 			range_value->start=min_range;

  02f9e	89 03		 mov	 DWORD PTR [ebx], eax

; 5480 : 		}
; 5481 : 		else

  02fa0	eb 1f		 jmp	 SHORT $L72754
$L72751:

; 5482 : 		{
; 5483 : 			if (range_value->range_set==2)

  02fa2	83 f9 02	 cmp	 ecx, 2
  02fa5	75 07		 jne	 SHORT $L72753

; 5484 : 			{
; 5485 : 				range_value->range_set= -1;

  02fa7	c7 43 0c ff ff
	ff ff		 mov	 DWORD PTR [ebx+12], -1
$L72753:

; 5486 : 			}
; 5487 : 			if (range_value->range_set==1)

  02fae	39 53 0c	 cmp	 DWORD PTR [ebx+12], edx
  02fb1	75 0e		 jne	 SHORT $L72754

; 5488 : 			{
; 5489 : 				range_value->start+=((min_range-range_value->end)-1);

  02fb3	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  02fb6	8b d0		 mov	 edx, eax
  02fb8	2b d1		 sub	 edx, ecx
  02fba	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  02fbc	4a		 dec	 edx
  02fbd	03 ca		 add	 ecx, edx
  02fbf	89 0b		 mov	 DWORD PTR [ebx], ecx
$L72754:

; 5493 : 		range_value->end=max_range;
; 5494 : 		min_range=par_get_int_length(min_range);

  02fc1	50		 push	 eax
  02fc2	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  02fc5	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  02fc8	e8 00 00 00 00	 call	 _par_get_int_length

; 5495 : 		max_range=par_get_int_length(max_range);

  02fcd	56		 push	 esi
  02fce	e8 00 00 00 00	 call	 _par_get_int_length

; 5496 : #ifdef DIGIT_DEBUG
; 5497 : 		printf("par_match_digits; before match length=%d match_is_over=%d satisfied_min_cond=%d\n",length,match_is_over,satisfied_min_cond);
; 5498 : 		printf("par_match_digits; before match min_range=%d max_range=%d\n",min_range,max_range);
; 5499 : #endif
; 5500 : 		for (i=0;(((parser_char_types[input_array[ipos+i]] & TYPE_digit)!=0) &&
; 5501 : 			((temp_num=par_convert_number(input_array+ipos,i+1))<=range_value->end) &&
; 5502 : 			(i<max_range))
; 5503 : 			;i++)

  02fd3	8b 4c 24 50	 mov	 ecx, DWORD PTR _input_array$[esp+68]
  02fd7	89 44 24 40	 mov	 DWORD PTR _max_range$[esp+72], eax
  02fdb	8b 44 24 2c	 mov	 eax, DWORD PTR _ipos$[esp+72]
  02fdf	33 d2		 xor	 edx, edx
  02fe1	03 c1		 add	 eax, ecx
  02fe3	83 c4 08	 add	 esp, 8
  02fe6	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _i$[esp+64], 0
  02fee	89 44 24 54	 mov	 DWORD PTR 24+[esp+60], eax
  02ff2	8a 10		 mov	 dl, BYTE PTR [eax]
  02ff4	f6 04 55 00 00
	00 00 01	 test	 BYTE PTR _parser_char_types[edx*2], 1
  02ffc	0f 84 c5 00 00
	00		 je	 $L73311

; 5490 : 			}
; 5491 : 		}
; 5492 : 		range_value->min=min_range;

  03002	be 01 00 00 00	 mov	 esi, 1
  03007	eb 04		 jmp	 SHORT $L72755
$L73310:
  03009	8b 44 24 54	 mov	 eax, DWORD PTR 24+[esp+60]
$L72755:

; 5496 : #ifdef DIGIT_DEBUG
; 5497 : 		printf("par_match_digits; before match length=%d match_is_over=%d satisfied_min_cond=%d\n",length,match_is_over,satisfied_min_cond);
; 5498 : 		printf("par_match_digits; before match min_range=%d max_range=%d\n",min_range,max_range);
; 5499 : #endif
; 5500 : 		for (i=0;(((parser_char_types[input_array[ipos+i]] & TYPE_digit)!=0) &&
; 5501 : 			((temp_num=par_convert_number(input_array+ipos,i+1))<=range_value->end) &&
; 5502 : 			(i<max_range))
; 5503 : 			;i++)

  0300d	56		 push	 esi
  0300e	50		 push	 eax
  0300f	e8 00 00 00 00	 call	 _par_convert_number
  03014	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  03017	83 c4 08	 add	 esp, 8
  0301a	3b c1		 cmp	 eax, ecx
  0301c	89 44 24 18	 mov	 DWORD PTR _temp_num$[esp+64], eax
  03020	0f 8f aa 00 00
	00		 jg	 $L73319
  03026	8b 54 24 38	 mov	 edx, DWORD PTR _max_range$[esp+64]
  0302a	8b 4c 24 14	 mov	 ecx, DWORD PTR _i$[esp+64]
  0302e	3b ca		 cmp	 ecx, edx
  03030	0f 8d 95 00 00
	00		 jge	 $L72757

; 5504 : 		{
; 5505 : #ifdef DIGIT_DEBUG
; 5506 : 			printf("looping in par_match_digits i=%d temp_num=%d\n",i,temp_num);
; 5507 : #endif
; 5508 : 			if (temp_num>=range_value->min)

  03036	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  03039	7c 5b		 jl	 SHORT $L72756

; 5509 : 			{
; 5510 : #ifdef DIGIT_DEBUG
; 5511 : 				printf("matched %d\n",temp_num);
; 5512 : #endif
; 5513 : 				temp=length=i+1;
; 5514 : 				satisfied_min_cond=temp_num;
; 5515 : 				satisfied_start=range_value->start;

  0303b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0303d	89 74 24 28	 mov	 DWORD PTR _length$[esp+64], esi
  03041	89 4c 24 34	 mov	 DWORD PTR _satisfied_start$[esp+64], ecx

; 5516 : 				if (break_on_min_match==1)

  03045	b9 01 00 00 00	 mov	 ecx, 1
  0304a	39 4c 24 5c	 cmp	 DWORD PTR _break_on_min_match$[esp+60], ecx
  0304e	89 44 24 30	 mov	 DWORD PTR _satisfied_min_cond$[esp+64], eax
  03052	74 65		 je	 SHORT $L73302

; 5520 : 				}
; 5521 : 				if ((lookahead) && ((counter<num_desc) || (((temp)<max_range))))

  03054	8b 44 24 58	 mov	 eax, DWORD PTR _lookahead$[esp+60]
  03058	85 c0		 test	 eax, eax
  0305a	74 3a		 je	 SHORT $L72756
  0305c	8b 44 24 10	 mov	 eax, DWORD PTR _num_desc$[esp+64]
  03060	8b 4c 24 44	 mov	 ecx, DWORD PTR _counter$[esp+60]
  03064	3b c8		 cmp	 ecx, eax
  03066	7c 04		 jl	 SHORT $L72761
  03068	3b f2		 cmp	 esi, edx
  0306a	7d 2a		 jge	 SHORT $L72756
$L72761:

; 5522 : 				{
; 5523 : 					if (par_look_ahead(current_rule,input_array,ipos+temp,next_type,match_array,ret_value)==1)

  0306c	8b 4c 24 50	 mov	 ecx, DWORD PTR _ret_value$[esp+60]
  03070	8b 54 24 4c	 mov	 edx, DWORD PTR _match_array$[esp+60]
  03074	8b 44 24 2c	 mov	 eax, DWORD PTR _next_type$[esp+64]
  03078	51		 push	 ecx
  03079	8b 4c 24 28	 mov	 ecx, DWORD PTR _ipos$[esp+68]
  0307d	52		 push	 edx
  0307e	50		 push	 eax
  0307f	8b 44 24 54	 mov	 eax, DWORD PTR _input_array$[esp+72]
  03083	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  03086	52		 push	 edx
  03087	50		 push	 eax
  03088	55		 push	 ebp
  03089	e8 00 00 00 00	 call	 _par_look_ahead
  0308e	83 c4 18	 add	 esp, 24			; 00000018H
  03091	83 f8 01	 cmp	 eax, 1
  03094	74 29		 je	 SHORT $L73303
$L72756:

; 5496 : #ifdef DIGIT_DEBUG
; 5497 : 		printf("par_match_digits; before match length=%d match_is_over=%d satisfied_min_cond=%d\n",length,match_is_over,satisfied_min_cond);
; 5498 : 		printf("par_match_digits; before match min_range=%d max_range=%d\n",min_range,max_range);
; 5499 : #endif
; 5500 : 		for (i=0;(((parser_char_types[input_array[ipos+i]] & TYPE_digit)!=0) &&
; 5501 : 			((temp_num=par_convert_number(input_array+ipos,i+1))<=range_value->end) &&
; 5502 : 			(i<max_range))
; 5503 : 			;i++)

  03096	8b 44 24 14	 mov	 eax, DWORD PTR _i$[esp+64]
  0309a	8b 54 24 54	 mov	 edx, DWORD PTR 24+[esp+60]
  0309e	40		 inc	 eax
  0309f	33 c9		 xor	 ecx, ecx
  030a1	89 44 24 14	 mov	 DWORD PTR _i$[esp+64], eax
  030a5	46		 inc	 esi
  030a6	8a 0c 02	 mov	 cl, BYTE PTR [edx+eax]
  030a9	f6 04 4d 00 00
	00 00 01	 test	 BYTE PTR _parser_char_types[ecx*2], 1
  030b1	0f 85 52 ff ff
	ff		 jne	 $L73310

; 5526 : 						break;
; 5527 : 					}
; 5528 : 				}
; 5529 : 			}
; 5530 : 		}
; 5531 : 		if ((temp_num>range_value->end) && (counter==num_desc))

  030b7	eb 0e		 jmp	 SHORT $L73311
$L73302:

; 5517 : 				{
; 5518 : 					match_is_over=1;

  030b9	89 4c 24 1c	 mov	 DWORD PTR _match_is_over$[esp+64], ecx

; 5519 : 					break;

  030bd	eb 0c		 jmp	 SHORT $L72757
$L73303:

; 5524 : 					{
; 5525 : 						match_is_over=1;

  030bf	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _match_is_over$[esp+64], 1
$L73311:
  030c7	8b 44 24 18	 mov	 eax, DWORD PTR _temp_num$[esp+64]
$L72757:

; 5526 : 						break;
; 5527 : 					}
; 5528 : 				}
; 5529 : 			}
; 5530 : 		}
; 5531 : 		if ((temp_num>range_value->end) && (counter==num_desc))

  030cb	3b 43 04	 cmp	 eax, DWORD PTR [ebx+4]
  030ce	7e 0c		 jle	 SHORT $L72763
$L73319:
  030d0	8b 44 24 44	 mov	 eax, DWORD PTR _counter$[esp+60]
  030d4	8b 4c 24 10	 mov	 ecx, DWORD PTR _num_desc$[esp+64]
  030d8	3b c1		 cmp	 eax, ecx
  030da	74 39		 je	 SHORT $L73315
$L72763:

; 5414 : 	}
; 5415 : 	/* either there is a number or there is a star of a plus */ 
; 5416 : 	
; 5417 : 	while ((counter<num_desc) && (match_is_over==0))

  030dc	8b 4c 24 10	 mov	 ecx, DWORD PTR _num_desc$[esp+64]
  030e0	8b 44 24 44	 mov	 eax, DWORD PTR _counter$[esp+60]
  030e4	3b c1		 cmp	 eax, ecx
  030e6	0f 8c 03 fe ff
	ff		 jl	 $L73308
  030ec	8b c1		 mov	 eax, ecx
  030ee	33 f6		 xor	 esi, esi
$L73304:

; 5532 : 		{
; 5533 : 			break;
; 5534 : 		}
; 5535 : 	}                              
; 5536 : #ifdef DIGIT_DEBUG
; 5537 : 	printf("take 2 length=%d match_is_over=%d satisfied_min_cond=%d\n",length,match_is_over,satisfied_min_cond);
; 5538 : 	printf("take 2 min_range=%d max_range=%d\n",min_range,max_range);
; 5539 : #endif
; 5540 : #ifdef DEBUG
; 5541 : 	printf("par_match_digits;rule_p=%d\n",rule_p);
; 5542 : #endif
; 5543 : 	if (counter!=num_desc)

  030f0	39 44 24 44	 cmp	 DWORD PTR _counter$[esp+60], eax
  030f4	74 21		 je	 SHORT $L72764

; 5544 : 	{
; 5545 : 		temp=in_rule_p;
; 5546 : 		temp+=2;

  030f6	8b 54 24 3c	 mov	 edx, DWORD PTR _in_rule_p$[esp+64]

; 5547 : 		if (lookahead)

  030fa	8b 4c 24 58	 mov	 ecx, DWORD PTR _lookahead$[esp+60]
  030fe	3b ce		 cmp	 ecx, esi
  03100	8d 7a 02	 lea	 edi, DWORD PTR [edx+2]
  03103	74 01		 je	 SHORT $L72765

; 5548 : 			temp++;

  03105	47		 inc	 edi
$L72765:

; 5549 : 		if (large_desc)

  03106	39 74 24 20	 cmp	 DWORD PTR _large_desc$[esp+64], esi
  0310a	74 05		 je	 SHORT $L72766

; 5550 : 		{
; 5551 : 			temp+=num_desc<<1;

  0310c	8d 3c 47	 lea	 edi, DWORD PTR [edi+eax*2]

; 5552 : 		}
; 5553 : 		else

  0310f	eb 06		 jmp	 SHORT $L72764
$L72766:

; 5554 : 		{
; 5555 : 			temp+=num_desc;

  03111	03 f8		 add	 edi, eax

; 5556 : 		}
; 5557 : 		rule_p=temp;

  03113	eb 02		 jmp	 SHORT $L72764
$L73315:
  03115	33 f6		 xor	 esi, esi
$L72764:

; 5558 : 	}
; 5559 : 	
; 5560 : 	/* if satisfied_min_cond was not changed, there was no successful matching */
; 5561 :    	if (satisfied_min_cond== -1)

  03117	83 7c 24 30 ff	 cmp	 DWORD PTR _satisfied_min_cond$[esp+64], -1
  0311c	75 0a		 jne	 SHORT $L72768
  0311e	5f		 pop	 edi
  0311f	5e		 pop	 esi
  03120	5d		 pop	 ebp

; 5562 :    	{
; 5563 : 		return(0);

  03121	33 c0		 xor	 eax, eax
  03123	5b		 pop	 ebx

; 5593 : }

  03124	83 c4 30	 add	 esp, 48			; 00000030H
  03127	c3		 ret	 0
$L72768:

; 5564 : 	}
; 5565 : 	else
; 5566 :    	{   
; 5567 : 	/* if there was a successful match that was not the last one set range_value->start to 
; 5568 :    		   the value of start at the when the match was hit */
; 5569 : 		if (range_value->start!=satisfied_start)

  03128	8b 44 24 34	 mov	 eax, DWORD PTR _satisfied_start$[esp+64]
  0312c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0312e	3b c8		 cmp	 ecx, eax
  03130	74 02		 je	 SHORT $L72770

; 5570 : 		{
; 5571 : 			range_value->start=satisfied_start;

  03132	89 03		 mov	 DWORD PTR [ebx], eax
$L72770:

; 5572 : 		}
; 5573 : 	}
; 5574 : 	if (input_array[ipos+i]=='\0')

  03134	8b 44 24 24	 mov	 eax, DWORD PTR _ipos$[esp+64]
  03138	8b 4c 24 14	 mov	 ecx, DWORD PTR _i$[esp+64]
  0313c	8b 54 24 48	 mov	 edx, DWORD PTR _input_array$[esp+60]
  03140	03 c1		 add	 eax, ecx
  03142	80 3c 10 00	 cmp	 BYTE PTR [eax+edx], 0
  03146	75 11		 jne	 SHORT $L72772

; 5575 : 	{
; 5576 : 		if (length==0)

  03148	39 74 24 28	 cmp	 DWORD PTR _length$[esp+64], esi
  0314c	75 0b		 jne	 SHORT $L72772
  0314e	5f		 pop	 edi
  0314f	5e		 pop	 esi
  03150	5d		 pop	 ebp

; 5577 : 		{	/* changed for speed */
; 5578 : 			return(-1);

  03151	83 c8 ff	 or	 eax, -1
  03154	5b		 pop	 ebx

; 5593 : }

  03155	83 c4 30	 add	 esp, 48			; 00000030H
  03158	c3		 ret	 0
$L72772:

; 5579 : 		}
; 5580 : 	}                                        
; 5581 : 	ret_value->rule=rule_p; 

  03159	8b 44 24 50	 mov	 eax, DWORD PTR _ret_value$[esp+60]
  0315d	89 78 10	 mov	 DWORD PTR [eax+16], edi

; 5582 : #ifdef DIGIT_DEBUG    
; 5583 : 	par_print_rule_error("par_match_digits;testing the rule_p index",current_rule,rule_p);
; 5584 : #endif
; 5585 : #ifdef DEBUG
; 5586 : 	printf("leaving par_match_digits length=%d\n",length);
; 5587 : #else
; 5588 : #ifdef DIGIT_DEBUG
; 5589 : 	printf("leaving par_match_digits length=%d ret_value->value=%d\n",length,ret_value->value);
; 5590 : #endif
; 5591 : #endif
; 5592 :    	return(length);

  03160	8b 44 24 28	 mov	 eax, DWORD PTR _length$[esp+64]
  03164	5f		 pop	 edi
  03165	5e		 pop	 esi
  03166	5d		 pop	 ebp
  03167	5b		 pop	 ebx

; 5593 : }

  03168	83 c4 30	 add	 esp, 48			; 00000030H
  0316b	c3		 ret	 0
_par_match_digits ENDP
_TEXT	ENDS
PUBLIC	_par_match_set
_TEXT	SEGMENT
_current_rule$ = 8
_input_array$ = 12
_match_array$ = 16
_ret_value$ = 20
_range_value$ = 24
_lookahead$ = 28
_break_on_min_match$ = 32
_times$ = -52
_ipos$ = -64
_total_length$ = -76
_match_is_over$ = -72
_satisfied_min_cond$ = -68
_counter$ = 8
_sect_p$ = -56
_section_p$ = -44
_end_of_all_types$ = -36
_num_desc$ = -40
_large_desc$ = -60
_new_ret$ = -32
_par_match_sets_with_ranges PROC NEAR

; 5630 : {

  03170	83 ec 4c	 sub	 esp, 76			; 0000004cH

; 5631 : 	int rule_p;
; 5632 : 	int times=0,length=0,ipos,total_length=0;
; 5633 : 	int min_range= -1,max_range= -1;
; 5634 : 	int match_is_over=0;                              
; 5635 : 	int satisfied_min_cond= -1;
; 5636 : 	//	int par_look_ahead_success=0;
; 5637 : 	int i=0;
; 5638 : 	int temp;
; 5639 : 	int counter;
; 5640 : 	int sect_p,section_p;
; 5641 : 	int end_of_all_types,num_desc;
; 5642 : 	int large_desc;
; 5643 : 	//	int num_sections;
; 5644 : 	/* int find_type= -2; */ /* uncomment when look_ahead is implimented from sets */
; 5645 : #ifndef NEW_PARSER_FILE_LOADING
; 5646 : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0 }; 
; 5647 : #else
; 5648 : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0,NULL }; 
; 5649 : #endif
; 5650 : 	
; 5651 : #ifdef DEBUG
; 5652 : 	printf("entering par_match_sets_and_ranges\n");
; 5653 : #endif
; 5654 : #ifdef SANITY_CHECKING	
; 5655 : 	if (ret_value==NULL)
; 5656 : 	{
; 5657 : #ifdef DEBUG
; 5658 : 		printf("leaving par_match_sets_and_ranges a 0\n");
; 5659 : #endif
; 5660 : 		return(0);
; 5661 : 	}
; 5662 : 	if ((current_rule==NULL) || (input_array==NULL))
; 5663 : 	{
; 5664 : 		ret_value->value=FATAL_FAIL;
; 5665 : #ifdef DEBUG
; 5666 : 		printf("leaving par_match_sets_and_ranges b 0\n");
; 5667 : #endif
; 5668 : 		return(0);
; 5669 : 	}
; 5670 : #endif
; 5671 : 	rule_p=ret_value->rule;
; 5672 : 	ipos=ret_value->input_pos+ret_value->input_offset;

  03173	8b 54 24 5c	 mov	 edx, DWORD PTR _ret_value$[esp+72]
  03177	53		 push	 ebx
  03178	55		 push	 ebp
  03179	56		 push	 esi
  0317a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0317d	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 5673 : 	
; 5674 : 	/* skip past the type delimiter */
; 5675 : 	
; 5676 : 	rule_p++;
; 5677 : 	
; 5678 : 	new_ret.input_pos=ret_value->input_pos+ret_value->input_offset;	
; 5679 : 	new_ret.input_offset=0;
; 5680 : 	new_ret.output_pos=ret_value->output_pos+ret_value->output_offset;

  0317f	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  03182	03 c8		 add	 ecx, eax
  03184	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  03187	89 4c 24 18	 mov	 DWORD PTR _ipos$[esp+88], ecx
  0318b	89 4c 24 38	 mov	 DWORD PTR _new_ret$[esp+88], ecx
  0318f	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  03192	03 ce		 add	 ecx, esi
  03194	57		 push	 edi

; 5681 : 	new_ret.output_offset=0;
; 5682 : 	new_ret.value=SUCCESS;
; 5683 : #ifdef NEW_PARSER_FILE_LOADING
; 5684 : 	new_ret.phTTS=ret_value->phTTS;
; 5685 : #endif
; 5686 : 	
; 5687 : 	section_p=rule_p; /* the location of the number of sections */
; 5688 : 	
; 5689 : 	//	num_sections=current_rule[rule_p];	
; 5690 : 	
; 5691 : 	
; 5692 : 	end_of_all_types=current_rule[section_p+current_rule[rule_p]]+1;

  03195	8b 7c 24 60	 mov	 edi, DWORD PTR _current_rule$[esp+88]
  03199	33 ed		 xor	 ebp, ebp
  0319b	89 4c 24 44	 mov	 DWORD PTR _new_ret$[esp+100], ecx
  0319f	40		 inc	 eax
  031a0	b9 01 00 00 00	 mov	 ecx, 1
  031a5	33 db		 xor	 ebx, ebx
  031a7	89 6c 24 4c	 mov	 DWORD PTR _new_ret$[esp+108], ebp
  031ab	89 6c 24 54	 mov	 DWORD PTR _new_ret$[esp+116], ebp
  031af	89 6c 24 58	 mov	 DWORD PTR _new_ret$[esp+120], ebp
  031b3	89 6c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ebp
  031b7	89 6c 24 48	 mov	 DWORD PTR _new_ret$[esp+104], ebp
  031bb	89 4c 24 50	 mov	 DWORD PTR _new_ret$[esp+112], ecx
  031bf	8a 1c 38	 mov	 bl, BYTE PTR [eax+edi]
  031c2	89 44 24 30	 mov	 DWORD PTR _section_p$[esp+92], eax
  031c6	03 c3		 add	 eax, ebx
  031c8	33 db		 xor	 ebx, ebx
  031ca	89 6c 24 28	 mov	 DWORD PTR _times$[esp+92], ebp
  031ce	89 6c 24 10	 mov	 DWORD PTR _total_length$[esp+92], ebp
  031d2	8a 1c 38	 mov	 bl, BYTE PTR [eax+edi]
  031d5	89 6c 24 14	 mov	 DWORD PTR _match_is_over$[esp+92], ebp
  031d9	8b f3		 mov	 esi, ebx
  031db	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR _satisfied_min_cond$[esp+92], -1
  031e3	46		 inc	 esi
  031e4	89 74 24 38	 mov	 DWORD PTR _end_of_all_types$[esp+92], esi

; 5693 : 	
; 5694 : 	rule_p+=(current_rule[rule_p])+1;	/* the location of the descriptors */

  031e8	8d 70 01	 lea	 esi, DWORD PTR [eax+1]

; 5695 : 	
; 5696 : 	if (current_rule[rule_p] & BIN_LARGE_DESC)

  031eb	8a 44 38 01	 mov	 al, BYTE PTR [eax+edi+1]
  031ef	a8 40		 test	 al, 64			; 00000040H
  031f1	74 0f		 je	 SHORT $L72806

; 5697 : 	{
; 5698 : 		large_desc=1;
; 5699 : 		sect_p=rule_p+(current_rule[rule_p] <<1)+1;

  031f3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  031f8	89 4c 24 20	 mov	 DWORD PTR _large_desc$[esp+92], ecx
  031fc	8d 4c 46 01	 lea	 ecx, DWORD PTR [esi+eax*2+1]

; 5700 : 	}
; 5701 : 	else

  03200	eb 0d		 jmp	 SHORT $L73338
$L72806:

; 5702 : 	{
; 5703 : 		large_desc=0;
; 5704 : 		sect_p=rule_p+(current_rule[rule_p])+1; // the for the start of the sections of the sets 

  03202	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  03207	89 6c 24 20	 mov	 DWORD PTR _large_desc$[esp+92], ebp
  0320b	8d 4c 30 01	 lea	 ecx, DWORD PTR [eax+esi+1]
$L73338:
  0320f	89 4c 24 24	 mov	 DWORD PTR _sect_p$[esp+92], ecx

; 5705 : 	}
; 5706 : 	//	new_ret.rule=section_p;
; 5707 : 	
; 5708 : 	num_desc=(current_rule[rule_p] & BIN_SIZE_DESC_MASK);

  03213	83 e0 3f	 and	 eax, 63			; 0000003fH

; 5709 : 	counter=0;

  03216	33 c9		 xor	 ecx, ecx

; 5710 : 	rule_p++; /* move past number of descrpitors */

  03218	46		 inc	 esi

; 5711 : 	
; 5712 : 	/* either there is a number or there is a star of a plus */
; 5713 : 	while ((counter<num_desc) && (match_is_over==0))

  03219	3b c5		 cmp	 eax, ebp
  0321b	89 44 24 34	 mov	 DWORD PTR _num_desc$[esp+92], eax
  0321f	0f 8e a3 01 00
	00		 jle	 $L73331
  03225	eb 02		 jmp	 SHORT $L72809
$L73336:
  03227	33 ed		 xor	 ebp, ebp
$L72809:
  03229	39 6c 24 14	 cmp	 DWORD PTR _match_is_over$[esp+92], ebp
  0322d	0f 85 8c 01 00
	00		 jne	 $L73328

; 5714 : 	{
; 5715 : 		if (large_desc)

  03233	39 6c 24 20	 cmp	 DWORD PTR _large_desc$[esp+92], ebp
  03237	74 45		 je	 SHORT $L72811

; 5716 : 		{
; 5717 : 			temp=get_short(current_rule+rule_p);

  03239	33 c0		 xor	 eax, eax
  0323b	8a 64 37 01	 mov	 ah, BYTE PTR [edi+esi+1]
  0323f	8a 04 3e	 mov	 al, BYTE PTR [esi+edi]

; 5718 : 			rule_p+=2;

  03242	83 c6 02	 add	 esi, 2

; 5719 : 			counter++;
; 5720 : 			min_range = temp & BIN_MAX_LARGE_DESC;

  03245	8b d8		 mov	 ebx, eax
  03247	41		 inc	 ecx
  03248	81 e3 ff 3f 00
	00		 and	 ebx, 16383		; 00003fffH
  0324e	89 4c 24 60	 mov	 DWORD PTR _counter$[esp+88], ecx

; 5721 : 			max_range=min_range;
; 5722 : 			if (temp & BIN_LARGE_ANY_NUMBER)

  03252	f6 c4 80	 test	 ah, -128		; ffffff80H
  03255	8b eb		 mov	 ebp, ebx

; 5723 : 			{
; 5724 : 				max_range=INT_MAX;
; 5725 : 			}
; 5726 : 			else

  03257	75 53		 jne	 SHORT $L73339

; 5727 : 			{
; 5728 : 				if (temp & BIN_LARGE_CONTINUE)

  03259	f6 c4 40	 test	 ah, 64			; 00000040H
  0325c	74 53		 je	 SHORT $L72826

; 5729 : 				{
; 5730 : 					temp=get_short(current_rule+rule_p);

  0325e	33 c0		 xor	 eax, eax
  03260	8a 64 37 01	 mov	 ah, BYTE PTR [edi+esi+1]
  03264	8a 04 3e	 mov	 al, BYTE PTR [esi+edi]

; 5731 : 					rule_p+=2;

  03267	83 c6 02	 add	 esi, 2

; 5732 : 					counter++;
; 5733 : 					max_range = temp & BIN_MAX_LARGE_DESC;

  0326a	8b e8		 mov	 ebp, eax
  0326c	41		 inc	 ecx
  0326d	81 e5 ff 3f 00
	00		 and	 ebp, 16383		; 00003fffH
  03273	89 4c 24 60	 mov	 DWORD PTR _counter$[esp+88], ecx

; 5734 : 					if (temp & BIN_LARGE_ANY_NUMBER)

  03277	f6 c4 80	 test	 ah, -128		; ffffff80H
  0327a	74 35		 je	 SHORT $L72826

; 5735 : 					{
; 5736 : 						max_range=INT_MAX;
; 5737 : 					}
; 5738 : 				}
; 5739 : 			}
; 5740 : 		}
; 5741 : 		else

  0327c	eb 2e		 jmp	 SHORT $L73339
$L72811:

; 5742 : 		{
; 5743 : 			temp=current_rule[rule_p];

  0327e	33 c0		 xor	 eax, eax
  03280	8a 04 3e	 mov	 al, BYTE PTR [esi+edi]

; 5744 : 			rule_p++;

  03283	46		 inc	 esi

; 5745 : 			counter++;
; 5746 : 			min_range = temp & BIN_MAX_SMALL_DESC;

  03284	8b d8		 mov	 ebx, eax
  03286	41		 inc	 ecx
  03287	83 e3 3f	 and	 ebx, 63			; 0000003fH
  0328a	89 4c 24 60	 mov	 DWORD PTR _counter$[esp+88], ecx

; 5747 : 			max_range=min_range;
; 5748 : 			if (temp & BIN_SMALL_ANY_NUMBER)

  0328e	a8 80		 test	 al, -128		; ffffff80H
  03290	8b eb		 mov	 ebp, ebx

; 5749 : 			{
; 5750 : 				max_range=INT_MAX;
; 5751 : 			}
; 5752 : 			else

  03292	75 18		 jne	 SHORT $L73339

; 5753 : 			{
; 5754 : 				if (temp & BIN_SMALL_CONTINUE)

  03294	a8 40		 test	 al, 64			; 00000040H
  03296	74 19		 je	 SHORT $L72826

; 5755 : 				{
; 5756 : 					temp=current_rule[rule_p];

  03298	33 c0		 xor	 eax, eax
  0329a	8a 04 3e	 mov	 al, BYTE PTR [esi+edi]

; 5757 : 					rule_p++;

  0329d	46		 inc	 esi

; 5758 : 					counter++;
; 5759 : 					max_range = temp & BIN_MAX_SMALL_DESC;

  0329e	8b e8		 mov	 ebp, eax
  032a0	41		 inc	 ecx
  032a1	83 e5 3f	 and	 ebp, 63			; 0000003fH
  032a4	89 4c 24 60	 mov	 DWORD PTR _counter$[esp+88], ecx

; 5760 : 					if (temp & BIN_SMALL_ANY_NUMBER)

  032a8	a8 80		 test	 al, -128		; ffffff80H
  032aa	74 05		 je	 SHORT $L72826
$L73339:

; 5761 : 					{
; 5762 : 						max_range=INT_MAX;

  032ac	bd ff ff ff 7f	 mov	 ebp, 2147483647		; 7fffffffH
$L72826:

; 5763 : 					}
; 5764 : 				}
; 5765 : 			}
; 5766 : 		}
; 5767 : 		
; 5768 : 		
; 5769 : 		/* do the character matching starting at length until min_length */
; 5770 : 		/* then match from min_length to max_length */
; 5771 : 		/* once min_length is reached, do lookahead for the next char type if necessary */
; 5772 : 		if (min_range==0)

  032b1	85 db		 test	 ebx, ebx
  032b3	75 15		 jne	 SHORT $L72828

; 5773 : 		{
; 5774 : 			/* signal that there could be success on a zero length string */
; 5775 : 			/* or the end of string could be successful too */
; 5776 : 			satisfied_min_cond= -2;
; 5777 : 			if (break_on_min_match==1)

  032b5	8b 44 24 78	 mov	 eax, DWORD PTR _break_on_min_match$[esp+88]
  032b9	c7 44 24 18 fe
	ff ff ff	 mov	 DWORD PTR _satisfied_min_cond$[esp+92], -2 ; fffffffeH
  032c1	83 f8 01	 cmp	 eax, 1
  032c4	0f 84 19 01 00
	00		 je	 $L73337
$L72828:

; 5778 : 			{
; 5779 : 				break;
; 5780 : 			}
; 5781 : 		}
; 5782 : 		for (i=times;i<max_range;i++)

  032ca	8b 44 24 28	 mov	 eax, DWORD PTR _times$[esp+92]
  032ce	3b c5		 cmp	 eax, ebp
  032d0	0f 8d d3 00 00
	00		 jge	 $L72831
  032d6	40		 inc	 eax
  032d7	89 44 24 2c	 mov	 DWORD PTR -48+[esp+92], eax
$L72829:

; 5783 : 		{
; 5784 : 			/* place the call to par_match_set here */
; 5785 : 			/* return the length of the thing matched */
; 5786 : 			length=par_match_set(current_rule,input_array,section_p,sect_p,ipos,match_array,range_value,&new_ret,lookahead);

  032db	8b 54 24 74	 mov	 edx, DWORD PTR _lookahead$[esp+88]
  032df	8b 4c 24 70	 mov	 ecx, DWORD PTR _range_value$[esp+88]
  032e3	8d 44 24 3c	 lea	 eax, DWORD PTR _new_ret$[esp+92]
  032e7	52		 push	 edx
  032e8	8b 54 24 6c	 mov	 edx, DWORD PTR _match_array$[esp+92]
  032ec	50		 push	 eax
  032ed	8b 44 24 24	 mov	 eax, DWORD PTR _ipos$[esp+100]
  032f1	51		 push	 ecx
  032f2	8b 4c 24 30	 mov	 ecx, DWORD PTR _sect_p$[esp+104]
  032f6	52		 push	 edx
  032f7	8b 54 24 40	 mov	 edx, DWORD PTR _section_p$[esp+108]
  032fb	50		 push	 eax
  032fc	8b 44 24 78	 mov	 eax, DWORD PTR _input_array$[esp+108]
  03300	51		 push	 ecx
  03301	52		 push	 edx
  03302	50		 push	 eax
  03303	57		 push	 edi
  03304	e8 00 00 00 00	 call	 _par_match_set
  03309	83 c4 24	 add	 esp, 36			; 00000024H

; 5787 : 			if (length== -1)

  0330c	83 f8 ff	 cmp	 eax, -1
  0330f	74 72		 je	 SHORT $L73323

; 5799 : 			}
; 5800 : 			if (length==0 && new_ret.value==SUCCESS)

  03311	8b 4c 24 50	 mov	 ecx, DWORD PTR _new_ret$[esp+112]
  03315	85 c0		 test	 eax, eax
  03317	75 13		 jne	 SHORT $L72836
  03319	ba 01 00 00 00	 mov	 edx, 1
  0331e	3b ca		 cmp	 ecx, edx
  03320	75 22		 jne	 SHORT $L72837

; 5801 : 			{
; 5802 : 				if (total_length==0)

  03322	8b 4c 24 10	 mov	 ecx, DWORD PTR _total_length$[esp+92]
  03326	85 c9		 test	 ecx, ecx
  03328	74 73		 je	 SHORT $L73324

; 5808 : 					match_is_over=1;
; 5809 : 					break;
; 5810 : 				}
; 5811 : 			}
; 5812 : 			if (length>0)

  0332a	eb 25		 jmp	 SHORT $L73330
$L72836:
  0332c	85 c0		 test	 eax, eax
  0332e	7e 14		 jle	 SHORT $L72837

; 5813 : 			{
; 5814 : 				ipos+=length;

  03330	8b 54 24 1c	 mov	 edx, DWORD PTR _ipos$[esp+92]
  03334	03 d0		 add	 edx, eax
  03336	89 54 24 1c	 mov	 DWORD PTR _ipos$[esp+92], edx

; 5815 : 				total_length+=length;

  0333a	8b 54 24 10	 mov	 edx, DWORD PTR _total_length$[esp+92]
  0333e	03 d0		 add	 edx, eax
  03340	89 54 24 10	 mov	 DWORD PTR _total_length$[esp+92], edx
$L72837:

; 5816 : 			}
; 5817 : 			if (new_ret.value==FAIL)

  03344	85 c9		 test	 ecx, ecx
  03346	0f 84 86 00 00
	00		 je	 $L73325
  0334c	ba 01 00 00 00	 mov	 edx, 1
$L73330:

; 5821 : 			}
; 5822 : 			if ((i+1)>=min_range)

  03351	8b 4c 24 2c	 mov	 ecx, DWORD PTR -48+[esp+92]
  03355	3b cb		 cmp	 ecx, ebx
  03357	7c 16		 jl	 SHORT $L72839

; 5823 : 			{
; 5824 : 				satisfied_min_cond=total_length;

  03359	8b 44 24 10	 mov	 eax, DWORD PTR _total_length$[esp+92]

; 5825 : 				times=i+1;

  0335d	89 4c 24 28	 mov	 DWORD PTR _times$[esp+92], ecx
  03361	89 44 24 18	 mov	 DWORD PTR _satisfied_min_cond$[esp+92], eax

; 5826 : 				/* par_look_ahead cannot be done from here */
; 5827 : 				if (break_on_min_match==1)

  03365	8b 44 24 78	 mov	 eax, DWORD PTR _break_on_min_match$[esp+88]
  03369	3b c2		 cmp	 eax, edx
  0336b	74 38		 je	 SHORT $L73326

; 5828 : 				{
; 5829 : 					match_is_over=1;
; 5830 : 					break;
; 5831 : 				}						    
; 5832 : 				
; 5833 : 			}
; 5834 : 			else

  0336d	eb 04		 jmp	 SHORT $L72830
$L72839:

; 5835 : 			{
; 5836 : 				if (length==0)

  0336f	85 c0		 test	 eax, eax
  03371	74 32		 je	 SHORT $L73326
$L72830:

; 5778 : 			{
; 5779 : 				break;
; 5780 : 			}
; 5781 : 		}
; 5782 : 		for (i=times;i<max_range;i++)

  03373	41		 inc	 ecx
  03374	89 4c 24 2c	 mov	 DWORD PTR -48+[esp+92], ecx
  03378	49		 dec	 ecx
  03379	3b cd		 cmp	 ecx, ebp
  0337b	0f 8c 5a ff ff
	ff		 jl	 $L72829

; 5773 : 		{
; 5774 : 			/* signal that there could be success on a zero length string */
; 5775 : 			/* or the end of string could be successful too */
; 5776 : 			satisfied_min_cond= -2;
; 5777 : 			if (break_on_min_match==1)

  03381	eb 26		 jmp	 SHORT $L72831
$L73323:

; 5788 : 			{
; 5789 : 				match_is_over=1;     
; 5790 : 				if (satisfied_min_cond>0)

  03383	8b 44 24 18	 mov	 eax, DWORD PTR _satisfied_min_cond$[esp+92]
  03387	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _match_is_over$[esp+92], 1
  0338f	85 c0		 test	 eax, eax
  03391	7f 16		 jg	 SHORT $L72831

; 5791 : 				{
; 5792 : 					length=total_length;
; 5793 : 				}
; 5794 : 				else
; 5795 : 				{
; 5796 : 					total_length= -1;

  03393	c7 44 24 10 ff
	ff ff ff	 mov	 DWORD PTR _total_length$[esp+92], -1

; 5797 : 				}
; 5798 : 				break;

  0339b	eb 0c		 jmp	 SHORT $L72831
$L73324:

; 5803 : 				{
; 5804 : #ifdef DEBUG
; 5805 : 					printf("set satisfied_min_cond to -2\n");
; 5806 : #endif
; 5807 : 					satisfied_min_cond= -2;

  0339d	c7 44 24 18 fe
	ff ff ff	 mov	 DWORD PTR _satisfied_min_cond$[esp+92], -2 ; fffffffeH
$L73326:

; 5837 : 				{
; 5838 : 					match_is_over=1;

  033a5	89 54 24 14	 mov	 DWORD PTR _match_is_over$[esp+92], edx
$L72831:

; 5711 : 	
; 5712 : 	/* either there is a number or there is a star of a plus */
; 5713 : 	while ((counter<num_desc) && (match_is_over==0))

  033a9	8b 4c 24 60	 mov	 ecx, DWORD PTR _counter$[esp+88]
  033ad	8b 44 24 34	 mov	 eax, DWORD PTR _num_desc$[esp+92]
  033b1	8b 54 24 6c	 mov	 edx, DWORD PTR _ret_value$[esp+88]
  033b5	3b c8		 cmp	 ecx, eax
  033b7	0f 8c 6a fe ff
	ff		 jl	 $L73336
  033bd	33 ed		 xor	 ebp, ebp
$L73328:

; 5839 : 					break;
; 5840 : 				}
; 5841 : 			}
; 5842 : 			
; 5843 : 		}
; 5844 : #ifdef DEBUG
; 5845 : 		printf("par_match_sets_and_ranges;rule_p=%d\n",rule_p);
; 5846 : #endif
; 5847 : 	}	/* while loop inner */
; 5848 :     /* look for the next format type specifier */
; 5849 :     /* look up in the table of ambiguity to know whether or not to do the lookahead parsing */
; 5850 :     /* start mathcing the string */
; 5851 : 	/* once the minimum requirement for the type is met, start checking for the next type if required */
; 5852 :     /* end the matching once the lookahead is successful or the current match hits the maximum 
; 5853 : 	number of characters */                
; 5854 : 	
; 5855 : 	
; 5856 : 	rule_p=end_of_all_types;
; 5857 : 	
; 5858 :    	if (satisfied_min_cond== -1)

  033bf	8b 44 24 18	 mov	 eax, DWORD PTR _satisfied_min_cond$[esp+92]
  033c3	83 f8 ff	 cmp	 eax, -1
  033c6	75 14		 jne	 SHORT $L72843
$L73331:
  033c8	5f		 pop	 edi
  033c9	5e		 pop	 esi
  033ca	5d		 pop	 ebp

; 5859 :    	{                                               
; 5860 : 		return(0);

  033cb	33 c0		 xor	 eax, eax
  033cd	5b		 pop	 ebx

; 5884 : }

  033ce	83 c4 4c	 add	 esp, 76			; 0000004cH
  033d1	c3		 ret	 0
$L73325:

; 5818 : 			{
; 5819 : 				match_is_over=1;

  033d2	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _match_is_over$[esp+92], 1

; 5820 : 				break;

  033da	eb cd		 jmp	 SHORT $L72831
$L72843:

; 5861 :    	}
; 5862 :    	if (satisfied_min_cond== -2)

  033dc	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  033df	75 25		 jne	 SHORT $L72844
  033e1	eb 02		 jmp	 SHORT $L73332
$L73337:
  033e3	33 ed		 xor	 ebp, ebp
$L73332:

; 5863 :    	{
; 5864 : 		if (total_length==0)

  033e5	39 6c 24 10	 cmp	 DWORD PTR _total_length$[esp+92], ebp
  033e9	75 08		 jne	 SHORT $L72848

; 5865 : 		{
; 5866 : 			total_length= -2;

  033eb	c7 44 24 10 fe
	ff ff ff	 mov	 DWORD PTR _total_length$[esp+92], -2 ; fffffffeH
$L72848:

; 5876 : 			}
; 5877 : 		}                                        
; 5878 : 	}
; 5879 : 	ret_value->rule=rule_p;

  033f3	8b 4c 24 38	 mov	 ecx, DWORD PTR _end_of_all_types$[esp+92]

; 5880 : #ifdef DEBUG
; 5881 : 	printf("leaving par_match_sets_and_ranges length=%d total_length=%d ret_value->value=%d\n",length,total_length,ret_value->value);
; 5882 : #endif
; 5883 :    	return(total_length);

  033f7	8b 44 24 10	 mov	 eax, DWORD PTR _total_length$[esp+92]
  033fb	5f		 pop	 edi
  033fc	5e		 pop	 esi
  033fd	5d		 pop	 ebp
  033fe	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  03401	5b		 pop	 ebx

; 5884 : }

  03402	83 c4 4c	 add	 esp, 76			; 0000004cH
  03405	c3		 ret	 0
$L72844:

; 5867 : 		}
; 5868 :    	}
; 5869 :    	else
; 5870 : 	{
; 5871 : 		if (input_array[ipos]=='\0')

  03406	8b 4c 24 64	 mov	 ecx, DWORD PTR _input_array$[esp+88]
  0340a	8b 44 24 1c	 mov	 eax, DWORD PTR _ipos$[esp+92]
  0340e	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  03412	75 df		 jne	 SHORT $L72848

; 5872 : 		{
; 5873 : 			if (total_length==0)

  03414	39 6c 24 10	 cmp	 DWORD PTR _total_length$[esp+92], ebp
  03418	75 d9		 jne	 SHORT $L72848
  0341a	5f		 pop	 edi
  0341b	5e		 pop	 esi
  0341c	5d		 pop	 ebp

; 5874 : 			{	/* changed fo speed */
; 5875 : 				return(-1);

  0341d	83 c8 ff	 or	 eax, -1
  03420	5b		 pop	 ebx

; 5884 : }

  03421	83 c4 4c	 add	 esp, 76			; 0000004cH
  03424	c3		 ret	 0
_par_match_sets_with_ranges ENDP
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+1
$SG72889 DB	'par_match_set; no charcter type found', 00H
_DATA	ENDS
_TEXT	SEGMENT
_current_rule$ = 8
_input_array$ = 12
_rule_p$ = 16
_sect_p$ = 20
_ipos$ = 24
_match_array$ = 28
_range_value$ = 32
_ret_value$ = 36
_lookahead$ = 40
_new_ret$ = -64
_save_ret$ = -32
_length$ = -72
_a_success$ = -68
_num_match$ = -76
_num_sections$ = 24
_end_of_all_sections$ = 8
_par_match_set PROC NEAR

; 5924 : {

  03430	83 ec 4c	 sub	 esp, 76			; 0000004cH

; 5927 : 	return_value_t		save_ret = { 0,0,0,0,0,0,0,0 };	/* a copy to restore new_ret */
; 5928 : #else
; 5929 : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0,NULL }; 	/* for par_match_string to use */
; 5930 : 	return_value_t		save_ret = { 0,0,0,0,0,0,0,0,NULL };	/* a copy to restore new_ret */
; 5931 : #endif
; 5932 : 	int length=0;
; 5933 : 	int a_success=FAIL;
; 5934 : 	int this_success=0;
; 5935 : 	int num_chars_matched=0;
; 5936 : 	int num_match=0;
; 5937 : 	int new_char_type;
; 5938 : 	int num_sections;
; 5939 : 	int end_of_all_sections;
; 5940 : 	
; 5941 : #ifdef DEBUG
; 5942 : 	printf("entering par_match_set\n");
; 5943 : #endif
; 5944 : #ifdef SANITY_CHECKING
; 5945 : 	if (ret_value==NULL)
; 5946 : 	{
; 5947 : #ifdef DEBUG
; 5948 : 		printf("leaving par_match_set ret_value is NULL\n");
; 5949 : #endif
; 5950 : 		return(0);
; 5951 : 	}
; 5952 : 	if ((current_rule==NULL) || (input_array==NULL) || 
; 5953 : 		(match_array==NULL) || (range_value==NULL))
; 5954 : 	{
; 5955 : 		ret_value->value=FATAL_FAIL;
; 5956 : #ifdef DEBUG
; 5957 : 		printf("leaving par_match_set, inputs are bad\n");
; 5958 : #endif
; 5959 : 		return(0);
; 5960 : 	}
; 5961 : #endif
; 5962 : 	new_ret.rule=sect_p;
; 5963 : 	new_ret.input_pos=ipos;

  03433	8b 4c 24 60	 mov	 ecx, DWORD PTR _ipos$[esp+72]

; 5964 : 	new_ret.optional=ret_value->optional;

  03437	8b 54 24 6c	 mov	 edx, DWORD PTR _ret_value$[esp+72]
  0343b	53		 push	 ebx
  0343c	55		 push	 ebp
  0343d	8b 6c 24 64	 mov	 ebp, DWORD PTR _sect_p$[esp+80]
  03441	33 c0		 xor	 eax, eax
  03443	89 4c 24 14	 mov	 DWORD PTR _new_ret$[esp+84], ecx
  03447	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]

; 5965 : 	new_ret.value=SUCCESS;
; 5966 : 	
; 5967 : 	par_copy_return_value(&save_ret,&new_ret);
; 5968 : 	
; 5969 : 	num_sections=current_rule[rule_p];

  0344a	8b 5c 24 58	 mov	 ebx, DWORD PTR _current_rule$[esp+80]
  0344e	56		 push	 esi
  0344f	89 44 24 1c	 mov	 DWORD PTR _new_ret$[esp+92], eax
  03453	89 44 24 20	 mov	 DWORD PTR _new_ret$[esp+96], eax
  03457	89 44 24 24	 mov	 DWORD PTR _new_ret$[esp+100], eax
  0345b	89 44 24 34	 mov	 DWORD PTR _new_ret$[esp+116], eax
  0345f	89 44 24 10	 mov	 DWORD PTR _length$[esp+88], eax
  03463	89 44 24 14	 mov	 DWORD PTR _a_success$[esp+88], eax
  03467	89 44 24 0c	 mov	 DWORD PTR _num_match$[esp+88], eax
  0346b	57		 push	 edi
  0346c	8b c5		 mov	 eax, ebp
  0346e	89 4c 24 34	 mov	 DWORD PTR _new_ret$[esp+116], ecx
  03472	b9 08 00 00 00	 mov	 ecx, 8
  03477	8d 74 24 1c	 lea	 esi, DWORD PTR _new_ret$[esp+92]
  0347b	8d 7c 24 3c	 lea	 edi, DWORD PTR _save_ret$[esp+92]
  0347f	89 44 24 2c	 mov	 DWORD PTR _new_ret$[esp+108], eax
  03483	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR _new_ret$[esp+112], 1

; 5970 : 	end_of_all_sections=current_rule[rule_p+num_sections];

  0348b	33 d2		 xor	 edx, edx
  0348d	f3 a5		 rep movsd
  0348f	8b 7c 24 68	 mov	 edi, DWORD PTR _rule_p$[esp+88]
  03493	33 c9		 xor	 ecx, ecx
  03495	8a 0c 3b	 mov	 cl, BYTE PTR [ebx+edi]
  03498	8d 34 3b	 lea	 esi, DWORD PTR [ebx+edi]
  0349b	89 4c 24 70	 mov	 DWORD PTR _num_sections$[esp+88], ecx
  0349f	03 cb		 add	 ecx, ebx
  034a1	8a 14 39	 mov	 dl, BYTE PTR [ecx+edi]
  034a4	8b ca		 mov	 ecx, edx

; 5971 : 	
; 5972 : 	while ((new_ret.rule<=end_of_all_sections) && (a_success==FAIL))

  034a6	3b e9		 cmp	 ebp, ecx
  034a8	89 4c 24 60	 mov	 DWORD PTR _end_of_all_sections$[esp+88], ecx
  034ac	0f 8f 00 01 00
	00		 jg	 $L73344

; 5925 : #ifndef NEW_PARSER_FILE_LOADING
; 5926 : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0 }; 	/* for par_match_string to use */

  034b2	8b 6c 24 78	 mov	 ebp, DWORD PTR _range_value$[esp+88]
$L72880:

; 5971 : 	
; 5972 : 	while ((new_ret.rule<=end_of_all_sections) && (a_success==FAIL))

  034b6	8b 4c 24 18	 mov	 ecx, DWORD PTR _a_success$[esp+92]
  034ba	85 c9		 test	 ecx, ecx
  034bc	0f 85 fb 00 00
	00		 jne	 $L72899

; 5973 : 	{
; 5974 : 		this_success=SUCCESS;     
; 5975 : 		length=0;
; 5976 : 		rule_p++; /* go to the next section */

  034c2	46		 inc	 esi

; 5977 : 		while ((new_ret.rule<=current_rule[rule_p]) && (a_success==FAIL))

  034c3	33 c9		 xor	 ecx, ecx
  034c5	bf 01 00 00 00	 mov	 edi, 1
  034ca	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _length$[esp+92], 0
  034d2	8a 0e		 mov	 cl, BYTE PTR [esi]
  034d4	89 74 24 6c	 mov	 DWORD PTR 20+[esp+88], esi
  034d8	3b c1		 cmp	 eax, ecx
  034da	7f 6d		 jg	 SHORT $L73345
$L72883:

; 5978 : 		{
; 5979 : 			if ((new_char_type=(current_rule[new_ret.rule] & BIN_OPERATION_MASK)))

  034dc	8a 0c 18	 mov	 cl, BYTE PTR [eax+ebx]
  034df	83 e1 1f	 and	 ecx, 31			; 0000001fH
  034e2	0f 84 ec 00 00
	00		 je	 $L72885

; 5980 : 			{
; 5981 : 				num_chars_matched=par_match_string(current_rule,new_char_type,input_array,match_array,&new_ret,range_value,0,0);

  034e8	8b 44 24 74	 mov	 eax, DWORD PTR _match_array$[esp+88]
  034ec	6a 00		 push	 0
  034ee	6a 00		 push	 0
  034f0	8d 54 24 24	 lea	 edx, DWORD PTR _new_ret$[esp+100]
  034f4	55		 push	 ebp
  034f5	52		 push	 edx
  034f6	8b 54 24 74	 mov	 edx, DWORD PTR _input_array$[esp+104]
  034fa	50		 push	 eax
  034fb	52		 push	 edx
  034fc	51		 push	 ecx
  034fd	53		 push	 ebx
  034fe	e8 00 00 00 00	 call	 _par_match_string

; 5982 : 				length+=num_chars_matched;

  03503	8b 4c 24 34	 mov	 ecx, DWORD PTR _length$[esp+124]

; 5983 : 				new_ret.input_pos+=num_chars_matched;

  03507	8b 54 24 3c	 mov	 edx, DWORD PTR _new_ret$[esp+124]
  0350b	83 c4 20	 add	 esp, 32			; 00000020H
  0350e	03 c8		 add	 ecx, eax
  03510	03 d0		 add	 edx, eax

; 5984 : 				if (num_chars_matched== -1)

  03512	83 f8 ff	 cmp	 eax, -1
  03515	89 4c 24 14	 mov	 DWORD PTR _length$[esp+92], ecx
  03519	89 54 24 1c	 mov	 DWORD PTR _new_ret$[esp+92], edx
  0351d	0f 84 a6 00 00
	00		 je	 $L73343

; 6000 : 			}
; 6001 : 			if (new_ret.value==FAIL)

  03523	8b 44 24 30	 mov	 eax, DWORD PTR _new_ret$[esp+112]
  03527	85 c0		 test	 eax, eax
  03529	75 0d		 jne	 SHORT $L73347

; 6002 : 			{
; 6003 : #ifdef DEBUG
; 6004 : 				printf("par_match_set;this section has failed, look for the next section\n");
; 6005 : #endif
; 6006 : 				this_success=FAIL;
; 6007 : 				new_ret.rule=current_rule[rule_p]+1;

  0352b	33 c0		 xor	 eax, eax
  0352d	33 ff		 xor	 edi, edi
  0352f	8a 06		 mov	 al, BYTE PTR [esi]
  03531	40		 inc	 eax
  03532	89 44 24 2c	 mov	 DWORD PTR _new_ret$[esp+108], eax
  03536	eb 04		 jmp	 SHORT $L72890
$L73347:
  03538	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+108]
$L72890:

; 5977 : 		while ((new_ret.rule<=current_rule[rule_p]) && (a_success==FAIL))

  0353c	33 c9		 xor	 ecx, ecx
  0353e	8a 0e		 mov	 cl, BYTE PTR [esi]
  03540	3b c1		 cmp	 eax, ecx
  03542	7e 98		 jle	 SHORT $L72883

; 6008 : 			} 
; 6009 : 			else
; 6010 : 			{
; 6011 : #ifdef DEBUG
; 6012 : 				printf("this type has succeeded, matching next type\n");
; 6013 : #endif
; 6014 : 			}
; 6015 : 		}    
; 6016 : #ifdef DEBUG
; 6017 : 		par_print_rule_error("par_match_set;after a comma or brace has been found",current_rule,new_ret.rule);
; 6018 : #endif
; 6019 : 		if (this_success==SUCCESS)

  03544	83 ff 01	 cmp	 edi, 1
  03547	75 28		 jne	 SHORT $L72892
$L73345:

; 6020 : 		{
; 6021 : 			a_success=SUCCESS;
; 6022 : #ifdef DEBUG
; 6023 : 			printf("par_match_set;this section has succeeded\n");
; 6024 : #endif
; 6025 : 			if (range_value->range_set==0)

  03549	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  0354c	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _a_success$[esp+92], 1
  03554	85 c9		 test	 ecx, ecx
  03556	75 10		 jne	 SHORT $L72893

; 6026 : 			{
; 6027 : 				range_value->range_set=2;
; 6028 : 				range_value->start=num_match;

  03558	8b 54 24 10	 mov	 edx, DWORD PTR _num_match$[esp+92]
  0355c	c7 45 0c 02 00
	00 00		 mov	 DWORD PTR [ebp+12], 2
  03563	89 55 00	 mov	 DWORD PTR [ebp], edx

; 6029 : 			}
; 6030 : 			else

  03566	eb 38		 jmp	 SHORT $L72897
$L72893:

; 6031 : 			{	
; 6032 : 				range_value->range_set= -1;

  03568	c7 45 0c ff ff
	ff ff		 mov	 DWORD PTR [ebp+12], -1

; 6033 : 			}
; 6034 : 		}            
; 6035 : 		else

  0356f	eb 2f		 jmp	 SHORT $L72897
$L72892:

; 6036 : 		{
; 6037 : 			if (num_match==num_sections)

  03571	8b 4c 24 70	 mov	 ecx, DWORD PTR _num_sections$[esp+88]
  03575	8b 54 24 10	 mov	 edx, DWORD PTR _num_match$[esp+92]
  03579	3b d1		 cmp	 edx, ecx
  0357b	74 23		 je	 SHORT $L72897

; 6038 : 			{
; 6039 : #ifdef DEBUG
; 6040 : 				printf("par_match_set;all sections failed\n");
; 6041 : #endif
; 6042 : 			}
; 6043 : 			else
; 6044 : 			{
; 6045 : #ifdef DEBUG
; 6046 : 				printf("par_match_set;this section has failed, going to next section\n");
; 6047 : #endif
; 6048 : 				par_copy_return_value(&new_ret,&save_ret);
; 6049 : 				num_match++;

  0357d	42		 inc	 edx

; 6050 : 				new_ret.rule=current_rule[rule_p]+1;

  0357e	33 c0		 xor	 eax, eax
  03580	89 54 24 10	 mov	 DWORD PTR _num_match$[esp+92], edx
  03584	8b 54 24 6c	 mov	 edx, DWORD PTR 20+[esp+88]
  03588	b9 08 00 00 00	 mov	 ecx, 8
  0358d	8d 74 24 3c	 lea	 esi, DWORD PTR _save_ret$[esp+92]
  03591	8a 02		 mov	 al, BYTE PTR [edx]
  03593	8d 7c 24 1c	 lea	 edi, DWORD PTR _new_ret$[esp+92]
  03597	f3 a5		 rep movsd
  03599	40		 inc	 eax
  0359a	8b f2		 mov	 esi, edx
  0359c	89 44 24 2c	 mov	 DWORD PTR _new_ret$[esp+108], eax
$L72897:
  035a0	3b 44 24 60	 cmp	 eax, DWORD PTR _end_of_all_sections$[esp+88]
  035a4	0f 8e 0c ff ff
	ff		 jle	 $L72880

; 6051 : 			}
; 6052 : 		}
; 6053 : 	}
; 6054 : 	if (a_success==FAIL)

  035aa	8b 44 24 18	 mov	 eax, DWORD PTR _a_success$[esp+92]
  035ae	85 c0		 test	 eax, eax
  035b0	75 0b		 jne	 SHORT $L72899
$L73344:

; 6055 : 	{
; 6056 : 		ret_value->value=FAIL;

  035b2	8b 4c 24 7c	 mov	 ecx, DWORD PTR _ret_value$[esp+88]
  035b6	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
$L72899:

; 6057 : #ifdef DEBUG
; 6058 : 		printf("par_match_set; it failed\n");
; 6059 : #endif
; 6060 : 	}    
; 6061 : #ifdef DEBUG
; 6062 : 	printf("leaving par_match_set length=%d ret_value->value=%d\n",length,ret_value->value);
; 6063 : #endif
; 6064 : 	return(length);

  035bd	8b 44 24 14	 mov	 eax, DWORD PTR _length$[esp+92]
  035c1	5f		 pop	 edi
  035c2	5e		 pop	 esi
  035c3	5d		 pop	 ebp
  035c4	5b		 pop	 ebx

; 6065 : }	

  035c5	83 c4 4c	 add	 esp, 76			; 0000004cH
  035c8	c3		 ret	 0
$L73343:
  035c9	5f		 pop	 edi
  035ca	5e		 pop	 esi
  035cb	5d		 pop	 ebp

; 5985 : 				{	/* changed for speed */
; 5986 : 					return(-1);

  035cc	83 c8 ff	 or	 eax, -1
  035cf	5b		 pop	 ebx

; 6065 : }	

  035d0	83 c4 4c	 add	 esp, 76			; 0000004cH
  035d3	c3		 ret	 0
$L72885:

; 5987 : 				}
; 5988 : #ifdef DEBUG
; 5989 : 				par_print_rule_error("par_match_set;after par_match_string",current_rule,new_ret.rule);
; 5990 : #endif
; 5991 : 			}
; 5992 : 			else
; 5993 : 			{
; 5994 : 				if (lookahead)

  035d4	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR _lookahead$[esp+88]
  035db	85 c9		 test	 ecx, ecx
  035dd	74 0f		 je	 SHORT $L72888

; 5995 : 				{
; 5996 : 					par_print_rule_error("par_match_set; no charcter type found",current_rule,new_ret.rule);

  035df	50		 push	 eax
  035e0	53		 push	 ebx
  035e1	68 00 00 00 00	 push	 OFFSET FLAT:$SG72889
  035e6	e8 00 00 00 00	 call	 _par_print_rule_error
  035eb	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72888:

; 5997 : 				}
; 5998 : 				ret_value->value=FATAL_FAIL;

  035ee	8b 44 24 7c	 mov	 eax, DWORD PTR _ret_value$[esp+88]
  035f2	5f		 pop	 edi
  035f3	5e		 pop	 esi
  035f4	5d		 pop	 ebp
  035f5	c7 40 14 04 00
	00 00		 mov	 DWORD PTR [eax+20], 4

; 5999 : 				return(0);

  035fc	33 c0		 xor	 eax, eax
  035fe	5b		 pop	 ebx

; 6065 : }	

  035ff	83 c4 4c	 add	 esp, 76			; 0000004cH
  03602	c3		 ret	 0
_par_match_set ENDP
_TEXT	ENDS
END
