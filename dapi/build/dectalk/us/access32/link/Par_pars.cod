	TITLE	D:\work\product\dapi\src\Cmd\Par_pars.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DP@EDMP@par_get_return_level?$DLno?5place?5to@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT _par_get_return_level
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _par_set_return_level
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _par_copy_index_list
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _par_copy_index
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _par_is_index_set
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_char_type_table
PUBLIC	_par_status_string
PUBLIC	_par_check_word_string
PUBLIC	_par_save_string
PUBLIC	_par_insert_string
PUBLIC	_par_compound_break
PUBLIC	_par_replace_string
PUBLIC	_par_delete_string
PUBLIC	_par_dom_dict_search
PUBLIC	_ERROR_func1
PUBLIC	_ERROR_func2
PUBLIC	_perform_action_funcs
_DATA	SEGMENT
_char_type_table DD 00H
	DD	01000H
	DD	08H
	DD	010H
	DD	0800H
	DD	0200H
	DD	04H
	DD	080H
	DD	0400H
	DD	04000H
	DD	040H
	DD	02H
	DD	0100H
	DD	02000H
	DD	020H
	DD	01H
_perform_action_funcs DD FLAT:_ERROR_func2
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func2
	DD	FLAT:_par_delete_string
	DD	FLAT:_ERROR_func2
	DD	FLAT:_par_save_string
	DD	FLAT:_ERROR_func2
	DD	FLAT:_par_replace_string
	DD	FLAT:_par_insert_string
	DD	FLAT:_par_compound_break
	DD	FLAT:_ERROR_func2
	DD	FLAT:_par_dom_dict_search
	DD	FLAT:_par_status_string
	DD	FLAT:_par_check_word_string
$SG71354 DB	'I am a pud-fart. ', 00H
_DATA	ENDS
_TEXT	SEGMENT
_output_array$ = 16
_ret_value$ = 32
_ERROR_func1 PROC NEAR

; 567  : 	strcpy(output_array+ret_value->output_pos,"I am a pud-fart. ");

  00000	8b 44 24 1c	 mov	 eax, DWORD PTR _ret_value$[esp-4]
  00004	8b 54 24 0c	 mov	 edx, DWORD PTR _output_array$[esp-4]
  00008	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000b	03 ca		 add	 ecx, edx
  0000d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR $SG71354
  00013	89 11		 mov	 DWORD PTR [ecx], edx
  00015	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR $SG71354+4
  0001b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0001e	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR $SG71354+8
  00024	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00027	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR $SG71354+12
  0002d	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00030	66 8b 15 10 00
	00 00		 mov	 dx, WORD PTR $SG71354+16
  00037	66 89 51 10	 mov	 WORD PTR [ecx+16], dx

; 568  : 	ret_value->output_offset=strlen("I am a pud-fart. ");

  0003b	c7 40 0c 11 00
	00 00		 mov	 DWORD PTR [eax+12], 17	; 00000011H

; 569  : 	return;
; 570  : }

  00042	c3		 ret	 0
_ERROR_func1 ENDP
_ERROR_func2 PROC NEAR

; 589  : 	return;
; 590  : }

  00050	c3		 ret	 0
_ERROR_func2 ENDP
_TEXT	ENDS
PUBLIC	_par_copy_word_to_output
PUBLIC	_par_skip_white_space
PUBLIC	_par_match_rule
PUBLIC	_par_process_input
PUBLIC	??_C@_0DP@EDMP@par_get_return_level?$DLno?5place?5to@ ; `string'
PUBLIC	??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@ ; `string'
EXTRN	_num_rule_sections:DWORD
EXTRN	_rule_sections:BYTE
EXTRN	_num_rules:DWORD
EXTRN	_rule_index_table:BYTE
EXTRN	_rule_data_table:BYTE
EXTRN	_parser_char_types:BYTE
EXTRN	__imp__printf:NEAR
EXTRN	_cm_util_flush_init:NEAR
_DATA	SEGMENT
	ORG $+2
$SG71503 DB	'par_process_input; no such rule section %d', 0aH, 00H
$SG71504 DB	'Invalid rule section. ', 00H
	ORG $+1
$SG71535 DB	'special rule value is out of range', 0aH, 00H
$SG71570 DB	'rule number is R%d', 0aH, 00H
$SG71588 DB	'Rule hit:R%d', 0aH, 00H
_DATA	ENDS
;	COMDAT ??_C@_0DP@EDMP@par_get_return_level?$DLno?5place?5to@
; File D:\work\product\dapi\src\Cmd\par_pars1.c
_DATA	SEGMENT
??_C@_0DP@EDMP@par_get_return_level?$DLno?5place?5to@ DB 'par_get_return_'
	DB	'level;no place to go to, going to next rule %d', 0aH, 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@
_DATA	SEGMENT
??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@ DB 'par_set_return_'
	DB	'level;too many levels of gorets throwing away %d', 0aH, 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_input_array$ = 12
_new_input$ = 16
_output_array$ = 20
_dict_hit_array$ = 24
_input_indexes$ = 28
_new_input_indexes$ = 32
_output_indexes$ = 36
_in_lang_flag$ = 40
_in_mode_flag$ = 44
_rule$ = 48
_go_until$ = 52
_match_array$ = 56
_ret_value$ = 60
_new_ret$ = -180
_hit_ret$ = -72
_save_ret$ = -112
_current_rule_R_value$ = -116
_cur_rule_next_hit$ = -144
_cur_rule_next_miss$ = -188
_cur_rule_next_go_hit$ = -136
_cur_rule_next_go_miss$ = -196
_cur_rule_copy_hit$ = -192
_done$ = -184
_j$ = -188
_current_rule_number$ = -200
_return_rule$ = -40
_return_level$ = -204
_input_length$ = -80
_new_input_diff$ = -124
_do_not_copy_next_word$ = -120
_pCmd_t$ = -140
_pKsd_t$ = -148
_par_process_input PROC NEAR

; 952  : {

  00060	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH

; 953  : /* 
; 954  :  *	this structure holds the information about where the
; 955  :  *	current search left off in the search of the array
; 956  : 	*/
; 957  : 	/* GL 02/08/1997  add one more item for parser_flag */
; 958  : #ifndef NEW_PARSER_FILE_LOADING
; 959  : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0 }; 
; 960  : 	return_value_t		hit_ret = { 0,0,0,0,0,0,0,0 }; 
; 961  : 	return_value_t		save_ret = { 0,0,0,0,0,0,0,0 };
; 962  : #else
; 963  : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0,NULL }; 
; 964  : 	return_value_t		hit_ret = { 0,0,0,0,0,0,0,0,NULL }; 
; 965  : 	return_value_t		save_ret = { 0,0,0,0,0,0,0,0,NULL };
; 966  : #endif
; 967  : 	U8 *		 		current_rule;	/* a pointer to the current rule */
; 968  : #if (defined DISPLAY_RULES_HIT) || !(defined PARSER_STANDALONE_DEBUG)
; 969  : 	unsigned int		current_rule_R_value;
; 970  : #endif
; 971  : 	int 				cur_rule_next_hit;
; 972  : 	int					cur_rule_next_miss;
; 973  : 	int					cur_rule_next_go_hit;
; 974  : 	int					cur_rule_next_go_miss;
; 975  : 	int					cur_rule_copy_hit;
; 976  : 	unsigned int		current_value;
; 977  : 	int  				done=0;
; 978  : 	int 				i;
; 979  : 	int					j;
; 980  : 	int					k;
; 981  : 	int					last_rule_was_hit=0;
; 982  : 	int 				current_rule_number=0;
; 983  : 	int					return_rule[PAR_MAX_RETURN_LEVEL];
; 984  : 	int					return_level=0;
; 985  : 	int					input_length=0;
; 986  : 	int					new_input_diff=0;
; 987  : 	int					input_size,output_size,size_diff;
; 988  : 	int					rule_p;
; 989  : 	int					temp,do_not_copy_next_word=0;
; 990  : 	U32 *				rule_modes;
; 991  : 	U16	*				rule_flags;
; 992  : 	
; 993  : #ifndef PARSER_STANDALONE_DEBUG
; 994  : 	PCMD_T pCmd_t;
; 995  : 	PKSD_T  pKsd_t;
; 996  : 	pCmd_t=phTTS->pCMDThreadData;

  00066	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR _phTTS$[esp+200]
  0006d	53		 push	 ebx

; 997  : 	pKsd_t=phTTS->pKernelShareData;
; 998  : #endif
; 999  : 	
; 1000 : #ifdef DEBUG
; 1001 : 	printf("entering par_process_input\n");
; 1002 : #endif
; 1003 : 	new_ret.input_pos=ret_value->input_pos+ret_value->input_offset;	

  0006e	8b 9c 24 08 01
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+204]
  00075	55		 push	 ebp
  00076	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00079	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0007c	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0007f	56		 push	 esi
  00080	8b 33		 mov	 esi, DWORD PTR [ebx]
  00082	89 54 24 44	 mov	 DWORD PTR _pKsd_t$[esp+216], edx

; 1004 : 	new_ret.input_offset=0;
; 1005 : 	new_ret.output_pos=ret_value->output_pos+ret_value->output_offset;

  00086	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  00089	03 c6		 add	 eax, esi
  0008b	89 44 24 24	 mov	 DWORD PTR _new_ret$[esp+216], eax
  0008f	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00092	03 c2		 add	 eax, edx
  00094	89 4c 24 4c	 mov	 DWORD PTR _pCmd_t$[esp+216], ecx

; 1006 : 	new_ret.output_offset=0;                 
; 1007 : 	/* GL 02/08/1997 set the initial parser_flag value */
; 1008 : 	new_ret.parser_flag = ret_value->parser_flag;
; 1009 : #ifdef NEW_PARSER_FILE_LOADING
; 1010 : #ifdef PARSER_STANDALONE_DEBUG
; 1011 : 	new_ret.phTTS=NULL;
; 1012 : #else
; 1013 : 	new_ret.phTTS=phTTS;
; 1014 : #endif
; 1015 : #endif
; 1016 : 	
; 1017 : 	if (rule>num_rule_sections)

  00098	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _num_rule_sections
  0009e	89 44 24 2c	 mov	 DWORD PTR _new_ret$[esp+224], eax
  000a2	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  000a5	33 ed		 xor	 ebp, ebp
  000a7	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+244], eax
  000ab	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR _rule$[esp+212]
  000b2	3b c1		 cmp	 eax, ecx
  000b4	57		 push	 edi
  000b5	89 6c 24 38	 mov	 DWORD PTR _new_ret$[esp+236], ebp
  000b9	89 6c 24 3c	 mov	 DWORD PTR _new_ret$[esp+240], ebp
  000bd	89 6c 24 40	 mov	 DWORD PTR _new_ret$[esp+244], ebp
  000c1	89 ac 24 94 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+220], ebp
  000c8	89 ac 24 98 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+224], ebp
  000cf	89 ac 24 9c 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+228], ebp
  000d6	89 ac 24 a0 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+232], ebp
  000dd	89 ac 24 a4 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+236], ebp
  000e4	89 ac 24 a8 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+240], ebp
  000eb	89 ac 24 ac 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+244], ebp
  000f2	89 ac 24 b0 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+248], ebp
  000f9	89 6c 24 24	 mov	 DWORD PTR _done$[esp+220], ebp
  000fd	89 6c 24 10	 mov	 DWORD PTR _return_level$[esp+220], ebp
  00101	89 6c 24 60	 mov	 DWORD PTR _new_input_diff$[esp+220], ebp
  00105	89 6c 24 64	 mov	 DWORD PTR _do_not_copy_next_word$[esp+220], ebp
  00109	89 6c 24 2c	 mov	 DWORD PTR _new_ret$[esp+224], ebp
  0010d	89 6c 24 34	 mov	 DWORD PTR _new_ret$[esp+232], ebp
  00111	7e 32		 jle	 SHORT $L71502

; 1018 : 	{
; 1019 : 		printf("par_process_input; no such rule section %d\n",rule);

  00113	50		 push	 eax
  00114	68 00 00 00 00	 push	 OFFSET FLAT:$SG71503
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf

; 1020 : 		strcpy(output_array,"Invalid rule section. ");

  0011f	8b bc 24 f4 00
	00 00		 mov	 edi, DWORD PTR _output_array$[esp+224]
  00126	b9 05 00 00 00	 mov	 ecx, 5
  0012b	be 00 00 00 00	 mov	 esi, OFFSET FLAT:$SG71504
  00130	83 c4 08	 add	 esp, 8
  00133	f3 a5		 rep movsd
  00135	66 a5		 movsw
  00137	a4		 movsb
  00138	5f		 pop	 edi
  00139	5e		 pop	 esi

; 1633 : #ifdef DEBUG
; 1634 : 	printf("leaving par_process_input\n");
; 1635 : #endif
; 1636 : 	return(ret_value);

  0013a	8b c3		 mov	 eax, ebx
  0013c	5d		 pop	 ebp
  0013d	5b		 pop	 ebx

; 1637 : }                       

  0013e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00144	c3		 ret	 0
$L71502:

; 1021 : 		return(ret_value);
; 1022 : 	}
; 1023 : 	memset(return_rule,-1,sizeof(return_rule));
; 1024 : 
; 1025 : 	input_length=strlen(input_array);

  00145	8b b4 24 e4 00
	00 00		 mov	 esi, DWORD PTR _input_array$[esp+216]
  0014c	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00151	83 c8 ff	 or	 eax, -1
  00154	8d bc 24 b4 00
	00 00		 lea	 edi, DWORD PTR _return_rule$[esp+220]
  0015b	f3 ab		 rep stosd
  0015d	8b fe		 mov	 edi, esi
  0015f	83 c9 ff	 or	 ecx, -1
  00162	33 c0		 xor	 eax, eax
  00164	f2 ae		 repne scasb
  00166	f7 d1		 not	 ecx
  00168	49		 dec	 ecx

; 1026 : 	
; 1027 : 	strcpy(new_input,input_array);

  00169	8b fe		 mov	 edi, esi
  0016b	8b d1		 mov	 edx, ecx
  0016d	83 c9 ff	 or	 ecx, -1
  00170	f2 ae		 repne scasb
  00172	f7 d1		 not	 ecx
  00174	2b f9		 sub	 edi, ecx
  00176	8b c1		 mov	 eax, ecx
  00178	8b f7		 mov	 esi, edi
  0017a	8b bc 24 e8 00
	00 00		 mov	 edi, DWORD PTR _new_input$[esp+216]
  00181	c1 e9 02	 shr	 ecx, 2
  00184	f3 a5		 rep movsd
  00186	8b c8		 mov	 ecx, eax
  00188	83 e1 03	 and	 ecx, 3
  0018b	f3 a4		 rep movsb

; 1028 : 	memcpy(new_input_indexes,input_indexes,input_length*sizeof(index_data_t));

  0018d	8b b4 24 f4 00
	00 00		 mov	 esi, DWORD PTR _input_indexes$[esp+216]
  00194	8b bc 24 f8 00
	00 00		 mov	 edi, DWORD PTR _new_input_indexes$[esp+216]
  0019b	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]

; 1029 : 	
; 1030 : 	input_length=(input_length*2)/3; /* input_length * 2/3 */

  0019e	03 d2		 add	 edx, edx
  001a0	d1 e1		 shl	 ecx, 1
  001a2	8b c1		 mov	 eax, ecx
  001a4	c1 e9 02	 shr	 ecx, 2
  001a7	f3 a5		 rep movsd
  001a9	8b c8		 mov	 ecx, eax
  001ab	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  001b0	f7 ea		 imul	 edx
  001b2	83 e1 03	 and	 ecx, 3
  001b5	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+224]
  001b9	f3 a4		 rep movsb
  001bb	8b b4 24 e8 00
	00 00		 mov	 esi, DWORD PTR _new_input$[esp+216]
  001c2	8b ca		 mov	 ecx, edx
  001c4	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  001c7	03 d1		 add	 edx, ecx
  001c9	bf 01 00 00 00	 mov	 edi, 1
  001ce	89 94 24 8c 00
	00 00		 mov	 DWORD PTR _input_length$[esp+220], edx
$L71507:

; 1031 : 	/* copy the input array to a temporary location for hit next rules */
; 1032 :     
; 1033 :     while (((new_input[new_ret.input_pos+new_ret.input_offset]!='\0') && (go_until==0)) ||    	   
; 1034 :     	   (((new_ret.input_pos+new_ret.input_offset-new_input_diff)<input_length) && (go_until==1) ) )

  001d5	8b 4c 24 28	 mov	 ecx, DWORD PTR _new_ret$[esp+220]
  001d9	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]
  001dc	80 3c 32 00	 cmp	 BYTE PTR [edx+esi], 0
  001e0	74 09		 je	 SHORT $L71510
  001e2	39 ac 24 0c 01
	00 00		 cmp	 DWORD PTR _go_until$[esp+216], ebp
  001e9	74 24		 je	 SHORT $L71509
$L71510:
  001eb	8b 54 24 60	 mov	 edx, DWORD PTR _new_input_diff$[esp+220]
  001ef	2b c2		 sub	 eax, edx
  001f1	03 c1		 add	 eax, ecx
  001f3	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR _input_length$[esp+220]
  001fa	3b c1		 cmp	 eax, ecx
  001fc	0f 8d 10 0a 00
	00		 jge	 $L71508
  00202	39 bc 24 0c 01
	00 00		 cmp	 DWORD PTR _go_until$[esp+216], edi
  00209	0f 85 03 0a 00
	00		 jne	 $L71508
$L71509:

; 1035 : 	{
; 1036 : #ifndef PARSER_STANDALONE_DEBUG
; 1037 : 		/* checking cmd_flushing */
; 1038 : 		if (pKsd_t->text_flush || (pKsd_t->cmd_flush == CMD_flush_toss))

  0020f	8b 44 24 48	 mov	 eax, DWORD PTR _pKsd_t$[esp+220]
  00213	39 a8 70 01 00
	00		 cmp	 DWORD PTR [eax+368], ebp
  00219	0f 85 85 09 00
	00		 jne	 $L71512
  0021f	39 b8 6c 01 00
	00		 cmp	 DWORD PTR [eax+364], edi
  00225	0f 84 79 09 00
	00		 je	 $L71512

; 1039 : 		{
; 1040 : 			cm_util_flush_init(phTTS);
; 1041 : 			return(&pCmd_t->ret_value);
; 1042 : 		}              
; 1043 : #endif
; 1044 : 		if (par_skip_white_space(new_input,new_input_indexes,output_array,output_indexes,&new_ret)== -1)

  0022b	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR _output_indexes$[esp+216]
  00232	8b 94 24 ec 00
	00 00		 mov	 edx, DWORD PTR _output_array$[esp+216]
  00239	8d 44 24 28	 lea	 eax, DWORD PTR _new_ret$[esp+220]
  0023d	50		 push	 eax
  0023e	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR _new_input_indexes$[esp+220]
  00245	51		 push	 ecx
  00246	52		 push	 edx
  00247	50		 push	 eax
  00248	56		 push	 esi
  00249	e8 00 00 00 00	 call	 _par_skip_white_space
  0024e	83 c4 14	 add	 esp, 20			; 00000014H
  00251	83 f8 ff	 cmp	 eax, -1
  00254	75 04		 jne	 SHORT $L71514

; 1045 : 			/* skip whitespace between words */		
; 1046 : 			/* copies one whitespace to the output array */
; 1047 : 			/* if there is an index, an extra space may end up in the output */
; 1048 : 		{
; 1049 : 			done=1;

  00256	89 7c 24 24	 mov	 DWORD PTR _done$[esp+220], edi
$L71514:

; 1050 : 		}  	               
; 1051 : 		par_copy_return_value(&save_ret,&new_ret);	/* save the values if the matching ends on a non white */
; 1052 : 		current_rule=NULL;                     
; 1053 : 		current_rule_number=rule_sections[rule];
; 1054 : 		last_rule_was_hit=0;
; 1055 : #ifdef DEBUG
; 1056 : 		par_print_rule_error("par_process_input;1 the input is",new_input,new_ret.input_pos+new_ret.input_offset);
; 1057 : 		par_print_rule_error("par_process_input;1 the output is",output_array,new_ret.output_pos+new_ret.output_offset);
; 1058 : #endif
; 1059 : 		while (!done)

  0025a	8b 44 24 24	 mov	 eax, DWORD PTR _done$[esp+220]
  0025e	b9 08 00 00 00	 mov	 ecx, 8
  00263	8d 74 24 28	 lea	 esi, DWORD PTR _new_ret$[esp+220]
  00267	8d 7c 24 6c	 lea	 edi, DWORD PTR _save_ret$[esp+220]
  0026b	f3 a5		 rep movsd
  0026d	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR _rule$[esp+216]
  00274	33 ed		 xor	 ebp, ebp
  00276	85 c0		 test	 eax, eax
  00278	8b 1c 8d 00 00
	00 00		 mov	 ebx, DWORD PTR _rule_sections[ecx*4]
  0027f	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00283	0f 85 9c 08 00
	00		 jne	 $L71525
$L71518:

; 1060 : 		{  	
; 1061 : #ifndef PARSER_STANDALONE_DEBUG
; 1062 : 			/* checking cmd_flushing */
; 1063 : 			if (pKsd_t->text_flush || (pKsd_t->cmd_flush == CMD_flush_toss))

  00289	8b 54 24 48	 mov	 edx, DWORD PTR _pKsd_t$[esp+220]
  0028d	8b 82 70 01 00
	00		 mov	 eax, DWORD PTR [edx+368]
  00293	85 c0		 test	 eax, eax
  00295	0f 85 52 09 00
	00		 jne	 $L71521
  0029b	83 ba 6c 01 00
	00 01		 cmp	 DWORD PTR [edx+364], 1
  002a2	0f 84 45 09 00
	00		 je	 $L71521

; 1067 : 			}              
; 1068 : #endif
; 1069 : 			/* MGS commented out for speed */
; 1070 : 			//			par_initialize_arrays(match_array);
; 1071 : //			memset(match_array->array_lengths,0,sizeof(match_array->array_lengths));
; 1072 : 			current_rule=&(rule_data_table[rule_index_table[current_rule_number]]); /* this line will change for the new rule tables */

  002a8	8b 3c 9d 00 00
	00 00		 mov	 edi, DWORD PTR _rule_index_table[ebx*4]

; 1073 : 			rule_p=0;
; 1074 : #ifdef DEBUG
; 1075 : 			par_print_rule_error("par_process_input;2 the input is",new_input,new_ret.input_pos+new_ret.input_offset);
; 1076 : 			par_print_rule_error("par_process_input;2 the output is",output_array,new_ret.input_pos+new_ret.output_offset);
; 1077 : #endif
; 1078 : 			/* 
; 1079 : 			* check for stop. if the last rule was a hit rule, 
; 1080 : 			* put the old values for the input and output back
; 1081 : 			*/
; 1082 : 			rule_flags=(U16 *)current_rule;
; 1083 : 			current_value=*rule_flags;

  002af	33 c9		 xor	 ecx, ecx
  002b1	81 c7 00 00 00
	00		 add	 edi, OFFSET FLAT:_rule_data_table
  002b7	66 8b 0f	 mov	 cx, WORD PTR [edi]

; 1084 : //			current_value=(*((U16 *)(current_rule)));
; 1085 : 			if (current_value & BIN_SPECIAL_RULE_MASK)

  002ba	8b c1		 mov	 eax, ecx
  002bc	25 00 e0 00 00	 and	 eax, 57344		; 0000e000H
  002c1	0f 84 a4 00 00
	00		 je	 $L71523

; 1086 : 			{
; 1087 : 				switch (current_value & BIN_SPECIAL_RULE_MASK)
; 1088 : 				{

  002c7	3d 00 a0 00 00	 cmp	 eax, 40960		; 0000a000H
  002cc	77 4f		 ja	 SHORT $L72826
  002ce	0f 84 88 00 00
	00		 je	 $L71532
  002d4	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  002d9	0f 84 18 08 00
	00		 je	 $L71528
  002df	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  002e4	0f 85 2d 08 00
	00		 jne	 $L72890

; 1103 : 				case BIN_RETURN:
; 1104 : 					current_rule_number=par_get_return_level(return_rule,&return_level,current_rule_number);

  002ea	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  002ee	85 c0		 test	 eax, eax
  002f0	7e 12		 jle	 SHORT $L72830
  002f2	8b 9c 84 b0 00
	00 00		 mov	 ebx, DWORD PTR _return_rule$[esp+eax*4+216]
  002f9	48		 dec	 eax
  002fa	89 44 24 10	 mov	 DWORD PTR _return_level$[esp+220], eax
  002fe	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00302	eb 85		 jmp	 SHORT $L71518
$L72830:
  00304	53		 push	 ebx
  00305	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@EDMP@par_get_return_level?$DLno?5place?5to@ ; `string'
  0030a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00310	83 c4 08	 add	 esp, 8
  00313	43		 inc	 ebx
  00314	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx

; 1105 : 					continue;

  00318	e9 6c ff ff ff	 jmp	 $L71518
$L72826:

; 1086 : 			{
; 1087 : 				switch (current_value & BIN_SPECIAL_RULE_MASK)
; 1088 : 				{

  0031d	3d 00 c0 00 00	 cmp	 eax, 49152		; 0000c000H
  00322	0f 85 ef 07 00
	00		 jne	 $L72890

; 1106 : 				case BIN_GOTO:
; 1107 : //					current_rule_number=(*((U16 *)(current_rule+2)));
; 1108 : 					current_rule_number=*(rule_flags+1);
; 1109 : 					continue;
; 1110 : 					/* put in goret and return here */
; 1111 : 				case BIN_GORET:
; 1112 : 					par_set_return_level(return_rule,&return_level,current_rule_number+1);

  00328	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  0032c	43		 inc	 ebx
  0032d	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00330	7d 1b		 jge	 SHORT $L72835
  00332	89 9c 84 b4 00
	00 00		 mov	 DWORD PTR _return_rule$[esp+eax*4+220], ebx
  00339	40		 inc	 eax

; 1113 : 					current_rule_number=*(rule_flags+1);

  0033a	33 db		 xor	 ebx, ebx
  0033c	89 44 24 10	 mov	 DWORD PTR _return_level$[esp+220], eax
  00340	66 8b 5f 02	 mov	 bx, WORD PTR [edi+2]
  00344	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx

; 1114 : // 					current_rule_number=(*((U16 *)(current_rule+2)));
; 1115 : 					continue;

  00348	e9 3c ff ff ff	 jmp	 $L71518

; 1106 : 				case BIN_GOTO:
; 1107 : //					current_rule_number=(*((U16 *)(current_rule+2)));
; 1108 : 					current_rule_number=*(rule_flags+1);
; 1109 : 					continue;
; 1110 : 					/* put in goret and return here */
; 1111 : 				case BIN_GORET:
; 1112 : 					par_set_return_level(return_rule,&return_level,current_rule_number+1);

$L72835:
  0034d	53		 push	 ebx
  0034e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@ ; `string'
  00353	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00359	83 c4 08	 add	 esp, 8
$L71532:

; 1113 : 					current_rule_number=*(rule_flags+1);

  0035c	33 db		 xor	 ebx, ebx
  0035e	66 8b 5f 02	 mov	 bx, WORD PTR [edi+2]
  00362	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx

; 1114 : // 					current_rule_number=(*((U16 *)(current_rule+2)));
; 1115 : 					continue;

  00366	e9 1e ff ff ff	 jmp	 $L71518
$L71523:

; 1118 : 					break;
; 1119 : 				}
; 1120 : 				break;
; 1121 : 			}
; 1122 : /* GL 04/16/98  add this for rule number caculation under debug mode */
; 1123 : /*              keep the debug setting for DISPLAY_RULES_HIT         */
; 1124 : #ifndef PARSER_STANDALONE_DEBUG
; 1125 : 			if (DT_DBG(CMD_DBG,0x0010))

  0036b	66 8b 82 78 04
	00 00		 mov	 ax, WORD PTR [edx+1144]
  00372	f6 c4 80	 test	 ah, -128		; ffffff80H
  00375	74 0e		 je	 SHORT $L71536
  00377	a8 10		 test	 al, 16			; 00000010H
  00379	74 0a		 je	 SHORT $L71536

; 1126 : 			{
; 1127 : 				rule_p+=2; /* advance past the special rule value flags */
; 1128 : 				current_rule_R_value=(*((U16 *)(current_rule+rule_p)));

  0037b	33 c0		 xor	 eax, eax
  0037d	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  00381	89 44 24 68	 mov	 DWORD PTR _current_rule_R_value$[esp+220], eax
$L71536:

; 1129 : 				rule_p+=2;;
; 1130 : 			}
; 1131 : 			else
; 1132 : 			{
; 1133 : 				rule_p+=4;
; 1134 : 			}
; 1135 : #endif
; 1136 : #ifdef DISPLAY_RULES_HIT
; 1137 : 			rule_p+=2; /* advance past the special rule value flags */
; 1138 : 			current_rule_R_value=(*((U16 *)(current_rule+rule_p)));
; 1139 : 			rule_p+=2;;
; 1140 : //#else
; 1141 : //			rule_p+=4;
; 1142 : #endif
; 1143 : 
; 1144 : //			new_ret.rule=0;
; 1145 : 			new_ret.value=FAIL;
; 1146 : //			i=0;
; 1147 : 			/* check the language tag */
; 1148 : 			/* get the language flag */
; 1149 : 			rule_modes=(U32 *)(current_rule+rule_p);
; 1150 : #ifdef DEBUG
; 1151 : 			printf("the language flag is 0x%08X\n",*rule_modes);
; 1152 : #endif
; 1153 : 			/* check the language flag against the kernel langauge flag for the correct langauage */
; 1154 : 			
; 1155 : 			if ((last_rule_was_hit==0) && (((*rule_modes) & in_lang_flag)==0))

  00385	85 ed		 test	 ebp, ebp
  00387	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR _new_ret$[esp+240], 0
  0038f	75 36		 jne	 SHORT $L71543
  00391	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR _in_lang_flag$[esp+216]
  00398	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0039b	85 c2		 test	 eax, edx
  0039d	75 17		 jne	 SHORT $L72897
$L72911:

; 1156 : 			{
; 1157 : 				current_rule_number++;	/* go to the next rule */
; 1158 : 				if (current_rule_number>=num_rules)		

  0039f	a1 00 00 00 00	 mov	 eax, DWORD PTR _num_rules
  003a4	43		 inc	 ebx
  003a5	3b d8		 cmp	 ebx, eax
  003a7	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  003ab	0f 8d 74 07 00
	00		 jge	 $L71525

; 1159 : 					done=1;
; 1160 : 				continue;

  003b1	e9 d3 fe ff ff	 jmp	 $L71518
$L72897:

; 1161 : 			}                                          
; 1162 : 			/* check the rule mode here */
; 1163 : #ifdef DEBUG
; 1164 : 			printf("the mode flag is 0x%08X\n",rule_modes[1]);
; 1165 : #endif
; 1166 : 			/*	044	MGS		09/24/1997	BATS#469 Fix for NWS parser problem */
; 1167 : 			if (last_rule_was_hit==0)
; 1168 : 			{
; 1169 : 				if ((rule_modes[1] != 0xFFFFFFFF) &&
; 1170 : 					((rule_modes[1] & in_mode_flag)==0))	

  003b6	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  003b9	83 f8 ff	 cmp	 eax, -1
  003bc	74 09		 je	 SHORT $L71543
  003be	85 84 24 04 01
	00 00		 test	 DWORD PTR _in_mode_flag$[esp+216], eax

; 1171 : 				{
; 1172 : 					current_rule_number++;	/* go to the next rule */
; 1173 : 					if (current_rule_number>=num_rules)		
; 1174 : 						done=1;
; 1175 : 					continue;

  003c5	74 d8		 je	 SHORT $L72911
$L71543:

; 1176 : 				}
; 1177 : 			}
; 1178 : 			rule_p+=8;
; 1179 : 			if ((current_value & (BIN_DICT_HIT | BIN_DICT_MISS)))

  003c7	f6 c1 c0	 test	 cl, 192			; 000000c0H
  003ca	be 0c 00 00 00	 mov	 esi, 12			; 0000000cH
  003cf	74 57		 je	 SHORT $L71552

; 1180 : 			{
; 1181 : 				if ((current_value & BIN_DICT_HIT) && 
; 1182 : 					(dict_hit_array[new_ret.input_pos+new_ret.input_offset]!=DICT_MISS_VALUE))

  003d1	f6 c1 80	 test	 cl, 128			; 00000080H
  003d4	74 17		 je	 SHORT $L71546
  003d6	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+224]
  003da	8b 54 24 28	 mov	 edx, DWORD PTR _new_ret$[esp+220]
  003de	03 c2		 add	 eax, edx
  003e0	8b 94 24 f0 00
	00 00		 mov	 edx, DWORD PTR _dict_hit_array$[esp+216]
  003e7	80 3c 10 00	 cmp	 BYTE PTR [eax+edx], 0
  003eb	75 3b		 jne	 SHORT $L71552
$L71546:

; 1183 : 				{
; 1184 : #ifdef DEBUG
; 1185 : 					printf("processing rule because of dictionary HIT on the word\n");
; 1186 : #endif				
; 1187 : 				}
; 1188 : 				else
; 1189 : 				{
; 1190 : 					if ((current_value & BIN_DICT_MISS) && 
; 1191 : 						(dict_hit_array[new_ret.input_pos+new_ret.input_offset]==DICT_MISS_VALUE))

  003ed	f6 c1 40	 test	 cl, 64			; 00000040H
  003f0	74 17		 je	 SHORT $L71548
  003f2	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+224]
  003f6	8b 54 24 28	 mov	 edx, DWORD PTR _new_ret$[esp+220]
  003fa	03 c2		 add	 eax, edx
  003fc	8b 94 24 f0 00
	00 00		 mov	 edx, DWORD PTR _dict_hit_array$[esp+216]
  00403	80 3c 10 00	 cmp	 BYTE PTR [eax+edx], 0
  00407	74 1f		 je	 SHORT $L71552
$L71548:

; 1192 : 					{
; 1193 : #ifdef DEBUG
; 1194 : 						printf("processing rule because of dictionary MISS on the word\n");
; 1195 : #endif
; 1196 : 					}
; 1197 : 					else
; 1198 : 					{
; 1199 : 						current_rule_number++;
; 1200 : 						if (current_rule_number>=num_rules)		

  00409	a1 00 00 00 00	 mov	 eax, DWORD PTR _num_rules
  0040e	43		 inc	 ebx
  0040f	3b d8		 cmp	 ebx, eax
  00411	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00415	0f 8d 0a 07 00
	00		 jge	 $L71525

; 1201 : 							done=1;
; 1202 : 						else
; 1203 : 							done= -1;
; 1204 : 					}
; 1205 : 				}
; 1206 : 			} /* if (current_rule->dict_flag!=UNSET_PARAM) */
; 1207 : 			if (done)
; 1208 : 			{
; 1209 : 				if (done<0)
; 1210 : 					done=0;

  0041b	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _done$[esp+220], 0

; 1211 : 				continue;

  00423	e9 61 fe ff ff	 jmp	 $L71518
$L71552:

; 1212 : 			}
; 1213 : 			
; 1214 : 			if (current_value & BIN_NEXT_HIT)

  00428	f6 c5 10	 test	 ch, 16			; 00000010H
  0042b	74 14		 je	 SHORT $L71554

; 1215 : 			{
; 1216 : 				cur_rule_next_hit = *((U16 *)(current_rule+rule_p));

  0042d	33 c0		 xor	 eax, eax

; 1217 : 				rule_p+=2;

  0042f	be 0e 00 00 00	 mov	 esi, 14			; 0000000eH
  00434	66 8b 47 0c	 mov	 ax, WORD PTR [edi+12]

; 1218 : 			}
; 1219 : 			else

  00438	83 ca ff	 or	 edx, -1
  0043b	89 44 24 4c	 mov	 DWORD PTR _cur_rule_next_hit$[esp+220], eax
  0043f	eb 07		 jmp	 SHORT $L71556
$L71554:

; 1220 : 			{
; 1221 : 				cur_rule_next_hit=-1;

  00441	83 ca ff	 or	 edx, -1
  00444	89 54 24 4c	 mov	 DWORD PTR _cur_rule_next_hit$[esp+220], edx
$L71556:

; 1222 : 			}
; 1223 : 			if (current_value & BIN_NEXT_MISS)

  00448	f6 c5 08	 test	 ch, 8
  0044b	74 0f		 je	 SHORT $L71557

; 1224 : 			{
; 1225 : 				cur_rule_next_miss = *((U16 *)(current_rule+rule_p));

  0044d	33 c0		 xor	 eax, eax
  0044f	66 8b 04 3e	 mov	 ax, WORD PTR [esi+edi]

; 1226 : 				rule_p+=2;

  00453	83 c6 02	 add	 esi, 2
  00456	89 44 24 20	 mov	 DWORD PTR _cur_rule_next_miss$[esp+220], eax

; 1227 : 			}
; 1228 : 			else

  0045a	eb 04		 jmp	 SHORT $L71559
$L71557:

; 1229 : 			{
; 1230 : 				cur_rule_next_miss=-1;

  0045c	89 54 24 20	 mov	 DWORD PTR _cur_rule_next_miss$[esp+220], edx
$L71559:

; 1231 : 			}
; 1232 : 			if (current_value & BIN_GORET_HIT)

  00460	f6 c5 04	 test	 ch, 4
  00463	74 0f		 je	 SHORT $L71560

; 1233 : 			{
; 1234 : 				cur_rule_next_go_hit = *((U16 *)(current_rule+rule_p));

  00465	33 c0		 xor	 eax, eax
  00467	66 8b 04 3e	 mov	 ax, WORD PTR [esi+edi]

; 1235 : 				rule_p+=2;

  0046b	83 c6 02	 add	 esi, 2
  0046e	89 44 24 54	 mov	 DWORD PTR _cur_rule_next_go_hit$[esp+220], eax

; 1236 : 			}
; 1237 : 			else

  00472	eb 04		 jmp	 SHORT $L71562
$L71560:

; 1238 : 			{
; 1239 : 				cur_rule_next_go_hit=-1;

  00474	89 54 24 54	 mov	 DWORD PTR _cur_rule_next_go_hit$[esp+220], edx
$L71562:

; 1240 : 			}
; 1241 : 			if (current_value & BIN_GORET_MISS)

  00478	f6 c5 02	 test	 ch, 2
  0047b	74 0f		 je	 SHORT $L71563

; 1242 : 			{
; 1243 : 				cur_rule_next_go_miss = *((U16 *)(current_rule+rule_p));

  0047d	33 c0		 xor	 eax, eax
  0047f	66 8b 04 3e	 mov	 ax, WORD PTR [esi+edi]

; 1244 : 				rule_p+=2;

  00483	83 c6 02	 add	 esi, 2
  00486	89 44 24 18	 mov	 DWORD PTR _cur_rule_next_go_miss$[esp+220], eax

; 1245 : 			}
; 1246 : 			else

  0048a	eb 04		 jmp	 SHORT $L71565
$L71563:

; 1247 : 			{
; 1248 : 				cur_rule_next_go_miss=-1;

  0048c	89 54 24 18	 mov	 DWORD PTR _cur_rule_next_go_miss$[esp+220], edx
$L71565:

; 1249 : 			}
; 1250 : 			if (current_value & BIN_COPY_HIT)

  00490	f6 c5 01	 test	 ch, 1
  00493	74 0f		 je	 SHORT $L71566

; 1251 : 			{
; 1252 : 				cur_rule_copy_hit = *((U16 *)(current_rule+rule_p));

  00495	33 c0		 xor	 eax, eax
  00497	66 8b 04 3e	 mov	 ax, WORD PTR [esi+edi]

; 1253 : 				rule_p+=2;

  0049b	83 c6 02	 add	 esi, 2
  0049e	89 44 24 1c	 mov	 DWORD PTR _cur_rule_copy_hit$[esp+220], eax

; 1254 : 			}
; 1255 : 			else

  004a2	eb 04		 jmp	 SHORT $L71568
$L71566:

; 1256 : 			{
; 1257 : 				cur_rule_copy_hit=-1;

  004a4	89 54 24 1c	 mov	 DWORD PTR _cur_rule_copy_hit$[esp+220], edx
$L71568:

; 1258 : 			}
; 1259 : 			
; 1260 : #ifdef DEBUG_RULES
; 1261 : #ifdef PARSER_STANDALONE_DEBUG
; 1262 : 			fprintf(stderr,"rule number is R%d\n",current_rule_R_value);
; 1263 : 			fprintf(stderr,"next hit rule is %d\n",cur_rule_next_hit);
; 1264 : 			fprintf(stderr,"next_miss_rule is %d\n",cur_rule_next_miss);
; 1265 : #else
; 1266 : 			printf("rule number is R%d\n",current_rule_R_value);
; 1267 : 			printf("next hit rule is %d\n",cur_rule_next_hit);
; 1268 : 			printf("next_miss_rule is %d\n",cur_rule_next_miss);
; 1269 : #endif
; 1270 : #endif
; 1271 : 			
; 1272 : 			
; 1273 : #ifdef DISPLAY_RULES_TESTED
; 1274 : #ifdef OUTPUT_HITS_NORMAL
; 1275 : 			printf("rule number is R%d\n",current_rule_R_value);
; 1276 : #else
; 1277 : 			fprintf(stderr,"rule number is R%d\n",current_rule_R_value);
; 1278 : #endif
; 1279 : #endif
; 1280 : #ifndef PARSER_STANDALONE_DEBUG
; 1281 : 			if (DT_DBG(CMD_DBG,0x0200))

  004a8	8b 44 24 48	 mov	 eax, DWORD PTR _pKsd_t$[esp+220]
  004ac	66 8b 80 78 04
	00 00		 mov	 ax, WORD PTR [eax+1144]
  004b3	f6 c4 80	 test	 ah, -128		; ffffff80H
  004b6	74 18		 je	 SHORT $L71569
  004b8	f6 c4 02	 test	 ah, 2
  004bb	74 13		 je	 SHORT $L71569

; 1282 : 			{
; 1283 : 				printf("rule number is R%d\n",current_rule_R_value);

  004bd	8b 4c 24 68	 mov	 ecx, DWORD PTR _current_rule_R_value$[esp+220]
  004c1	51		 push	 ecx
  004c2	68 00 00 00 00	 push	 OFFSET FLAT:$SG71570
  004c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  004cd	83 c4 08	 add	 esp, 8
$L71569:

; 1284 : 				//par_print_rule_error("input before match",new_input,new_ret.input_pos+new_ret.input_offset);
; 1285 : 			}
; 1286 : #endif
; 1287 : 
; 1288 : 			
; 1289 : #ifdef DEBUG
; 1290 : 			par_print_rule_error("par_process_input; before par_match_rule",current_rule,new_ret.rule);
; 1291 : #endif
; 1292 : 			
; 1293 : #ifndef PARSER_STANDALONE_DEBUG
; 1294 : 			/* checking cmd_flushing */
; 1295 : 			if (pKsd_t->text_flush || (pKsd_t->cmd_flush == CMD_flush_toss))

  004d0	8b 44 24 48	 mov	 eax, DWORD PTR _pKsd_t$[esp+220]
  004d4	8b 88 70 01 00
	00		 mov	 ecx, DWORD PTR [eax+368]
  004da	85 c9		 test	 ecx, ecx
  004dc	0f 85 e6 06 00
	00		 jne	 $L71572
  004e2	83 b8 6c 01 00
	00 01		 cmp	 DWORD PTR [eax+364], 1
  004e9	0f 84 d9 06 00
	00		 je	 $L71572

; 1299 : 			}              
; 1300 : #endif
; 1301 : 			new_ret.rule=rule_p;
; 1302 : 			par_match_rule(current_rule,BIN_END_OF_RULE,new_input,output_array,new_input_indexes,output_indexes,match_array,&new_ret,0);

  004ef	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR _match_array$[esp+216]
  004f6	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR _output_indexes$[esp+216]
  004fd	8b ac 24 e8 00
	00 00		 mov	 ebp, DWORD PTR _new_input$[esp+216]
  00504	8d 54 24 28	 lea	 edx, DWORD PTR _new_ret$[esp+220]
  00508	6a 00		 push	 0
  0050a	52		 push	 edx
  0050b	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR _new_input_indexes$[esp+224]
  00512	50		 push	 eax
  00513	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR _output_array$[esp+228]
  0051a	51		 push	 ecx
  0051b	52		 push	 edx
  0051c	50		 push	 eax
  0051d	55		 push	 ebp
  0051e	6a 00		 push	 0
  00520	57		 push	 edi
  00521	89 74 24 5c	 mov	 DWORD PTR _new_ret$[esp+272], esi
  00525	e8 00 00 00 00	 call	 _par_match_rule

; 1303 : 			
; 1304 : #ifndef PARSER_STANDALONE_DEBUG
; 1305 : 			/* checking cmd_flushing */
; 1306 : 			if (pKsd_t->text_flush || (pKsd_t->cmd_flush == CMD_flush_toss))

  0052a	8b 74 24 6c	 mov	 esi, DWORD PTR _pKsd_t$[esp+256]
  0052e	83 c4 24	 add	 esp, 36			; 00000024H
  00531	8b 86 70 01 00
	00		 mov	 eax, DWORD PTR [esi+368]
  00537	85 c0		 test	 eax, eax
  00539	0f 85 65 06 00
	00		 jne	 $L71512
  0053f	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]
  00545	b8 01 00 00 00	 mov	 eax, 1
  0054a	3b c8		 cmp	 ecx, eax
  0054c	0f 84 52 06 00
	00		 je	 $L71512

; 1310 : 			}              
; 1311 : #endif
; 1312 : 			//printf("C parser_flag is %d\n",new_ret.parser_flag);
; 1313 :             /* GL 02/08/1997, set the parser_flag back to the caller */
; 1314 : 			ret_value->parser_flag = new_ret.parser_flag;

  00552	8b 94 24 14 01
	00 00		 mov	 edx, DWORD PTR _ret_value$[esp+216]
  00559	8b 4c 24 44	 mov	 ecx, DWORD PTR _new_ret$[esp+248]
  0055d	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 1315 : 			
; 1316 : 			/* 
; 1317 : 			* at this point in the matching, either a rule has hit and was processed or the 
; 1318 : 			* current word has to be copied to the output 
; 1319 : 			*/
; 1320 : 			if (new_ret.value == SUCCESS)

  00560	8b 4c 24 3c	 mov	 ecx, DWORD PTR _new_ret$[esp+240]
  00564	3b c8		 cmp	 ecx, eax
  00566	0f 85 08 05 00
	00		 jne	 $L71575

; 1321 : 			{         
; 1322 : 				/*	check to be sure the matching left off at the end of a word */
; 1323 : 				temp=new_ret.input_pos+new_ret.input_offset;

  0056c	8b 44 24 28	 mov	 eax, DWORD PTR _new_ret$[esp+220]
  00570	8b 4c 24 2c	 mov	 ecx, DWORD PTR _new_ret$[esp+224]

; 1324 : 			//	temp1=parser_char_types[new_input[temp]];
; 1325 : 				if (!((new_input[temp]=='\0') ||
; 1326 : 				      ((parser_char_types[new_input[temp]] & (TYPE_white))!=0) ||
; 1327 : 				      (((parser_char_types[new_input[temp]] & (TYPE_clause))!=0) &&
; 1328 : 				       ((new_input[temp+1]=='\0') || 
; 1329 : 				        (parser_char_types[new_input[temp+1]] & (TYPE_white))!=0)) ||
; 1330 : 				      (((parser_char_types[output_array[new_ret.output_pos+new_ret.output_offset-1]] & (TYPE_white))!=0) &&
; 1331 : 					   /*((parser_char_types[new_input[temp]] & (TYPE_white))==0) && */ (do_not_copy_next_word=1))
; 1332 : 					 
; 1333 : 					 
; 1334 : 					 
; 1335 : 					 
; 1336 : 					 ))

  00574	8b 54 24 34	 mov	 edx, DWORD PTR _new_ret$[esp+232]
  00578	03 c8		 add	 ecx, eax
  0057a	8a 04 29	 mov	 al, BYTE PTR [ecx+ebp]
  0057d	84 c0		 test	 al, al
  0057f	74 53		 je	 SHORT $L71576
  00581	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00586	66 8b 04 45 00
	00 00 00	 mov	 ax, WORD PTR _parser_char_types[eax*2]
  0058e	a8 20		 test	 al, 32			; 00000020H
  00590	75 42		 jne	 SHORT $L71576
  00592	f6 c4 08	 test	 ah, 8
  00595	74 17		 je	 SHORT $L71577
  00597	8a 44 29 01	 mov	 al, BYTE PTR [ecx+ebp+1]
  0059b	84 c0		 test	 al, al
  0059d	74 35		 je	 SHORT $L71576
  0059f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005a4	f6 04 45 00 00
	00 00 20	 test	 BYTE PTR _parser_char_types[eax*2], 32 ; 00000020H
  005ac	75 26		 jne	 SHORT $L71576
$L71577:
  005ae	8b 44 24 30	 mov	 eax, DWORD PTR _new_ret$[esp+228]
  005b2	8b bc 24 ec 00
	00 00		 mov	 edi, DWORD PTR _output_array$[esp+216]
  005b9	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  005bc	33 c0		 xor	 eax, eax
  005be	8a 44 39 ff	 mov	 al, BYTE PTR [ecx+edi-1]
  005c2	f6 04 45 00 00
	00 00 20	 test	 BYTE PTR _parser_char_types[eax*2], 32 ; 00000020H
  005ca	74 5d		 je	 SHORT $L71578
  005cc	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR _do_not_copy_next_word$[esp+220], 1
$L71576:

; 1376 : 						{
; 1377 : 							current_rule_number=cur_rule_next_miss;
; 1378 : 							last_rule_was_hit= -1;				/* reset the last_rule_was_hit flag */
; 1379 : 						}
; 1380 : 						else
; 1381 : 						{
; 1382 : 							current_rule_number++;      		/* go to the next rule in the rule table */
; 1383 : 							last_rule_was_hit=0;				/* reset the last_rule_was_hit flag */
; 1384 : 						}
; 1385 : 					}
; 1386 : 					
; 1387 : 				} /* if (((new_input[new_ret.input_pos+new_ret.input_offset]!='\0') && */
; 1388 : 				else                      
; 1389 : 				{
; 1390 : 					/* here is where next hit rules have to be done */
; 1391 : 					/* 	
; 1392 : 					*	the amount of data that was writen o the output array if the difference 
; 1393 : 					*	between new_ret.output_offset and save_ret.output_offset
; 1394 : 					*	The amount of data read is the difference between new_ret.input_offset
; 1395 : 					*	and save_ret.input_offset
; 1396 : 					*/          
; 1397 : 					/*  
; 1398 : 					*	the data in the output starting at save_ret.output_offset has to be 
; 1399 : 					*	copied into new_input starting at save_ret.input_offset
; 1400 : 					*/ 
; 1401 : 					/*	if the output is larger than the input, move the input over output-input characters
; 1402 : 					*	if the output is the same size as the input, overwrite the input with the output
; 1403 : 					*	if the output is smaller than the input, place the output input-output 
; 1404 : 					*		characters to the right
; 1405 : 					*/
; 1406 : 					/* debug switch */
; 1407 : #ifndef PARSER_STANDALONE_DEBUG
; 1408 : 					if (DT_DBG(CMD_DBG,0x0010))

  005d4	66 8b 86 78 04
	00 00		 mov	 ax, WORD PTR [esi+1144]
  005db	f6 c4 80	 test	 ah, -128		; ffffff80H
  005de	74 1b		 je	 SHORT $L71587
  005e0	a8 10		 test	 al, 16			; 00000010H
  005e2	74 17		 je	 SHORT $L71587

; 1409 : 					{
; 1410 : 						printf("Rule hit:R%d\n",current_rule_R_value);

  005e4	8b 54 24 68	 mov	 edx, DWORD PTR _current_rule_R_value$[esp+220]
  005e8	52		 push	 edx
  005e9	68 00 00 00 00	 push	 OFFSET FLAT:$SG71588
  005ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  005f4	8b 54 24 3c	 mov	 edx, DWORD PTR _new_ret$[esp+240]
  005f8	83 c4 08	 add	 esp, 8
$L71587:

; 1411 : 					}
; 1412 : #endif
; 1413 : #ifdef DISPLAY_RULES_HIT
; 1414 : #ifdef PARSER_STANDALONE_DEBUG
; 1415 : #ifdef OUTPUT_HITS_NORMAL
; 1416 : 					fprintf(stderr,"H");
; 1417 : 					printf("the rule hit was R%d\n",current_rule_R_value);
; 1418 : 					printf("output array=%s\n",output_array);
; 1419 : #else
; 1420 : 					fprintf(stderr,"the rule hit was R%d\n",current_rule_R_value);
; 1421 : 					printf("output array=%s\n",output_array);
; 1422 : #endif
; 1423 : #else
; 1424 : 					printf("the rule hit was R%d\n",current_rule_R_value);
; 1425 : #endif
; 1426 : 
; 1427 : #endif
; 1428 : 					 
; 1429 : #if 0
; 1430 : 					if (((parser_char_types[output_array[new_ret.output_pos+new_ret.output_offset-1]] & (TYPE_white))!=0) &&
; 1431 : 					   ((temp1 & (TYPE_white))==0))
; 1432 : 					{
; 1433 : 						do_not_copy_next_word=1;
; 1434 : 					}
; 1435 : #endif
; 1436 : 					if (cur_rule_copy_hit!=-1)

  005fb	8b 4c 24 1c	 mov	 ecx, DWORD PTR _cur_rule_copy_hit$[esp+220]
  005ff	83 c8 ff	 or	 eax, -1
  00602	3b c8		 cmp	 ecx, eax
  00604	0f 84 cc 00 00
	00		 je	 $L71589

; 1437 : 					{
; 1438 : 						last_rule_was_hit=1;
; 1439 : 						current_rule_number=cur_rule_copy_hit;

  0060a	8b d9		 mov	 ebx, ecx

; 1440 : 						par_copy_return_value(&save_ret,&new_ret);

  0060c	b9 08 00 00 00	 mov	 ecx, 8
  00611	8d 74 24 28	 lea	 esi, DWORD PTR _new_ret$[esp+220]
  00615	8d 7c 24 6c	 lea	 edi, DWORD PTR _save_ret$[esp+220]
  00619	bd 01 00 00 00	 mov	 ebp, 1
  0061e	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00622	f3 a5		 rep movsd

; 1441 : 					}
; 1442 : 					else

  00624	e9 b5 04 00 00	 jmp	 $L71616
$L71578:

; 1337 : 
; 1338 : 
; 1339 : 
; 1340 : /*				if (
; 1341 : 					(
; 1342 : 					 (new_input[new_ret.input_pos+new_ret.input_offset]!='\0') &&					
; 1343 : 					 !(
; 1344 : 					  ((parser_char_types[new_input[new_ret.input_pos+new_ret.input_offset]] & (TYPE_white))!=0)  ||
; 1345 : 					  (
; 1346 : 					   ((parser_char_types[new_input[new_ret.input_pos+new_ret.input_offset]] & (TYPE_clause))!=0) &&
; 1347 : 					   ( 
; 1348 : 					    (new_input[new_ret.input_pos+new_ret.input_offset+1]=='\0') ||
; 1349 : 					    ((parser_char_types[new_input[new_ret.input_pos+new_ret.input_offset+1]] & (TYPE_white))!=0) 
; 1350 : 					   )
; 1351 : 					  )
; 1352 : 					 )
; 1353 : 					) 
; 1354 : 				   )
; 1355 : */
; 1356 : 				{
; 1357 : 					par_copy_return_value(&new_ret,&save_ret);
; 1358 : 					if (cur_rule_next_go_miss!= -1)

  00629	8b 44 24 18	 mov	 eax, DWORD PTR _cur_rule_next_go_miss$[esp+220]
  0062d	b9 08 00 00 00	 mov	 ecx, 8
  00632	8d 74 24 6c	 lea	 esi, DWORD PTR _save_ret$[esp+220]
  00636	8d 7c 24 28	 lea	 edi, DWORD PTR _new_ret$[esp+220]
  0063a	83 f8 ff	 cmp	 eax, -1
  0063d	f3 a5		 rep movsd
  0063f	74 7a		 je	 SHORT $L71580

; 1359 : 					{
; 1360 : 						if (cur_rule_next_miss!= -1)

  00641	8b 4c 24 20	 mov	 ecx, DWORD PTR _cur_rule_next_miss$[esp+220]
  00645	83 f9 ff	 cmp	 ecx, -1
  00648	74 2c		 je	 SHORT $L71581

; 1361 : 						{
; 1362 : 							par_set_return_level(return_rule,&return_level,cur_rule_next_miss);

  0064a	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  0064e	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00651	7d 1c		 jge	 SHORT $L72841

; 1368 : 							//return_rule[return_level++]=current_rule_number+1;
; 1369 : 						}
; 1370 : 						current_rule_number=cur_rule_next_go_miss;

  00653	8b 5c 24 18	 mov	 ebx, DWORD PTR _cur_rule_next_go_miss$[esp+220]
  00657	89 8c 84 b4 00
	00 00		 mov	 DWORD PTR _return_rule$[esp+eax*4+220], ecx
  0065e	40		 inc	 eax
  0065f	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00663	89 44 24 10	 mov	 DWORD PTR _return_level$[esp+220], eax

; 1371 : 						last_rule_was_hit= -1;

  00667	83 cd ff	 or	 ebp, -1

; 1372 : 					}
; 1373 : 					else

  0066a	e9 6f 04 00 00	 jmp	 $L71616

; 1361 : 						{
; 1362 : 							par_set_return_level(return_rule,&return_level,cur_rule_next_miss);

$L72841:
  0066f	8b 4c 24 20	 mov	 ecx, DWORD PTR _cur_rule_next_miss$[esp+220]
  00673	51		 push	 ecx

; 1363 : 							//return_rule[return_level++]=next_miss_rule;
; 1364 : 						}
; 1365 : 						else

  00674	eb 27		 jmp	 SHORT $L72919
$L71581:

; 1366 : 						{
; 1367 : 							par_set_return_level(return_rule,&return_level,current_rule_number+1);

  00676	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  0067a	43		 inc	 ebx
  0067b	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0067e	7d 1c		 jge	 SHORT $L72883
$L72920:
  00680	89 9c 84 b4 00
	00 00		 mov	 DWORD PTR _return_rule$[esp+eax*4+220], ebx

; 1368 : 							//return_rule[return_level++]=current_rule_number+1;
; 1369 : 						}
; 1370 : 						current_rule_number=cur_rule_next_go_miss;

  00687	8b 5c 24 18	 mov	 ebx, DWORD PTR _cur_rule_next_go_miss$[esp+220]
  0068b	40		 inc	 eax
  0068c	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00690	89 44 24 10	 mov	 DWORD PTR _return_level$[esp+220], eax

; 1371 : 						last_rule_was_hit= -1;

  00694	83 cd ff	 or	 ebp, -1

; 1372 : 					}
; 1373 : 					else

  00697	e9 42 04 00 00	 jmp	 $L71616

; 1576 : 					{
; 1577 : 						par_set_return_level(return_rule,&return_level,current_rule_number+1);

$L72883:

; 1366 : 						{
; 1367 : 							par_set_return_level(return_rule,&return_level,current_rule_number+1);

  0069c	53		 push	 ebx
$L72919:
  0069d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@ ; `string'
  006a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf

; 1368 : 							//return_rule[return_level++]=current_rule_number+1;
; 1369 : 						}
; 1370 : 						current_rule_number=cur_rule_next_go_miss;

  006a8	8b 5c 24 20	 mov	 ebx, DWORD PTR _cur_rule_next_go_miss$[esp+228]
  006ac	83 c4 08	 add	 esp, 8
  006af	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx

; 1371 : 						last_rule_was_hit= -1;

  006b3	83 cd ff	 or	 ebp, -1

; 1372 : 					}
; 1373 : 					else

  006b6	e9 23 04 00 00	 jmp	 $L71616
$L71580:

; 1374 : 					{
; 1375 : 						if (cur_rule_next_miss!= -1)	/* this is also a miss */

  006bb	8b 44 24 20	 mov	 eax, DWORD PTR _cur_rule_next_miss$[esp+220]
  006bf	83 f8 ff	 cmp	 eax, -1
  006c2	0f 84 0f 04 00
	00		 je	 $L71584

; 1585 : 					{
; 1586 : 						current_rule_number=cur_rule_next_miss;

  006c8	8b d8		 mov	 ebx, eax
  006ca	83 cd ff	 or	 ebp, -1
  006cd	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  006d1	e9 08 04 00 00	 jmp	 $L71616
$L71589:

; 1443 : 
; 1444 : 					if ((cur_rule_next_hit!= -1) || (cur_rule_next_go_hit!= -1))

  006d6	39 44 24 4c	 cmp	 DWORD PTR _cur_rule_next_hit$[esp+220], eax
  006da	75 13		 jne	 SHORT $L71593
  006dc	39 44 24 54	 cmp	 DWORD PTR _cur_rule_next_go_hit$[esp+220], eax
  006e0	75 0d		 jne	 SHORT $L71593

; 1558 : 					} /* if ((current_rule->next_hit_rule!= -1) || (current_rule->next_goret_hit!= -1)) */
; 1559 : 					else
; 1560 : 					{
; 1561 : 						done=1;

  006e2	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR _done$[esp+220], 1

; 1562 : 						last_rule_was_hit=0;

  006ea	e9 ed 03 00 00	 jmp	 $L72914
$L71593:

; 1445 : 					{
; 1446 : 						par_copy_return_value(&hit_ret,&new_ret);
; 1447 : 						input_size=new_ret.input_offset-save_ret.input_offset;

  006ef	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+224]

; 1448 : 						output_size=new_ret.output_offset-save_ret.output_offset;

  006f3	8b 5c 24 78	 mov	 ebx, DWORD PTR _save_ret$[esp+232]
  006f7	b9 08 00 00 00	 mov	 ecx, 8
  006fc	8d 74 24 28	 lea	 esi, DWORD PTR _new_ret$[esp+220]
  00700	8d bc 24 94 00
	00 00		 lea	 edi, DWORD PTR _hit_ret$[esp+220]
  00707	2b d3		 sub	 edx, ebx
  00709	f3 a5		 rep movsd
  0070b	8b 74 24 70	 mov	 esi, DWORD PTR _save_ret$[esp+224]
  0070f	2b c6		 sub	 eax, esi

; 1449 : 						if (output_size>input_size)

  00711	3b c2		 cmp	 eax, edx
  00713	0f 8d fb 01 00
	00		 jge	 $L72915

; 1450 : 						{
; 1451 : #ifdef DEBUG
; 1452 : 							printf("par_process_input;the output is larger than the input\n");
; 1453 : #endif
; 1454 : 							size_diff=output_size-input_size;

  00719	8b ea		 mov	 ebp, edx
  0071b	2b e8		 sub	 ebp, eax

; 1455 : 							/* should check for overrunning the new input array */
; 1456 : 							/* copy the input to its new location */
; 1457 : #ifdef NEW_DEBUG
; 1458 : 							par_print_rule_error("the input_array before moving, changing",new_input,new_ret.input_pos+new_ret.input_offset);
; 1459 : 							par_print_rule_error("the output_array before moving, changing",output_array,new_ret.output_pos+new_ret.output_offset);
; 1460 : #endif
; 1461 : 							
; 1462 : 							if (save_ret.input_offset > size_diff)

  0071d	8b c6		 mov	 eax, esi
  0071f	3b c5		 cmp	 eax, ebp
  00721	0f 8e 84 00 00
	00		 jle	 $L71596

; 1463 : 							{
; 1464 : 								memcpy(new_input+(save_ret.input_pos+save_ret.input_offset-size_diff),output_array+(save_ret.output_offset+save_ret.output_pos),output_size);

  00727	8b 44 24 74	 mov	 eax, DWORD PTR _save_ret$[esp+228]
  0072b	8b bc 24 ec 00
	00 00		 mov	 edi, DWORD PTR _output_array$[esp+216]
  00732	8b ca		 mov	 ecx, edx
  00734	8d 34 03	 lea	 esi, DWORD PTR [ebx+eax]
  00737	8b 44 24 70	 mov	 eax, DWORD PTR _save_ret$[esp+224]
  0073b	89 74 24 1c	 mov	 DWORD PTR -192+[esp+220], esi
  0073f	03 f7		 add	 esi, edi
  00741	8b 7c 24 6c	 mov	 edi, DWORD PTR _save_ret$[esp+220]
  00745	2b c5		 sub	 eax, ebp
  00747	89 44 24 18	 mov	 DWORD PTR -196+[esp+220], eax
  0074b	03 f8		 add	 edi, eax
  0074d	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR _new_input$[esp+216]
  00754	03 f8		 add	 edi, eax
  00756	8b c1		 mov	 eax, ecx
  00758	c1 e9 02	 shr	 ecx, 2
  0075b	f3 a5		 rep movsd
  0075d	8b c8		 mov	 ecx, eax

; 1465 : 								/* copy the index data */
; 1466 : 								par_copy_index_list(new_input_indexes,(save_ret.input_pos+save_ret.input_pos-size_diff),output_indexes,(save_ret.output_offset+save_ret.output_pos),output_size);

  0075f	8b 44 24 1c	 mov	 eax, DWORD PTR -192+[esp+220]
  00763	83 e1 03	 and	 ecx, 3
  00766	f3 a4		 rep movsb
  00768	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  0076b	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0076e	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR _output_indexes$[esp+216]
  00775	d1 e1		 shl	 ecx, 1
  00777	8d 34 50	 lea	 esi, DWORD PTR [eax+edx*2]
  0077a	8b 54 24 6c	 mov	 edx, DWORD PTR _save_ret$[esp+220]
  0077e	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  00781	8b 94 24 f8 00
	00 00		 mov	 edx, DWORD PTR _new_input_indexes$[esp+216]
  00788	2b c5		 sub	 eax, ebp
  0078a	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0078d	8d 3c 42	 lea	 edi, DWORD PTR [edx+eax*2]
  00790	8b c1		 mov	 eax, ecx
  00792	c1 e9 02	 shr	 ecx, 2
  00795	f3 a5		 rep movsd
  00797	8b c8		 mov	 ecx, eax
  00799	83 e1 03	 and	 ecx, 3
  0079c	f3 a4		 rep movsb

; 1467 : 								/* hit_ret.input_offset+=size_diff; */
; 1468 : 								new_ret.input_offset=save_ret.input_offset-size_diff;

  0079e	8b 4c 24 18	 mov	 ecx, DWORD PTR -196+[esp+220]
  007a2	89 4c 24 2c	 mov	 DWORD PTR _new_ret$[esp+224], ecx

; 1469 : 								new_ret.output_offset=save_ret.output_offset;
; 1470 : 								save_ret.input_offset-=size_diff;
; 1471 : 							}
; 1472 : 							else

  007a6	e9 3e 02 00 00	 jmp	 $L72916
$L71596:

; 1473 : 							{
; 1474 : 								j=new_ret.input_offset+new_ret.input_pos;

  007ab	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+224]
  007af	8b 4c 24 28	 mov	 ecx, DWORD PTR _new_ret$[esp+220]

; 1475 : 								for (i=strlen(new_input)+size_diff;i>j;i--)

  007b3	8b bc 24 e8 00
	00 00		 mov	 edi, DWORD PTR _new_input$[esp+216]
  007ba	03 c1		 add	 eax, ecx
  007bc	89 44 24 20	 mov	 DWORD PTR _j$[esp+220], eax
  007c0	83 c9 ff	 or	 ecx, -1
  007c3	33 c0		 xor	 eax, eax
  007c5	f2 ae		 repne scasb
  007c7	8b 44 24 20	 mov	 eax, DWORD PTR _j$[esp+220]
  007cb	f7 d1		 not	 ecx
  007cd	49		 dec	 ecx
  007ce	8b f1		 mov	 esi, ecx
  007d0	03 f5		 add	 esi, ebp
  007d2	3b f0		 cmp	 esi, eax
  007d4	0f 8e a6 00 00
	00		 jle	 $L71600
  007da	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR _dict_hit_array$[esp+216]
  007e1	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  007e4	8d 5c 6d 00	 lea	 ebx, DWORD PTR [ebp+ebp*2]
  007e8	8d 3c 06	 lea	 edi, DWORD PTR [esi+eax]
  007eb	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR _new_input$[esp+216]
  007f2	d1 e1		 shl	 ecx, 1
  007f4	d1 e3		 shl	 ebx, 1
  007f6	2b 84 24 f0 00
	00 00		 sub	 eax, DWORD PTR _dict_hit_array$[esp+216]
  007fd	89 7c 24 18	 mov	 DWORD PTR -196+[esp+220], edi
  00801	89 4c 24 1c	 mov	 DWORD PTR -192+[esp+220], ecx
  00805	89 9c 24 90 00
	00 00		 mov	 DWORD PTR -76+[esp+220], ebx
  0080c	89 44 24 58	 mov	 DWORD PTR -132+[esp+220], eax
  00810	eb 07		 jmp	 SHORT $L71598
$L72905:
  00812	8b 9c 24 90 00
	00 00		 mov	 ebx, DWORD PTR -76+[esp+220]
$L71598:

; 1476 : 								{
; 1477 : 									k=i-size_diff;

  00819	2b cb		 sub	 ecx, ebx

; 1478 : #ifdef DEBUG
; 1479 : 									printf("process_input;copying new_input[%d]%c(%0X)=new_input[%d]%c(%0X)\n",i,new_input[i],new_input[i],k,new_input[k],new_input[k]);
; 1480 : #endif
; 1481 : 									new_input[i]=new_input[k];

  0081b	8b 5c 24 58	 mov	 ebx, DWORD PTR -132+[esp+220]
  0081f	8b c6		 mov	 eax, esi
  00821	89 4c 24 5c	 mov	 DWORD PTR -128+[esp+220], ecx
  00825	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR _new_input$[esp+216]
  0082c	2b c5		 sub	 eax, ebp
  0082e	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  00831	88 0c 3b	 mov	 BYTE PTR [ebx+edi], cl

; 1482 : 									par_copy_index(new_input_indexes,i,new_input_indexes,k);

  00834	8b 7c 24 5c	 mov	 edi, DWORD PTR -128+[esp+220]
  00838	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR _new_input_indexes$[esp+216]
  0083f	8b 5c 24 1c	 mov	 ebx, DWORD PTR -192+[esp+220]
  00843	03 f9		 add	 edi, ecx
  00845	03 d9		 add	 ebx, ecx
  00847	4e		 dec	 esi
  00848	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0084a	89 0b		 mov	 DWORD PTR [ebx], ecx
  0084c	66 8b 4f 04	 mov	 cx, WORD PTR [edi+4]

; 1483 : 									dict_hit_array[i]=dict_hit_array[k];

  00850	8b 7c 24 18	 mov	 edi, DWORD PTR -196+[esp+220]
  00854	66 89 4b 04	 mov	 WORD PTR [ebx+4], cx
  00858	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR _dict_hit_array$[esp+216]
  0085f	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  00862	8b 4c 24 1c	 mov	 ecx, DWORD PTR -192+[esp+220]
  00866	88 07		 mov	 BYTE PTR [edi], al
  00868	8b 44 24 20	 mov	 eax, DWORD PTR _j$[esp+220]
  0086c	83 e9 06	 sub	 ecx, 6
  0086f	4f		 dec	 edi
  00870	3b f0		 cmp	 esi, eax
  00872	89 4c 24 1c	 mov	 DWORD PTR -192+[esp+220], ecx
  00876	89 7c 24 18	 mov	 DWORD PTR -196+[esp+220], edi
  0087a	7f 96		 jg	 SHORT $L72905

; 1475 : 								for (i=strlen(new_input)+size_diff;i>j;i--)

  0087c	8b 5c 24 78	 mov	 ebx, DWORD PTR _save_ret$[esp+232]
$L71600:

; 1484 : 									
; 1485 : 								}
; 1486 : 								new_input_diff+=size_diff;

  00880	8b 4c 24 60	 mov	 ecx, DWORD PTR _new_input_diff$[esp+220]

; 1487 : #ifdef DEBUG
; 1488 : 								par_print_rule_error("111 input",new_input,new_ret.input_pos+new_ret.input_offset);
; 1489 : 								par_print_rule_error("111 output",output_array,new_ret.output_pos+new_ret.output_offset);
; 1490 : #endif
; 1491 : 								/* copy the changed data */
; 1492 : 								memcpy(new_input+(save_ret.input_offset+save_ret.input_pos),output_array+(save_ret.output_offset+save_ret.output_pos),output_size);

  00884	8b 74 24 70	 mov	 esi, DWORD PTR _save_ret$[esp+224]
  00888	03 cd		 add	 ecx, ebp
  0088a	89 4c 24 60	 mov	 DWORD PTR _new_input_diff$[esp+220], ecx
  0088e	8b 4c 24 74	 mov	 ecx, DWORD PTR _save_ret$[esp+228]
  00892	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  00895	8b 4c 24 6c	 mov	 ecx, DWORD PTR _save_ret$[esp+220]
  00899	89 44 24 1c	 mov	 DWORD PTR -192+[esp+220], eax
  0089d	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  008a0	8b b4 24 ec 00
	00 00		 mov	 esi, DWORD PTR _output_array$[esp+216]
  008a7	03 f0		 add	 esi, eax
  008a9	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR _new_input$[esp+216]
  008b0	89 7c 24 18	 mov	 DWORD PTR -196+[esp+220], edi
  008b4	8b ca		 mov	 ecx, edx
  008b6	03 f8		 add	 edi, eax
  008b8	8b c1		 mov	 eax, ecx
  008ba	c1 e9 02	 shr	 ecx, 2
  008bd	f3 a5		 rep movsd
  008bf	8b c8		 mov	 ecx, eax

; 1493 : 								/* copy the index data */
; 1494 : 								par_copy_index_list(new_input_indexes,(save_ret.input_offset+save_ret.input_pos),output_indexes,(save_ret.output_offset+save_ret.output_pos),output_size);

  008c1	8b 44 24 1c	 mov	 eax, DWORD PTR -192+[esp+220]
  008c5	83 e1 03	 and	 ecx, 3
  008c8	f3 a4		 rep movsb
  008ca	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  008cd	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  008d0	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR _output_indexes$[esp+216]
  008d7	d1 e1		 shl	 ecx, 1
  008d9	8d 34 50	 lea	 esi, DWORD PTR [eax+edx*2]
  008dc	8b 44 24 18	 mov	 eax, DWORD PTR -196+[esp+220]
  008e0	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  008e3	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR _new_input_indexes$[esp+216]
  008ea	8d 3c 50	 lea	 edi, DWORD PTR [eax+edx*2]
  008ed	8b d1		 mov	 edx, ecx
  008ef	c1 e9 02	 shr	 ecx, 2
  008f2	f3 a5		 rep movsd

; 1495 : 								hit_ret.input_offset+=size_diff;

  008f4	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR _hit_ret$[esp+224]
  008fb	8b ca		 mov	 ecx, edx
  008fd	83 e1 03	 and	 ecx, 3
  00900	03 c5		 add	 eax, ebp
  00902	89 84 24 98 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+224], eax

; 1496 : 								new_ret.input_offset=save_ret.input_offset;

  00909	8b 44 24 70	 mov	 eax, DWORD PTR _save_ret$[esp+224]
  0090d	f3 a4		 rep movsb

; 1497 : 								new_ret.output_offset=save_ret.output_offset;
; 1498 : 							}
; 1499 : #ifdef DEBUG
; 1500 : 							par_print_rule_error("222 input",new_input,new_ret.input_pos+new_ret.input_offset);
; 1501 : 							par_print_rule_error("222 output",output_array,new_ret.output_pos+new_ret.output_offset);
; 1502 : #endif
; 1503 : #ifdef NEW_DEBUG
; 1504 : 							par_print_rule_error("the input_array after moving, changing",new_input,new_ret.input_pos+new_ret.input_offset);
; 1505 : 							par_print_rule_error("the output_array after moving, changing",output_array,new_ret.output_pos+new_ret.output_offset);
; 1506 : #endif
; 1507 : 						} /* if (output_size>input_size) */
; 1508 : 						else

  0090f	e9 d1 00 00 00	 jmp	 $L72917
$L72915:

; 1509 : 						{
; 1510 : 							if (input_size==output_size)

  00914	75 64		 jne	 SHORT $L71602

; 1511 : 							{
; 1512 : #ifdef DEBUG
; 1513 : 								printf("par_process_input;the output is the same size as the input\n");
; 1514 : #endif              
; 1515 : 								/* overwrite the input with the output */
; 1516 : 								memcpy(new_input+save_ret.input_offset+save_ret.input_pos,output_array+save_ret.output_offset+save_ret.output_pos,input_size);

  00916	8b 4c 24 74	 mov	 ecx, DWORD PTR _save_ret$[esp+228]
  0091a	8d 14 0b	 lea	 edx, DWORD PTR [ebx+ecx]
  0091d	8b 4c 24 6c	 mov	 ecx, DWORD PTR _save_ret$[esp+220]
  00921	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  00924	8b b4 24 ec 00
	00 00		 mov	 esi, DWORD PTR _output_array$[esp+216]
  0092b	89 7c 24 18	 mov	 DWORD PTR -196+[esp+220], edi
  0092f	8b c8		 mov	 ecx, eax
  00931	03 fd		 add	 edi, ebp
  00933	8b e9		 mov	 ebp, ecx
  00935	03 f2		 add	 esi, edx

; 1517 : 								/* overwrite the index data with the output index data */
; 1518 : 								par_copy_index_list(new_input_indexes,save_ret.input_offset+save_ret.input_pos,output_indexes,save_ret.output_offset+save_ret.output_pos,input_size);

  00937	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  0093a	c1 e9 02	 shr	 ecx, 2
  0093d	f3 a5		 rep movsd
  0093f	8b cd		 mov	 ecx, ebp
  00941	83 e1 03	 and	 ecx, 3
  00944	f3 a4		 rep movsb
  00946	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00949	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR _output_indexes$[esp+216]
  00950	d1 e1		 shl	 ecx, 1
  00952	8d 34 50	 lea	 esi, DWORD PTR [eax+edx*2]
  00955	8b 44 24 18	 mov	 eax, DWORD PTR -196+[esp+220]
  00959	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0095c	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR _new_input_indexes$[esp+216]
  00963	8d 3c 50	 lea	 edi, DWORD PTR [eax+edx*2]
  00966	8b d1		 mov	 edx, ecx
  00968	c1 e9 02	 shr	 ecx, 2
  0096b	f3 a5		 rep movsd

; 1519 : 								new_ret.input_offset=save_ret.input_offset;

  0096d	8b 44 24 70	 mov	 eax, DWORD PTR _save_ret$[esp+224]
  00971	8b ca		 mov	 ecx, edx
  00973	83 e1 03	 and	 ecx, 3
  00976	f3 a4		 rep movsb

; 1520 : 								new_ret.output_offset=save_ret.output_offset;
; 1521 : 							} /* if (input_size==output_size) */
; 1522 : 							else

  00978	eb 6b		 jmp	 SHORT $L72917
$L71602:

; 1523 : 							{
; 1524 : #ifdef DEBUG
; 1525 : 								printf("par_process_input;the output is smaller than the input\n");
; 1526 : #endif                                   
; 1527 : 								/* 
; 1528 : 								* place the output in the input array so the end of the output
; 1529 : 								* matches up with the end of the input that was just processed 
; 1530 : 								*/
; 1531 : 								size_diff=input_size-output_size;

  0097a	2b c2		 sub	 eax, edx
  0097c	8b c8		 mov	 ecx, eax

; 1532 : 								/* copy the output to the proper place in the input */
; 1533 : 								memcpy(new_input+save_ret.input_offset+save_ret.input_pos+size_diff,output_array+save_ret.output_offset+save_ret.output_pos,output_size);

  0097e	8b 44 24 74	 mov	 eax, DWORD PTR _save_ret$[esp+228]
  00982	03 ce		 add	 ecx, esi
  00984	8b 74 24 6c	 mov	 esi, DWORD PTR _save_ret$[esp+220]
  00988	89 4c 24 58	 mov	 DWORD PTR -132+[esp+220], ecx
  0098c	03 c3		 add	 eax, ebx
  0098e	8d 3c 31	 lea	 edi, DWORD PTR [ecx+esi]
  00991	8b b4 24 ec 00
	00 00		 mov	 esi, DWORD PTR _output_array$[esp+216]
  00998	89 7c 24 5c	 mov	 DWORD PTR -128+[esp+220], edi
  0099c	8b ca		 mov	 ecx, edx
  0099e	03 fd		 add	 edi, ebp
  009a0	8b e9		 mov	 ebp, ecx
  009a2	03 f0		 add	 esi, eax
  009a4	c1 e9 02	 shr	 ecx, 2
  009a7	f3 a5		 rep movsd
  009a9	8b cd		 mov	 ecx, ebp
  009ab	83 e1 03	 and	 ecx, 3
  009ae	f3 a4		 rep movsb

; 1534 : 								/* copy the indexes into their new home */
; 1535 : 								par_copy_index_list(new_input_indexes,save_ret.input_offset+save_ret.input_pos+size_diff,output_indexes,save_ret.output_offset+save_ret.output_pos,output_size);

  009b0	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  009b3	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  009b6	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR _output_indexes$[esp+216]
  009bd	d1 e1		 shl	 ecx, 1
  009bf	8d 34 50	 lea	 esi, DWORD PTR [eax+edx*2]
  009c2	8b 44 24 5c	 mov	 eax, DWORD PTR -128+[esp+220]
  009c6	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  009c9	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR _new_input_indexes$[esp+216]
  009d0	8d 3c 50	 lea	 edi, DWORD PTR [eax+edx*2]
  009d3	8b d1		 mov	 edx, ecx
  009d5	c1 e9 02	 shr	 ecx, 2
  009d8	f3 a5		 rep movsd

; 1536 : 								new_ret.input_offset=save_ret.input_offset+size_diff;

  009da	8b 44 24 58	 mov	 eax, DWORD PTR -132+[esp+220]
  009de	8b ca		 mov	 ecx, edx
  009e0	83 e1 03	 and	 ecx, 3
  009e3	f3 a4		 rep movsb
$L72917:
  009e5	89 44 24 2c	 mov	 DWORD PTR _new_ret$[esp+224], eax
$L72916:

; 1537 : 								new_ret.output_offset=save_ret.output_offset;

  009e9	89 5c 24 34	 mov	 DWORD PTR _new_ret$[esp+232], ebx

; 1538 : 							} /* if (input_size==output_size) */
; 1539 : 						} /* if (output_size>input_size) */
; 1540 : 						if (cur_rule_next_go_hit!= -1)

  009ed	8b 5c 24 54	 mov	 ebx, DWORD PTR _cur_rule_next_go_hit$[esp+220]
  009f1	83 fb ff	 cmp	 ebx, -1
  009f4	74 60		 je	 SHORT $L71604

; 1541 : 						{
; 1542 : 							if (cur_rule_next_hit!= -1)

  009f6	8b 4c 24 4c	 mov	 ecx, DWORD PTR _cur_rule_next_hit$[esp+220]
  009fa	83 f9 ff	 cmp	 ecx, -1
  009fd	74 28		 je	 SHORT $L71605

; 1543 : 							{
; 1544 : 								par_set_return_level(return_rule,&return_level,cur_rule_next_hit);

  009ff	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  00a03	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00a06	7d 0e		 jge	 SHORT $L72867
  00a08	89 8c 84 b4 00
	00 00		 mov	 DWORD PTR _return_rule$[esp+eax*4+220], ecx
  00a0f	40		 inc	 eax
  00a10	89 44 24 10	 mov	 DWORD PTR _return_level$[esp+220], eax
  00a14	eb 44		 jmp	 SHORT $L72873
$L72867:
  00a16	51		 push	 ecx

; 1545 : 							}
; 1546 : 							else
; 1547 : 							{
; 1548 : 								par_set_return_level(return_rule,&return_level,current_rule_number+1);

  00a17	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@ ; `string'
  00a1c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00a22	83 c4 08	 add	 esp, 8

; 1549 : 							}
; 1550 : 							current_rule_number=cur_rule_next_go_hit;
; 1551 : 						}
; 1552 : 						else

  00a25	eb 33		 jmp	 SHORT $L72873
$L71605:

; 1545 : 							}
; 1546 : 							else
; 1547 : 							{
; 1548 : 								par_set_return_level(return_rule,&return_level,current_rule_number+1);

  00a27	8b 4c 24 14	 mov	 ecx, DWORD PTR _current_rule_number$[esp+220]
  00a2b	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00a2e	8b 4c 24 10	 mov	 ecx, DWORD PTR _return_level$[esp+220]
  00a32	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00a35	7d 0e		 jge	 SHORT $L72872
  00a37	89 84 8c b4 00
	00 00		 mov	 DWORD PTR _return_rule$[esp+ecx*4+220], eax
  00a3e	41		 inc	 ecx
  00a3f	89 4c 24 10	 mov	 DWORD PTR _return_level$[esp+220], ecx
  00a43	eb 15		 jmp	 SHORT $L72873
$L72872:
  00a45	50		 push	 eax
  00a46	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@ ; `string'
  00a4b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00a51	83 c4 08	 add	 esp, 8

; 1549 : 							}
; 1550 : 							current_rule_number=cur_rule_next_go_hit;
; 1551 : 						}
; 1552 : 						else

  00a54	eb 04		 jmp	 SHORT $L72873
$L71604:

; 1553 : 						{						
; 1554 : 							current_rule_number=cur_rule_next_hit;         

  00a56	8b 5c 24 4c	 mov	 ebx, DWORD PTR _cur_rule_next_hit$[esp+220]

; 1545 : 							}
; 1546 : 							else
; 1547 : 							{
; 1548 : 								par_set_return_level(return_rule,&return_level,current_rule_number+1);

$L72873:

; 1555 : 						}
; 1556 : 						par_copy_return_value(&save_ret,&new_ret);

  00a5a	b9 08 00 00 00	 mov	 ecx, 8
  00a5f	8d 74 24 28	 lea	 esi, DWORD PTR _new_ret$[esp+220]
  00a63	8d 7c 24 6c	 lea	 edi, DWORD PTR _save_ret$[esp+220]
  00a67	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00a6b	f3 a5		 rep movsd

; 1557 : 						last_rule_was_hit=1;

  00a6d	bd 01 00 00 00	 mov	 ebp, 1

; 1563 : 					} /* if ((current_rule->next_hit_rule!= -1) || (current_rule->next_goret_hit!= -1)) */
; 1564 : 				} /* if (((new_input[new_ret.input_pos+new_ret.input_offset]!='\0') && */
; 1565 : 			} /* if (new_ret.value == SUCCESS) */
; 1566 : 			else                  

  00a72	eb 6a		 jmp	 SHORT $L71616
$L71575:

; 1567 : 			{
; 1568 : 				/* next miss rules are done here */
; 1569 : 				if (cur_rule_next_go_miss!= -1)

  00a74	83 7c 24 18 ff	 cmp	 DWORD PTR _cur_rule_next_go_miss$[esp+220], -1
  00a79	74 48		 je	 SHORT $L71611

; 1570 : 				{
; 1571 : 					if (cur_rule_next_miss!= -1)

  00a7b	8b 4c 24 20	 mov	 ecx, DWORD PTR _cur_rule_next_miss$[esp+220]
  00a7f	83 f9 ff	 cmp	 ecx, -1
  00a82	74 2c		 je	 SHORT $L71612

; 1572 : 					{
; 1573 : 						par_set_return_level(return_rule,&return_level,cur_rule_next_miss);

  00a84	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  00a88	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00a8b	7d 19		 jge	 SHORT $L72878
  00a8d	8b 5c 24 18	 mov	 ebx, DWORD PTR _cur_rule_next_go_miss$[esp+220]
  00a91	89 8c 84 b4 00
	00 00		 mov	 DWORD PTR _return_rule$[esp+eax*4+220], ecx
  00a98	40		 inc	 eax
  00a99	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00a9d	89 44 24 10	 mov	 DWORD PTR _return_level$[esp+220], eax
  00aa1	83 cd ff	 or	 ebp, -1
  00aa4	eb 38		 jmp	 SHORT $L71616
$L72878:
  00aa6	8b 54 24 20	 mov	 edx, DWORD PTR _cur_rule_next_miss$[esp+220]
  00aaa	52		 push	 edx

; 1574 : 					}
; 1575 : 					else

  00aab	e9 ed fb ff ff	 jmp	 $L72919
$L71612:

; 1576 : 					{
; 1577 : 						par_set_return_level(return_rule,&return_level,current_rule_number+1);

  00ab0	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  00ab4	43		 inc	 ebx
  00ab5	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00ab8	0f 8d de fb ff
	ff		 jge	 $L72883

; 1578 : 					}
; 1579 : 					current_rule_number=cur_rule_next_go_miss;
; 1580 : 					last_rule_was_hit= -1;
; 1581 : 				}
; 1582 : 				else

  00abe	e9 bd fb ff ff	 jmp	 $L72920
$L71611:

; 1583 : 				{
; 1584 : 					if (cur_rule_next_miss!= -1)	/* this is also a miss */

  00ac3	8b 44 24 20	 mov	 eax, DWORD PTR _cur_rule_next_miss$[esp+220]
  00ac7	83 f8 ff	 cmp	 eax, -1
  00aca	74 0b		 je	 SHORT $L71584

; 1585 : 					{
; 1586 : 						current_rule_number=cur_rule_next_miss;

  00acc	8b d8		 mov	 ebx, eax
  00ace	83 cd ff	 or	 ebp, -1
  00ad1	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00ad5	eb 07		 jmp	 SHORT $L71616
$L71584:

; 1587 : 						last_rule_was_hit= -1;				/* reset the last_rule_was_hit flag */
; 1588 : 					}
; 1589 : 					else
; 1590 : 					{
; 1591 : 						current_rule_number++;      		/* go to the next rule in the rule table */

  00ad7	43		 inc	 ebx
  00ad8	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
$L72914:

; 1592 : 						last_rule_was_hit=0;				/* reset the last_rule_was_hit flag */

  00adc	33 ed		 xor	 ebp, ebp
$L71616:

; 1593 : 					}
; 1594 : 				}
; 1595 : 			} /* if (new_ret.value == SUCCESS) */
; 1596 : 			  /*
; 1597 : 			  * the processing has tried all the rules and either the
; 1598 : 			  * last rule has hit or none of them hit 
; 1599 : 			*/
; 1600 : 			if ((current_rule_number>=num_rules) || (current_rule_number<0))

  00ade	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR _num_rules
  00ae4	7d 3f		 jge	 SHORT $L71525
  00ae6	85 db		 test	 ebx, ebx
  00ae8	7c 3b		 jl	 SHORT $L71525
  00aea	8b 44 24 24	 mov	 eax, DWORD PTR _done$[esp+220]
  00aee	85 c0		 test	 eax, eax
  00af0	75 33		 jne	 SHORT $L71525

; 1050 : 		}  	               
; 1051 : 		par_copy_return_value(&save_ret,&new_ret);	/* save the values if the matching ends on a non white */
; 1052 : 		current_rule=NULL;                     
; 1053 : 		current_rule_number=rule_sections[rule];
; 1054 : 		last_rule_was_hit=0;
; 1055 : #ifdef DEBUG
; 1056 : 		par_print_rule_error("par_process_input;1 the input is",new_input,new_ret.input_pos+new_ret.input_offset);
; 1057 : 		par_print_rule_error("par_process_input;1 the output is",output_array,new_ret.output_pos+new_ret.output_offset);
; 1058 : #endif
; 1059 : 		while (!done)

  00af2	e9 92 f7 ff ff	 jmp	 $L71518
$L71528:

; 1089 : 				case BIN_STOP:
; 1090 : 					done=1;
; 1091 : 					/* 
; 1092 : 					* potential bug if the matching is down a return level and 
; 1093 : 					* encounters a stop, the return level is left in place and could start
; 1094 : 					* to overwrite memory 
; 1095 : 					*/
; 1096 : 					return_level=0;
; 1097 : 					if (last_rule_was_hit>0)

  00af7	85 ed		 test	 ebp, ebp
  00af9	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _return_level$[esp+220], 0
  00b01	7e 22		 jle	 SHORT $L71525

; 1098 : 					{
; 1099 : 						//new_ret.output_offset=hit_ret.output_offset;
; 1100 : 						par_copy_return_value(&new_ret,&hit_ret);

  00b03	b9 08 00 00 00	 mov	 ecx, 8
  00b08	8d b4 24 94 00
	00 00		 lea	 esi, DWORD PTR _hit_ret$[esp+220]
  00b0f	8d 7c 24 28	 lea	 edi, DWORD PTR _new_ret$[esp+220]
  00b13	f3 a5		 rep movsd

; 1101 : 					}
; 1102 : 					continue;          

  00b15	eb 0e		 jmp	 SHORT $L71525
$L72890:

; 1116 : 				default:
; 1117 : 					printf("special rule value is out of range\n");

  00b17	68 00 00 00 00	 push	 OFFSET FLAT:$SG71535
  00b1c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00b22	83 c4 04	 add	 esp, 4
$L71525:

; 1601 : 				done=1;         
; 1602 : #ifdef DEBUG
; 1603 : 			printf("process_input done = %d\n",done);
; 1604 : #endif
; 1605 : 			
; 1606 : 		}	/* while (!done) */
; 1607 : 		/* copy the word to the output */
; 1608 : 		/* this copies the data from the current position in the input until it hits a whitespace */
; 1609 : 		/* -1 signals that the end of the input string has been reached */
; 1610 : 		/* should check for overrunning the output array */
; 1611 : 		if (do_not_copy_next_word==1)

  00b25	83 7c 24 64 01	 cmp	 DWORD PTR _do_not_copy_next_word$[esp+220], 1
  00b2a	75 28		 jne	 SHORT $L71619

; 1612 : 		{
; 1613 : 			do_not_copy_next_word=0;
; 1614 : 			done=0;
; 1615 : 		}
; 1616 : 		else

  00b2c	8b 9c 24 14 01
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+216]
  00b33	8b b4 24 e8 00
	00 00		 mov	 esi, DWORD PTR _new_input$[esp+216]
  00b3a	33 c0		 xor	 eax, eax
  00b3c	bf 01 00 00 00	 mov	 edi, 1
  00b41	89 44 24 64	 mov	 DWORD PTR _do_not_copy_next_word$[esp+220], eax
  00b45	89 44 24 24	 mov	 DWORD PTR _done$[esp+220], eax
  00b49	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+224]
  00b4d	33 ed		 xor	 ebp, ebp
  00b4f	e9 81 f6 ff ff	 jmp	 $L71507
$L71619:

; 1617 : 		{
; 1618 : 			if (par_copy_word_to_output(new_input,output_array,new_input_indexes,output_indexes,&new_ret)== -1)

  00b54	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR _output_indexes$[esp+216]
  00b5b	8b 94 24 f8 00
	00 00		 mov	 edx, DWORD PTR _new_input_indexes$[esp+216]
  00b62	8b b4 24 e8 00
	00 00		 mov	 esi, DWORD PTR _new_input$[esp+216]
  00b69	8d 44 24 28	 lea	 eax, DWORD PTR _new_ret$[esp+220]
  00b6d	50		 push	 eax
  00b6e	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR _output_array$[esp+220]
  00b75	51		 push	 ecx
  00b76	52		 push	 edx
  00b77	50		 push	 eax
  00b78	56		 push	 esi
  00b79	e8 00 00 00 00	 call	 _par_copy_word_to_output

; 1619 : 			{
; 1620 : 				done=1;
; 1621 : 			}
; 1622 : 			else
; 1623 : 			{
; 1624 : 				done=0;
; 1625 : 			}
; 1626 : 		}
; 1627 : 		
; 1628 : 	}	/* while (new_input[]!='\0') */

  00b7e	8b 9c 24 28 01
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+236]
  00b85	83 c4 14	 add	 esp, 20			; 00000014H
  00b88	33 c9		 xor	 ecx, ecx
  00b8a	83 f8 ff	 cmp	 eax, -1
  00b8d	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+224]
  00b91	bf 01 00 00 00	 mov	 edi, 1
  00b96	0f 94 c1	 sete	 cl
  00b99	89 4c 24 24	 mov	 DWORD PTR _done$[esp+220], ecx
  00b9d	33 ed		 xor	 ebp, ebp
  00b9f	e9 31 f6 ff ff	 jmp	 $L71507
$L71512:

; 1307 : 			{
; 1308 : 				cm_util_flush_init(phTTS);

  00ba4	8b 94 24 e0 00
	00 00		 mov	 edx, DWORD PTR _phTTS$[esp+216]
  00bab	52		 push	 edx
  00bac	e8 00 00 00 00	 call	 _cm_util_flush_init

; 1309 : 				return(&pCmd_t->ret_value);

  00bb1	8b 44 24 54	 mov	 eax, DWORD PTR _pCmd_t$[esp+224]
  00bb5	83 c4 04	 add	 esp, 4
  00bb8	05 78 33 00 00	 add	 eax, 13176		; 00003378H
  00bbd	5f		 pop	 edi
  00bbe	5e		 pop	 esi
  00bbf	5d		 pop	 ebp
  00bc0	5b		 pop	 ebx

; 1637 : }                       

  00bc1	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00bc7	c3		 ret	 0
$L71572:

; 1296 : 			{
; 1297 : 				cm_util_flush_init(phTTS);

  00bc8	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR _phTTS$[esp+216]
  00bcf	51		 push	 ecx
  00bd0	e8 00 00 00 00	 call	 _cm_util_flush_init

; 1298 : 				return(&pCmd_t->ret_value);

  00bd5	8b 54 24 54	 mov	 edx, DWORD PTR _pCmd_t$[esp+224]
  00bd9	83 c4 04	 add	 esp, 4
  00bdc	5f		 pop	 edi
  00bdd	5e		 pop	 esi
  00bde	5d		 pop	 ebp
  00bdf	8d 82 78 33 00
	00		 lea	 eax, DWORD PTR [edx+13176]
  00be5	5b		 pop	 ebx

; 1637 : }                       

  00be6	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00bec	c3		 ret	 0
$L71521:

; 1064 : 			{
; 1065 : 				cm_util_flush_init(phTTS);

  00bed	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR _phTTS$[esp+216]
  00bf4	50		 push	 eax
  00bf5	e8 00 00 00 00	 call	 _cm_util_flush_init

; 1066 : 				return(&pCmd_t->ret_value);

  00bfa	8b 4c 24 54	 mov	 ecx, DWORD PTR _pCmd_t$[esp+224]
  00bfe	83 c4 04	 add	 esp, 4
  00c01	5f		 pop	 edi
  00c02	5e		 pop	 esi
  00c03	5d		 pop	 ebp
  00c04	8d 81 78 33 00
	00		 lea	 eax, DWORD PTR [ecx+13176]
  00c0a	5b		 pop	 ebx

; 1637 : }                       

  00c0b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00c11	c3		 ret	 0
$L71508:

; 1629 : 	output_array[new_ret.output_pos+new_ret.output_offset]='\0';

  00c12	8b 4c 24 30	 mov	 ecx, DWORD PTR _new_ret$[esp+228]
  00c16	8b 44 24 34	 mov	 eax, DWORD PTR _new_ret$[esp+232]
  00c1a	03 c1		 add	 eax, ecx
  00c1c	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR _output_array$[esp+216]
  00c23	5f		 pop	 edi
  00c24	5e		 pop	 esi
  00c25	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1630 : 	
; 1631 : 	ret_value->input_offset=new_ret.input_offset-new_input_diff;	 /* the offsets are the change from the current pos */

  00c29	8b 44 24 24	 mov	 eax, DWORD PTR _new_ret$[esp+216]

; 1632 : 	ret_value->output_offset=new_ret.output_offset; /* so add the values to the callers offsets */

  00c2d	8b 4c 24 2c	 mov	 ecx, DWORD PTR _new_ret$[esp+224]
  00c31	2b c2		 sub	 eax, edx
  00c33	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00c36	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx

; 1633 : #ifdef DEBUG
; 1634 : 	printf("leaving par_process_input\n");
; 1635 : #endif
; 1636 : 	return(ret_value);

  00c39	8b c3		 mov	 eax, ebx
  00c3b	5d		 pop	 ebp
  00c3c	5b		 pop	 ebx

; 1637 : }                       

  00c3d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00c43	c3		 ret	 0
_par_process_input ENDP
_TEXT	ENDS
PUBLIC	_par_print_rule_error
PUBLIC	_par_copy_string_data
PUBLIC	_par_match_string
_DATA	SEGMENT
	ORG $+2
$SG71754 DB	'par_match_rule;end of state slash not found', 00H
_DATA	ENDS
_TEXT	SEGMENT
_input_indexes$ = 24
_output_indexes$ = 28
_match_array$ = 32
_ret_value$ = 36
_dict_state_flag$ = 40
_new_ret$ = -32
_save_state_num$ = -60
_range_value$ = -48
_in_rule_index$ = 36
_length_of_input$ = -56
_insert_operation_flags$ = -52
_end_of_match$ = -64
_current_rule$ = 8
_state$ = 12
_input_array$ = 16
_output_array$ = 20
_par_match_rule PROC NEAR

; 1913 : {

  00c50	83 ec 40	 sub	 esp, 64			; 00000040H
  00c53	53		 push	 ebx

; 1914 : 	
; 1915 : 	//	int end_marker=End_Is_Slash;			/* used to store the end of state marker for comparison */
; 1916 : 	return_value_t	new_ret;				/* the return_value data */
; 1917 : 	int new_operation=BIN_END_OF_RULE;		/* the current_operation */
; 1918 : 	int num_chars_matched=0; 				/* the number of characters matched by par_match_string */
; 1919 : 	int save_state_num=0;					/* the number of the array to save the matching result into or
; 1920 : 											 * the dictionary number */
; 1921 : 	range_value_t range_value = {0,0,0,0};	/* 
; 1922 : 											*	a structure to store the minimum and maximum values of 
; 1923 : 											* 	a digit range find 
; 1924 : 											*/
; 1925 : 	U8 *new_rule;
; 1926 : 	int in_rule_index;
; 1927 : 	int next_rule_number,rule_p,length=0;
; 1928 : 	int length_of_input;
; 1929 : 	int temp;
; 1930 : #ifdef GERMAN_COMPOUND_NOUNS
; 1931 : 	int insert_operation_flags;
; 1932 : #endif
; 1933 : 	U8 end_of_match;
; 1934 : //	U8 end_of_action;
; 1935 : //	U8 end_of_hit;
; 1936 : 											
; 1937 : #ifdef DEBUG
; 1938 : 	printf("entering par_match_rule state=%d\n",state);
; 1939 : #endif
; 1940 : #ifdef SANITY_CHECKING
; 1941 : 	/* check the inputs or bail out at this point */                                      
; 1942 : 	if (ret_value==NULL) /* there was no input structure,  bail and return NULL */
; 1943 : 	{
; 1944 : #ifdef DEBUG
; 1945 : 		printf("leaving par_match_rule ret_value is NULL\n");
; 1946 : #endif
; 1947 : 		return;
; 1948 : 	}	
; 1949 : 	if (current_rule==NULL || input_array==NULL || output_array==NULL || match_array==NULL)
; 1950 : 	{	/* return a failed value */
; 1951 : 		ret_value->value=FATAL_FAIL;
; 1952 : #ifdef DEBUG
; 1953 : 		printf("leaving par_match_rule some input is NULL returning FAIL\n");
; 1954 : #endif
; 1955 : 		return;
; 1956 : 	}
; 1957 : #endif
; 1958 : 	length_of_input=strlen(input_array);

  00c54	8b 5c 24 50	 mov	 ebx, DWORD PTR _input_array$[esp+64]
  00c58	55		 push	 ebp
  00c59	56		 push	 esi
  00c5a	57		 push	 edi
  00c5b	8b fb		 mov	 edi, ebx
  00c5d	83 c9 ff	 or	 ecx, -1
  00c60	33 c0		 xor	 eax, eax
  00c62	33 ed		 xor	 ebp, ebp

; 1959 : 
; 1960 : 	/* update the state information and pointer to ret_value for par_look_ahead */                   
; 1961 : 	new_ret.input_pos=ret_value->input_pos+ret_value->input_offset;	

  00c64	8b 74 24 70	 mov	 esi, DWORD PTR _ret_value$[esp+76]
  00c68	f2 ae		 repne scasb
  00c6a	8b 06		 mov	 eax, DWORD PTR [esi]

; 1962 : 	new_ret.input_offset=0;
; 1963 : 	new_ret.output_pos=ret_value->output_pos+ret_value->output_offset;

  00c6c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00c6f	f7 d1		 not	 ecx
  00c71	49		 dec	 ecx

; 1964 : 	new_ret.output_offset=0;
; 1965 : 	new_ret.value=SUCCESS;
; 1966 : 	/* GL 02/08/1997 set the initial parser_flag */
; 1967 : 	new_ret.parser_flag = ret_value->parser_flag;   
; 1968 : #ifdef NEW_PARSER_FILE_LOADING
; 1969 : 	new_ret.phTTS=ret_value->phTTS;
; 1970 : #endif
; 1971 : 
; 1972 : 	/* 
; 1973 : 	*	NULL_STATE is used for the first call to the par_match_rule function to 
; 1974 : 	*	tell it to go into COPY_STATE and that the end of state marker is a NULL 
; 1975 : 	*/
; 1976 : 	new_ret.rule=in_rule_index=ret_value->rule;
; 1977 : 	if (state==BIN_END_OF_RULE) 	

  00c72	8b 7c 24 58	 mov	 edi, DWORD PTR _state$[esp+76]
  00c76	89 4c 24 18	 mov	 DWORD PTR _length_of_input$[esp+80], ecx
  00c7a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00c7d	03 c1		 add	 eax, ecx
  00c7f	b9 01 00 00 00	 mov	 ecx, 1
  00c84	89 44 24 30	 mov	 DWORD PTR _new_ret$[esp+80], eax
  00c88	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00c8b	03 d0		 add	 edx, eax
  00c8d	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00c90	89 44 24 4c	 mov	 DWORD PTR _new_ret$[esp+108], eax
  00c94	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00c97	85 ff		 test	 edi, edi
  00c99	89 6c 24 14	 mov	 DWORD PTR _save_state_num$[esp+80], ebp
  00c9d	89 6c 24 20	 mov	 DWORD PTR _range_value$[esp+80], ebp
  00ca1	89 6c 24 24	 mov	 DWORD PTR _range_value$[esp+84], ebp
  00ca5	89 6c 24 28	 mov	 DWORD PTR _range_value$[esp+88], ebp
  00ca9	89 6c 24 2c	 mov	 DWORD PTR _range_value$[esp+92], ebp
  00cad	89 6c 24 34	 mov	 DWORD PTR _new_ret$[esp+84], ebp
  00cb1	89 54 24 38	 mov	 DWORD PTR _new_ret$[esp+88], edx
  00cb5	89 6c 24 3c	 mov	 DWORD PTR _new_ret$[esp+92], ebp
  00cb9	89 4c 24 44	 mov	 DWORD PTR _new_ret$[esp+100], ecx
  00cbd	89 44 24 70	 mov	 DWORD PTR _in_rule_index$[esp+76], eax
  00cc1	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
  00cc5	75 31		 jne	 SHORT $L71705

; 1978 : 	{
; 1979 : 		//		state=BIN_COPY;
; 1980 : 		end_of_match=255;

  00cc7	c6 44 24 10 ff	 mov	 BYTE PTR _end_of_match$[esp+80], 255 ; 000000ffH
$L71706:

; 1992 : 	{
; 1993 : 		new_ret.optional=ret_value->optional;

  00ccc	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]

; 1994 : 	}
; 1995 : 	/* 
; 1996 : 	* copy the return value data from the input to the temporary location for the
; 1997 : 	* children of this function to use 
; 1998 : 	*/
; 1999 : 	/*
; 2000 : 	*	if this is in save state the array number has to be retrieved here to 
; 2001 : 	*  know which array to place the data into 
; 2002 : 	*/
; 2003 : 	if (state==BIN_SAVE)

  00ccf	83 ff 17	 cmp	 edi, 23			; 00000017H
  00cd2	89 4c 24 48	 mov	 DWORD PTR _new_ret$[esp+104], ecx

; 2004 : 	{
; 2005 : 		/* get the number from the rule to save the result in */
; 2006 : 		new_ret.rule++;	/* skip the operation */
; 2007 : 		save_state_num=current_rule[new_ret.rule];
; 2008 : 	}
; 2009 : 	if (state==BIN_DICTIONARY)

  00cd6	74 05		 je	 SHORT $L72949
  00cd8	83 ff 1d	 cmp	 edi, 29			; 0000001dH
  00cdb	75 29		 jne	 SHORT $L71709
$L72949:

; 2010 : 	{
; 2011 : 		new_ret.rule++;

  00cdd	8b 44 24 70	 mov	 eax, DWORD PTR _in_rule_index$[esp+76]

; 2012 : 		save_state_num=current_rule[new_ret.rule];

  00ce1	8b 7c 24 54	 mov	 edi, DWORD PTR _current_rule$[esp+76]
  00ce5	40		 inc	 eax
  00ce6	33 c9		 xor	 ecx, ecx
  00ce8	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
  00cec	8a 0c 38	 mov	 cl, BYTE PTR [eax+edi]
  00cef	89 4c 24 14	 mov	 DWORD PTR _save_state_num$[esp+80], ecx

; 2013 : 	}
; 2014 : #ifdef GERMAN_COMPOUND_NOUNS
; 2015 : 	if (state==BIN_INSERT)

  00cf3	e9 2d 01 00 00	 jmp	 $L72928
$L71705:

; 1981 : 	}
; 1982 : 
; 1983 : 	/* set the optional flag if the state is optional */
; 1984 : 	if (state==BIN_OPTIONAL)

  00cf8	83 ff 16	 cmp	 edi, 22			; 00000016H
  00cfb	75 cf		 jne	 SHORT $L71706

; 1985 : 	{                                         
; 1986 : #ifdef DEBUG
; 1987 : 		printf("set optional to 1\n");
; 1988 : #endif
; 1989 : 		new_ret.optional=1;

  00cfd	89 4c 24 48	 mov	 DWORD PTR _new_ret$[esp+104], ecx

; 1990 : 	}     
; 1991 : 	else

  00d01	e9 1f 01 00 00	 jmp	 $L72928
$L71709:

; 2013 : 	}
; 2014 : #ifdef GERMAN_COMPOUND_NOUNS
; 2015 : 	if (state==BIN_INSERT)

  00d06	83 ff 1a	 cmp	 edi, 26			; 0000001aH
  00d09	75 1a		 jne	 SHORT $L71710

; 2016 : 	{
; 2017 : 		insert_operation_flags=current_rule[new_ret.rule];

  00d0b	8b 7c 24 70	 mov	 edi, DWORD PTR _in_rule_index$[esp+76]
  00d0f	8b 5c 24 54	 mov	 ebx, DWORD PTR _current_rule$[esp+76]
  00d13	33 c9		 xor	 ecx, ecx
  00d15	8a 0c 1f	 mov	 cl, BYTE PTR [edi+ebx]

; 2018 : 	}
; 2019 : #endif
; 2020 : 	if (state==BIN_MACRO)

  00d18	8b 5c 24 5c	 mov	 ebx, DWORD PTR _input_array$[esp+76]
  00d1c	89 4c 24 1c	 mov	 DWORD PTR _insert_operation_flags$[esp+80], ecx
  00d20	e9 00 01 00 00	 jmp	 $L72928
$L71710:
  00d25	83 ff 18	 cmp	 edi, 24			; 00000018H
  00d28	0f 85 f2 00 00
	00		 jne	 $L71711

; 2021 : 	{
; 2022 : 		rule_p=new_ret.rule;
; 2023 : 		rule_p++; /* skip state identifier */

  00d2e	8b 54 24 70	 mov	 edx, DWORD PTR _in_rule_index$[esp+76]

; 2024 : 		next_rule_number=get_short(&current_rule[rule_p]);

  00d32	8b 44 24 54	 mov	 eax, DWORD PTR _current_rule$[esp+76]
  00d36	33 c9		 xor	 ecx, ecx
  00d38	8a 6c 10 02	 mov	 ch, BYTE PTR [eax+edx+2]
  00d3c	8d 6a 01	 lea	 ebp, DWORD PTR [edx+1]
  00d3f	8a 0c 28	 mov	 cl, BYTE PTR [eax+ebp]

; 2025 : 		rule_p+=2;

  00d42	83 c5 02	 add	 ebp, 2
  00d45	8b c1		 mov	 eax, ecx

; 2026 : 		
; 2027 : 		new_rule=(&(rule_data_table[rule_index_table[next_rule_number]]));
; 2028 : 		new_ret.rule=0;

  00d47	33 c9		 xor	 ecx, ecx
  00d49	89 4c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ecx
  00d4d	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _rule_index_table[eax*4]
  00d54	05 00 00 00 00	 add	 eax, OFFSET FLAT:_rule_data_table

; 2029 : 		if (new_rule[0] & BIN_NEXT_HIT)	 new_ret.rule+=2;

  00d59	84 08		 test	 BYTE PTR [eax], cl
  00d5b	74 3c		 je	 SHORT $L71719
  00d5d	b9 02 00 00 00	 mov	 ecx, 2
  00d62	89 4c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ecx

; 2030 : 		if (new_rule[0] & BIN_NEXT_MISS)  new_ret.rule+=2;

  00d66	8a 10		 mov	 dl, BYTE PTR [eax]
  00d68	f6 c2 00	 test	 dl, 0
  00d6b	74 2c		 je	 SHORT $L71719
  00d6d	03 c9		 add	 ecx, ecx
  00d6f	89 4c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ecx

; 2031 : 		if (new_rule[0] & BIN_GORET_HIT)  new_ret.rule+=2;

  00d73	8a 10		 mov	 dl, BYTE PTR [eax]
  00d75	f6 c2 00	 test	 dl, 0
  00d78	74 1f		 je	 SHORT $L71719
  00d7a	83 c1 02	 add	 ecx, 2
  00d7d	89 4c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ecx

; 2032 : 		if (new_rule[0] & BIN_GORET_MISS) new_ret.rule+=2;

  00d81	8a 10		 mov	 dl, BYTE PTR [eax]
  00d83	f6 c2 00	 test	 dl, 0
  00d86	74 11		 je	 SHORT $L71719
  00d88	83 c1 02	 add	 ecx, 2
  00d8b	89 4c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ecx

; 2033 : 		if (new_rule[0] & BIN_COPY_HIT) new_ret.rule+=2;

  00d8f	8a 10		 mov	 dl, BYTE PTR [eax]
  00d91	f6 c2 00	 test	 dl, 0
  00d94	74 03		 je	 SHORT $L71719
  00d96	83 c1 02	 add	 ecx, 2
$L71719:

; 2034 : 		new_ret.rule+=12;

  00d99	83 c1 0c	 add	 ecx, 12			; 0000000cH

; 2035 : 		
; 2036 : 		par_match_rule(new_rule,BIN_END_OF_RULE,input_array,output_array,input_indexes,output_indexes,match_array,&new_ret,0);

  00d9c	8d 54 24 30	 lea	 edx, DWORD PTR _new_ret$[esp+80]
  00da0	89 4c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ecx
  00da4	8b 4c 24 6c	 mov	 ecx, DWORD PTR _match_array$[esp+76]
  00da8	6a 00		 push	 0
  00daa	52		 push	 edx
  00dab	8b 54 24 70	 mov	 edx, DWORD PTR _output_indexes$[esp+84]
  00daf	51		 push	 ecx
  00db0	8b 4c 24 70	 mov	 ecx, DWORD PTR _input_indexes$[esp+88]
  00db4	52		 push	 edx
  00db5	8b 54 24 70	 mov	 edx, DWORD PTR _output_array$[esp+92]
  00db9	51		 push	 ecx
  00dba	52		 push	 edx
  00dbb	53		 push	 ebx
  00dbc	6a 00		 push	 0
  00dbe	50		 push	 eax
  00dbf	e8 00 00 00 00	 call	 _par_match_rule

; 2037 : 		/* fixed macro state */
; 2038 : 		new_ret.rule=rule_p;
; 2039 : 		if ((new_ret.input_pos+new_ret.input_offset > length_of_input)) 

  00dc4	8b 4c 24 54	 mov	 ecx, DWORD PTR _new_ret$[esp+116]
  00dc8	8b 54 24 58	 mov	 edx, DWORD PTR _new_ret$[esp+120]
  00dcc	03 d1		 add	 edx, ecx
  00dce	8b 4c 24 3c	 mov	 ecx, DWORD PTR _length_of_input$[esp+116]
  00dd2	83 c4 24	 add	 esp, 36			; 00000024H
  00dd5	8b c5		 mov	 eax, ebp
  00dd7	3b d1		 cmp	 edx, ecx
  00dd9	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
  00ddd	7e 1a		 jle	 SHORT $L71722

; 2040 : 		{
; 2041 : 			if (new_ret.optional==1)

  00ddf	83 7c 24 48 01	 cmp	 DWORD PTR _new_ret$[esp+104], 1
  00de4	0f 85 5a 02 00
	00		 jne	 $L71721

; 2042 : 			{
; 2043 : //				new_ret.optional= -1;
; 2044 : 				ret_value->value=OPT_FAIL;

  00dea	c7 46 14 02 00
	00 00		 mov	 DWORD PTR [esi+20], 2
  00df1	5f		 pop	 edi
  00df2	5e		 pop	 esi
  00df3	5d		 pop	 ebp
  00df4	5b		 pop	 ebx

; 2309 : #ifdef DEBUG
; 2310 : 	printf("leaving par_match_rule success\n");
; 2311 : #endif
; 2312 : }

  00df5	83 c4 40	 add	 esp, 64			; 00000040H
  00df8	c3		 ret	 0
$L71722:

; 2045 : //				ret_value->rule=rule_p;
; 2046 : 				return;
; 2047 : 			}
; 2048 : 			else
; 2049 : 			{
; 2050 : //				new_ret.value=END_OF_STRING;
; 2051 : 				ret_value->value=END_OF_STRING;
; 2052 : 				return;
; 2053 : 			}
; 2054 : 		}
; 2055 : 		if ((new_ret.value==FAIL) && (new_ret.optional))

  00df9	8b 4c 24 44	 mov	 ecx, DWORD PTR _new_ret$[esp+100]
  00dfd	85 c9		 test	 ecx, ecx
  00dff	0f 85 0a 02 00
	00		 jne	 $L72934
  00e05	8b 44 24 48	 mov	 eax, DWORD PTR _new_ret$[esp+104]
  00e09	85 c0		 test	 eax, eax
  00e0b	0f 84 c7 01 00
	00		 je	 $L72933

; 2056 : 		{
; 2057 : //			new_ret.optional= -1;
; 2058 : 			ret_value->value=OPT_FAIL;

  00e11	c7 46 14 02 00
	00 00		 mov	 DWORD PTR [esi+20], 2
  00e18	5f		 pop	 edi
  00e19	5e		 pop	 esi
  00e1a	5d		 pop	 ebp
  00e1b	5b		 pop	 ebx

; 2309 : #ifdef DEBUG
; 2310 : 	printf("leaving par_match_rule success\n");
; 2311 : #endif
; 2312 : }

  00e1c	83 c4 40	 add	 esp, 64			; 00000040H
  00e1f	c3		 ret	 0
$L71711:

; 2059 : //			ret_value->rule=new_ret.rule;
; 2060 : 			return;
; 2061 : 		}                                                                 
; 2062 : 	}
; 2063 : 	else
; 2064 : 	{
; 2065 : 		/* extract the state data */
; 2066 : 		if (state>=BIN_COPY)

  00e20	83 ff 14	 cmp	 edi, 20			; 00000014H
  00e23	7c 59		 jl	 SHORT $L72923
$L72928:

; 2067 : 		{
; 2068 : 			new_ret.rule++;	/* skip the operation */
; 2069 : 			end_of_match=current_rule[new_ret.rule];

  00e25	8b 4c 24 54	 mov	 ecx, DWORD PTR _current_rule$[esp+76]
  00e29	40		 inc	 eax
  00e2a	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
  00e2e	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]

; 2070 : 			new_ret.rule++;

  00e31	40		 inc	 eax
  00e32	88 4c 24 10	 mov	 BYTE PTR _end_of_match$[esp+80], cl

; 2071 : #ifndef GERMAN_COMPOUND_NOUNS
; 2072 : 			if (state>=BIN_REPLACE && state <=BIN_BEFORE)
; 2073 : #else
; 2074 : 			if (state>=BIN_REPLACE && state <=BIN_INSERT)

  00e36	8b 4c 24 58	 mov	 ecx, DWORD PTR _state$[esp+76]
  00e3a	83 f9 19	 cmp	 ecx, 25			; 00000019H
  00e3d	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
  00e41	7c 23		 jl	 SHORT $L71726
  00e43	83 f9 1a	 cmp	 ecx, 26			; 0000001aH
  00e46	7f 1e		 jg	 SHORT $L71726

; 2075 : #endif
; 2076 : 			{
; 2077 : 				new_ret.rule++;
; 2078 : 				if (current_rule[in_rule_index] & BIN_CONDITIONAL_REPLACE)

  00e48	8b 4c 24 70	 mov	 ecx, DWORD PTR _in_rule_index$[esp+76]
  00e4c	8b 7c 24 54	 mov	 edi, DWORD PTR _current_rule$[esp+76]
  00e50	40		 inc	 eax
  00e51	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
  00e55	f6 04 39 80	 test	 BYTE PTR [ecx+edi], 128	; 00000080H
  00e59	74 1f		 je	 SHORT $L72937

; 2079 : 				{
; 2080 : 					new_ret.rule+=current_rule[new_ret.rule];
; 2081 : 					new_ret.rule++; /* add 1 for the conditional number */

  00e5b	33 c9		 xor	 ecx, ecx
  00e5d	8a 0c 38	 mov	 cl, BYTE PTR [eax+edi]
  00e60	8d 44 08 01	 lea	 eax, DWORD PTR [eax+ecx+1]

; 2082 : 				}
; 2083 : 			}
; 2084 : 			else

  00e64	eb 10		 jmp	 SHORT $L72950
$L71726:

; 2085 : 			{
; 2086 : 				if (state==BIN_DICTIONARY)

  00e66	83 f9 1d	 cmp	 ecx, 29			; 0000001dH
  00e69	75 05		 jne	 SHORT $L71729

; 2087 : 				{
; 2088 : 					new_ret.rule+=2;

  00e6b	83 c0 02	 add	 eax, 2

; 2089 : 				}
; 2090 : 				else

  00e6e	eb 06		 jmp	 SHORT $L72950
$L71729:

; 2091 : 				{
; 2092 : 					if (state==BIN_STATUS)

  00e70	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  00e73	75 05		 jne	 SHORT $L72937

; 2093 : 					{
; 2094 : 						new_ret.rule++;

  00e75	40		 inc	 eax
$L72950:
  00e76	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
$L72937:

; 2082 : 				}
; 2083 : 			}
; 2084 : 			else

  00e7a	8b 7c 24 58	 mov	 edi, DWORD PTR _state$[esp+76]
$L72923:

; 2095 : 					}
; 2096 : 				}
; 2097 : 			}
; 2098 : 		}
; 2099 : 		
; 2100 : 		/* 
; 2101 : 		* decide whether the string in the position being processed is another rule 
; 2102 : 		* or if it is a character type or string to be matched.
; 2103 : 		*/
; 2104 : #if 0
; 2105 : 		while ((current_rule[new_ret.rule]!=0) && (new_ret.rule <= end_of_match) && (new_ret.optional!=-1) &&
; 2106 : 			(new_ret.value!=FATAL_FAIL) && (new_ret.value!=FAIL) && (new_ret.value!=END_OF_STRING)) /* && */
; 2107 : #endif
; 2108 : 
; 2109 : 		
; 2110 : 		while ((new_ret.rule <= end_of_match) && ((temp=current_rule[new_ret.rule])!=0) &&  (new_ret.value==SUCCESS))

  00e7e	8b 4c 24 10	 mov	 ecx, DWORD PTR _end_of_match$[esp+80]
  00e82	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00e88	3b c1		 cmp	 eax, ecx
  00e8a	89 4c 24 5c	 mov	 DWORD PTR 16+[esp+76], ecx
  00e8e	0f 8f ca 01 00
	00		 jg	 $L72943
$L71733:
  00e94	8b 7c 24 54	 mov	 edi, DWORD PTR _current_rule$[esp+76]
  00e98	33 c9		 xor	 ecx, ecx
  00e9a	8a 0c 38	 mov	 cl, BYTE PTR [eax+edi]
  00e9d	85 c9		 test	 ecx, ecx
  00e9f	0f 84 f9 00 00
	00		 je	 $L71734
  00ea5	83 7c 24 44 01	 cmp	 DWORD PTR _new_ret$[esp+100], 1
  00eaa	0f 85 ee 00 00
	00		 jne	 $L71734

; 2111 : 			/*(new_ret.input_pos+new_ret.input_offset < (int)strlen(input_array))*/ 	/* slow ?? */
; 2112 : 			/* process all the data in this action state that is before the ending slash */
; 2113 : 		{
; 2114 : 			new_operation=temp & BIN_OPERATION_MASK;

  00eb0	83 e1 1f	 and	 ecx, 31			; 0000001fH

; 2115 : 			if ((new_operation <= BIN_SETS))
; 2116 : 			{
; 2117 : 				num_chars_matched=par_match_string(current_rule,new_operation,input_array,match_array,&new_ret,&range_value,1,0);

  00eb3	6a 00		 push	 0
  00eb5	8b c1		 mov	 eax, ecx
  00eb7	83 f8 13	 cmp	 eax, 19			; 00000013H
  00eba	7f 74		 jg	 SHORT $L71735
  00ebc	8d 54 24 24	 lea	 edx, DWORD PTR _range_value$[esp+84]
  00ec0	6a 01		 push	 1
  00ec2	52		 push	 edx
  00ec3	8b 54 24 78	 mov	 edx, DWORD PTR _match_array$[esp+88]
  00ec7	8d 4c 24 3c	 lea	 ecx, DWORD PTR _new_ret$[esp+92]
  00ecb	51		 push	 ecx
  00ecc	52		 push	 edx
  00ecd	53		 push	 ebx
  00ece	50		 push	 eax
  00ecf	8b 44 24 70	 mov	 eax, DWORD PTR _current_rule$[esp+104]
  00ed3	50		 push	 eax
  00ed4	e8 00 00 00 00	 call	 _par_match_string
  00ed9	8b f8		 mov	 edi, eax
  00edb	83 c4 20	 add	 esp, 32			; 00000020H

; 2118 : 				
; 2119 : 				/* copy matched data to the output string */
; 2120 : 				if (num_chars_matched== -1)

  00ede	83 ff ff	 cmp	 edi, -1
  00ee1	0f 84 c1 00 00
	00		 je	 $L72924

; 2133 : 						return;
; 2134 : 					}
; 2135 : 				}
; 2136 : 				if (num_chars_matched== 0 && new_ret.optional)

  00ee7	85 ff		 test	 edi, edi
  00ee9	75 0c		 jne	 SHORT $L71739
  00eeb	8b 44 24 48	 mov	 eax, DWORD PTR _new_ret$[esp+104]
  00eef	85 c0		 test	 eax, eax
  00ef1	0f 85 67 02 00
	00		 jne	 $L72935
$L71739:

; 2137 : 				{
; 2138 : 					new_ret.value=OPT_FAIL;
; 2139 : 					break;
; 2140 : 				}
; 2141 : #ifdef DEBUG
; 2142 : 				par_print_rule_error("after par_match_string",current_rule,new_ret.rule);
; 2143 : #endif
; 2144 : 				par_copy_string_data(input_array,input_indexes,output_array,output_indexes,num_chars_matched,&new_ret);

  00ef7	8b 54 24 68	 mov	 edx, DWORD PTR _output_indexes$[esp+76]
  00efb	8b 44 24 60	 mov	 eax, DWORD PTR _output_array$[esp+76]
  00eff	8d 4c 24 30	 lea	 ecx, DWORD PTR _new_ret$[esp+80]
  00f03	51		 push	 ecx
  00f04	8b 4c 24 68	 mov	 ecx, DWORD PTR _input_indexes$[esp+80]
  00f08	57		 push	 edi
  00f09	52		 push	 edx
  00f0a	50		 push	 eax
  00f0b	51		 push	 ecx
  00f0c	53		 push	 ebx
  00f0d	e8 00 00 00 00	 call	 _par_copy_string_data

; 2145 : 				/* update new_ret output_offset */
; 2146 : 				new_ret.output_offset+=num_chars_matched;

  00f12	8b 6c 24 54	 mov	 ebp, DWORD PTR _new_ret$[esp+116]

; 2147 : 				new_ret.input_offset+=num_chars_matched; 

  00f16	8b 44 24 4c	 mov	 eax, DWORD PTR _new_ret$[esp+108]
  00f1a	83 c4 18	 add	 esp, 24			; 00000018H
  00f1d	03 ef		 add	 ebp, edi
  00f1f	03 c7		 add	 eax, edi
  00f21	89 6c 24 3c	 mov	 DWORD PTR _new_ret$[esp+92], ebp
  00f25	89 44 24 34	 mov	 DWORD PTR _new_ret$[esp+84], eax

; 2148 : 			}
; 2149 : 			else

  00f29	b8 03 00 00 00	 mov	 eax, 3
  00f2e	eb 39		 jmp	 SHORT $L71743
$L71735:

; 2150 : 			{
; 2151 : 					/* recursively call the par_match_rule function with the new action state */
; 2152 : 				par_match_rule(current_rule,new_operation,input_array,output_array,input_indexes,output_indexes,match_array,&new_ret,0);

  00f30	8b 4c 24 70	 mov	 ecx, DWORD PTR _match_array$[esp+80]
  00f34	8d 54 24 34	 lea	 edx, DWORD PTR _new_ret$[esp+84]
  00f38	52		 push	 edx
  00f39	8b 54 24 70	 mov	 edx, DWORD PTR _output_indexes$[esp+84]
  00f3d	51		 push	 ecx
  00f3e	8b 4c 24 70	 mov	 ecx, DWORD PTR _input_indexes$[esp+88]
  00f42	52		 push	 edx
  00f43	8b 54 24 70	 mov	 edx, DWORD PTR _output_array$[esp+92]
  00f47	51		 push	 ecx
  00f48	52		 push	 edx
  00f49	53		 push	 ebx
  00f4a	50		 push	 eax
  00f4b	8b 44 24 74	 mov	 eax, DWORD PTR _current_rule$[esp+108]
  00f4f	50		 push	 eax
  00f50	e8 00 00 00 00	 call	 _par_match_rule

; 2153 : 				
; 2154 : #ifdef DEBUG
; 2155 : 				par_print_rule_error("after par_match_rule",current_rule,new_ret.rule);
; 2156 : #endif
; 2157 : 				if (new_ret.value==END_OF_STRING)

  00f55	8b 4c 24 68	 mov	 ecx, DWORD PTR _new_ret$[esp+136]
  00f59	b8 03 00 00 00	 mov	 eax, 3
  00f5e	83 c4 24	 add	 esp, 36			; 00000024H
  00f61	3b c8		 cmp	 ecx, eax
  00f63	74 5d		 je	 SHORT $L72926
  00f65	8b 6c 24 3c	 mov	 ebp, DWORD PTR _new_ret$[esp+92]
$L71743:

; 2170 : 						return;
; 2171 : 					}
; 2172 : 				}
; 2173 : 				/* the matched expression should already be in the output buffer */
; 2174 : 			}                              
; 2175 : 			/* processing continues here after a call to either par_match_string() or to par_match_rule() */
; 2176 : 			if ((new_ret.input_pos+new_ret.input_offset > length_of_input)) 

  00f69	8b 4c 24 30	 mov	 ecx, DWORD PTR _new_ret$[esp+80]
  00f6d	8b 54 24 34	 mov	 edx, DWORD PTR _new_ret$[esp+84]
  00f71	03 d1		 add	 edx, ecx
  00f73	8b 4c 24 18	 mov	 ecx, DWORD PTR _length_of_input$[esp+80]
  00f77	3b d1		 cmp	 edx, ecx
  00f79	7e 0f		 jle	 SHORT $L71746

; 2177 : 			{
; 2178 : 				if (new_ret.optional==1)

  00f7b	83 7c 24 48 01	 cmp	 DWORD PTR _new_ret$[esp+104], 1
  00f80	0f 84 dc 01 00
	00		 je	 $L72936

; 2179 : 				{
; 2180 : 					new_ret.value=OPT_FAIL;
; 2181 : 					break;
; 2182 : 				}
; 2183 : 				else
; 2184 : 				{
; 2185 : 					new_ret.value=END_OF_STRING;

  00f86	89 44 24 44	 mov	 DWORD PTR _new_ret$[esp+100], eax
$L71746:

; 2095 : 					}
; 2096 : 				}
; 2097 : 			}
; 2098 : 		}
; 2099 : 		
; 2100 : 		/* 
; 2101 : 		* decide whether the string in the position being processed is another rule 
; 2102 : 		* or if it is a character type or string to be matched.
; 2103 : 		*/
; 2104 : #if 0
; 2105 : 		while ((current_rule[new_ret.rule]!=0) && (new_ret.rule <= end_of_match) && (new_ret.optional!=-1) &&
; 2106 : 			(new_ret.value!=FATAL_FAIL) && (new_ret.value!=FAIL) && (new_ret.value!=END_OF_STRING)) /* && */
; 2107 : #endif
; 2108 : 
; 2109 : 		
; 2110 : 		while ((new_ret.rule <= end_of_match) && ((temp=current_rule[new_ret.rule])!=0) &&  (new_ret.value==SUCCESS))

  00f8a	8b 44 24 40	 mov	 eax, DWORD PTR _new_ret$[esp+96]
  00f8e	8b 4c 24 5c	 mov	 ecx, DWORD PTR 16+[esp+76]

; 2177 : 			{
; 2178 : 				if (new_ret.optional==1)

  00f92	8b 54 24 38	 mov	 edx, DWORD PTR _new_ret$[esp+88]
  00f96	3b c1		 cmp	 eax, ecx
  00f98	0f 8e f6 fe ff
	ff		 jle	 $L71733
$L71734:

; 2186 : 				}
; 2187 : 			}
; 2188 : 		}
; 2189 : 	}
; 2190 : 	/* the end of state slash marker was found or there was a failure in the matching */
; 2191 : 	if (new_ret.value==FAIL)

  00f9e	8b 4c 24 44	 mov	 ecx, DWORD PTR _new_ret$[esp+100]
  00fa2	85 c9		 test	 ecx, ecx
  00fa4	75 73		 jne	 SHORT $L72942
  00fa6	eb 38		 jmp	 SHORT $L72929
$L72924:

; 2121 : 				{
; 2122 : #ifdef DEBUG
; 2123 : 					printf("leaving par_match_rule; end of string reached in string\n");
; 2124 : #endif
; 2125 : 					if (new_ret.optional==1)

  00fa8	83 7c 24 48 01	 cmp	 DWORD PTR _new_ret$[esp+104], 1

; 2126 : 					{
; 2127 : 						new_ret.value=OPT_FAIL;
; 2128 : 						break;

  00fad	0f 84 ab 01 00
	00		 je	 $L72935

; 2129 : 					}
; 2130 : 					else
; 2131 : 					{
; 2132 : 						ret_value->value=END_OF_STRING;                         

  00fb3	c7 46 14 03 00
	00 00		 mov	 DWORD PTR [esi+20], 3
  00fba	5f		 pop	 edi
  00fbb	5e		 pop	 esi
  00fbc	5d		 pop	 ebp
  00fbd	5b		 pop	 ebx

; 2309 : #ifdef DEBUG
; 2310 : 	printf("leaving par_match_rule success\n");
; 2311 : #endif
; 2312 : }

  00fbe	83 c4 40	 add	 esp, 64			; 00000040H
  00fc1	c3		 ret	 0
$L72926:

; 2158 : 				{
; 2159 : #ifdef DEBUG
; 2160 : 					printf("leaving par_match_rule; end of string reached in rule\n");
; 2161 : #endif
; 2162 : 					if (new_ret.optional==1)

  00fc2	83 7c 24 48 01	 cmp	 DWORD PTR _new_ret$[esp+104], 1

; 2163 : 					{
; 2164 : 						new_ret.value=OPT_FAIL;
; 2165 : 						break;

  00fc7	0f 84 91 01 00
	00		 je	 $L72935

; 2166 : 					}
; 2167 : 					else						
; 2168 : 					{
; 2169 : 						ret_value->value=END_OF_STRING;

  00fcd	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00fd0	5f		 pop	 edi
  00fd1	5e		 pop	 esi
  00fd2	5d		 pop	 ebp
  00fd3	5b		 pop	 ebx

; 2309 : #ifdef DEBUG
; 2310 : 	printf("leaving par_match_rule success\n");
; 2311 : #endif
; 2312 : }

  00fd4	83 c4 40	 add	 esp, 64			; 00000040H
  00fd7	c3		 ret	 0
$L72933:

; 2186 : 				}
; 2187 : 			}
; 2188 : 		}
; 2189 : 	}
; 2190 : 	/* the end of state slash marker was found or there was a failure in the matching */
; 2191 : 	if (new_ret.value==FAIL)

  00fd8	8b 6c 24 3c	 mov	 ebp, DWORD PTR _new_ret$[esp+92]
  00fdc	8b 54 24 38	 mov	 edx, DWORD PTR _new_ret$[esp+88]
$L72929:

; 2192 : 	{
; 2193 : 	/* on failure of a rule just send back FAIL. the caller will then send FAIL back to its caller
; 2194 : 	* and so on, until the outer loop is reached with FAIL.  The original ret_value array 
; 2195 : 	* should remain unchanged for the following rules to use 
; 2196 : 		*/
; 2197 : 		ret_value->value=FAIL;

  00fe0	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2198 : #ifdef INDEX_DEBUG2
; 2199 : 		printf("cleared indexes from %d to %d in the output, failure\n",new_ret.output_pos,new_ret.output_pos+new_ret.output_offset);
; 2200 : #endif
; 2201 : 		memset(output_indexes+new_ret.output_pos,0,new_ret.output_offset*sizeof(index_data_t));

  00fe7	8b 74 24 68	 mov	 esi, DWORD PTR _output_indexes$[esp+76]
  00feb	8d 4c 6d 00	 lea	 ecx, DWORD PTR [ebp+ebp*2]
  00fef	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  00ff2	d1 e1		 shl	 ecx, 1
  00ff4	8d 3c 56	 lea	 edi, DWORD PTR [esi+edx*2]
  00ff7	8b d1		 mov	 edx, ecx
  00ff9	33 c0		 xor	 eax, eax
  00ffb	c1 e9 02	 shr	 ecx, 2
  00ffe	f3 ab		 rep stosd
  01000	8b ca		 mov	 ecx, edx
  01002	83 e1 03	 and	 ecx, 3
  01005	f3 aa		 rep stosb
  01007	5f		 pop	 edi
  01008	5e		 pop	 esi
  01009	5d		 pop	 ebp
  0100a	5b		 pop	 ebx

; 2309 : #ifdef DEBUG
; 2310 : 	printf("leaving par_match_rule success\n");
; 2311 : #endif
; 2312 : }

  0100b	83 c4 40	 add	 esp, 64			; 00000040H
  0100e	c3		 ret	 0
$L72934:

; 2202 : #ifdef DEBUG
; 2203 : 		printf("leaving par_match_rule failure of the rule\n");
; 2204 : #endif
; 2205 : 		
; 2206 : 		return;

  0100f	8b 6c 24 3c	 mov	 ebp, DWORD PTR _new_ret$[esp+92]
  01013	8b 54 24 38	 mov	 edx, DWORD PTR _new_ret$[esp+88]
  01017	eb 04		 jmp	 SHORT $L71747
$L72942:
  01019	8b 7c 24 58	 mov	 edi, DWORD PTR _state$[esp+76]
$L71747:

; 2207 : 	}
; 2208 : 	if (new_ret.value==END_OF_STRING)

  0101d	83 7c 24 44 03	 cmp	 DWORD PTR _new_ret$[esp+100], 3
  01022	75 2f		 jne	 SHORT $L71749

; 2209 : 	{
; 2210 : 		/* on finding the end of the string, return END_OF_STRING to the caller */
; 2211 : #ifdef INDEX_DEBUG2
; 2212 : 		printf("cleared indexes from %d to %d in the output, end_of_string\n",new_ret.output_pos,new_ret.output_pos+new_ret.output_offset);
; 2213 : #endif
; 2214 : 		memset(output_indexes+new_ret.output_pos,0,new_ret.output_offset*sizeof(index_data_t));

  01024	8b 7c 24 68	 mov	 edi, DWORD PTR _output_indexes$[esp+76]
  01028	8d 4c 6d 00	 lea	 ecx, DWORD PTR [ebp+ebp*2]
  0102c	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  0102f	33 c0		 xor	 eax, eax
  01031	d1 e1		 shl	 ecx, 1
  01033	8d 3c 57	 lea	 edi, DWORD PTR [edi+edx*2]
  01036	8b d1		 mov	 edx, ecx
  01038	c1 e9 02	 shr	 ecx, 2
  0103b	f3 ab		 rep stosd
  0103d	8b ca		 mov	 ecx, edx
  0103f	83 e1 03	 and	 ecx, 3
  01042	f3 aa		 rep stosb
$L71721:

; 2215 : 		ret_value->value=END_OF_STRING;

  01044	c7 46 14 03 00
	00 00		 mov	 DWORD PTR [esi+20], 3
  0104b	5f		 pop	 edi
  0104c	5e		 pop	 esi
  0104d	5d		 pop	 ebp
  0104e	5b		 pop	 ebx

; 2309 : #ifdef DEBUG
; 2310 : 	printf("leaving par_match_rule success\n");
; 2311 : #endif
; 2312 : }

  0104f	83 c4 40	 add	 esp, 64			; 00000040H
  01052	c3		 ret	 0
$L71749:

; 2216 : #ifdef DEBUG
; 2217 : 		printf("leaving par_match_rule; the end of the string was encountered\n");
; 2218 : #endif
; 2219 : 		return;
; 2220 : 	}
; 2221 : 	
; 2222 : 	/* this should be the ending slash of the state */
; 2223 : 	if (new_ret.value!=OPT_FAIL)

  01053	83 7c 24 44 02	 cmp	 DWORD PTR _new_ret$[esp+100], 2
  01058	0f 84 08 01 00
	00		 je	 $L71751
$L72943:
  0105e	8b 4c 24 10	 mov	 ecx, DWORD PTR _end_of_match$[esp+80]

; 2224 : 	{
; 2225 : 		if ((state!=BIN_END_OF_RULE) && (state!=BIN_MACRO))

  01062	85 ff		 test	 edi, edi
  01064	0f 84 80 00 00
	00		 je	 $L71755
  0106a	83 ff 18	 cmp	 edi, 24			; 00000018H
  0106d	74 2d		 je	 SHORT $L71753

; 2226 : 		{
; 2227 : 			if (new_ret.rule!=(end_of_match+1))

  0106f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  01075	41		 inc	 ecx
  01076	3b c1		 cmp	 eax, ecx
  01078	74 22		 je	 SHORT $L71753

; 2228 : 			{
; 2229 : 				par_print_rule_error("par_match_rule;end of state slash not found",current_rule,new_ret.rule);

  0107a	50		 push	 eax
  0107b	8b 44 24 58	 mov	 eax, DWORD PTR _current_rule$[esp+80]
  0107f	50		 push	 eax
  01080	68 00 00 00 00	 push	 OFFSET FLAT:$SG71754
  01085	e8 00 00 00 00	 call	 _par_print_rule_error
  0108a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2230 : 				ret_value->value=FATAL_FAIL;

  0108d	c7 46 14 04 00
	00 00		 mov	 DWORD PTR [esi+20], 4
  01094	5f		 pop	 edi
  01095	5e		 pop	 esi
  01096	5d		 pop	 ebp
  01097	5b		 pop	 ebx

; 2309 : #ifdef DEBUG
; 2310 : 	printf("leaving par_match_rule success\n");
; 2311 : #endif
; 2312 : }

  01098	83 c4 40	 add	 esp, 64			; 00000040H
  0109b	c3		 ret	 0
$L71753:

; 2231 : 				return;
; 2232 : 			}
; 2233 : 		}
; 2234 : 		/* performing the action of this state */  
; 2235 : #ifdef DEBUG
; 2236 : 		printf("the current output is:%s\n",output_array);
; 2237 : 		printf("output_pos=%d output_offset=%d\n",new_ret.output_pos,new_ret.output_offset);
; 2238 : #endif
; 2239 : 		if (state!=BIN_END_OF_RULE)
; 2240 : 		{
; 2241 : #ifndef GERMAN_COMPOUND_NOUNS
; 2242 : 			(perform_action_funcs[state])(current_rule,input_array,output_array,input_indexes,output_indexes,match_array,&new_ret,&range_value,save_state_num,dict_state_flag,in_rule_index);
; 2243 : #else
; 2244 : 			(perform_action_funcs[state])(current_rule,input_array,output_array,input_indexes,output_indexes,match_array,&new_ret,&range_value,save_state_num,dict_state_flag,in_rule_index,insert_operation_flags);

  0109c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _insert_operation_flags$[esp+80]
  010a0	8b 54 24 70	 mov	 edx, DWORD PTR _in_rule_index$[esp+76]
  010a4	8b 44 24 74	 mov	 eax, DWORD PTR _dict_state_flag$[esp+76]
  010a8	51		 push	 ecx
  010a9	8b 4c 24 18	 mov	 ecx, DWORD PTR _save_state_num$[esp+84]
  010ad	52		 push	 edx
  010ae	50		 push	 eax
  010af	8d 54 24 2c	 lea	 edx, DWORD PTR _range_value$[esp+92]
  010b3	51		 push	 ecx
  010b4	8b 4c 24 7c	 mov	 ecx, DWORD PTR _match_array$[esp+92]
  010b8	8d 44 24 40	 lea	 eax, DWORD PTR _new_ret$[esp+96]
  010bc	52		 push	 edx
  010bd	8b 54 24 7c	 mov	 edx, DWORD PTR _output_indexes$[esp+96]
  010c1	50		 push	 eax
  010c2	8b 44 24 7c	 mov	 eax, DWORD PTR _input_indexes$[esp+100]
  010c6	51		 push	 ecx
  010c7	8b 4c 24 7c	 mov	 ecx, DWORD PTR _output_array$[esp+104]
  010cb	52		 push	 edx
  010cc	8b 54 24 74	 mov	 edx, DWORD PTR _current_rule$[esp+108]
  010d0	50		 push	 eax
  010d1	51		 push	 ecx
  010d2	53		 push	 ebx
  010d3	52		 push	 edx
  010d4	ff 14 bd 00 00
	00 00		 call	 DWORD PTR _perform_action_funcs[edi*4]
  010db	8b 44 24 70	 mov	 eax, DWORD PTR _new_ret$[esp+144]
  010df	8b 6c 24 6c	 mov	 ebp, DWORD PTR _new_ret$[esp+140]
  010e3	8b 54 24 68	 mov	 edx, DWORD PTR _new_ret$[esp+136]
  010e7	83 c4 30	 add	 esp, 48			; 00000030H
$L71755:

; 2245 : #endif
; 2246 : 		}
; 2247 : 
; 2248 : 		//printf("B parser_flag is %d\n",new_ret.parser_flag);
; 2249 : 		/* GL 02/08/1997 set the parser_flag to caller */
; 2250 : 		ret_value->parser_flag = new_ret.parser_flag;

  010ea	8b 4c 24 4c	 mov	 ecx, DWORD PTR _new_ret$[esp+108]
  010ee	89 4e 1c	 mov	 DWORD PTR [esi+28], ecx

; 2251 : 		
; 2252 : 		/* updating ret_value */
; 2253 : 		/* only the value of offset is updated with the change in the offset */
; 2254 : 		/* pos values have the value of what they were at the beginning of the rule matching */
; 2255 : #ifdef DEBUG
; 2256 : 		printf("par_match_rule;the output after the action has been performed\n is %s\n",output_array);
; 2257 : #endif
; 2258 : 		if (new_ret.value==FATAL_FAIL)

  010f1	8b 4c 24 44	 mov	 ecx, DWORD PTR _new_ret$[esp+100]
  010f5	83 f9 04	 cmp	 ecx, 4
  010f8	75 0b		 jne	 SHORT $L71756

; 2259 : 		{
; 2260 : 			ret_value->value=FATAL_FAIL;

  010fa	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  010fd	5f		 pop	 edi
  010fe	5e		 pop	 esi
  010ff	5d		 pop	 ebp
  01100	5b		 pop	 ebx

; 2309 : #ifdef DEBUG
; 2310 : 	printf("leaving par_match_rule success\n");
; 2311 : #endif
; 2312 : }

  01101	83 c4 40	 add	 esp, 64			; 00000040H
  01104	c3		 ret	 0
$L71756:

; 2261 : #ifdef DEBUG
; 2262 : 			printf("leaving par_match_rule fatal failure of the rule\n");
; 2263 : #endif
; 2264 : 			return;
; 2265 : 		}
; 2266 : 		if (new_ret.value==FAIL)

  01105	85 c9		 test	 ecx, ecx
  01107	75 2f		 jne	 SHORT $L71757

; 2267 : 		{
; 2268 : #ifdef INDEX_DEBUG2
; 2269 : 			printf("cleared indexes from %d to %d in the output, fail-fail\n",new_ret.output_pos,new_ret.output_pos+new_ret.output_offset);
; 2270 : #endif
; 2271 : 			memset(output_indexes+new_ret.output_pos,0,new_ret.output_offset*sizeof(index_data_t));

  01109	8b 7c 24 68	 mov	 edi, DWORD PTR _output_indexes$[esp+76]
  0110d	8d 4c 6d 00	 lea	 ecx, DWORD PTR [ebp+ebp*2]
  01111	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  01114	33 c0		 xor	 eax, eax
  01116	d1 e1		 shl	 ecx, 1
  01118	8d 3c 57	 lea	 edi, DWORD PTR [edi+edx*2]
  0111b	8b d1		 mov	 edx, ecx
  0111d	c1 e9 02	 shr	 ecx, 2
  01120	f3 ab		 rep stosd
  01122	8b ca		 mov	 ecx, edx
  01124	83 e1 03	 and	 ecx, 3
  01127	f3 aa		 rep stosb

; 2272 : 			ret_value->value=FAIL;

  01129	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  01130	5f		 pop	 edi
  01131	5e		 pop	 esi
  01132	5d		 pop	 ebp
  01133	5b		 pop	 ebx

; 2309 : #ifdef DEBUG
; 2310 : 	printf("leaving par_match_rule success\n");
; 2311 : #endif
; 2312 : }

  01134	83 c4 40	 add	 esp, 64			; 00000040H
  01137	c3		 ret	 0
$L71757:

; 2273 : #ifdef DEBUG
; 2274 : 			printf("leaving par_match_rule failure of the rule\n");
; 2275 : #endif
; 2276 : 			return;
; 2277 : 
; 2278 : 		}
; 2279 : 		ret_value->value=SUCCESS;
; 2280 : 		/* 
; 2281 : 		*	make the callers return value atructure know how much data was processed 
; 2282 : 		*/
; 2283 : 		/* 	
; 2284 : 		*	these have to be changed with the change in the input value because 
; 2285 : 		*	offsets may have been non zero when the call to this function was made 
; 2286 : 		*/
; 2287 : 		ret_value->input_offset+=new_ret.input_offset;	 /* the offsets are the change from the current pos */

  01138	8b 4c 24 34	 mov	 ecx, DWORD PTR _new_ret$[esp+84]
  0113c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0113f	03 d1		 add	 edx, ecx

; 2288 : 		ret_value->output_offset+=new_ret.output_offset; /* so add the values to the callers offsets */

  01141	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01144	03 cd		 add	 ecx, ebp
  01146	c7 46 14 01 00
	00 00		 mov	 DWORD PTR [esi+20], 1
  0114d	89 56 04	 mov	 DWORD PTR [esi+4], edx
  01150	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx

; 2306 : 	}
; 2307 : 	/* ret_value->rule should be pointing to the character afterh the rule now */
; 2308 : 	ret_value->rule=new_ret.rule;

  01153	89 46 10	 mov	 DWORD PTR [esi+16], eax
  01156	5f		 pop	 edi
  01157	5e		 pop	 esi
  01158	5d		 pop	 ebp
  01159	5b		 pop	 ebx

; 2309 : #ifdef DEBUG
; 2310 : 	printf("leaving par_match_rule success\n");
; 2311 : #endif
; 2312 : }

  0115a	83 c4 40	 add	 esp, 64			; 00000040H
  0115d	c3		 ret	 0
$L72935:

; 2289 : 	}
; 2290 : 	else

  0115e	8b 6c 24 3c	 mov	 ebp, DWORD PTR _new_ret$[esp+92]
$L72936:
  01162	8b 54 24 38	 mov	 edx, DWORD PTR _new_ret$[esp+88]
$L71751:

; 2291 : 	{
; 2292 : #ifdef DEBUG
; 2293 : 		printf("par_match_rule;optional set to OPT_FAIL\n");
; 2294 : #endif
; 2295 : #ifdef INDEX_DEBUG2
; 2296 : 		printf("cleared indexes from %d to %d in the output, opt_fail\n",new_ret.output_pos,new_ret.output_pos+new_ret.output_offset);
; 2297 : #endif
; 2298 : 		memset(output_indexes+new_ret.output_pos,0,new_ret.output_offset*sizeof(index_data_t));

  01166	8b 7c 24 68	 mov	 edi, DWORD PTR _output_indexes$[esp+76]
  0116a	8d 4c 6d 00	 lea	 ecx, DWORD PTR [ebp+ebp*2]
  0116e	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  01171	33 c0		 xor	 eax, eax
  01173	d1 e1		 shl	 ecx, 1
  01175	8d 3c 57	 lea	 edi, DWORD PTR [edi+edx*2]
  01178	8b d1		 mov	 edx, ecx
  0117a	c1 e9 02	 shr	 ecx, 2
  0117d	f3 ab		 rep stosd
  0117f	8b ca		 mov	 ecx, edx
  01181	83 e1 03	 and	 ecx, 3
  01184	f3 aa		 rep stosb

; 2299 : 		if (state==BIN_OPTIONAL)

  01186	83 7c 24 58 16	 cmp	 DWORD PTR _state$[esp+76], 22 ; 00000016H
  0118b	75 1c		 jne	 SHORT $L71761

; 2300 : 		{
; 2301 : 			ret_value->rule=end_of_match+1;

  0118d	8b 44 24 10	 mov	 eax, DWORD PTR _end_of_match$[esp+80]

; 2302 : 			ret_value->value=SUCCESS;

  01191	c7 46 14 01 00
	00 00		 mov	 DWORD PTR [esi+20], 1
  01198	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0119d	5f		 pop	 edi
  0119e	40		 inc	 eax
  0119f	89 46 10	 mov	 DWORD PTR [esi+16], eax
  011a2	5e		 pop	 esi
  011a3	5d		 pop	 ebp
  011a4	5b		 pop	 ebx

; 2309 : #ifdef DEBUG
; 2310 : 	printf("leaving par_match_rule success\n");
; 2311 : #endif
; 2312 : }

  011a5	83 c4 40	 add	 esp, 64			; 00000040H
  011a8	c3		 ret	 0
$L71761:

; 2303 : 			return;
; 2304 : 		}
; 2305 : 		ret_value->value=OPT_FAIL;

  011a9	8b 44 24 40	 mov	 eax, DWORD PTR _new_ret$[esp+96]
  011ad	c7 46 14 02 00
	00 00		 mov	 DWORD PTR [esi+20], 2

; 2306 : 	}
; 2307 : 	/* ret_value->rule should be pointing to the character afterh the rule now */
; 2308 : 	ret_value->rule=new_ret.rule;

  011b4	89 46 10	 mov	 DWORD PTR [esi+16], eax
  011b7	5f		 pop	 edi
  011b8	5e		 pop	 esi
  011b9	5d		 pop	 ebp
  011ba	5b		 pop	 ebx

; 2309 : #ifdef DEBUG
; 2310 : 	printf("leaving par_match_rule success\n");
; 2311 : #endif
; 2312 : }

  011bb	83 c4 40	 add	 esp, 64			; 00000040H
  011be	c3		 ret	 0
_par_match_rule ENDP
_output_array$ = 16
_output_indexes$ = 24
_ret_value$ = 32
_par_delete_string PROC NEAR

; 2517 : 	int	i,j,save_offset=0;
; 2518 : //055	MGS		10/14/1999	BATS#900 Fixed indexing in spanish phone numbers
; 2519 : 	index_data_t temp_index;
; 2520 : #ifdef DEBUG
; 2521 : 	printf("entering par_delete_string\n");
; 2522 : #endif
; 2523 : 	/*
; 2524 : 	*	check the inputs for valid data 
; 2525 : 	*/
; 2526 : #ifdef SANITY_CHECKING
; 2527 : 	if (ret_value==NULL)
; 2528 : 	{
; 2529 : #ifdef DEBUG
; 2530 : 		printf("leaving par_delete_string ret_value is NULL\n");
; 2531 : #endif
; 2532 : 		return;
; 2533 : 	}
; 2534 : 	if ((output_array==NULL))
; 2535 : 	{
; 2536 : 		ret_value->value=FATAL_FAIL;
; 2537 : #ifdef DEBUG
; 2538 : 		printf("leaving par_delete_string input is NULL\n");
; 2539 : #endif
; 2540 : 		return;
; 2541 : 	}                 
; 2542 : #endif
; 2543 : 	//055	MGS		10/14/1999	BATS#900 Fixed indexing in spanish phone numbers
; 2544 : 	save_offset=ret_value->output_offset+ret_value->output_pos;             

  011c0	8b 54 24 1c	 mov	 edx, DWORD PTR _ret_value$[esp-4]
  011c4	53		 push	 ebx

; 2545 : 	/* blank out the data being deleted */
; 2546 : 	memset((output_array+(ret_value->output_pos)),0,ret_value->output_offset);                              

  011c5	8b 5c 24 10	 mov	 ebx, DWORD PTR _output_array$[esp]
  011c9	55		 push	 ebp
  011ca	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  011cd	56		 push	 esi
  011ce	57		 push	 edi
  011cf	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
  011d2	33 c0		 xor	 eax, eax
  011d4	8d 34 0f	 lea	 esi, DWORD PTR [edi+ecx]
  011d7	8b e9		 mov	 ebp, ecx
  011d9	03 fb		 add	 edi, ebx
  011db	c1 e9 02	 shr	 ecx, 2
  011de	f3 ab		 rep stosd
  011e0	8b cd		 mov	 ecx, ebp
  011e2	83 e1 03	 and	 ecx, 3
  011e5	f3 aa		 rep stosb

; 2547 : 	/* set the ouput_offset to 0 to logically delete the data from processing */
; 2548 : 	memset(&temp_index,0,sizeof(temp_index));
; 2549 : 	ret_value->output_offset=0;
; 2550 : 	for (j=i=ret_value->output_pos;i<save_offset;i++)

  011e7	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  011ea	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
  011f1	3b ce		 cmp	 ecx, esi
  011f3	7d 5b		 jge	 SHORT $L71793
  011f5	8b 7c 24 24	 mov	 edi, DWORD PTR _output_indexes$[esp+12]
  011f9	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  011fc	03 d9		 add	 ebx, ecx
  011fe	2b f1		 sub	 esi, ecx
  01200	8d 04 47	 lea	 eax, DWORD PTR [edi+eax*2]
  01203	89 74 24 2c	 mov	 DWORD PTR 32+[esp+12], esi
  01207	8b f8		 mov	 edi, eax
$L71791:

; 2551 : 	{
; 2552 : 		if (par_is_index_set(output_indexes,i))

  01209	66 83 38 00	 cmp	 WORD PTR [eax], 0
  0120d	75 0e		 jne	 SHORT $L72956
  0120f	66 83 78 02 00	 cmp	 WORD PTR [eax+2], 0
  01214	75 07		 jne	 SHORT $L72956
  01216	66 83 78 04 00	 cmp	 WORD PTR [eax+4], 0
  0121b	74 25		 je	 SHORT $L71792
$L72956:

; 2553 : 		{
; 2554 : #ifdef INDEX_DEBUG
; 2555 : 			printf("copying index in delete state from %d to %d\n",i,j);
; 2556 : #endif
; 2557 : 			par_copy_index(output_indexes,j,output_indexes,i);

  0121d	8b c8		 mov	 ecx, eax
  0121f	8b f7		 mov	 esi, edi

; 2558 : 			/* kill the old index */
; 2559 : 			par_copy_index(output_indexes,i,&temp_index,0);
; 2560 : 			output_array[j]=PAR_INDEX_DUMMY_CHAR;
; 2561 : 			j++;

  01221	83 c7 06	 add	 edi, 6
  01224	8b 29		 mov	 ebp, DWORD PTR [ecx]
  01226	89 2e		 mov	 DWORD PTR [esi], ebp
  01228	66 8b 49 04	 mov	 cx, WORD PTR [ecx+4]
  0122c	66 89 4e 04	 mov	 WORD PTR [esi+4], cx
  01230	8b f0		 mov	 esi, eax
  01232	33 c9		 xor	 ecx, ecx
  01234	43		 inc	 ebx
  01235	89 0e		 mov	 DWORD PTR [esi], ecx
  01237	66 89 4e 04	 mov	 WORD PTR [esi+4], cx
  0123b	c6 43 ff 82	 mov	 BYTE PTR [ebx-1], 130	; 00000082H

; 2562 : 			ret_value->output_offset++;

  0123f	ff 42 0c	 inc	 DWORD PTR [edx+12]
$L71792:
  01242	8b 4c 24 2c	 mov	 ecx, DWORD PTR 32+[esp+12]
  01246	83 c0 06	 add	 eax, 6
  01249	49		 dec	 ecx
  0124a	89 4c 24 2c	 mov	 DWORD PTR 32+[esp+12], ecx
  0124e	75 b9		 jne	 SHORT $L71791
$L71793:
  01250	5f		 pop	 edi
  01251	5e		 pop	 esi
  01252	5d		 pop	 ebp
  01253	5b		 pop	 ebx

; 2563 : 		}
; 2564 : 	}
; 2565 : #ifdef DEBUG
; 2566 : 	printf("leaving par_delete_string string deleted\n");
; 2567 : #endif
; 2568 : }

  01254	c3		 ret	 0
_par_delete_string ENDP
_TEXT	ENDS
PUBLIC	_par_build_string_from_rule
_TEXT	SEGMENT
_current_rule$ = 8
_output_array$ = 16
_output_indexes$ = 24
_match_array$ = 28
_ret_value$ = 32
_range_value$ = 36
_in_rule_index$ = 48
_length$ = -708
_buf$ = -700
_temp_index$ = -600
_par_replace_string PROC NEAR

; 2609 : {

  01260	81 ec c4 02 00
	00		 sub	 esp, 708		; 000002c4H

; 2610 : 	int length;
; 2611 : 	int i,j;
; 2612 : 	unsigned char buf[100];
; 2613 : 	index_data_t  temp_index[100];
; 2614 : 	
; 2615 : 	
; 2616 : #if defined (DEBUG) || defined (INDEX_DEBUG)
; 2617 : 	printf("entering par_replace_string\n");
; 2618 : #endif
; 2619 : 	
; 2620 : 	memset(temp_index,0,100*sizeof(index_data_t));
; 2621 : 	/* 
; 2622 : 	*	check the inputs for valid data 
; 2623 : 	*/
; 2624 : #ifdef SANITY_CHECKING
; 2625 : 	if (ret_value==NULL)
; 2626 : 	{
; 2627 : #ifdef DEBUG
; 2628 : 		printf("leaving par_replace_string ret_value is NULL\n");
; 2629 : #endif
; 2630 : 		return;
; 2631 : 	}
; 2632 : 	if ((current_rule==NULL) || (output_array==NULL) || (match_array==NULL))
; 2633 : 	{
; 2634 : 		ret_value->value=FATAL_FAIL;
; 2635 : #ifdef DEBUG
; 2636 : 		printf("leaving par_replace_string inputs are invalid\n");
; 2637 : #endif
; 2638 : 		return;
; 2639 : 	}
; 2640 : #endif
; 2641 : 	/* 
; 2642 : 	*	build the string that is going to replace the current string bounded by
; 2643 : 	*	by output_pos and output_offset
; 2644 : 	*	then just copy the string built (null and all) on top of the current string
; 2645 : 	*/
; 2646 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_REPLACE,&length,in_rule_index);

  01266	8b 94 24 e4 02
	00 00		 mov	 edx, DWORD PTR _range_value$[esp+704]
  0126d	b9 96 00 00 00	 mov	 ecx, 150		; 00000096H
  01272	33 c0		 xor	 eax, eax
  01274	53		 push	 ebx
  01275	56		 push	 esi
  01276	57		 push	 edi
  01277	8b 9c 24 ec 02
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+716]
  0127e	8d 7c 24 78	 lea	 edi, DWORD PTR _temp_index$[esp+720]
  01282	f3 ab		 rep stosd
  01284	8b 84 24 fc 02
	00 00		 mov	 eax, DWORD PTR _in_rule_index$[esp+716]
  0128b	8d 4c 24 0c	 lea	 ecx, DWORD PTR _length$[esp+720]
  0128f	50		 push	 eax
  01290	8b 84 24 ec 02
	00 00		 mov	 eax, DWORD PTR _match_array$[esp+720]
  01297	51		 push	 ecx
  01298	8b 8c 24 e4 02
	00 00		 mov	 ecx, DWORD PTR _output_array$[esp+724]
  0129f	6a 19		 push	 25			; 00000019H
  012a1	52		 push	 edx
  012a2	53		 push	 ebx
  012a3	50		 push	 eax
  012a4	8b 84 24 ec 02
	00 00		 mov	 eax, DWORD PTR _current_rule$[esp+740]
  012ab	8d 54 24 2c	 lea	 edx, DWORD PTR _buf$[esp+744]
  012af	51		 push	 ecx
  012b0	52		 push	 edx
  012b1	50		 push	 eax
  012b2	e8 00 00 00 00	 call	 _par_build_string_from_rule

; 2647 : 		/* have to do something with indexes so they don't appear in the middle of a word */
; 2648 : 	for (j=0,i=ret_value->output_pos;i<ret_value->output_pos+ret_value->output_offset;i++)

  012b7	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  012ba	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  012bd	03 ce		 add	 ecx, esi
  012bf	83 c4 24	 add	 esp, 36			; 00000024H
  012c2	33 c0		 xor	 eax, eax
  012c4	3b f1		 cmp	 esi, ecx
  012c6	7d 7b		 jge	 SHORT $L71828
  012c8	8b bc 24 e4 02
	00 00		 mov	 edi, DWORD PTR _output_indexes$[esp+716]
  012cf	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  012d2	2b ce		 sub	 ecx, esi
  012d4	55		 push	 ebp
  012d5	8d 14 57	 lea	 edx, DWORD PTR [edi+edx*2]
  012d8	8b 7c 24 10	 mov	 edi, DWORD PTR _length$[esp+724]
  012dc	89 4c 24 14	 mov	 DWORD PTR -704+[esp+724], ecx
$L71826:

; 2649 : 	{
; 2650 : 		if (par_is_index_set(output_indexes,i))

  012e0	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  012e4	75 0e		 jne	 SHORT $L72973
  012e6	66 83 7a 02 00	 cmp	 WORD PTR [edx+2], 0
  012eb	75 07		 jne	 SHORT $L72973
  012ed	66 83 7a 04 00	 cmp	 WORD PTR [edx+4], 0
  012f2	74 39		 je	 SHORT $L71827
$L72973:

; 2651 : 		{
; 2652 : 			/* find a space if there is one */
; 2653 : 			for (;j<length && buf[j]!=' ';j++);

  012f4	3b c7		 cmp	 eax, edi
  012f6	7d 10		 jge	 SHORT $L71833
$L71830:
  012f8	80 7c 04 18 20	 cmp	 BYTE PTR _buf$[esp+eax+724], 32 ; 00000020H
  012fd	0f 84 a6 00 00
	00		 je	 $L71832
  01303	40		 inc	 eax
  01304	3b c7		 cmp	 eax, edi
  01306	7c f0		 jl	 SHORT $L71830
$L71833:

; 2665 : 			{
; 2666 : 				/* use the dummy character for the moved index */
; 2667 : 				buf[j]=PAR_INDEX_DUMMY_CHAR;
; 2668 : 				buf[j+1]='\0';     
; 2669 : #ifdef INDEX_DEBUG
; 2670 : 				printf("copying index in replace 2 from %d to buf %d\n",i,j);
; 2671 : #endif
; 2672 : 				par_copy_index(temp_index,j,output_indexes,i);

  01308	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0130b	8b da		 mov	 ebx, edx
  0130d	c6 44 04 18 82	 mov	 BYTE PTR _buf$[esp+eax+724], 130 ; 00000082H
  01312	c6 44 04 19 00	 mov	 BYTE PTR _buf$[esp+eax+725], 0
  01317	8b 2b		 mov	 ebp, DWORD PTR [ebx]
  01319	8d 4c 4c 7c	 lea	 ecx, DWORD PTR _temp_index$[esp+ecx*2+724]

; 2673 : 				j++;

  0131d	40		 inc	 eax

; 2674 : 				length++;

  0131e	47		 inc	 edi
  0131f	66 8b 5b 04	 mov	 bx, WORD PTR [ebx+4]
  01323	89 29		 mov	 DWORD PTR [ecx], ebp
  01325	89 7c 24 10	 mov	 DWORD PTR _length$[esp+724], edi
  01329	66 89 59 04	 mov	 WORD PTR [ecx+4], bx
$L71827:
  0132d	8b 4c 24 14	 mov	 ecx, DWORD PTR -704+[esp+724]
  01331	83 c2 06	 add	 edx, 6
  01334	49		 dec	 ecx
  01335	89 4c 24 14	 mov	 DWORD PTR -704+[esp+724], ecx
  01339	75 a5		 jne	 SHORT $L71826
  0133b	8b 9c 24 f0 02
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+720]
  01342	5d		 pop	 ebp
$L71828:

; 2675 : 			}       
; 2676 : 		}
; 2677 : 	}
; 2678 : 								
; 2679 : 	strcpy((output_array+(ret_value->output_pos)),buf);

  01343	8b 94 24 dc 02
	00 00		 mov	 edx, DWORD PTR _output_array$[esp+716]
  0134a	8d 7c 24 14	 lea	 edi, DWORD PTR _buf$[esp+720]
  0134e	83 c9 ff	 or	 ecx, -1
  01351	33 c0		 xor	 eax, eax
  01353	03 d6		 add	 edx, esi
  01355	f2 ae		 repne scasb
  01357	f7 d1		 not	 ecx
  01359	2b f9		 sub	 edi, ecx
  0135b	8b c1		 mov	 eax, ecx
  0135d	8b f7		 mov	 esi, edi
  0135f	8b fa		 mov	 edi, edx
  01361	c1 e9 02	 shr	 ecx, 2
  01364	f3 a5		 rep movsd
  01366	8b c8		 mov	 ecx, eax
  01368	83 e1 03	 and	 ecx, 3
  0136b	f3 a4		 rep movsb

; 2680 : 	/* copy the indexes too */
; 2681 : 	par_copy_index_list(output_indexes,ret_value->output_pos,temp_index,0,length);

  0136d	8b 44 24 0c	 mov	 eax, DWORD PTR _length$[esp+720]
  01371	8d 74 24 78	 lea	 esi, DWORD PTR _temp_index$[esp+720]
  01375	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  01378	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0137b	d1 e1		 shl	 ecx, 1
  0137d	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  01380	8b 84 24 e4 02
	00 00		 mov	 eax, DWORD PTR _output_indexes$[esp+716]
  01387	8d 3c 50	 lea	 edi, DWORD PTR [eax+edx*2]
  0138a	8b d1		 mov	 edx, ecx
  0138c	c1 e9 02	 shr	 ecx, 2
  0138f	f3 a5		 rep movsd
  01391	8b ca		 mov	 ecx, edx
  01393	83 e1 03	 and	 ecx, 3
  01396	f3 a4		 rep movsb

; 2682 : 	/* 
; 2683 : 	* the output offset is now the length of of the new output string 
; 2684 : 	*/
; 2685 : #ifdef DEBUG
; 2686 : 	printf("par_replace_string; length=%d\n",length);
; 2687 : #endif	
; 2688 : 	ret_value->output_offset=length;

  01398	8b 44 24 0c	 mov	 eax, DWORD PTR _length$[esp+720]
  0139c	5f		 pop	 edi
  0139d	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  013a0	5e		 pop	 esi
  013a1	5b		 pop	 ebx

; 2689 : 	//	ret_value->rule++;
; 2690 : #ifdef DEBUG
; 2691 : 	printf("leaving replace_state replacement is successful\n");
; 2692 : #endif
; 2693 : }

  013a2	81 c4 c4 02 00
	00		 add	 esp, 708		; 000002c4H
  013a8	c3		 ret	 0
$L71832:

; 2654 : 			if (j<length)

  013a9	3b c7		 cmp	 eax, edi
  013ab	0f 8d 57 ff ff
	ff		 jge	 $L71833

; 2655 : 			{
; 2656 : #ifdef INDEX_DEBUG
; 2657 : 				printf("copying index in replace 1 from %d to buf %d\n",i,j);
; 2658 : #endif
; 2659 : 				par_copy_index(temp_index,j,output_indexes,i);

  013b1	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  013b4	8b da		 mov	 ebx, edx

; 2660 : 				//055	MGS		10/14/1999	BATS#900 Fixed indexing in spanish phone numbers
; 2661 : 				buf[j]=PAR_INDEX_DUMMY_CHAR;
; 2662 : 				j++;

  013b6	40		 inc	 eax
  013b7	8b 2b		 mov	 ebp, DWORD PTR [ebx]
  013b9	8d 4c 4c 7c	 lea	 ecx, DWORD PTR _temp_index$[esp+ecx*2+724]
  013bd	66 8b 5b 04	 mov	 bx, WORD PTR [ebx+4]
  013c1	89 29		 mov	 DWORD PTR [ecx], ebp
  013c3	c6 44 04 17 82	 mov	 BYTE PTR _buf$[esp+eax+723], 130 ; 00000082H
  013c8	66 89 59 04	 mov	 WORD PTR [ecx+4], bx

; 2663 : 			}
; 2664 : 			else

  013cc	e9 5c ff ff ff	 jmp	 $L71827
_par_replace_string ENDP
_TEXT	ENDS
PUBLIC	_par_break_down_word
EXTRN	_noun_num_character_in_mapping:DWORD
_TEXT	SEGMENT
_output_array$ = 16
_ret_value$ = 32
_new_input$ = -200
_new_output$ = -100
_par_compound_break PROC NEAR

; 2709 : 	int num_matched;
; 2710 : 	char new_input[100];
; 2711 : 	char new_output[100];
; 2712 : 
; 2713 : #ifdef DEBUG
; 2714 : 	printf("entering par_compound_break\n");
; 2715 : #endif
; 2716 : 
; 2717 : 	if (noun_num_character_in_mapping==0)

  013e0	a1 00 00 00 00	 mov	 eax, DWORD PTR _noun_num_character_in_mapping
  013e5	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  013eb	85 c0		 test	 eax, eax
  013ed	53		 push	 ebx
  013ee	55		 push	 ebp
  013ef	56		 push	 esi
  013f0	57		 push	 edi
  013f1	0f 84 93 00 00
	00		 je	 $L71866

; 2718 : 	{
; 2719 : #ifdef DEBUG
; 2720 : 		printf("leaving par_compound_break, no table loaded\n");
; 2721 : #endif
; 2722 : 		return;
; 2723 : 	}
; 2724 : 
; 2725 : 	memcpy(new_input,output_array+ret_value->output_pos,ret_value->output_offset);

  013f7	8b ac 24 f4 00
	00 00		 mov	 ebp, DWORD PTR _ret_value$[esp+212]
  013fe	8b 9c 24 e4 00
	00 00		 mov	 ebx, DWORD PTR _output_array$[esp+212]
  01405	8b f3		 mov	 esi, ebx
  01407	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
  0140a	8b 7d 08	 mov	 edi, DWORD PTR [ebp+8]
  0140d	8b c8		 mov	 ecx, eax
  0140f	03 f7		 add	 esi, edi
  01411	8b d1		 mov	 edx, ecx
  01413	8d 7c 24 10	 lea	 edi, DWORD PTR _new_input$[esp+216]
  01417	c1 e9 02	 shr	 ecx, 2
  0141a	f3 a5		 rep movsd
  0141c	8b ca		 mov	 ecx, edx
  0141e	83 e1 03	 and	 ecx, 3
  01421	f3 a4		 rep movsb

; 2726 : 	new_input[ret_value->output_offset]='\0';

  01423	c6 44 04 10 00	 mov	 BYTE PTR _new_input$[esp+eax+216], 0

; 2727 : 	memset(new_output,0,100);

  01428	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  0142d	33 c0		 xor	 eax, eax
  0142f	8d 7c 24 74	 lea	 edi, DWORD PTR _new_output$[esp+216]
  01433	f3 ab		 rep stosd

; 2728 : 
; 2729 : 	num_matched=par_break_down_word(new_input,new_output);

  01435	8d 44 24 74	 lea	 eax, DWORD PTR _new_output$[esp+216]
  01439	8d 4c 24 10	 lea	 ecx, DWORD PTR _new_input$[esp+216]
  0143d	50		 push	 eax
  0143e	51		 push	 ecx
  0143f	e8 00 00 00 00	 call	 _par_break_down_word
  01444	83 c4 08	 add	 esp, 8

; 2730 : 
; 2731 : 	if (num_matched>0)

  01447	85 c0		 test	 eax, eax
  01449	7e 29		 jle	 SHORT $L71864

; 2732 : 	{
; 2733 : 		memcpy(output_array+ret_value->output_pos,new_output,num_matched);

  0144b	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  0144e	8b fb		 mov	 edi, ebx
  01450	8b c8		 mov	 ecx, eax
  01452	03 fa		 add	 edi, edx
  01454	8b d1		 mov	 edx, ecx
  01456	8d 74 24 74	 lea	 esi, DWORD PTR _new_output$[esp+216]
  0145a	c1 e9 02	 shr	 ecx, 2
  0145d	f3 a5		 rep movsd
  0145f	8b ca		 mov	 ecx, edx
  01461	83 e1 03	 and	 ecx, 3
  01464	f3 a4		 rep movsb
  01466	5f		 pop	 edi

; 2734 : 		ret_value->output_offset=num_matched;

  01467	89 45 0c	 mov	 DWORD PTR [ebp+12], eax
  0146a	5e		 pop	 esi
  0146b	5d		 pop	 ebp
  0146c	5b		 pop	 ebx

; 2747 : 		}
; 2748 : 	}
; 2749 : 
; 2750 : #ifdef DEBUG
; 2751 : 	printf("leaving par_compound_break\n");
; 2752 : #endif
; 2753 : 
; 2754 : 	/* rewrite the word breaker code and the word finder code */
; 2755 : 	/* the word breaker should return the number of characters
; 2756 : 	   that are in the output if successful, or -1 if failed */
; 2757 : 	/* create a new header file for the structure used in here */
; 2758 : 
; 2759 : 
; 2760 : 	/* write a file loader */
; 2761 : 	/* the file loader has to be load the file for german, and not for any other language */
; 2762 : 	/* the file loader has to globally allocate the memory, and the other threads
; 2763 : 	   have to use it */
; 2764 : }

  0146d	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  01473	c3		 ret	 0
$L71864:

; 2735 : 	}
; 2736 : 	else
; 2737 : 	{
; 2738 : 
; 2739 : 		ret_value->value=FAIL;
; 2740 : 
; 2741 : 		if (ret_value->optional==1)

  01474	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  01477	c7 45 14 00 00
	00 00		 mov	 DWORD PTR [ebp+20], 0
  0147e	83 f8 01	 cmp	 eax, 1
  01481	75 07		 jne	 SHORT $L71866

; 2742 : 		{
; 2743 : #ifdef DEBUG
; 2744 : 			printf("set optional to opt_fail\n");
; 2745 : #endif
; 2746 : 			ret_value->value=OPT_FAIL;

  01483	c7 45 14 02 00
	00 00		 mov	 DWORD PTR [ebp+20], 2
$L71866:
  0148a	5f		 pop	 edi
  0148b	5e		 pop	 esi
  0148c	5d		 pop	 ebp
  0148d	5b		 pop	 ebx

; 2747 : 		}
; 2748 : 	}
; 2749 : 
; 2750 : #ifdef DEBUG
; 2751 : 	printf("leaving par_compound_break\n");
; 2752 : #endif
; 2753 : 
; 2754 : 	/* rewrite the word breaker code and the word finder code */
; 2755 : 	/* the word breaker should return the number of characters
; 2756 : 	   that are in the output if successful, or -1 if failed */
; 2757 : 	/* create a new header file for the structure used in here */
; 2758 : 
; 2759 : 
; 2760 : 	/* write a file loader */
; 2761 : 	/* the file loader has to be load the file for german, and not for any other language */
; 2762 : 	/* the file loader has to globally allocate the memory, and the other threads
; 2763 : 	   have to use it */
; 2764 : }

  0148e	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  01494	c3		 ret	 0
_par_compound_break ENDP
_TEXT	ENDS
PUBLIC	_par_find_word_in_dict
EXTRN	_par_upper:BYTE
EXTRN	_noun_number_of_conjunctions:DWORD
EXTRN	_noun_conjunction:BYTE
_TEXT	SEGMENT
_input$ = 8
_output$ = 12
_i$ = -56
_j$ = 12
_number_of_pos$ = -48
_positions$ = -40
_par_break_down_word PROC NEAR

; 2767 : {

  014a0	83 ec 38	 sub	 esp, 56			; 00000038H

; 2768 : 	int i,j;
; 2769 : 	int head=1;
; 2770 : 	int number_of_pos=0;
; 2771 : 	int positions[10];
; 2772 : 	int result;
; 2773 : 
; 2774 : #ifdef DEBUG
; 2775 : 	printf("entering par_break_down_word %s\n",input);
; 2776 : #endif
; 2777 : 	result=par_find_word_in_dict(head,input,positions,0,&number_of_pos);

  014a3	8b 54 24 3c	 mov	 edx, DWORD PTR _input$[esp+52]
  014a7	53		 push	 ebx
  014a8	55		 push	 ebp
  014a9	56		 push	 esi
  014aa	8d 44 24 14	 lea	 eax, DWORD PTR _number_of_pos$[esp+68]
  014ae	57		 push	 edi
  014af	50		 push	 eax
  014b0	8d 4c 24 24	 lea	 ecx, DWORD PTR _positions$[esp+76]
  014b4	6a 00		 push	 0
  014b6	51		 push	 ecx
  014b7	52		 push	 edx
  014b8	6a 01		 push	 1
  014ba	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _number_of_pos$[esp+92], 0
  014c2	e8 00 00 00 00	 call	 _par_find_word_in_dict
  014c7	83 c4 14	 add	 esp, 20			; 00000014H

; 2778 : 	if (result==0)

  014ca	85 c0		 test	 eax, eax

; 2779 : 	{
; 2780 : #ifdef DEBUG
; 2781 : 		printf("leaving par_break_down_word no matches\n");
; 2782 : #endif
; 2783 : 		return(-1);

  014cc	0f 84 07 01 00
	00		 je	 $L71881

; 2784 : 	}
; 2785 : 	for (i=number_of_pos-1;i>=0;i--)

  014d2	8b 44 24 18	 mov	 eax, DWORD PTR _number_of_pos$[esp+72]
  014d6	48		 dec	 eax
  014d7	85 c0		 test	 eax, eax
  014d9	89 44 24 10	 mov	 DWORD PTR _i$[esp+72], eax
  014dd	0f 8c f6 00 00
	00		 jl	 $L71881
  014e3	8b 6c 24 50	 mov	 ebp, DWORD PTR _output$[esp+68]
  014e7	8d 5c 84 20	 lea	 ebx, DWORD PTR _positions$[esp+eax*4+72]
  014eb	89 5c 24 14	 mov	 DWORD PTR -52+[esp+72], ebx
$L71879:

; 2786 : 	{
; 2787 : 		memcpy(output,input,positions[i]);

  014ef	8b 03		 mov	 eax, DWORD PTR [ebx]
  014f1	8b 74 24 4c	 mov	 esi, DWORD PTR _input$[esp+68]
  014f5	8b c8		 mov	 ecx, eax
  014f7	8b fd		 mov	 edi, ebp
  014f9	8b d1		 mov	 edx, ecx
  014fb	c1 e9 02	 shr	 ecx, 2
  014fe	f3 a5		 rep movsd
  01500	8b ca		 mov	 ecx, edx
  01502	83 e1 03	 and	 ecx, 3
  01505	f3 a4		 rep movsb

; 2788 : 		/* MGS make the first character of the new word uppercase */
; 2789 : 		output[0]=par_upper[output[0]];

  01507	33 c9		 xor	 ecx, ecx

; 2790 : 		output[positions[i]]='\0';
; 2791 : 		output[positions[i]+1]='\0';
; 2792 : 		if (input[positions[i]]=='\0')

  01509	8b 7c 24 4c	 mov	 edi, DWORD PTR _input$[esp+68]
  0150d	8a 4d 00	 mov	 cl, BYTE PTR [ebp]
  01510	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR _par_upper[ecx]
  01516	88 55 00	 mov	 BYTE PTR [ebp], dl
  01519	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
  0151d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0151f	c6 44 28 01 00	 mov	 BYTE PTR [eax+ebp+1], 0
  01524	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  01526	80 3c 39 00	 cmp	 BYTE PTR [ecx+edi], 0
  0152a	0f 84 b4 00 00
	00		 je	 $L72998

; 2795 : 		}
; 2796 : 		if (noun_number_of_conjunctions>0)

  01530	a1 00 00 00 00	 mov	 eax, DWORD PTR _noun_number_of_conjunctions
  01535	85 c0		 test	 eax, eax
  01537	0f 8e 84 00 00
	00		 jle	 $L71880

; 2797 : 		{
; 2798 : 			for (j=0;j<noun_number_of_conjunctions;j++)

  0153d	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_noun_conjunction
  01542	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR _j$[esp+68], 0
  0154a	89 74 24 1c	 mov	 DWORD PTR -44+[esp+72], esi
  0154e	eb 04		 jmp	 SHORT $L71884
$L73005:
  01550	8b 7c 24 4c	 mov	 edi, DWORD PTR _input$[esp+68]
$L71884:

; 2799 : 			{
; 2800 : 				if (noun_conjunction[j].length==0)

  01554	8b 06		 mov	 eax, DWORD PTR [esi]
  01556	85 c0		 test	 eax, eax
  01558	75 1c		 jne	 SHORT $L71887

; 2801 : 				{
; 2802 : 					result=par_break_down_word(input+positions[i],output+positions[i]+1);

  0155a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0155c	8d 54 28 01	 lea	 edx, DWORD PTR [eax+ebp+1]
  01560	03 c7		 add	 eax, edi
  01562	52		 push	 edx
  01563	50		 push	 eax
  01564	e8 00 00 00 00	 call	 _par_break_down_word
  01569	83 c4 08	 add	 esp, 8

; 2803 : 					if (result>0)

  0156c	85 c0		 test	 eax, eax
  0156e	0f 8f 80 00 00
	00		 jg	 $L72996

; 2810 : 					}
; 2811 : 				}
; 2812 : 				else

  01574	eb 2d		 jmp	 SHORT $L71885
$L71887:

; 2813 : 				{
; 2814 : 					if (memcmp(noun_conjunction[j].conj,input+positions[i],noun_conjunction[j].length)==0)

  01576	8b 13		 mov	 edx, DWORD PTR [ebx]
  01578	83 c6 04	 add	 esi, 4
  0157b	03 fa		 add	 edi, edx
  0157d	8b c8		 mov	 ecx, eax
  0157f	33 db		 xor	 ebx, ebx
  01581	f3 a6		 repe cmpsb
  01583	75 1a		 jne	 SHORT $L73002

; 2815 : 					{
; 2816 : 						result=par_break_down_word(input+positions[i]+noun_conjunction[j].length,output+positions[i]+noun_conjunction[j].length+1);

  01585	03 c2		 add	 eax, edx
  01587	8b 54 24 4c	 mov	 edx, DWORD PTR _input$[esp+68]
  0158b	8d 4c 28 01	 lea	 ecx, DWORD PTR [eax+ebp+1]
  0158f	03 c2		 add	 eax, edx
  01591	51		 push	 ecx
  01592	50		 push	 eax
  01593	e8 00 00 00 00	 call	 _par_break_down_word
  01598	83 c4 08	 add	 esp, 8

; 2817 : 						if (result>0)

  0159b	85 c0		 test	 eax, eax
  0159d	7f 73		 jg	 SHORT $L72997
$L73002:
  0159f	8b 5c 24 14	 mov	 ebx, DWORD PTR -52+[esp+72]
$L71885:

; 2797 : 		{
; 2798 : 			for (j=0;j<noun_number_of_conjunctions;j++)

  015a3	8b 44 24 50	 mov	 eax, DWORD PTR _j$[esp+68]
  015a7	8b 74 24 1c	 mov	 esi, DWORD PTR -44+[esp+72]
  015ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _noun_number_of_conjunctions
  015b1	40		 inc	 eax
  015b2	83 c6 08	 add	 esi, 8
  015b5	3b c1		 cmp	 eax, ecx
  015b7	89 44 24 50	 mov	 DWORD PTR _j$[esp+68], eax
  015bb	89 74 24 1c	 mov	 DWORD PTR -44+[esp+72], esi
  015bf	7c 8f		 jl	 SHORT $L73005
$L71880:

; 2784 : 	}
; 2785 : 	for (i=number_of_pos-1;i>=0;i--)

  015c1	8b 44 24 10	 mov	 eax, DWORD PTR _i$[esp+72]
  015c5	83 eb 04	 sub	 ebx, 4
  015c8	48		 dec	 eax
  015c9	89 5c 24 14	 mov	 DWORD PTR -52+[esp+72], ebx
  015cd	85 c0		 test	 eax, eax
  015cf	89 44 24 10	 mov	 DWORD PTR _i$[esp+72], eax
  015d3	0f 8d 16 ff ff
	ff		 jge	 $L71879
$L71881:
  015d9	5f		 pop	 edi
  015da	5e		 pop	 esi
  015db	5d		 pop	 ebp

; 2826 : 						}
; 2827 : 					}
; 2828 : 				}
; 2829 : 			}
; 2830 : 		}
; 2831 : 		/* insert code for connecting characters here */
; 2832 : 		/* remove the connections in reverse order from longest to shortest */
; 2833 : 	}
; 2834 : #ifdef DEBUG
; 2835 : 	printf("leaving par_break_down_word failure %s %s\n",input,output);
; 2836 : #endif
; 2837 : 	return(-1);

  015dc	83 c8 ff	 or	 eax, -1
  015df	5b		 pop	 ebx

; 2838 : 
; 2839 : }

  015e0	83 c4 38	 add	 esp, 56			; 00000038H
  015e3	c3		 ret	 0
$L72998:

; 2793 : 		{
; 2794 : 			return(positions[i]);

  015e4	8b 44 24 10	 mov	 eax, DWORD PTR _i$[esp+72]
  015e8	5f		 pop	 edi
  015e9	5e		 pop	 esi
  015ea	5d		 pop	 ebp
  015eb	8b 44 84 14	 mov	 eax, DWORD PTR _positions$[esp+eax*4+60]
  015ef	5b		 pop	 ebx

; 2838 : 
; 2839 : }

  015f0	83 c4 38	 add	 esp, 56			; 00000038H
  015f3	c3		 ret	 0
$L72996:

; 2804 : 					{
; 2805 : 						output[positions[i]]='-';

  015f4	8b 4c 24 10	 mov	 ecx, DWORD PTR _i$[esp+72]
  015f8	5f		 pop	 edi
  015f9	5e		 pop	 esi
  015fa	8b 54 8c 18	 mov	 edx, DWORD PTR _positions$[esp+ecx*4+64]
  015fe	8d 4c 8c 18	 lea	 ecx, DWORD PTR _positions$[esp+ecx*4+64]
  01602	c6 04 2a 2d	 mov	 BYTE PTR [edx+ebp], 45	; 0000002dH

; 2806 : #ifdef DEBUG
; 2807 : 						printf("leaving par_break_down_word no conj %s %s %d\n",input,output,result+positions[i]+1);
; 2808 : #endif
; 2809 : 						return(result+positions[i]+1);

  01606	8b 09		 mov	 ecx, DWORD PTR [ecx]
  01608	5d		 pop	 ebp
  01609	5b		 pop	 ebx
  0160a	8d 44 08 01	 lea	 eax, DWORD PTR [eax+ecx+1]

; 2838 : 
; 2839 : }

  0160e	83 c4 38	 add	 esp, 56			; 00000038H
  01611	c3		 ret	 0
$L72997:

; 2818 : 						{
; 2819 : 							memcpy(output+positions[i],noun_conjunction[j].conj,noun_conjunction[j].length);

  01612	8b 74 24 50	 mov	 esi, DWORD PTR _j$[esp+68]
  01616	8b 4c 24 10	 mov	 ecx, DWORD PTR _i$[esp+72]
  0161a	8b fd		 mov	 edi, ebp
  0161c	03 7c 8c 20	 add	 edi, DWORD PTR _positions$[esp+ecx*4+72]
  01620	8d 14 f5 00 00
	00 00		 lea	 edx, DWORD PTR _noun_conjunction[esi*8]
  01627	8d 5c 8c 20	 lea	 ebx, DWORD PTR _positions$[esp+ecx*4+72]
  0162b	8d 34 f5 04 00
	00 00		 lea	 esi, DWORD PTR _noun_conjunction[esi*8+4]
  01632	8b 0a		 mov	 ecx, DWORD PTR [edx]
  01634	89 5c 24 4c	 mov	 DWORD PTR 8+[esp+68], ebx
  01638	8b d9		 mov	 ebx, ecx
  0163a	c1 e9 02	 shr	 ecx, 2
  0163d	f3 a5		 rep movsd
  0163f	8b cb		 mov	 ecx, ebx
  01641	83 e1 03	 and	 ecx, 3
  01644	f3 a4		 rep movsb

; 2820 : 							output[positions[i]+noun_conjunction[j].length]='-';

  01646	8b 4c 24 4c	 mov	 ecx, DWORD PTR 8+[esp+68]
  0164a	8b 3a		 mov	 edi, DWORD PTR [edx]
  0164c	03 ef		 add	 ebp, edi
  0164e	5f		 pop	 edi
  0164f	8b 31		 mov	 esi, DWORD PTR [ecx]
  01651	c6 04 2e 2d	 mov	 BYTE PTR [esi+ebp], 45	; 0000002dH

; 2821 : 
; 2822 : #ifdef DEBUG
; 2823 : 							printf("leaving par_break_down_word conj %s %s %d\n",input,output,result+positions[i]+1);
; 2824 : #endif
; 2825 : 							return(result+positions[i]+noun_conjunction[j].length+1);

  01655	8b 32		 mov	 esi, DWORD PTR [edx]
  01657	8b 11		 mov	 edx, DWORD PTR [ecx]
  01659	03 c6		 add	 eax, esi
  0165b	5e		 pop	 esi
  0165c	5d		 pop	 ebp
  0165d	8d 44 10 01	 lea	 eax, DWORD PTR [eax+edx+1]
  01661	5b		 pop	 ebx

; 2838 : 
; 2839 : }

  01662	83 c4 38	 add	 esp, 56			; 00000038H
  01665	c3		 ret	 0
_par_break_down_word ENDP
_TEXT	ENDS
EXTRN	_noun_character_mapping_table:BYTE
EXTRN	_noun_index_table:BYTE
EXTRN	_noun_data_table:BYTE
_TEXT	SEGMENT
_head$ = 8
_word$ = 12
_positions$ = 16
_depth$ = 20
_num_pos$ = 24
_par_find_word_in_dict PROC NEAR

; 2843 : 	//removed unused vairable 
; 2844 : 	//int i;
; 2845 : 	comp_noun_table_entry *cur;
; 2846 : 	if (head==NOUN_UNUSED_ENTRY)

  01670	8b 44 24 04	 mov	 eax, DWORD PTR _head$[esp-4]
  01674	8b 54 24 14	 mov	 edx, DWORD PTR _num_pos$[esp-4]
  01678	53		 push	 ebx
  01679	55		 push	 ebp
  0167a	56		 push	 esi
  0167b	83 f8 ff	 cmp	 eax, -1
  0167e	57		 push	 edi
  0167f	74 5c		 je	 SHORT $L73010
  01681	8b 6c 24 20	 mov	 ebp, DWORD PTR _depth$[esp+12]
  01685	8b 74 24 18	 mov	 esi, DWORD PTR _word$[esp+12]
$L73007:

; 2847 : 	{
; 2848 : 		if (*num_pos>0)
; 2849 : 		{
; 2850 : 			return(1);
; 2851 : 		}
; 2852 : 		else
; 2853 : 		{
; 2854 : 			return(0);
; 2855 : 		}
; 2856 : 	}
; 2857 : 	if (head==0)

  01689	85 c0		 test	 eax, eax
  0168b	74 5e		 je	 SHORT $L73011

; 2862 : 	}
; 2863 : 	cur= (comp_noun_table_entry *)(&(noun_data_table[noun_index_table[head]]));

  0168d	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _noun_index_table[eax*4]
  01694	05 00 00 00 00	 add	 eax, OFFSET FLAT:_noun_data_table

; 2864 : 	if (cur->word_ending & 1)

  01699	f6 00 01	 test	 BYTE PTR [eax], 1
  0169c	74 0e		 je	 SHORT $L71909

; 2865 : 	{
; 2866 : 		positions[*num_pos]=depth;

  0169e	8b 0a		 mov	 ecx, DWORD PTR [edx]
  016a0	8b 7c 24 1c	 mov	 edi, DWORD PTR _positions$[esp+12]
  016a4	89 2c 8f	 mov	 DWORD PTR [edi+ecx*4], ebp

; 2867 : 		(*num_pos)++;

  016a7	8b 0a		 mov	 ecx, DWORD PTR [edx]
  016a9	41		 inc	 ecx
  016aa	89 0a		 mov	 DWORD PTR [edx], ecx
$L71909:

; 2868 : 	}
; 2869 : 	if (cur->word_ending & 2)

  016ac	f6 00 02	 test	 BYTE PTR [eax], 2
  016af	75 52		 jne	 SHORT $L73012

; 2876 : 		}
; 2877 : 		else
; 2878 : 		{
; 2879 : 			if (*num_pos>0)
; 2880 : 			{
; 2881 : 				return(1);
; 2882 : 			}
; 2883 : 			else
; 2884 : 			{
; 2885 : 				return(0);
; 2886 : 			}
; 2887 : 		}
; 2888 : 	}
; 2889 : 	if (word[0]=='\0')

  016b1	8a 0e		 mov	 cl, BYTE PTR [esi]
  016b3	84 c9		 test	 cl, cl
  016b5	74 26		 je	 SHORT $L73010

; 2890 : 	{
; 2891 : 		if (*num_pos>0)
; 2892 : 		{
; 2893 : 			return(1);
; 2894 : 		}
; 2895 : 		else
; 2896 : 		{
; 2897 : 			return(0);
; 2898 : 		}
; 2899 : 	}
; 2900 : 	if (noun_character_mapping_table[word[0]]==NOUN_UNUSED_ENTRY)

  016b7	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  016bd	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _noun_character_mapping_table[ecx*4]
  016c4	83 f9 ff	 cmp	 ecx, -1
  016c7	74 14		 je	 SHORT $L73010

; 2901 : 	{
; 2902 : 		if (*num_pos>0)
; 2903 : 		{
; 2904 : 			return(1);
; 2905 : 		}
; 2906 : 		else
; 2907 : 		{
; 2908 : 			return(0);
; 2909 : 		}
; 2910 : 	}
; 2911 : 	if (noun_character_mapping_table[word[0]]>(cur->length))

  016c9	0f be 78 01	 movsx	 edi, BYTE PTR [eax+1]
  016cd	3b cf		 cmp	 ecx, edi
  016cf	7f 0c		 jg	 SHORT $L73010

; 2914 : 		{
; 2915 : 			return(1);
; 2916 : 		}
; 2917 : 		else
; 2918 : 		{
; 2919 : 			return(0);
; 2920 : 		}
; 2921 : 	}
; 2922 : 	return(par_find_word_in_dict(cur->foo.entries[noun_character_mapping_table[word[0]]],word+1,positions,depth+1,num_pos));

  016d1	0f bf 44 48 02	 movsx	 eax, WORD PTR [eax+ecx*2+2]
  016d6	45		 inc	 ebp
  016d7	46		 inc	 esi
  016d8	83 f8 ff	 cmp	 eax, -1
  016db	75 ac		 jne	 SHORT $L73007
$L73010:

; 2912 : 	{
; 2913 : 		if (*num_pos>0)

  016dd	8b 0a		 mov	 ecx, DWORD PTR [edx]
  016df	33 c0		 xor	 eax, eax
  016e1	5f		 pop	 edi
  016e2	5e		 pop	 esi
  016e3	85 c9		 test	 ecx, ecx
  016e5	5d		 pop	 ebp
  016e6	5b		 pop	 ebx
  016e7	0f 9f c0	 setg	 al

; 2923 : }

  016ea	c3		 ret	 0
$L73011:

; 2858 : 	{
; 2859 : 		positions[*num_pos]=depth;

  016eb	8b 02		 mov	 eax, DWORD PTR [edx]
  016ed	8b 4c 24 1c	 mov	 ecx, DWORD PTR _positions$[esp+12]
  016f1	5f		 pop	 edi
  016f2	5e		 pop	 esi
  016f3	89 2c 81	 mov	 DWORD PTR [ecx+eax*4], ebp

; 2860 : 		(*num_pos)++;

  016f6	8b 02		 mov	 eax, DWORD PTR [edx]
  016f8	40		 inc	 eax
  016f9	5d		 pop	 ebp
  016fa	89 02		 mov	 DWORD PTR [edx], eax

; 2861 : 		return(1);

  016fc	b8 01 00 00 00	 mov	 eax, 1
  01701	5b		 pop	 ebx

; 2923 : }

  01702	c3		 ret	 0
$L73012:

; 2870 : 	{
; 2871 : 	  if (memcmp(word,cur->foo.rest_of_word,cur->length)==0)

  01703	0f be 58 01	 movsx	 ebx, BYTE PTR [eax+1]
  01707	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
  0170a	8b cb		 mov	 ecx, ebx
  0170c	33 c0		 xor	 eax, eax
  0170e	f3 a6		 repe cmpsb
  01710	75 cb		 jne	 SHORT $L73010

; 2872 : 		{
; 2873 : 			positions[*num_pos]=depth+cur->length;

  01712	8b 0a		 mov	 ecx, DWORD PTR [edx]
  01714	8b 44 24 1c	 mov	 eax, DWORD PTR _positions$[esp+12]
  01718	03 dd		 add	 ebx, ebp
  0171a	5f		 pop	 edi
  0171b	89 1c 88	 mov	 DWORD PTR [eax+ecx*4], ebx

; 2874 : 			(*num_pos)++;

  0171e	8b 02		 mov	 eax, DWORD PTR [edx]
  01720	40		 inc	 eax
  01721	5e		 pop	 esi
  01722	89 02		 mov	 DWORD PTR [edx], eax
  01724	5d		 pop	 ebp

; 2875 : 			return(1);

  01725	b8 01 00 00 00	 mov	 eax, 1
  0172a	5b		 pop	 ebx

; 2923 : }

  0172b	c3		 ret	 0
_par_find_word_in_dict ENDP
_TEXT	ENDS
PUBLIC	_par_insert_string_before
PUBLIC	_par_insert_string_after
_TEXT	SEGMENT
_current_rule$ = 8
_input_array$ = 12
_output_array$ = 16
_input_indexes$ = 20
_output_indexes$ = 24
_match_array$ = 28
_ret_value$ = 32
_range_value$ = 36
_save_num$ = 40
_dict_state_flag$ = 44
_in_rule_index$ = 48
_insert_operation_flags$ = 52
_buf$ = -100
_length$ = 48
_new_length$ = 16
_temp_index$ = -108
_par_insert_string PROC NEAR

; 2968 : {

  01730	83 ec 6c	 sub	 esp, 108		; 0000006cH

; 2969 : 	unsigned char buf[100];
; 2970 : 	int length,new_length;
; 2971 : 	int pos,new_loc,off;
; 2972 : 	//055	MGS		10/14/1999	BATS#900 Fixed indexing in spanish phone numbers
; 2973 : 	int i;
; 2974 : 	index_data_t temp_index={0,0,0};

  01733	33 c0		 xor	 eax, eax
  01735	66 89 44 24 00	 mov	 WORD PTR _temp_index$[esp+108], ax
  0173a	66 89 44 24 02	 mov	 WORD PTR _temp_index$[esp+110], ax
  0173f	66 89 44 24 04	 mov	 WORD PTR _temp_index$[esp+112], ax

; 2975 : 	
; 2976 : #ifdef GERMAN_COMPOUND_NOUNS
; 2977 : 	if (insert_operation_flags & BIN_AFTER_FLAG)

  01744	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR _insert_operation_flags$[esp+104]
  0174b	a8 40		 test	 al, 64			; 00000040H
  0174d	74 65		 je	 SHORT $L71957

; 2978 : 	{
; 2979 : 		par_insert_string_after(current_rule,input_array,output_array,input_indexes,output_indexes,match_array,ret_value,range_value,save_num,dict_state_flag,in_rule_index,insert_operation_flags);

  0174f	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _dict_state_flag$[esp+104]
  01756	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR _save_num$[esp+104]
  0175d	50		 push	 eax
  0175e	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR _in_rule_index$[esp+108]
  01765	50		 push	 eax
  01766	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _range_value$[esp+112]
  0176d	51		 push	 ecx
  0176e	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _ret_value$[esp+116]
  01775	52		 push	 edx
  01776	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR _match_array$[esp+120]
  0177d	50		 push	 eax
  0177e	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _output_indexes$[esp+124]
  01785	51		 push	 ecx
  01786	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _input_indexes$[esp+128]
  0178d	52		 push	 edx
  0178e	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR _output_array$[esp+132]
  01795	50		 push	 eax
  01796	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _input_array$[esp+136]
  0179d	51		 push	 ecx
  0179e	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _current_rule$[esp+140]
  017a5	52		 push	 edx
  017a6	50		 push	 eax
  017a7	51		 push	 ecx
  017a8	e8 00 00 00 00	 call	 _par_insert_string_after
  017ad	83 c4 30	 add	 esp, 48			; 00000030H

; 3052 : 
; 3053 : #ifdef DEBUG
; 3054 : 	printf("leaving par_insert_string; insert is done\n");
; 3055 : #endif
; 3056 : 	return;
; 3057 : }

  017b0	83 c4 6c	 add	 esp, 108		; 0000006cH
  017b3	c3		 ret	 0
$L71957:

; 2980 : 		return;
; 2981 : 	}
; 2982 : 	if (insert_operation_flags & BIN_BEFORE_FLAG)

  017b4	a8 20		 test	 al, 32			; 00000020H
  017b6	74 65		 je	 SHORT $L71958

; 2983 : 	{
; 2984 : 		par_insert_string_before(current_rule,input_array,output_array,input_indexes,output_indexes,match_array,ret_value,range_value,save_num,dict_state_flag,in_rule_index,insert_operation_flags);

  017b8	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR _in_rule_index$[esp+104]
  017bf	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _save_num$[esp+104]
  017c6	50		 push	 eax
  017c7	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR _dict_state_flag$[esp+108]
  017ce	52		 push	 edx
  017cf	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR _range_value$[esp+112]
  017d6	50		 push	 eax
  017d7	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _ret_value$[esp+116]
  017de	51		 push	 ecx
  017df	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _match_array$[esp+120]
  017e6	52		 push	 edx
  017e7	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR _output_indexes$[esp+124]
  017ee	50		 push	 eax
  017ef	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _input_indexes$[esp+128]
  017f6	51		 push	 ecx
  017f7	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _output_array$[esp+132]
  017fe	52		 push	 edx
  017ff	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR _input_array$[esp+136]
  01806	50		 push	 eax
  01807	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _current_rule$[esp+140]
  0180e	51		 push	 ecx
  0180f	52		 push	 edx
  01810	50		 push	 eax
  01811	e8 00 00 00 00	 call	 _par_insert_string_before
  01816	83 c4 30	 add	 esp, 48			; 00000030H

; 3052 : 
; 3053 : #ifdef DEBUG
; 3054 : 	printf("leaving par_insert_string; insert is done\n");
; 3055 : #endif
; 3056 : 	return;
; 3057 : }

  01819	83 c4 6c	 add	 esp, 108		; 0000006cH
  0181c	c3		 ret	 0
$L71958:

; 2985 : 		return;
; 2986 : 	}
; 2987 : #endif
; 2988 : #ifdef DEBUG
; 2989 : 	printf("entering par_insert_string\n");
; 2990 : #endif
; 2991 : 	/* 
; 2992 : 	*	check the inputs for valid data 
; 2993 : 	*/
; 2994 : #ifdef SANITY_CHECKING
; 2995 : 	if (ret_value==NULL)
; 2996 : 	{
; 2997 : #ifdef DEBUG
; 2998 : 		printf("leaving par_insert_string ret_value is NULL\n");
; 2999 : #endif
; 3000 : 		return;
; 3001 : 	}
; 3002 : 	if ((current_rule==NULL) || (output_array==NULL) || (match_array==NULL))
; 3003 : 	{
; 3004 : 		ret_value->value=FATAL_FAIL;
; 3005 : #ifdef DEBUG
; 3006 : 		printf("leaving par_insert_string; inputs are invalid\n");
; 3007 : #endif
; 3008 : 		return;
; 3009 : 	}
; 3010 : #endif /* SANITY_CHECKING */
; 3011 : 	/* 
; 3012 : 	*	build the string that is going to be inserted 
; 3013 : 	*/
; 3014 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_INSERT,&length,in_rule_index);

  0181d	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR _in_rule_index$[esp+104]
  01824	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR _range_value$[esp+104]
  0182b	55		 push	 ebp
  0182c	8b 6c 24 7c	 mov	 ebp, DWORD PTR _output_array$[esp+108]
  01830	56		 push	 esi
  01831	57		 push	 edi
  01832	8b bc 24 94 00
	00 00		 mov	 edi, DWORD PTR _ret_value$[esp+116]
  01839	8d 94 24 a4 00
	00 00		 lea	 edx, DWORD PTR _length$[esp+116]
  01840	51		 push	 ecx
  01841	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _match_array$[esp+120]
  01848	52		 push	 edx
  01849	6a 1a		 push	 26			; 0000001aH
  0184b	50		 push	 eax
  0184c	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR _current_rule$[esp+132]
  01853	57		 push	 edi
  01854	51		 push	 ecx
  01855	8d 54 24 2c	 lea	 edx, DWORD PTR _buf$[esp+144]
  01859	55		 push	 ebp
  0185a	52		 push	 edx
  0185b	50		 push	 eax
  0185c	e8 00 00 00 00	 call	 _par_build_string_from_rule

; 3015 : 	/* 
; 3016 : 	*	the new length of the ouput string is
; 3017 : 	*	the number of characters inserted into minus 1 (the insert is only between)
; 3018 : 	*	times the length of the string to be inserted plus one (the original character)
; 3019 : 	*	plus one (the last character)
; 3020 : 	*/
; 3021 : 	new_length=(ret_value->output_offset-1)*(length+1)+1;

  01861	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  01864	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR _length$[esp+152]
  0186b	83 c4 24	 add	 esp, 36			; 00000024H
  0186e	42		 inc	 edx
  0186f	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]

; 3022 : 	
; 3023 : 	/* pos is the current position */
; 3024 : 	pos=ret_value->output_pos;

  01872	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  01875	0f af ca	 imul	 ecx, edx
  01878	41		 inc	 ecx

; 3025 : 	/* off is the pos plus the offset minus 1 (the offset is positioned for the next insert) */
; 3026 : 	off=ret_value->output_offset+ret_value->output_pos-1;

  01879	8d 54 06 ff	 lea	 edx, DWORD PTR [esi+eax-1]

; 3027 : 	/* new is the place where the last character of the inserted string will be placed */
; 3028 : 	new_loc=new_length+ret_value->output_pos-1;
; 3029 : 	while (pos<off) /* go until the offset if equal to the position */

  0187d	3b f2		 cmp	 esi, edx
  0187f	89 8c 24 84 00
	00 00		 mov	 DWORD PTR _new_length$[esp+116], ecx
  01886	89 b4 24 90 00
	00 00		 mov	 DWORD PTR 28+[esp+116], esi
  0188d	8d 44 0e ff	 lea	 eax, DWORD PTR [esi+ecx-1]
  01891	0f 8d d6 00 00
	00		 jge	 $L71961
  01897	8b b4 24 8c 00
	00 00		 mov	 esi, DWORD PTR _output_indexes$[esp+116]
  0189e	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  018a1	53		 push	 ebx
  018a2	8d 34 4e	 lea	 esi, DWORD PTR [esi+ecx*2]
  018a5	eb 07		 jmp	 SHORT $L71960
$L73034:

; 2985 : 		return;
; 2986 : 	}
; 2987 : #endif
; 2988 : #ifdef DEBUG
; 2989 : 	printf("entering par_insert_string\n");
; 2990 : #endif
; 2991 : 	/* 
; 2992 : 	*	check the inputs for valid data 
; 2993 : 	*/
; 2994 : #ifdef SANITY_CHECKING
; 2995 : 	if (ret_value==NULL)
; 2996 : 	{
; 2997 : #ifdef DEBUG
; 2998 : 		printf("leaving par_insert_string ret_value is NULL\n");
; 2999 : #endif
; 3000 : 		return;
; 3001 : 	}
; 3002 : 	if ((current_rule==NULL) || (output_array==NULL) || (match_array==NULL))
; 3003 : 	{
; 3004 : 		ret_value->value=FATAL_FAIL;
; 3005 : #ifdef DEBUG
; 3006 : 		printf("leaving par_insert_string; inputs are invalid\n");
; 3007 : #endif
; 3008 : 		return;
; 3009 : 	}
; 3010 : #endif /* SANITY_CHECKING */
; 3011 : 	/* 
; 3012 : 	*	build the string that is going to be inserted 
; 3013 : 	*/
; 3014 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_INSERT,&length,in_rule_index);

  018a7	8b b4 24 9c 00
	00 00		 mov	 esi, DWORD PTR 36+[esp+120]
$L71960:

; 3030 : 	{
; 3031 : 		/* copy the character in the current string into its new location */
; 3032 : 		output_array[new_loc]=output_array[off];                                

  018ae	8a 0c 2a	 mov	 cl, BYTE PTR [edx+ebp]

; 3033 : 		par_copy_index(output_indexes,new_loc,output_indexes,off);

  018b1	8b bc 24 90 00
	00 00		 mov	 edi, DWORD PTR _output_indexes$[esp+120]
  018b8	88 0c 28	 mov	 BYTE PTR [eax+ebp], cl
  018bb	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  018be	8d 0c 4f	 lea	 ecx, DWORD PTR [edi+ecx*2]
  018c1	8b fe		 mov	 edi, esi
  018c3	8b 1f		 mov	 ebx, DWORD PTR [edi]
  018c5	89 19		 mov	 DWORD PTR [ecx], ebx
  018c7	66 8b 7f 04	 mov	 di, WORD PTR [edi+4]
  018cb	66 89 79 04	 mov	 WORD PTR [ecx+4], di

; 3034 : 		par_copy_index(output_indexes,off,output_indexes,PAR_MAX_OUTPUT_ARRAY-1);

  018cf	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _output_indexes$[esp+120]
  018d6	81 c1 b2 0b 00
	00		 add	 ecx, 2994		; 00000bb2H
  018dc	8b fe		 mov	 edi, esi

; 3035 : 		/* move off back to the previous character */
; 3036 : 		off--;                                       

  018de	83 ee 06	 sub	 esi, 6
  018e1	4a		 dec	 edx
  018e2	8b 19		 mov	 ebx, DWORD PTR [ecx]
  018e4	89 b4 24 9c 00
	00 00		 mov	 DWORD PTR 36+[esp+120], esi
  018eb	89 1f		 mov	 DWORD PTR [edi], ebx

; 3037 : 		/* move new back for the insert of the inset string */
; 3038 : 		new_loc-=length;                                          
; 3039 : 		/* copy the insert string to new */
; 3040 : 		memcpy(output_array+new_loc,buf,length);

  018ed	8d 74 24 18	 lea	 esi, DWORD PTR _buf$[esp+124]
  018f1	66 8b 49 04	 mov	 cx, WORD PTR [ecx+4]
  018f5	66 89 4f 04	 mov	 WORD PTR [edi+4], cx
  018f9	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR _length$[esp+120]
  01900	2b c1		 sub	 eax, ecx
  01902	8b d9		 mov	 ebx, ecx
  01904	c1 e9 02	 shr	 ecx, 2
  01907	8d 3c 28	 lea	 edi, DWORD PTR [eax+ebp]
  0190a	f3 a5		 rep movsd
  0190c	8b cb		 mov	 ecx, ebx
  0190e	83 e1 03	 and	 ecx, 3
  01911	f3 a4		 rep movsb

; 3041 : 		//055	MGS		10/14/1999	BATS#900 Fixed indexing in spanish phone numbers
; 3042 : 		/* blank the indexes in the inserted range */
; 3043 : 		for (i=new_loc;i<new_loc+length;i++)

  01913	8b b4 24 a8 00
	00 00		 mov	 esi, DWORD PTR _length$[esp+120]
  0191a	8b c8		 mov	 ecx, eax
  0191c	03 f0		 add	 esi, eax
  0191e	3b c6		 cmp	 eax, esi
  01920	7d 2c		 jge	 SHORT $L71964

; 3044 : 		{
; 3045 : 			par_copy_index(output_indexes,new_loc,&temp_index,0);

  01922	8b bc 24 90 00
	00 00		 mov	 edi, DWORD PTR _output_indexes$[esp+120]
  01929	8d 34 40	 lea	 esi, DWORD PTR [eax+eax*2]
  0192c	8d 34 77	 lea	 esi, DWORD PTR [edi+esi*2]
$L71962:
  0192f	8b 5c 24 10	 mov	 ebx, DWORD PTR _temp_index$[esp+124]
  01933	8b fe		 mov	 edi, esi
  01935	41		 inc	 ecx
  01936	89 1f		 mov	 DWORD PTR [edi], ebx
  01938	66 8b 5c 24 14	 mov	 bx, WORD PTR _temp_index$[esp+128]
  0193d	66 89 5f 04	 mov	 WORD PTR [edi+4], bx
  01941	8b bc 24 a8 00
	00 00		 mov	 edi, DWORD PTR _length$[esp+120]
  01948	03 f8		 add	 edi, eax
  0194a	3b cf		 cmp	 ecx, edi
  0194c	7c e1		 jl	 SHORT $L71962
$L71964:

; 3027 : 	/* new is the place where the last character of the inserted string will be placed */
; 3028 : 	new_loc=new_length+ret_value->output_pos-1;
; 3029 : 	while (pos<off) /* go until the offset if equal to the position */

  0194e	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR 28+[esp+120]

; 3046 : 		}
; 3047 : 		/* move new back one character */
; 3048 : 		new_loc--;

  01955	48		 dec	 eax
  01956	3b d1		 cmp	 edx, ecx
  01958	0f 8f 49 ff ff
	ff		 jg	 $L73034
  0195e	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR _new_length$[esp+120]
  01965	8b bc 24 98 00
	00 00		 mov	 edi, DWORD PTR _ret_value$[esp+120]
  0196c	5b		 pop	 ebx
$L71961:

; 3049 : 	}                                    
; 3050 : 	/* the output offset is equal to the total length of the new string */
; 3051 : 	ret_value->output_offset=new_length;

  0196d	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  01970	5f		 pop	 edi
  01971	5e		 pop	 esi
  01972	5d		 pop	 ebp

; 3052 : 
; 3053 : #ifdef DEBUG
; 3054 : 	printf("leaving par_insert_string; insert is done\n");
; 3055 : #endif
; 3056 : 	return;
; 3057 : }

  01973	83 c4 6c	 add	 esp, 108		; 0000006cH
  01976	c3		 ret	 0
_par_insert_string ENDP
_current_rule$ = 8
_output_array$ = 16
_match_array$ = 28
_ret_value$ = 32
_range_value$ = 36
_in_rule_index$ = 48
_length$ = 48
_buf$ = -100
_par_insert_string_after PROC NEAR

; 3099 : 	int length;
; 3100 : 	unsigned char buf[100];
; 3101 : 	
; 3102 : #ifdef DEBUG
; 3103 : 	printf("entering par_insert_string_after\n");
; 3104 : #endif
; 3105 : 	/*
; 3106 : 	*	check the input values
; 3107 : 	*/
; 3108 : #ifdef SANITY_CHECKING
; 3109 : 	if (ret_value==NULL)
; 3110 : 	{
; 3111 : #ifdef DEBUG
; 3112 : 		printf("leaving par_insert_string_after ret_value is NULL\n");
; 3113 : #endif
; 3114 : 		return;
; 3115 : 	}
; 3116 : 	if ((current_rule==NULL) || (output_array==NULL) || (match_array==NULL))
; 3117 : 	{
; 3118 : 		ret_value->value=FATAL_FAIL;
; 3119 : #ifdef DEBUG
; 3120 : 		printf("leaving par_insert_string_after inputs are invalid\n");
; 3121 : #endif
; 3122 : 		return;
; 3123 : 	}
; 3124 : #endif
; 3125 : 	/*
; 3126 : 	*	build the string for the insert after 
; 3127 : 	*/
; 3128 : #ifndef GERMAN_COMPOUND_NOUNS
; 3129 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_AFTER,&length,in_rule_index);
; 3130 : #else
; 3131 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_INSERT | BIN_AFTER_FLAG,&length,in_rule_index);

  01980	8b 44 24 2c	 mov	 eax, DWORD PTR _in_rule_index$[esp-4]
  01984	83 ec 64	 sub	 esp, 100		; 00000064H
  01987	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR _range_value$[esp+96]
  0198e	8d 8c 24 90 00
	00 00		 lea	 ecx, DWORD PTR _length$[esp+96]
  01995	53		 push	 ebx
  01996	8b 9c 24 84 00
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+100]
  0199d	55		 push	 ebp
  0199e	8b 6c 24 78	 mov	 ebp, DWORD PTR _output_array$[esp+104]
  019a2	56		 push	 esi
  019a3	57		 push	 edi
  019a4	50		 push	 eax
  019a5	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR _match_array$[esp+116]
  019ac	51		 push	 ecx
  019ad	6a 5a		 push	 90			; 0000005aH
  019af	52		 push	 edx
  019b0	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR _current_rule$[esp+128]
  019b7	53		 push	 ebx
  019b8	50		 push	 eax
  019b9	8d 4c 24 28	 lea	 ecx, DWORD PTR _buf$[esp+140]
  019bd	55		 push	 ebp
  019be	51		 push	 ecx
  019bf	52		 push	 edx
  019c0	e8 00 00 00 00	 call	 _par_build_string_from_rule

; 3132 : #endif
; 3133 : 	/* copy the inserted string into its place */
; 3134 : 	/* the indexes will have been copied by copy_string _data */
; 3135 : 	strcpy((output_array+(ret_value->output_pos+ret_value->output_offset)),buf);

  019c5	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  019c8	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  019cb	03 d5		 add	 edx, ebp
  019cd	8d 7c 24 34	 lea	 edi, DWORD PTR _buf$[esp+152]
  019d1	03 d1		 add	 edx, ecx
  019d3	83 c9 ff	 or	 ecx, -1
  019d6	33 c0		 xor	 eax, eax
  019d8	83 c4 24	 add	 esp, 36			; 00000024H
  019db	f2 ae		 repne scasb
  019dd	f7 d1		 not	 ecx
  019df	2b f9		 sub	 edi, ecx
  019e1	8b c1		 mov	 eax, ecx
  019e3	8b f7		 mov	 esi, edi
  019e5	8b fa		 mov	 edi, edx
  019e7	c1 e9 02	 shr	 ecx, 2
  019ea	f3 a5		 rep movsd
  019ec	8b c8		 mov	 ecx, eax
  019ee	83 e1 03	 and	 ecx, 3
  019f1	f3 a4		 rep movsb

; 3136 : 	memcpy((output_array+(ret_value->output_pos+ret_value->output_offset)),buf,length);

  019f3	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _length$[esp+112]
  019fa	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  019fd	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  01a00	03 fd		 add	 edi, ebp
  01a02	8b d1		 mov	 edx, ecx
  01a04	8d 74 24 10	 lea	 esi, DWORD PTR _buf$[esp+116]
  01a08	03 f8		 add	 edi, eax
  01a0a	c1 e9 02	 shr	 ecx, 2
  01a0d	f3 a5		 rep movsd
  01a0f	8b ca		 mov	 ecx, edx
  01a11	83 e1 03	 and	 ecx, 3
  01a14	f3 a4		 rep movsb

; 3137 : 	/* add the length of the inserted atring to the offset */
; 3138 : 	ret_value->output_offset+=length;

  01a16	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _length$[esp+112]
  01a1d	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  01a20	03 c8		 add	 ecx, eax
  01a22	5f		 pop	 edi
  01a23	5e		 pop	 esi
  01a24	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx
  01a27	5d		 pop	 ebp
  01a28	5b		 pop	 ebx

; 3139 : #ifdef DEBUG
; 3140 : 	printf("leaving par_insert_string_after insert after is done\n");
; 3141 : #endif
; 3142 : 	return;
; 3143 : }                                                                             

  01a29	83 c4 64	 add	 esp, 100		; 00000064H
  01a2c	c3		 ret	 0
_par_insert_string_after ENDP
_current_rule$ = 8
_output_array$ = 16
_output_indexes$ = 24
_match_array$ = 28
_ret_value$ = 32
_range_value$ = 36
_in_rule_index$ = 48
_length$ = 48
_buf$ = -100
_par_insert_string_before PROC NEAR

; 3187 : 	int length;
; 3188 : 	int i,j;
; 3189 : 	unsigned char buf[100];           
; 3190 : 	
; 3191 : #ifdef DEBUG
; 3192 : 	printf("entering par_insert_string_before\n");
; 3193 : #endif
; 3194 : 	/*
; 3195 : 	*	check the input values
; 3196 : 	*/
; 3197 : #ifdef SANITY_CHECKING
; 3198 : 	if (ret_value==NULL)
; 3199 : 	{
; 3200 : #ifdef DEBUG
; 3201 : 		printf("leaving par_insert_string_before ret_value is NULL\n");
; 3202 : #endif
; 3203 : 		return;
; 3204 : 	}
; 3205 : 	if ((current_rule==NULL) || (output_array==NULL) || (match_array==NULL))
; 3206 : 	{
; 3207 : 		ret_value->value=FATAL_FAIL;
; 3208 : #ifdef DEBUG
; 3209 : 		printf("leaving par_insert_string_before; inputs are invalid\n");
; 3210 : #endif
; 3211 : 		return;
; 3212 : 	}
; 3213 : #endif
; 3214 : 	
; 3215 : 	/* build the string to be inserted before the input string */
; 3216 : #ifndef GERMAN_COMPOUND_NOUNS
; 3217 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_BEFORE,&length,in_rule_index);
; 3218 : #else
; 3219 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_INSERT | BIN_BEFORE_FLAG,&length,in_rule_index);

  01a30	8b 44 24 2c	 mov	 eax, DWORD PTR _in_rule_index$[esp-4]
  01a34	83 ec 64	 sub	 esp, 100		; 00000064H
  01a37	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR _range_value$[esp+96]
  01a3e	8d 8c 24 90 00
	00 00		 lea	 ecx, DWORD PTR _length$[esp+96]
  01a45	53		 push	 ebx
  01a46	8b 9c 24 84 00
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+100]
  01a4d	55		 push	 ebp
  01a4e	8b 6c 24 78	 mov	 ebp, DWORD PTR _output_array$[esp+104]
  01a52	56		 push	 esi
  01a53	57		 push	 edi
  01a54	50		 push	 eax
  01a55	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR _match_array$[esp+116]
  01a5c	51		 push	 ecx
  01a5d	6a 3a		 push	 58			; 0000003aH
  01a5f	52		 push	 edx
  01a60	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR _current_rule$[esp+128]
  01a67	53		 push	 ebx
  01a68	50		 push	 eax
  01a69	8d 4c 24 28	 lea	 ecx, DWORD PTR _buf$[esp+140]
  01a6d	55		 push	 ebp
  01a6e	51		 push	 ecx
  01a6f	52		 push	 edx
  01a70	e8 00 00 00 00	 call	 _par_build_string_from_rule

; 3220 : #endif
; 3221 : 	/* move the current string length characters to the right to make room for the insert string */
; 3222 : 	j=ret_value->output_pos+ret_value->output_offset;

  01a75	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 3223 : 	for (i=j-1;i>=ret_value->output_pos;i--)

  01a78	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  01a7b	8b 94 24 ac 00
	00 00		 mov	 edx, DWORD PTR _output_indexes$[esp+148]
  01a82	83 c4 24	 add	 esp, 36			; 00000024H
  01a85	8d 44 01 ff	 lea	 eax, DWORD PTR [ecx+eax-1]
  01a89	3b c1		 cmp	 eax, ecx
  01a8b	7c 45		 jl	 SHORT $L72023
  01a8d	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  01a90	8d 34 4a	 lea	 esi, DWORD PTR [edx+ecx*2]
$L72021:

; 3224 : 	{
; 3225 : 		output_array[i+length]=output_array[i];

  01a93	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _length$[esp+112]
  01a9a	8d 3c 08	 lea	 edi, DWORD PTR [eax+ecx]
  01a9d	8a 0c 28	 mov	 cl, BYTE PTR [eax+ebp]
  01aa0	88 0c 2f	 mov	 BYTE PTR [edi+ebp], cl

; 3226 : 		par_copy_index(output_indexes,i+length,output_indexes,i);

  01aa3	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _length$[esp+112]
  01aaa	03 c8		 add	 ecx, eax
  01aac	48		 dec	 eax
  01aad	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  01ab0	8d 14 4a	 lea	 edx, DWORD PTR [edx+ecx*2]
  01ab3	8b ce		 mov	 ecx, esi
  01ab5	83 ee 06	 sub	 esi, 6
  01ab8	8b 39		 mov	 edi, DWORD PTR [ecx]
  01aba	89 3a		 mov	 DWORD PTR [edx], edi
  01abc	66 8b 49 04	 mov	 cx, WORD PTR [ecx+4]
  01ac0	66 89 4a 04	 mov	 WORD PTR [edx+4], cx
  01ac4	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  01ac7	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR _output_indexes$[esp+112]
  01ace	3b c1		 cmp	 eax, ecx
  01ad0	7d c1		 jge	 SHORT $L72021
$L72023:

; 3227 : 	}
; 3228 : 	/* insert the string */
; 3229 : 	memcpy((output_array+(ret_value->output_pos)),buf,length);

  01ad2	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _length$[esp+112]
  01ad9	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  01adc	8b c1		 mov	 eax, ecx
  01ade	8d 74 24 10	 lea	 esi, DWORD PTR _buf$[esp+116]
  01ae2	03 fd		 add	 edi, ebp
  01ae4	c1 e9 02	 shr	 ecx, 2
  01ae7	f3 a5		 rep movsd
  01ae9	8b c8		 mov	 ecx, eax
  01aeb	83 e1 03	 and	 ecx, 3
  01aee	f3 a4		 rep movsb

; 3230 : 	for (i=0;i<length;i++)

  01af0	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _length$[esp+112]
  01af7	33 c9		 xor	 ecx, ecx
  01af9	85 c0		 test	 eax, eax
  01afb	7e 2b		 jle	 SHORT $L73052

; 3231 : 	{
; 3232 : 		par_copy_index(output_indexes,ret_value->output_pos+i,output_indexes,PAR_MAX_OUTPUT_ARRAY-1);

  01afd	8d b2 b2 0b 00
	00		 lea	 esi, DWORD PTR [edx+2994]
$L72024:
  01b03	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  01b06	8b fe		 mov	 edi, esi
  01b08	03 c1		 add	 eax, ecx
  01b0a	41		 inc	 ecx
  01b0b	8b 2f		 mov	 ebp, DWORD PTR [edi]
  01b0d	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  01b10	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  01b13	89 28		 mov	 DWORD PTR [eax], ebp
  01b15	66 8b 7f 04	 mov	 di, WORD PTR [edi+4]
  01b19	66 89 78 04	 mov	 WORD PTR [eax+4], di
  01b1d	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _length$[esp+112]
  01b24	3b c8		 cmp	 ecx, eax
  01b26	7c db		 jl	 SHORT $L72024
$L73052:

; 3233 : 	}
; 3234 : 	/* add the length of the inserted string to the offset */
; 3235 : 	ret_value->output_offset+=length;

  01b28	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  01b2b	5f		 pop	 edi
  01b2c	03 c8		 add	 ecx, eax
  01b2e	5e		 pop	 esi
  01b2f	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx
  01b32	5d		 pop	 ebp
  01b33	5b		 pop	 ebx

; 3236 : 	//	ret_value->rule++;
; 3237 : #ifdef DEBUG
; 3238 : 	printf("leaving par_insert_string_before; insert before is done\n");
; 3239 : #endif
; 3240 : 	return;
; 3241 : }    

  01b34	83 c4 64	 add	 esp, 100		; 00000064H
  01b37	c3		 ret	 0
_par_insert_string_before ENDP
_output_array$ = 16
_match_array$ = 28
_ret_value$ = 32
_save_num$ = 40
_par_save_string PROC NEAR

; 3281 : 	/* this should be the last thing in the output array, but to be sure strncpy is used */
; 3282 : #ifdef DEBUG
; 3283 : 	printf("entering par_save_string\n");
; 3284 : #endif
; 3285 : 	/* 
; 3286 : 	*	check the input values 
; 3287 : 	*/
; 3288 : #ifdef SANITY_CHECKING
; 3289 : 	if (ret_value==NULL)
; 3290 : 	{
; 3291 : #ifdef DEBUG
; 3292 : 		printf("leaving par_save_string ret_value is NULL\n");
; 3293 : #endif
; 3294 : 		return;
; 3295 : 	}
; 3296 : 	if ((output_array==NULL) || (match_array==NULL))
; 3297 : 	{
; 3298 : 		ret_value->value=FATAL_FAIL;
; 3299 : #ifdef DEBUG
; 3300 : 		printf("leaving par_save_string; inputs are invalid\n");
; 3301 : #endif
; 3302 : 		return;
; 3303 : 	}
; 3304 : 	if (save_num<0 || save_num >PAR_MAX_ARRAYS)
; 3305 : 	{
; 3306 : 		printf("$%d is out of range\n",save_num);
; 3307 : 		ret_value->value=FATAL_FAIL;
; 3308 : 		return;
; 3309 : 	}
; 3310 : #endif
; 3311 : 	
; 3312 : 	/* MGS BATS #449 */
; 3313 : 	if (ret_value->output_offset>=PAR_MAX_MATCH_ARRAY)

  01b40	8b 54 24 1c	 mov	 edx, DWORD PTR _ret_value$[esp-4]
  01b44	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  01b47	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  01b4a	7c 08		 jl	 SHORT $L72052

; 3314 : 	{
; 3315 : 		ret_value->value=FATAL_FAIL;

  01b4c	c7 42 14 04 00
	00 00		 mov	 DWORD PTR [edx+20], 4

; 3323 : #ifdef DEBUG
; 3324 : 	printf("leaving par_save_string; string is saved in array %d\n",save_num);
; 3325 : #endif
; 3326 : 	return;
; 3327 : }

  01b53	c3		 ret	 0
$L72052:
  01b54	53		 push	 ebx

; 3316 : 		return;
; 3317 : 	}
; 3318 : 	/* copy the output string to the temporoar array num */
; 3319 : 	memcpy(match_array->array[save_num],(output_array+(ret_value->output_pos)),ret_value->output_offset);

  01b55	8b 5c 24 28	 mov	 ebx, DWORD PTR _save_num$[esp]
  01b59	55		 push	 ebp
  01b5a	56		 push	 esi
  01b5b	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  01b5e	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  01b61	57		 push	 edi
  01b62	8b 7c 24 1c	 mov	 edi, DWORD PTR _output_array$[esp+12]
  01b66	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  01b69	03 f7		 add	 esi, edi
  01b6b	8b 7c 24 28	 mov	 edi, DWORD PTR _match_array$[esp+12]
  01b6f	8b e9		 mov	 ebp, ecx
  01b71	d1 e0		 shl	 eax, 1
  01b73	c1 e9 02	 shr	 ecx, 2
  01b76	8d 7c 38 28	 lea	 edi, DWORD PTR [eax+edi+40]
  01b7a	f3 a5		 rep movsd
  01b7c	8b cd		 mov	 ecx, ebp
  01b7e	83 e1 03	 and	 ecx, 3
  01b81	f3 a4		 rep movsb

; 3320 : 	match_array->array_lengths[save_num]=ret_value->output_offset;

  01b83	8b 4c 24 28	 mov	 ecx, DWORD PTR _match_array$[esp+12]
  01b87	8b 72 0c	 mov	 esi, DWORD PTR [edx+12]

; 3321 : 	/* null terminate the string */
; 3322 : 	match_array->array[save_num][ret_value->output_offset]='\0';

  01b8a	03 c1		 add	 eax, ecx
  01b8c	5f		 pop	 edi
  01b8d	89 34 99	 mov	 DWORD PTR [ecx+ebx*4], esi
  01b90	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  01b93	5e		 pop	 esi
  01b94	5d		 pop	 ebp
  01b95	c6 44 08 28 00	 mov	 BYTE PTR [eax+ecx+40], 0
  01b9a	5b		 pop	 ebx

; 3323 : #ifdef DEBUG
; 3324 : 	printf("leaving par_save_string; string is saved in array %d\n",save_num);
; 3325 : #endif
; 3326 : 	return;
; 3327 : }

  01b9b	c3		 ret	 0
_par_save_string ENDP
_TEXT	ENDS
PUBLIC	_par_search_for_word
_TEXT	SEGMENT
_current_rule$ = 8
_input_array$ = 12
_output_array$ = 16
_input_indexes$ = 20
_output_indexes$ = 24
_match_array$ = 28
_ret_value$ = 32
_dict_num$ = 40
_dict_state_flag$ = 44
_in_rule_index$ = 48
_par_dom_dict_search PROC NEAR

; 3372 : {

  01ba0	53		 push	 ebx
  01ba1	55		 push	 ebp

; 3373 : 	int	ipos,opos;
; 3374 : 	int	result=FAIL;
; 3375 : #ifdef DEBUG
; 3376 : 	printf("entering par_dom_dict_search\n");
; 3377 : #endif
; 3378 : 	ipos=ret_value->input_pos;
; 3379 : 	opos=ret_value->output_pos;

  01ba2	8b 6c 24 24	 mov	 ebp, DWORD PTR _ret_value$[esp+4]
  01ba6	56		 push	 esi
  01ba7	57		 push	 edi

; 3380 : 	
; 3381 : 	/* MGS BATS #449 */
; 3382 : 	if (ret_value->input_offset>=PAR_MAX_MATCH_ARRAY)

  01ba8	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  01bab	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  01bae	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  01bb1	7c 0c		 jl	 SHORT $L72081
  01bb3	5f		 pop	 edi

; 3383 : 	{
; 3384 : 		ret_value->value=FATAL_FAIL;

  01bb4	c7 45 14 04 00
	00 00		 mov	 DWORD PTR [ebp+20], 4
  01bbb	5e		 pop	 esi
  01bbc	5d		 pop	 ebp
  01bbd	5b		 pop	 ebx

; 3479 : 	}       
; 3480 : #ifdef DEBUG
; 3481 : 	printf("leaving par_dom_dict_search\n");
; 3482 : 	par_print_rule_error("",current_rule,ret_value->rule);
; 3483 : #endif
; 3484 : }

  01bbe	c3		 ret	 0
$L72081:

; 3385 : #ifdef DEBUG
; 3386 : 		printf("leaving par_dom_dict_search fatal failure of the rule\n");
; 3387 : #endif
; 3388 : 		return;
; 3389 : 	}
; 3390 : 	if (ret_value->output_offset>=PAR_MAX_MATCH_ARRAY)

  01bbf	83 7d 0c 1e	 cmp	 DWORD PTR [ebp+12], 30	; 0000001eH
  01bc3	7c 0c		 jl	 SHORT $L72082
  01bc5	5f		 pop	 edi

; 3391 : 	{
; 3392 : 		ret_value->value=FATAL_FAIL;

  01bc6	c7 45 14 04 00
	00 00		 mov	 DWORD PTR [ebp+20], 4
  01bcd	5e		 pop	 esi
  01bce	5d		 pop	 ebp
  01bcf	5b		 pop	 ebx

; 3479 : 	}       
; 3480 : #ifdef DEBUG
; 3481 : 	printf("leaving par_dom_dict_search\n");
; 3482 : 	par_print_rule_error("",current_rule,ret_value->rule);
; 3483 : #endif
; 3484 : }

  01bd0	c3		 ret	 0
$L72082:

; 3393 : #ifdef DEBUG
; 3394 : 		printf("leaving par_dom_dict_search fatal failure of the rule\n");
; 3395 : #endif
; 3396 : 		return;
; 3397 : 	}
; 3398 : 	memcpy(match_array->array[7],input_array+ipos,ret_value->input_offset);

  01bd1	8b 75 00	 mov	 esi, DWORD PTR [ebp]
  01bd4	8b 7c 24 18	 mov	 edi, DWORD PTR _input_array$[esp+12]
  01bd8	8b 5c 24 28	 mov	 ebx, DWORD PTR _match_array$[esp+12]
  01bdc	8b c1		 mov	 eax, ecx
  01bde	03 f7		 add	 esi, edi
  01be0	8d bb fa 00 00
	00		 lea	 edi, DWORD PTR [ebx+250]
  01be6	c1 e9 02	 shr	 ecx, 2
  01be9	f3 a5		 rep movsd
  01beb	8b c8		 mov	 ecx, eax
  01bed	83 e1 03	 and	 ecx, 3
  01bf0	f3 a4		 rep movsb

; 3399 : 	match_array->array[7][ret_value->input_offset]='\0';

  01bf2	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]

; 3400 : 	match_array->array_lengths[7]=ret_value->input_offset;
; 3401 : 	memcpy(match_array->array[8],output_array+opos,ret_value->output_offset);

  01bf5	8b 74 24 1c	 mov	 esi, DWORD PTR _output_array$[esp+12]
  01bf9	03 f2		 add	 esi, edx
  01bfb	c6 84 19 fa 00
	00 00 00	 mov	 BYTE PTR [ecx+ebx+250], 0
  01c03	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  01c06	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  01c09	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01c0c	8d 83 18 01 00
	00		 lea	 eax, DWORD PTR [ebx+280]
  01c12	8b d1		 mov	 edx, ecx
  01c14	8b f8		 mov	 edi, eax
  01c16	c1 e9 02	 shr	 ecx, 2
  01c19	f3 a5		 rep movsd
  01c1b	8b ca		 mov	 ecx, edx
  01c1d	83 e1 03	 and	 ecx, 3
  01c20	f3 a4		 rep movsb

; 3402 : 	match_array->array[8][ret_value->output_offset]='\0';

  01c22	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]

; 3403 : 	match_array->array_lengths[8]=ret_value->output_offset;
; 3404 : 	result=par_search_for_word(match_array->array[8],ret_value->output_offset,match_array->array[9],dict_num,dict_state_flag);

  01c25	8b 74 24 38	 mov	 esi, DWORD PTR _dict_state_flag$[esp+12]
  01c29	8d bb 36 01 00
	00		 lea	 edi, DWORD PTR [ebx+310]
  01c2f	56		 push	 esi
  01c30	c6 84 19 18 01
	00 00 00	 mov	 BYTE PTR [ecx+ebx+280], 0
  01c38	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01c3b	8b 4c 24 38	 mov	 ecx, DWORD PTR _dict_num$[esp+16]
  01c3f	89 53 20	 mov	 DWORD PTR [ebx+32], edx
  01c42	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01c45	51		 push	 ecx
  01c46	57		 push	 edi
  01c47	52		 push	 edx
  01c48	50		 push	 eax
  01c49	e8 00 00 00 00	 call	 _par_search_for_word

; 3405 : 	if (dict_state_flag)

  01c4e	33 d2		 xor	 edx, edx
  01c50	83 c4 14	 add	 esp, 20			; 00000014H
  01c53	3b f2		 cmp	 esi, edx
  01c55	74 14		 je	 SHORT $L72083

; 3406 : 	{
; 3407 : 		if (result)

  01c57	3b c2		 cmp	 eax, edx
  01c59	0f 84 c1 00 00
	00		 je	 $L72089
  01c5f	5f		 pop	 edi

; 3408 : 		{
; 3409 : #ifdef DEBUG
; 3410 : 			printf("leaving par_dom_dict_search 1 success\n");
; 3411 : #endif
; 3412 : 			ret_value->value=SUCCESS;

  01c60	c7 45 14 01 00
	00 00		 mov	 DWORD PTR [ebp+20], 1
  01c67	5e		 pop	 esi
  01c68	5d		 pop	 ebp
  01c69	5b		 pop	 ebx

; 3479 : 	}       
; 3480 : #ifdef DEBUG
; 3481 : 	printf("leaving par_dom_dict_search\n");
; 3482 : 	par_print_rule_error("",current_rule,ret_value->rule);
; 3483 : #endif
; 3484 : }

  01c6a	c3		 ret	 0
$L72083:

; 3413 : 			return;
; 3414 : 		}
; 3415 : #ifdef DEBUG
; 3416 : 		printf("leaving par_dom_dict_search 1 failure\n");
; 3417 : #endif
; 3418 : 		return;		
; 3419 : 	}
; 3420 : 	if (result==1)

  01c6b	83 f8 01	 cmp	 eax, 1
  01c6e	75 6e		 jne	 SHORT $L72085

; 3421 : 	{
; 3422 : 		match_array->array_lengths[9]=strlen(match_array->array[9]);

  01c70	83 c9 ff	 or	 ecx, -1
  01c73	33 c0		 xor	 eax, eax
  01c75	f2 ae		 repne scasb

; 3423 : 		if (current_rule[in_rule_index] & BIN_DICT_HIT_FAIL)

  01c77	8b 74 24 14	 mov	 esi, DWORD PTR _current_rule$[esp+12]
  01c7b	8b 7c 24 3c	 mov	 edi, DWORD PTR _in_rule_index$[esp+12]
  01c7f	f7 d1		 not	 ecx
  01c81	49		 dec	 ecx
  01c82	89 4b 24	 mov	 DWORD PTR [ebx+36], ecx
  01c85	8a 04 3e	 mov	 al, BYTE PTR [esi+edi]
  01c88	a8 80		 test	 al, 128			; 00000080H
  01c8a	74 1b		 je	 SHORT $L72088
$L73056:

; 3424 : 		{
; 3425 : 			ret_value->value=FAIL;
; 3426 : 			if (ret_value->optional==1)

  01c8c	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  01c8f	89 55 14	 mov	 DWORD PTR [ebp+20], edx
  01c92	83 f8 01	 cmp	 eax, 1
  01c95	0f 85 85 00 00
	00		 jne	 $L72089
  01c9b	5f		 pop	 edi

; 3427 : 			{
; 3428 : #ifdef DEBUG
; 3429 : 				printf("par_dom_dict_search hit set optinal to -1\n");
; 3430 : #endif
; 3431 : //				ret_value->optional= -1;
; 3432 : 				ret_value->value=OPT_FAIL;

  01c9c	c7 45 14 02 00
	00 00		 mov	 DWORD PTR [ebp+20], 2
  01ca3	5e		 pop	 esi
  01ca4	5d		 pop	 ebp
  01ca5	5b		 pop	 ebx

; 3479 : 	}       
; 3480 : #ifdef DEBUG
; 3481 : 	printf("leaving par_dom_dict_search\n");
; 3482 : 	par_print_rule_error("",current_rule,ret_value->rule);
; 3483 : #endif
; 3484 : }

  01ca6	c3		 ret	 0
$L72088:

; 3433 : 				return;
; 3434 : 			}
; 3435 : 			else
; 3436 : 			{
; 3437 : #ifdef DEBUG
; 3438 : 				par_print_rule_error("",current_rule,ret_value->rule);
; 3439 : 				printf("leaving par_dom_dict_search because of a fail hit_action\n");
; 3440 : #endif
; 3441 : 				return;
; 3442 : 			}
; 3443 : 		}
; 3444 : 		ret_value->input_offset=0;	/* reset for rematching */
; 3445 : 		ret_value->output_offset=0; /* reset for rematching */
; 3446 : 		par_match_rule(current_rule,BIN_COPY,input_array,output_array,input_indexes,output_indexes,match_array,ret_value,dict_state_flag);

  01ca7	8b 44 24 24	 mov	 eax, DWORD PTR _output_indexes$[esp+12]
  01cab	8b 4c 24 20	 mov	 ecx, DWORD PTR _input_indexes$[esp+12]
  01caf	52		 push	 edx
  01cb0	55		 push	 ebp
  01cb1	89 55 04	 mov	 DWORD PTR [ebp+4], edx
  01cb4	89 55 0c	 mov	 DWORD PTR [ebp+12], edx
  01cb7	8b 54 24 24	 mov	 edx, DWORD PTR _output_array$[esp+20]
  01cbb	53		 push	 ebx
  01cbc	50		 push	 eax
  01cbd	8b 44 24 28	 mov	 eax, DWORD PTR _input_array$[esp+28]
  01cc1	51		 push	 ecx
  01cc2	52		 push	 edx
  01cc3	50		 push	 eax
  01cc4	6a 14		 push	 20			; 00000014H
  01cc6	56		 push	 esi
  01cc7	e8 00 00 00 00	 call	 _par_match_rule

; 3447 : #ifdef DEBUG
; 3448 : 		printf("input_off = %d output_off =%d\n",ret_value->input_offset,ret_value->output_offset);
; 3449 : #endif
; 3450 : 		/* skip the miss_action */ /* copy the code for this from the compiler */
; 3451 : 		ret_value->rule=current_rule[in_rule_index+4]+1;

  01ccc	33 c9		 xor	 ecx, ecx
  01cce	83 c4 24	 add	 esp, 36			; 00000024H
  01cd1	8a 4c 3e 04	 mov	 cl, BYTE PTR [esi+edi+4]
  01cd5	41		 inc	 ecx
  01cd6	5f		 pop	 edi
  01cd7	89 4d 10	 mov	 DWORD PTR [ebp+16], ecx
  01cda	5e		 pop	 esi
  01cdb	5d		 pop	 ebp
  01cdc	5b		 pop	 ebx

; 3479 : 	}       
; 3480 : #ifdef DEBUG
; 3481 : 	printf("leaving par_dom_dict_search\n");
; 3482 : 	par_print_rule_error("",current_rule,ret_value->rule);
; 3483 : #endif
; 3484 : }

  01cdd	c3		 ret	 0
$L72085:

; 3452 : 	}
; 3453 : 	else    /* if (result==1) */
; 3454 : 	{
; 3455 : 		ret_value->rule=current_rule[in_rule_index+3]+1;

  01cde	8b 44 24 14	 mov	 eax, DWORD PTR _current_rule$[esp+12]
  01ce2	8b 74 24 3c	 mov	 esi, DWORD PTR _in_rule_index$[esp+12]
  01ce6	33 c9		 xor	 ecx, ecx
  01ce8	8a 4c 30 03	 mov	 cl, BYTE PTR [eax+esi+3]
  01cec	41		 inc	 ecx
  01ced	89 4d 10	 mov	 DWORD PTR [ebp+16], ecx

; 3456 : 		
; 3457 : 		/* skip the hit action state */ /* copy the code for this from the compiler */
; 3458 : 		if (current_rule[in_rule_index] & BIN_DICT_MISS_FAIL)

  01cf0	8a 0c 30	 mov	 cl, BYTE PTR [eax+esi]
  01cf3	f6 c1 40	 test	 cl, 64			; 00000040H

; 3459 : 		{
; 3460 : 			ret_value->value=FAIL;
; 3461 : 			if (ret_value->optional==1)
; 3462 : 			{
; 3463 : #ifdef DEBUG
; 3464 : 				printf("par_dom_dict_search miss set optinal to -1\n");
; 3465 : #endif
; 3466 : //				ret_value->optional= -1;
; 3467 : 				ret_value->value=OPT_FAIL;
; 3468 : 				return;

  01cf6	75 94		 jne	 SHORT $L73056

; 3469 : 			}
; 3470 : #ifdef DEBUG
; 3471 : 			printf("leaving par_dom_dict_search because of a fail miss_action\n");
; 3472 : 			par_print_rule_error("",current_rule,ret_value->rule);
; 3473 : #endif
; 3474 : 			return;
; 3475 : 		}
; 3476 : 		ret_value->input_offset=0;	/* reset for rematching */
; 3477 : 		ret_value->output_offset=0; /* reset for rematching */
; 3478 : 		par_match_rule(current_rule,BIN_COPY,input_array,output_array,input_indexes,output_indexes,match_array,ret_value,dict_state_flag);

  01cf8	8b 4c 24 20	 mov	 ecx, DWORD PTR _input_indexes$[esp+12]
  01cfc	89 55 04	 mov	 DWORD PTR [ebp+4], edx
  01cff	89 55 0c	 mov	 DWORD PTR [ebp+12], edx
  01d02	52		 push	 edx
  01d03	8b 54 24 28	 mov	 edx, DWORD PTR _output_indexes$[esp+16]
  01d07	55		 push	 ebp
  01d08	53		 push	 ebx
  01d09	52		 push	 edx
  01d0a	8b 54 24 2c	 mov	 edx, DWORD PTR _output_array$[esp+28]
  01d0e	51		 push	 ecx
  01d0f	8b 4c 24 2c	 mov	 ecx, DWORD PTR _input_array$[esp+32]
  01d13	52		 push	 edx
  01d14	51		 push	 ecx
  01d15	6a 14		 push	 20			; 00000014H
  01d17	50		 push	 eax
  01d18	e8 00 00 00 00	 call	 _par_match_rule
  01d1d	83 c4 24	 add	 esp, 36			; 00000024H
$L72089:
  01d20	5f		 pop	 edi
  01d21	5e		 pop	 esi
  01d22	5d		 pop	 ebp
  01d23	5b		 pop	 ebx

; 3479 : 	}       
; 3480 : #ifdef DEBUG
; 3481 : 	printf("leaving par_dom_dict_search\n");
; 3482 : 	par_print_rule_error("",current_rule,ret_value->rule);
; 3483 : #endif
; 3484 : }

  01d24	c3		 ret	 0
_par_dom_dict_search ENDP
_TEXT	ENDS
PUBLIC	_par_look_ahead_dictionary
_TEXT	SEGMENT
_current_rule$ = 8
_input_array$ = 12
_match_array$ = 16
_ret_value$ = 20
_temp_output$ = -700
_temp_indexes$ = -600
_par_look_ahead_dictionary PROC NEAR

; 3512 : {           

  01d30	81 ec bc 02 00
	00		 sub	 esp, 700		; 000002bcH

; 3513 : 	unsigned char temp_output[100];
; 3514 : 	index_data_t temp_indexes[100]; 
; 3515 : #ifdef DEBUG
; 3516 : 	printf("entering par_look_ahead_dictionary\n");
; 3517 : #endif
; 3518 : 	ret_value->output_pos=0;

  01d36	33 c0		 xor	 eax, eax

; 3519 : 	ret_value->output_offset=0;
; 3520 : 	ret_value->value=SUCCESS;	
; 3521 : 	par_match_rule(current_rule,BIN_DICTIONARY,input_array,temp_output,temp_indexes,temp_indexes,match_array,ret_value,1);

  01d38	8d 4c 24 64	 lea	 ecx, DWORD PTR _temp_indexes$[esp+700]
  01d3c	8d 54 24 64	 lea	 edx, DWORD PTR _temp_indexes$[esp+700]
  01d40	56		 push	 esi
  01d41	8b b4 24 d0 02
	00 00		 mov	 esi, DWORD PTR _ret_value$[esp+700]
  01d48	6a 01		 push	 1
  01d4a	56		 push	 esi
  01d4b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  01d4e	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  01d51	8b 84 24 d4 02
	00 00		 mov	 eax, DWORD PTR _match_array$[esp+708]
  01d58	c7 46 14 01 00
	00 00		 mov	 DWORD PTR [esi+20], 1
  01d5f	50		 push	 eax
  01d60	51		 push	 ecx
  01d61	8b 8c 24 d8 02
	00 00		 mov	 ecx, DWORD PTR _input_array$[esp+716]
  01d68	8d 44 24 14	 lea	 eax, DWORD PTR _temp_output$[esp+720]
  01d6c	52		 push	 edx
  01d6d	8b 94 24 d8 02
	00 00		 mov	 edx, DWORD PTR _current_rule$[esp+720]
  01d74	50		 push	 eax
  01d75	51		 push	 ecx
  01d76	6a 1d		 push	 29			; 0000001dH
  01d78	52		 push	 edx
  01d79	e8 00 00 00 00	 call	 _par_match_rule

; 3522 : 	if (ret_value->value==SUCCESS)

  01d7e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  01d81	83 c4 24	 add	 esp, 36			; 00000024H
  01d84	33 c0		 xor	 eax, eax
  01d86	83 f9 01	 cmp	 ecx, 1
  01d89	0f 94 c0	 sete	 al
  01d8c	5e		 pop	 esi

; 3523 : 	{
; 3524 : #ifdef DEBUG
; 3525 : 		printf("leaving par_look_ahead_dictionary success\n");
; 3526 : #endif
; 3527 : 		return(1);
; 3528 : 	}
; 3529 : #ifdef DEBUG
; 3530 : 	printf("leaving par_look_ahead_dictionary failure\n");
; 3531 : #endif                                                    
; 3532 : 	return(0);
; 3533 : }

  01d8d	81 c4 bc 02 00
	00		 add	 esp, 700		; 000002bcH
  01d93	c3		 ret	 0
_par_look_ahead_dictionary ENDP
_TEXT	ENDS
EXTRN	_dict_point:BYTE
EXTRN	_dict_index_table:BYTE
EXTRN	_dict_data_table:BYTE
EXTRN	__imp___stricmp:NEAR
_TEXT	SEGMENT
_input$ = 8
_input_length$ = 12
_output$ = 16
_dict_num$ = 20
_dict_state_flag$ = 24
_high$ = 20
_pos$ = 8
_value$ = 8
_rev_same$ = 20
_npos$ = 8
_par_search_for_word PROC NEAR

; 3566 : 	int high,low,pos;
; 3567 : 	int dict_number;
; 3568 : 	int value;
; 3569 : 	int rev_same=0,for_same=0,npos;
; 3570 : 	int save_for;
; 3571 : #ifdef DEBUG
; 3572 : 	printf("entering par_search_for_word\n");
; 3573 : #endif                        
; 3574 : 	dict_number=dict_num-1;	

  01da0	8b 44 24 10	 mov	 eax, DWORD PTR _dict_num$[esp-4]
  01da4	53		 push	 ebx
  01da5	55		 push	 ebp
  01da6	56		 push	 esi

; 3575 : 	low=dict_point[dict_number].start;

  01da7	8b 1c c5 f8 ff
	ff ff		 mov	 ebx, DWORD PTR _dict_point[eax*8-8]

; 3576 : 	rev_same=low;
; 3577 : 	high=dict_point[dict_number].end;

  01dae	8b 0c c5 fc ff
	ff ff		 mov	 ecx, DWORD PTR _dict_point[eax*8-4]
  01db5	57		 push	 edi

; 3578 : 	for_same=high;
; 3579 : 	while (rev_same<=for_same)

  01db6	3b d9		 cmp	 ebx, ecx
  01db8	8b fb		 mov	 edi, ebx
  01dba	89 4c 24 20	 mov	 DWORD PTR _high$[esp+12], ecx
  01dbe	8b e9		 mov	 ebp, ecx
  01dc0	7f 50		 jg	 SHORT $L73076
$L72125:

; 3580 : 	{
; 3581 : 		pos=((rev_same+for_same)>>1); /* divide the offset by 2 */

  01dc2	8d 34 2f	 lea	 esi, DWORD PTR [edi+ebp]

; 3582 : #ifdef DEBUG
; 3583 : 		printf("comparing %s to %d %s\n",input,pos,(unsigned char *)(dict_data_table+dict_index_table[pos]));
; 3584 : #endif
; 3585 : 		if ((value=_stricmp(input,(unsigned char *)(dict_data_table+dict_index_table[pos])))==0)

  01dc5	8b 4c 24 14	 mov	 ecx, DWORD PTR _input$[esp+12]
  01dc9	d1 fe		 sar	 esi, 1
  01dcb	8b 04 b5 00 00
	00 00		 mov	 eax, DWORD PTR _dict_index_table[esi*4]
  01dd2	05 00 00 00 00	 add	 eax, OFFSET FLAT:_dict_data_table
  01dd7	50		 push	 eax
  01dd8	51		 push	 ecx
  01dd9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___stricmp
  01ddf	83 c4 08	 add	 esp, 8
  01de2	85 c0		 test	 eax, eax
  01de4	74 0e		 je	 SHORT $L73078

; 3586 : 		{
; 3587 : 			break;
; 3588 : 		}
; 3589 : 		else
; 3590 : 		{
; 3591 : 			if (value<0)

  01de6	7d 05		 jge	 SHORT $L72130

; 3592 : 			{
; 3593 : 				for_same=pos-1;;

  01de8	8d 6e ff	 lea	 ebp, DWORD PTR [esi-1]

; 3594 : 			}
; 3595 : 			else

  01deb	eb 03		 jmp	 SHORT $L72131
$L72130:

; 3596 : 			{
; 3597 : 				rev_same=pos+1;

  01ded	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]
$L72131:

; 3578 : 	for_same=high;
; 3579 : 	while (rev_same<=for_same)

  01df0	3b fd		 cmp	 edi, ebp
  01df2	7e ce		 jle	 SHORT $L72125
$L73078:
  01df4	8b 4c 24 20	 mov	 ecx, DWORD PTR _high$[esp+12]
$L73064:

; 3598 : 			}
; 3599 : 		}
; 3600 : 	}
; 3601 : 	if (dict_state_flag)

  01df8	8b 54 24 24	 mov	 edx, DWORD PTR _dict_state_flag$[esp+12]
  01dfc	85 d2		 test	 edx, edx
  01dfe	74 1c		 je	 SHORT $L72133

; 3602 : 	{
; 3603 : 		if (value==0)

  01e00	85 c0		 test	 eax, eax
  01e02	0f 85 82 01 00
	00		 jne	 $L73069
  01e08	5f		 pop	 edi
  01e09	5e		 pop	 esi
  01e0a	5d		 pop	 ebp

; 3604 : 		{
; 3605 : #ifdef DEBUG
; 3606 : 			printf("leaving par_search_for_word in dict and short search\n");
; 3607 : #endif
; 3608 : 			return(1);

  01e0b	b8 01 00 00 00	 mov	 eax, 1
  01e10	5b		 pop	 ebx

; 3687 : #ifdef DEBUG
; 3688 : 	printf("leaving par_search_for_word failure\n");
; 3689 : #endif
; 3690 : }

  01e11	c3		 ret	 0
$L73076:

; 3578 : 	for_same=high;
; 3579 : 	while (rev_same<=for_same)

  01e12	8b 74 24 14	 mov	 esi, DWORD PTR _pos$[esp+12]
  01e16	8b 44 24 14	 mov	 eax, DWORD PTR _value$[esp+12]
  01e1a	eb dc		 jmp	 SHORT $L73064
$L72133:

; 3609 : 		}
; 3610 : 	}                                    
; 3611 : 	if (value!=0)

  01e1c	85 c0		 test	 eax, eax

; 3612 : 	{
; 3613 : #ifdef DEBUG
; 3614 : 		printf("leaving par_search_for_word not in dic\n");
; 3615 : #endif
; 3616 : 		return(0);

  01e1e	0f 85 66 01 00
	00		 jne	 $L73069

; 3617 : 	}
; 3618 : 	/* do the case sensitive part of the search */
; 3619 : 	rev_same=pos-1;

  01e24	8d 6e ff	 lea	 ebp, DWORD PTR [esi-1]

; 3620 : 	while ((rev_same>=low) && (_stricmp(input,(unsigned char *)(dict_data_table+dict_index_table[rev_same]))==0))

  01e27	3b eb		 cmp	 ebp, ebx
  01e29	7c 2e		 jl	 SHORT $L72138

; 3617 : 	}
; 3618 : 	/* do the case sensitive part of the search */
; 3619 : 	rev_same=pos-1;

  01e2b	8d 3c ad 00 00
	00 00		 lea	 edi, DWORD PTR _dict_index_table[ebp*4]
$L72137:

; 3620 : 	while ((rev_same>=low) && (_stricmp(input,(unsigned char *)(dict_data_table+dict_index_table[rev_same]))==0))

  01e32	8b 17		 mov	 edx, DWORD PTR [edi]
  01e34	8b 44 24 14	 mov	 eax, DWORD PTR _input$[esp+12]
  01e38	81 c2 00 00 00
	00		 add	 edx, OFFSET FLAT:_dict_data_table
  01e3e	52		 push	 edx
  01e3f	50		 push	 eax
  01e40	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___stricmp
  01e46	83 c4 08	 add	 esp, 8
  01e49	85 c0		 test	 eax, eax
  01e4b	75 08		 jne	 SHORT $L73080

; 3621 : 	{
; 3622 : 		rev_same--;

  01e4d	4d		 dec	 ebp
  01e4e	83 ef 04	 sub	 edi, 4
  01e51	3b eb		 cmp	 ebp, ebx
  01e53	7d dd		 jge	 SHORT $L72137
$L73080:

; 3620 : 	while ((rev_same>=low) && (_stricmp(input,(unsigned char *)(dict_data_table+dict_index_table[rev_same]))==0))

  01e55	8b 4c 24 20	 mov	 ecx, DWORD PTR _high$[esp+12]
$L72138:

; 3623 : 	}                  
; 3624 : 	for_same=pos+1;

  01e59	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]

; 3625 : 	/* BATS 895 Fixed problem with spanish phone numbers with 9 */
; 3626 : 	while ((for_same<=high) && (_stricmp(input,(unsigned char *)(dict_data_table+dict_index_table[for_same]))==0))

  01e5c	3b f9		 cmp	 edi, ecx
  01e5e	7f 2e		 jg	 SHORT $L72142

; 3623 : 	}                  
; 3624 : 	for_same=pos+1;

  01e60	8d 34 bd 00 00
	00 00		 lea	 esi, DWORD PTR _dict_index_table[edi*4]
$L72141:

; 3625 : 	/* BATS 895 Fixed problem with spanish phone numbers with 9 */
; 3626 : 	while ((for_same<=high) && (_stricmp(input,(unsigned char *)(dict_data_table+dict_index_table[for_same]))==0))

  01e67	8b 0e		 mov	 ecx, DWORD PTR [esi]
  01e69	8b 54 24 14	 mov	 edx, DWORD PTR _input$[esp+12]
  01e6d	81 c1 00 00 00
	00		 add	 ecx, OFFSET FLAT:_dict_data_table
  01e73	51		 push	 ecx
  01e74	52		 push	 edx
  01e75	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___stricmp
  01e7b	83 c4 08	 add	 esp, 8
  01e7e	85 c0		 test	 eax, eax
  01e80	75 0c		 jne	 SHORT $L72142
  01e82	8b 44 24 20	 mov	 eax, DWORD PTR _high$[esp+12]

; 3627 : 	{
; 3628 : 		for_same++;

  01e86	47		 inc	 edi
  01e87	83 c6 04	 add	 esi, 4
  01e8a	3b f8		 cmp	 edi, eax
  01e8c	7e d9		 jle	 SHORT $L72141
$L72142:

; 3629 : 	}                  
; 3630 : 	rev_same++;

  01e8e	45		 inc	 ebp

; 3631 : 	for_same--;    

  01e8f	4f		 dec	 edi

; 3632 : 	low=rev_same;
; 3633 : 	save_for=for_same;	/* take the last insensitive match, it will be lower case it any are */
; 3634 : 	while ((for_same!=rev_same) && !(parser_char_types[dict_data_table[dict_index_table[for_same]]] & TYPE_upper))

  01e90	3b fd		 cmp	 edi, ebp
  01e92	89 6c 24 20	 mov	 DWORD PTR _rev_same$[esp+12], ebp
  01e96	8b cf		 mov	 ecx, edi
  01e98	74 2b		 je	 SHORT $L73070
  01e9a	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR _dict_index_table[edi*4]
  01ea1	ba 02 00 00 00	 mov	 edx, 2
  01ea6	89 44 24 24	 mov	 DWORD PTR 24+[esp+12], eax
$L72144:
  01eaa	8b 30		 mov	 esi, DWORD PTR [eax]
  01eac	33 db		 xor	 ebx, ebx
  01eae	8a 9e 00 00 00
	00		 mov	 bl, BYTE PTR _dict_data_table[esi]
  01eb4	84 14 5d 00 00
	00 00		 test	 BYTE PTR _parser_char_types[ebx*2], dl
  01ebb	75 43		 jne	 SHORT $L72145

; 3635 : 	{
; 3636 : 		for_same--;

  01ebd	4f		 dec	 edi
  01ebe	83 e8 04	 sub	 eax, 4
  01ec1	3b fd		 cmp	 edi, ebp
  01ec3	75 e5		 jne	 SHORT $L72144
$L73070:

; 3669 : 			{
; 3670 : #ifdef DEBUG
; 3671 : 				printf("leaving par_dom_dict_search capitilization doesn't match\n");
; 3672 : #endif
; 3673 : 				return(0);
; 3674 : 			}
; 3675 : 		}
; 3676 : 	}
; 3677 : 	if (value==0)
; 3678 : 	{
; 3679 : //		strcpy(output,((unsigned char *)(dict_data_table+dict_index_table[save_for]))+(strlen((unsigned char *)(dict_data_table+dict_index_table[save_for]))+1));
; 3680 : 		strcpy(output,((unsigned char *)(dict_data_table+dict_index_table[save_for]))+(input_length+1));

  01ec5	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _dict_index_table[ecx*4]
  01ecc	8b 54 24 18	 mov	 edx, DWORD PTR _input_length$[esp+12]
  01ed0	33 c0		 xor	 eax, eax
  01ed2	8d bc 11 01 00
	00 00		 lea	 edi, DWORD PTR _dict_data_table[ecx+edx+1]
  01ed9	83 c9 ff	 or	 ecx, -1
  01edc	f2 ae		 repne scasb
  01ede	f7 d1		 not	 ecx
  01ee0	2b f9		 sub	 edi, ecx
  01ee2	8b c1		 mov	 eax, ecx
  01ee4	8b f7		 mov	 esi, edi
  01ee6	8b 7c 24 1c	 mov	 edi, DWORD PTR _output$[esp+12]
  01eea	c1 e9 02	 shr	 ecx, 2
  01eed	f3 a5		 rep movsd
  01eef	8b c8		 mov	 ecx, eax

; 3681 : #ifdef DEBUG
; 3682 : 		printf("leaving par_search_for_word success\n");
; 3683 : #endif
; 3684 : 		return(1);

  01ef1	b8 01 00 00 00	 mov	 eax, 1
  01ef6	83 e1 03	 and	 ecx, 3
  01ef9	f3 a4		 rep movsb
  01efb	5f		 pop	 edi
  01efc	5e		 pop	 esi
  01efd	5d		 pop	 ebp
  01efe	5b		 pop	 ebx

; 3687 : #ifdef DEBUG
; 3688 : 	printf("leaving par_search_for_word failure\n");
; 3689 : #endif
; 3690 : }

  01eff	c3		 ret	 0
$L72145:

; 3637 : 	}
; 3638 : 	if (rev_same!=for_same)

  01f00	3b ef		 cmp	 ebp, edi
  01f02	74 c1		 je	 SHORT $L73070

; 3639 : 	{
; 3640 : 		while (rev_same<=for_same)

  01f04	7f 64		 jg	 SHORT $L73077
  01f06	eb 04		 jmp	 SHORT $L72148
$L73082:
  01f08	8b 6c 24 20	 mov	 ebp, DWORD PTR _rev_same$[esp+12]
$L72148:

; 3641 : 		{
; 3642 : 			npos=((rev_same+for_same)>>1); /* divide the offset by 2 */
; 3643 : #ifdef DEBUG
; 3644 : 			printf("comapring case %s to %d %s\n",input,npos,(unsigned char *)(dict_data_table+dict_index_table[npos]));
; 3645 : #endif
; 3646 : 			if ((value=strcmp(input,(unsigned char *)(dict_data_table+dict_index_table[npos])))==0)

  01f0c	8b 74 24 14	 mov	 esi, DWORD PTR _input$[esp+12]
  01f10	03 ef		 add	 ebp, edi
  01f12	d1 fd		 sar	 ebp, 1
  01f14	8b 04 ad 00 00
	00 00		 mov	 eax, DWORD PTR _dict_index_table[ebp*4]
  01f1b	05 00 00 00 00	 add	 eax, OFFSET FLAT:_dict_data_table
$L73072:
  01f20	8a 1e		 mov	 bl, BYTE PTR [esi]
  01f22	8a cb		 mov	 cl, bl
  01f24	3a 18		 cmp	 bl, BYTE PTR [eax]
  01f26	75 1a		 jne	 SHORT $L73073
  01f28	84 c9		 test	 cl, cl
  01f2a	74 12		 je	 SHORT $L73074
  01f2c	8a 5e 01	 mov	 bl, BYTE PTR [esi+1]
  01f2f	8a cb		 mov	 cl, bl
  01f31	3a 58 01	 cmp	 bl, BYTE PTR [eax+1]
  01f34	75 0c		 jne	 SHORT $L73073
  01f36	03 f2		 add	 esi, edx
  01f38	03 c2		 add	 eax, edx
  01f3a	84 c9		 test	 cl, cl
  01f3c	75 e2		 jne	 SHORT $L73072
$L73074:
  01f3e	33 c0		 xor	 eax, eax
  01f40	eb 05		 jmp	 SHORT $L73075
$L73073:
  01f42	1b c0		 sbb	 eax, eax
  01f44	83 d8 ff	 sbb	 eax, -1
$L73075:
  01f47	85 c0		 test	 eax, eax
  01f49	74 23		 je	 SHORT $L73071

; 3647 : 			{
; 3648 : 				break;
; 3649 : 			}
; 3650 : 			else
; 3651 : 			{
; 3652 : 				if (value<0)

  01f4b	7d 05		 jge	 SHORT $L72153

; 3653 : 				{
; 3654 : 					for_same=npos-1;

  01f4d	8d 7d ff	 lea	 edi, DWORD PTR [ebp-1]

; 3655 : 				}
; 3656 : 				else

  01f50	eb 07		 jmp	 SHORT $L72154
$L72153:

; 3657 : 				{
; 3658 : 					rev_same=npos+1;

  01f52	8d 4d 01	 lea	 ecx, DWORD PTR [ebp+1]
  01f55	89 4c 24 20	 mov	 DWORD PTR _rev_same$[esp+12], ecx
$L72154:
  01f59	39 7c 24 20	 cmp	 DWORD PTR _rev_same$[esp+12], edi
  01f5d	7e a9		 jle	 SHORT $L73082

; 3659 : 				}
; 3660 : 			}
; 3661 : 		}
; 3662 : 		if (value==0)

  01f5f	85 c0		 test	 eax, eax
  01f61	75 12		 jne	 SHORT $L72155

; 3663 : 		{
; 3664 : 			save_for=npos;

  01f63	8b cd		 mov	 ecx, ebp

; 3665 : 		}
; 3666 : 		else

  01f65	e9 5b ff ff ff	 jmp	 $L73070
$L73077:

; 3659 : 				}
; 3660 : 			}
; 3661 : 		}
; 3662 : 		if (value==0)

  01f6a	8b 6c 24 14	 mov	 ebp, DWORD PTR _npos$[esp+12]
$L73071:

; 3663 : 		{
; 3664 : 			save_for=npos;

  01f6e	8b cd		 mov	 ecx, ebp

; 3665 : 		}
; 3666 : 		else

  01f70	e9 50 ff ff ff	 jmp	 $L73070
$L72155:

; 3667 : 		{
; 3668 : 			if ((parser_char_types[dict_data_table[dict_index_table[save_for]]] & TYPE_upper))

  01f75	8b 44 24 24	 mov	 eax, DWORD PTR 24+[esp+12]
  01f79	8b 08		 mov	 ecx, DWORD PTR [eax]
  01f7b	33 c0		 xor	 eax, eax
  01f7d	8a 81 00 00 00
	00		 mov	 al, BYTE PTR _dict_data_table[ecx]
  01f83	8a 0c 45 00 00
	00 00		 mov	 cl, BYTE PTR _parser_char_types[eax*2]
$L73069:
  01f8a	5f		 pop	 edi
  01f8b	5e		 pop	 esi
  01f8c	5d		 pop	 ebp

; 3685 : 	}             
; 3686 : 	return(0);

  01f8d	33 c0		 xor	 eax, eax
  01f8f	5b		 pop	 ebx

; 3687 : #ifdef DEBUG
; 3688 : 	printf("leaving par_search_for_word failure\n");
; 3689 : #endif
; 3690 : }

  01f90	c3		 ret	 0
_par_search_for_word ENDP
_output_array$ = 16
_ret_value$ = 32
_par_check_word_string PROC NEAR

; 3729 : 	register int i;
; 3730 : 	int has_cons=0,has_vowel=0;
; 3731 : 	int temp;
; 3732 : #ifdef DEBUG
; 3733 : 	printf("entering par_check_word_string\n");
; 3734 : #endif
; 3735 : 	/*
; 3736 : 	*	check the inputs for valid data 
; 3737 : 	*/
; 3738 : #ifdef SANITY_CHECKING
; 3739 : 	if (ret_value==NULL)
; 3740 : 	{
; 3741 : #ifdef DEBUG
; 3742 : 		printf("leaving par_check_word_string ret_value is NULL\n");
; 3743 : #endif
; 3744 : 		return;
; 3745 : 	}
; 3746 : 	if ((output_array==NULL))
; 3747 : 	{
; 3748 : 		ret_value->value=FATAL_FAIL;
; 3749 : #ifdef DEBUG
; 3750 : 		printf("leaving par_check_word_string input is NULL\n");
; 3751 : #endif
; 3752 : 		return;
; 3753 : 	}                 
; 3754 : #endif
; 3755 : 	i=ret_value->output_pos;		

  01fa0	8b 54 24 1c	 mov	 edx, DWORD PTR _ret_value$[esp-4]
  01fa4	53		 push	 ebx
  01fa5	55		 push	 ebp
  01fa6	56		 push	 esi
  01fa7	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  01faa	57		 push	 edi

; 3756 : 	/* BATS 874 MGS 03/03/1999 fixed word state */
; 3757 : 	while (i<(ret_value->output_offset+ret_value->output_pos) && ((has_cons & has_vowel)==0))

  01fab	8b 7a 0c	 mov	 edi, DWORD PTR [edx+12]
  01fae	33 f6		 xor	 esi, esi
  01fb0	03 f9		 add	 edi, ecx
  01fb2	33 ed		 xor	 ebp, ebp
  01fb4	3b cf		 cmp	 ecx, edi
  01fb6	7d 44		 jge	 SHORT $L72197
$L72190:
  01fb8	85 ee		 test	 ebp, esi
  01fba	75 32		 jne	 SHORT $L72191

; 3758 : 	{
; 3759 : 		temp=parser_char_types[output_array[i]];

  01fbc	8b 5c 24 1c	 mov	 ebx, DWORD PTR _output_array$[esp+12]
  01fc0	33 c0		 xor	 eax, eax
  01fc2	8a 04 19	 mov	 al, BYTE PTR [ecx+ebx]
  01fc5	8b d8		 mov	 ebx, eax
  01fc7	33 c0		 xor	 eax, eax
  01fc9	66 8b 04 5d 00
	00 00 00	 mov	 ax, WORD PTR _parser_char_types[ebx*2]

; 3760 : 		if (temp & TYPE_consonant)

  01fd1	f6 c4 02	 test	 ah, 2
  01fd4	74 05		 je	 SHORT $L72192

; 3761 : 		{
; 3762 : 			has_cons=1;

  01fd6	be 01 00 00 00	 mov	 esi, 1
$L72192:

; 3763 : 		}
; 3764 : 		if (temp & TYPE_vowel)

  01fdb	f6 c4 01	 test	 ah, 1
  01fde	74 05		 je	 SHORT $L72193

; 3765 : 		{
; 3766 : 			has_vowel=1;

  01fe0	bd 01 00 00 00	 mov	 ebp, 1
$L72193:

; 3767 : 		}                                
; 3768 : 		if ((temp & TYPE_alpha) == 0)

  01fe5	a8 08		 test	 al, 8
  01fe7	74 26		 je	 SHORT $L73086

; 3771 : 			{
; 3772 : 				ret_value->value=OPT_FAIL;
; 3773 : 			}
; 3774 : 			else
; 3775 : 			{	
; 3776 : 				ret_value->value=FAIL;
; 3777 : 			}
; 3778 : #ifdef DEBUG
; 3779 : 			printf("the output is not a word\n");
; 3780 : #endif
; 3781 : 			return;
; 3782 : 		}			
; 3783 : 		i++;

  01fe9	41		 inc	 ecx
  01fea	3b cf		 cmp	 ecx, edi
  01fec	7c ca		 jl	 SHORT $L72190
$L72191:

; 3784 : 	}
; 3785 : 	/* BATS 874 MGS 03/03/1999 fixed word state */
; 3786 : 	if (has_cons && has_vowel && (ret_value->output_offset)>=2)

  01fee	85 f6		 test	 esi, esi
  01ff0	74 0a		 je	 SHORT $L72197
  01ff2	85 ed		 test	 ebp, ebp
  01ff4	74 06		 je	 SHORT $L72197
  01ff6	83 7a 0c 02	 cmp	 DWORD PTR [edx+12], 2
  01ffa	7d 2d		 jge	 SHORT $L72200
$L72197:

; 3787 : 	{
; 3788 : #ifdef DEBUG
; 3789 : 		printf("the output may be a word\n");
; 3790 : #endif
; 3791 : 	}         
; 3792 : 	else
; 3793 : 	{
; 3794 : 		if (ret_value->optional)

  01ffc	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  01fff	85 c0		 test	 eax, eax
  02001	74 1f		 je	 SHORT $L72195
  02003	5f		 pop	 edi
  02004	5e		 pop	 esi
  02005	5d		 pop	 ebp

; 3795 : 		{
; 3796 : 			ret_value->value=OPT_FAIL;

  02006	c7 42 14 02 00
	00 00		 mov	 DWORD PTR [edx+20], 2
  0200d	5b		 pop	 ebx

; 3801 : 		}
; 3802 : #ifdef DEBUG
; 3803 : 		printf("the output is not a word\n");
; 3804 : #endif
; 3805 : 	}
; 3806 : #ifdef DEBUG
; 3807 : 	printf("leaving par_check_word_string\n");
; 3808 : #endif
; 3809 : 	return;
; 3810 : }

  0200e	c3		 ret	 0
$L73086:

; 3769 : 		{
; 3770 : 			if (ret_value->optional)

  0200f	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  02012	85 c0		 test	 eax, eax
  02014	74 0c		 je	 SHORT $L72195
  02016	5f		 pop	 edi
  02017	5e		 pop	 esi
  02018	5d		 pop	 ebp

; 3795 : 		{
; 3796 : 			ret_value->value=OPT_FAIL;

  02019	c7 42 14 02 00
	00 00		 mov	 DWORD PTR [edx+20], 2
  02020	5b		 pop	 ebx

; 3801 : 		}
; 3802 : #ifdef DEBUG
; 3803 : 		printf("the output is not a word\n");
; 3804 : #endif
; 3805 : 	}
; 3806 : #ifdef DEBUG
; 3807 : 	printf("leaving par_check_word_string\n");
; 3808 : #endif
; 3809 : 	return;
; 3810 : }

  02021	c3		 ret	 0
$L72195:

; 3797 : 		}
; 3798 : 		else
; 3799 : 		{	
; 3800 : 			ret_value->value=FAIL;

  02022	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0
$L72200:
  02029	5f		 pop	 edi
  0202a	5e		 pop	 esi
  0202b	5d		 pop	 ebp
  0202c	5b		 pop	 ebx

; 3801 : 		}
; 3802 : #ifdef DEBUG
; 3803 : 		printf("the output is not a word\n");
; 3804 : #endif
; 3805 : 	}
; 3806 : #ifdef DEBUG
; 3807 : 	printf("leaving par_check_word_string\n");
; 3808 : #endif
; 3809 : 	return;
; 3810 : }

  0202d	c3		 ret	 0
_par_check_word_string ENDP
_TEXT	ENDS
EXTRN	__imp__atoi:NEAR
_TEXT	SEGMENT
_current_rule$ = 8
_output_array$ = 16
_match_array$ = 28
_ret_value$ = 32
_range_value$ = 36
_in_rule_index$ = 48
_length$ = -16
_buf$ = -12
_par_status_string PROC NEAR

; 3829 : {

  02030	83 ec 10	 sub	 esp, 16			; 00000010H

; 3830 : 	int length=0;
; 3831 : 	unsigned char buf[10];
; 3832 : 
; 3833 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_STATUS,&length,in_rule_index);

  02033	8b 44 24 3c	 mov	 eax, DWORD PTR _in_rule_index$[esp+12]
  02037	8b 54 24 30	 mov	 edx, DWORD PTR _range_value$[esp+12]
  0203b	56		 push	 esi
  0203c	8b 74 24 30	 mov	 esi, DWORD PTR _ret_value$[esp+16]
  02040	8d 4c 24 04	 lea	 ecx, DWORD PTR _length$[esp+20]
  02044	50		 push	 eax
  02045	8b 44 24 30	 mov	 eax, DWORD PTR _match_array$[esp+20]
  02049	51		 push	 ecx
  0204a	8b 4c 24 28	 mov	 ecx, DWORD PTR _output_array$[esp+24]
  0204e	6a 1e		 push	 30			; 0000001eH
  02050	52		 push	 edx
  02051	56		 push	 esi
  02052	50		 push	 eax
  02053	8b 44 24 30	 mov	 eax, DWORD PTR _current_rule$[esp+40]
  02057	8d 54 24 20	 lea	 edx, DWORD PTR _buf$[esp+44]
  0205b	51		 push	 ecx
  0205c	52		 push	 edx
  0205d	50		 push	 eax
  0205e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _length$[esp+56], 0
  02066	e8 00 00 00 00	 call	 _par_build_string_from_rule

; 3834 : 	ret_value->parser_flag = atoi(buf);

  0206b	8d 4c 24 2c	 lea	 ecx, DWORD PTR _buf$[esp+56]
  0206f	51		 push	 ecx
  02070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  02076	83 c4 28	 add	 esp, 40			; 00000028H
  02079	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  0207c	5e		 pop	 esi

; 3835 : }

  0207d	83 c4 10	 add	 esp, 16			; 00000010H
  02080	c3		 ret	 0
_par_status_string ENDP
_TEXT	ENDS
PUBLIC	_par_convert_number_new2
_TEXT	SEGMENT
_current_rule$ = 8
_buf$ = 12
_output_array$ = 16
_match_array$ = 20
_ret_value$ = 24
_range_value$ = 28
_state$ = 32
_length$ = 36
_in_rule_index$ = 40
_buf_ind$ = -8
_end_of_action$ = -4
_end_of_build$ = 8
_par_build_string_from_rule PROC NEAR

; 3887 : {

  02090	83 ec 08	 sub	 esp, 8
  02093	53		 push	 ebx
  02094	55		 push	 ebp

; 3888 : 	int is_cond=0;						/* is the current replacement conditional */
; 3889 : 	int cond_num=0;						/* what number conditioal thing to replace with */
; 3890 : 	int rule_p;							/* a temporary rule pointer */
; 3891 : 	int buf_ind=0;						/* the current index into the temp buffer */
; 3892 : 	int match_l=0;						/* the length of the string in the save array */
; 3893 : 	int match_num;						/* the index of the save array to be used */
; 3894 : 	U8 end_of_action;
; 3895 : 	U8 end_of_build;
; 3896 : 	
; 3897 : #ifdef DEBUG
; 3898 : 	printf("entering par_build_string_from_rule\n");
; 3899 : #endif
; 3900 : 	/*
; 3901 : 	*	check input values
; 3902 : 	*/
; 3903 : #ifdef SANITY_CHECKING
; 3904 : 	if (ret_value==NULL)
; 3905 : 	{
; 3906 : #ifdef DEBUG
; 3907 : 		printf("leaving par_build_string_from_rule ret_value is NULL\n");
; 3908 : #endif
; 3909 : 		return(NULL);
; 3910 : 	}
; 3911 : 	if ((current_rule==NULL) || (buf == NULL) || (match_array == NULL) ||
; 3912 : 		(state == BIN_END_OF_RULE) || (length==NULL))
; 3913 : 	{
; 3914 : #ifdef DEBUG
; 3915 : 		printf("leaving par_build_string_from_rule; inputs are invalid\n");
; 3916 : #endif
; 3917 : 		ret_value->value=FATAL_FAIL;
; 3918 : 		return(NULL);
; 3919 : 	}
; 3920 : #endif
; 3921 : 	
; 3922 : 	rule_p=ret_value->rule;
; 3923 : 	end_of_action=current_rule[in_rule_index+2];

  02095	8b 6c 24 14	 mov	 ebp, DWORD PTR _current_rule$[esp+12]
  02099	56		 push	 esi
  0209a	8b 74 24 38	 mov	 esi, DWORD PTR _in_rule_index$[esp+16]
  0209e	8b 4c 24 28	 mov	 ecx, DWORD PTR _ret_value$[esp+16]
  020a2	57		 push	 edi
  020a3	33 ff		 xor	 edi, edi
  020a5	8b 59 10	 mov	 ebx, DWORD PTR [ecx+16]
  020a8	8d 44 2e 02	 lea	 eax, DWORD PTR [esi+ebp+2]
  020ac	89 44 24 3c	 mov	 DWORD PTR 40+[esp+20], eax
  020b0	89 7c 24 10	 mov	 DWORD PTR _buf_ind$[esp+24], edi
  020b4	8a 00		 mov	 al, BYTE PTR [eax]
  020b6	88 44 24 14	 mov	 BYTE PTR _end_of_action$[esp+24], al

; 3924 : 	end_of_build=end_of_action;

  020ba	88 44 24 1c	 mov	 BYTE PTR _end_of_build$[esp+20], al

; 3925 : #ifdef DEBUG
; 3926 : 	printf("current_rule[%d]=%c\n",rule_p,current_rule[rule_p]);
; 3927 : 	if (current_rule[rule_p]==BIN_EXACT)
; 3928 : 		printf("found an exact character delimiter\n");
; 3929 : #endif
; 3930 : 	buf[0]='\0';	/* clear buf just in case */

  020be	8b 44 24 20	 mov	 eax, DWORD PTR _buf$[esp+20]
  020c2	c6 00 00	 mov	 BYTE PTR [eax], 0

; 3931 : 	/* build the string until a '/' is hit */
; 3932 : 	
; 3933 : 	if (current_rule[in_rule_index] & BIN_CONDITIONAL_REPLACE)

  020c5	8a 04 2e	 mov	 al, BYTE PTR [esi+ebp]
  020c8	a8 80		 test	 al, 128			; 00000080H
  020ca	0f 84 ed 00 00
	00		 je	 $L73094

; 3934 : 	{
; 3935 : 		is_cond=-1;
; 3936 : #ifndef GERMAN_COMPOUND_NOUNS
; 3937 : 		switch (state)
; 3938 : #else
; 3939 : 		switch(state & BIN_OPERATION_MASK)
; 3940 : #endif
; 3941 : 		{

  020d0	8b 44 24 34	 mov	 eax, DWORD PTR _state$[esp+20]
  020d4	8b d0		 mov	 edx, eax
  020d6	83 e2 1f	 and	 edx, 31			; 0000001fH
  020d9	80 fa 1a	 cmp	 dl, 26			; 0000001aH
  020dc	75 65		 jne	 SHORT $L72266

; 3942 : #ifndef GERMAN_COMPOUND_NOUNS
; 3943 : 			/* MGS fixed this, it was BIN_INSERT but it should be BIN_BEFORE */
; 3944 : 		case BIN_BEFORE:
; 3945 : #endif
; 3946 : #ifdef GERMAN_COMPOUND_NOUNS
; 3947 : 		case BIN_INSERT:
; 3948 : 			if (state & BIN_BEFORE_FLAG)

  020de	a8 20		 test	 al, 32			; 00000020H
  020e0	74 2d		 je	 SHORT $L72261

; 3949 : 			{
; 3950 : #endif
; 3951 : 			/* read the first character in the output range */
; 3952 : 			if (range_value->range_set==2)

  020e2	8b 44 24 30	 mov	 eax, DWORD PTR _range_value$[esp+20]
  020e6	83 78 0c 02	 cmp	 DWORD PTR [eax+12], 2
  020ea	75 07		 jne	 SHORT $L72262

; 3953 : 			{
; 3954 : 				cond_num=range_value->start;

  020ec	8b 00		 mov	 eax, DWORD PTR [eax]

; 3955 : 			}
; 3956 : 			else

  020ee	e9 88 00 00 00	 jmp	 $L72274
$L72262:

; 3957 : 			{
; 3958 : 				cond_num=output_array[ret_value->output_pos]-'0';

  020f3	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  020f6	8b 54 24 24	 mov	 edx, DWORD PTR _output_array$[esp+20]
  020fa	33 c9		 xor	 ecx, ecx
  020fc	8a 0c 10	 mov	 cl, BYTE PTR [eax+edx]
  020ff	8b c1		 mov	 eax, ecx
  02101	83 e8 30	 sub	 eax, 48			; 00000030H

; 3959 : 				if (cond_num<0 || cond_num>9)

  02104	78 39		 js	 SHORT $L72265
  02106	83 f8 09	 cmp	 eax, 9
  02109	7e 70		 jle	 SHORT $L72274

; 3960 : 					cond_num=0;

  0210b	33 c0		 xor	 eax, eax

; 3961 : 			}
; 3962 : 			break;

  0210d	eb 6c		 jmp	 SHORT $L72274
$L72261:

; 3963 : #ifndef GERMAN_COMPOUND_NOUNS
; 3964 : 		case BIN_AFTER:
; 3965 : #else
; 3966 : 			}
; 3967 : 			if (state & BIN_AFTER_FLAG)

  0210f	a8 40		 test	 al, 64			; 00000040H
  02111	74 30		 je	 SHORT $L72266

; 3968 : 			{
; 3969 : #endif
; 3970 : 			/* convert the last character in the range */
; 3971 : 			if (range_value->range_set==2)

  02113	8b 44 24 30	 mov	 eax, DWORD PTR _range_value$[esp+20]
  02117	83 78 0c 02	 cmp	 DWORD PTR [eax+12], 2
  0211b	75 04		 jne	 SHORT $L72267

; 3972 : 			{
; 3973 : 				cond_num=range_value->start;

  0211d	8b 00		 mov	 eax, DWORD PTR [eax]

; 3974 : 			}
; 3975 : 			else

  0211f	eb 5a		 jmp	 SHORT $L72274
$L72267:

; 3976 : 			{
; 3977 : 				cond_num=output_array[ret_value->output_pos+ret_value->output_offset-1]-'0';

  02121	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  02124	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  02127	03 c2		 add	 eax, edx
  02129	8b 54 24 24	 mov	 edx, DWORD PTR _output_array$[esp+20]
  0212d	33 c9		 xor	 ecx, ecx
  0212f	8a 4c 10 ff	 mov	 cl, BYTE PTR [eax+edx-1]
  02133	8b c1		 mov	 eax, ecx
  02135	83 e8 30	 sub	 eax, 48			; 00000030H

; 3978 : 				if (cond_num<0 || cond_num>9)

  02138	78 05		 js	 SHORT $L72265
  0213a	83 f8 09	 cmp	 eax, 9
  0213d	7e 3c		 jle	 SHORT $L72274
$L72265:

; 3979 : 					cond_num=0;

  0213f	33 c0		 xor	 eax, eax

; 3980 : 			}
; 3981 : 			break;

  02141	eb 38		 jmp	 SHORT $L72274
$L72266:

; 3982 : #ifdef GERMAN_COMPOUND_NOUNS
; 3983 : 			}
; 3984 : 			/* for GERMAN_COMPOUND_NOUNS, it is intended to not have a break after 
; 3985 : 			   the case for BIN_INSERT so it can do the right thing */
; 3986 : #endif
; 3987 : 
; 3988 : 		default:
; 3989 : 			if (range_value->range_set==2)

  02143	8b 44 24 30	 mov	 eax, DWORD PTR _range_value$[esp+20]
  02147	83 78 0c 02	 cmp	 DWORD PTR [eax+12], 2
  0214b	75 04		 jne	 SHORT $L72272

; 3990 : 			{
; 3991 : 				cond_num=range_value->start;

  0214d	8b 00		 mov	 eax, DWORD PTR [eax]

; 3992 : 			}
; 3993 : 			else

  0214f	eb 2a		 jmp	 SHORT $L72274
$L72272:

; 3994 : 			{
; 3995 : 				/* convert all the character in the range */
; 3996 : 				/*	a range_value->range_set == -1 cant have any fancy conditionals
; 3997 : 				so it just does the normal stuff of converting the digits
; 3998 : 				*/
; 3999 : 				output_array[ret_value->output_offset+ret_value->output_pos]='\0';

  02151	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  02154	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  02157	03 d0		 add	 edx, eax
  02159	8b 44 24 24	 mov	 eax, DWORD PTR _output_array$[esp+20]
  0215d	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 4000 : 				cond_num=par_convert_number_new2(output_array+ret_value->output_pos);

  02161	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  02164	03 c8		 add	 ecx, eax
  02166	51		 push	 ecx
  02167	e8 00 00 00 00	 call	 _par_convert_number_new2

; 4001 : 				if (range_value->range_set==1)

  0216c	8b 4c 24 34	 mov	 ecx, DWORD PTR _range_value$[esp+24]
  02170	83 c4 04	 add	 esp, 4
  02173	83 79 0c 01	 cmp	 DWORD PTR [ecx+12], 1
  02177	75 02		 jne	 SHORT $L72274

; 4002 : 				{
; 4003 : 					cond_num-=range_value->start;

  02179	2b 01		 sub	 eax, DWORD PTR [ecx]
$L72274:

; 4004 : 				}
; 4005 : 			}
; 4006 : 		}
; 4007 : 		if (cond_num > (current_rule[in_rule_index+3]))

  0217b	33 c9		 xor	 ecx, ecx
  0217d	8a 4c 2e 03	 mov	 cl, BYTE PTR [esi+ebp+3]
  02181	3b c1		 cmp	 eax, ecx

; 4008 : 		{
; 4009 : 			cond_num=0;
; 4010 : 		}
; 4011 : 		if (cond_num==0)

  02183	7f 04		 jg	 SHORT $L73095
  02185	85 c0		 test	 eax, eax
  02187	75 06		 jne	 SHORT $L72276
$L73095:

; 4012 : 		{
; 4013 : 			end_of_build=current_rule[in_rule_index+4];

  02189	8a 54 2e 04	 mov	 dl, BYTE PTR [esi+ebp+4]

; 4014 : 		}
; 4015 : 		else

  0218d	eb 26		 jmp	 SHORT $L73100
$L72276:

; 4016 : 		{
; 4017 : 			if (cond_num == (current_rule[in_rule_index+3]))

  0218f	3b c1		 cmp	 eax, ecx
  02191	75 15		 jne	 SHORT $L72278

; 4018 : 			{
; 4019 : 				rule_p=current_rule[in_rule_index+3+cond_num]+1;

  02193	03 c5		 add	 eax, ebp
  02195	33 db		 xor	 ebx, ebx
  02197	8a 5c 30 03	 mov	 bl, BYTE PTR [eax+esi+3]

; 4020 : 				end_of_build=current_rule[in_rule_index+2];

  0219b	8b 44 24 3c	 mov	 eax, DWORD PTR 40+[esp+20]
  0219f	43		 inc	 ebx
  021a0	8a 08		 mov	 cl, BYTE PTR [eax]
  021a2	88 4c 24 1c	 mov	 BYTE PTR _end_of_build$[esp+20], cl

; 4021 : 			}
; 4022 : 			else

  021a6	eb 11		 jmp	 SHORT $L73101
$L72278:

; 4023 : 			{
; 4024 : 				rule_p=current_rule[in_rule_index+3+cond_num]+1;

  021a8	03 c5		 add	 eax, ebp
  021aa	33 db		 xor	 ebx, ebx
  021ac	03 f0		 add	 esi, eax
  021ae	8a 5e 03	 mov	 bl, BYTE PTR [esi+3]

; 4025 : 				end_of_build=current_rule[in_rule_index+4+cond_num];

  021b1	8a 56 04	 mov	 dl, BYTE PTR [esi+4]
  021b4	43		 inc	 ebx
$L73100:
  021b5	88 54 24 1c	 mov	 BYTE PTR _end_of_build$[esp+20], dl
$L73101:
  021b9	8b 4c 24 2c	 mov	 ecx, DWORD PTR _ret_value$[esp+20]
$L73094:

; 4026 : 			}
; 4027 : 		}
; 4028 : 		
; 4029 : 	}
; 4030 : 	while (rule_p<=end_of_build)

  021bd	8b 44 24 1c	 mov	 eax, DWORD PTR _end_of_build$[esp+20]
  021c1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  021c6	3b d8		 cmp	 ebx, eax
  021c8	89 44 24 30	 mov	 DWORD PTR 28+[esp+20], eax
  021cc	0f 8f 9d 00 00
	00		 jg	 $L72282
$L72281:

; 4031 : 	{
; 4032 : 		/* build the string until either a slash is found or a conditional is found */
; 4033 : 		switch (current_rule[rule_p] & BIN_OPERATION_MASK)
; 4034 : 		{

  021d2	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  021d5	83 e0 1f	 and	 eax, 31			; 0000001fH
  021d8	83 e8 10	 sub	 eax, 16			; 00000010H
  021db	74 58		 je	 SHORT $L72287
  021dd	48		 dec	 eax
  021de	74 41		 je	 SHORT $L72289
  021e0	48		 dec	 eax
  021e1	0f 85 ac 00 00
	00		 jne	 $L72290

; 4042 : 			break;
; 4043 : 		case BIN_RESTORE:						/* a $# sequence was found. */
; 4044 : 			rule_p++;
; 4045 : 			match_num=current_rule[rule_p];
; 4046 : 			match_l=match_array->array_lengths[match_num];	/* get the length of the strig in the array */

  021e7	8b 74 24 28	 mov	 esi, DWORD PTR _match_array$[esp+20]
  021eb	43		 inc	 ebx
  021ec	33 c0		 xor	 eax, eax
  021ee	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  021f1	8b 14 86	 mov	 edx, DWORD PTR [esi+eax*4]

; 4047 : 			memcpy(buf+buf_ind,match_array->array[match_num],match_l);

  021f4	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  021f7	8b ca		 mov	 ecx, edx
  021f9	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  021fc	8d 74 46 28	 lea	 esi, DWORD PTR [esi+eax*2+40]
  02200	8b 44 24 20	 mov	 eax, DWORD PTR _buf$[esp+20]
  02204	03 f8		 add	 edi, eax
  02206	8b c1		 mov	 eax, ecx
  02208	c1 e9 02	 shr	 ecx, 2
  0220b	f3 a5		 rep movsd
  0220d	8b c8		 mov	 ecx, eax
  0220f	83 e1 03	 and	 ecx, 3
  02212	f3 a4		 rep movsb

; 4048 : 			buf_ind+=match_l;   		/* add the length of the string in the array to buff_ind */

  02214	8b 4c 24 10	 mov	 ecx, DWORD PTR _buf_ind$[esp+24]
  02218	03 ca		 add	 ecx, edx

; 4049 : 			rule_p++;

  0221a	43		 inc	 ebx
  0221b	89 4c 24 10	 mov	 DWORD PTR _buf_ind$[esp+24], ecx

; 4050 : 			break;

  0221f	eb 3a		 jmp	 SHORT $L73102
$L72289:

; 4051 : 		case BIN_HEXADECIMAL:
; 4052 : 			/* a hexadecimal value was found */
; 4053 : 			/* hexadecimal values have to be specified in the format 0xab */
; 4054 : 			/* they must have 2 legal letters after the x */
; 4055 : 			rule_p++;
; 4056 : 			buf[buf_ind]=current_rule[rule_p]; /* put the value into the buffer array */

  02221	8b 54 24 20	 mov	 edx, DWORD PTR _buf$[esp+20]
  02225	8a 4c 2b 01	 mov	 cl, BYTE PTR [ebx+ebp+1]
  02229	43		 inc	 ebx
  0222a	88 0c 17	 mov	 BYTE PTR [edi+edx], cl

; 4057 : 			buf_ind++;

  0222d	47		 inc	 edi
  0222e	89 7c 24 10	 mov	 DWORD PTR _buf_ind$[esp+24], edi

; 4058 : 			rule_p++;

  02232	43		 inc	 ebx

; 4059 : 			break;

  02233	eb 2a		 jmp	 SHORT $L72284
$L72287:

; 4035 : 		case BIN_EXACT:		/* an exact string was found */
; 4036 : 			rule_p++;
; 4037 : 			match_l=current_rule[rule_p];
; 4038 : 			rule_p++;
; 4039 : 			memcpy(&buf[buf_ind],&current_rule[rule_p],match_l);

  02235	8b 54 24 20	 mov	 edx, DWORD PTR _buf$[esp+20]
  02239	43		 inc	 ebx
  0223a	33 c0		 xor	 eax, eax
  0223c	03 fa		 add	 edi, edx
  0223e	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02241	43		 inc	 ebx
  02242	8b c8		 mov	 ecx, eax
  02244	8b d1		 mov	 edx, ecx
  02246	8d 34 2b	 lea	 esi, DWORD PTR [ebx+ebp]
  02249	c1 e9 02	 shr	 ecx, 2
  0224c	f3 a5		 rep movsd
  0224e	8b ca		 mov	 ecx, edx

; 4040 : 			rule_p+=match_l;

  02250	03 d8		 add	 ebx, eax
  02252	83 e1 03	 and	 ecx, 3
  02255	f3 a4		 rep movsb

; 4041 : 			buf_ind+=match_l;

  02257	01 44 24 10	 add	 DWORD PTR _buf_ind$[esp+24], eax
$L73102:
  0225b	8b 7c 24 10	 mov	 edi, DWORD PTR _buf_ind$[esp+24]
$L72284:

; 4026 : 			}
; 4027 : 		}
; 4028 : 		
; 4029 : 	}
; 4030 : 	while (rule_p<=end_of_build)

  0225f	8b 44 24 30	 mov	 eax, DWORD PTR 28+[esp+20]
  02263	8b 4c 24 2c	 mov	 ecx, DWORD PTR _ret_value$[esp+20]
  02267	3b d8		 cmp	 ebx, eax
  02269	0f 8e 63 ff ff
	ff		 jle	 $L72281
$L72282:

; 4067 : 		}
; 4068 : 	}
; 4069 : 	/* the end of the rule has been hit */
; 4070 : 	buf[buf_ind]='\0';

  0226f	8b 44 24 20	 mov	 eax, DWORD PTR _buf$[esp+20]

; 4071 : 	*length=buf_ind;

  02273	8b 54 24 38	 mov	 edx, DWORD PTR _length$[esp+20]
  02277	c6 04 07 00	 mov	 BYTE PTR [edi+eax], 0
  0227b	89 3a		 mov	 DWORD PTR [edx], edi

; 4072 : 	ret_value->rule=end_of_action+1;

  0227d	8b 54 24 14	 mov	 edx, DWORD PTR _end_of_action$[esp+24]
  02281	5f		 pop	 edi
  02282	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  02288	5e		 pop	 esi
  02289	42		 inc	 edx
  0228a	5d		 pop	 ebp
  0228b	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0228e	5b		 pop	 ebx

; 4073 : #ifdef DEBUG2
; 4074 : 	par_print_rule_error("no error, just debugging output position",current_rule,rule_p);
; 4075 : #endif
; 4076 : #ifdef 	DEBUG
; 4077 : 	printf("leaving par_build_string_from_rule buf=%s\n",buf);
; 4078 : #endif
; 4079 : 	return(buf);
; 4080 : }

  0228f	83 c4 08	 add	 esp, 8
  02292	c3		 ret	 0
$L72290:
  02293	5f		 pop	 edi
  02294	5e		 pop	 esi
  02295	5d		 pop	 ebp

; 4060 : 		default:
; 4061 : 			/* the current character is not a recognized type */
; 4062 : #ifdef DEBUG
; 4063 : 			par_print_rule_error("build_string;unrecognized delimiter",current_rule,rule_p);
; 4064 : #endif
; 4065 : 			ret_value->value=FATAL_FAIL;

  02296	c7 41 14 04 00
	00 00		 mov	 DWORD PTR [ecx+20], 4

; 4066 : 			return(NULL);

  0229d	33 c0		 xor	 eax, eax
  0229f	5b		 pop	 ebx

; 4073 : #ifdef DEBUG2
; 4074 : 	par_print_rule_error("no error, just debugging output position",current_rule,rule_p);
; 4075 : #endif
; 4076 : #ifdef 	DEBUG
; 4077 : 	printf("leaving par_build_string_from_rule buf=%s\n",buf);
; 4078 : #endif
; 4079 : 	return(buf);
; 4080 : }

  022a0	83 c4 08	 add	 esp, 8
  022a3	c3		 ret	 0
_par_build_string_from_rule ENDP
_TEXT	ENDS
PUBLIC	_par_match_sets_with_ranges
PUBLIC	_par_match_digits
PUBLIC	_par_match_standard
EXTRN	_par_lower:BYTE
_TEXT	SEGMENT
_current_rule$ = 8
_char_type$ = 12
_input_array$ = 16
_match_array$ = 20
_ret_value$ = 24
_range_value$ = 28
_lookahead$ = 32
_break_on_min_match$ = 36
_par_match_string PROC NEAR

; 4126 : 	register int rule_p;
; 4127 : 	register int ipos;
; 4128 : 	int length=0;
; 4129 : 	int value;
; 4130 : 	
; 4131 : 	
; 4132 : #ifdef DEBUG
; 4133 : 	printf("entering par_match_string\n");
; 4134 : #endif
; 4135 : 	
; 4136 : 
; 4137 : 	
; 4138 : 	rule_p=ret_value->rule;
; 4139 : 	ipos=ret_value->input_pos+ret_value->input_offset;
; 4140 : 	
; 4141 : 	if (char_type<=BIN_DIGIT)

  022b0	8b 44 24 08	 mov	 eax, DWORD PTR _char_type$[esp-4]
  022b4	53		 push	 ebx
  022b5	55		 push	 ebp
  022b6	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ret_value$[esp+4]
  022ba	56		 push	 esi
  022bb	57		 push	 edi
  022bc	8b 75 04	 mov	 esi, DWORD PTR [ebp+4]
  022bf	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  022c2	8b 4d 10	 mov	 ecx, DWORD PTR [ebp+16]
  022c5	03 f3		 add	 esi, ebx
  022c7	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  022ca	8b d1		 mov	 edx, ecx
  022cc	7f 50		 jg	 SHORT $L72313

; 4142 : 	{
; 4143 : 		if (current_rule[rule_p] & BIN_DIGIT_RANGE)

  022ce	8b 4c 24 14	 mov	 ecx, DWORD PTR _current_rule$[esp+12]
  022d2	f6 04 0a 20	 test	 BYTE PTR [edx+ecx], 32	; 00000020H
  022d6	74 25		 je	 SHORT $L72314

; 4144 : 		{
; 4145 : 			/* check for the special digit type and if it is there */
; 4146 : 			/* use the special digit matching function. */
; 4147 : 			/* use the normal one otherwise */
; 4148 : 			length=par_match_digits(current_rule,input_array,match_array,ret_value,range_value,lookahead,break_on_min_match);

  022d8	8b 44 24 30	 mov	 eax, DWORD PTR _break_on_min_match$[esp+12]
  022dc	8b 54 24 2c	 mov	 edx, DWORD PTR _lookahead$[esp+12]
  022e0	50		 push	 eax
  022e1	8b 44 24 2c	 mov	 eax, DWORD PTR _range_value$[esp+16]
  022e5	52		 push	 edx
  022e6	8b 54 24 28	 mov	 edx, DWORD PTR _match_array$[esp+20]
  022ea	50		 push	 eax
  022eb	8b 44 24 28	 mov	 eax, DWORD PTR _input_array$[esp+24]
  022ef	55		 push	 ebp
  022f0	52		 push	 edx
  022f1	50		 push	 eax
  022f2	51		 push	 ecx
  022f3	e8 00 00 00 00	 call	 _par_match_digits

; 4149 : 		}
; 4150 : 		else

  022f8	e9 49 01 00 00	 jmp	 $L73111
$L72314:

; 4151 : 		{
; 4152 : 			length=par_match_standard(current_rule,char_type,input_array,match_array,ret_value,lookahead,break_on_min_match);

  022fd	8b 54 24 30	 mov	 edx, DWORD PTR _break_on_min_match$[esp+12]
  02301	52		 push	 edx
  02302	8b 54 24 30	 mov	 edx, DWORD PTR _lookahead$[esp+16]
  02306	52		 push	 edx
  02307	8b 54 24 28	 mov	 edx, DWORD PTR _match_array$[esp+20]
  0230b	55		 push	 ebp
  0230c	52		 push	 edx
  0230d	8b 54 24 2c	 mov	 edx, DWORD PTR _input_array$[esp+28]
  02311	52		 push	 edx
  02312	50		 push	 eax
  02313	51		 push	 ecx
  02314	e8 00 00 00 00	 call	 _par_match_standard

; 4153 : 		}
; 4154 : 		rule_p=ret_value->rule;
; 4155 : 	}
; 4156 : 	else	/* if (char_type<=BIN_DIGIT) */

  02319	e9 28 01 00 00	 jmp	 $L73111
$L72313:

; 4157 : 	{
; 4158 : 		if (char_type<=BIN_HEXADECIMAL)

  0231e	83 f8 11	 cmp	 eax, 17			; 00000011H
  02321	0f 8f a6 00 00
	00		 jg	 $L72317

; 4159 : 		{
; 4160 : 			
; 4161 : 			if (char_type==BIN_EXACT)

  02327	83 f8 10	 cmp	 eax, 16			; 00000010H
  0232a	75 6e		 jne	 SHORT $L72318

; 4162 : 			{
; 4163 : 				rule_p++;
; 4164 : 				length=0;
; 4165 : 				value=current_rule[rule_p];

  0232c	8b 7c 24 14	 mov	 edi, DWORD PTR _current_rule$[esp+12]
  02330	42		 inc	 edx
  02331	33 db		 xor	 ebx, ebx
  02333	33 c0		 xor	 eax, eax
  02335	8a 1c 3a	 mov	 bl, BYTE PTR [edx+edi]

; 4166 : 				rule_p++;

  02338	42		 inc	 edx

; 4167 : 				if (current_rule[ret_value->rule] & BIN_CASE_INSEN)

  02339	f6 04 39 20	 test	 BYTE PTR [ecx+edi], 32	; 00000020H
  0233d	74 3b		 je	 SHORT $L72319

; 4168 : 				{
; 4169 : 					while (length<value)

  0233f	85 db		 test	 ebx, ebx
  02341	0f 8e 09 01 00
	00		 jle	 $L73107
  02347	8b 4c 24 1c	 mov	 ecx, DWORD PTR _input_array$[esp+12]
  0234b	03 f1		 add	 esi, ecx
  0234d	89 74 24 1c	 mov	 DWORD PTR 16+[esp+12], esi
$L72321:

; 4170 : 					{
; 4171 : 						if (par_lower[current_rule[rule_p]]!=par_lower[input_array[ipos+length]])

  02351	8b 74 24 1c	 mov	 esi, DWORD PTR 16+[esp+12]
  02355	33 c9		 xor	 ecx, ecx
  02357	8a 0c 06	 mov	 cl, BYTE PTR [esi+eax]
  0235a	8b f1		 mov	 esi, ecx
  0235c	33 c9		 xor	 ecx, ecx
  0235e	8a 0c 3a	 mov	 cl, BYTE PTR [edx+edi]
  02361	8a 89 00 00 00
	00		 mov	 cl, BYTE PTR _par_lower[ecx]
  02367	3a 8e 00 00 00
	00		 cmp	 cl, BYTE PTR _par_lower[esi]
  0236d	75 3c		 jne	 SHORT $L73105

; 4172 : 						{
; 4173 : #ifdef DEBUG
; 4174 : 							printf("leaving par_match_string; exact characters dont match\n");
; 4175 : #endif
; 4176 : 							if (ret_value->optional==1)
; 4177 : 							{
; 4178 : #ifdef DEBUG
; 4179 : 								printf("par_match_string; exact optional set to -1\n");
; 4180 : #endif
; 4181 : //								ret_value->optional= -1;
; 4182 : 								ret_value->value=OPT_FAIL;
; 4183 : 							}
; 4184 : 							else
; 4185 : 							{
; 4186 : 								ret_value->value=FAIL;
; 4187 : 							}
; 4188 : 							return(0);
; 4189 : 						}
; 4190 : 						length++;

  0236f	40		 inc	 eax

; 4191 : 						rule_p++;

  02370	42		 inc	 edx
  02371	3b c3		 cmp	 eax, ebx
  02373	7c dc		 jl	 SHORT $L72321

; 4170 : 					{
; 4171 : 						if (par_lower[current_rule[rule_p]]!=par_lower[input_array[ipos+length]])

  02375	e9 d2 00 00 00	 jmp	 $L72341
$L72319:

; 4192 : 					}
; 4193 : 				}
; 4194 : 				else
; 4195 : 				{
; 4196 : 					if (current_rule[rule_p]!=input_array[ipos])

  0237a	8b 44 24 1c	 mov	 eax, DWORD PTR _input_array$[esp+12]
  0237e	8a 0c 17	 mov	 cl, BYTE PTR [edi+edx]
  02381	03 fa		 add	 edi, edx
  02383	03 f0		 add	 esi, eax
  02385	3a 0e		 cmp	 cl, BYTE PTR [esi]

; 4197 : 					{
; 4198 : #ifdef DEBUG
; 4199 : 						printf("leaving par_match_string; exact characters dont match\n");
; 4200 : #endif
; 4201 : 						if (ret_value->optional==1)
; 4202 : 						{
; 4203 : #ifdef DEBUG
; 4204 : 							printf("par_match_string; exact optional set to -1\n");
; 4205 : #endif
; 4206 : 							//ret_value->optional= -1;
; 4207 : 							ret_value->value=OPT_FAIL;
; 4208 : 						}
; 4209 : 						else

  02387	75 22		 jne	 SHORT $L73105

; 4210 : 						{
; 4211 : 							ret_value->value=FAIL;
; 4212 : 						}
; 4213 : 						return(0);
; 4214 : 					}
; 4215 : 					if (memcmp(input_array+ipos,current_rule+rule_p,value)!=0)

  02389	8b cb		 mov	 ecx, ebx
  0238b	33 c0		 xor	 eax, eax
  0238d	f3 a6		 repe cmpsb

; 4216 : 					{
; 4217 : #ifdef DEBUG
; 4218 : 						printf("leaving par_match_string; exact characters dont match\n");
; 4219 : #endif
; 4220 : 						if (ret_value->optional==1)
; 4221 : 						{
; 4222 : #ifdef DEBUG
; 4223 : 							printf("par_match_string; exact optional set to -1\n");
; 4224 : #endif
; 4225 : 			//				ret_value->optional= -1;
; 4226 : 							ret_value->value=OPT_FAIL;
; 4227 : 							
; 4228 : 						}
; 4229 : 						else

  0238f	75 1a		 jne	 SHORT $L73105

; 4230 : 						{
; 4231 : 							ret_value->value=FAIL;
; 4232 : 						}
; 4233 : 						return(0);
; 4234 : 					}
; 4235 : 					rule_p+=value;

  02391	03 d3		 add	 edx, ebx

; 4236 : 					length=value;

  02393	8b c3		 mov	 eax, ebx

; 4237 : 				}
; 4238 : 			}
; 4239 : 			else /* if (char_type==BIN_EXACT) */

  02395	e9 b2 00 00 00	 jmp	 $L72341
$L72318:

; 4240 : 			{
; 4241 : 				/* BIN_HEXADECIMAL */
; 4242 : 				rule_p++;
; 4243 : 				if (input_array[ipos]!=current_rule[rule_p])

  0239a	8b 4c 24 1c	 mov	 ecx, DWORD PTR _input_array$[esp+12]
  0239e	42		 inc	 edx
  0239f	8a 04 0e	 mov	 al, BYTE PTR [esi+ecx]
  023a2	8b 4c 24 14	 mov	 ecx, DWORD PTR _current_rule$[esp+12]
  023a6	3a 04 0a	 cmp	 al, BYTE PTR [edx+ecx]
  023a9	74 14		 je	 SHORT $L72334
$L73105:

; 4244 : 				{
; 4245 : 					if (ret_value->optional==1)

  023ab	83 7d 18 01	 cmp	 DWORD PTR [ebp+24], 1
  023af	75 60		 jne	 SHORT $L72335
  023b1	5f		 pop	 edi

; 4246 : 					{
; 4247 : #ifdef DEBUG
; 4248 : 						printf("par_match_string; hex optional set to -1\n");
; 4249 : #endif
; 4250 : 		//				ret_value->optional= -1;
; 4251 : 						ret_value->value=OPT_FAIL;

  023b2	c7 45 14 02 00
	00 00		 mov	 DWORD PTR [ebp+20], 2
  023b9	5e		 pop	 esi
  023ba	5d		 pop	 ebp

; 4286 : 					return(0);

  023bb	33 c0		 xor	 eax, eax
  023bd	5b		 pop	 ebx

; 4327 : #ifdef DEBUG
; 4328 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4329 : #endif
; 4330 : 	return(length);
; 4331 : }

  023be	c3		 ret	 0
$L72334:

; 4252 : 					}
; 4253 : 					else
; 4254 : 					{
; 4255 : 						ret_value->value=FAIL;
; 4256 : 					}
; 4257 : #ifdef DEBUG
; 4258 : 					printf("leaving par_match_string hexadecimal value %02X mismatch\n",value);
; 4259 : #endif
; 4260 : 					return(0);
; 4261 : 				}
; 4262 : 				length=1;
; 4263 : 				rule_p++;

  023bf	42		 inc	 edx
  023c0	5f		 pop	 edi

; 4325 : 	}
; 4326 : 	ret_value->rule=rule_p;

  023c1	89 55 10	 mov	 DWORD PTR [ebp+16], edx
  023c4	5e		 pop	 esi
  023c5	5d		 pop	 ebp
  023c6	b8 01 00 00 00	 mov	 eax, 1
  023cb	5b		 pop	 ebx

; 4327 : #ifdef DEBUG
; 4328 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4329 : #endif
; 4330 : 	return(length);
; 4331 : }

  023cc	c3		 ret	 0
$L72317:

; 4264 : 			}
; 4265 : 		}
; 4266 : 		else /* if (char_type<=BIN_HEXADECIMAL) */
; 4267 : 		{
; 4268 : 			if (char_type==BIN_RESTORE)

  023cd	83 f8 12	 cmp	 eax, 18			; 00000012H
  023d0	75 50		 jne	 SHORT $L72338

; 4269 : 			{
; 4270 : 				rule_p++;
; 4271 : 				value=current_rule[rule_p];					/* get the array number */

  023d2	8b 4c 24 14	 mov	 ecx, DWORD PTR _current_rule$[esp+12]

; 4272 : 				length=match_array->array_lengths[value];	/* get the length of the strig in the array */

  023d6	8b 5c 24 20	 mov	 ebx, DWORD PTR _match_array$[esp+12]
  023da	42		 inc	 edx
  023db	33 c0		 xor	 eax, eax
  023dd	8a 04 0a	 mov	 al, BYTE PTR [edx+ecx]
  023e0	8b f8		 mov	 edi, eax
  023e2	8b 04 bb	 mov	 eax, DWORD PTR [ebx+edi*4]

; 4273 : 				if ((memcmp(input_array+ipos,match_array->array[value],length)!=0))

  023e5	8d 3c 7f	 lea	 edi, DWORD PTR [edi+edi*2]
  023e8	8b c8		 mov	 ecx, eax
  023ea	8d 3c bf	 lea	 edi, DWORD PTR [edi+edi*4]
  023ed	8d 7c 7b 28	 lea	 edi, DWORD PTR [ebx+edi*2+40]
  023f1	8b 5c 24 1c	 mov	 ebx, DWORD PTR _input_array$[esp+12]
  023f5	03 f3		 add	 esi, ebx
  023f7	33 db		 xor	 ebx, ebx
  023f9	f3 a6		 repe cmpsb
  023fb	74 22		 je	 SHORT $L72339

; 4274 : 				{
; 4275 : 					if (ret_value->optional==1)

  023fd	83 7d 18 01	 cmp	 DWORD PTR [ebp+24], 1
  02401	75 0e		 jne	 SHORT $L72335
  02403	5f		 pop	 edi

; 4276 : 					{
; 4277 : #ifdef DEBUG
; 4278 : 						printf("par_match_string; save optional set to -1\n");
; 4279 : #endif
; 4280 : //						ret_value->optional= -1;
; 4281 : 						ret_value->value=OPT_FAIL;

  02404	c7 45 14 02 00
	00 00		 mov	 DWORD PTR [ebp+20], 2
  0240b	5e		 pop	 esi
  0240c	5d		 pop	 ebp

; 4282 : 						return(0);

  0240d	33 c0		 xor	 eax, eax
  0240f	5b		 pop	 ebx

; 4327 : #ifdef DEBUG
; 4328 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4329 : #endif
; 4330 : 	return(length);
; 4331 : }

  02410	c3		 ret	 0
$L72335:
  02411	5f		 pop	 edi

; 4283 : 
; 4284 : 					}
; 4285 : 					ret_value->value=FAIL;

  02412	c7 45 14 00 00
	00 00		 mov	 DWORD PTR [ebp+20], 0
  02419	5e		 pop	 esi
  0241a	5d		 pop	 ebp

; 4286 : 					return(0);

  0241b	33 c0		 xor	 eax, eax
  0241d	5b		 pop	 ebx

; 4327 : #ifdef DEBUG
; 4328 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4329 : #endif
; 4330 : 	return(length);
; 4331 : }

  0241e	c3		 ret	 0
$L72339:

; 4287 : 				}
; 4288 : 				rule_p++;

  0241f	42		 inc	 edx

; 4289 : 			}
; 4290 : 			else /* if (char_type==BIN_RESTORE) */

  02420	eb 2a		 jmp	 SHORT $L72341
$L72338:

; 4291 : 			{
; 4292 : 				/* BIN_SETS */	
; 4293 : 				length=par_match_sets_with_ranges(current_rule,input_array,match_array,ret_value,range_value,lookahead,break_on_min_match);

  02422	8b 54 24 30	 mov	 edx, DWORD PTR _break_on_min_match$[esp+12]
  02426	8b 44 24 2c	 mov	 eax, DWORD PTR _lookahead$[esp+12]
  0242a	8b 4c 24 28	 mov	 ecx, DWORD PTR _range_value$[esp+12]
  0242e	52		 push	 edx
  0242f	8b 54 24 24	 mov	 edx, DWORD PTR _match_array$[esp+16]
  02433	50		 push	 eax
  02434	8b 44 24 24	 mov	 eax, DWORD PTR _input_array$[esp+20]
  02438	51		 push	 ecx
  02439	8b 4c 24 20	 mov	 ecx, DWORD PTR _current_rule$[esp+24]
  0243d	55		 push	 ebp
  0243e	52		 push	 edx
  0243f	50		 push	 eax
  02440	51		 push	 ecx
  02441	e8 00 00 00 00	 call	 _par_match_sets_with_ranges
$L73111:

; 4294 : 				rule_p=ret_value->rule;

  02446	8b 55 10	 mov	 edx, DWORD PTR [ebp+16]
  02449	83 c4 1c	 add	 esp, 28			; 0000001cH
$L72341:

; 4295 : 				/* find the { */ /* } */
; 4296 : 				/* find the first thing to search for */
; 4297 : 				/* save the rule pointer for multiple matches */
; 4298 : 				/* loop calling par_match_string pointing to each thing to match before the comma
; 4299 : 				and if all of them are successful, return the total nubmer of characters matched
; 4300 : 				if not, go on to the next section */
; 4301 : 				/* the ret_value structure passed is the same one that is passed to the current
; 4302 : 				par_match_string, so the rule field will be corrupted */
; 4303 : 				/* repeat the loop for each time iteration of the <#> thing */
; 4304 : 				/* set the range if only one is found */
; 4305 : 			} /* if (char_type==BIN_RESTORE) */
; 4306 : 		} /* if (char_type<=BIN_HEXADECIMAL) */
; 4307 : 	} /* if (char_type<=BIN_DIGIT) */
; 4308 : 
; 4309 : 
; 4310 : 
; 4311 : 	if (length==0)

  0244c	85 c0		 test	 eax, eax
  0244e	75 24		 jne	 SHORT $L72344
$L73107:

; 4312 : 	{
; 4313 : 		if (ret_value->optional==1)

  02450	83 7d 18 01	 cmp	 DWORD PTR [ebp+24], 1
  02454	75 0f		 jne	 SHORT $L72343
  02456	5f		 pop	 edi

; 4314 : 		{
; 4315 : 			ret_value->value=OPT_FAIL;

  02457	c7 45 14 02 00
	00 00		 mov	 DWORD PTR [ebp+20], 2

; 4325 : 	}
; 4326 : 	ret_value->rule=rule_p;

  0245e	89 55 10	 mov	 DWORD PTR [ebp+16], edx
  02461	5e		 pop	 esi
  02462	5d		 pop	 ebp
  02463	5b		 pop	 ebx

; 4327 : #ifdef DEBUG
; 4328 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4329 : #endif
; 4330 : 	return(length);
; 4331 : }

  02464	c3		 ret	 0
$L72343:
  02465	5f		 pop	 edi

; 4316 : 		}
; 4317 : 		else
; 4318 : 		{
; 4319 : 			ret_value->value=FAIL;

  02466	c7 45 14 00 00
	00 00		 mov	 DWORD PTR [ebp+20], 0

; 4325 : 	}
; 4326 : 	ret_value->rule=rule_p;

  0246d	89 55 10	 mov	 DWORD PTR [ebp+16], edx
  02470	5e		 pop	 esi
  02471	5d		 pop	 ebp
  02472	5b		 pop	 ebx

; 4327 : #ifdef DEBUG
; 4328 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4329 : #endif
; 4330 : 	return(length);
; 4331 : }

  02473	c3		 ret	 0
$L72344:

; 4320 : 		}
; 4321 : 	}
; 4322 : 	if (length==-2)

  02474	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  02477	75 02		 jne	 SHORT $L72345

; 4323 : 	{
; 4324 : 		length=0;

  02479	33 c0		 xor	 eax, eax
$L72345:
  0247b	5f		 pop	 edi

; 4325 : 	}
; 4326 : 	ret_value->rule=rule_p;

  0247c	89 55 10	 mov	 DWORD PTR [ebp+16], edx
  0247f	5e		 pop	 esi
  02480	5d		 pop	 ebp
  02481	5b		 pop	 ebx

; 4327 : #ifdef DEBUG
; 4328 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4329 : #endif
; 4330 : 	return(length);
; 4331 : }

  02482	c3		 ret	 0
_par_match_string ENDP
_input_array$ = 8
_input_indexes$ = 12
_output_array$ = 16
_output_indexes$ = 20
_num_chars$ = 24
_ret_value$ = 28
_par_copy_string_data PROC NEAR

; 4364 : #ifdef DEBUG
; 4365 : 	printf("entering par_copy_string_data\n");
; 4366 : #endif
; 4367 : 	memcpy(&output_array[ret_value->output_pos+ret_value->output_offset],&input_array[ret_value->input_pos+ret_value->input_offset],num_chars);

  02490	8b 44 24 18	 mov	 eax, DWORD PTR _ret_value$[esp-4]
  02494	53		 push	 ebx
  02495	8b 5c 24 08	 mov	 ebx, DWORD PTR _input_array$[esp]
  02499	56		 push	 esi
  0249a	8b 30		 mov	 esi, DWORD PTR [eax]
  0249c	8b 54 24 1c	 mov	 edx, DWORD PTR _num_chars$[esp+4]
  024a0	57		 push	 edi
  024a1	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  024a4	03 f3		 add	 esi, ebx
  024a6	8b 5c 24 18	 mov	 ebx, DWORD PTR _output_array$[esp+8]
  024aa	03 f7		 add	 esi, edi
  024ac	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  024af	03 fb		 add	 edi, ebx
  024b1	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]
  024b4	8b ca		 mov	 ecx, edx
  024b6	03 fb		 add	 edi, ebx
  024b8	8b d9		 mov	 ebx, ecx
  024ba	c1 e9 02	 shr	 ecx, 2
  024bd	f3 a5		 rep movsd
  024bf	8b cb		 mov	 ecx, ebx
  024c1	83 e1 03	 and	 ecx, 3
  024c4	f3 a4		 rep movsb

; 4368 : 	
; 4369 : 	par_copy_index_list(output_indexes,ret_value->output_pos+ret_value->output_offset,input_indexes,ret_value->input_pos+ret_value->input_offset,num_chars);

  024c6	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  024c9	8b 74 24 14	 mov	 esi, DWORD PTR _input_indexes$[esp+8]
  024cd	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  024d0	8b 10		 mov	 edx, DWORD PTR [eax]
  024d2	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  024d5	03 d3		 add	 edx, ebx
  024d7	d1 e1		 shl	 ecx, 1
  024d9	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  024dc	8d 34 56	 lea	 esi, DWORD PTR [esi+edx*2]
  024df	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  024e2	03 d7		 add	 edx, edi
  024e4	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  024e7	8b 54 24 1c	 mov	 edx, DWORD PTR _output_indexes$[esp+8]
  024eb	8d 3c 42	 lea	 edi, DWORD PTR [edx+eax*2]
  024ee	8b c1		 mov	 eax, ecx
  024f0	c1 e9 02	 shr	 ecx, 2
  024f3	f3 a5		 rep movsd
  024f5	8b c8		 mov	 ecx, eax
  024f7	83 e1 03	 and	 ecx, 3
  024fa	f3 a4		 rep movsb
  024fc	5f		 pop	 edi
  024fd	5e		 pop	 esi
  024fe	5b		 pop	 ebx

; 4370 : 	/* turn this into two memcpy's */
; 4371 : #if 0
; 4372 : 	for (i=0;i<num_chars;i++)
; 4373 : 	{
; 4374 : 		output_array[ret_value->output_pos+ret_value->output_offset+i]=input_array[ret_value->input_pos+ret_value->input_offset+i];
; 4375 : 		par_copy_index(output_indexes,ret_value->output_pos+ret_value->output_offset+i,input_indexes,ret_value->input_pos+ret_value->input_offset+i);
; 4376 : 	}
; 4377 : #endif
; 4378 : #ifdef DEBUG
; 4379 : 	printf("leaving par_copy_string_data\n");
; 4380 : #endif
; 4381 : }

  024ff	c3		 ret	 0
_par_copy_string_data ENDP
_TEXT	ENDS
PUBLIC	_par_convert_number
_TEXT	SEGMENT
_string$ = 8
_num$ = 12
_par_convert_number PROC NEAR

; 4405 : {

  02500	56		 push	 esi

; 4406 : 	register int i,total=0,temp;
; 4407 : 	
; 4408 : 	for (i=0;i<num;i++)

  02501	8b 74 24 0c	 mov	 esi, DWORD PTR _num$[esp]
  02505	33 c0		 xor	 eax, eax
  02507	33 d2		 xor	 edx, edx
  02509	85 f6		 test	 esi, esi
  0250b	57		 push	 edi
  0250c	7e 1e		 jle	 SHORT $L72364
  0250e	8b 7c 24 0c	 mov	 edi, DWORD PTR _string$[esp+4]
$L72368:

; 4409 : 	{
; 4410 : 		temp=string[i]-'0';

  02512	33 c9		 xor	 ecx, ecx
  02514	8a 0c 3a	 mov	 cl, BYTE PTR [edx+edi]
  02517	83 e9 30	 sub	 ecx, 48			; 00000030H

; 4411 : 		if ((temp<0) || (temp>9))

  0251a	78 10		 js	 SHORT $L72364
  0251c	83 f9 09	 cmp	 ecx, 9
  0251f	7f 0b		 jg	 SHORT $L72364

; 4412 : 			return(total);
; 4413 : 		total=total*10+temp;

  02521	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  02524	42		 inc	 edx
  02525	3b d6		 cmp	 edx, esi
  02527	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0252a	7c e6		 jl	 SHORT $L72368
$L72364:
  0252c	5f		 pop	 edi
  0252d	5e		 pop	 esi

; 4414 : 	}
; 4415 : 	return(total);
; 4416 : }

  0252e	c3		 ret	 0
_par_convert_number ENDP
_string$ = 8
_par_convert_number_new2 PROC NEAR

; 4443 : 	register int i,total=0,temp;
; 4444 : 	
; 4445 : 	for (i=0;;i++)
; 4446 : 	{
; 4447 : 		temp=string[i]-'0';

  02530	8b 54 24 04	 mov	 edx, DWORD PTR _string$[esp-4]
  02534	33 c9		 xor	 ecx, ecx
  02536	33 c0		 xor	 eax, eax
  02538	8a 0a		 mov	 cl, BYTE PTR [edx]
  0253a	83 e9 30	 sub	 ecx, 48			; 00000030H

; 4448 : 		if ((temp<0) || (temp>9))

  0253d	78 15		 js	 SHORT $L73125
$L72379:
  0253f	83 f9 09	 cmp	 ecx, 9
  02542	7f 10		 jg	 SHORT $L73125

; 4449 : 			return(total);
; 4450 : 		total=total*10+temp;

  02544	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  02547	42		 inc	 edx
  02548	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0254b	33 c9		 xor	 ecx, ecx
  0254d	8a 0a		 mov	 cl, BYTE PTR [edx]
  0254f	83 e9 30	 sub	 ecx, 48			; 00000030H
  02552	79 eb		 jns	 SHORT $L72379
$L73125:

; 4451 : 	}
; 4452 : 	return(total);
; 4453 : }

  02554	c3		 ret	 0
_par_convert_number_new2 ENDP
_TEXT	ENDS
PUBLIC	_par_get_int_length
_TEXT	SEGMENT
_i$ = 8
_par_get_int_length PROC NEAR

; 4475 : 	if (i<10)

  02560	8b 44 24 04	 mov	 eax, DWORD PTR _i$[esp-4]
  02564	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  02567	7d 06		 jge	 SHORT $L72387

; 4476 : 		return(1);

  02569	b8 01 00 00 00	 mov	 eax, 1

; 4482 : 		return(4);
; 4483 : 	else
; 4484 : 		return(5);
; 4485 : 
; 4486 : 
; 4487 : #if 0
; 4488 : 	register int j;
; 4489 : #ifdef DEBUG
; 4490 : 	printf("entering par_get_int_length\n");
; 4491 : #endif
; 4492 : 	if (i==0)
; 4493 : 	{
; 4494 : #ifdef DEBUG
; 4495 : 		printf("leaving par_get_int_length length=1\n");
; 4496 : #endif
; 4497 : 		return(1);
; 4498 : 	}
; 4499 : 	for (j=0;i;j++)
; 4500 : 		i/=10;
; 4501 : #ifdef DEBUG
; 4502 : 	printf("leaving par_get_int_length length=%d\n",j);
; 4503 : #endif
; 4504 : 	return(j);
; 4505 : #endif
; 4506 : }

  0256e	c3		 ret	 0
$L72387:

; 4477 : 	else if (i<100)

  0256f	83 f8 64	 cmp	 eax, 100		; 00000064H
  02572	7d 06		 jge	 SHORT $L72389

; 4478 : 		return(2);

  02574	b8 02 00 00 00	 mov	 eax, 2

; 4482 : 		return(4);
; 4483 : 	else
; 4484 : 		return(5);
; 4485 : 
; 4486 : 
; 4487 : #if 0
; 4488 : 	register int j;
; 4489 : #ifdef DEBUG
; 4490 : 	printf("entering par_get_int_length\n");
; 4491 : #endif
; 4492 : 	if (i==0)
; 4493 : 	{
; 4494 : #ifdef DEBUG
; 4495 : 		printf("leaving par_get_int_length length=1\n");
; 4496 : #endif
; 4497 : 		return(1);
; 4498 : 	}
; 4499 : 	for (j=0;i;j++)
; 4500 : 		i/=10;
; 4501 : #ifdef DEBUG
; 4502 : 	printf("leaving par_get_int_length length=%d\n",j);
; 4503 : #endif
; 4504 : 	return(j);
; 4505 : #endif
; 4506 : }

  02579	c3		 ret	 0
$L72389:

; 4479 : 	else if (i<1000)

  0257a	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  0257f	7d 06		 jge	 SHORT $L72391

; 4480 : 		return(3);

  02581	b8 03 00 00 00	 mov	 eax, 3

; 4482 : 		return(4);
; 4483 : 	else
; 4484 : 		return(5);
; 4485 : 
; 4486 : 
; 4487 : #if 0
; 4488 : 	register int j;
; 4489 : #ifdef DEBUG
; 4490 : 	printf("entering par_get_int_length\n");
; 4491 : #endif
; 4492 : 	if (i==0)
; 4493 : 	{
; 4494 : #ifdef DEBUG
; 4495 : 		printf("leaving par_get_int_length length=1\n");
; 4496 : #endif
; 4497 : 		return(1);
; 4498 : 	}
; 4499 : 	for (j=0;i;j++)
; 4500 : 		i/=10;
; 4501 : #ifdef DEBUG
; 4502 : 	printf("leaving par_get_int_length length=%d\n",j);
; 4503 : #endif
; 4504 : 	return(j);
; 4505 : #endif
; 4506 : }

  02586	c3		 ret	 0
$L72391:

; 4481 : 	else if (i<10000)

  02587	33 c9		 xor	 ecx, ecx
  02589	3d 10 27 00 00	 cmp	 eax, 10000		; 00002710H
  0258e	0f 9d c1	 setge	 cl
  02591	83 c1 04	 add	 ecx, 4
  02594	8b c1		 mov	 eax, ecx

; 4482 : 		return(4);
; 4483 : 	else
; 4484 : 		return(5);
; 4485 : 
; 4486 : 
; 4487 : #if 0
; 4488 : 	register int j;
; 4489 : #ifdef DEBUG
; 4490 : 	printf("entering par_get_int_length\n");
; 4491 : #endif
; 4492 : 	if (i==0)
; 4493 : 	{
; 4494 : #ifdef DEBUG
; 4495 : 		printf("leaving par_get_int_length length=1\n");
; 4496 : #endif
; 4497 : 		return(1);
; 4498 : 	}
; 4499 : 	for (j=0;i;j++)
; 4500 : 		i/=10;
; 4501 : #ifdef DEBUG
; 4502 : 	printf("leaving par_get_int_length length=%d\n",j);
; 4503 : #endif
; 4504 : 	return(j);
; 4505 : #endif
; 4506 : }

  02596	c3		 ret	 0
_par_get_int_length ENDP
_TEXT	ENDS
PUBLIC	_par_look_ahead
_TEXT	SEGMENT
_current_rule$ = 8
_input_array$ = 12
_ipos$ = 16
_find_index$ = 20
_match_array$ = 24
_ret_value$ = 28
_new_ret$ = -32
_range_value$ = -48
_par_look_ahead PROC NEAR

; 4544 : {

  025a0	83 ec 30	 sub	 esp, 48			; 00000030H

; 4545 : #ifndef NEW_PARSER_FILE_LOADING
; 4546 : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0 };
; 4547 : #else
; 4548 : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0,NULL };
; 4549 : #endif
; 4550 : 	range_value_t		range_value = {0,0,0,0};
; 4551 : 	int char_length=0;
; 4552 : 	int value;
; 4553 : 	register int rule_p;
; 4554 : 	int char_type;
; 4555 : 
; 4556 : 	rule_p=find_index;
; 4557 : #ifdef DEBUG
; 4558 : 	printf("entering par_look_ahead\n");
; 4559 : 	par_print_rule_error("par_look_ahead; the current position is",current_rule,ret_value->rule);
; 4560 : #endif
; 4561 : 	char_type=current_rule[find_index] & BIN_OPERATION_MASK;

  025a3	8b 54 24 34	 mov	 edx, DWORD PTR _current_rule$[esp+44]
  025a7	53		 push	 ebx
  025a8	56		 push	 esi
  025a9	8b 74 24 48	 mov	 esi, DWORD PTR _find_index$[esp+52]
  025ad	57		 push	 edi
  025ae	33 db		 xor	 ebx, ebx
  025b0	8a 0c 32	 mov	 cl, BYTE PTR [edx+esi]
  025b3	89 5c 24 1c	 mov	 DWORD PTR _new_ret$[esp+60], ebx
  025b7	8a c1		 mov	 al, cl
  025b9	89 5c 24 20	 mov	 DWORD PTR _new_ret$[esp+64], ebx
  025bd	83 e0 1f	 and	 eax, 31			; 0000001fH
  025c0	89 5c 24 24	 mov	 DWORD PTR _new_ret$[esp+68], ebx
  025c4	8b f8		 mov	 edi, eax
  025c6	89 5c 24 28	 mov	 DWORD PTR _new_ret$[esp+72], ebx

; 4562 : 
; 4563 : 	if (char_type==BIN_EXACT)

  025ca	83 ff 10	 cmp	 edi, 16			; 00000010H
  025cd	89 5c 24 2c	 mov	 DWORD PTR _new_ret$[esp+76], ebx
  025d1	89 5c 24 30	 mov	 DWORD PTR _new_ret$[esp+80], ebx
  025d5	89 5c 24 34	 mov	 DWORD PTR _new_ret$[esp+84], ebx
  025d9	89 5c 24 38	 mov	 DWORD PTR _new_ret$[esp+88], ebx
  025dd	89 5c 24 0c	 mov	 DWORD PTR _range_value$[esp+60], ebx
  025e1	89 5c 24 10	 mov	 DWORD PTR _range_value$[esp+64], ebx
  025e5	89 5c 24 14	 mov	 DWORD PTR _range_value$[esp+68], ebx
  025e9	89 5c 24 18	 mov	 DWORD PTR _range_value$[esp+72], ebx
  025ed	0f 85 a1 00 00
	00		 jne	 $L72414

; 4564 : 	{
; 4565 : 		rule_p++;			/* skip the single quote */

  025f3	46		 inc	 esi

; 4566 : 		value=current_rule[rule_p]+ipos;

  025f4	33 c0		 xor	 eax, eax
  025f6	8a 04 16	 mov	 al, BYTE PTR [esi+edx]
  025f9	8b f8		 mov	 edi, eax
  025fb	8b 44 24 48	 mov	 eax, DWORD PTR _ipos$[esp+56]
  025ff	03 f8		 add	 edi, eax

; 4567 : 		rule_p++;

  02601	46		 inc	 esi

; 4568 : 		if (current_rule[find_index] & BIN_CASE_INSEN)

  02602	f6 c1 20	 test	 cl, 32			; 00000020H

; 4569 : 		{
; 4570 : 			if (par_lower[current_rule[rule_p]]!=par_lower[input_array[ipos]])

  02605	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  02608	74 53		 je	 SHORT $L72415
  0260a	8b 74 24 44	 mov	 esi, DWORD PTR _input_array$[esp+56]
  0260e	8a 19		 mov	 bl, BYTE PTR [ecx]
  02610	33 d2		 xor	 edx, edx
  02612	8a 14 06	 mov	 dl, BYTE PTR [esi+eax]
  02615	8a 9b 00 00 00
	00		 mov	 bl, BYTE PTR _par_lower[ebx]
  0261b	3a 9a 00 00 00
	00		 cmp	 bl, BYTE PTR _par_lower[edx]
  02621	74 09		 je	 SHORT $L73131
$L73134:
  02623	5f		 pop	 edi
  02624	5e		 pop	 esi

; 4571 : 			{
; 4572 : #ifdef DEBUG
; 4573 : 				printf("leaving par_look_ahead; exact failure\n");
; 4574 : #endif
; 4575 : 				return(0);

  02625	33 c0		 xor	 eax, eax
  02627	5b		 pop	 ebx

; 4732 : 					
; 4733 : 				} /* (char_type==BIN_RESTORE) */
; 4734 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4735 : 		} /* if (char_type<=BIN_DIGIT) */
; 4736 : 	} /* if (char_type==BIN_EXACT) */
; 4737 : 
; 4738 : #ifdef DEBUG
; 4739 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4740 : #endif
; 4741 : 	return(0);
; 4742 : 	
; 4743 : }

  02628	83 c4 30	 add	 esp, 48			; 00000030H
  0262b	c3		 ret	 0
$L73131:

; 4576 : 			}
; 4577 : 			while (ipos<value)

  0262c	3b c7		 cmp	 eax, edi
  0262e	0f 8d 39 01 00
	00		 jge	 $L72425
$L72418:

; 4578 : 			{
; 4579 : 				if (par_lower[current_rule[rule_p]]!=par_lower[input_array[ipos]])

  02634	33 db		 xor	 ebx, ebx
  02636	33 d2		 xor	 edx, edx
  02638	8a 19		 mov	 bl, BYTE PTR [ecx]
  0263a	8a 14 06	 mov	 dl, BYTE PTR [esi+eax]
  0263d	8a 9b 00 00 00
	00		 mov	 bl, BYTE PTR _par_lower[ebx]
  02643	3a 9a 00 00 00
	00		 cmp	 bl, BYTE PTR _par_lower[edx]
  02649	75 d8		 jne	 SHORT $L73134

; 4580 : 				{
; 4581 : #ifdef DEBUG
; 4582 : 					printf("leaving par_look_ahead; exact failure\n");
; 4583 : #endif
; 4584 : 					return(0);
; 4585 : 				}
; 4586 : 				ipos++;

  0264b	40		 inc	 eax

; 4587 : 				rule_p++;

  0264c	41		 inc	 ecx
  0264d	3b c7		 cmp	 eax, edi
  0264f	7c e3		 jl	 SHORT $L72418
  02651	5f		 pop	 edi
  02652	5e		 pop	 esi

; 4703 : 					{
; 4704 : 						if (match_array->array[value][0]!='\0')
; 4705 : 						{
; 4706 : #ifdef DEBUG
; 4707 : 							printf("leaving par_look_ahead; par_save_string success\n");
; 4708 : #endif
; 4709 : 							return(1);

  02653	b8 01 00 00 00	 mov	 eax, 1
  02658	5b		 pop	 ebx

; 4732 : 					
; 4733 : 				} /* (char_type==BIN_RESTORE) */
; 4734 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4735 : 		} /* if (char_type<=BIN_DIGIT) */
; 4736 : 	} /* if (char_type==BIN_EXACT) */
; 4737 : 
; 4738 : #ifdef DEBUG
; 4739 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4740 : #endif
; 4741 : 	return(0);
; 4742 : 	
; 4743 : }

  02659	83 c4 30	 add	 esp, 48			; 00000030H
  0265c	c3		 ret	 0
$L72415:

; 4588 : 			}
; 4589 : #ifdef DEBUG
; 4590 : 			printf("leaving par_look_ahead; exact success\n");
; 4591 : #endif
; 4592 : 			return(1);
; 4593 : 		}
; 4594 : 		else /* if (current_rule[find_index] & BIN_CASE_INSEN) */
; 4595 : 		{
; 4596 : 			if (current_rule[rule_p]!=input_array[ipos])

  0265d	8b 74 24 44	 mov	 esi, DWORD PTR _input_array$[esp+56]
  02661	8a 11		 mov	 dl, BYTE PTR [ecx]
  02663	3a 14 06	 cmp	 dl, BYTE PTR [esi+eax]
  02666	74 09		 je	 SHORT $L73132
  02668	5f		 pop	 edi
  02669	5e		 pop	 esi

; 4597 : 			{
; 4598 : #ifdef DEBUG
; 4599 : 				printf("leaving par_look_ahead; exact failure\n");
; 4600 : #endif
; 4601 : 				return(0);

  0266a	33 c0		 xor	 eax, eax
  0266c	5b		 pop	 ebx

; 4732 : 					
; 4733 : 				} /* (char_type==BIN_RESTORE) */
; 4734 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4735 : 		} /* if (char_type<=BIN_DIGIT) */
; 4736 : 	} /* if (char_type==BIN_EXACT) */
; 4737 : 
; 4738 : #ifdef DEBUG
; 4739 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4740 : #endif
; 4741 : 	return(0);
; 4742 : 	
; 4743 : }

  0266d	83 c4 30	 add	 esp, 48			; 00000030H
  02670	c3		 ret	 0
$L73132:

; 4602 : 			}
; 4603 : 
; 4604 : 			while (ipos<value)

  02671	3b c7		 cmp	 eax, edi
  02673	0f 8d f4 00 00
	00		 jge	 $L72425
$L72424:

; 4605 : 			{
; 4606 : 				if (current_rule[rule_p]!=input_array[ipos])

  02679	8a 11		 mov	 dl, BYTE PTR [ecx]
  0267b	8a 1c 06	 mov	 bl, BYTE PTR [esi+eax]
  0267e	3a d3		 cmp	 dl, bl
  02680	75 a1		 jne	 SHORT $L73134

; 4607 : 				{
; 4608 : #ifdef DEBUG
; 4609 : 					printf("leaving par_look_ahead; exact failure\n");
; 4610 : #endif
; 4611 : 					return(0);
; 4612 : 				}
; 4613 : 				ipos++;

  02682	40		 inc	 eax

; 4614 : 				rule_p++;

  02683	41		 inc	 ecx
  02684	3b c7		 cmp	 eax, edi
  02686	7c f1		 jl	 SHORT $L72424
  02688	5f		 pop	 edi
  02689	5e		 pop	 esi

; 4703 : 					{
; 4704 : 						if (match_array->array[value][0]!='\0')
; 4705 : 						{
; 4706 : #ifdef DEBUG
; 4707 : 							printf("leaving par_look_ahead; par_save_string success\n");
; 4708 : #endif
; 4709 : 							return(1);

  0268a	b8 01 00 00 00	 mov	 eax, 1
  0268f	5b		 pop	 ebx

; 4732 : 					
; 4733 : 				} /* (char_type==BIN_RESTORE) */
; 4734 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4735 : 		} /* if (char_type<=BIN_DIGIT) */
; 4736 : 	} /* if (char_type==BIN_EXACT) */
; 4737 : 
; 4738 : #ifdef DEBUG
; 4739 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4740 : #endif
; 4741 : 	return(0);
; 4742 : 	
; 4743 : }

  02690	83 c4 30	 add	 esp, 48			; 00000030H
  02693	c3		 ret	 0
$L72414:

; 4615 : 			}
; 4616 : #ifdef DEBUG
; 4617 : 			printf("leaving par_look_ahead; exact success\n");
; 4618 : #endif
; 4619 : 			return(1);
; 4620 : 		}
; 4621 : #ifdef DEBUG
; 4622 : 		printf("leaving par_look_ahead; exact failure\n");
; 4623 : #endif
; 4624 : 		return(0);
; 4625 : 	}
; 4626 : 	else /* if (char_type==BIN_EXACT) */
; 4627 : 	{
; 4628 : 		if (char_type<=BIN_DIGIT)

  02694	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  02697	7f 78		 jg	 SHORT $L72428

; 4629 : 		{
; 4630 : 			if (current_rule[find_index] & BIN_DIGIT_RANGE)
; 4631 : 			{
; 4632 : 				/* check for the special digit type and if it is there */
; 4633 : 				/* use the special digit matching function. */
; 4634 : 				/* use the normal one otherwise */
; 4635 : 				new_ret.rule= find_index;

  02699	89 74 24 2c	 mov	 DWORD PTR _new_ret$[esp+76], esi

; 4636 : 				new_ret.value=SUCCESS;

  0269d	be 01 00 00 00	 mov	 esi, 1
  026a2	f6 c1 20	 test	 cl, 32			; 00000020H
  026a5	89 74 24 30	 mov	 DWORD PTR _new_ret$[esp+80], esi
  026a9	74 44		 je	 SHORT $L72429

; 4637 : 				new_ret.input_pos=ipos;

  026ab	8b 44 24 48	 mov	 eax, DWORD PTR _ipos$[esp+56]

; 4638 : 				char_length=par_match_digits(current_rule,input_array,match_array,&new_ret,&range_value,0,1);

  026af	56		 push	 esi
  026b0	89 44 24 20	 mov	 DWORD PTR _new_ret$[esp+64], eax
  026b4	8d 4c 24 10	 lea	 ecx, DWORD PTR _range_value$[esp+64]
  026b8	53		 push	 ebx
  026b9	8d 44 24 24	 lea	 eax, DWORD PTR _new_ret$[esp+68]
  026bd	51		 push	 ecx
  026be	8b 4c 24 5c	 mov	 ecx, DWORD PTR _match_array$[esp+68]
  026c2	50		 push	 eax
  026c3	8b 44 24 54	 mov	 eax, DWORD PTR _input_array$[esp+72]
  026c7	51		 push	 ecx
  026c8	50		 push	 eax
  026c9	52		 push	 edx
  026ca	e8 00 00 00 00	 call	 _par_match_digits
$L73139:

; 4639 : 				if (new_ret.value==SUCCESS)

  026cf	8b 4c 24 4c	 mov	 ecx, DWORD PTR _new_ret$[esp+108]
  026d3	83 c4 1c	 add	 esp, 28			; 0000001cH
  026d6	3b ce		 cmp	 ecx, esi
  026d8	0f 85 45 ff ff
	ff		 jne	 $L73134

; 4640 : 				{
; 4641 : 					if (char_length>0)

  026de	3b c3		 cmp	 eax, ebx
  026e0	0f 8e 3d ff ff
	ff		 jle	 $L73134

; 4642 : 					{
; 4643 : #ifdef DEBUG
; 4644 : 						printf("leaving par_look_ahead;digit range success\n");
; 4645 : #endif
; 4646 : 						return(1);

  026e6	8b c6		 mov	 eax, esi
  026e8	5f		 pop	 edi
  026e9	5e		 pop	 esi
  026ea	5b		 pop	 ebx

; 4732 : 					
; 4733 : 				} /* (char_type==BIN_RESTORE) */
; 4734 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4735 : 		} /* if (char_type<=BIN_DIGIT) */
; 4736 : 	} /* if (char_type==BIN_EXACT) */
; 4737 : 
; 4738 : #ifdef DEBUG
; 4739 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4740 : #endif
; 4741 : 	return(0);
; 4742 : 	
; 4743 : }

  026eb	83 c4 30	 add	 esp, 48			; 00000030H
  026ee	c3		 ret	 0
$L72429:

; 4647 : 					}
; 4648 : 				}
; 4649 : #ifdef DEBUG
; 4650 : 				printf("leaving par_look_ahead;digit range fail\n");
; 4651 : #endif
; 4652 : 				return(0);
; 4653 : 			}
; 4654 : 			else
; 4655 : 			{	/* most types */
; 4656 : 				
; 4657 : 				new_ret.rule= find_index;
; 4658 : 				new_ret.value=SUCCESS;
; 4659 : 				new_ret.input_pos=ipos;

  026ef	8b 4c 24 48	 mov	 ecx, DWORD PTR _ipos$[esp+56]

; 4660 : 				char_length=par_match_standard(current_rule,char_type ,input_array,match_array,&new_ret,0,1);

  026f3	56		 push	 esi
  026f4	8d 44 24 20	 lea	 eax, DWORD PTR _new_ret$[esp+64]
  026f8	89 4c 24 20	 mov	 DWORD PTR _new_ret$[esp+64], ecx
  026fc	8b 4c 24 54	 mov	 ecx, DWORD PTR _match_array$[esp+60]
  02700	53		 push	 ebx
  02701	50		 push	 eax
  02702	8b 44 24 50	 mov	 eax, DWORD PTR _input_array$[esp+68]
  02706	51		 push	 ecx
  02707	50		 push	 eax
  02708	57		 push	 edi
  02709	52		 push	 edx
  0270a	e8 00 00 00 00	 call	 _par_match_standard

; 4661 : 				if (new_ret.value==SUCCESS)
; 4662 : 				{
; 4663 : 					if (char_length>0)
; 4664 : 					{
; 4665 : #ifdef DEBUG
; 4666 : 						printf("leaving par_look_ahead;standard success\n");
; 4667 : #endif
; 4668 : 						return(1);

  0270f	eb be		 jmp	 SHORT $L73139
$L72428:

; 4669 : 					}
; 4670 : 				}
; 4671 : #ifdef DEBUG
; 4672 : 				printf("leaving par_look_ahead;standard fail\n");
; 4673 : #endif
; 4674 : 				return(0);
; 4675 : 			}
; 4676 : 			
; 4677 : 		}
; 4678 : 		else /* if (char_type<=BIN_DIGIT) */
; 4679 : 		{
; 4680 : 			if (char_type==BIN_HEXADECIMAL)

  02711	83 ff 11	 cmp	 edi, 17			; 00000011H
  02714	75 1d		 jne	 SHORT $L72436

; 4681 : 			{
; 4682 : 				rule_p++;
; 4683 : 				if (input_array[ipos]==current_rule[rule_p])

  02716	8b 4c 24 48	 mov	 ecx, DWORD PTR _ipos$[esp+56]
  0271a	8b 44 24 44	 mov	 eax, DWORD PTR _input_array$[esp+56]
  0271e	8a 5c 32 01	 mov	 bl, BYTE PTR [edx+esi+1]
  02722	5f		 pop	 edi
  02723	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  02726	33 c0		 xor	 eax, eax
  02728	3a cb		 cmp	 cl, bl
  0272a	5e		 pop	 esi
  0272b	0f 94 c0	 sete	 al
  0272e	5b		 pop	 ebx

; 4732 : 					
; 4733 : 				} /* (char_type==BIN_RESTORE) */
; 4734 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4735 : 		} /* if (char_type<=BIN_DIGIT) */
; 4736 : 	} /* if (char_type==BIN_EXACT) */
; 4737 : 
; 4738 : #ifdef DEBUG
; 4739 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4740 : #endif
; 4741 : 	return(0);
; 4742 : 	
; 4743 : }

  0272f	83 c4 30	 add	 esp, 48			; 00000030H
  02732	c3		 ret	 0
$L72436:

; 4684 : 				{
; 4685 : #ifdef DEBUG
; 4686 : 					printf("leaving par_look_ahead; hex number success\n");
; 4687 : #endif
; 4688 : 					return(1);
; 4689 : 				}
; 4690 : #ifdef DEBUG
; 4691 : 				printf("leaving par_look_ahead; hex number failure\n");
; 4692 : #endif
; 4693 : 				return(0);
; 4694 : 			}
; 4695 : 			else /* if (char_type==BIN_HEXADECIMAL) */
; 4696 : 			{
; 4697 : 				if (char_type==BIN_RESTORE)

  02733	83 ff 12	 cmp	 edi, 18			; 00000012H
  02736	75 41		 jne	 SHORT $L72439

; 4698 : 				{
; 4699 : 					rule_p++;
; 4700 : 					value=current_rule[rule_p];		/* get the array number */

  02738	33 c0		 xor	 eax, eax
  0273a	8a 44 32 01	 mov	 al, BYTE PTR [edx+esi+1]

; 4701 : 					char_length=match_array->array_lengths[value];	/* get the length of the strig in the array */
; 4702 : 					if ((memcmp(input_array+ipos,match_array->array[value],char_length)==0))

  0273e	8b 74 24 44	 mov	 esi, DWORD PTR _input_array$[esp+56]
  02742	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  02745	8d 14 89	 lea	 edx, DWORD PTR [ecx+ecx*4]

; 4722 : 					{
; 4723 : #ifdef DEBUG
; 4724 : 						printf("par_look_ahead;dictionary_state dict entry found\n");
; 4725 : #endif
; 4726 : 						return(1);
; 4727 : 					}
; 4728 : #ifdef DEBUG
; 4729 : 					printf("par_look_ahead;dictionary_state dict entry not found\n");
; 4730 : #endif
; 4731 : 					return(0);			   

  02748	8b 4c 24 50	 mov	 ecx, DWORD PTR _match_array$[esp+56]
  0274c	8d 54 51 28	 lea	 edx, DWORD PTR [ecx+edx*2+40]
  02750	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  02753	8b 44 24 48	 mov	 eax, DWORD PTR _ipos$[esp+56]
  02757	8b fa		 mov	 edi, edx
  02759	03 f0		 add	 esi, eax
  0275b	33 c0		 xor	 eax, eax
  0275d	f3 a6		 repe cmpsb
  0275f	0f 85 be fe ff
	ff		 jne	 $L73134
  02765	38 1a		 cmp	 BYTE PTR [edx], bl
  02767	0f 84 b6 fe ff
	ff		 je	 $L73134
$L72425:
  0276d	5f		 pop	 edi
  0276e	5e		 pop	 esi

; 4703 : 					{
; 4704 : 						if (match_array->array[value][0]!='\0')
; 4705 : 						{
; 4706 : #ifdef DEBUG
; 4707 : 							printf("leaving par_look_ahead; par_save_string success\n");
; 4708 : #endif
; 4709 : 							return(1);

  0276f	b8 01 00 00 00	 mov	 eax, 1
  02774	5b		 pop	 ebx

; 4732 : 					
; 4733 : 				} /* (char_type==BIN_RESTORE) */
; 4734 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4735 : 		} /* if (char_type<=BIN_DIGIT) */
; 4736 : 	} /* if (char_type==BIN_EXACT) */
; 4737 : 
; 4738 : #ifdef DEBUG
; 4739 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4740 : #endif
; 4741 : 	return(0);
; 4742 : 	
; 4743 : }

  02775	83 c4 30	 add	 esp, 48			; 00000030H
  02778	c3		 ret	 0
$L72439:

; 4710 : 						}
; 4711 : 					}
; 4712 : #ifdef DEBUG
; 4713 : 					printf("leaving par_look_ahead; par_save_string failure\n");
; 4714 : #endif
; 4715 : 					return(0);
; 4716 : 				}
; 4717 : 				else /* (char_type==BIN_RESTORE) */
; 4718 : 				{	/* BIN_DICTIONARY */
; 4719 : 					par_copy_return_value(&new_ret,ret_value);			  

  02779	8b 74 24 54	 mov	 esi, DWORD PTR _ret_value$[esp+56]
  0277d	b9 08 00 00 00	 mov	 ecx, 8
  02782	8d 7c 24 1c	 lea	 edi, DWORD PTR _new_ret$[esp+60]

; 4720 : 					new_ret.input_pos=ipos;
; 4721 : 					if (par_look_ahead_dictionary(current_rule,input_array,match_array,&new_ret))

  02786	8d 44 24 1c	 lea	 eax, DWORD PTR _new_ret$[esp+60]
  0278a	f3 a5		 rep movsd
  0278c	8b 4c 24 48	 mov	 ecx, DWORD PTR _ipos$[esp+56]
  02790	50		 push	 eax
  02791	8b 44 24 48	 mov	 eax, DWORD PTR _input_array$[esp+60]
  02795	89 4c 24 20	 mov	 DWORD PTR _new_ret$[esp+64], ecx
  02799	8b 4c 24 54	 mov	 ecx, DWORD PTR _match_array$[esp+60]
  0279d	51		 push	 ecx
  0279e	50		 push	 eax
  0279f	52		 push	 edx
  027a0	e8 00 00 00 00	 call	 _par_look_ahead_dictionary
  027a5	83 c4 10	 add	 esp, 16			; 00000010H
  027a8	f7 d8		 neg	 eax
  027aa	1b c0		 sbb	 eax, eax
  027ac	5f		 pop	 edi
  027ad	5e		 pop	 esi
  027ae	5b		 pop	 ebx
  027af	f7 d8		 neg	 eax

; 4732 : 					
; 4733 : 				} /* (char_type==BIN_RESTORE) */
; 4734 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4735 : 		} /* if (char_type<=BIN_DIGIT) */
; 4736 : 	} /* if (char_type==BIN_EXACT) */
; 4737 : 
; 4738 : #ifdef DEBUG
; 4739 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4740 : #endif
; 4741 : 	return(0);
; 4742 : 	
; 4743 : }

  027b1	83 c4 30	 add	 esp, 48			; 00000030H
  027b4	c3		 ret	 0
_par_look_ahead ENDP
_input_array$ = 8
_output_array$ = 12
_input_indexes$ = 16
_output_indexes$ = 20
_ret_value$ = 24
_par_copy_word_to_output PROC NEAR

; 4771 : {

  027c0	53		 push	 ebx
  027c1	55		 push	 ebp

; 4772 : 	int i,ipos,opos;
; 4773 : 	
; 4774 : #ifdef DEBUG
; 4775 : 	printf("entering par_copy_word_to_output\n");
; 4776 : #endif
; 4777 : 	if ((ret_value==NULL) || (input_array==NULL) || (output_array==NULL))

  027c2	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ret_value$[esp+4]
  027c6	85 ed		 test	 ebp, ebp
  027c8	0f 84 cb 00 00
	00		 je	 $L72463
  027ce	8b 5c 24 0c	 mov	 ebx, DWORD PTR _input_array$[esp+4]
  027d2	85 db		 test	 ebx, ebx
  027d4	0f 84 bf 00 00
	00		 je	 $L72463
  027da	8b 44 24 10	 mov	 eax, DWORD PTR _output_array$[esp+4]
  027de	85 c0		 test	 eax, eax
  027e0	0f 84 b3 00 00
	00		 je	 $L72463

; 4783 : 	}                      
; 4784 : 	ipos=ret_value->input_pos+ret_value->input_offset;

  027e6	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  027e9	56		 push	 esi
  027ea	8b 75 04	 mov	 esi, DWORD PTR [ebp+4]

; 4785 : 	opos=ret_value->output_pos+ret_value->output_offset;

  027ed	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  027f0	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
  027f3	03 f1		 add	 esi, ecx
  027f5	57		 push	 edi
  027f6	03 d0		 add	 edx, eax

; 4786 : 	i=0;
; 4787 : 	/* this function only copies non whitespace, so it never has to check for indexes */
; 4788 : 	while (((parser_char_types[(int)(input_array[ipos+i])] & TYPE_white)==0) && (input_array[ipos+i]!='\0'))

  027f8	8a 0c 1e	 mov	 cl, BYTE PTR [esi+ebx]
  027fb	33 c0		 xor	 eax, eax
  027fd	8b f9		 mov	 edi, ecx
  027ff	81 e7 ff 00 00
	00		 and	 edi, 255		; 000000ffH
  02805	f6 04 7d 00 00
	00 00 20	 test	 BYTE PTR _parser_char_types[edi*2], 32 ; 00000020H
  0280d	75 69		 jne	 SHORT $L72467
  0280f	8b 5c 24 20	 mov	 ebx, DWORD PTR _output_indexes$[esp+12]
  02813	8d 3c 52	 lea	 edi, DWORD PTR [edx+edx*2]
  02816	8d 3c 7b	 lea	 edi, DWORD PTR [ebx+edi*2]
  02819	8b 5c 24 1c	 mov	 ebx, DWORD PTR _input_indexes$[esp+12]
  0281d	89 7c 24 20	 mov	 DWORD PTR 20+[esp+12], edi
  02821	8d 3c 76	 lea	 edi, DWORD PTR [esi+esi*2]
  02824	8d 3c 7b	 lea	 edi, DWORD PTR [ebx+edi*2]
  02827	8b 5c 24 14	 mov	 ebx, DWORD PTR _input_array$[esp+12]
$L72466:
  0282b	84 c9		 test	 cl, cl
  0282d	74 49		 je	 SHORT $L72467

; 4789 : 	{
; 4790 : 		output_array[opos+i]=input_array[ipos+i];        

  0282f	8b 6c 24 18	 mov	 ebp, DWORD PTR _output_array$[esp+12]
  02833	8d 1c 10	 lea	 ebx, DWORD PTR [eax+edx]

; 4791 : 		/* copy the index anyway even if it isn't there */
; 4792 : 		par_copy_index(output_indexes,opos+i,input_indexes,ipos+i);
; 4793 : #ifdef DEBUG
; 4794 : 		printf("output_array[%d]=%c ",opos+i,output_array[opos+i]);
; 4795 : #endif
; 4796 : 		i++;

  02836	40		 inc	 eax
  02837	88 0c 2b	 mov	 BYTE PTR [ebx+ebp], cl
  0283a	8b 5c 24 20	 mov	 ebx, DWORD PTR 20+[esp+12]
  0283e	8b cf		 mov	 ecx, edi
  02840	83 c7 06	 add	 edi, 6
  02843	8b 29		 mov	 ebp, DWORD PTR [ecx]
  02845	89 2b		 mov	 DWORD PTR [ebx], ebp
  02847	66 8b 49 04	 mov	 cx, WORD PTR [ecx+4]
  0284b	66 89 4b 04	 mov	 WORD PTR [ebx+4], cx
  0284f	8b cb		 mov	 ecx, ebx
  02851	8b 5c 24 14	 mov	 ebx, DWORD PTR _input_array$[esp+12]
  02855	83 c1 06	 add	 ecx, 6
  02858	89 4c 24 20	 mov	 DWORD PTR 20+[esp+12], ecx
  0285c	8d 0c 1e	 lea	 ecx, DWORD PTR [esi+ebx]
  0285f	8a 0c 01	 mov	 cl, BYTE PTR [ecx+eax]
  02862	8b e9		 mov	 ebp, ecx
  02864	81 e5 ff 00 00
	00		 and	 ebp, 255		; 000000ffH
  0286a	f6 04 6d 00 00
	00 00 20	 test	 BYTE PTR _parser_char_types[ebp*2], 32 ; 00000020H
  02872	8b 6c 24 24	 mov	 ebp, DWORD PTR _ret_value$[esp+12]
  02876	74 b3		 je	 SHORT $L72466
$L72467:

; 4797 : 	}
; 4798 : 	ret_value->input_offset+=i;

  02878	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]

; 4799 : 	ret_value->output_offset+=i;

  0287b	8b 7d 0c	 mov	 edi, DWORD PTR [ebp+12]
  0287e	03 c8		 add	 ecx, eax
  02880	03 f8		 add	 edi, eax

; 4800 : 	if (input_array[ipos+i]=='\0')

  02882	03 c6		 add	 eax, esi
  02884	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  02887	89 7d 0c	 mov	 DWORD PTR [ebp+12], edi
  0288a	5f		 pop	 edi
  0288b	8a 04 18	 mov	 al, BYTE PTR [eax+ebx]
  0288e	5e		 pop	 esi
  0288f	f6 d8		 neg	 al
  02891	1b c0		 sbb	 eax, eax
  02893	5d		 pop	 ebp
  02894	f7 d8		 neg	 eax
  02896	48		 dec	 eax
  02897	5b		 pop	 ebx

; 4801 : 	{
; 4802 : #ifdef DEBUG
; 4803 : 		printf("leaving par_copy_word_to_output b -1\n");
; 4804 : #endif
; 4805 : 		return(-1);
; 4806 : 	}
; 4807 : #ifdef DEBUG
; 4808 : 	printf("leaving par_copy_word_to_output b \n");
; 4809 : #endif
; 4810 : 	return(0);
; 4811 : }

  02898	c3		 ret	 0
$L72463:
  02899	5d		 pop	 ebp

; 4778 : 	{
; 4779 : #ifdef DEBUG
; 4780 : 		printf("leaving par_copy_word_to_output a 0\n");
; 4781 : #endif
; 4782 : 		return(0);

  0289a	33 c0		 xor	 eax, eax
  0289c	5b		 pop	 ebx

; 4801 : 	{
; 4802 : #ifdef DEBUG
; 4803 : 		printf("leaving par_copy_word_to_output b -1\n");
; 4804 : #endif
; 4805 : 		return(-1);
; 4806 : 	}
; 4807 : #ifdef DEBUG
; 4808 : 	printf("leaving par_copy_word_to_output b \n");
; 4809 : #endif
; 4810 : 	return(0);
; 4811 : }

  0289d	c3		 ret	 0
_par_copy_word_to_output ENDP
_input_array$ = 8
_input_indexes$ = 12
_output_array$ = 16
_output_indexes$ = 20
_ret_value$ = 24
_ipos$ = -4
_par_skip_white_space PROC NEAR

; 4840 : {

  028a0	83 ec 08	 sub	 esp, 8
  028a3	55		 push	 ebp

; 4841 : 	int i,ipos,opos,j;
; 4842 : 	
; 4843 : #ifdef DEBUG
; 4844 : 	printf("entering par_skip_white_space\n");
; 4845 : #endif
; 4846 : 	if ((ret_value==NULL) || (input_array==NULL) || (output_array==NULL))

  028a4	8b 6c 24 20	 mov	 ebp, DWORD PTR _ret_value$[esp+8]
  028a8	85 ed		 test	 ebp, ebp
  028aa	0f 84 10 01 00
	00		 je	 $L72488
  028b0	8b 44 24 10	 mov	 eax, DWORD PTR _input_array$[esp+8]
  028b4	85 c0		 test	 eax, eax
  028b6	0f 84 04 01 00
	00		 je	 $L72488
  028bc	8b 4c 24 18	 mov	 ecx, DWORD PTR _output_array$[esp+8]
  028c0	85 c9		 test	 ecx, ecx
  028c2	0f 84 f8 00 00
	00		 je	 $L72488

; 4852 : 	}
; 4853 : 	ipos=ret_value->input_pos+ret_value->input_offset;
; 4854 : 	opos=ret_value->output_pos+ret_value->output_offset;

  028c8	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  028cb	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  028ce	53		 push	 ebx
  028cf	8b 5d 04	 mov	 ebx, DWORD PTR [ebp+4]
  028d2	56		 push	 esi
  028d3	8b 75 00	 mov	 esi, DWORD PTR [ebp]
  028d6	03 de		 add	 ebx, esi
  028d8	03 ca		 add	 ecx, edx

; 4855 : 	i=0;                                             
; 4856 : 	j=0;
; 4857 : 	while (((parser_char_types[(int)(input_array[ipos+i])] & TYPE_white)!=0) && (input_array[ipos+i]!='\0'))

  028da	03 c3		 add	 eax, ebx
  028dc	33 d2		 xor	 edx, edx
  028de	89 44 24 0c	 mov	 DWORD PTR -8+[esp+20], eax
  028e2	57		 push	 edi
  028e3	8a 10		 mov	 dl, BYTE PTR [eax]
  028e5	33 f6		 xor	 esi, esi
  028e7	33 ff		 xor	 edi, edi
  028e9	89 5c 24 14	 mov	 DWORD PTR _ipos$[esp+24], ebx
  028ed	f6 04 55 00 00
	00 00 20	 test	 BYTE PTR _parser_char_types[edx*2], 32 ; 00000020H
  028f5	0f 84 9e 00 00
	00		 je	 $L72492
  028fb	8b 54 24 28	 mov	 edx, DWORD PTR _output_indexes$[esp+20]
  028ff	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  02902	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  02905	8d 14 5b	 lea	 edx, DWORD PTR [ebx+ebx*2]
  02908	89 44 24 28	 mov	 DWORD PTR 20+[esp+20], eax
  0290c	8b 44 24 20	 mov	 eax, DWORD PTR _input_indexes$[esp+20]
  02910	8d 44 50 04	 lea	 eax, DWORD PTR [eax+edx*2+4]
$L72491:
  02914	8b 54 24 10	 mov	 edx, DWORD PTR -8+[esp+24]
  02918	8a 14 32	 mov	 dl, BYTE PTR [edx+esi]
  0291b	84 d2		 test	 dl, dl
  0291d	74 7a		 je	 SHORT $L72492

; 4858 : 	{
; 4859 : 		if (i==0 || par_is_index_set(input_indexes,ipos+i))

  0291f	85 f6		 test	 esi, esi
  02921	74 14		 je	 SHORT $L73153
  02923	66 83 78 fc 00	 cmp	 WORD PTR [eax-4], 0
  02928	75 0d		 jne	 SHORT $L73153
  0292a	66 83 78 fe 00	 cmp	 WORD PTR [eax-2], 0
  0292f	75 06		 jne	 SHORT $L73153
  02931	66 83 38 00	 cmp	 WORD PTR [eax], 0
  02935	74 43		 je	 SHORT $L72496
$L73153:

; 4860 : 		{
; 4861 : 			output_array[opos+j]=input_array[ipos+i];

  02937	8b 6c 24 24	 mov	 ebp, DWORD PTR _output_array$[esp+20]
  0293b	8d 1c 0f	 lea	 ebx, DWORD PTR [edi+ecx]
  0293e	88 14 2b	 mov	 BYTE PTR [ebx+ebp], dl

; 4862 : 			if (par_is_index_set(input_indexes,ipos+i))

  02941	66 83 78 fc 00	 cmp	 WORD PTR [eax-4], 0
  02946	75 0d		 jne	 SHORT $L73160
  02948	66 83 78 fe 00	 cmp	 WORD PTR [eax-2], 0
  0294d	75 06		 jne	 SHORT $L73160
  0294f	66 83 38 00	 cmp	 WORD PTR [eax], 0
  02953	74 15		 je	 SHORT $L72495
$L73160:

; 4863 : 			{                                       
; 4864 : #ifdef INDEX_DEBUG
; 4865 : 				printf("copying index from %d to %d\n",ipos+i,opos+j);
; 4866 : #endif
; 4867 : 				par_copy_index(output_indexes,opos+j,input_indexes,ipos+i);

  02955	8b 54 24 28	 mov	 edx, DWORD PTR 20+[esp+20]
  02959	8b 68 fc	 mov	 ebp, DWORD PTR [eax-4]
  0295c	8b da		 mov	 ebx, edx

; 4868 : 				j++;

  0295e	47		 inc	 edi
  0295f	89 2b		 mov	 DWORD PTR [ebx], ebp
  02961	66 8b 28	 mov	 bp, WORD PTR [eax]
  02964	66 89 6b 04	 mov	 WORD PTR [ebx+4], bp

; 4869 : 			}
; 4870 : 			else

  02968	eb 05		 jmp	 SHORT $L73171
$L72495:

; 4871 : 			{
; 4872 : 				j++;

  0296a	8b 54 24 28	 mov	 edx, DWORD PTR 20+[esp+20]
  0296e	47		 inc	 edi
$L73171:
  0296f	8b 6c 24 2c	 mov	 ebp, DWORD PTR _ret_value$[esp+20]
  02973	83 c2 06	 add	 edx, 6
  02976	89 54 24 28	 mov	 DWORD PTR 20+[esp+20], edx
$L72496:
  0297a	8b 5c 24 10	 mov	 ebx, DWORD PTR -8+[esp+24]

; 4873 : 			}
; 4874 : #ifdef INDEX_DEBUG
; 4875 : 			if (i!=0)
; 4876 : 			{
; 4877 : 				printf("copied extra space because of index\n");
; 4878 : 			}
; 4879 : 			printf("output_array[%d]=%c\n",opos+i,output_array[opos+i]);
; 4880 : #endif
; 4881 : 		}
; 4882 : 		i++;

  0297e	46		 inc	 esi
  0297f	33 d2		 xor	 edx, edx
  02981	83 c0 06	 add	 eax, 6
  02984	8a 14 33	 mov	 dl, BYTE PTR [ebx+esi]
  02987	f6 04 55 00 00
	00 00 20	 test	 BYTE PTR _parser_char_types[edx*2], 32 ; 00000020H
  0298f	8b 5c 24 14	 mov	 ebx, DWORD PTR _ipos$[esp+24]
  02993	0f 85 7b ff ff
	ff		 jne	 $L72491
$L72492:

; 4883 : 	}
; 4884 : 	ret_value->input_offset+=i;

  02999	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  0299c	03 ce		 add	 ecx, esi

; 4885 : 	if (i>0)

  0299e	85 f6		 test	 esi, esi
  029a0	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  029a3	7e 03		 jle	 SHORT $L72497

; 4886 : 		ret_value->output_offset+=j;

  029a5	01 7d 0c	 add	 DWORD PTR [ebp+12], edi
$L72497:

; 4887 : 	if (input_array[ipos+i]=='\0')

  029a8	8b 44 24 1c	 mov	 eax, DWORD PTR _input_array$[esp+20]
  029ac	03 f3		 add	 esi, ebx
  029ae	5f		 pop	 edi
  029af	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  029b2	5e		 pop	 esi
  029b3	f6 d8		 neg	 al
  029b5	1b c0		 sbb	 eax, eax
  029b7	5b		 pop	 ebx
  029b8	f7 d8		 neg	 eax
  029ba	48		 dec	 eax
  029bb	5d		 pop	 ebp

; 4888 : 	{
; 4889 : #ifdef DEBUG
; 4890 : 		printf("leaving par_skip_white_space b -1\n");
; 4891 : #endif
; 4892 : 		return(-1);
; 4893 : 	}
; 4894 : #ifdef DEBUG
; 4895 : 	printf("leaving par_skip_white_space b 0\n");
; 4896 : #endif
; 4897 : 	return(0);
; 4898 : }

  029bc	83 c4 08	 add	 esp, 8
  029bf	c3		 ret	 0
$L72488:

; 4847 : 	{
; 4848 : #ifdef DEBUG
; 4849 : 		printf("leaving par_skip_white_space a 0\n");
; 4850 : #endif
; 4851 : 		return(0);

  029c0	33 c0		 xor	 eax, eax
  029c2	5d		 pop	 ebp

; 4888 : 	{
; 4889 : #ifdef DEBUG
; 4890 : 		printf("leaving par_skip_white_space b -1\n");
; 4891 : #endif
; 4892 : 		return(-1);
; 4893 : 	}
; 4894 : #ifdef DEBUG
; 4895 : 	printf("leaving par_skip_white_space b 0\n");
; 4896 : #endif
; 4897 : 	return(0);
; 4898 : }

  029c3	83 c4 08	 add	 esp, 8
  029c6	c3		 ret	 0
_par_skip_white_space ENDP
_TEXT	ENDS
_DATA	SEGMENT
$SG72507 DB	'%s', 0aH, 00H
$SG72508 DB	'error in rule at position %d', 0aH, 00H
	ORG $+2
$SG72509 DB	'rule, %s', 0aH, 00H
	ORG $+2
$SG72510 DB	'      ', 00H
	ORG $+1
$SG72514 DB	' ', 00H
	ORG $+2
$SG72515 DB	'^', 0aH, 00H
_DATA	ENDS
_TEXT	SEGMENT
_message$ = 8
_current_rule$ = 12
_pos$ = 16
_par_print_rule_error PROC NEAR

; 4924 : 	int i;
; 4925 : 	printf("%s\n",message);

  029d0	8b 44 24 04	 mov	 eax, DWORD PTR _message$[esp-4]
  029d4	56		 push	 esi
  029d5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__printf
  029db	57		 push	 edi
  029dc	50		 push	 eax
  029dd	68 00 00 00 00	 push	 OFFSET FLAT:$SG72507
  029e2	ff d6		 call	 esi

; 4926 : 	printf("error in rule at position %d\n",pos);

  029e4	8b 7c 24 1c	 mov	 edi, DWORD PTR _pos$[esp+12]
  029e8	57		 push	 edi
  029e9	68 00 00 00 00	 push	 OFFSET FLAT:$SG72508
  029ee	ff d6		 call	 esi

; 4927 : 	printf("rule, %s\n",current_rule);

  029f0	8b 4c 24 20	 mov	 ecx, DWORD PTR _current_rule$[esp+20]
  029f4	51		 push	 ecx
  029f5	68 00 00 00 00	 push	 OFFSET FLAT:$SG72509
  029fa	ff d6		 call	 esi

; 4928 : 	printf("      ");

  029fc	68 00 00 00 00	 push	 OFFSET FLAT:$SG72510
  02a01	ff d6		 call	 esi
  02a03	83 c4 1c	 add	 esp, 28			; 0000001cH

; 4929 : 	for (i=0;i<pos;i++)

  02a06	85 ff		 test	 edi, edi
  02a08	7e 0d		 jle	 SHORT $L72513
$L72511:

; 4930 : 	{
; 4931 : 		printf(" ");

  02a0a	68 00 00 00 00	 push	 OFFSET FLAT:$SG72514
  02a0f	ff d6		 call	 esi
  02a11	83 c4 04	 add	 esp, 4
  02a14	4f		 dec	 edi
  02a15	75 f3		 jne	 SHORT $L72511
$L72513:

; 4932 : 	}
; 4933 : 	printf("^\n");

  02a17	68 00 00 00 00	 push	 OFFSET FLAT:$SG72515
  02a1c	ff d6		 call	 esi
  02a1e	83 c4 04	 add	 esp, 4
  02a21	5f		 pop	 edi
  02a22	5e		 pop	 esi

; 4934 : }

  02a23	c3		 ret	 0
_par_print_rule_error ENDP
_current_rule$ = 8
_char_type$ = 12
_input_array$ = 16
_match_array$ = 20
_ret_value$ = 24
_lookahead$ = 28
_break_on_min_match$ = 32
_rule_p$ = 12
_length$ = -52
_ipos$ = -20
_min_range$ = -40
_match_is_over$ = -48
_satisfied_min_cond$ = -32
_new_char_type$ = -8
_i$ = -44
_counter$ = 8
_match_non_match$ = -12
_in_rule_p$ = -4
_next_type$ = -36
_num_desc$ = -28
_large_desc$ = -16
_par_match_standard PROC NEAR

; 4997 : {

  02a30	83 ec 34	 sub	 esp, 52			; 00000034H

; 4998 : 	int rule_p;
; 4999 : 	int length=0;
; 5000 : 	int ipos;
; 5001 : 	int min_range= -1,max_range= -1;
; 5002 : 	int match_is_over=0;
; 5003 : 	int satisfied_min_cond= -1;
; 5004 :     int new_char_type;
; 5005 : 	int i=0,counter;          
; 5006 : 	int match_non_match=1;         /* 1 is match 0 is non-match */
; 5007 : //	int find_type= -2;
; 5008 : 	int temp;
; 5009 : 	int temp2;
; 5010 : 	int in_rule_p;
; 5011 : 	int next_type=0;
; 5012 : 	int num_desc;
; 5013 : 	int large_desc=0;
; 5014 : 	
; 5015 : 	
; 5016 : #ifdef DEBUG
; 5017 : 	printf("entering par_match_standard\n");
; 5018 : #endif
; 5019 : #ifdef SANITY_CHECKING
; 5020 : 	if (ret_value==NULL)
; 5021 : 	{
; 5022 : #ifdef DEBUG
; 5023 : 		printf("leaving par_match_standard a 0\n");
; 5024 : #endif
; 5025 : 		return(0);
; 5026 : 	}
; 5027 : 	if ((current_rule==NULL) || (input_array==NULL))
; 5028 : 	{
; 5029 : 		ret_value->value=FATAL_FAIL;
; 5030 : #ifdef DEBUG
; 5031 : 		printf("leaving par_match_standard b 0\n");
; 5032 : #endif
; 5033 : 		return(0);
; 5034 : 	}
; 5035 : #endif
; 5036 : 	rule_p=ret_value->rule;

  02a33	8b 44 24 48	 mov	 eax, DWORD PTR _ret_value$[esp+48]
  02a37	53		 push	 ebx
  02a38	55		 push	 ebp

; 5037 : 	in_rule_p=rule_p;
; 5038 : 	ipos=ret_value->input_pos+ret_value->input_offset;
; 5039 : 	/* skip past the type delimiter */
; 5040 : 	new_char_type=char_type_table[char_type];
; 5041 : 	if (current_rule[rule_p] & BIN_LOOK_FROM_DISABLE)

  02a39	8b 6c 24 40	 mov	 ebp, DWORD PTR _current_rule$[esp+56]
  02a3d	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]
  02a40	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  02a43	56		 push	 esi
  02a44	57		 push	 edi
  02a45	8b 38		 mov	 edi, DWORD PTR [eax]
  02a47	8b 44 24 4c	 mov	 eax, DWORD PTR _char_type$[esp+64]
  02a4b	33 f6		 xor	 esi, esi
  02a4d	b9 01 00 00 00	 mov	 ecx, 1
  02a52	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _char_type_table[eax*4]
  02a59	03 d7		 add	 edx, edi
  02a5b	89 44 24 3c	 mov	 DWORD PTR _new_char_type$[esp+68], eax
  02a5f	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02a62	a8 40		 test	 al, 64			; 00000040H
  02a64	89 74 24 10	 mov	 DWORD PTR _length$[esp+68], esi
  02a68	89 74 24 14	 mov	 DWORD PTR _match_is_over$[esp+68], esi
  02a6c	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR _satisfied_min_cond$[esp+68], -1
  02a74	89 74 24 18	 mov	 DWORD PTR _i$[esp+68], esi
  02a78	89 4c 24 38	 mov	 DWORD PTR _match_non_match$[esp+68], ecx
  02a7c	89 74 24 20	 mov	 DWORD PTR _next_type$[esp+68], esi
  02a80	89 74 24 34	 mov	 DWORD PTR _large_desc$[esp+68], esi
  02a84	89 5c 24 40	 mov	 DWORD PTR _in_rule_p$[esp+68], ebx
  02a88	89 54 24 30	 mov	 DWORD PTR _ipos$[esp+68], edx
  02a8c	74 04		 je	 SHORT $L72548

; 5042 : 	{
; 5043 : 		lookahead=0;

  02a8e	89 74 24 5c	 mov	 DWORD PTR _lookahead$[esp+64], esi
$L72548:

; 5044 : #ifdef DEBUG
; 5045 : 		printf("match_standard set no lookahead\n");
; 5046 : #endif
; 5047 : 	}
; 5048 : 	rule_p++; /* move past operation */

  02a92	43		 inc	 ebx

; 5049 : 	temp=current_rule[rule_p];

  02a93	33 c0		 xor	 eax, eax
  02a95	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]

; 5050 : 	if (temp & BIN_COMPLIMENT)

  02a98	a8 80		 test	 al, -128		; ffffff80H
  02a9a	74 04		 je	 SHORT $L72549

; 5051 : 	{
; 5052 : #ifdef DEBUG
; 5053 : 		printf("match_standard set to non matches\n");
; 5054 : #endif
; 5055 : 		match_non_match=0;

  02a9c	89 74 24 38	 mov	 DWORD PTR _match_non_match$[esp+68], esi
$L72549:

; 5056 : 	}
; 5057 : 	if (temp & BIN_LARGE_DESC)

  02aa0	a8 40		 test	 al, 64			; 00000040H
  02aa2	74 04		 je	 SHORT $L72550

; 5058 : 	{
; 5059 : 		large_desc=1;

  02aa4	89 4c 24 34	 mov	 DWORD PTR _large_desc$[esp+68], ecx
$L72550:

; 5060 : #ifdef DEBUG
; 5061 : 		printf("match_standard using large descriptors\n");
; 5062 : #endif
; 5063 : 	}
; 5064 : 	num_desc=(temp & BIN_SIZE_DESC_MASK);

  02aa8	83 e0 3f	 and	 eax, 63			; 0000003fH

; 5065 : 	counter=0;
; 5066 : 	rule_p++; /* move past number of descrpitors */

  02aab	43		 inc	 ebx
  02aac	8b f8		 mov	 edi, eax

; 5067 : 	if (lookahead!=0)

  02aae	8b 44 24 5c	 mov	 eax, DWORD PTR _lookahead$[esp+64]
  02ab2	85 c0		 test	 eax, eax
  02ab4	89 7c 24 28	 mov	 DWORD PTR _num_desc$[esp+68], edi
  02ab8	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR _counter$[esp+64], 0
  02ac0	74 0a		 je	 SHORT $L73176

; 5068 : 	{
; 5069 : 		next_type=current_rule[rule_p];

  02ac2	33 c9		 xor	 ecx, ecx
  02ac4	8a 0c 2b	 mov	 cl, BYTE PTR [ebx+ebp]

; 5070 : 		rule_p++; /* move past next type */

  02ac7	43		 inc	 ebx
  02ac8	89 4c 24 20	 mov	 DWORD PTR _next_type$[esp+68], ecx
$L73176:

; 5071 : 	}
; 5072 : 	/* either there is a number or there is a star of a plus */ 
; 5073 : 	while ((counter<num_desc) && (match_is_over==0))

  02acc	85 ff		 test	 edi, edi
  02ace	0f 8e af 02 00
	00		 jle	 $L73188
$L72553:
  02ad4	8b 44 24 14	 mov	 eax, DWORD PTR _match_is_over$[esp+68]
  02ad8	85 c0		 test	 eax, eax
  02ada	0f 85 9a 02 00
	00		 jne	 $L73185

; 5074 : 	{
; 5075 : 		if (large_desc)

  02ae0	8b 44 24 34	 mov	 eax, DWORD PTR _large_desc$[esp+68]
  02ae4	85 c0		 test	 eax, eax
  02ae6	74 65		 je	 SHORT $L72555

; 5076 : 		{
; 5077 : 			temp=get_short(current_rule+rule_p);
; 5078 : 			rule_p+=2;
; 5079 : 			counter++;

  02ae8	8b 4c 24 48	 mov	 ecx, DWORD PTR _counter$[esp+64]
  02aec	33 c0		 xor	 eax, eax
  02aee	8a 64 2b 01	 mov	 ah, BYTE PTR [ebx+ebp+1]
  02af2	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02af5	83 c3 02	 add	 ebx, 2
  02af8	41		 inc	 ecx
  02af9	89 5c 24 4c	 mov	 DWORD PTR _rule_p$[esp+64], ebx
  02afd	89 4c 24 48	 mov	 DWORD PTR _counter$[esp+64], ecx

; 5080 : 			min_range = temp & BIN_MAX_LARGE_DESC;

  02b01	8b c8		 mov	 ecx, eax
  02b03	81 e1 ff 3f 00
	00		 and	 ecx, 16383		; 00003fffH

; 5081 : 			max_range=min_range;
; 5082 : 			if (temp & BIN_LARGE_ANY_NUMBER)

  02b09	f6 c4 80	 test	 ah, -128		; ffffff80H
  02b0c	89 4c 24 1c	 mov	 DWORD PTR _min_range$[esp+68], ecx
  02b10	8b f9		 mov	 edi, ecx
  02b12	74 07		 je	 SHORT $L72559

; 5083 : 			{
; 5084 : 				max_range=INT_MAX;

  02b14	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH

; 5085 : 			}
; 5086 : 			else

  02b19	eb 7b		 jmp	 SHORT $L72570
$L72559:

; 5087 : 			{
; 5088 : 				if (temp & BIN_LARGE_CONTINUE)

  02b1b	f6 c4 40	 test	 ah, 64			; 00000040H
  02b1e	74 76		 je	 SHORT $L72570

; 5089 : 				{
; 5090 : 					temp=get_short(current_rule+rule_p);
; 5091 : 					rule_p+=2;
; 5092 : 					counter++;

  02b20	8b 7c 24 48	 mov	 edi, DWORD PTR _counter$[esp+64]
  02b24	33 c0		 xor	 eax, eax
  02b26	8a 64 2b 01	 mov	 ah, BYTE PTR [ebx+ebp+1]
  02b2a	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02b2d	83 c3 02	 add	 ebx, 2
  02b30	47		 inc	 edi
  02b31	89 5c 24 4c	 mov	 DWORD PTR _rule_p$[esp+64], ebx
  02b35	89 7c 24 48	 mov	 DWORD PTR _counter$[esp+64], edi

; 5093 : 					max_range = temp & BIN_MAX_LARGE_DESC;

  02b39	8b f8		 mov	 edi, eax
  02b3b	81 e7 ff 3f 00
	00		 and	 edi, 16383		; 00003fffH

; 5094 : 					if (temp & BIN_LARGE_ANY_NUMBER)

  02b41	f6 c4 80	 test	 ah, -128		; ffffff80H
  02b44	74 50		 je	 SHORT $L72570

; 5095 : 					{
; 5096 : 						max_range=INT_MAX;

  02b46	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH

; 5097 : 					}
; 5098 : 				}
; 5099 : 			}
; 5100 : 		}
; 5101 : 		else

  02b4b	eb 49		 jmp	 SHORT $L72570
$L72555:

; 5102 : 		{
; 5103 : 			temp=current_rule[rule_p];
; 5104 : 			rule_p++;
; 5105 : 			counter++;

  02b4d	8b 7c 24 48	 mov	 edi, DWORD PTR _counter$[esp+64]
  02b51	33 c0		 xor	 eax, eax
  02b53	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02b56	43		 inc	 ebx
  02b57	47		 inc	 edi
  02b58	89 5c 24 4c	 mov	 DWORD PTR _rule_p$[esp+64], ebx
  02b5c	89 7c 24 48	 mov	 DWORD PTR _counter$[esp+64], edi

; 5106 : 			min_range = temp & BIN_MAX_SMALL_DESC;

  02b60	8b f8		 mov	 edi, eax
  02b62	83 e7 3f	 and	 edi, 63			; 0000003fH

; 5107 : 			max_range=min_range;
; 5108 : 			if (temp & BIN_SMALL_ANY_NUMBER)

  02b65	a8 80		 test	 al, -128		; ffffff80H
  02b67	89 7c 24 1c	 mov	 DWORD PTR _min_range$[esp+68], edi

; 5109 : 			{
; 5110 : 				max_range=INT_MAX;
; 5111 : 			}
; 5112 : 			else

  02b6b	75 20		 jne	 SHORT $L73205

; 5113 : 			{
; 5114 : 				if (temp & BIN_SMALL_CONTINUE)

  02b6d	a8 40		 test	 al, 64			; 00000040H
  02b6f	74 21		 je	 SHORT $L73193

; 5115 : 				{
; 5116 : 					temp=current_rule[rule_p];
; 5117 : 					rule_p++;
; 5118 : 					counter++;

  02b71	8b 7c 24 48	 mov	 edi, DWORD PTR _counter$[esp+64]
  02b75	33 c0		 xor	 eax, eax
  02b77	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02b7a	43		 inc	 ebx
  02b7b	47		 inc	 edi
  02b7c	89 5c 24 4c	 mov	 DWORD PTR _rule_p$[esp+64], ebx
  02b80	89 7c 24 48	 mov	 DWORD PTR _counter$[esp+64], edi

; 5119 : 					max_range = temp & BIN_MAX_SMALL_DESC;

  02b84	8b f8		 mov	 edi, eax
  02b86	83 e7 3f	 and	 edi, 63			; 0000003fH

; 5120 : 					if (temp & BIN_SMALL_ANY_NUMBER)

  02b89	a8 80		 test	 al, -128		; ffffff80H
  02b8b	74 05		 je	 SHORT $L73193
$L73205:

; 5121 : 					{
; 5122 : 						max_range=INT_MAX;

  02b8d	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
$L73193:
  02b92	8b 4c 24 1c	 mov	 ecx, DWORD PTR _min_range$[esp+68]
$L72570:

; 5123 : 					}
; 5124 : 				}
; 5125 : 			}
; 5126 : 		}
; 5127 : 		
; 5128 : 		
; 5129 : 		
; 5130 : 		/* do the character matching starting at length until min_length */
; 5131 : 		/* then match from min_length to max_length */
; 5132 : 		/* once min_length is reached, do lookahead for the next char type if necessary */
; 5133 : 		if (min_range==0)

  02b96	85 c9		 test	 ecx, ecx
  02b98	75 3f		 jne	 SHORT $L72574

; 5134 : 		{
; 5135 : 			/* signal that there could be success on a zero length string */
; 5136 : 			/* or the end of string could be successful too */
; 5137 : 			satisfied_min_cond= -2;                          
; 5138 : 			if (length==0)

  02b9a	85 f6		 test	 esi, esi
  02b9c	c7 44 24 24 fe
	ff ff ff	 mov	 DWORD PTR _satisfied_min_cond$[esp+68], -2 ; fffffffeH
  02ba4	75 2f		 jne	 SHORT $L73194

; 5139 : 			{
; 5140 : 				if (lookahead)

  02ba6	8b 44 24 5c	 mov	 eax, DWORD PTR _lookahead$[esp+64]
  02baa	85 c0		 test	 eax, eax
  02bac	74 27		 je	 SHORT $L73194

; 5141 : 				{
; 5142 : 					if ((par_look_ahead(current_rule,input_array,ipos,next_type,match_array,ret_value)==1))

  02bae	8b 44 24 58	 mov	 eax, DWORD PTR _ret_value$[esp+64]
  02bb2	8b 4c 24 54	 mov	 ecx, DWORD PTR _match_array$[esp+64]
  02bb6	50		 push	 eax
  02bb7	8b 44 24 24	 mov	 eax, DWORD PTR _next_type$[esp+72]
  02bbb	51		 push	 ecx
  02bbc	8b 4c 24 58	 mov	 ecx, DWORD PTR _input_array$[esp+72]
  02bc0	50		 push	 eax
  02bc1	52		 push	 edx
  02bc2	51		 push	 ecx
  02bc3	55		 push	 ebp
  02bc4	e8 00 00 00 00	 call	 _par_look_ahead
  02bc9	83 c4 18	 add	 esp, 24			; 00000018H
  02bcc	83 f8 01	 cmp	 eax, 1
  02bcf	0f 84 c1 01 00
	00		 je	 $L73190
$L73194:
  02bd5	8b 54 24 30	 mov	 edx, DWORD PTR _ipos$[esp+68]
$L72574:

; 5143 : 					{
; 5144 : 						break;
; 5145 : 					}
; 5146 : 				}
; 5147 : 			}
; 5148 : 		}
; 5149 : 		if (match_non_match==1)

  02bd9	8b 44 24 38	 mov	 eax, DWORD PTR _match_non_match$[esp+68]

; 5150 : 		{
; 5151 : 			
; 5152 : 			for (i=length;i<max_range;i++)

  02bdd	89 74 24 18	 mov	 DWORD PTR _i$[esp+68], esi
  02be1	83 f8 01	 cmp	 eax, 1
  02be4	0f 85 bc 00 00
	00		 jne	 $L72575
  02bea	3b f7		 cmp	 esi, edi
  02bec	0f 8d 74 01 00
	00		 jge	 $L72589
  02bf2	8b 4c 24 50	 mov	 ecx, DWORD PTR _input_array$[esp+64]
  02bf6	8d 5e 01	 lea	 ebx, DWORD PTR [esi+1]
  02bf9	03 f2		 add	 esi, edx
  02bfb	b8 01 00 00 00	 mov	 eax, 1
  02c00	03 f1		 add	 esi, ecx
  02c02	2b c1		 sub	 eax, ecx
  02c04	89 44 24 2c	 mov	 DWORD PTR -24+[esp+68], eax
$L72576:

; 5153 : 			{
; 5154 : 				temp2=input_array[ipos+i];
; 5155 : 				
; 5156 : 				if ((((parser_char_types[temp2]) & new_char_type)==0) || (temp2=='\0'))

  02c08	8b 4c 24 3c	 mov	 ecx, DWORD PTR _new_char_type$[esp+68]
  02c0c	33 c0		 xor	 eax, eax
  02c0e	8a 06		 mov	 al, BYTE PTR [esi]
  02c10	33 d2		 xor	 edx, edx
  02c12	66 8b 14 45 00
	00 00 00	 mov	 dx, WORD PTR _parser_char_types[eax*2]
  02c1a	85 d1		 test	 edx, ecx
  02c1c	0f 84 34 01 00
	00		 je	 $L73181
  02c22	85 c0		 test	 eax, eax
  02c24	0f 84 2c 01 00
	00		 je	 $L73181

; 5157 : 				{   
; 5158 : 					/* the matching failed in the section between the last range and the current range */
; 5159 : 					/* return length as the number of character matched */
; 5160 : 					match_is_over=1;
; 5161 : 					break;
; 5162 : 				}
; 5163 : 				temp=i+1;
; 5164 : 				if ((temp)>=min_range)

  02c2a	3b 5c 24 1c	 cmp	 ebx, DWORD PTR _min_range$[esp+68]
  02c2e	7c 5e		 jl	 SHORT $L72577

; 5165 : 				{
; 5166 : 					satisfied_min_cond=length=temp;
; 5167 : 					if (break_on_min_match==1)

  02c30	8b 4c 24 60	 mov	 ecx, DWORD PTR _break_on_min_match$[esp+64]
  02c34	b8 01 00 00 00	 mov	 eax, 1
  02c39	3b c8		 cmp	 ecx, eax
  02c3b	89 5c 24 10	 mov	 DWORD PTR _length$[esp+68], ebx
  02c3f	89 5c 24 24	 mov	 DWORD PTR _satisfied_min_cond$[esp+68], ebx
  02c43	0f 84 07 01 00
	00		 je	 $L73180

; 5168 : 					{
; 5169 : 						match_is_over=1;
; 5170 : 						break;
; 5171 : 					}					    
; 5172 : 					if ((lookahead) && ((counter<num_desc) || ( ((temp)<max_range))))

  02c49	8b 44 24 5c	 mov	 eax, DWORD PTR _lookahead$[esp+64]
  02c4d	85 c0		 test	 eax, eax
  02c4f	74 3d		 je	 SHORT $L72577
  02c51	8b 54 24 28	 mov	 edx, DWORD PTR _num_desc$[esp+68]
  02c55	8b 44 24 48	 mov	 eax, DWORD PTR _counter$[esp+64]
  02c59	3b c2		 cmp	 eax, edx
  02c5b	7c 04		 jl	 SHORT $L72584
  02c5d	3b df		 cmp	 ebx, edi
  02c5f	7d 2d		 jge	 SHORT $L72577
$L72584:

; 5173 : 					{
; 5174 : 						if (par_look_ahead(current_rule,input_array,ipos+temp,next_type,match_array,ret_value)==1)

  02c61	8b 44 24 58	 mov	 eax, DWORD PTR _ret_value$[esp+64]
  02c65	8b 4c 24 54	 mov	 ecx, DWORD PTR _match_array$[esp+64]
  02c69	8b 54 24 20	 mov	 edx, DWORD PTR _next_type$[esp+68]
  02c6d	50		 push	 eax
  02c6e	8b 44 24 30	 mov	 eax, DWORD PTR -24+[esp+72]
  02c72	51		 push	 ecx
  02c73	8b 4c 24 58	 mov	 ecx, DWORD PTR _input_array$[esp+72]
  02c77	03 c6		 add	 eax, esi
  02c79	52		 push	 edx
  02c7a	50		 push	 eax
  02c7b	51		 push	 ecx
  02c7c	55		 push	 ebp
  02c7d	e8 00 00 00 00	 call	 _par_look_ahead
  02c82	83 c4 18	 add	 esp, 24			; 00000018H
  02c85	83 f8 01	 cmp	 eax, 1
  02c88	0f 84 c8 00 00
	00		 je	 $L73181
$L72577:

; 5150 : 		{
; 5151 : 			
; 5152 : 			for (i=length;i<max_range;i++)

  02c8e	8b 44 24 18	 mov	 eax, DWORD PTR _i$[esp+68]
  02c92	40		 inc	 eax
  02c93	46		 inc	 esi
  02c94	43		 inc	 ebx
  02c95	3b c7		 cmp	 eax, edi
  02c97	89 44 24 18	 mov	 DWORD PTR _i$[esp+68], eax
  02c9b	0f 8c 67 ff ff
	ff		 jl	 $L72576

; 5141 : 				{
; 5142 : 					if ((par_look_ahead(current_rule,input_array,ipos,next_type,match_array,ret_value)==1))

  02ca1	e9 b8 00 00 00	 jmp	 $L73204
$L72575:

; 5175 : 						{
; 5176 : 							match_is_over=1;
; 5177 : 							break;
; 5178 : 						}
; 5179 : 					}
; 5180 : 				}
; 5181 : 			}
; 5182 : 		}
; 5183 : 		else
; 5184 : 		{
; 5185 : 			for (i=length;i<max_range;i++)

  02ca6	3b f7		 cmp	 esi, edi
  02ca8	0f 8d b8 00 00
	00		 jge	 $L72589
  02cae	8b 4c 24 50	 mov	 ecx, DWORD PTR _input_array$[esp+64]
  02cb2	8d 5e 01	 lea	 ebx, DWORD PTR [esi+1]
  02cb5	03 f2		 add	 esi, edx
  02cb7	b8 01 00 00 00	 mov	 eax, 1
  02cbc	03 f1		 add	 esi, ecx
  02cbe	2b c1		 sub	 eax, ecx
  02cc0	89 44 24 2c	 mov	 DWORD PTR -24+[esp+68], eax
$L72587:

; 5186 : 			{
; 5187 : 				temp2=input_array[ipos+i];
; 5188 : 				
; 5189 : 				if ((((parser_char_types[temp2]) & new_char_type)!=0) || (temp2=='\0'))

  02cc4	8b 4c 24 3c	 mov	 ecx, DWORD PTR _new_char_type$[esp+68]
  02cc8	33 c0		 xor	 eax, eax
  02cca	8a 06		 mov	 al, BYTE PTR [esi]
  02ccc	33 d2		 xor	 edx, edx
  02cce	66 8b 14 45 00
	00 00 00	 mov	 dx, WORD PTR _parser_char_types[eax*2]
  02cd6	85 d1		 test	 edx, ecx
  02cd8	75 7c		 jne	 SHORT $L73181
  02cda	85 c0		 test	 eax, eax
  02cdc	74 78		 je	 SHORT $L73181

; 5194 : 					break;
; 5195 : 				}
; 5196 : 				temp=i+1;
; 5197 : 				if ((temp)>=min_range)

  02cde	3b 5c 24 1c	 cmp	 ebx, DWORD PTR _min_range$[esp+68]
  02ce2	7c 57		 jl	 SHORT $L72588

; 5198 : 				{
; 5199 : 					satisfied_min_cond=length=temp;
; 5200 : 					if (break_on_min_match==1)

  02ce4	8b 4c 24 60	 mov	 ecx, DWORD PTR _break_on_min_match$[esp+64]
  02ce8	b8 01 00 00 00	 mov	 eax, 1
  02ced	3b c8		 cmp	 ecx, eax
  02cef	89 5c 24 10	 mov	 DWORD PTR _length$[esp+68], ebx
  02cf3	89 5c 24 24	 mov	 DWORD PTR _satisfied_min_cond$[esp+68], ebx
  02cf7	74 57		 je	 SHORT $L73180

; 5204 : 					}					    
; 5205 : 					if ((lookahead) && ((counter<num_desc) || (((temp)<max_range))))

  02cf9	8b 44 24 5c	 mov	 eax, DWORD PTR _lookahead$[esp+64]
  02cfd	85 c0		 test	 eax, eax
  02cff	74 3a		 je	 SHORT $L72588
  02d01	8b 54 24 28	 mov	 edx, DWORD PTR _num_desc$[esp+68]
  02d05	8b 44 24 48	 mov	 eax, DWORD PTR _counter$[esp+64]
  02d09	3b c2		 cmp	 eax, edx
  02d0b	7c 04		 jl	 SHORT $L72595
  02d0d	3b df		 cmp	 ebx, edi
  02d0f	7d 2a		 jge	 SHORT $L72588
$L72595:

; 5206 : 					{
; 5207 : 						if (par_look_ahead(current_rule,input_array,ipos+temp,next_type,match_array,ret_value)==1)

  02d11	8b 44 24 58	 mov	 eax, DWORD PTR _ret_value$[esp+64]
  02d15	8b 4c 24 54	 mov	 ecx, DWORD PTR _match_array$[esp+64]
  02d19	8b 54 24 20	 mov	 edx, DWORD PTR _next_type$[esp+68]
  02d1d	50		 push	 eax
  02d1e	8b 44 24 30	 mov	 eax, DWORD PTR -24+[esp+72]
  02d22	51		 push	 ecx
  02d23	52		 push	 edx
  02d24	8b 54 24 5c	 mov	 edx, DWORD PTR _input_array$[esp+76]
  02d28	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  02d2b	51		 push	 ecx
  02d2c	52		 push	 edx
  02d2d	55		 push	 ebp
  02d2e	e8 00 00 00 00	 call	 _par_look_ahead
  02d33	83 c4 18	 add	 esp, 24			; 00000018H
  02d36	83 f8 01	 cmp	 eax, 1
  02d39	74 1b		 je	 SHORT $L73181
$L72588:

; 5175 : 						{
; 5176 : 							match_is_over=1;
; 5177 : 							break;
; 5178 : 						}
; 5179 : 					}
; 5180 : 				}
; 5181 : 			}
; 5182 : 		}
; 5183 : 		else
; 5184 : 		{
; 5185 : 			for (i=length;i<max_range;i++)

  02d3b	8b 44 24 18	 mov	 eax, DWORD PTR _i$[esp+68]
  02d3f	40		 inc	 eax
  02d40	46		 inc	 esi
  02d41	43		 inc	 ebx
  02d42	3b c7		 cmp	 eax, edi
  02d44	89 44 24 18	 mov	 DWORD PTR _i$[esp+68], eax
  02d48	0f 8c 76 ff ff
	ff		 jl	 $L72587

; 5141 : 				{
; 5142 : 					if ((par_look_ahead(current_rule,input_array,ipos,next_type,match_array,ret_value)==1))

  02d4e	eb 0e		 jmp	 SHORT $L73204
$L73180:

; 5201 : 					{
; 5202 : 						match_is_over=1;

  02d50	89 44 24 14	 mov	 DWORD PTR _match_is_over$[esp+68], eax

; 5203 : 						break;

  02d54	eb 08		 jmp	 SHORT $L73204
$L73181:

; 5190 : 				{   
; 5191 : 					/* the matching failed in the section between the last range and the current range */
; 5192 : 					/* return length as the number of character matched */
; 5193 : 					match_is_over=1;

  02d56	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _match_is_over$[esp+68], 1
$L73204:
  02d5e	8b 74 24 10	 mov	 esi, DWORD PTR _length$[esp+68]
  02d62	8b 5c 24 4c	 mov	 ebx, DWORD PTR _rule_p$[esp+64]
$L72589:
  02d66	8b 7c 24 28	 mov	 edi, DWORD PTR _num_desc$[esp+68]
  02d6a	8b 44 24 48	 mov	 eax, DWORD PTR _counter$[esp+64]
  02d6e	8b 54 24 30	 mov	 edx, DWORD PTR _ipos$[esp+68]
  02d72	3b c7		 cmp	 eax, edi
  02d74	0f 8c 5a fd ff
	ff		 jl	 $L72553
$L73185:

; 5208 : 						{
; 5209 : 							match_is_over=1;
; 5210 : 							break;
; 5211 : 						}
; 5212 : 					}
; 5213 : 				}
; 5214 : 			}
; 5215 : 		}
; 5216 : 	}
; 5217 : #ifdef DEBUG
; 5218 : 	printf("par_match_standard;rule_p=%d\n",rule_p);
; 5219 : #endif
; 5220 : 	/* look for the next format type specifier */
; 5221 : 	/* look up in the table of ambiguity to know whether or not to do the lookahead parsing */
; 5222 : 	/* start mathcing the string */
; 5223 : 	/* once the minimum requirement for the type is met, start checking for the next type if required */
; 5224 : 	/* end the matching once the lookahead is successful or the current match hits the maximum 
; 5225 : 	number of characters */                
; 5226 : 	if (satisfied_min_cond== -1)

  02d7a	8b 44 24 24	 mov	 eax, DWORD PTR _satisfied_min_cond$[esp+68]
  02d7e	83 f8 ff	 cmp	 eax, -1
  02d81	75 0a		 jne	 SHORT $L72597
$L73188:
  02d83	5f		 pop	 edi
  02d84	5e		 pop	 esi
  02d85	5d		 pop	 ebp

; 5227 : 	{   /* changed for speed */ 
; 5228 : //		ret_value->value=FAIL;
; 5229 : 		return(0);

  02d86	33 c0		 xor	 eax, eax
  02d88	5b		 pop	 ebx

; 5269 : }

  02d89	83 c4 34	 add	 esp, 52			; 00000034H
  02d8c	c3		 ret	 0
$L72597:

; 5230 : 	}
; 5231 : 	if (satisfied_min_cond== -2)

  02d8d	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  02d90	75 37		 jne	 SHORT $L72598

; 5232 : 	{
; 5233 : 		if (length==0)

  02d92	85 f6		 test	 esi, esi
  02d94	75 10		 jne	 SHORT $L72602
$L73190:

; 5234 : 		{
; 5235 : 			length= -2;
; 5236 : 		}
; 5237 : 	}
; 5238 : 	else

  02d96	8b 7c 24 28	 mov	 edi, DWORD PTR _num_desc$[esp+68]
  02d9a	c7 44 24 10 fe
	ff ff ff	 mov	 DWORD PTR _length$[esp+68], -2 ; fffffffeH
  02da2	8b 74 24 10	 mov	 esi, DWORD PTR _length$[esp+68]
$L72602:

; 5245 : 			}
; 5246 : 		}                                        
; 5247 : 	}
; 5248 : 	if (counter!=num_desc)

  02da6	39 7c 24 48	 cmp	 DWORD PTR _counter$[esp+64], edi
  02daa	74 44		 je	 SHORT $L72603

; 5249 : 	{
; 5250 : 		temp=in_rule_p;
; 5251 : 		temp+=2;

  02dac	8b 54 24 40	 mov	 edx, DWORD PTR _in_rule_p$[esp+68]

; 5252 : 		if (lookahead)

  02db0	8b 4c 24 5c	 mov	 ecx, DWORD PTR _lookahead$[esp+64]
  02db4	85 c9		 test	 ecx, ecx
  02db6	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  02db9	74 01		 je	 SHORT $L72604

; 5253 : 			temp++;

  02dbb	40		 inc	 eax
$L72604:

; 5254 : 		if (large_desc)

  02dbc	8b 4c 24 34	 mov	 ecx, DWORD PTR _large_desc$[esp+68]
  02dc0	85 c9		 test	 ecx, ecx
  02dc2	74 24		 je	 SHORT $L72605

; 5255 : 		{
; 5256 : 			temp+=num_desc<<1;

  02dc4	8d 04 78	 lea	 eax, DWORD PTR [eax+edi*2]

; 5257 : 		}
; 5258 : 		else

  02dc7	eb 21		 jmp	 SHORT $L72606
$L72598:

; 5239 : 	{
; 5240 : 		if (input_array[ipos+i]=='\0')

  02dc9	8b 44 24 18	 mov	 eax, DWORD PTR _i$[esp+68]
  02dcd	8b 4c 24 50	 mov	 ecx, DWORD PTR _input_array$[esp+64]
  02dd1	03 d0		 add	 edx, eax
  02dd3	80 3c 0a 00	 cmp	 BYTE PTR [edx+ecx], 0
  02dd7	75 cd		 jne	 SHORT $L72602

; 5241 : 		{
; 5242 : 			if (length==0)

  02dd9	85 f6		 test	 esi, esi
  02ddb	75 c9		 jne	 SHORT $L72602
  02ddd	5f		 pop	 edi
  02dde	5e		 pop	 esi
  02ddf	5d		 pop	 ebp

; 5243 : 			{	/* changed for speed */
; 5244 : 				return(-1);

  02de0	83 c8 ff	 or	 eax, -1
  02de3	5b		 pop	 ebx

; 5269 : }

  02de4	83 c4 34	 add	 esp, 52			; 00000034H
  02de7	c3		 ret	 0
$L72605:

; 5259 : 		{
; 5260 : 			temp+=num_desc;

  02de8	03 c7		 add	 eax, edi
$L72606:

; 5261 : 		}
; 5262 : 		rule_p=temp;

  02dea	89 44 24 4c	 mov	 DWORD PTR _rule_p$[esp+64], eax
  02dee	8b d8		 mov	 ebx, eax
$L72603:

; 5263 : 	}
; 5264 : 	ret_value->rule=rule_p;

  02df0	8b 44 24 58	 mov	 eax, DWORD PTR _ret_value$[esp+64]
  02df4	5f		 pop	 edi
  02df5	89 58 10	 mov	 DWORD PTR [eax+16], ebx

; 5265 : #ifdef DEBUG
; 5266 : 	printf("leaving par_match_standard length=%d ret_value->value=%d\n",length,ret_value->value);
; 5267 : #endif
; 5268 : 	return(length);

  02df8	8b c6		 mov	 eax, esi
  02dfa	5e		 pop	 esi
  02dfb	5d		 pop	 ebp
  02dfc	5b		 pop	 ebx

; 5269 : }

  02dfd	83 c4 34	 add	 esp, 52			; 00000034H
  02e00	c3		 ret	 0
_par_match_standard ENDP
_current_rule$ = 8
_input_array$ = 12
_match_array$ = 16
_ret_value$ = 20
_range_value$ = 24
_lookahead$ = 28
_break_on_min_match$ = 32
_length$ = -24
_ipos$ = -28
_max_range$ = -8
_match_is_over$ = -36
_satisfied_min_cond$ = -16
_satisfied_start$ = -12
_temp_num$ = -40
_i$ = -44
_counter$ = 8
_in_rule_p$ = -4
_next_type$ = -20
_num_desc$ = -48
_large_desc$ = -32
_par_match_digits PROC NEAR

; 5306 : {

  02e10	83 ec 30	 sub	 esp, 48			; 00000030H

; 5307 : 	int rule_p;							/* a temproary rule pointer */
; 5308 : 	int	length=0;						/* the length of the matched characters */
; 5309 : 	int	ipos;							/* the input_pos+input_offset from ret_value */
; 5310 : 	int min_range= -1;					/* the minimum value of the current range */
; 5311 : 	int	max_range= -1;					/* the maximum value of the range */
; 5312 : 	int	match_is_over=0;				/* a flag to signal that the matching has failed */
; 5313 : 	int	satisfied_min_cond= -1;			/* holds the value of the largest number that

  02e13	83 c8 ff	 or	 eax, -1
  02e16	53		 push	 ebx
  02e17	89 44 24 24	 mov	 DWORD PTR _satisfied_min_cond$[esp+52], eax

; 5314 : 										* is still in the range found so far */
; 5315 : 	int	satisfied_start= -1;			/* holds the starting value of the number in satisfied_min_cond */

  02e1b	89 44 24 28	 mov	 DWORD PTR _satisfied_start$[esp+52], eax

; 5316 : 	int temp_num=0;						/* a temporary variable to hold the current number being processes */
; 5317 : 	int end_of_type=0;					/* flag that signals the end of the type specifier has been reached in the rule */
; 5318 : 	register int i=0;
; 5319 : 	int counter;          
; 5320 : 	//int find_type= -2;						/* the type that par_look_ahead found */
; 5321 : 	int temp;
; 5322 : 	int in_rule_p;
; 5323 : 	int next_type=0;
; 5324 : 	int num_desc;
; 5325 : 	int new_char_type;
; 5326 : 	int large_desc=0;
; 5327 : 	
; 5328 : 	
; 5329 : #ifdef DEBUG
; 5330 : 	printf("entering par_match_digits\n");
; 5331 : #endif            
; 5332 : #ifdef SANITY_CHECKING
; 5333 : 	if (ret_value==NULL)
; 5334 : 	{
; 5335 : #ifdef DEBUG
; 5336 : 		printf("leaving par_match_digits a 0\n");
; 5337 : #endif
; 5338 : 		return(0);
; 5339 : 	}
; 5340 : 	if ((current_rule==NULL) || (input_array==NULL) ||
; 5341 : 		(range_value==NULL))
; 5342 : 	{
; 5343 : 		ret_value->value=FATAL_FAIL;
; 5344 : #ifdef DEBUG
; 5345 : 		printf("leaving par_match_digits b 0\n");
; 5346 : #endif
; 5347 : 		return(0);
; 5348 : 	}
; 5349 : #endif
; 5350 : 	
; 5351 : 	rule_p=ret_value->rule;

  02e1f	8b 44 24 44	 mov	 eax, DWORD PTR _ret_value$[esp+48]
  02e23	55		 push	 ebp

; 5352 : 	in_rule_p=rule_p;
; 5353 : 	ipos=ret_value->input_pos+ret_value->input_offset;
; 5354 : 	/* skip past the type delimiter */
; 5355 : 	new_char_type=char_type_table[BIN_DIGIT];
; 5356 : 	if (current_rule[rule_p] & BIN_LOOK_FROM_DISABLE)

  02e24	8b 6c 24 3c	 mov	 ebp, DWORD PTR _current_rule$[esp+52]
  02e28	56		 push	 esi
  02e29	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  02e2c	8b 10		 mov	 edx, DWORD PTR [eax]
  02e2e	57		 push	 edi
  02e2f	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  02e32	33 f6		 xor	 esi, esi
  02e34	03 ca		 add	 ecx, edx
  02e36	8a 04 2f	 mov	 al, BYTE PTR [edi+ebp]
  02e39	89 74 24 28	 mov	 DWORD PTR _length$[esp+64], esi
  02e3d	a8 40		 test	 al, 64			; 00000040H
  02e3f	89 74 24 1c	 mov	 DWORD PTR _match_is_over$[esp+64], esi
  02e43	89 74 24 18	 mov	 DWORD PTR _temp_num$[esp+64], esi
  02e47	89 74 24 14	 mov	 DWORD PTR _i$[esp+64], esi
  02e4b	89 74 24 2c	 mov	 DWORD PTR _next_type$[esp+64], esi
  02e4f	89 74 24 20	 mov	 DWORD PTR _large_desc$[esp+64], esi
  02e53	89 7c 24 3c	 mov	 DWORD PTR _in_rule_p$[esp+64], edi
  02e57	89 4c 24 24	 mov	 DWORD PTR _ipos$[esp+64], ecx
  02e5b	74 04		 je	 SHORT $L72640

; 5357 : 	{
; 5358 : 		lookahead=0;

  02e5d	89 74 24 58	 mov	 DWORD PTR _lookahead$[esp+60], esi
$L72640:

; 5359 : #ifdef DEBUG
; 5360 : 		printf("match_standard set no lookahead\n");
; 5361 : #endif
; 5362 : 	}
; 5363 : 	rule_p++; /* move past operation */
; 5364 : 	if (current_rule[rule_p] & BIN_LARGE_DESC)

  02e61	8a 44 2f 01	 mov	 al, BYTE PTR [edi+ebp+1]
  02e65	47		 inc	 edi
  02e66	a8 40		 test	 al, 64			; 00000040H

; 5365 : 	{
; 5366 : 		large_desc=1;

  02e68	ba 01 00 00 00	 mov	 edx, 1
  02e6d	74 04		 je	 SHORT $L72641
  02e6f	89 54 24 20	 mov	 DWORD PTR _large_desc$[esp+64], edx
$L72641:

; 5367 : #ifdef DEBUG
; 5368 : 		printf("match_standard using large descriptors\n");
; 5369 : #endif
; 5370 : 	}
; 5371 : 	num_desc=(current_rule[rule_p] & BIN_SIZE_DESC_MASK);
; 5372 : 	counter=0;
; 5373 : 	rule_p++; /* move past number of descrpitors */
; 5374 : 	if (lookahead!=0)

  02e73	8b 4c 24 58	 mov	 ecx, DWORD PTR _lookahead$[esp+60]
  02e77	83 e0 3f	 and	 eax, 63			; 0000003fH
  02e7a	47		 inc	 edi
  02e7b	3b ce		 cmp	 ecx, esi
  02e7d	89 44 24 10	 mov	 DWORD PTR _num_desc$[esp+64], eax
  02e81	89 74 24 44	 mov	 DWORD PTR _counter$[esp+60], esi
  02e85	74 0a		 je	 SHORT $L73207

; 5375 : 	{
; 5376 : 		next_type=current_rule[rule_p];

  02e87	33 c9		 xor	 ecx, ecx
  02e89	8a 0c 2f	 mov	 cl, BYTE PTR [edi+ebp]

; 5377 : 		rule_p++; /* move past next type */

  02e8c	47		 inc	 edi
  02e8d	89 4c 24 2c	 mov	 DWORD PTR _next_type$[esp+64], ecx
$L73207:

; 5378 : 	}
; 5379 : 	/* either there is a number or there is a star of a plus */ 
; 5380 : 	
; 5381 : 	while ((counter<num_desc) && (match_is_over==0))

  02e91	8b 5c 24 54	 mov	 ebx, DWORD PTR _range_value$[esp+60]
  02e95	3b c6		 cmp	 eax, esi
  02e97	0f 8e 03 02 00
	00		 jle	 $L73211
  02e9d	eb 0b		 jmp	 SHORT $L72644
$L73215:
  02e9f	8b 44 24 10	 mov	 eax, DWORD PTR _num_desc$[esp+64]
  02ea3	ba 01 00 00 00	 mov	 edx, 1
  02ea8	33 f6		 xor	 esi, esi
$L72644:
  02eaa	39 74 24 1c	 cmp	 DWORD PTR _match_is_over$[esp+64], esi
  02eae	0f 85 ec 01 00
	00		 jne	 $L73211

; 5382 : 	{
; 5383 : 		if (large_desc)

  02eb4	39 74 24 20	 cmp	 DWORD PTR _large_desc$[esp+64], esi
  02eb8	74 4c		 je	 SHORT $L72646

; 5384 : 		{
; 5385 : 			temp=get_short(current_rule+rule_p);
; 5386 : 			rule_p+=2;
; 5387 : 			counter++;

  02eba	8b 44 24 44	 mov	 eax, DWORD PTR _counter$[esp+60]
  02ebe	33 c9		 xor	 ecx, ecx
  02ec0	8a 6c 2f 01	 mov	 ch, BYTE PTR [edi+ebp+1]
  02ec4	8a 0c 2f	 mov	 cl, BYTE PTR [edi+ebp]
  02ec7	83 c7 02	 add	 edi, 2
  02eca	40		 inc	 eax
  02ecb	89 44 24 44	 mov	 DWORD PTR _counter$[esp+60], eax

; 5388 : 			min_range = temp & BIN_MAX_LARGE_DESC;

  02ecf	8b c1		 mov	 eax, ecx
  02ed1	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH

; 5389 : 			max_range=min_range;
; 5390 : 			if (temp & BIN_LARGE_ANY_NUMBER)

  02ed6	f6 c5 80	 test	 ch, -128		; ffffff80H
  02ed9	8b f0		 mov	 esi, eax

; 5391 : 			{
; 5392 : 				max_range=INT_MAX;
; 5393 : 			}
; 5394 : 			else

  02edb	75 62		 jne	 SHORT $L73224

; 5395 : 			{
; 5396 : 				if (temp & BIN_LARGE_CONTINUE)

  02edd	f6 c5 40	 test	 ch, 64			; 00000040H
  02ee0	74 62		 je	 SHORT $L72661

; 5397 : 				{
; 5398 : 					temp=get_short(current_rule+rule_p);
; 5399 : 					rule_p+=2;
; 5400 : 					counter++;

  02ee2	8b 74 24 44	 mov	 esi, DWORD PTR _counter$[esp+60]
  02ee6	33 c9		 xor	 ecx, ecx
  02ee8	8a 6c 2f 01	 mov	 ch, BYTE PTR [edi+ebp+1]
  02eec	8a 0c 2f	 mov	 cl, BYTE PTR [edi+ebp]
  02eef	83 c7 02	 add	 edi, 2
  02ef2	46		 inc	 esi
  02ef3	89 74 24 44	 mov	 DWORD PTR _counter$[esp+60], esi

; 5401 : 					max_range = temp & BIN_MAX_LARGE_DESC;

  02ef7	8b f1		 mov	 esi, ecx
  02ef9	81 e6 ff 3f 00
	00		 and	 esi, 16383		; 00003fffH

; 5402 : 					if (temp & BIN_LARGE_ANY_NUMBER)

  02eff	f6 c5 80	 test	 ch, -128		; ffffff80H
  02f02	74 40		 je	 SHORT $L72661

; 5403 : 					{
; 5404 : 						max_range=INT_MAX;
; 5405 : 					}
; 5406 : 				}
; 5407 : 			}
; 5408 : 		}
; 5409 : 		else

  02f04	eb 39		 jmp	 SHORT $L73224
$L72646:

; 5410 : 		{
; 5411 : 			temp=current_rule[rule_p];
; 5412 : 			rule_p++;
; 5413 : 			counter++;

  02f06	8b 44 24 44	 mov	 eax, DWORD PTR _counter$[esp+60]
  02f0a	33 c9		 xor	 ecx, ecx
  02f0c	8a 0c 2f	 mov	 cl, BYTE PTR [edi+ebp]
  02f0f	47		 inc	 edi
  02f10	40		 inc	 eax
  02f11	89 44 24 44	 mov	 DWORD PTR _counter$[esp+60], eax

; 5414 : 			min_range = temp & BIN_MAX_SMALL_DESC;

  02f15	8b c1		 mov	 eax, ecx
  02f17	83 e0 3f	 and	 eax, 63			; 0000003fH

; 5415 : 			max_range=min_range;
; 5416 : 			if (temp & BIN_SMALL_ANY_NUMBER)

  02f1a	f6 c1 80	 test	 cl, -128		; ffffff80H
  02f1d	8b f0		 mov	 esi, eax

; 5417 : 			{
; 5418 : 				max_range=INT_MAX;
; 5419 : 			}
; 5420 : 			else

  02f1f	75 1e		 jne	 SHORT $L73224

; 5421 : 			{
; 5422 : 				if (temp & BIN_SMALL_CONTINUE)

  02f21	f6 c1 40	 test	 cl, 64			; 00000040H
  02f24	74 1e		 je	 SHORT $L72661

; 5423 : 				{
; 5424 : 					temp=current_rule[rule_p];
; 5425 : 					rule_p++;
; 5426 : 					counter++;

  02f26	8b 74 24 44	 mov	 esi, DWORD PTR _counter$[esp+60]
  02f2a	33 c9		 xor	 ecx, ecx
  02f2c	8a 0c 2f	 mov	 cl, BYTE PTR [edi+ebp]
  02f2f	47		 inc	 edi
  02f30	46		 inc	 esi
  02f31	89 74 24 44	 mov	 DWORD PTR _counter$[esp+60], esi

; 5427 : 					max_range = temp & BIN_MAX_SMALL_DESC;

  02f35	8b f1		 mov	 esi, ecx
  02f37	83 e6 3f	 and	 esi, 63			; 0000003fH

; 5428 : 					if (temp & BIN_SMALL_ANY_NUMBER)

  02f3a	f6 c1 80	 test	 cl, -128		; ffffff80H
  02f3d	74 05		 je	 SHORT $L72661
$L73224:

; 5429 : 					{
; 5430 : 						max_range=INT_MAX;

  02f3f	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
$L72661:

; 5431 : 					}
; 5432 : 				}
; 5433 : 			}
; 5434 : 		}
; 5435 : 		
; 5436 : 		/* do the character matching starting at length until min_length */
; 5437 : 		/* then match from min_length to max_length */
; 5438 : 		/* once min_length is reached, do lookahead for the next char type if necessary */
; 5439 : 		/* this is the conversion from actual number to number lengths */
; 5440 : 		if (range_value->range_set==0)

  02f44	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  02f47	85 c9		 test	 ecx, ecx
  02f49	75 07		 jne	 SHORT $L72662

; 5441 : 		{
; 5442 : 			range_value->range_set=1;

  02f4b	89 53 0c	 mov	 DWORD PTR [ebx+12], edx

; 5443 : 			range_value->start=min_range;

  02f4e	89 03		 mov	 DWORD PTR [ebx], eax

; 5444 : 		}
; 5445 : 		else

  02f50	eb 1f		 jmp	 SHORT $L72665
$L72662:

; 5446 : 		{
; 5447 : 			if (range_value->range_set==2)

  02f52	83 f9 02	 cmp	 ecx, 2
  02f55	75 07		 jne	 SHORT $L72664

; 5448 : 			{
; 5449 : 				range_value->range_set= -1;

  02f57	c7 43 0c ff ff
	ff ff		 mov	 DWORD PTR [ebx+12], -1
$L72664:

; 5450 : 			}
; 5451 : 			if (range_value->range_set==1)

  02f5e	39 53 0c	 cmp	 DWORD PTR [ebx+12], edx
  02f61	75 0e		 jne	 SHORT $L72665

; 5452 : 			{
; 5453 : 				range_value->start+=((min_range-range_value->end)-1);

  02f63	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  02f66	8b d0		 mov	 edx, eax
  02f68	2b d1		 sub	 edx, ecx
  02f6a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  02f6c	4a		 dec	 edx
  02f6d	03 ca		 add	 ecx, edx
  02f6f	89 0b		 mov	 DWORD PTR [ebx], ecx
$L72665:

; 5457 : 		range_value->end=max_range;
; 5458 : 		min_range=par_get_int_length(min_range);

  02f71	50		 push	 eax
  02f72	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  02f75	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  02f78	e8 00 00 00 00	 call	 _par_get_int_length

; 5459 : 		max_range=par_get_int_length(max_range);

  02f7d	56		 push	 esi
  02f7e	e8 00 00 00 00	 call	 _par_get_int_length

; 5460 : #ifdef DIGIT_DEBUG
; 5461 : 		printf("par_match_digits; before match length=%d match_is_over=%d satisfied_min_cond=%d\n",length,match_is_over,satisfied_min_cond);
; 5462 : 		printf("par_match_digits; before match min_range=%d max_range=%d\n",min_range,max_range);
; 5463 : #endif
; 5464 : 		for (i=0;(((parser_char_types[input_array[ipos+i]] & TYPE_digit)!=0) &&
; 5465 : 			((temp_num=par_convert_number(input_array+ipos,i+1))<=range_value->end) &&
; 5466 : 			(i<max_range))
; 5467 : 			;i++)

  02f83	8b 4c 24 50	 mov	 ecx, DWORD PTR _input_array$[esp+68]
  02f87	89 44 24 40	 mov	 DWORD PTR _max_range$[esp+72], eax
  02f8b	8b 44 24 2c	 mov	 eax, DWORD PTR _ipos$[esp+72]
  02f8f	33 d2		 xor	 edx, edx
  02f91	03 c1		 add	 eax, ecx
  02f93	83 c4 08	 add	 esp, 8
  02f96	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _i$[esp+64], 0
  02f9e	89 44 24 54	 mov	 DWORD PTR 24+[esp+60], eax
  02fa2	8a 10		 mov	 dl, BYTE PTR [eax]
  02fa4	f6 04 55 00 00
	00 00 01	 test	 BYTE PTR _parser_char_types[edx*2], 1
  02fac	0f 84 c5 00 00
	00		 je	 $L73218

; 5454 : 			}
; 5455 : 		}
; 5456 : 		range_value->min=min_range;

  02fb2	be 01 00 00 00	 mov	 esi, 1
  02fb7	eb 04		 jmp	 SHORT $L72666
$L73217:
  02fb9	8b 44 24 54	 mov	 eax, DWORD PTR 24+[esp+60]
$L72666:

; 5460 : #ifdef DIGIT_DEBUG
; 5461 : 		printf("par_match_digits; before match length=%d match_is_over=%d satisfied_min_cond=%d\n",length,match_is_over,satisfied_min_cond);
; 5462 : 		printf("par_match_digits; before match min_range=%d max_range=%d\n",min_range,max_range);
; 5463 : #endif
; 5464 : 		for (i=0;(((parser_char_types[input_array[ipos+i]] & TYPE_digit)!=0) &&
; 5465 : 			((temp_num=par_convert_number(input_array+ipos,i+1))<=range_value->end) &&
; 5466 : 			(i<max_range))
; 5467 : 			;i++)

  02fbd	56		 push	 esi
  02fbe	50		 push	 eax
  02fbf	e8 00 00 00 00	 call	 _par_convert_number
  02fc4	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  02fc7	83 c4 08	 add	 esp, 8
  02fca	3b c1		 cmp	 eax, ecx
  02fcc	89 44 24 18	 mov	 DWORD PTR _temp_num$[esp+64], eax
  02fd0	0f 8f aa 00 00
	00		 jg	 $L73226
  02fd6	8b 54 24 38	 mov	 edx, DWORD PTR _max_range$[esp+64]
  02fda	8b 4c 24 14	 mov	 ecx, DWORD PTR _i$[esp+64]
  02fde	3b ca		 cmp	 ecx, edx
  02fe0	0f 8d 95 00 00
	00		 jge	 $L72668

; 5468 : 		{
; 5469 : #ifdef DIGIT_DEBUG
; 5470 : 			printf("looping in par_match_digits i=%d temp_num=%d\n",i,temp_num);
; 5471 : #endif
; 5472 : 			if (temp_num>=range_value->min)

  02fe6	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  02fe9	7c 5b		 jl	 SHORT $L72667

; 5473 : 			{
; 5474 : #ifdef DIGIT_DEBUG
; 5475 : 				printf("matched %d\n",temp_num);
; 5476 : #endif
; 5477 : 				temp=length=i+1;
; 5478 : 				satisfied_min_cond=temp_num;
; 5479 : 				satisfied_start=range_value->start;

  02feb	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  02fed	89 74 24 28	 mov	 DWORD PTR _length$[esp+64], esi
  02ff1	89 4c 24 34	 mov	 DWORD PTR _satisfied_start$[esp+64], ecx

; 5480 : 				if (break_on_min_match==1)

  02ff5	b9 01 00 00 00	 mov	 ecx, 1
  02ffa	39 4c 24 5c	 cmp	 DWORD PTR _break_on_min_match$[esp+60], ecx
  02ffe	89 44 24 30	 mov	 DWORD PTR _satisfied_min_cond$[esp+64], eax
  03002	74 65		 je	 SHORT $L73209

; 5484 : 				}
; 5485 : 				if ((lookahead) && ((counter<num_desc) || (((temp)<max_range))))

  03004	8b 44 24 58	 mov	 eax, DWORD PTR _lookahead$[esp+60]
  03008	85 c0		 test	 eax, eax
  0300a	74 3a		 je	 SHORT $L72667
  0300c	8b 44 24 10	 mov	 eax, DWORD PTR _num_desc$[esp+64]
  03010	8b 4c 24 44	 mov	 ecx, DWORD PTR _counter$[esp+60]
  03014	3b c8		 cmp	 ecx, eax
  03016	7c 04		 jl	 SHORT $L72672
  03018	3b f2		 cmp	 esi, edx
  0301a	7d 2a		 jge	 SHORT $L72667
$L72672:

; 5486 : 				{
; 5487 : 					if (par_look_ahead(current_rule,input_array,ipos+temp,next_type,match_array,ret_value)==1)

  0301c	8b 4c 24 50	 mov	 ecx, DWORD PTR _ret_value$[esp+60]
  03020	8b 54 24 4c	 mov	 edx, DWORD PTR _match_array$[esp+60]
  03024	8b 44 24 2c	 mov	 eax, DWORD PTR _next_type$[esp+64]
  03028	51		 push	 ecx
  03029	8b 4c 24 28	 mov	 ecx, DWORD PTR _ipos$[esp+68]
  0302d	52		 push	 edx
  0302e	50		 push	 eax
  0302f	8b 44 24 54	 mov	 eax, DWORD PTR _input_array$[esp+72]
  03033	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  03036	52		 push	 edx
  03037	50		 push	 eax
  03038	55		 push	 ebp
  03039	e8 00 00 00 00	 call	 _par_look_ahead
  0303e	83 c4 18	 add	 esp, 24			; 00000018H
  03041	83 f8 01	 cmp	 eax, 1
  03044	74 29		 je	 SHORT $L73210
$L72667:

; 5460 : #ifdef DIGIT_DEBUG
; 5461 : 		printf("par_match_digits; before match length=%d match_is_over=%d satisfied_min_cond=%d\n",length,match_is_over,satisfied_min_cond);
; 5462 : 		printf("par_match_digits; before match min_range=%d max_range=%d\n",min_range,max_range);
; 5463 : #endif
; 5464 : 		for (i=0;(((parser_char_types[input_array[ipos+i]] & TYPE_digit)!=0) &&
; 5465 : 			((temp_num=par_convert_number(input_array+ipos,i+1))<=range_value->end) &&
; 5466 : 			(i<max_range))
; 5467 : 			;i++)

  03046	8b 44 24 14	 mov	 eax, DWORD PTR _i$[esp+64]
  0304a	8b 54 24 54	 mov	 edx, DWORD PTR 24+[esp+60]
  0304e	40		 inc	 eax
  0304f	33 c9		 xor	 ecx, ecx
  03051	89 44 24 14	 mov	 DWORD PTR _i$[esp+64], eax
  03055	46		 inc	 esi
  03056	8a 0c 02	 mov	 cl, BYTE PTR [edx+eax]
  03059	f6 04 4d 00 00
	00 00 01	 test	 BYTE PTR _parser_char_types[ecx*2], 1
  03061	0f 85 52 ff ff
	ff		 jne	 $L73217

; 5490 : 						break;
; 5491 : 					}
; 5492 : 				}
; 5493 : 			}
; 5494 : 		}
; 5495 : 		if ((temp_num>range_value->end) && (counter==num_desc))

  03067	eb 0e		 jmp	 SHORT $L73218
$L73209:

; 5481 : 				{
; 5482 : 					match_is_over=1;

  03069	89 4c 24 1c	 mov	 DWORD PTR _match_is_over$[esp+64], ecx

; 5483 : 					break;

  0306d	eb 0c		 jmp	 SHORT $L72668
$L73210:

; 5488 : 					{
; 5489 : 						match_is_over=1;

  0306f	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _match_is_over$[esp+64], 1
$L73218:
  03077	8b 44 24 18	 mov	 eax, DWORD PTR _temp_num$[esp+64]
$L72668:

; 5490 : 						break;
; 5491 : 					}
; 5492 : 				}
; 5493 : 			}
; 5494 : 		}
; 5495 : 		if ((temp_num>range_value->end) && (counter==num_desc))

  0307b	3b 43 04	 cmp	 eax, DWORD PTR [ebx+4]
  0307e	7e 0c		 jle	 SHORT $L72674
$L73226:
  03080	8b 44 24 44	 mov	 eax, DWORD PTR _counter$[esp+60]
  03084	8b 4c 24 10	 mov	 ecx, DWORD PTR _num_desc$[esp+64]
  03088	3b c1		 cmp	 eax, ecx
  0308a	74 39		 je	 SHORT $L73222
$L72674:

; 5378 : 	}
; 5379 : 	/* either there is a number or there is a star of a plus */ 
; 5380 : 	
; 5381 : 	while ((counter<num_desc) && (match_is_over==0))

  0308c	8b 4c 24 10	 mov	 ecx, DWORD PTR _num_desc$[esp+64]
  03090	8b 44 24 44	 mov	 eax, DWORD PTR _counter$[esp+60]
  03094	3b c1		 cmp	 eax, ecx
  03096	0f 8c 03 fe ff
	ff		 jl	 $L73215
  0309c	8b c1		 mov	 eax, ecx
  0309e	33 f6		 xor	 esi, esi
$L73211:

; 5496 : 		{
; 5497 : 			break;
; 5498 : 		}
; 5499 : 	}                              
; 5500 : #ifdef DIGIT_DEBUG
; 5501 : 	printf("take 2 length=%d match_is_over=%d satisfied_min_cond=%d\n",length,match_is_over,satisfied_min_cond);
; 5502 : 	printf("take 2 min_range=%d max_range=%d\n",min_range,max_range);
; 5503 : #endif
; 5504 : #ifdef DEBUG
; 5505 : 	printf("par_match_digits;rule_p=%d\n",rule_p);
; 5506 : #endif
; 5507 : 	if (counter!=num_desc)

  030a0	39 44 24 44	 cmp	 DWORD PTR _counter$[esp+60], eax
  030a4	74 21		 je	 SHORT $L72675

; 5508 : 	{
; 5509 : 		temp=in_rule_p;
; 5510 : 		temp+=2;

  030a6	8b 54 24 3c	 mov	 edx, DWORD PTR _in_rule_p$[esp+64]

; 5511 : 		if (lookahead)

  030aa	8b 4c 24 58	 mov	 ecx, DWORD PTR _lookahead$[esp+60]
  030ae	3b ce		 cmp	 ecx, esi
  030b0	8d 7a 02	 lea	 edi, DWORD PTR [edx+2]
  030b3	74 01		 je	 SHORT $L72676

; 5512 : 			temp++;

  030b5	47		 inc	 edi
$L72676:

; 5513 : 		if (large_desc)

  030b6	39 74 24 20	 cmp	 DWORD PTR _large_desc$[esp+64], esi
  030ba	74 05		 je	 SHORT $L72677

; 5514 : 		{
; 5515 : 			temp+=num_desc<<1;

  030bc	8d 3c 47	 lea	 edi, DWORD PTR [edi+eax*2]

; 5516 : 		}
; 5517 : 		else

  030bf	eb 06		 jmp	 SHORT $L72675
$L72677:

; 5518 : 		{
; 5519 : 			temp+=num_desc;

  030c1	03 f8		 add	 edi, eax

; 5520 : 		}
; 5521 : 		rule_p=temp;

  030c3	eb 02		 jmp	 SHORT $L72675
$L73222:
  030c5	33 f6		 xor	 esi, esi
$L72675:

; 5522 : 	}
; 5523 : 	
; 5524 : 	/* if satisfied_min_cond was not changed, there was no successful matching */
; 5525 :    	if (satisfied_min_cond== -1)

  030c7	83 7c 24 30 ff	 cmp	 DWORD PTR _satisfied_min_cond$[esp+64], -1
  030cc	75 0a		 jne	 SHORT $L72679
  030ce	5f		 pop	 edi
  030cf	5e		 pop	 esi
  030d0	5d		 pop	 ebp

; 5526 :    	{
; 5527 : 		return(0);

  030d1	33 c0		 xor	 eax, eax
  030d3	5b		 pop	 ebx

; 5557 : }

  030d4	83 c4 30	 add	 esp, 48			; 00000030H
  030d7	c3		 ret	 0
$L72679:

; 5528 : 	}
; 5529 : 	else
; 5530 :    	{   
; 5531 : 	/* if there was a successful match that was not the last one set range_value->start to 
; 5532 :    		   the value of start at the when the match was hit */
; 5533 : 		if (range_value->start!=satisfied_start)

  030d8	8b 44 24 34	 mov	 eax, DWORD PTR _satisfied_start$[esp+64]
  030dc	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  030de	3b c8		 cmp	 ecx, eax
  030e0	74 02		 je	 SHORT $L72681

; 5534 : 		{
; 5535 : 			range_value->start=satisfied_start;

  030e2	89 03		 mov	 DWORD PTR [ebx], eax
$L72681:

; 5536 : 		}
; 5537 : 	}
; 5538 : 	if (input_array[ipos+i]=='\0')

  030e4	8b 44 24 24	 mov	 eax, DWORD PTR _ipos$[esp+64]
  030e8	8b 4c 24 14	 mov	 ecx, DWORD PTR _i$[esp+64]
  030ec	8b 54 24 48	 mov	 edx, DWORD PTR _input_array$[esp+60]
  030f0	03 c1		 add	 eax, ecx
  030f2	80 3c 10 00	 cmp	 BYTE PTR [eax+edx], 0
  030f6	75 11		 jne	 SHORT $L72683

; 5539 : 	{
; 5540 : 		if (length==0)

  030f8	39 74 24 28	 cmp	 DWORD PTR _length$[esp+64], esi
  030fc	75 0b		 jne	 SHORT $L72683
  030fe	5f		 pop	 edi
  030ff	5e		 pop	 esi
  03100	5d		 pop	 ebp

; 5541 : 		{	/* changed for speed */
; 5542 : 			return(-1);

  03101	83 c8 ff	 or	 eax, -1
  03104	5b		 pop	 ebx

; 5557 : }

  03105	83 c4 30	 add	 esp, 48			; 00000030H
  03108	c3		 ret	 0
$L72683:

; 5543 : 		}
; 5544 : 	}                                        
; 5545 : 	ret_value->rule=rule_p; 

  03109	8b 44 24 50	 mov	 eax, DWORD PTR _ret_value$[esp+60]
  0310d	89 78 10	 mov	 DWORD PTR [eax+16], edi

; 5546 : #ifdef DIGIT_DEBUG    
; 5547 : 	par_print_rule_error("par_match_digits;testing the rule_p index",current_rule,rule_p);
; 5548 : #endif
; 5549 : #ifdef DEBUG
; 5550 : 	printf("leaving par_match_digits length=%d\n",length);
; 5551 : #else
; 5552 : #ifdef DIGIT_DEBUG
; 5553 : 	printf("leaving par_match_digits length=%d ret_value->value=%d\n",length,ret_value->value);
; 5554 : #endif
; 5555 : #endif
; 5556 :    	return(length);

  03110	8b 44 24 28	 mov	 eax, DWORD PTR _length$[esp+64]
  03114	5f		 pop	 edi
  03115	5e		 pop	 esi
  03116	5d		 pop	 ebp
  03117	5b		 pop	 ebx

; 5557 : }

  03118	83 c4 30	 add	 esp, 48			; 00000030H
  0311b	c3		 ret	 0
_par_match_digits ENDP
_TEXT	ENDS
PUBLIC	_par_match_set
_TEXT	SEGMENT
_match_is_over$ = -72
_satisfied_min_cond$ = -68
_counter$ = 8
_sect_p$ = -56
_section_p$ = -44
_end_of_all_types$ = -36
_num_desc$ = -40
_large_desc$ = -60
_new_ret$ = -32
_current_rule$ = 8
_input_array$ = 12
_match_array$ = 16
_ret_value$ = 20
_range_value$ = 24
_lookahead$ = 28
_break_on_min_match$ = 32
_times$ = -52
_ipos$ = -64
_total_length$ = -76
_par_match_sets_with_ranges PROC NEAR

; 5594 : {

  03120	83 ec 4c	 sub	 esp, 76			; 0000004cH

; 5595 : 	int rule_p;
; 5596 : 	int times=0,length=0,ipos,total_length=0;
; 5597 : 	int min_range= -1,max_range= -1;
; 5598 : 	int match_is_over=0;                              
; 5599 : 	int satisfied_min_cond= -1;
; 5600 : 	//	int par_look_ahead_success=0;
; 5601 : 	int i=0;
; 5602 : 	int temp;
; 5603 : 	int counter;
; 5604 : 	int sect_p,section_p;
; 5605 : 	int end_of_all_types,num_desc;
; 5606 : 	int large_desc;
; 5607 : 	//	int num_sections;
; 5608 : 	/* int find_type= -2; */ /* uncomment when look_ahead is implimented from sets */
; 5609 : #ifndef NEW_PARSER_FILE_LOADING
; 5610 : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0 }; 
; 5611 : #else
; 5612 : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0,NULL }; 
; 5613 : #endif
; 5614 : 	
; 5615 : #ifdef DEBUG
; 5616 : 	printf("entering par_match_sets_and_ranges\n");
; 5617 : #endif
; 5618 : #ifdef SANITY_CHECKING	
; 5619 : 	if (ret_value==NULL)
; 5620 : 	{
; 5621 : #ifdef DEBUG
; 5622 : 		printf("leaving par_match_sets_and_ranges a 0\n");
; 5623 : #endif
; 5624 : 		return(0);
; 5625 : 	}
; 5626 : 	if ((current_rule==NULL) || (input_array==NULL))
; 5627 : 	{
; 5628 : 		ret_value->value=FATAL_FAIL;
; 5629 : #ifdef DEBUG
; 5630 : 		printf("leaving par_match_sets_and_ranges b 0\n");
; 5631 : #endif
; 5632 : 		return(0);
; 5633 : 	}
; 5634 : #endif
; 5635 : 	rule_p=ret_value->rule;
; 5636 : 	ipos=ret_value->input_pos+ret_value->input_offset;

  03123	8b 54 24 5c	 mov	 edx, DWORD PTR _ret_value$[esp+72]
  03127	53		 push	 ebx
  03128	55		 push	 ebp
  03129	56		 push	 esi
  0312a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0312d	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 5637 : 	
; 5638 : 	/* skip past the type delimiter */
; 5639 : 	
; 5640 : 	rule_p++;
; 5641 : 	
; 5642 : 	new_ret.input_pos=ret_value->input_pos+ret_value->input_offset;	
; 5643 : 	new_ret.input_offset=0;
; 5644 : 	new_ret.output_pos=ret_value->output_pos+ret_value->output_offset;

  0312f	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  03132	03 c8		 add	 ecx, eax
  03134	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  03137	89 4c 24 18	 mov	 DWORD PTR _ipos$[esp+88], ecx
  0313b	89 4c 24 38	 mov	 DWORD PTR _new_ret$[esp+88], ecx
  0313f	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  03142	03 ce		 add	 ecx, esi
  03144	57		 push	 edi

; 5645 : 	new_ret.output_offset=0;
; 5646 : 	new_ret.value=SUCCESS;
; 5647 : #ifdef NEW_PARSER_FILE_LOADING
; 5648 : 	new_ret.phTTS=ret_value->phTTS;
; 5649 : #endif
; 5650 : 	
; 5651 : 	section_p=rule_p; /* the location of the number of sections */
; 5652 : 	
; 5653 : 	//	num_sections=current_rule[rule_p];	
; 5654 : 	
; 5655 : 	
; 5656 : 	end_of_all_types=current_rule[section_p+current_rule[rule_p]]+1;

  03145	8b 7c 24 60	 mov	 edi, DWORD PTR _current_rule$[esp+88]
  03149	33 ed		 xor	 ebp, ebp
  0314b	89 4c 24 44	 mov	 DWORD PTR _new_ret$[esp+100], ecx
  0314f	40		 inc	 eax
  03150	b9 01 00 00 00	 mov	 ecx, 1
  03155	33 db		 xor	 ebx, ebx
  03157	89 6c 24 4c	 mov	 DWORD PTR _new_ret$[esp+108], ebp
  0315b	89 6c 24 54	 mov	 DWORD PTR _new_ret$[esp+116], ebp
  0315f	89 6c 24 58	 mov	 DWORD PTR _new_ret$[esp+120], ebp
  03163	89 6c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ebp
  03167	89 6c 24 48	 mov	 DWORD PTR _new_ret$[esp+104], ebp
  0316b	89 4c 24 50	 mov	 DWORD PTR _new_ret$[esp+112], ecx
  0316f	8a 1c 38	 mov	 bl, BYTE PTR [eax+edi]
  03172	89 44 24 30	 mov	 DWORD PTR _section_p$[esp+92], eax
  03176	03 c3		 add	 eax, ebx
  03178	33 db		 xor	 ebx, ebx
  0317a	89 6c 24 28	 mov	 DWORD PTR _times$[esp+92], ebp
  0317e	89 6c 24 10	 mov	 DWORD PTR _total_length$[esp+92], ebp
  03182	8a 1c 38	 mov	 bl, BYTE PTR [eax+edi]
  03185	89 6c 24 14	 mov	 DWORD PTR _match_is_over$[esp+92], ebp
  03189	8b f3		 mov	 esi, ebx
  0318b	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR _satisfied_min_cond$[esp+92], -1
  03193	46		 inc	 esi
  03194	89 74 24 38	 mov	 DWORD PTR _end_of_all_types$[esp+92], esi

; 5657 : 	
; 5658 : 	rule_p+=(current_rule[rule_p])+1;	/* the location of the descriptors */

  03198	8d 70 01	 lea	 esi, DWORD PTR [eax+1]

; 5659 : 	
; 5660 : 	if (current_rule[rule_p] & BIN_LARGE_DESC)

  0319b	8a 44 38 01	 mov	 al, BYTE PTR [eax+edi+1]
  0319f	a8 40		 test	 al, 64			; 00000040H
  031a1	74 0f		 je	 SHORT $L72717

; 5661 : 	{
; 5662 : 		large_desc=1;
; 5663 : 		sect_p=rule_p+(current_rule[rule_p] <<1)+1;

  031a3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  031a8	89 4c 24 20	 mov	 DWORD PTR _large_desc$[esp+92], ecx
  031ac	8d 4c 46 01	 lea	 ecx, DWORD PTR [esi+eax*2+1]

; 5664 : 	}
; 5665 : 	else

  031b0	eb 0d		 jmp	 SHORT $L73245
$L72717:

; 5666 : 	{
; 5667 : 		large_desc=0;
; 5668 : 		sect_p=rule_p+(current_rule[rule_p])+1; // the for the start of the sections of the sets 

  031b2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  031b7	89 6c 24 20	 mov	 DWORD PTR _large_desc$[esp+92], ebp
  031bb	8d 4c 30 01	 lea	 ecx, DWORD PTR [eax+esi+1]
$L73245:
  031bf	89 4c 24 24	 mov	 DWORD PTR _sect_p$[esp+92], ecx

; 5669 : 	}
; 5670 : 	//	new_ret.rule=section_p;
; 5671 : 	
; 5672 : 	num_desc=(current_rule[rule_p] & BIN_SIZE_DESC_MASK);

  031c3	83 e0 3f	 and	 eax, 63			; 0000003fH

; 5673 : 	counter=0;

  031c6	33 c9		 xor	 ecx, ecx

; 5674 : 	rule_p++; /* move past number of descrpitors */

  031c8	46		 inc	 esi

; 5675 : 	
; 5676 : 	/* either there is a number or there is a star of a plus */
; 5677 : 	while ((counter<num_desc) && (match_is_over==0))

  031c9	3b c5		 cmp	 eax, ebp
  031cb	89 44 24 34	 mov	 DWORD PTR _num_desc$[esp+92], eax
  031cf	0f 8e a3 01 00
	00		 jle	 $L73238
  031d5	eb 02		 jmp	 SHORT $L72720
$L73243:
  031d7	33 ed		 xor	 ebp, ebp
$L72720:
  031d9	39 6c 24 14	 cmp	 DWORD PTR _match_is_over$[esp+92], ebp
  031dd	0f 85 8c 01 00
	00		 jne	 $L73235

; 5678 : 	{
; 5679 : 		if (large_desc)

  031e3	39 6c 24 20	 cmp	 DWORD PTR _large_desc$[esp+92], ebp
  031e7	74 45		 je	 SHORT $L72722

; 5680 : 		{
; 5681 : 			temp=get_short(current_rule+rule_p);

  031e9	33 c0		 xor	 eax, eax
  031eb	8a 64 37 01	 mov	 ah, BYTE PTR [edi+esi+1]
  031ef	8a 04 3e	 mov	 al, BYTE PTR [esi+edi]

; 5682 : 			rule_p+=2;

  031f2	83 c6 02	 add	 esi, 2

; 5683 : 			counter++;
; 5684 : 			min_range = temp & BIN_MAX_LARGE_DESC;

  031f5	8b d8		 mov	 ebx, eax
  031f7	41		 inc	 ecx
  031f8	81 e3 ff 3f 00
	00		 and	 ebx, 16383		; 00003fffH
  031fe	89 4c 24 60	 mov	 DWORD PTR _counter$[esp+88], ecx

; 5685 : 			max_range=min_range;
; 5686 : 			if (temp & BIN_LARGE_ANY_NUMBER)

  03202	f6 c4 80	 test	 ah, -128		; ffffff80H
  03205	8b eb		 mov	 ebp, ebx

; 5687 : 			{
; 5688 : 				max_range=INT_MAX;
; 5689 : 			}
; 5690 : 			else

  03207	75 53		 jne	 SHORT $L73246

; 5691 : 			{
; 5692 : 				if (temp & BIN_LARGE_CONTINUE)

  03209	f6 c4 40	 test	 ah, 64			; 00000040H
  0320c	74 53		 je	 SHORT $L72737

; 5693 : 				{
; 5694 : 					temp=get_short(current_rule+rule_p);

  0320e	33 c0		 xor	 eax, eax
  03210	8a 64 37 01	 mov	 ah, BYTE PTR [edi+esi+1]
  03214	8a 04 3e	 mov	 al, BYTE PTR [esi+edi]

; 5695 : 					rule_p+=2;

  03217	83 c6 02	 add	 esi, 2

; 5696 : 					counter++;
; 5697 : 					max_range = temp & BIN_MAX_LARGE_DESC;

  0321a	8b e8		 mov	 ebp, eax
  0321c	41		 inc	 ecx
  0321d	81 e5 ff 3f 00
	00		 and	 ebp, 16383		; 00003fffH
  03223	89 4c 24 60	 mov	 DWORD PTR _counter$[esp+88], ecx

; 5698 : 					if (temp & BIN_LARGE_ANY_NUMBER)

  03227	f6 c4 80	 test	 ah, -128		; ffffff80H
  0322a	74 35		 je	 SHORT $L72737

; 5699 : 					{
; 5700 : 						max_range=INT_MAX;
; 5701 : 					}
; 5702 : 				}
; 5703 : 			}
; 5704 : 		}
; 5705 : 		else

  0322c	eb 2e		 jmp	 SHORT $L73246
$L72722:

; 5706 : 		{
; 5707 : 			temp=current_rule[rule_p];

  0322e	33 c0		 xor	 eax, eax
  03230	8a 04 3e	 mov	 al, BYTE PTR [esi+edi]

; 5708 : 			rule_p++;

  03233	46		 inc	 esi

; 5709 : 			counter++;
; 5710 : 			min_range = temp & BIN_MAX_SMALL_DESC;

  03234	8b d8		 mov	 ebx, eax
  03236	41		 inc	 ecx
  03237	83 e3 3f	 and	 ebx, 63			; 0000003fH
  0323a	89 4c 24 60	 mov	 DWORD PTR _counter$[esp+88], ecx

; 5711 : 			max_range=min_range;
; 5712 : 			if (temp & BIN_SMALL_ANY_NUMBER)

  0323e	a8 80		 test	 al, -128		; ffffff80H
  03240	8b eb		 mov	 ebp, ebx

; 5713 : 			{
; 5714 : 				max_range=INT_MAX;
; 5715 : 			}
; 5716 : 			else

  03242	75 18		 jne	 SHORT $L73246

; 5717 : 			{
; 5718 : 				if (temp & BIN_SMALL_CONTINUE)

  03244	a8 40		 test	 al, 64			; 00000040H
  03246	74 19		 je	 SHORT $L72737

; 5719 : 				{
; 5720 : 					temp=current_rule[rule_p];

  03248	33 c0		 xor	 eax, eax
  0324a	8a 04 3e	 mov	 al, BYTE PTR [esi+edi]

; 5721 : 					rule_p++;

  0324d	46		 inc	 esi

; 5722 : 					counter++;
; 5723 : 					max_range = temp & BIN_MAX_SMALL_DESC;

  0324e	8b e8		 mov	 ebp, eax
  03250	41		 inc	 ecx
  03251	83 e5 3f	 and	 ebp, 63			; 0000003fH
  03254	89 4c 24 60	 mov	 DWORD PTR _counter$[esp+88], ecx

; 5724 : 					if (temp & BIN_SMALL_ANY_NUMBER)

  03258	a8 80		 test	 al, -128		; ffffff80H
  0325a	74 05		 je	 SHORT $L72737
$L73246:

; 5725 : 					{
; 5726 : 						max_range=INT_MAX;

  0325c	bd ff ff ff 7f	 mov	 ebp, 2147483647		; 7fffffffH
$L72737:

; 5727 : 					}
; 5728 : 				}
; 5729 : 			}
; 5730 : 		}
; 5731 : 		
; 5732 : 		
; 5733 : 		/* do the character matching starting at length until min_length */
; 5734 : 		/* then match from min_length to max_length */
; 5735 : 		/* once min_length is reached, do lookahead for the next char type if necessary */
; 5736 : 		if (min_range==0)

  03261	85 db		 test	 ebx, ebx
  03263	75 15		 jne	 SHORT $L72739

; 5737 : 		{
; 5738 : 			/* signal that there could be success on a zero length string */
; 5739 : 			/* or the end of string could be successful too */
; 5740 : 			satisfied_min_cond= -2;
; 5741 : 			if (break_on_min_match==1)

  03265	8b 44 24 78	 mov	 eax, DWORD PTR _break_on_min_match$[esp+88]
  03269	c7 44 24 18 fe
	ff ff ff	 mov	 DWORD PTR _satisfied_min_cond$[esp+92], -2 ; fffffffeH
  03271	83 f8 01	 cmp	 eax, 1
  03274	0f 84 19 01 00
	00		 je	 $L73244
$L72739:

; 5742 : 			{
; 5743 : 				break;
; 5744 : 			}
; 5745 : 		}
; 5746 : 		for (i=times;i<max_range;i++)

  0327a	8b 44 24 28	 mov	 eax, DWORD PTR _times$[esp+92]
  0327e	3b c5		 cmp	 eax, ebp
  03280	0f 8d d3 00 00
	00		 jge	 $L72742
  03286	40		 inc	 eax
  03287	89 44 24 2c	 mov	 DWORD PTR -48+[esp+92], eax
$L72740:

; 5747 : 		{
; 5748 : 			/* place the call to par_match_set here */
; 5749 : 			/* return the length of the thing matched */
; 5750 : 			length=par_match_set(current_rule,input_array,section_p,sect_p,ipos,match_array,range_value,&new_ret,lookahead);

  0328b	8b 54 24 74	 mov	 edx, DWORD PTR _lookahead$[esp+88]
  0328f	8b 4c 24 70	 mov	 ecx, DWORD PTR _range_value$[esp+88]
  03293	8d 44 24 3c	 lea	 eax, DWORD PTR _new_ret$[esp+92]
  03297	52		 push	 edx
  03298	8b 54 24 6c	 mov	 edx, DWORD PTR _match_array$[esp+92]
  0329c	50		 push	 eax
  0329d	8b 44 24 24	 mov	 eax, DWORD PTR _ipos$[esp+100]
  032a1	51		 push	 ecx
  032a2	8b 4c 24 30	 mov	 ecx, DWORD PTR _sect_p$[esp+104]
  032a6	52		 push	 edx
  032a7	8b 54 24 40	 mov	 edx, DWORD PTR _section_p$[esp+108]
  032ab	50		 push	 eax
  032ac	8b 44 24 78	 mov	 eax, DWORD PTR _input_array$[esp+108]
  032b0	51		 push	 ecx
  032b1	52		 push	 edx
  032b2	50		 push	 eax
  032b3	57		 push	 edi
  032b4	e8 00 00 00 00	 call	 _par_match_set
  032b9	83 c4 24	 add	 esp, 36			; 00000024H

; 5751 : 			if (length== -1)

  032bc	83 f8 ff	 cmp	 eax, -1
  032bf	74 72		 je	 SHORT $L73230

; 5763 : 			}
; 5764 : 			if (length==0 && new_ret.value==SUCCESS)

  032c1	8b 4c 24 50	 mov	 ecx, DWORD PTR _new_ret$[esp+112]
  032c5	85 c0		 test	 eax, eax
  032c7	75 13		 jne	 SHORT $L72747
  032c9	ba 01 00 00 00	 mov	 edx, 1
  032ce	3b ca		 cmp	 ecx, edx
  032d0	75 22		 jne	 SHORT $L72748

; 5765 : 			{
; 5766 : 				if (total_length==0)

  032d2	8b 4c 24 10	 mov	 ecx, DWORD PTR _total_length$[esp+92]
  032d6	85 c9		 test	 ecx, ecx
  032d8	74 73		 je	 SHORT $L73231

; 5772 : 					match_is_over=1;
; 5773 : 					break;
; 5774 : 				}
; 5775 : 			}
; 5776 : 			if (length>0)

  032da	eb 25		 jmp	 SHORT $L73237
$L72747:
  032dc	85 c0		 test	 eax, eax
  032de	7e 14		 jle	 SHORT $L72748

; 5777 : 			{
; 5778 : 				ipos+=length;

  032e0	8b 54 24 1c	 mov	 edx, DWORD PTR _ipos$[esp+92]
  032e4	03 d0		 add	 edx, eax
  032e6	89 54 24 1c	 mov	 DWORD PTR _ipos$[esp+92], edx

; 5779 : 				total_length+=length;

  032ea	8b 54 24 10	 mov	 edx, DWORD PTR _total_length$[esp+92]
  032ee	03 d0		 add	 edx, eax
  032f0	89 54 24 10	 mov	 DWORD PTR _total_length$[esp+92], edx
$L72748:

; 5780 : 			}
; 5781 : 			if (new_ret.value==FAIL)

  032f4	85 c9		 test	 ecx, ecx
  032f6	0f 84 86 00 00
	00		 je	 $L73232
  032fc	ba 01 00 00 00	 mov	 edx, 1
$L73237:

; 5785 : 			}
; 5786 : 			if ((i+1)>=min_range)

  03301	8b 4c 24 2c	 mov	 ecx, DWORD PTR -48+[esp+92]
  03305	3b cb		 cmp	 ecx, ebx
  03307	7c 16		 jl	 SHORT $L72750

; 5787 : 			{
; 5788 : 				satisfied_min_cond=total_length;

  03309	8b 44 24 10	 mov	 eax, DWORD PTR _total_length$[esp+92]

; 5789 : 				times=i+1;

  0330d	89 4c 24 28	 mov	 DWORD PTR _times$[esp+92], ecx
  03311	89 44 24 18	 mov	 DWORD PTR _satisfied_min_cond$[esp+92], eax

; 5790 : 				/* par_look_ahead cannot be done from here */
; 5791 : 				if (break_on_min_match==1)

  03315	8b 44 24 78	 mov	 eax, DWORD PTR _break_on_min_match$[esp+88]
  03319	3b c2		 cmp	 eax, edx
  0331b	74 38		 je	 SHORT $L73233

; 5792 : 				{
; 5793 : 					match_is_over=1;
; 5794 : 					break;
; 5795 : 				}						    
; 5796 : 				
; 5797 : 			}
; 5798 : 			else

  0331d	eb 04		 jmp	 SHORT $L72741
$L72750:

; 5799 : 			{
; 5800 : 				if (length==0)

  0331f	85 c0		 test	 eax, eax
  03321	74 32		 je	 SHORT $L73233
$L72741:

; 5742 : 			{
; 5743 : 				break;
; 5744 : 			}
; 5745 : 		}
; 5746 : 		for (i=times;i<max_range;i++)

  03323	41		 inc	 ecx
  03324	89 4c 24 2c	 mov	 DWORD PTR -48+[esp+92], ecx
  03328	49		 dec	 ecx
  03329	3b cd		 cmp	 ecx, ebp
  0332b	0f 8c 5a ff ff
	ff		 jl	 $L72740

; 5737 : 		{
; 5738 : 			/* signal that there could be success on a zero length string */
; 5739 : 			/* or the end of string could be successful too */
; 5740 : 			satisfied_min_cond= -2;
; 5741 : 			if (break_on_min_match==1)

  03331	eb 26		 jmp	 SHORT $L72742
$L73230:

; 5752 : 			{
; 5753 : 				match_is_over=1;     
; 5754 : 				if (satisfied_min_cond>0)

  03333	8b 44 24 18	 mov	 eax, DWORD PTR _satisfied_min_cond$[esp+92]
  03337	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _match_is_over$[esp+92], 1
  0333f	85 c0		 test	 eax, eax
  03341	7f 16		 jg	 SHORT $L72742

; 5755 : 				{
; 5756 : 					length=total_length;
; 5757 : 				}
; 5758 : 				else
; 5759 : 				{
; 5760 : 					total_length= -1;

  03343	c7 44 24 10 ff
	ff ff ff	 mov	 DWORD PTR _total_length$[esp+92], -1

; 5761 : 				}
; 5762 : 				break;

  0334b	eb 0c		 jmp	 SHORT $L72742
$L73231:

; 5767 : 				{
; 5768 : #ifdef DEBUG
; 5769 : 					printf("set satisfied_min_cond to -2\n");
; 5770 : #endif
; 5771 : 					satisfied_min_cond= -2;

  0334d	c7 44 24 18 fe
	ff ff ff	 mov	 DWORD PTR _satisfied_min_cond$[esp+92], -2 ; fffffffeH
$L73233:

; 5801 : 				{
; 5802 : 					match_is_over=1;

  03355	89 54 24 14	 mov	 DWORD PTR _match_is_over$[esp+92], edx
$L72742:

; 5675 : 	
; 5676 : 	/* either there is a number or there is a star of a plus */
; 5677 : 	while ((counter<num_desc) && (match_is_over==0))

  03359	8b 4c 24 60	 mov	 ecx, DWORD PTR _counter$[esp+88]
  0335d	8b 44 24 34	 mov	 eax, DWORD PTR _num_desc$[esp+92]
  03361	8b 54 24 6c	 mov	 edx, DWORD PTR _ret_value$[esp+88]
  03365	3b c8		 cmp	 ecx, eax
  03367	0f 8c 6a fe ff
	ff		 jl	 $L73243
  0336d	33 ed		 xor	 ebp, ebp
$L73235:

; 5803 : 					break;
; 5804 : 				}
; 5805 : 			}
; 5806 : 			
; 5807 : 		}
; 5808 : #ifdef DEBUG
; 5809 : 		printf("par_match_sets_and_ranges;rule_p=%d\n",rule_p);
; 5810 : #endif
; 5811 : 	}	/* while loop inner */
; 5812 :     /* look for the next format type specifier */
; 5813 :     /* look up in the table of ambiguity to know whether or not to do the lookahead parsing */
; 5814 :     /* start mathcing the string */
; 5815 : 	/* once the minimum requirement for the type is met, start checking for the next type if required */
; 5816 :     /* end the matching once the lookahead is successful or the current match hits the maximum 
; 5817 : 	number of characters */                
; 5818 : 	
; 5819 : 	
; 5820 : 	rule_p=end_of_all_types;
; 5821 : 	
; 5822 :    	if (satisfied_min_cond== -1)

  0336f	8b 44 24 18	 mov	 eax, DWORD PTR _satisfied_min_cond$[esp+92]
  03373	83 f8 ff	 cmp	 eax, -1
  03376	75 14		 jne	 SHORT $L72754
$L73238:
  03378	5f		 pop	 edi
  03379	5e		 pop	 esi
  0337a	5d		 pop	 ebp

; 5823 :    	{                                               
; 5824 : 		return(0);

  0337b	33 c0		 xor	 eax, eax
  0337d	5b		 pop	 ebx

; 5848 : }

  0337e	83 c4 4c	 add	 esp, 76			; 0000004cH
  03381	c3		 ret	 0
$L73232:

; 5782 : 			{
; 5783 : 				match_is_over=1;

  03382	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _match_is_over$[esp+92], 1

; 5784 : 				break;

  0338a	eb cd		 jmp	 SHORT $L72742
$L72754:

; 5825 :    	}
; 5826 :    	if (satisfied_min_cond== -2)

  0338c	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  0338f	75 25		 jne	 SHORT $L72755
  03391	eb 02		 jmp	 SHORT $L73239
$L73244:
  03393	33 ed		 xor	 ebp, ebp
$L73239:

; 5827 :    	{
; 5828 : 		if (total_length==0)

  03395	39 6c 24 10	 cmp	 DWORD PTR _total_length$[esp+92], ebp
  03399	75 08		 jne	 SHORT $L72759

; 5829 : 		{
; 5830 : 			total_length= -2;

  0339b	c7 44 24 10 fe
	ff ff ff	 mov	 DWORD PTR _total_length$[esp+92], -2 ; fffffffeH
$L72759:

; 5840 : 			}
; 5841 : 		}                                        
; 5842 : 	}
; 5843 : 	ret_value->rule=rule_p;

  033a3	8b 4c 24 38	 mov	 ecx, DWORD PTR _end_of_all_types$[esp+92]

; 5844 : #ifdef DEBUG
; 5845 : 	printf("leaving par_match_sets_and_ranges length=%d total_length=%d ret_value->value=%d\n",length,total_length,ret_value->value);
; 5846 : #endif
; 5847 :    	return(total_length);

  033a7	8b 44 24 10	 mov	 eax, DWORD PTR _total_length$[esp+92]
  033ab	5f		 pop	 edi
  033ac	5e		 pop	 esi
  033ad	5d		 pop	 ebp
  033ae	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  033b1	5b		 pop	 ebx

; 5848 : }

  033b2	83 c4 4c	 add	 esp, 76			; 0000004cH
  033b5	c3		 ret	 0
$L72755:

; 5831 : 		}
; 5832 :    	}
; 5833 :    	else
; 5834 : 	{
; 5835 : 		if (input_array[ipos]=='\0')

  033b6	8b 4c 24 64	 mov	 ecx, DWORD PTR _input_array$[esp+88]
  033ba	8b 44 24 1c	 mov	 eax, DWORD PTR _ipos$[esp+92]
  033be	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  033c2	75 df		 jne	 SHORT $L72759

; 5836 : 		{
; 5837 : 			if (total_length==0)

  033c4	39 6c 24 10	 cmp	 DWORD PTR _total_length$[esp+92], ebp
  033c8	75 d9		 jne	 SHORT $L72759
  033ca	5f		 pop	 edi
  033cb	5e		 pop	 esi
  033cc	5d		 pop	 ebp

; 5838 : 			{	/* changed fo speed */
; 5839 : 				return(-1);

  033cd	83 c8 ff	 or	 eax, -1
  033d0	5b		 pop	 ebx

; 5848 : }

  033d1	83 c4 4c	 add	 esp, 76			; 0000004cH
  033d4	c3		 ret	 0
_par_match_sets_with_ranges ENDP
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+1
$SG72800 DB	'par_match_set; no charcter type found', 00H
_DATA	ENDS
_TEXT	SEGMENT
_current_rule$ = 8
_input_array$ = 12
_rule_p$ = 16
_sect_p$ = 20
_ipos$ = 24
_match_array$ = 28
_range_value$ = 32
_ret_value$ = 36
_lookahead$ = 40
_new_ret$ = -64
_save_ret$ = -32
_length$ = -72
_a_success$ = -68
_num_match$ = -76
_num_sections$ = 24
_end_of_all_sections$ = 8
_par_match_set PROC NEAR

; 5888 : {

  033e0	83 ec 4c	 sub	 esp, 76			; 0000004cH

; 5891 : 	return_value_t		save_ret = { 0,0,0,0,0,0,0,0 };	/* a copy to restore new_ret */
; 5892 : #else
; 5893 : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0,NULL }; 	/* for par_match_string to use */
; 5894 : 	return_value_t		save_ret = { 0,0,0,0,0,0,0,0,NULL };	/* a copy to restore new_ret */
; 5895 : #endif
; 5896 : 	int length=0;
; 5897 : 	int a_success=FAIL;
; 5898 : 	int this_success=0;
; 5899 : 	int num_chars_matched=0;
; 5900 : 	int num_match=0;
; 5901 : 	int new_char_type;
; 5902 : 	int num_sections;
; 5903 : 	int end_of_all_sections;
; 5904 : 	
; 5905 : #ifdef DEBUG
; 5906 : 	printf("entering par_match_set\n");
; 5907 : #endif
; 5908 : #ifdef SANITY_CHECKING
; 5909 : 	if (ret_value==NULL)
; 5910 : 	{
; 5911 : #ifdef DEBUG
; 5912 : 		printf("leaving par_match_set ret_value is NULL\n");
; 5913 : #endif
; 5914 : 		return(0);
; 5915 : 	}
; 5916 : 	if ((current_rule==NULL) || (input_array==NULL) || 
; 5917 : 		(match_array==NULL) || (range_value==NULL))
; 5918 : 	{
; 5919 : 		ret_value->value=FATAL_FAIL;
; 5920 : #ifdef DEBUG
; 5921 : 		printf("leaving par_match_set, inputs are bad\n");
; 5922 : #endif
; 5923 : 		return(0);
; 5924 : 	}
; 5925 : #endif
; 5926 : 	new_ret.rule=sect_p;
; 5927 : 	new_ret.input_pos=ipos;

  033e3	8b 4c 24 60	 mov	 ecx, DWORD PTR _ipos$[esp+72]

; 5928 : 	new_ret.optional=ret_value->optional;

  033e7	8b 54 24 6c	 mov	 edx, DWORD PTR _ret_value$[esp+72]
  033eb	53		 push	 ebx
  033ec	55		 push	 ebp
  033ed	8b 6c 24 64	 mov	 ebp, DWORD PTR _sect_p$[esp+80]
  033f1	33 c0		 xor	 eax, eax
  033f3	89 4c 24 14	 mov	 DWORD PTR _new_ret$[esp+84], ecx
  033f7	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]

; 5929 : 	new_ret.value=SUCCESS;
; 5930 : 	
; 5931 : 	par_copy_return_value(&save_ret,&new_ret);
; 5932 : 	
; 5933 : 	num_sections=current_rule[rule_p];

  033fa	8b 5c 24 58	 mov	 ebx, DWORD PTR _current_rule$[esp+80]
  033fe	56		 push	 esi
  033ff	89 44 24 1c	 mov	 DWORD PTR _new_ret$[esp+92], eax
  03403	89 44 24 20	 mov	 DWORD PTR _new_ret$[esp+96], eax
  03407	89 44 24 24	 mov	 DWORD PTR _new_ret$[esp+100], eax
  0340b	89 44 24 34	 mov	 DWORD PTR _new_ret$[esp+116], eax
  0340f	89 44 24 10	 mov	 DWORD PTR _length$[esp+88], eax
  03413	89 44 24 14	 mov	 DWORD PTR _a_success$[esp+88], eax
  03417	89 44 24 0c	 mov	 DWORD PTR _num_match$[esp+88], eax
  0341b	57		 push	 edi
  0341c	8b c5		 mov	 eax, ebp
  0341e	89 4c 24 34	 mov	 DWORD PTR _new_ret$[esp+116], ecx
  03422	b9 08 00 00 00	 mov	 ecx, 8
  03427	8d 74 24 1c	 lea	 esi, DWORD PTR _new_ret$[esp+92]
  0342b	8d 7c 24 3c	 lea	 edi, DWORD PTR _save_ret$[esp+92]
  0342f	89 44 24 2c	 mov	 DWORD PTR _new_ret$[esp+108], eax
  03433	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR _new_ret$[esp+112], 1

; 5934 : 	end_of_all_sections=current_rule[rule_p+num_sections];

  0343b	33 d2		 xor	 edx, edx
  0343d	f3 a5		 rep movsd
  0343f	8b 7c 24 68	 mov	 edi, DWORD PTR _rule_p$[esp+88]
  03443	33 c9		 xor	 ecx, ecx
  03445	8a 0c 3b	 mov	 cl, BYTE PTR [ebx+edi]
  03448	8d 34 3b	 lea	 esi, DWORD PTR [ebx+edi]
  0344b	89 4c 24 70	 mov	 DWORD PTR _num_sections$[esp+88], ecx
  0344f	03 cb		 add	 ecx, ebx
  03451	8a 14 39	 mov	 dl, BYTE PTR [ecx+edi]
  03454	8b ca		 mov	 ecx, edx

; 5935 : 	
; 5936 : 	while ((new_ret.rule<=end_of_all_sections) && (a_success==FAIL))

  03456	3b e9		 cmp	 ebp, ecx
  03458	89 4c 24 60	 mov	 DWORD PTR _end_of_all_sections$[esp+88], ecx
  0345c	0f 8f 00 01 00
	00		 jg	 $L73251

; 5889 : #ifndef NEW_PARSER_FILE_LOADING
; 5890 : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0 }; 	/* for par_match_string to use */

  03462	8b 6c 24 78	 mov	 ebp, DWORD PTR _range_value$[esp+88]
$L72791:

; 5935 : 	
; 5936 : 	while ((new_ret.rule<=end_of_all_sections) && (a_success==FAIL))

  03466	8b 4c 24 18	 mov	 ecx, DWORD PTR _a_success$[esp+92]
  0346a	85 c9		 test	 ecx, ecx
  0346c	0f 85 fb 00 00
	00		 jne	 $L72810

; 5937 : 	{
; 5938 : 		this_success=SUCCESS;     
; 5939 : 		length=0;
; 5940 : 		rule_p++; /* go to the next section */

  03472	46		 inc	 esi

; 5941 : 		while ((new_ret.rule<=current_rule[rule_p]) && (a_success==FAIL))

  03473	33 c9		 xor	 ecx, ecx
  03475	bf 01 00 00 00	 mov	 edi, 1
  0347a	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _length$[esp+92], 0
  03482	8a 0e		 mov	 cl, BYTE PTR [esi]
  03484	89 74 24 6c	 mov	 DWORD PTR 20+[esp+88], esi
  03488	3b c1		 cmp	 eax, ecx
  0348a	7f 6d		 jg	 SHORT $L73252
$L72794:

; 5942 : 		{
; 5943 : 			if (new_char_type=(current_rule[new_ret.rule] & BIN_OPERATION_MASK))

  0348c	8a 0c 18	 mov	 cl, BYTE PTR [eax+ebx]
  0348f	83 e1 1f	 and	 ecx, 31			; 0000001fH
  03492	0f 84 ec 00 00
	00		 je	 $L72796

; 5944 : 			{
; 5945 : 				num_chars_matched=par_match_string(current_rule,new_char_type,input_array,match_array,&new_ret,range_value,0,0);

  03498	8b 44 24 74	 mov	 eax, DWORD PTR _match_array$[esp+88]
  0349c	6a 00		 push	 0
  0349e	6a 00		 push	 0
  034a0	8d 54 24 24	 lea	 edx, DWORD PTR _new_ret$[esp+100]
  034a4	55		 push	 ebp
  034a5	52		 push	 edx
  034a6	8b 54 24 74	 mov	 edx, DWORD PTR _input_array$[esp+104]
  034aa	50		 push	 eax
  034ab	52		 push	 edx
  034ac	51		 push	 ecx
  034ad	53		 push	 ebx
  034ae	e8 00 00 00 00	 call	 _par_match_string

; 5946 : 				length+=num_chars_matched;

  034b3	8b 4c 24 34	 mov	 ecx, DWORD PTR _length$[esp+124]

; 5947 : 				new_ret.input_pos+=num_chars_matched;

  034b7	8b 54 24 3c	 mov	 edx, DWORD PTR _new_ret$[esp+124]
  034bb	83 c4 20	 add	 esp, 32			; 00000020H
  034be	03 c8		 add	 ecx, eax
  034c0	03 d0		 add	 edx, eax

; 5948 : 				if (num_chars_matched== -1)

  034c2	83 f8 ff	 cmp	 eax, -1
  034c5	89 4c 24 14	 mov	 DWORD PTR _length$[esp+92], ecx
  034c9	89 54 24 1c	 mov	 DWORD PTR _new_ret$[esp+92], edx
  034cd	0f 84 a6 00 00
	00		 je	 $L73250

; 5964 : 			}
; 5965 : 			if (new_ret.value==FAIL)

  034d3	8b 44 24 30	 mov	 eax, DWORD PTR _new_ret$[esp+112]
  034d7	85 c0		 test	 eax, eax
  034d9	75 0d		 jne	 SHORT $L73254

; 5966 : 			{
; 5967 : #ifdef DEBUG
; 5968 : 				printf("par_match_set;this section has failed, look for the next section\n");
; 5969 : #endif
; 5970 : 				this_success=FAIL;
; 5971 : 				new_ret.rule=current_rule[rule_p]+1;

  034db	33 c0		 xor	 eax, eax
  034dd	33 ff		 xor	 edi, edi
  034df	8a 06		 mov	 al, BYTE PTR [esi]
  034e1	40		 inc	 eax
  034e2	89 44 24 2c	 mov	 DWORD PTR _new_ret$[esp+108], eax
  034e6	eb 04		 jmp	 SHORT $L72801
$L73254:
  034e8	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+108]
$L72801:

; 5941 : 		while ((new_ret.rule<=current_rule[rule_p]) && (a_success==FAIL))

  034ec	33 c9		 xor	 ecx, ecx
  034ee	8a 0e		 mov	 cl, BYTE PTR [esi]
  034f0	3b c1		 cmp	 eax, ecx
  034f2	7e 98		 jle	 SHORT $L72794

; 5972 : 			} 
; 5973 : 			else
; 5974 : 			{
; 5975 : #ifdef DEBUG
; 5976 : 				printf("this type has succeeded, matching next type\n");
; 5977 : #endif
; 5978 : 			}
; 5979 : 		}    
; 5980 : #ifdef DEBUG
; 5981 : 		par_print_rule_error("par_match_set;after a comma or brace has been found",current_rule,new_ret.rule);
; 5982 : #endif
; 5983 : 		if (this_success==SUCCESS)

  034f4	83 ff 01	 cmp	 edi, 1
  034f7	75 28		 jne	 SHORT $L72803
$L73252:

; 5984 : 		{
; 5985 : 			a_success=SUCCESS;
; 5986 : #ifdef DEBUG
; 5987 : 			printf("par_match_set;this section has succeeded\n");
; 5988 : #endif
; 5989 : 			if (range_value->range_set==0)

  034f9	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  034fc	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _a_success$[esp+92], 1
  03504	85 c9		 test	 ecx, ecx
  03506	75 10		 jne	 SHORT $L72804

; 5990 : 			{
; 5991 : 				range_value->range_set=2;
; 5992 : 				range_value->start=num_match;

  03508	8b 54 24 10	 mov	 edx, DWORD PTR _num_match$[esp+92]
  0350c	c7 45 0c 02 00
	00 00		 mov	 DWORD PTR [ebp+12], 2
  03513	89 55 00	 mov	 DWORD PTR [ebp], edx

; 5993 : 			}
; 5994 : 			else

  03516	eb 38		 jmp	 SHORT $L72808
$L72804:

; 5995 : 			{	
; 5996 : 				range_value->range_set= -1;

  03518	c7 45 0c ff ff
	ff ff		 mov	 DWORD PTR [ebp+12], -1

; 5997 : 			}
; 5998 : 		}            
; 5999 : 		else

  0351f	eb 2f		 jmp	 SHORT $L72808
$L72803:

; 6000 : 		{
; 6001 : 			if (num_match==num_sections)

  03521	8b 4c 24 70	 mov	 ecx, DWORD PTR _num_sections$[esp+88]
  03525	8b 54 24 10	 mov	 edx, DWORD PTR _num_match$[esp+92]
  03529	3b d1		 cmp	 edx, ecx
  0352b	74 23		 je	 SHORT $L72808

; 6002 : 			{
; 6003 : #ifdef DEBUG
; 6004 : 				printf("par_match_set;all sections failed\n");
; 6005 : #endif
; 6006 : 			}
; 6007 : 			else
; 6008 : 			{
; 6009 : #ifdef DEBUG
; 6010 : 				printf("par_match_set;this section has failed, going to next section\n");
; 6011 : #endif
; 6012 : 				par_copy_return_value(&new_ret,&save_ret);
; 6013 : 				num_match++;

  0352d	42		 inc	 edx

; 6014 : 				new_ret.rule=current_rule[rule_p]+1;

  0352e	33 c0		 xor	 eax, eax
  03530	89 54 24 10	 mov	 DWORD PTR _num_match$[esp+92], edx
  03534	8b 54 24 6c	 mov	 edx, DWORD PTR 20+[esp+88]
  03538	b9 08 00 00 00	 mov	 ecx, 8
  0353d	8d 74 24 3c	 lea	 esi, DWORD PTR _save_ret$[esp+92]
  03541	8a 02		 mov	 al, BYTE PTR [edx]
  03543	8d 7c 24 1c	 lea	 edi, DWORD PTR _new_ret$[esp+92]
  03547	f3 a5		 rep movsd
  03549	40		 inc	 eax
  0354a	8b f2		 mov	 esi, edx
  0354c	89 44 24 2c	 mov	 DWORD PTR _new_ret$[esp+108], eax
$L72808:
  03550	3b 44 24 60	 cmp	 eax, DWORD PTR _end_of_all_sections$[esp+88]
  03554	0f 8e 0c ff ff
	ff		 jle	 $L72791

; 6015 : 			}
; 6016 : 		}
; 6017 : 	}
; 6018 : 	if (a_success==FAIL)

  0355a	8b 44 24 18	 mov	 eax, DWORD PTR _a_success$[esp+92]
  0355e	85 c0		 test	 eax, eax
  03560	75 0b		 jne	 SHORT $L72810
$L73251:

; 6019 : 	{
; 6020 : 		ret_value->value=FAIL;

  03562	8b 4c 24 7c	 mov	 ecx, DWORD PTR _ret_value$[esp+88]
  03566	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
$L72810:

; 6021 : #ifdef DEBUG
; 6022 : 		printf("par_match_set; it failed\n");
; 6023 : #endif
; 6024 : 	}    
; 6025 : #ifdef DEBUG
; 6026 : 	printf("leaving par_match_set length=%d ret_value->value=%d\n",length,ret_value->value);
; 6027 : #endif
; 6028 : 	return(length);

  0356d	8b 44 24 14	 mov	 eax, DWORD PTR _length$[esp+92]
  03571	5f		 pop	 edi
  03572	5e		 pop	 esi
  03573	5d		 pop	 ebp
  03574	5b		 pop	 ebx

; 6029 : }	

  03575	83 c4 4c	 add	 esp, 76			; 0000004cH
  03578	c3		 ret	 0
$L73250:
  03579	5f		 pop	 edi
  0357a	5e		 pop	 esi
  0357b	5d		 pop	 ebp

; 5949 : 				{	/* changed for speed */
; 5950 : 					return(-1);

  0357c	83 c8 ff	 or	 eax, -1
  0357f	5b		 pop	 ebx

; 6029 : }	

  03580	83 c4 4c	 add	 esp, 76			; 0000004cH
  03583	c3		 ret	 0
$L72796:

; 5951 : 				}
; 5952 : #ifdef DEBUG
; 5953 : 				par_print_rule_error("par_match_set;after par_match_string",current_rule,new_ret.rule);
; 5954 : #endif
; 5955 : 			}
; 5956 : 			else
; 5957 : 			{
; 5958 : 				if (lookahead)

  03584	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR _lookahead$[esp+88]
  0358b	85 c9		 test	 ecx, ecx
  0358d	74 0f		 je	 SHORT $L72799

; 5959 : 				{
; 5960 : 					par_print_rule_error("par_match_set; no charcter type found",current_rule,new_ret.rule);

  0358f	50		 push	 eax
  03590	53		 push	 ebx
  03591	68 00 00 00 00	 push	 OFFSET FLAT:$SG72800
  03596	e8 00 00 00 00	 call	 _par_print_rule_error
  0359b	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72799:

; 5961 : 				}
; 5962 : 				ret_value->value=FATAL_FAIL;

  0359e	8b 44 24 7c	 mov	 eax, DWORD PTR _ret_value$[esp+88]
  035a2	5f		 pop	 edi
  035a3	5e		 pop	 esi
  035a4	5d		 pop	 ebp
  035a5	c7 40 14 04 00
	00 00		 mov	 DWORD PTR [eax+20], 4

; 5963 : 				return(0);

  035ac	33 c0		 xor	 eax, eax
  035ae	5b		 pop	 ebx

; 6029 : }	

  035af	83 c4 4c	 add	 esp, 76			; 0000004cH
  035b2	c3		 ret	 0
_par_match_set ENDP
_TEXT	ENDS
END
