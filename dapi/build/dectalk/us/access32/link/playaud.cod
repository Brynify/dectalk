	TITLE	D:\work\Product\dapi\src\NT\playaud.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_Shm_t
PUBLIC	_pShm_t
PUBLIC	_tlPlayAudio
_BSS	SEGMENT
_tlPlayAudio DB	0cH DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_Shm_t	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_pShm_t	DD	FLAT:_Shm_t
_DATA	ENDS
PUBLIC	_PA_CreatePlayHandle
PUBLIC	_PA_CreatePlayHandleEx
EXTRN	_ThreadLock:NEAR
EXTRN	_ThreadUnlock:NEAR
_TEXT	SEGMENT
_ppPlayAudio$ = 8
_uiWaveOutDeviceID$ = 12
_pWaveFormat$ = 16
_dwDeviceOptions$ = 20
_CallbackRoutine$ = 24
_aInstance$ = 28
_PA_CreatePlayHandle PROC NEAR

; 773  : {

  00000	56		 push	 esi

; 774  :   
; 775  :   MMRESULT mmResult=MMSYSERR_ERROR; // the default error
; 776  :   BOOL bGotLock=FALSE;	// whether we got the lock
; 777  :   
; 778  :   // try to gain control of the resources
; 779  :   bGotLock = ThreadLock(&tlPlayAudio,5);

  00001	6a 05		 push	 5
  00003	68 00 00 00 00	 push	 OFFSET FLAT:_tlPlayAudio
  00008	be 01 00 00 00	 mov	 esi, 1
  0000d	e8 00 00 00 00	 call	 _ThreadLock
  00012	83 c4 08	 add	 esp, 8

; 780  :   if (bGotLock)

  00015	85 c0		 test	 eax, eax
  00017	74 32		 je	 SHORT $L72095

; 781  :     {	// do the actual call..
; 782  :       mmResult = PA_CreatePlayHandleEx(ppPlayAudio,
; 783  : 				       uiWaveOutDeviceID,
; 784  : 				       pWaveFormat,
; 785  : 				       dwDeviceOptions,
; 786  : 				       CallbackRoutine,
; 787  : 				       aInstance);

  00019	8b 44 24 1c	 mov	 eax, DWORD PTR _aInstance$[esp]
  0001d	8b 4c 24 18	 mov	 ecx, DWORD PTR _CallbackRoutine$[esp]
  00021	8b 54 24 14	 mov	 edx, DWORD PTR _dwDeviceOptions$[esp]
  00025	50		 push	 eax
  00026	8b 44 24 14	 mov	 eax, DWORD PTR _pWaveFormat$[esp+4]
  0002a	51		 push	 ecx
  0002b	8b 4c 24 14	 mov	 ecx, DWORD PTR _uiWaveOutDeviceID$[esp+8]
  0002f	52		 push	 edx
  00030	8b 54 24 14	 mov	 edx, DWORD PTR _ppPlayAudio$[esp+12]
  00034	50		 push	 eax
  00035	51		 push	 ecx
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 _PA_CreatePlayHandleEx

; 788  :       // unlock the resources
; 789  :       ThreadUnlock(&tlPlayAudio);

  0003c	68 00 00 00 00	 push	 OFFSET FLAT:_tlPlayAudio
  00041	8b f0		 mov	 esi, eax
  00043	e8 00 00 00 00	 call	 _ThreadUnlock
  00048	83 c4 1c	 add	 esp, 28			; 0000001cH
$L72095:

; 790  :     }
; 791  :   // return our result
; 792  :   return (mmResult);

  0004b	8b c6		 mov	 eax, esi
  0004d	5e		 pop	 esi

; 793  : }

  0004e	c3		 ret	 0
_PA_CreatePlayHandle ENDP
_TEXT	ENDS
PUBLIC	_PA_DestroyPlayHandle
PUBLIC	_PA_SetFormat
PUBLIC	_PlayAudioThreadMain
PUBLIC	_TimerThreadMain
EXTRN	__imp__malloc:NEAR
EXTRN	__imp__waveOutGetNumDevs@0:NEAR
EXTRN	_OP_CreateThread:NEAR
EXTRN	_OP_SetThreadPriority:NEAR
EXTRN	_OP_CreateMutex:NEAR
EXTRN	_OP_CreateEvent:NEAR
EXTRN	_mallocLock:NEAR
_TEXT	SEGMENT
_ppPlayAudio$ = 8
_uiWaveOutDeviceID$ = 12
_pWaveFormat$ = 16
_dwDeviceOptions$ = 20
_CallbackRoutine$ = 24
_aInstance$ = 28
_uiNumberOfWaveOutDevices$ = -24
_WaveFormat$ = -20
_PA_CreatePlayHandleEx PROC NEAR

; 805  : {

  00050	83 ec 18	 sub	 esp, 24			; 00000018H

; 806  :   unsigned int uiI;
; 807  :   unsigned int uiNumberOfWaveOutDevices;
; 808  :   MMRESULT mmStatus;
; 809  :   WAVEFORMATEX WaveFormat;
; 810  :   LPPLAY_RING_T pPlayAudioRing;
; 811  :   HPLAY_AUDIO_T pPlayAudio = NULL;
; 812  : 
; 813  : #ifdef OS_SIXTY_FOUR_BIT
; 814  :   unsigned int bHandleSaved;
; 815  :   HPLAY_AUDIO_T * ppGlobalHandleListTemp;
; 816  : #endif
; 817  :   
; 818  : #ifdef AUD_DEBUG
; 819  :   OutputDebugString("PA_CreatePlayHandle()\n");
; 820  : #endif
; 821  :   
; 822  :   /********************************************************************/
; 823  :   /*  Set the return handle to NULL in case this function fails.      */
; 824  :   /********************************************************************/
; 825  : 
; 826  :   *ppPlayAudio = NULL;

  00053	8b 44 24 1c	 mov	 eax, DWORD PTR _ppPlayAudio$[esp+20]
  00057	53		 push	 ebx
  00058	55		 push	 ebp
  00059	56		 push	 esi
  0005a	57		 push	 edi
  0005b	33 ff		 xor	 edi, edi
  0005d	89 38		 mov	 DWORD PTR [eax], edi

; 827  : 
; 828  :   /********************************************************************/
; 829  :   /*  Increment the play audio instance count.                        */
; 830  :   /********************************************************************/
; 831  : 
; 832  :   pShm_t->uiGlobalPlayAudioInstance++;

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  00064	ff 00		 inc	 DWORD PTR [eax]

; 833  : 
; 834  : #ifdef __linux__
; 835  :   OSS_WaveInit();
; 836  : #endif
; 837  : 
; 838  : #ifdef MME_THREAD_SAFE
; 839  : 
; 840  :   /********************************************************************/
; 841  :   /*  If this is the first instance then create a global mutex to     */
; 842  :   /*  protect MME server calls.                                       */
; 843  :   /********************************************************************/
; 844  : 
; 845  :   if ( pShm_t->uiGlobalPlayAudioInstance == 1 )
; 846  :   {
; 847  :     /******************************************************************/
; 848  :     /*  Create the "Multimedia" mutex.                                */
; 849  :     /******************************************************************/
; 850  : 
; 851  :     pShm_t->hmxGlobalMmeServer = OP_CreateMutex();
; 852  : 
; 853  :     if ( pShm_t->hmxGlobalMmeServer == NULL )
; 854  :     {
; 855  :       PA_DestroyPlayHandle( pPlayAudio );
; 856  :       return MMSYSERR_ERROR;
; 857  :     }
; 858  :   }
; 859  : 
; 860  : #endif
; 861  : 
; 862  : 
; 863  : #ifdef OS_SIXTY_FOUR_BIT
; 864  : 
; 865  :   /********************************************************************/
; 866  :   /*  If this is the first instance then create a global mutex to     */
; 867  :   /*  protect the global Handle List.                                 */
; 868  :   /********************************************************************/
; 869  : 
; 870  :   if ( pShm_t->uiGlobalPlayAudioInstance == 1 )
; 871  :   {
; 872  :     /******************************************************************/
; 873  :     /*  Create the global handle mutex.                               */
; 874  :     /******************************************************************/
; 875  : 
; 876  :     pShm_t->hmxGlobalHandleList = OP_CreateMutex();
; 877  : 
; 878  :     if ( pShm_t->hmxGlobalHandleList == NULL )
; 879  :     {
; 880  :       PA_DestroyPlayHandle( pPlayAudio );
; 881  :       return MMSYSERR_ERROR;
; 882  :     }
; 883  :   }
; 884  : 
; 885  : #endif
; 886  : 
; 887  :   /********************************************************************/
; 888  :   /*  Make sure the system has an audio card.                         */
; 889  :   /********************************************************************/
; 890  : 
; 891  :   LOCK_MME_CALL( uiNumberOfWaveOutDevices = waveOutGetNumDevs() )

  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetNumDevs@0

; 892  : 
; 893  :   if ( uiNumberOfWaveOutDevices == 0 )

  0006c	3b c7		 cmp	 eax, edi
  0006e	89 44 24 10	 mov	 DWORD PTR _uiNumberOfWaveOutDevices$[esp+40], eax
  00072	75 16		 jne	 SHORT $L70997

; 894  :   {
; 895  : #ifdef AUD_DEBUG
; 896  : 	OutputDebugString("PA_: No wave output device found.\n");
; 897  : #endif
; 898  :     PA_DestroyPlayHandle( pPlayAudio );

  00074	57		 push	 edi
  00075	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  0007a	83 c4 04	 add	 esp, 4

; 899  :     return MMSYSERR_NODRIVER;

  0007d	b8 06 00 00 00	 mov	 eax, 6
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5d		 pop	 ebp
  00085	5b		 pop	 ebx

; 1581 : }

  00086	83 c4 18	 add	 esp, 24			; 00000018H
  00089	c3		 ret	 0
$L70997:

; 900  :   }
; 901  :   else
; 902  :   {
; 903  : #ifdef AUD_DEBUG
; 904  : 	  OutputDebugString("PA_: Wave device found.\n");
; 905  : #endif
; 906  :   }
; 907  : 
; 908  :   /********************************************************************/
; 909  :   /*  Make sure the device ID is valid. This is tested as an integer  */
; 910  :   /*  so that a device ID of WAVE_MAPPER ( which is equal to -1 )     */
; 911  :   /*  passes as a valid device ID.                                    */
; 912  :   /********************************************************************/
; 913  :   if ((int)uiWaveOutDeviceID >= (int)uiNumberOfWaveOutDevices )

  0008a	39 44 24 30	 cmp	 DWORD PTR _uiWaveOutDeviceID$[esp+36], eax
  0008e	7c 16		 jl	 SHORT $L71001

; 914  :   {
; 915  : #ifdef AUD_DEBUG
; 916  : 	OutputDebugString("PA_: Bad Device ID\n");
; 917  : #endif
; 918  :     PA_DestroyPlayHandle( pPlayAudio );

  00090	57		 push	 edi
  00091	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00096	83 c4 04	 add	 esp, 4

; 919  :     return MMSYSERR_BADDEVICEID;

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5d		 pop	 ebp
  000a1	5b		 pop	 ebx

; 1581 : }

  000a2	83 c4 18	 add	 esp, 24			; 00000018H
  000a5	c3		 ret	 0
$L71001:

; 920  :   }
; 921  :    else
; 922  :   {
; 923  : #ifdef AUD_DEBUG
; 924  : 	OutputDebugString("PA_: Device ID OK\n");
; 925  : #endif
; 926  :    }
; 927  :   /********************************************************************/
; 928  :   /*  Allocate memory for the play audio handle structure.            */
; 929  :   /********************************************************************/
; 930  : 
; 931  :   pPlayAudio = (HPLAY_AUDIO_T)malloc(sizeof(PLAY_AUDIO_T));

  000a6	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__malloc
  000ac	68 c0 00 00 00	 push	 192			; 000000c0H
  000b1	ff d3		 call	 ebx
  000b3	8b f0		 mov	 esi, eax
  000b5	83 c4 04	 add	 esp, 4

; 932  : 
; 933  :   if ( pPlayAudio == NULL )

  000b8	3b f7		 cmp	 esi, edi
  000ba	75 16		 jne	 SHORT $L71006

; 934  :   {
; 935  :     PA_DestroyPlayHandle( pPlayAudio );

  000bc	56		 push	 esi
  000bd	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  000c2	83 c4 04	 add	 esp, 4

; 936  :     return MMSYSERR_NOMEM;

  000c5	b8 07 00 00 00	 mov	 eax, 7
  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5d		 pop	 ebp
  000cd	5b		 pop	 ebx

; 1581 : }

  000ce	83 c4 18	 add	 esp, 24			; 00000018H
  000d1	c3		 ret	 0
$L71006:

; 937  :   }
; 938  : 
; 939  :   pPlayAudio->bHandleValid = FALSE;
; 940  : 
; 941  :   /********************************************************************/
; 942  :   /*  Initialize several handle elements to NULL.                     */
; 943  :   /********************************************************************/
; 944  : 
; 945  :   pPlayAudio->CallbackRoutine = NULL;
; 946  :   pPlayAudio->hWaveOut = (int)NULL;
; 947  :   pPlayAudio->hTimerThread = NULL;
; 948  :   pPlayAudio->hevAudioDeviceInactive = NULL;
; 949  :   pPlayAudio->hevTimerThreadActive = NULL;
; 950  :   pPlayAudio->hevQueueNotFull = NULL;
; 951  :   pPlayAudio->hevResetComplete = NULL;
; 952  :   pPlayAudio->hmxAudioDeviceState = NULL;
; 953  :   pPlayAudio->hmxBytesPlayed = NULL;
; 954  :   pPlayAudio->hmxSelectedDeviceID = NULL;
; 955  :   pPlayAudio->hmxQueueCount = NULL;
; 956  :   pPlayAudio->hmxQueueAudioBusy = NULL;
; 957  :   pPlayAudio->hmxPauseFlag = NULL;
; 958  :   pPlayAudio->ppWaveHdr = NULL;
; 959  :   pPlayAudio->pPlayAudioRing = NULL;
; 960  :   pPlayAudio->pSyncMarkList = NULL;
; 961  :   pPlayAudio->pWaveFormat = NULL;
; 962  :   //tek 09may97
; 963  :   pPlayAudio->iOutstandingBuffers=0;
; 964  :   pPlayAudio->iFirstFreeBuffer=0; //tek
; 965  : 
; 966  : #ifdef OS_SIXTY_FOUR_BIT
; 967  : 
; 968  :   /********************************************************************/
; 969  :   /*  Store the handle in the first free location in the global       */
; 970  :   /*  instance array so the wave output callback function can access  */
; 971  :   /*  the handle. This is necessary because for Digital UNIX,         */
; 972  :   /*  pointers are 64 bit and the dwInstance parameter (that is       */
; 973  :   /*  passed to the waveOutOpen() function and later returned in      */
; 974  :   /*  a callback) cannot hold a pointer to the play audio handle.     */
; 975  :   /********************************************************************/
; 976  : 
; 977  :   /********************************************************************/
; 978  :   /*  Set the audio instance to an illegal value. This is tested in   */
; 979  :   /*  the PA_DestroyPlayHandle() function.                            */
; 980  :   /********************************************************************/
; 981  : 
; 982  :   pPlayAudio->uiHandleListIndex = (unsigned int)(-1);
; 983  : 
; 984  :   /********************************************************************/
; 985  :   /*  Protect the Handle List.                                        */
; 986  :   /********************************************************************/
; 987  : 
; 988  :   OP_LockMutex( pShm_t->hmxGlobalHandleList );
; 989  : 
; 990  :   /********************************************************************/
; 991  :   /*  If this is the first "play audio" instance, then allocate the   */
; 992  :   /*  global handle array.                                            */
; 993  :   /********************************************************************/
; 994  : 
; 995  :   if ( pShm_t->ppGlobalHandleList == NULL )
; 996  :   {
; 997  :     pShm_t->ppGlobalHandleList = (HPLAY_AUDIO_T *)malloc( sizeof(HPLAY_AUDIO_T ));
; 998  : 
; 999  :     if ( pShm_t->ppGlobalHandleList == NULL )
; 1000 :     {
; 1001 :       PA_DestroyPlayHandle( pPlayAudio );
; 1002 :       return MMSYSERR_NOMEM;
; 1003 :     }
; 1004 : 
; 1005 :     pShm_t->ppGlobalHandleList[0] = NULL;
; 1006 :     pShm_t->uiGlobalHandleListLength = 1;
; 1007 :   }
; 1008 : 
; 1009 :   /********************************************************************/
; 1010 :   /*  Attempt to save the handle in the handle list. There might be   */
; 1011 :   /*  space in the handle array because a previous "play audio"       */
; 1012 :   /*  instance was destroyed by the PA_DestroyPlayHandle() function.  */
; 1013 :   /********************************************************************/
; 1014 : 
; 1015 :   bHandleSaved = FALSE;
; 1016 : 
; 1017 :   for ( uiI = 0; uiI < pShm_t->uiGlobalHandleListLength; uiI++ )
; 1018 :   {
; 1019 :     if ( pShm_t->ppGlobalHandleList[uiI] == NULL )
; 1020 :     {
; 1021 :       pShm_t->ppGlobalHandleList[uiI] = pPlayAudio;
; 1022 :       pPlayAudio->uiHandleListIndex = uiI;
; 1023 :       bHandleSaved = TRUE;
; 1024 :       break;
; 1025 :     }
; 1026 :   }
; 1027 : 
; 1028 :   /******************************************************************/
; 1029 :   /*  If there was no space in the handle list to save the handle   */
; 1030 :   /*  then extend the handle list. Then save the handle.            */
; 1031 :   /******************************************************************/
; 1032 : 
; 1033 :   if ( ! bHandleSaved )
; 1034 :   {
; 1035 :     ppGlobalHandleListTemp = ( HPLAY_AUDIO_T * )
; 1036 :       realloc( pShm_t->ppGlobalHandleList,
; 1037 :                ( pShm_t->uiGlobalHandleListLength + 1 ) * sizeof(HPLAY_AUDIO_T ));
; 1038 : 
; 1039 :     if ( ppGlobalHandleListTemp == NULL )
; 1040 :     {
; 1041 :       PA_DestroyPlayHandle( pPlayAudio );
; 1042 :       return MMSYSERR_NOMEM;
; 1043 :     }
; 1044 : 
; 1045 :     pShm_t->ppGlobalHandleList = ppGlobalHandleListTemp;
; 1046 :     pShm_t->ppGlobalHandleList[pShm_t->uiGlobalHandleListLength] = pPlayAudio;
; 1047 :     pPlayAudio->uiHandleListIndex = pShm_t->uiGlobalHandleListLength;
; 1048 :     pShm_t->uiGlobalHandleListLength++;
; 1049 :   }
; 1050 : 
; 1051 :   /********************************************************************/
; 1052 :   /*  Release the Handle List.                                        */
; 1053 :   /********************************************************************/
; 1054 : 
; 1055 :   OP_UnlockMutex( pShm_t->hmxGlobalHandleList );
; 1056 : 
; 1057 : #endif
; 1058 : 
; 1059 :   /********************************************************************/
; 1060 :   /*  Save the input parameters in the play audio handle.             */
; 1061 :   /********************************************************************/
; 1062 : 
; 1063 :   pPlayAudio->CallbackRoutine = CallbackRoutine;

  000d2	8b 4c 24 3c	 mov	 ecx, DWORD PTR _CallbackRoutine$[esp+36]

; 1064 :   pPlayAudio->aInstance = aInstance;

  000d6	8b 54 24 40	 mov	 edx, DWORD PTR _aInstance$[esp+36]

; 1065 :   pPlayAudio->dwDeviceOptions = dwDeviceOptions;

  000da	8b 44 24 38	 mov	 eax, DWORD PTR _dwDeviceOptions$[esp+36]
  000de	89 7e 68	 mov	 DWORD PTR [esi+104], edi

; 1066 : 
; 1067 :   /********************************************************************/
; 1068 :   /*  Initialize some Audio parameter handles and flags.              */
; 1069 :   /********************************************************************/
; 1070 : 
; 1071 :   pPlayAudio->bTimerExit = FALSE;
; 1072 :   pPlayAudio->bPaused = FALSE;
; 1073 :   pPlayAudio->bEnableOpenErrorMessage = TRUE;

  000e1	bd 01 00 00 00	 mov	 ebp, 1
  000e6	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  000e9	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 1074 :   pPlayAudio->bReportPlayStop = FALSE;
; 1075 : 
; 1076 :   /********************************************************************/
; 1077 :   /*  Initialize the wave out device state flags.                     */
; 1078 :   /********************************************************************/
; 1079 : 
; 1080 :   pPlayAudio->dwAudioDeviceState = AUDIO_DEVICE_INACTIVE;
; 1081 :   pPlayAudio->dwAudioPlayState = AUDIO_STATE_PLAY;
; 1082 : 
; 1083 :   /********************************************************************/
; 1084 :   /*  Set both audio position counts to zero.                         */
; 1085 :   /********************************************************************/
; 1086 : 
; 1087 :   pPlayAudio->dwPositionBase = 0;
; 1088 :   pPlayAudio->dwBytesPlayed = 0;
; 1089 :   pPlayAudio->dwQueuedByteCount = 0;
; 1090 : 
; 1091 :   /********************************************************************/
; 1092 :   /*  Create an "Audio Device Inactive" event. The initial state is   */
; 1093 :   /*  signalled.                                                      */
; 1094 :   /********************************************************************/
; 1095 : 
; 1096 :   pPlayAudio->hevAudioDeviceInactive = OP_CreateEvent( TRUE, TRUE );

  000ec	55		 push	 ebp
  000ed	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000f0	55		 push	 ebp
  000f1	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  000f4	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  000f7	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  000fa	89 7e 70	 mov	 DWORD PTR [esi+112], edi
  000fd	89 7e 74	 mov	 DWORD PTR [esi+116], edi
  00100	89 7e 78	 mov	 DWORD PTR [esi+120], edi
  00103	89 7e 7c	 mov	 DWORD PTR [esi+124], edi
  00106	89 be 80 00 00
	00		 mov	 DWORD PTR [esi+128], edi
  0010c	89 be 88 00 00
	00		 mov	 DWORD PTR [esi+136], edi
  00112	89 be 94 00 00
	00		 mov	 DWORD PTR [esi+148], edi
  00118	89 be 98 00 00
	00		 mov	 DWORD PTR [esi+152], edi
  0011e	89 be 9c 00 00
	00		 mov	 DWORD PTR [esi+156], edi
  00124	89 be a0 00 00
	00		 mov	 DWORD PTR [esi+160], edi
  0012a	89 be a4 00 00
	00		 mov	 DWORD PTR [esi+164], edi
  00130	89 be a8 00 00
	00		 mov	 DWORD PTR [esi+168], edi
  00136	89 0e		 mov	 DWORD PTR [esi], ecx
  00138	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0013b	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  0013e	89 7e 54	 mov	 DWORD PTR [esi+84], edi
  00141	89 7e 58	 mov	 DWORD PTR [esi+88], edi
  00144	89 6e 60	 mov	 DWORD PTR [esi+96], ebp
  00147	89 7e 64	 mov	 DWORD PTR [esi+100], edi
  0014a	89 7e 34	 mov	 DWORD PTR [esi+52], edi
  0014d	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  00150	89 7e 40	 mov	 DWORD PTR [esi+64], edi
  00153	89 7e 44	 mov	 DWORD PTR [esi+68], edi
  00156	89 7e 4c	 mov	 DWORD PTR [esi+76], edi
  00159	e8 00 00 00 00	 call	 _OP_CreateEvent
  0015e	83 c4 08	 add	 esp, 8

; 1097 : 
; 1098 :   if ( pPlayAudio->hevAudioDeviceInactive == NULL )

  00161	3b c7		 cmp	 eax, edi
  00163	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00166	75 13		 jne	 SHORT $L71026

; 1099 :   {
; 1100 :     PA_DestroyPlayHandle( pPlayAudio );

  00168	56		 push	 esi
  00169	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  0016e	83 c4 04	 add	 esp, 4

; 1101 :     return MMSYSERR_ERROR;

  00171	8b c5		 mov	 eax, ebp
  00173	5f		 pop	 edi
  00174	5e		 pop	 esi
  00175	5d		 pop	 ebp
  00176	5b		 pop	 ebx

; 1581 : }

  00177	83 c4 18	 add	 esp, 24			; 00000018H
  0017a	c3		 ret	 0
$L71026:

; 1102 :   }
; 1103 : 
; 1104 :   /********************************************************************/
; 1105 :   /*  Create an "Timer Thread Active" event. The initial state is     */
; 1106 :   /*  signalled.                                                      */
; 1107 :   /********************************************************************/
; 1108 : 
; 1109 :   pPlayAudio->hevTimerThreadActive = OP_CreateEvent( TRUE, TRUE );

  0017b	55		 push	 ebp
  0017c	55		 push	 ebp
  0017d	e8 00 00 00 00	 call	 _OP_CreateEvent
  00182	83 c4 08	 add	 esp, 8

; 1110 : 
; 1111 :   if ( pPlayAudio->hevTimerThreadActive == NULL )

  00185	3b c7		 cmp	 eax, edi
  00187	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0018a	75 13		 jne	 SHORT $L71028

; 1112 :   {
; 1113 :     PA_DestroyPlayHandle( pPlayAudio );

  0018c	56		 push	 esi
  0018d	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00192	83 c4 04	 add	 esp, 4

; 1114 :     return MMSYSERR_ERROR;

  00195	8b c5		 mov	 eax, ebp
  00197	5f		 pop	 edi
  00198	5e		 pop	 esi
  00199	5d		 pop	 ebp
  0019a	5b		 pop	 ebx

; 1581 : }

  0019b	83 c4 18	 add	 esp, 24			; 00000018H
  0019e	c3		 ret	 0
$L71028:

; 1115 :   }
; 1116 : 
; 1117 :   /********************************************************************/
; 1118 :   /*  Create a "Queue Not Full" event. The initial state is           */
; 1119 :   /*  signalled.                                                      */
; 1120 :   /********************************************************************/
; 1121 : 
; 1122 :   pPlayAudio->hevQueueNotFull = OP_CreateEvent( TRUE, TRUE );

  0019f	55		 push	 ebp
  001a0	55		 push	 ebp
  001a1	e8 00 00 00 00	 call	 _OP_CreateEvent
  001a6	83 c4 08	 add	 esp, 8

; 1123 : 
; 1124 :   if ( pPlayAudio->hevQueueNotFull == NULL )

  001a9	3b c7		 cmp	 eax, edi
  001ab	89 46 18	 mov	 DWORD PTR [esi+24], eax
  001ae	75 13		 jne	 SHORT $L71030

; 1125 :   {
; 1126 :     PA_DestroyPlayHandle( pPlayAudio );

  001b0	56		 push	 esi
  001b1	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  001b6	83 c4 04	 add	 esp, 4

; 1127 :     return MMSYSERR_ERROR;

  001b9	8b c5		 mov	 eax, ebp
  001bb	5f		 pop	 edi
  001bc	5e		 pop	 esi
  001bd	5d		 pop	 ebp
  001be	5b		 pop	 ebx

; 1581 : }

  001bf	83 c4 18	 add	 esp, 24			; 00000018H
  001c2	c3		 ret	 0
$L71030:

; 1128 :   }
; 1129 : 
; 1130 :   /********************************************************************/
; 1131 :   /*  Create a "Reset Complete" event. The initial state is not       */
; 1132 :   /*  signalled.                                                      */
; 1133 :   /********************************************************************/
; 1134 : 
; 1135 :   pPlayAudio->hevResetComplete = OP_CreateEvent( TRUE, TRUE );

  001c3	55		 push	 ebp
  001c4	55		 push	 ebp
  001c5	e8 00 00 00 00	 call	 _OP_CreateEvent
  001ca	83 c4 08	 add	 esp, 8

; 1136 : 
; 1137 :   if ( pPlayAudio->hevResetComplete == NULL )

  001cd	3b c7		 cmp	 eax, edi
  001cf	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  001d2	75 13		 jne	 SHORT $L71032

; 1138 :   {
; 1139 :     PA_DestroyPlayHandle( pPlayAudio );

  001d4	56		 push	 esi
  001d5	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  001da	83 c4 04	 add	 esp, 4

; 1140 :     return MMSYSERR_ERROR;

  001dd	8b c5		 mov	 eax, ebp
  001df	5f		 pop	 edi
  001e0	5e		 pop	 esi
  001e1	5d		 pop	 ebp
  001e2	5b		 pop	 ebx

; 1581 : }

  001e3	83 c4 18	 add	 esp, 24			; 00000018H
  001e6	c3		 ret	 0
$L71032:

; 1141 :   }
; 1142 : 
; 1143 :   /********************************************************************/
; 1144 :   /*  Create the "Audio Device State" mutex.                          */
; 1145 :   /********************************************************************/
; 1146 : 
; 1147 :   pPlayAudio->hmxAudioDeviceState = OP_CreateMutex();

  001e7	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1148 : 
; 1149 :   if ( pPlayAudio->hmxAudioDeviceState == NULL )

  001ec	3b c7		 cmp	 eax, edi
  001ee	89 46 70	 mov	 DWORD PTR [esi+112], eax
  001f1	75 13		 jne	 SHORT $L71034

; 1150 :   {
; 1151 :     PA_DestroyPlayHandle( pPlayAudio );

  001f3	56		 push	 esi
  001f4	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  001f9	83 c4 04	 add	 esp, 4

; 1152 :     return MMSYSERR_ERROR;

  001fc	8b c5		 mov	 eax, ebp
  001fe	5f		 pop	 edi
  001ff	5e		 pop	 esi
  00200	5d		 pop	 ebp
  00201	5b		 pop	 ebx

; 1581 : }

  00202	83 c4 18	 add	 esp, 24			; 00000018H
  00205	c3		 ret	 0
$L71034:

; 1153 :   }
; 1154 : 
; 1155 :   /********************************************************************/
; 1156 :   /*  Create the "Bytes Played" mutex.                                */
; 1157 :   /********************************************************************/
; 1158 : 
; 1159 :   pPlayAudio->hmxBytesPlayed = OP_CreateMutex();

  00206	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1160 : 
; 1161 :   if ( pPlayAudio->hmxBytesPlayed == NULL )

  0020b	3b c7		 cmp	 eax, edi
  0020d	89 46 74	 mov	 DWORD PTR [esi+116], eax
  00210	75 13		 jne	 SHORT $L71036

; 1162 :   {
; 1163 :     PA_DestroyPlayHandle( pPlayAudio );

  00212	56		 push	 esi
  00213	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00218	83 c4 04	 add	 esp, 4

; 1164 :     return MMSYSERR_ERROR;

  0021b	8b c5		 mov	 eax, ebp
  0021d	5f		 pop	 edi
  0021e	5e		 pop	 esi
  0021f	5d		 pop	 ebp
  00220	5b		 pop	 ebx

; 1581 : }

  00221	83 c4 18	 add	 esp, 24			; 00000018H
  00224	c3		 ret	 0
$L71036:

; 1165 :   }
; 1166 : 
; 1167 :   /********************************************************************/
; 1168 :   /*  Create the "Selected Device ID" mutex.                          */
; 1169 :   /********************************************************************/
; 1170 : 
; 1171 :   pPlayAudio->hmxSelectedDeviceID = OP_CreateMutex();

  00225	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1172 : 
; 1173 :   if ( pPlayAudio->hmxSelectedDeviceID == NULL )

  0022a	3b c7		 cmp	 eax, edi
  0022c	89 46 78	 mov	 DWORD PTR [esi+120], eax
  0022f	75 13		 jne	 SHORT $L71038

; 1174 :   {
; 1175 :     PA_DestroyPlayHandle( pPlayAudio );

  00231	56		 push	 esi
  00232	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00237	83 c4 04	 add	 esp, 4

; 1176 :     return MMSYSERR_ERROR;

  0023a	8b c5		 mov	 eax, ebp
  0023c	5f		 pop	 edi
  0023d	5e		 pop	 esi
  0023e	5d		 pop	 ebp
  0023f	5b		 pop	 ebx

; 1581 : }

  00240	83 c4 18	 add	 esp, 24			; 00000018H
  00243	c3		 ret	 0
$L71038:

; 1177 :   }
; 1178 : 
; 1179 :   /********************************************************************/
; 1180 :   /*  Create the "Queue Count" mutex.                                 */
; 1181 :   /********************************************************************/
; 1182 : 
; 1183 :   pPlayAudio->hmxQueueCount = OP_CreateMutex();

  00244	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1184 : 
; 1185 :   if ( pPlayAudio->hmxQueueCount == NULL )

  00249	3b c7		 cmp	 eax, edi
  0024b	89 46 7c	 mov	 DWORD PTR [esi+124], eax
  0024e	75 13		 jne	 SHORT $L71040

; 1186 :   {
; 1187 :     PA_DestroyPlayHandle( pPlayAudio );

  00250	56		 push	 esi
  00251	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00256	83 c4 04	 add	 esp, 4

; 1188 :     return MMSYSERR_ERROR;

  00259	8b c5		 mov	 eax, ebp
  0025b	5f		 pop	 edi
  0025c	5e		 pop	 esi
  0025d	5d		 pop	 ebp
  0025e	5b		 pop	 ebx

; 1581 : }

  0025f	83 c4 18	 add	 esp, 24			; 00000018H
  00262	c3		 ret	 0
$L71040:

; 1189 :   }
; 1190 : 
; 1191 :   /********************************************************************/
; 1192 :   /*  Create the "Queue Audio Busy" mutex.                            */
; 1193 :   /********************************************************************/
; 1194 : 
; 1195 :   pPlayAudio->hmxQueueAudioBusy = OP_CreateMutex();

  00263	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1196 : 
; 1197 :   if ( pPlayAudio->hmxQueueAudioBusy == NULL )

  00268	3b c7		 cmp	 eax, edi
  0026a	89 86 80 00 00
	00		 mov	 DWORD PTR [esi+128], eax
  00270	75 13		 jne	 SHORT $L71042

; 1198 :   {
; 1199 :     PA_DestroyPlayHandle( pPlayAudio );

  00272	56		 push	 esi
  00273	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00278	83 c4 04	 add	 esp, 4

; 1200 :     return MMSYSERR_ERROR;

  0027b	8b c5		 mov	 eax, ebp
  0027d	5f		 pop	 edi
  0027e	5e		 pop	 esi
  0027f	5d		 pop	 ebp
  00280	5b		 pop	 ebx

; 1581 : }

  00281	83 c4 18	 add	 esp, 24			; 00000018H
  00284	c3		 ret	 0
$L71042:

; 1201 :   }
; 1202 : 
; 1203 :   /********************************************************************/
; 1204 :   /*  Create the "Queued Byte Count" mutex.                           */
; 1205 :   /********************************************************************/
; 1206 : 
; 1207 :   pPlayAudio->hmxQueuedByteCount = OP_CreateMutex();

  00285	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1208 : 
; 1209 :   if ( pPlayAudio->hmxQueuedByteCount == NULL )

  0028a	3b c7		 cmp	 eax, edi
  0028c	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  00292	75 13		 jne	 SHORT $L71044

; 1210 :   {
; 1211 :     PA_DestroyPlayHandle( pPlayAudio );

  00294	56		 push	 esi
  00295	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  0029a	83 c4 04	 add	 esp, 4

; 1212 :     return MMSYSERR_ERROR;

  0029d	8b c5		 mov	 eax, ebp
  0029f	5f		 pop	 edi
  002a0	5e		 pop	 esi
  002a1	5d		 pop	 ebp
  002a2	5b		 pop	 ebx

; 1581 : }

  002a3	83 c4 18	 add	 esp, 24			; 00000018H
  002a6	c3		 ret	 0
$L71044:

; 1213 :   }
; 1214 : 
; 1215 :   /********************************************************************/
; 1216 :   /*  Create the "Pause Flag" mutex.                                  */
; 1217 :   /********************************************************************/
; 1218 : 
; 1219 :   pPlayAudio->hmxPauseFlag = OP_CreateMutex();

  002a7	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1220 : 
; 1221 :   if ( pPlayAudio->hmxPauseFlag == NULL )

  002ac	3b c7		 cmp	 eax, edi
  002ae	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  002b4	75 13		 jne	 SHORT $L71046

; 1222 :   {
; 1223 :     PA_DestroyPlayHandle( pPlayAudio );

  002b6	56		 push	 esi
  002b7	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  002bc	83 c4 04	 add	 esp, 4

; 1224 :     return MMSYSERR_ERROR;

  002bf	8b c5		 mov	 eax, ebp
  002c1	5f		 pop	 edi
  002c2	5e		 pop	 esi
  002c3	5d		 pop	 ebp
  002c4	5b		 pop	 ebx

; 1581 : }

  002c5	83 c4 18	 add	 esp, 24			; 00000018H
  002c8	c3		 ret	 0
$L71046:

; 1225 :   }
; 1226 : 
; 1227 :   /********************************************************************/
; 1228 :   /*  Create the "Synchronization Mark List" mutex.                   */
; 1229 :   /********************************************************************/
; 1230 : 
; 1231 :   pPlayAudio->hmxSynchronizationMarkList = OP_CreateMutex();

  002c9	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1232 : 
; 1233 :   if ( pPlayAudio->hmxSynchronizationMarkList == NULL )

  002ce	3b c7		 cmp	 eax, edi
  002d0	89 86 8c 00 00
	00		 mov	 DWORD PTR [esi+140], eax
  002d6	75 13		 jne	 SHORT $L71048

; 1234 :   {
; 1235 :     PA_DestroyPlayHandle( pPlayAudio );

  002d8	56		 push	 esi
  002d9	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  002de	83 c4 04	 add	 esp, 4

; 1236 :     return MMSYSERR_ERROR;

  002e1	8b c5		 mov	 eax, ebp
  002e3	5f		 pop	 edi
  002e4	5e		 pop	 esi
  002e5	5d		 pop	 ebp
  002e6	5b		 pop	 ebx

; 1581 : }

  002e7	83 c4 18	 add	 esp, 24			; 00000018H
  002ea	c3		 ret	 0
$L71048:

; 1237 :   }
; 1238 : 
; 1239 :   /********************************************************************/
; 1240 :   /*  Create the "Wave Format" mutex.                                 */
; 1241 :   /********************************************************************/
; 1242 : 
; 1243 :   pPlayAudio->hmxWaveFormat = OP_CreateMutex();

  002eb	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1244 : 
; 1245 :   if ( pPlayAudio->hmxWaveFormat == NULL )

  002f0	3b c7		 cmp	 eax, edi
  002f2	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax
  002f8	75 13		 jne	 SHORT $L71050

; 1246 :   {
; 1247 :     PA_DestroyPlayHandle( pPlayAudio );

  002fa	56		 push	 esi
  002fb	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00300	83 c4 04	 add	 esp, 4

; 1248 :     return MMSYSERR_ERROR;

  00303	8b c5		 mov	 eax, ebp
  00305	5f		 pop	 edi
  00306	5e		 pop	 esi
  00307	5d		 pop	 ebp
  00308	5b		 pop	 ebx

; 1581 : }

  00309	83 c4 18	 add	 esp, 24			; 00000018H
  0030c	c3		 ret	 0
$L71050:

; 1249 :   }
; 1250 : 
; 1251 :   /********************************************************************/
; 1252 :   /*  Set the wave format data in the "play audio" handle.            */
; 1253 :   /********************************************************************/
; 1254 : #ifdef AUD_DEBUG
; 1255 :   OutputDebugString("PA_: setting format in handle..\n");
; 1256 : #endif
; 1257 :   if ( pWaveFormat != NULL )

  0030d	8b 44 24 34	 mov	 eax, DWORD PTR _pWaveFormat$[esp+36]
  00311	3b c7		 cmp	 eax, edi
  00313	74 03		 je	 SHORT $L71052

; 1258 :   {
; 1259 : #ifdef AUD_DEBUG
; 1260 : 	  OutputDebugString("PA_: SetNewFormat {1}\n");
; 1261 : #endif
; 1262 : 	  mmStatus = SetNewFormat( pPlayAudio, pWaveFormat );

  00315	50		 push	 eax

; 1263 :   }
; 1264 :   else

  00316	eb 32		 jmp	 SHORT $L72102
$L71052:

; 1265 :   {
; 1266 :     /******************************************************************/
; 1267 :     /*  The default format is 11 Khz. 16 bit PCM.                     */
; 1268 :     /******************************************************************/
; 1269 : 
; 1270 :     WaveFormat.wFormatTag = WAVE_FORMAT_PCM;
; 1271 :     WaveFormat.nSamplesPerSec = 11025;
; 1272 :     WaveFormat.nChannels = 1;
; 1273 :     WaveFormat.nAvgBytesPerSec = 22050;
; 1274 :     WaveFormat.nBlockAlign = 2;
; 1275 :     WaveFormat.wBitsPerSample = 16;
; 1276 :     WaveFormat.cbSize = 0;
; 1277 : 
; 1278 : #ifdef AUD_DEBUG
; 1279 : 	OutputDebugString("PA_: SetNewFormat {2}\n");
; 1280 : #endif
; 1281 :     mmStatus = SetNewFormat( pPlayAudio, &WaveFormat );

  00318	8d 4c 24 14	 lea	 ecx, DWORD PTR _WaveFormat$[esp+40]
  0031c	66 89 6c 24 14	 mov	 WORD PTR _WaveFormat$[esp+40], bp
  00321	c7 44 24 18 11
	2b 00 00	 mov	 DWORD PTR _WaveFormat$[esp+44], 11025 ; 00002b11H
  00329	66 89 6c 24 16	 mov	 WORD PTR _WaveFormat$[esp+42], bp
  0032e	c7 44 24 1c 22
	56 00 00	 mov	 DWORD PTR _WaveFormat$[esp+48], 22050 ; 00005622H
  00336	66 c7 44 24 20
	02 00		 mov	 WORD PTR _WaveFormat$[esp+52], 2
  0033d	66 c7 44 24 22
	10 00		 mov	 WORD PTR _WaveFormat$[esp+54], 16 ; 00000010H
  00344	66 89 7c 24 24	 mov	 WORD PTR _WaveFormat$[esp+56], di
  00349	51		 push	 ecx
$L72102:
  0034a	56		 push	 esi
  0034b	e8 00 00 00 00	 call	 _SetNewFormat
  00350	8b e8		 mov	 ebp, eax
  00352	83 c4 08	 add	 esp, 8

; 1282 :   }
; 1283 : 
; 1284 :   if ( mmStatus )

  00355	3b ef		 cmp	 ebp, edi
  00357	74 13		 je	 SHORT $L71054

; 1285 :   {
; 1286 : #ifdef AUD_DEBUG
; 1287 : 	OutputDebugString("PA_: SetNewFormat failed\n");
; 1288 : #endif
; 1289 :     PA_DestroyPlayHandle( pPlayAudio );

  00359	56		 push	 esi
  0035a	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  0035f	83 c4 04	 add	 esp, 4

; 1290 :     return mmStatus;

  00362	8b c5		 mov	 eax, ebp
  00364	5f		 pop	 edi
  00365	5e		 pop	 esi
  00366	5d		 pop	 ebp
  00367	5b		 pop	 ebx

; 1581 : }

  00368	83 c4 18	 add	 esp, 24			; 00000018H
  0036b	c3		 ret	 0
$L71054:

; 1291 :   }
; 1292 : 
; 1293 :   /********************************************************************/
; 1294 :   /*  Allocate Memory for Wave Header pointer array.                  */
; 1295 :   /********************************************************************/
; 1296 : 
; 1297 :   pPlayAudio->ppWaveHdr =
; 1298 :     (LPWAVEHDR *)malloc( MAXIMUM_BUFFERS_QUEUED * sizeof(LPWAVEHDR));

  0036c	6a 20		 push	 32			; 00000020H
  0036e	ff d3		 call	 ebx
  00370	83 c4 04	 add	 esp, 4

; 1299 : 
; 1300 :   if ( pPlayAudio->ppWaveHdr == NULL )

  00373	3b c7		 cmp	 eax, edi
  00375	89 86 94 00 00
	00		 mov	 DWORD PTR [esi+148], eax
  0037b	75 16		 jne	 SHORT $L71058

; 1301 :   {
; 1302 :     PA_DestroyPlayHandle( pPlayAudio );

  0037d	56		 push	 esi
  0037e	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00383	83 c4 04	 add	 esp, 4

; 1303 :     return MMSYSERR_NOMEM;

  00386	b8 07 00 00 00	 mov	 eax, 7
  0038b	5f		 pop	 edi
  0038c	5e		 pop	 esi
  0038d	5d		 pop	 ebp
  0038e	5b		 pop	 ebx

; 1581 : }

  0038f	83 c4 18	 add	 esp, 24			; 00000018H
  00392	c3		 ret	 0
$L71058:

; 1304 :   }
; 1305 :   else
; 1306 :   {
; 1307 :     for ( uiI = 0; uiI < MAXIMUM_BUFFERS_QUEUED; uiI++ )

  00393	33 c0		 xor	 eax, eax
$L71060:

; 1308 :       pPlayAudio->ppWaveHdr[uiI] = NULL;

  00395	8b 96 94 00 00
	00		 mov	 edx, DWORD PTR [esi+148]
  0039b	83 c0 04	 add	 eax, 4
  0039e	83 f8 20	 cmp	 eax, 32			; 00000020H
  003a1	89 7c 10 fc	 mov	 DWORD PTR [eax+edx-4], edi
  003a5	7c ee		 jl	 SHORT $L71060

; 1309 : 
; 1310 :     /******************************************************************/
; 1311 :     /*  Allocate Memory for the Wave Headers.                         */
; 1312 :     /******************************************************************/
; 1313 : 
; 1314 :     for ( uiI = 0; uiI < MAXIMUM_BUFFERS_QUEUED; uiI++ )

  003a7	33 ed		 xor	 ebp, ebp
$L71064:

; 1315 :     {
; 1316 :       LOCK_MME_CALL(
; 1317 :         pPlayAudio->ppWaveHdr[uiI] =
; 1318 :           (LPWAVEHDR)ALLOCATE_LOCKED_MEMORY( sizeof(WAVEHDR)))

  003a9	6a 20		 push	 32			; 00000020H
  003ab	e8 00 00 00 00	 call	 _mallocLock
  003b0	8b 8e 94 00 00
	00		 mov	 ecx, DWORD PTR [esi+148]
  003b6	83 c4 04	 add	 esp, 4
  003b9	89 04 29	 mov	 DWORD PTR [ecx+ebp], eax

; 1319 : 
; 1320 :       if ( pPlayAudio->ppWaveHdr[uiI] == NULL )

  003bc	8b 96 94 00 00
	00		 mov	 edx, DWORD PTR [esi+148]
  003c2	39 3c 2a	 cmp	 DWORD PTR [edx+ebp], edi
  003c5	74 48		 je	 SHORT $L72099
  003c7	83 c5 04	 add	 ebp, 4
  003ca	83 fd 20	 cmp	 ebp, 32			; 00000020H
  003cd	7c da		 jl	 SHORT $L71064

; 1321 :       {
; 1322 :         PA_DestroyPlayHandle( pPlayAudio );
; 1323 :         return MMSYSERR_NOMEM;
; 1324 :       }
; 1325 :     }
; 1326 :   }
; 1327 : 
; 1328 :   /********************************************************************/
; 1329 :   /*  Allocate Memory for the Audio Queue Structure.                  */
; 1330 :   /********************************************************************/
; 1331 : 
; 1332 :   pPlayAudioRing = (LPPLAY_RING_T)malloc(sizeof(PLAY_RING_T));

  003cf	6a 20		 push	 32			; 00000020H
  003d1	ff d3		 call	 ebx
  003d3	8b e8		 mov	 ebp, eax
  003d5	83 c4 04	 add	 esp, 4

; 1333 : 
; 1334 :   if ( pPlayAudioRing == NULL )

  003d8	3b ef		 cmp	 ebp, edi
  003da	75 16		 jne	 SHORT $L71074

; 1335 :   {
; 1336 :     PA_DestroyPlayHandle( pPlayAudio );

  003dc	56		 push	 esi
  003dd	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  003e2	83 c4 04	 add	 esp, 4

; 1337 :     return MMSYSERR_NOMEM;

  003e5	b8 07 00 00 00	 mov	 eax, 7
  003ea	5f		 pop	 edi
  003eb	5e		 pop	 esi
  003ec	5d		 pop	 ebp
  003ed	5b		 pop	 ebx

; 1581 : }

  003ee	83 c4 18	 add	 esp, 24			; 00000018H
  003f1	c3		 ret	 0
$L71074:

; 1338 :   }
; 1339 : 
; 1340 :   pPlayAudio->pPlayAudioRing = pPlayAudioRing;

  003f2	89 ae 98 00 00
	00		 mov	 DWORD PTR [esi+152], ebp

; 1341 : 
; 1342 :   /********************************************************************/
; 1343 :   /*  Initialize several of the audio queue elements to NULL.         */
; 1344 :   /********************************************************************/
; 1345 : 
; 1346 :   pPlayAudioRing->pQueueTop = NULL;
; 1347 : 
; 1348 :   /********************************************************************/
; 1349 :   /*  Allocate Memory for the audio buffer.                           */
; 1350 :   /********************************************************************/
; 1351 : 
; 1352 :   LOCK_MME_CALL(
; 1353 :     pPlayAudioRing->pQueueTop = (LPAUDIO_T)
; 1354 :       ALLOCATE_SERVER_BUFFER(( AUDIO_BUFFER_SIZE + MAXIMUM_WRITE_LENGTH ) *
; 1355 :         sizeof(AUDIO_T)))

  003f8	68 00 80 02 00	 push	 163840			; 00028000H
  003fd	89 7d 00	 mov	 DWORD PTR [ebp], edi
  00400	e8 00 00 00 00	 call	 _mallocLock
  00405	83 c4 04	 add	 esp, 4

; 1356 : 
; 1357 :   if ( pPlayAudioRing->pQueueTop == NULL )

  00408	3b c7		 cmp	 eax, edi
  0040a	89 45 00	 mov	 DWORD PTR [ebp], eax
  0040d	75 16		 jne	 SHORT $L71079
$L72099:

; 1358 :   {
; 1359 :     PA_DestroyPlayHandle( pPlayAudio );

  0040f	56		 push	 esi
  00410	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00415	83 c4 04	 add	 esp, 4

; 1360 :     return MMSYSERR_NOMEM;

  00418	b8 07 00 00 00	 mov	 eax, 7
  0041d	5f		 pop	 edi
  0041e	5e		 pop	 esi
  0041f	5d		 pop	 ebp
  00420	5b		 pop	 ebx

; 1581 : }

  00421	83 c4 18	 add	 esp, 24			; 00000018H
  00424	c3		 ret	 0
$L71079:

; 1361 :   }
; 1362 : 
; 1363 :   /********************************************************************/
; 1364 :   /*  Initialize the audio queue buffer start and length.             */
; 1365 :   /********************************************************************/
; 1366 : 
; 1367 :   pPlayAudioRing->pQueueStart =
; 1368 :     pPlayAudioRing->pQueueTop + MAXIMUM_WRITE_LENGTH;

  00425	05 00 40 00 00	 add	 eax, 16384		; 00004000H

; 1369 :   pPlayAudioRing->iQueueLength = AUDIO_BUFFER_SIZE;
; 1370 : 
; 1371 :   /********************************************************************/
; 1372 :   /*  Initialize the audio queue and the completion count.            */
; 1373 :   /********************************************************************/
; 1374 : 
; 1375 :   ResetAudioQueue( pPlayAudio );

  0042a	56		 push	 esi
  0042b	89 45 04	 mov	 DWORD PTR [ebp+4], eax
  0042e	c7 45 1c 00 40
	02 00		 mov	 DWORD PTR [ebp+28], 147456 ; 00024000H
  00435	e8 00 00 00 00	 call	 _ResetAudioQueue

; 1376 : 
; 1377 :   pPlayAudio->iSamplesWaitingForCompletion = 0;

  0043a	89 7e 30	 mov	 DWORD PTR [esi+48], edi

; 1378 : 
; 1379 :   /********************************************************************/
; 1380 :   /*  If this is the first instance then create a message queue and   */
; 1381 :   /*  a "play audio" thread.                                          */
; 1382 :   /********************************************************************/
; 1383 : 
; 1384 :   if ( pShm_t->uiGlobalPlayAudioInstance == 1 )

  0043d	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  00442	83 c4 04	 add	 esp, 4
  00445	83 38 01	 cmp	 DWORD PTR [eax], 1
  00448	0f 85 df 00 00
	00		 jne	 $L71080

; 1385 :   {
; 1386 :     /******************************************************************/
; 1387 :     /*  Create the "play audio" message queue.                        */
; 1388 :     /******************************************************************/
; 1389 : 
; 1390 :     pShm_t->pGlobalPlayAudioMessageQueue = CreateMessageQueue( MESSAGE_QUEUE_LENGTH );

  0044e	68 00 01 00 00	 push	 256			; 00000100H
  00453	e8 00 00 00 00	 call	 _CreateMessageQueue
  00458	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t
  0045e	83 c4 04	 add	 esp, 4
  00461	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1391 : 
; 1392 :     if ( pShm_t->pGlobalPlayAudioMessageQueue == NULL )

  00464	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  0046a	39 7a 14	 cmp	 DWORD PTR [edx+20], edi
  0046d	75 16		 jne	 SHORT $L71082

; 1393 :     {
; 1394 :       PA_DestroyPlayHandle( pPlayAudio );

  0046f	56		 push	 esi
  00470	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00475	83 c4 04	 add	 esp, 4

; 1395 :       return MMSYSERR_ERROR;

  00478	b8 01 00 00 00	 mov	 eax, 1
  0047d	5f		 pop	 edi
  0047e	5e		 pop	 esi
  0047f	5d		 pop	 ebp
  00480	5b		 pop	 ebx

; 1581 : }

  00481	83 c4 18	 add	 esp, 24			; 00000018H
  00484	c3		 ret	 0
$L71082:

; 1396 :     }
; 1397 : 
; 1398 :     /******************************************************************/
; 1399 :     /*  Create the "report" message queue.                            */
; 1400 :     /******************************************************************/
; 1401 : 
; 1402 :     pShm_t->pGlobalReportMessageQueue = CreateMessageQueue( 1 );

  00485	6a 01		 push	 1
  00487	e8 00 00 00 00	 call	 _CreateMessageQueue
  0048c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t
  00492	83 c4 04	 add	 esp, 4
  00495	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 1403 : 
; 1404 :     if ( pShm_t->pGlobalReportMessageQueue == NULL )

  00498	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  0049e	39 7a 10	 cmp	 DWORD PTR [edx+16], edi
  004a1	75 16		 jne	 SHORT $L71084

; 1405 :     {
; 1406 :       PA_DestroyPlayHandle( pPlayAudio );

  004a3	56		 push	 esi
  004a4	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  004a9	83 c4 04	 add	 esp, 4

; 1407 :       return MMSYSERR_ERROR;

  004ac	b8 01 00 00 00	 mov	 eax, 1
  004b1	5f		 pop	 edi
  004b2	5e		 pop	 esi
  004b3	5d		 pop	 ebp
  004b4	5b		 pop	 ebx

; 1581 : }

  004b5	83 c4 18	 add	 esp, 24			; 00000018H
  004b8	c3		 ret	 0
$L71084:

; 1408 :     }
; 1409 : 
; 1410 :     /******************************************************************/
; 1411 :     /*  Create the global "Send Play Audio" mutex.                    */
; 1412 :     /******************************************************************/
; 1413 : 
; 1414 :     pShm_t->hmxGlobalSendPlayAudio = OP_CreateMutex();

  004b9	e8 00 00 00 00	 call	 _OP_CreateMutex
  004be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t

; 1415 : 
; 1416 :     if ( pShm_t->hmxGlobalSendPlayAudio == NULL )
; 1417 :     {
; 1418 :       PA_DestroyPlayHandle( pPlayAudio );

  004c4	56		 push	 esi
  004c5	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  004c8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  004ce	39 7a 0c	 cmp	 DWORD PTR [edx+12], edi
  004d1	75 15		 jne	 SHORT $L71086
  004d3	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  004d8	83 c4 04	 add	 esp, 4

; 1419 :       return MMSYSERR_ERROR;

  004db	b8 01 00 00 00	 mov	 eax, 1
  004e0	5f		 pop	 edi
  004e1	5e		 pop	 esi
  004e2	5d		 pop	 ebp
  004e3	5b		 pop	 ebx

; 1581 : }

  004e4	83 c4 18	 add	 esp, 24			; 00000018H
  004e7	c3		 ret	 0
$L71086:

; 1420 :     }
; 1421 : 
; 1422 :     /******************************************************************/
; 1423 :     /*  Create the play audio thread.                                 */
; 1424 :     /******************************************************************/
; 1425 : 
; 1426 :     pShm_t->hGlobalPlayAudioThread =
; 1427 :               OP_CreateThread( 0,
; 1428 :                                (THREAD_PROCEDURE_T)PlayAudioThreadMain,
; 1429 :                                pPlayAudio );

  004e8	68 00 00 00 00	 push	 OFFSET FLAT:_PlayAudioThreadMain
  004ed	57		 push	 edi
  004ee	e8 00 00 00 00	 call	 _OP_CreateThread
  004f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t
  004f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  004fc	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1430 : 
; 1431 :     if ( pShm_t->hGlobalPlayAudioThread == NULL )

  004ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  00505	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00508	3b c7		 cmp	 eax, edi
  0050a	75 16		 jne	 SHORT $L71089

; 1432 :     {
; 1433 :       PA_DestroyPlayHandle( pPlayAudio );

  0050c	56		 push	 esi
  0050d	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00512	83 c4 04	 add	 esp, 4

; 1434 :       return MMSYSERR_ERROR;

  00515	b8 01 00 00 00	 mov	 eax, 1
  0051a	5f		 pop	 edi
  0051b	5e		 pop	 esi
  0051c	5d		 pop	 ebp
  0051d	5b		 pop	 ebx

; 1581 : }

  0051e	83 c4 18	 add	 esp, 24			; 00000018H
  00521	c3		 ret	 0
$L71089:

; 1435 :     }
; 1436 : 
; 1437 :     OP_SetThreadPriority( pShm_t->hGlobalPlayAudioThread, OP_PRIORITY_HIGHEST );

  00522	6a 02		 push	 2
  00524	50		 push	 eax
  00525	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  0052a	83 c4 08	 add	 esp, 8
$L71080:

; 1438 : 
; 1439 : #ifdef USE_MME_SERVER
; 1440 : 
; 1441 :     /******************************************************************/
; 1442 :     /*  Create the MME callback thread.                               */
; 1443 :     /******************************************************************/
; 1444 : 
; 1445 :     pShm_t->bGlobalMmeCallbackExit = FALSE;
; 1446 : 
; 1447 :     pShm_t->hGlobalMmeCallbackThread =
; 1448 :             OP_CreateThread( 0,
; 1449 :                              (THREAD_PROCEDURE_T)MmeCallbackThreadMain,
; 1450 :                              pPlayAudio );
; 1451 : 
; 1452 : /* TQL 05/21/1997  change this for OSF build */
; 1453 : #ifdef WIN32
; 1454 :     if ( pShm_t->hGlobalPlayAudioThread == NULL )
; 1455 : #endif
; 1456 : #ifdef __osf__
; 1457 :     if ( pShm_t->hGlobalMmeCallbackThread == NULL )
; 1458 : #endif
; 1459 :     {
; 1460 :       PA_DestroyPlayHandle( pPlayAudio );
; 1461 :       return MMSYSERR_ERROR;
; 1462 :     }
; 1463 : 
; 1464 : #endif
; 1465 : 
; 1466 :   }
; 1467 :   // tek 30sep96 move this thread creation up here (BATS 136)
; 1468 :   /********************************************************************/
; 1469 :   /*  Create the Timer Thread.                                        */
; 1470 :   /********************************************************************/
; 1471 : 
; 1472 :   pPlayAudio->hTimerThread =
; 1473 :                   OP_CreateThread( 0,
; 1474 :                                    (THREAD_PROCEDURE_T)TimerThreadMain,
; 1475 :                                    pPlayAudio );

  0052d	56		 push	 esi
  0052e	68 00 00 00 00	 push	 OFFSET FLAT:_TimerThreadMain
  00533	57		 push	 edi
  00534	e8 00 00 00 00	 call	 _OP_CreateThread
  00539	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1476 : 
; 1477 :   if ( pPlayAudio->hTimerThread == NULL )

  0053c	3b c7		 cmp	 eax, edi
  0053e	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00541	75 16		 jne	 SHORT $L71092

; 1478 :   {
; 1479 :     PA_DestroyPlayHandle( pPlayAudio );

  00543	56		 push	 esi
  00544	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00549	83 c4 04	 add	 esp, 4

; 1480 :     return MMSYSERR_ERROR;

  0054c	b8 01 00 00 00	 mov	 eax, 1
  00551	5f		 pop	 edi
  00552	5e		 pop	 esi
  00553	5d		 pop	 ebp
  00554	5b		 pop	 ebx

; 1581 : }

  00555	83 c4 18	 add	 esp, 24			; 00000018H
  00558	c3		 ret	 0
$L71092:

; 1481 :   }
; 1482 : 
; 1483 :   /********************************************************************/
; 1484 :   /*  Selected a device ID into the "play audio" handle.              */
; 1485 :   /********************************************************************/
; 1486 : 
; 1487 :   if ( uiWaveOutDeviceID == (unsigned int)WAVE_MAPPER )

  00559	8b 44 24 30	 mov	 eax, DWORD PTR _uiWaveOutDeviceID$[esp+36]
  0055d	83 f8 ff	 cmp	 eax, -1
  00560	75 2e		 jne	 SHORT $L71095

; 1488 :   {
; 1489 : #ifdef AUD_DEBUG
; 1490 : 	OutputDebugString("PA_: device is WAVE_MAPPER\n");
; 1491 : #endif
; 1492 :     mmStatus = DetermineDeviceID( pPlayAudio,
; 1493 :                                   uiNumberOfWaveOutDevices,
; 1494 :                                   pPlayAudio->pWaveFormat );

  00562	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  00568	8b 4c 24 10	 mov	 ecx, DWORD PTR _uiNumberOfWaveOutDevices$[esp+40]
  0056c	50		 push	 eax
  0056d	51		 push	 ecx
  0056e	56		 push	 esi
  0056f	e8 00 00 00 00	 call	 _DetermineDeviceID
  00574	8b e8		 mov	 ebp, eax
  00576	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1495 :     if ( mmStatus )

  00579	3b ef		 cmp	 ebp, edi
  0057b	74 45		 je	 SHORT $L71098

; 1496 :     {
; 1497 : #ifdef AUD_DEBUG
; 1498 : 	  OutputDebugString("PA_: DetermineDeviceID failed\n");
; 1499 : #endif
; 1500 :       PA_DestroyPlayHandle( pPlayAudio );

  0057d	56		 push	 esi
  0057e	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00583	83 c4 04	 add	 esp, 4

; 1501 :       return mmStatus;

  00586	8b c5		 mov	 eax, ebp
  00588	5f		 pop	 edi
  00589	5e		 pop	 esi
  0058a	5d		 pop	 ebp
  0058b	5b		 pop	 ebx

; 1581 : }

  0058c	83 c4 18	 add	 esp, 24			; 00000018H
  0058f	c3		 ret	 0
$L71095:

; 1502 :     }
; 1503 :   }
; 1504 :   else
; 1505 :   {
; 1506 : #ifdef AUD_DEBUG
; 1507 :     {
; 1508 :       char  szTemp[256]="";
; 1509 :       sprintf(szTemp,"PA_: device is not WAVE_MAPPER, it is: %i\n"
; 1510 : 	      ,uiWaveOutDeviceID);
; 1511 :       OutputDebugString(szTemp);
; 1512 :     }
; 1513 : #endif
; 1514 :     pPlayAudio->uiSelectedDeviceID = uiWaveOutDeviceID;
; 1515 : 
; 1516 :     mmStatus = PA_SetFormat( pPlayAudio, pPlayAudio->pWaveFormat );

  00590	8b 96 a0 00 00
	00		 mov	 edx, DWORD PTR [esi+160]
  00596	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00599	52		 push	 edx
  0059a	56		 push	 esi
  0059b	e8 00 00 00 00	 call	 _PA_SetFormat
  005a0	83 c4 08	 add	 esp, 8

; 1517 : 
; 1518 :     if (( mmStatus != MMSYSERR_NOERROR )
; 1519 :       && ( mmStatus != MMSYSERR_ALLOCATED ))

  005a3	3b c7		 cmp	 eax, edi
  005a5	74 1b		 je	 SHORT $L71098
  005a7	83 f8 04	 cmp	 eax, 4
  005aa	74 16		 je	 SHORT $L71098

; 1520 :     {
; 1521 : #ifdef AUD_DEBUG
; 1522 : 	  OutputDebugString("PA_: PA_SetFormat failed\n");
; 1523 : #endif
; 1524 :       PA_DestroyPlayHandle( pPlayAudio );

  005ac	56		 push	 esi
  005ad	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  005b2	83 c4 04	 add	 esp, 4

; 1525 :       return MMSYSERR_NOTSUPPORTED;

  005b5	b8 08 00 00 00	 mov	 eax, 8
  005ba	5f		 pop	 edi
  005bb	5e		 pop	 esi
  005bc	5d		 pop	 ebp
  005bd	5b		 pop	 ebx

; 1581 : }

  005be	83 c4 18	 add	 esp, 24			; 00000018H
  005c1	c3		 ret	 0
$L71098:

; 1526 :     }
; 1527 :   }
; 1528 : 
; 1529 :   /********************************************************************/
; 1530 :   /*  Set the dwDeviceSupport member of the play audio handle         */
; 1531 :   /*  pointed to by "pPlayAudio" to the dwSupport field of the        */
; 1532 :   /*  WAVEOUTCAPS structure. The device ID is specified by the        */
; 1533 :   /*  uiSelectedDeviceID field of the play audio handle.              */
; 1534 :   /********************************************************************/
; 1535 : 
; 1536 :   if ( pPlayAudio->uiSelectedDeviceID != (unsigned int)WAVE_MAPPER )

  005c2	83 7e 20 ff	 cmp	 DWORD PTR [esi+32], -1
  005c6	74 22		 je	 SHORT $L71102

; 1537 :   {
; 1538 :     mmStatus = GetWaveOutDeviceCaps( pPlayAudio );

  005c8	56		 push	 esi
  005c9	e8 00 00 00 00	 call	 _GetWaveOutDeviceCaps
  005ce	8b e8		 mov	 ebp, eax
  005d0	83 c4 04	 add	 esp, 4

; 1539 : 
; 1540 :     if ( mmStatus )

  005d3	3b ef		 cmp	 ebp, edi
  005d5	74 13		 je	 SHORT $L71102

; 1541 :     {
; 1542 : #ifdef AUD_DEBUG
; 1543 : 	  OutputDebugString("PA_: GetWaveOutDeviceCaps failed\n");
; 1544 : #endif
; 1545 :       PA_DestroyPlayHandle( pPlayAudio );

  005d7	56		 push	 esi
  005d8	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  005dd	83 c4 04	 add	 esp, 4

; 1546 :       return mmStatus;

  005e0	8b c5		 mov	 eax, ebp
  005e2	5f		 pop	 edi
  005e3	5e		 pop	 esi
  005e4	5d		 pop	 ebp
  005e5	5b		 pop	 ebx

; 1581 : }

  005e6	83 c4 18	 add	 esp, 24			; 00000018H
  005e9	c3		 ret	 0
$L71102:

; 1547 :     }
; 1548 :   }
; 1549 : 
; 1550 :   /********************************************************************/
; 1551 :   /*  If the application will own the audio device then try to open   */
; 1552 :   /*  it now.                                                         */
; 1553 :   /********************************************************************/
; 1554 : 
; 1555 :   if ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )

  005ea	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  005ee	74 26		 je	 SHORT $L71104

; 1556 :   {
; 1557 :     if ( SendPlayAudioMessage( pPlayAudio,
; 1558 :                                ID_Open_Wave_Output_Device,
; 1559 :                                0L ) == MMSYSERR_NOTSUPPORTED )

  005f0	57		 push	 edi
  005f1	57		 push	 edi
  005f2	56		 push	 esi
  005f3	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  005f8	83 c4 0c	 add	 esp, 12			; 0000000cH
  005fb	83 f8 08	 cmp	 eax, 8
  005fe	75 16		 jne	 SHORT $L71104

; 1560 :     {
; 1561 : #ifdef AUD_DEBUG
; 1562 : 	  OutputDebugString("PA_: SendPlayAudioMessage failed\n");
; 1563 : #endif
; 1564 : 	  PA_DestroyPlayHandle( pPlayAudio );

  00600	56		 push	 esi
  00601	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00606	83 c4 04	 add	 esp, 4

; 1565 :       return MMSYSERR_NOTSUPPORTED;

  00609	b8 08 00 00 00	 mov	 eax, 8
  0060e	5f		 pop	 edi
  0060f	5e		 pop	 esi
  00610	5d		 pop	 ebp
  00611	5b		 pop	 ebx

; 1581 : }

  00612	83 c4 18	 add	 esp, 24			; 00000018H
  00615	c3		 ret	 0
$L71104:

; 1566 :     }
; 1567 :   }
; 1568 : 
; 1569 :   /********************************************************************/
; 1570 :   /*  Pass the play audio handle back to the application.             */
; 1571 :   /********************************************************************/
; 1572 : 
; 1573 :   pPlayAudio->bHandleValid = TRUE;
; 1574 : 
; 1575 :   *ppPlayAudio = pPlayAudio;

  00616	8b 44 24 2c	 mov	 eax, DWORD PTR _ppPlayAudio$[esp+36]
  0061a	c7 46 68 01 00
	00 00		 mov	 DWORD PTR [esi+104], 1
  00621	5f		 pop	 edi
  00622	89 30		 mov	 DWORD PTR [eax], esi
  00624	5e		 pop	 esi
  00625	5d		 pop	 ebp

; 1576 : 
; 1577 : #ifdef AUD_DEBUG
; 1578 :   OutputDebugString("PA_: Successful exit.\n");
; 1579 : #endif
; 1580 :   return MMSYSERR_NOERROR;

  00626	33 c0		 xor	 eax, eax
  00628	5b		 pop	 ebx

; 1581 : }

  00629	83 c4 18	 add	 esp, 24			; 00000018H
  0062c	c3		 ret	 0
_PA_CreatePlayHandleEx ENDP
_TEXT	ENDS
PUBLIC	_PA_DestroyPlayHandleEx
_TEXT	SEGMENT
_pPlayAudio$ = 8
_PA_DestroyPlayHandle PROC NEAR

; 1617 : {

  00630	56		 push	 esi

; 1618 : 
; 1619 : 	MMRESULT mmResult=MMSYSERR_ERROR; // the default error
; 1620 : 	BOOL bGotLock=FALSE;	// whether we got the lock
; 1621 : 
; 1622 : 	// try to gain control of the resources
; 1623 : 	bGotLock = ThreadLock(&tlPlayAudio,5);

  00631	6a 05		 push	 5
  00633	68 00 00 00 00	 push	 OFFSET FLAT:_tlPlayAudio
  00638	be 01 00 00 00	 mov	 esi, 1
  0063d	e8 00 00 00 00	 call	 _ThreadLock
  00642	83 c4 08	 add	 esp, 8

; 1624 : 	if (bGotLock)

  00645	85 c0		 test	 eax, eax
  00647	74 19		 je	 SHORT $L72104

; 1625 : 	{	// do the actual call..
; 1626 : 		mmResult = PA_DestroyPlayHandleEx( pPlayAudio );

  00649	8b 44 24 08	 mov	 eax, DWORD PTR _pPlayAudio$[esp]
  0064d	50		 push	 eax
  0064e	e8 00 00 00 00	 call	 _PA_DestroyPlayHandleEx

; 1627 : 		// unlock the resources
; 1628 : 		ThreadUnlock(&tlPlayAudio);

  00653	68 00 00 00 00	 push	 OFFSET FLAT:_tlPlayAudio
  00658	8b f0		 mov	 esi, eax
  0065a	e8 00 00 00 00	 call	 _ThreadUnlock
  0065f	83 c4 08	 add	 esp, 8
$L72104:

; 1629 : 	}
; 1630 : 	// return our result
; 1631 : 	return (mmResult);

  00662	8b c6		 mov	 eax, esi
  00664	5e		 pop	 esi

; 1632 : }

  00665	c3		 ret	 0
_PA_DestroyPlayHandle ENDP
_TEXT	ENDS
PUBLIC	_PA_Reset
EXTRN	__imp__free:NEAR
EXTRN	__imp__waveOutClose@4:NEAR
EXTRN	_OP_WaitForThreadTermination:NEAR
EXTRN	_OP_DestroyMutex:NEAR
EXTRN	_OP_LockMutex:NEAR
EXTRN	_OP_UnlockMutex:NEAR
EXTRN	_OP_DestroyEvent:NEAR
EXTRN	_OP_SetEvent:NEAR
EXTRN	_OP_ResetEvent:NEAR
EXTRN	_OP_WaitForEvent:NEAR
EXTRN	_freeLock:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_ThreadStatus$ = -4
_PA_DestroyPlayHandleEx PROC NEAR

; 1636 : {

  00670	51		 push	 ecx

; 1637 :   unsigned int uiI;
; 1638 :   MMRESULT mmStatus;
; 1639 :   THREAD_STATUS_T ThreadStatus;
; 1640 :   LPPLAY_RING_T pPlayAudioRing;
; 1641 :   
; 1642 :   /********************************************************************/
; 1643 :   /*  Decrement the play audio instance count.                        */
; 1644 :   /********************************************************************/
; 1645 :   
; 1646 :   pShm_t->uiGlobalPlayAudioInstance--;

  00671	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  00676	55		 push	 ebp
  00677	56		 push	 esi

; 1647 :   
; 1648 :   /********************************************************************/
; 1649 :   /*  Destroy the play audio handle.                                  */
; 1650 :   /********************************************************************/
; 1651 :   
; 1652 :   if ( pPlayAudio != NULL )

  00678	8b 74 24 10	 mov	 esi, DWORD PTR _pPlayAudio$[esp+8]
  0067c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0067e	33 ed		 xor	 ebp, ebp
  00680	49		 dec	 ecx
  00681	3b f5		 cmp	 esi, ebp
  00683	89 08		 mov	 DWORD PTR [eax], ecx
  00685	0f 84 0f 02 00
	00		 je	 $L71122

; 1653 :     {
; 1654 :       /******************************************************************/
; 1655 :       /*  If the audio system is playing then a reset is necessary      */
; 1656 :       /*  before shutting down.                                         */
; 1657 :       /******************************************************************/
; 1658 :       
; 1659 :       if ( pPlayAudio->bHandleValid )

  0068b	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  0068e	53		 push	 ebx
  0068f	3b c5		 cmp	 eax, ebp
  00691	bb 01 00 00 00	 mov	 ebx, 1
  00696	74 3a		 je	 SHORT $L71124

; 1660 : 	{
; 1661 : 	  PA_Reset( pPlayAudio );

  00698	56		 push	 esi
  00699	e8 00 00 00 00	 call	 _PA_Reset

; 1662 : 	  
; 1663 : 	  /****************************************************************/
; 1664 : 	  /*  The audio system has already been reset so we can close the */
; 1665 : 	  /*  wave output device here.                                    */
; 1666 : 	  /****************************************************************/
; 1667 : 	  
; 1668 : 	  pPlayAudio->bReportPlayStop = FALSE;
; 1669 : 	  
; 1670 : 	  OP_ResetEvent( pPlayAudio->hevAudioDeviceInactive );

  0069e	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  006a1	89 6e 64	 mov	 DWORD PTR [esi+100], ebp
  006a4	50		 push	 eax
  006a5	e8 00 00 00 00	 call	 _OP_ResetEvent

; 1671 : 	  
; 1672 : 	  if ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )

  006aa	8a 46 3c	 mov	 al, BYTE PTR [esi+60]
  006ad	83 c4 08	 add	 esp, 8
  006b0	84 c3		 test	 al, bl
  006b2	74 1e		 je	 SHORT $L71124

; 1673 : 	    {
; 1674 : 	      LOCK_MME_CALL( waveOutClose( pPlayAudio->hWaveOut ))

  006b4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  006b7	51		 push	 ecx
  006b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutClose@4

; 1675 : 		  pPlayAudio->bResetPaused = FALSE;
; 1676 : 		OP_WaitForEvent( pPlayAudio->hevAudioDeviceInactive,
; 1677 : 				 MAXIMUM_CLOSE_WAIT_IN_MSEC );

  006be	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  006c1	68 88 13 00 00	 push	 5000			; 00001388H
  006c6	52		 push	 edx
  006c7	89 6e 5c	 mov	 DWORD PTR [esi+92], ebp
  006ca	e8 00 00 00 00	 call	 _OP_WaitForEvent
  006cf	83 c4 08	 add	 esp, 8
$L71124:

; 1678 : 	    }
; 1679 : 	}
; 1680 :       
; 1681 :       /******************************************************************/
; 1682 :       /*  Cause the timer thread to exit.                               */
; 1683 :       /*  The only place in the code where the hevTimerThreadActive     */
; 1684 :       /*  event is reset is locked by the synchronization mark mutex so */
; 1685 :       /*  we use that also to lock the thread exit flag. Since this is  */
; 1686 :       /*  only used for shutdown, it seemed unnecessary to create       */
; 1687 :       /*  an additional mutex.                                          */
; 1688 :       /******************************************************************/
; 1689 :       
; 1690 :       if ( pPlayAudio->hTimerThread != NULL )

  006d2	39 6e 0c	 cmp	 DWORD PTR [esi+12], ebp
  006d5	74 3f		 je	 SHORT $L71126

; 1691 : 	{
; 1692 : 	  OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  006d7	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  006dd	50		 push	 eax
  006de	e8 00 00 00 00	 call	 _OP_LockMutex

; 1693 : 	  pPlayAudio->bTimerExit = TRUE;
; 1694 : 	  OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  006e3	8b 8e 8c 00 00
	00		 mov	 ecx, DWORD PTR [esi+140]
  006e9	89 5e 54	 mov	 DWORD PTR [esi+84], ebx
  006ec	51		 push	 ecx
  006ed	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 1695 : 	  
; 1696 : 	  if ( pPlayAudio->hevTimerThreadActive != NULL )

  006f2	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  006f5	83 c4 08	 add	 esp, 8
  006f8	3b c5		 cmp	 eax, ebp
  006fa	74 09		 je	 SHORT $L71128

; 1697 : 	    {
; 1698 : 	      OP_SetEvent( pPlayAudio->hevTimerThreadActive );

  006fc	50		 push	 eax
  006fd	e8 00 00 00 00	 call	 _OP_SetEvent
  00702	83 c4 04	 add	 esp, 4
$L71128:

; 1699 : 	    }
; 1700 : 	  /* TQL 05/21/1997  change this for OSF build */  
; 1701 : 	  OP_WaitForThreadTermination( pPlayAudio->hTimerThread,
; 1702 : #if defined WIN32 && !defined NOWIN  
; 1703 : 				       &ThreadStatus
; 1704 : #endif
; 1705 : #if defined __osf__ || defined __linux__ || defined VXWORKS || defined _SPARC_SOLARIS_  || defined NOWIN
; 1706 : 	                               &ThreadStatus, OP_INFINITE
; 1707 : #endif
; 1708 : 				       );

  00705	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00708	8d 54 24 0c	 lea	 edx, DWORD PTR _ThreadStatus$[esp+16]
  0070c	52		 push	 edx
  0070d	50		 push	 eax
  0070e	e8 00 00 00 00	 call	 _OP_WaitForThreadTermination
  00713	83 c4 08	 add	 esp, 8
$L71126:

; 1709 :         }
; 1710 :       
; 1711 : #ifdef OS_SIXTY_FOUR_BIT
; 1712 :       
; 1713 :       /******************************************************************/
; 1714 :       /*  Set the instance location in the global audio handle array    */
; 1715 :       /*  to NULL.                                                      */
; 1716 :       /******************************************************************/
; 1717 :       
; 1718 :       uiI = pPlayAudio->uiHandleListIndex;
; 1719 :       
; 1720 :       if ( uiI != (unsigned int)(-1))
; 1721 : 	{
; 1722 : 	  pShm_t->ppGlobalHandleList[uiI] = pPlayAudio;
; 1723 : 	}
; 1724 :       
; 1725 : #endif
; 1726 :       
; 1727 :       /******************************************************************/
; 1728 :       /*  If there are no more "play audio" instances then destroy the  */
; 1729 :       /*  "play audio" thread and the message queue.                    */
; 1730 :       /******************************************************************/
; 1731 :       
; 1732 :       if ( pShm_t->uiGlobalPlayAudioInstance == 0 )

  00716	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  0071b	39 28		 cmp	 DWORD PTR [eax], ebp
  0071d	75 7c		 jne	 SHORT $L71137

; 1733 : 	{
; 1734 : 	  
; 1735 : #ifdef USE_MME_SERVER
; 1736 : 	  
; 1737 : 	  /****************************************************************/
; 1738 : 	  /*  Destroy the MME callback thread.                            */
; 1739 : 	  /****************************************************************/
; 1740 : 	  
; 1741 : 	  if ( pShm_t->hGlobalMmeCallbackThread != NULL )
; 1742 : 	    {
; 1743 : 	      pShm_t->bGlobalMmeCallbackExit = TRUE;
; 1744 : 	      
; 1745 : 	      OP_WaitForThreadTermination( pShm_t->hGlobalMmeCallbackThread,
; 1746 : 					   /* TQL 05/21/1997  change this for OSF build */
; 1747 : #ifdef WIN32
; 1748 : 					   &ThreadStatus
; 1749 : #endif
; 1750 : #ifdef __osf__
; 1751 : 					   &ThreadStatus, OP_INFINITE
; 1752 : #endif
; 1753 : 					   );
; 1754 : 	      pShm_t->hGlobalMmeCallbackThread = NULL;
; 1755 : 	    }
; 1756 : 	  
; 1757 : #endif
; 1758 : 	  
; 1759 : 	  /****************************************************************/
; 1760 : 	  /*  Destroy the play audio thread.                              */
; 1761 : 	  /****************************************************************/
; 1762 : 	  
; 1763 : 	  if ( pShm_t->hGlobalPlayAudioThread != NULL ) {

  0071f	39 68 08	 cmp	 DWORD PTR [eax+8], ebp
  00722	74 2e		 je	 SHORT $L71131

; 1764 : 	    SendPlayAudioMessage( pPlayAudio, ID_Destroy_Message, 0 );

  00724	55		 push	 ebp
  00725	6a 0a		 push	 10			; 0000000aH
  00727	56		 push	 esi
  00728	e8 00 00 00 00	 call	 _SendPlayAudioMessage

; 1765 : 	    
; 1766 : 	    OP_WaitForThreadTermination( pShm_t->hGlobalPlayAudioThread,
; 1767 : #if defined WIN32 && !defined NOWIN 
; 1768 : 					 &ThreadStatus
; 1769 : #endif
; 1770 : #if defined __osf__ || defined __linux__ || defined VXWORKS || defined _SPARC_SOLARIS_ || defined NOWIN
; 1771 : 					 &ThreadStatus, OP_INFINITE
; 1772 : #endif
; 1773 : 					 );

  0072d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  00733	8d 4c 24 18	 lea	 ecx, DWORD PTR _ThreadStatus$[esp+28]
  00737	51		 push	 ecx
  00738	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0073b	50		 push	 eax
  0073c	e8 00 00 00 00	 call	 _OP_WaitForThreadTermination

; 1774 : 	    pShm_t->hGlobalPlayAudioThread = NULL;

  00741	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t
  00747	83 c4 14	 add	 esp, 20			; 00000014H
  0074a	89 69 08	 mov	 DWORD PTR [ecx+8], ebp
  0074d	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
$L71131:

; 1775 : 	  }
; 1776 : 	  
; 1777 : 	  /****************************************************************/
; 1778 : 	  /*  Destroy the "Play Audio" message queue.                     */
; 1779 : 	  /****************************************************************/
; 1780 : 	  
; 1781 : 	  if ( pShm_t->pGlobalPlayAudioMessageQueue != NULL )

  00752	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00755	3b cd		 cmp	 ecx, ebp
  00757	74 17		 je	 SHORT $L71134

; 1782 : 	    {
; 1783 : 	      DestroyMessageQueue( pShm_t->pGlobalPlayAudioMessageQueue );

  00759	51		 push	 ecx
  0075a	e8 00 00 00 00	 call	 _DestroyMessageQueue

; 1784 : 	      pShm_t->pGlobalPlayAudioMessageQueue = NULL;

  0075f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  00765	83 c4 04	 add	 esp, 4
  00768	89 6a 14	 mov	 DWORD PTR [edx+20], ebp
  0076b	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
$L71134:

; 1785 : 	    }
; 1786 : 	  
; 1787 : 	  /****************************************************************/
; 1788 : 	  /*  Destroy the "Send Play Audio" mutex.                        */
; 1789 : 	  /****************************************************************/
; 1790 : 	  
; 1791 : 	  OP_DestroyMutex( pShm_t->hmxGlobalSendPlayAudio );

  00770	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00773	50		 push	 eax
  00774	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1792 : 	  
; 1793 : 	  /****************************************************************/
; 1794 : 	  /*  Destroy the "Report" message queue.                         */
; 1795 : 	  /****************************************************************/
; 1796 : 	  
; 1797 : 	  if ( pShm_t->pGlobalReportMessageQueue != NULL )

  00779	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t
  0077f	83 c4 04	 add	 esp, 4
  00782	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00785	3b c5		 cmp	 eax, ebp
  00787	74 12		 je	 SHORT $L71137

; 1798 : 	    {
; 1799 : 	      DestroyMessageQueue( pShm_t->pGlobalReportMessageQueue );

  00789	50		 push	 eax
  0078a	e8 00 00 00 00	 call	 _DestroyMessageQueue

; 1800 : 	      pShm_t->pGlobalReportMessageQueue = NULL;

  0078f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  00795	83 c4 04	 add	 esp, 4
  00798	89 6a 10	 mov	 DWORD PTR [edx+16], ebp
$L71137:

; 1801 : 	    }
; 1802 : 	  
; 1803 : #ifdef OS_SIXTY_FOUR_BIT
; 1804 : 	  
; 1805 : 	  /****************************************************************/
; 1806 : 	  /*  Free the global "play audio" handle list.                   */
; 1807 : 	  /****************************************************************/
; 1808 : 	  
; 1809 : 	  if ( pShm_t->ppGlobalHandleList != NULL )
; 1810 : 	    {
; 1811 : 	      free( pShm_t->ppGlobalHandleList );
; 1812 : 	      pShm_t->ppGlobalHandleList = NULL;
; 1813 : 	    }
; 1814 : 	  
; 1815 : 	  pShm_t->uiGlobalHandleListLength = 0;
; 1816 : 	  
; 1817 : 	  /****************************************************************/
; 1818 : 	  /*  Destroy the "Handle List" mutex.                            */
; 1819 : 	  /****************************************************************/
; 1820 : 	  
; 1821 : 	  OP_DestroyMutex( pShm_t->hmxGlobalHandleList );
; 1822 : 	  
; 1823 : #endif
; 1824 : 	  
; 1825 : 	}
; 1826 :       
; 1827 :       /******************************************************************/
; 1828 :       /*  Free the Audio Queue memory.                                  */
; 1829 :       /******************************************************************/
; 1830 :       
; 1831 :       pPlayAudioRing = pPlayAudio->pPlayAudioRing;
; 1832 :       
; 1833 :       if ( pPlayAudioRing != NULL )

  0079b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__free
  007a1	57		 push	 edi
  007a2	8b be 98 00 00
	00		 mov	 edi, DWORD PTR [esi+152]
  007a8	3b fd		 cmp	 edi, ebp
  007aa	74 15		 je	 SHORT $L71140

; 1834 : 	{
; 1835 : 	  /****************************************************************/
; 1836 : 	  /*  Free Memory for the Audio Queue sample buffer.              */
; 1837 : 	  /****************************************************************/
; 1838 : 	  
; 1839 : 	  if ( pPlayAudioRing->pQueueTop != NULL )

  007ac	8b 07		 mov	 eax, DWORD PTR [edi]
  007ae	3b c5		 cmp	 eax, ebp
  007b0	74 09		 je	 SHORT $L71142

; 1840 : 	    {
; 1841 : 	      LOCK_MME_CALL( FREE_SERVER_BUFFER( pPlayAudioRing->pQueueTop ))

  007b2	50		 push	 eax
  007b3	e8 00 00 00 00	 call	 _freeLock
  007b8	83 c4 04	 add	 esp, 4
$L71142:

; 1842 : 		}
; 1843 : 	  
; 1844 : 	  /****************************************************************/
; 1845 : 	  /*  Free Memory for the Audio Queue Structure.                  */
; 1846 : 	  /****************************************************************/
; 1847 : 	  
; 1848 : 	  free( pPlayAudioRing );

  007bb	57		 push	 edi
  007bc	ff d3		 call	 ebx
  007be	83 c4 04	 add	 esp, 4
$L71140:

; 1849 : 	}
; 1850 :       
; 1851 :       /******************************************************************/
; 1852 :       /*  Free Memory for Wave Headers.                                 */
; 1853 :       /******************************************************************/
; 1854 :       
; 1855 :       if ( pPlayAudio->ppWaveHdr != NULL )

  007c1	39 ae 94 00 00
	00		 cmp	 DWORD PTR [esi+148], ebp
  007c7	74 2c		 je	 SHORT $L71144

; 1856 : 	{
; 1857 : 	  for ( uiI = 0; uiI < MAXIMUM_BUFFERS_QUEUED; uiI++ )

  007c9	33 ff		 xor	 edi, edi
$L71145:

; 1858 : 	    {
; 1859 : 	      if ( pPlayAudio->ppWaveHdr[uiI] != NULL )

  007cb	8b 86 94 00 00
	00		 mov	 eax, DWORD PTR [esi+148]
  007d1	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  007d4	3b c5		 cmp	 eax, ebp
  007d6	74 09		 je	 SHORT $L71146

; 1860 : 		{
; 1861 : 		  LOCK_MME_CALL( FREE_LOCKED_MEMORY( pPlayAudio->ppWaveHdr[uiI] ))

  007d8	50		 push	 eax
  007d9	e8 00 00 00 00	 call	 _freeLock
  007de	83 c4 04	 add	 esp, 4
$L71146:
  007e1	83 c7 04	 add	 edi, 4
  007e4	83 ff 20	 cmp	 edi, 32			; 00000020H
  007e7	7c e2		 jl	 SHORT $L71145

; 1862 : 		    }
; 1863 : 	    }
; 1864 : 	  
; 1865 : 	  /****************************************************************/
; 1866 : 	  /*  Free the Wave Header pointer array memory.                  */
; 1867 : 	  /****************************************************************/
; 1868 : 	  
; 1869 : 	  free( pPlayAudio->ppWaveHdr );

  007e9	8b 8e 94 00 00
	00		 mov	 ecx, DWORD PTR [esi+148]
  007ef	51		 push	 ecx
  007f0	ff d3		 call	 ebx
  007f2	83 c4 04	 add	 esp, 4
$L71144:

; 1870 : 	}
; 1871 :       
; 1872 :       /******************************************************************/
; 1873 :       /*  Destroy the "WaveFormat" mutex.                               */
; 1874 :       /******************************************************************/
; 1875 :       
; 1876 :       OP_DestroyMutex( pPlayAudio->hmxWaveFormat );

  007f5	8b 96 90 00 00
	00		 mov	 edx, DWORD PTR [esi+144]
  007fb	52		 push	 edx
  007fc	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1877 :       
; 1878 :       /******************************************************************/
; 1879 :       /*  Destroy the "Synchronization Mark List" mutex.                */
; 1880 :       /******************************************************************/
; 1881 :       
; 1882 :       OP_DestroyMutex( pPlayAudio->hmxSynchronizationMarkList );

  00801	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  00807	50		 push	 eax
  00808	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1883 :       
; 1884 :       /******************************************************************/
; 1885 :       /*  Destroy the ""Pause Flag" mutex.                              */
; 1886 :       /******************************************************************/
; 1887 :       
; 1888 :       OP_DestroyMutex( pPlayAudio->hmxPauseFlag );

  0080d	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  00813	51		 push	 ecx
  00814	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1889 :       
; 1890 :       /******************************************************************/
; 1891 :       /*  Destroy the "Queued Byte Count" mutex.                        */
; 1892 :       /******************************************************************/
; 1893 :       
; 1894 :       OP_DestroyMutex( pPlayAudio->hmxQueuedByteCount );

  00819	8b 96 84 00 00
	00		 mov	 edx, DWORD PTR [esi+132]
  0081f	52		 push	 edx
  00820	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1895 :       
; 1896 :       /******************************************************************/
; 1897 :       /*  Destroy the "Queue Audio Busy" mutex.                         */
; 1898 :       /******************************************************************/
; 1899 :       
; 1900 :       OP_DestroyMutex( pPlayAudio->hmxQueueAudioBusy );

  00825	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  0082b	50		 push	 eax
  0082c	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1901 :       
; 1902 :       /******************************************************************/
; 1903 :       /*  Destroy the "Queue Count" mutex.                              */
; 1904 :       /******************************************************************/
; 1905 : 
; 1906 :     OP_DestroyMutex( pPlayAudio->hmxQueueCount );

  00831	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  00834	51		 push	 ecx
  00835	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1907 : 
; 1908 :     /******************************************************************/
; 1909 :     /*  Destroy the "Selected Device ID" mutex.                       */
; 1910 :     /******************************************************************/
; 1911 : 
; 1912 :     OP_DestroyMutex( pPlayAudio->hmxSelectedDeviceID );

  0083a	8b 56 78	 mov	 edx, DWORD PTR [esi+120]
  0083d	52		 push	 edx
  0083e	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1913 : 
; 1914 :     /******************************************************************/
; 1915 :     /*  Destroy the "Bytes Played" mutex.                             */
; 1916 :     /******************************************************************/
; 1917 : 
; 1918 :     OP_DestroyMutex( pPlayAudio->hmxBytesPlayed );

  00843	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00846	50		 push	 eax
  00847	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1919 : 
; 1920 :     /******************************************************************/
; 1921 :     /*  Destroy the "Audio Device State" mutex.                       */
; 1922 :     /******************************************************************/
; 1923 : 
; 1924 :     OP_DestroyMutex( pPlayAudio->hmxAudioDeviceState );

  0084c	8b 4e 70	 mov	 ecx, DWORD PTR [esi+112]
  0084f	51		 push	 ecx
  00850	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1925 : 
; 1926 :     /******************************************************************/
; 1927 :     /*  Destroy the "Reset Complete" event.                           */
; 1928 :     /******************************************************************/
; 1929 : 
; 1930 :     OP_DestroyEvent( pPlayAudio->hevResetComplete );

  00855	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00858	52		 push	 edx
  00859	e8 00 00 00 00	 call	 _OP_DestroyEvent

; 1931 : 
; 1932 :     /******************************************************************/
; 1933 :     /*  Destroy the "Queue Not Full" event.                           */
; 1934 :     /******************************************************************/
; 1935 : 
; 1936 :     OP_DestroyEvent( pPlayAudio->hevQueueNotFull );

  0085e	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00861	50		 push	 eax
  00862	e8 00 00 00 00	 call	 _OP_DestroyEvent

; 1937 : 
; 1938 :     /******************************************************************/
; 1939 :     /*  Destroy the "Timer Thread Active" event.                      */
; 1940 :     /******************************************************************/
; 1941 : 
; 1942 :     OP_DestroyEvent( pPlayAudio->hevTimerThreadActive );

  00867	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0086a	51		 push	 ecx
  0086b	e8 00 00 00 00	 call	 _OP_DestroyEvent

; 1943 : 
; 1944 :     /******************************************************************/
; 1945 :     /*  Destroy the "Audio Device Inactive" event.                    */
; 1946 :     /******************************************************************/
; 1947 : 
; 1948 :     OP_DestroyEvent( pPlayAudio->hevAudioDeviceInactive );

  00870	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00873	52		 push	 edx
  00874	e8 00 00 00 00	 call	 _OP_DestroyEvent

; 1949 : 
; 1950 :     /******************************************************************/
; 1951 :     /*  Free the play audio handle WAVEFORMATEX structure.            */
; 1952 :     /******************************************************************/
; 1953 : 
; 1954 :     if ( pPlayAudio->pWaveFormat != NULL )

  00879	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  0087f	83 c4 34	 add	 esp, 52			; 00000034H
  00882	3b c5		 cmp	 eax, ebp
  00884	5f		 pop	 edi
  00885	74 06		 je	 SHORT $L71151

; 1955 :     {
; 1956 :       LOCK_MME_CALL( FREE_SERVER_MEM( pPlayAudio->pWaveFormat ))

  00887	50		 push	 eax
  00888	ff d3		 call	 ebx
  0088a	83 c4 04	 add	 esp, 4
$L71151:

; 1957 :     }
; 1958 : 
; 1959 :     /******************************************************************/
; 1960 :     /*  Free the play audio handle.                                   */
; 1961 :     /******************************************************************/
; 1962 : 
; 1963 :     free( pPlayAudio );

  0088d	56		 push	 esi
  0088e	ff d3		 call	 ebx
  00890	83 c4 04	 add	 esp, 4

; 1964 :     
; 1965 :     mmStatus = MMSYSERR_NOERROR;

  00893	33 c0		 xor	 eax, eax
  00895	5b		 pop	 ebx
  00896	5e		 pop	 esi
  00897	5d		 pop	 ebp

; 1970 :     }
; 1971 : 
; 1972 : #ifdef MME_THREAD_SAFE
; 1973 :   
; 1974 :   /********************************************************************/
; 1975 :   /*  If this is the last instance then destroy the global mutex that */
; 1976 :   /*  is used to protect MME server calls.                            */
; 1977 :   /********************************************************************/
; 1978 :   
; 1979 :   if ( pShm_t->uiGlobalPlayAudioInstance == 0 )
; 1980 :     {
; 1981 :       OP_DestroyMutex( pShm_t->hmxGlobalMmeServer );
; 1982 :     }
; 1983 :   
; 1984 : #endif
; 1985 : 
; 1986 :   return mmStatus;
; 1987 : }

  00898	59		 pop	 ecx
  00899	c3		 ret	 0
$L71122:
  0089a	5e		 pop	 esi

; 1966 :     }
; 1967 :   else
; 1968 :     {
; 1969 :       mmStatus = MMSYSERR_INVALHANDLE;

  0089b	b8 05 00 00 00	 mov	 eax, 5
  008a0	5d		 pop	 ebp

; 1970 :     }
; 1971 : 
; 1972 : #ifdef MME_THREAD_SAFE
; 1973 :   
; 1974 :   /********************************************************************/
; 1975 :   /*  If this is the last instance then destroy the global mutex that */
; 1976 :   /*  is used to protect MME server calls.                            */
; 1977 :   /********************************************************************/
; 1978 :   
; 1979 :   if ( pShm_t->uiGlobalPlayAudioInstance == 0 )
; 1980 :     {
; 1981 :       OP_DestroyMutex( pShm_t->hmxGlobalMmeServer );
; 1982 :     }
; 1983 :   
; 1984 : #endif
; 1985 : 
; 1986 :   return mmStatus;
; 1987 : }

  008a1	59		 pop	 ecx
  008a2	c3		 ret	 0
_PA_DestroyPlayHandleEx ENDP
_TEXT	ENDS
PUBLIC	_PA_Queue
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pBuffer$ = 12
_dwLength$ = 16
_PA_Queue PROC NEAR

; 2065 : {

  008b0	55		 push	 ebp

; 2066 :   DWORD dwWrap;
; 2067 :   DWORD dwRemaining;
; 2068 :   LPPLAY_RING_T pPlayAudioRing;
; 2069 : 
; 2070 : #ifdef __linux__
; 2071 :   struct timespec tv;
; 2072 : #endif
; 2073 : 
; 2074 : #ifdef AUD_DEBUG  // 13may97 tek 
; 2075 :   {
; 2076 : 		  char  szTemp[256]="";
; 2077 : 		  sprintf(szTemp,"PA_Queue: size=%lu at %lu\n",
; 2078 : 			  dwLength, timeGetTime());
; 2079 : 		  //OutputDebugString(szTemp); // tek 21nov97 make less verbose
; 2080 :   }
; 2081 : #endif //AUD_DEBUG
; 2082 : 
; 2083 :   /********************************************************************/
; 2084 :   /*  Return an error if NULL handle.                                 */
; 2085 :   /********************************************************************/
; 2086 : 
; 2087 :   if ( pPlayAudio == NULL )

  008b1	8b 6c 24 08	 mov	 ebp, DWORD PTR _pPlayAudio$[esp]
  008b5	85 ed		 test	 ebp, ebp
  008b7	56		 push	 esi
  008b8	75 08		 jne	 SHORT $L71164
  008ba	5e		 pop	 esi

; 2088 :     return MMSYSERR_INVALHANDLE;

  008bb	b8 05 00 00 00	 mov	 eax, 5
  008c0	5d		 pop	 ebp

; 2240 : }

  008c1	c3		 ret	 0
$L71164:

; 2089 : 
; 2090 :   /********************************************************************/
; 2091 :   /*  If too many samples then exit with error status.                */
; 2092 :   /********************************************************************/
; 2093 : 
; 2094 :   if ( dwLength > AUDIO_BUFFER_SIZE )

  008c2	8b 74 24 14	 mov	 esi, DWORD PTR _dwLength$[esp+4]
  008c6	81 fe 00 40 02
	00		 cmp	 esi, 147456		; 00024000H
  008cc	76 08		 jbe	 SHORT $L71165
  008ce	5e		 pop	 esi

; 2095 :     return MMSYSERR_INVALPARAM;

  008cf	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  008d4	5d		 pop	 ebp

; 2240 : }

  008d5	c3		 ret	 0
$L71165:

; 2096 : 
; 2097 :   pPlayAudioRing = pPlayAudio->pPlayAudioRing;
; 2098 : 
; 2099 :   /********************************************************************/
; 2100 :   /*  Block if another thread is queueing audio or performing a       */
; 2101 :   /*  reset.                                                          */
; 2102 :   /********************************************************************/
; 2103 :   OP_LockMutex( pPlayAudio->hmxQueueAudioBusy );

  008d6	8b 85 80 00 00
	00		 mov	 eax, DWORD PTR [ebp+128]
  008dc	53		 push	 ebx
  008dd	8b 9d 98 00 00
	00		 mov	 ebx, DWORD PTR [ebp+152]
  008e3	50		 push	 eax
  008e4	e8 00 00 00 00	 call	 _OP_LockMutex

; 2104 : 
; 2105 :   /********************************************************************/
; 2106 :   /*  Wait for space in the queue before adding the new audio buffer. */
; 2107 :   /*  Block if another thread is manipulating the queue count.        */
; 2108 :   /********************************************************************/
; 2109 : 
; 2110 :   OP_LockMutex( pPlayAudio->hmxQueueCount );

  008e9	8b 4d 7c	 mov	 ecx, DWORD PTR [ebp+124]
  008ec	51		 push	 ecx
  008ed	e8 00 00 00 00	 call	 _OP_LockMutex

; 2111 : 
; 2112 :   while ( pPlayAudioRing->iQueueCount + (int)dwLength
; 2113 :             > pPlayAudioRing->iQueueLength )

  008f2	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  008f5	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  008f8	03 d6		 add	 edx, esi
  008fa	83 c4 08	 add	 esp, 8
  008fd	3b d0		 cmp	 edx, eax
  008ff	7e 4d		 jle	 SHORT $L71169
$L71168:

; 2114 :   {
; 2115 :     OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  00901	8b 45 7c	 mov	 eax, DWORD PTR [ebp+124]
  00904	50		 push	 eax
  00905	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 2116 :     OP_UnlockMutex( pPlayAudio->hmxQueueAudioBusy );

  0090a	8b 8d 80 00 00
	00		 mov	 ecx, DWORD PTR [ebp+128]
  00910	51		 push	 ecx
  00911	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 2117 : 
; 2118 :     OP_ResetEvent( pPlayAudio->hevQueueNotFull );

  00916	8b 55 18	 mov	 edx, DWORD PTR [ebp+24]
  00919	52		 push	 edx
  0091a	e8 00 00 00 00	 call	 _OP_ResetEvent

; 2119 : 
; 2120 :     OP_WaitForEvent( pPlayAudio->hevQueueNotFull, OP_INFINITE );

  0091f	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  00922	6a ff		 push	 -1
  00924	50		 push	 eax
  00925	e8 00 00 00 00	 call	 _OP_WaitForEvent

; 2121 : #ifdef __linux__ 
; 2122 : //necessary for proper multithreading, this may be fixed in newer kernels
; 2123 :     tv.tv_sec=0;
; 2124 :     tv.tv_nsec=1;
; 2125 :     nanosleep(&tv,NULL);
; 2126 :     //usleep(1);
; 2127 : #endif
; 2128 :     OP_LockMutex( pPlayAudio->hmxQueueAudioBusy );

  0092a	8b 8d 80 00 00
	00		 mov	 ecx, DWORD PTR [ebp+128]
  00930	51		 push	 ecx
  00931	e8 00 00 00 00	 call	 _OP_LockMutex

; 2129 :     OP_LockMutex( pPlayAudio->hmxQueueCount );

  00936	8b 55 7c	 mov	 edx, DWORD PTR [ebp+124]
  00939	52		 push	 edx
  0093a	e8 00 00 00 00	 call	 _OP_LockMutex
  0093f	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00942	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  00945	03 c6		 add	 eax, esi
  00947	83 c4 1c	 add	 esp, 28			; 0000001cH
  0094a	3b c1		 cmp	 eax, ecx
  0094c	7f b3		 jg	 SHORT $L71168
$L71169:

; 2130 :   }
; 2131 : 
; 2132 :   OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  0094e	8b 4d 7c	 mov	 ecx, DWORD PTR [ebp+124]
  00951	57		 push	 edi
  00952	51		 push	 ecx
  00953	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 2133 : 
; 2134 :   /********************************************************************/
; 2135 :   /*  There is enough space in the audio queue. Test to see if the    */
; 2136 :   /*  data will wrap around the circular queue.                       */
; 2137 :   /********************************************************************/
; 2138 : 
; 2139 :   if ( pPlayAudioRing->iInputPosition + (int)dwLength
; 2140 :          > pPlayAudioRing->iQueueLength )

  00958	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  0095b	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  0095e	83 c4 04	 add	 esp, 4
  00961	8d 14 31	 lea	 edx, DWORD PTR [ecx+esi]
  00964	3b d0		 cmp	 edx, eax
  00966	7e 48		 jle	 SHORT $L71171

; 2141 :   {
; 2142 :     /******************************************************************/
; 2143 :     /*  The data will wrap around the circular queue.                 */
; 2144 :     /******************************************************************/
; 2145 : 
; 2146 :     dwRemaining =
; 2147 :       pPlayAudioRing->iQueueLength - pPlayAudioRing->iInputPosition;
; 2148 : 
; 2149 :     /******************************************************************/
; 2150 :     /*  for ( uiI = 0; uiI < dwRemaining; uiI++ )                     */
; 2151 :     /*    *pPlayAudioRing->pQueueInput++ = *pBuffer++;                */
; 2152 :     /******************************************************************/
; 2153 : 
; 2154 :     memcpy( pPlayAudioRing->pQueueInput, pBuffer, dwRemaining );

  00968	8b 74 24 18	 mov	 esi, DWORD PTR _pBuffer$[esp+12]
  0096c	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  0096f	2b c1		 sub	 eax, ecx
  00971	8b d0		 mov	 edx, eax
  00973	8b ca		 mov	 ecx, edx
  00975	c1 e9 02	 shr	 ecx, 2
  00978	f3 a5		 rep movsd
  0097a	8b c8		 mov	 ecx, eax

; 2155 : 
; 2156 :     pBuffer += dwRemaining;
; 2157 : 
; 2158 :     /******************************************************************/
; 2159 :     /*  Reset to the start of the audio queue.                        */
; 2160 :     /******************************************************************/
; 2161 : 
; 2162 :     pPlayAudioRing->pQueueInput = pPlayAudioRing->pQueueStart;
; 2163 : 
; 2164 :     /******************************************************************/
; 2165 :     /*  for ( uiI = dwRemaining; uiI < dwLength; uiI++ )              */
; 2166 :     /*    *pPlayAudioRing->pQueueInput++ = *pBuffer++;                */
; 2167 :     /******************************************************************/
; 2168 : 
; 2169 :     dwWrap = dwLength - dwRemaining;

  0097c	8b 44 24 1c	 mov	 eax, DWORD PTR _dwLength$[esp+12]
  00980	83 e1 03	 and	 ecx, 3
  00983	2b c2		 sub	 eax, edx
  00985	f3 a4		 rep movsb
  00987	8b 74 24 18	 mov	 esi, DWORD PTR _pBuffer$[esp+12]
  0098b	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]

; 2170 : 
; 2171 :     memcpy( pPlayAudioRing->pQueueInput, pBuffer, dwWrap );

  0098e	8b c8		 mov	 ecx, eax
  00990	03 f2		 add	 esi, edx
  00992	8b d1		 mov	 edx, ecx
  00994	89 7b 08	 mov	 DWORD PTR [ebx+8], edi
  00997	c1 e9 02	 shr	 ecx, 2
  0099a	f3 a5		 rep movsd
  0099c	8b ca		 mov	 ecx, edx
  0099e	83 e1 03	 and	 ecx, 3
  009a1	f3 a4		 rep movsb

; 2172 : 
; 2173 :     pPlayAudioRing->pQueueInput += dwWrap;

  009a3	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 2174 :     pPlayAudioRing->iInputPosition = (int)dwWrap;

  009a6	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  009a9	03 c8		 add	 ecx, eax
  009ab	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx

; 2175 :   }
; 2176 :   else

  009ae	eb 2b		 jmp	 SHORT $L71173
$L71171:

; 2177 :   {
; 2178 :     /******************************************************************/
; 2179 :     /*  The data will NOT wrap around the circular queue.             */
; 2180 :     /******************************************************************/
; 2181 :     /******************************************************************/
; 2182 :     /*  for ( uiI = 0; uiI < dwLength; uiI++ )                        */
; 2183 :     /*    *pPlayAudioRing->pQueueInput++ = *pBuffer++;                */
; 2184 :     /******************************************************************/
; 2185 : 
; 2186 :     memcpy( pPlayAudioRing->pQueueInput, pBuffer, dwLength );

  009b0	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  009b3	8b ce		 mov	 ecx, esi
  009b5	8b 74 24 18	 mov	 esi, DWORD PTR _pBuffer$[esp+12]
  009b9	8b c1		 mov	 eax, ecx
  009bb	c1 e9 02	 shr	 ecx, 2
  009be	f3 a5		 rep movsd
  009c0	8b c8		 mov	 ecx, eax

; 2187 : 
; 2188 :     pPlayAudioRing->pQueueInput += dwLength;

  009c2	8b 44 24 1c	 mov	 eax, DWORD PTR _dwLength$[esp+12]
  009c6	83 e1 03	 and	 ecx, 3
  009c9	f3 a4		 rep movsb
  009cb	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]

; 2189 :     pPlayAudioRing->iInputPosition += (int)dwLength;

  009ce	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  009d1	03 d0		 add	 edx, eax
  009d3	03 c8		 add	 ecx, eax
  009d5	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  009d8	89 4b 10	 mov	 DWORD PTR [ebx+16], ecx
$L71173:

; 2190 :   }
; 2191 : 
; 2192 :   /********************************************************************/
; 2193 :   /*  Atomically update the audio queue count.                        */
; 2194 :   /********************************************************************/
; 2195 : 
; 2196 :   OP_LockMutex( pPlayAudio->hmxQueueCount );

  009db	8b 4d 7c	 mov	 ecx, DWORD PTR [ebp+124]
  009de	51		 push	 ecx
  009df	e8 00 00 00 00	 call	 _OP_LockMutex

; 2197 :   pPlayAudioRing->iQueueCount += (int)dwLength;

  009e4	8b 74 24 20	 mov	 esi, DWORD PTR _dwLength$[esp+16]
  009e8	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  009eb	03 d6		 add	 edx, esi
  009ed	89 53 18	 mov	 DWORD PTR [ebx+24], edx

; 2198 :   OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  009f0	8b 55 7c	 mov	 edx, DWORD PTR [ebp+124]
  009f3	52		 push	 edx
  009f4	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 2199 : 
; 2200 :   /********************************************************************/
; 2201 :   /*  Atomically update the queued byte count.                        */
; 2202 :   /*  If audio is not playing then activate the timer thread.         */
; 2203 :   /********************************************************************/
; 2204 : 
; 2205 :   OP_LockMutex( pPlayAudio->hmxQueuedByteCount );

  009f9	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR [ebp+132]
  009ff	50		 push	 eax
  00a00	e8 00 00 00 00	 call	 _OP_LockMutex

; 2206 : 
; 2207 :   pPlayAudio->dwQueuedByteCount += dwLength;

  00a05	8b 4d 4c	 mov	 ecx, DWORD PTR [ebp+76]

; 2208 : 
; 2209 :   if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )

  00a08	8b 45 34	 mov	 eax, DWORD PTR [ebp+52]
  00a0b	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a0e	03 ce		 add	 ecx, esi
  00a10	85 c0		 test	 eax, eax
  00a12	89 4d 4c	 mov	 DWORD PTR [ebp+76], ecx
  00a15	5f		 pop	 edi
  00a16	75 0c		 jne	 SHORT $L71176

; 2210 :   {
; 2211 :     OP_SetEvent( pPlayAudio->hevTimerThreadActive );

  00a18	8b 4d 14	 mov	 ecx, DWORD PTR [ebp+20]
  00a1b	51		 push	 ecx
  00a1c	e8 00 00 00 00	 call	 _OP_SetEvent
  00a21	83 c4 04	 add	 esp, 4
$L71176:

; 2212 :   }
; 2213 : 
; 2214 :   OP_UnlockMutex( pPlayAudio->hmxQueuedByteCount );

  00a24	8b 95 84 00 00
	00		 mov	 edx, DWORD PTR [ebp+132]
  00a2a	52		 push	 edx
  00a2b	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 2215 : 
; 2216 :   /********************************************************************/
; 2217 :   /*  If the audio is not playing and there are enough audio samples  */
; 2218 :   /*  and the system is not paused then start playing audio. Note     */
; 2219 :   /*  that the following tests do NOT have to be performed in a       */
; 2220 :   /*  thread-safe manner.                                             */
; 2221 :   /********************************************************************/
; 2222 : 
; 2223 :   if (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )
; 2224 :     && ( pPlayAudioRing->iQueueCount
; 2225 : 	>= (int)pPlayAudio->uiMinimumStartupBytes )
; 2226 :    && ( ! pPlayAudio->bPaused ))

  00a30	8b 45 34	 mov	 eax, DWORD PTR [ebp+52]
  00a33	83 c4 04	 add	 esp, 4
  00a36	85 c0		 test	 eax, eax
  00a38	75 1e		 jne	 SHORT $L71178
  00a3a	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00a3d	8b 4d 2c	 mov	 ecx, DWORD PTR [ebp+44]
  00a40	3b c1		 cmp	 eax, ecx
  00a42	7c 14		 jl	 SHORT $L71178
  00a44	8b 45 58	 mov	 eax, DWORD PTR [ebp+88]
  00a47	85 c0		 test	 eax, eax
  00a49	75 0d		 jne	 SHORT $L71178

; 2227 :   {
; 2228 :     SendPlayAudioMessage( pPlayAudio,
; 2229 :                           ID_Open_Wave_Output_Device,
; 2230 :                           0L );

  00a4b	6a 00		 push	 0
  00a4d	6a 00		 push	 0
  00a4f	55		 push	 ebp
  00a50	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00a55	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71178:

; 2231 :   }
; 2232 : 
; 2233 :   /********************************************************************/
; 2234 :   /*  Release the PA_Queue() function for use in another thread.      */
; 2235 :   /********************************************************************/
; 2236 : 
; 2237 :   OP_UnlockMutex( pPlayAudio->hmxQueueAudioBusy );

  00a58	8b 8d 80 00 00
	00		 mov	 ecx, DWORD PTR [ebp+128]
  00a5e	51		 push	 ecx
  00a5f	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00a64	83 c4 04	 add	 esp, 4

; 2238 : 
; 2239 :   return MMSYSERR_NOERROR;

  00a67	33 c0		 xor	 eax, eax
  00a69	5b		 pop	 ebx
  00a6a	5e		 pop	 esi
  00a6b	5d		 pop	 ebp

; 2240 : }

  00a6c	c3		 ret	 0
_PA_Queue ENDP
_pPlayAudio$ = 8
_PA_Reset PROC NEAR

; 2270 : {

  00a70	56		 push	 esi

; 2271 :   MMRESULT mmStatus;
; 2272 : #ifdef AUD_DEBUG //tek 22may97
; 2273 :   {
; 2274 :     char szTemp[256]="";
; 2275 :     sprintf(szTemp,"PA_Reset: at %ld\n",timeGetTime());
; 2276 :     OutputDebugString(szTemp);
; 2277 :   }
; 2278 : #endif //AUD_DEBUG
; 2279 :   
; 2280 :   /********************************************************************/
; 2281 :   /*  Return an error if NULL handle.                                 */
; 2282 :   /********************************************************************/
; 2283 :   
; 2284 :   if ( pPlayAudio == NULL )

  00a71	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  00a75	85 f6		 test	 esi, esi
  00a77	75 07		 jne	 SHORT $L71184

; 2285 :     return MMSYSERR_INVALPARAM;

  00a79	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00a7e	5e		 pop	 esi

; 2350 : }

  00a7f	c3		 ret	 0
$L71184:

; 2286 : 
; 2287 :   /********************************************************************/
; 2288 :   /*  Block if another thread is queueing audio.                      */
; 2289 :   /********************************************************************/
; 2290 : 
; 2291 :   OP_LockMutex( pPlayAudio->hmxQueueAudioBusy );

  00a80	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  00a86	57		 push	 edi
  00a87	50		 push	 eax
  00a88	e8 00 00 00 00	 call	 _OP_LockMutex

; 2292 : 
; 2293 :   /********************************************************************/
; 2294 :   /*  Reset the "Reset Complete" event.                               */
; 2295 :   /********************************************************************/
; 2296 : 
; 2297 :   OP_ResetEvent( pPlayAudio->hevResetComplete );

  00a8d	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00a90	51		 push	 ecx
  00a91	e8 00 00 00 00	 call	 _OP_ResetEvent

; 2298 : 
; 2299 :   /********************************************************************/
; 2300 :   /*  Cancel all audio output and initialize the audio queue.         */
; 2301 :   /********************************************************************/
; 2302 : 
; 2303 :   mmStatus = (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2304 : 	  ID_Reset_Audio,
; 2305 : 	  0L );

  00a96	6a 00		 push	 0
  00a98	6a 01		 push	 1
  00a9a	56		 push	 esi
  00a9b	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00aa0	8b f8		 mov	 edi, eax

; 2306 :   // tek 22jan99 if the audio device is still busy (we really don't
; 2307 :   // care if there is another writer of the status word, because we're
; 2308 :   // not gonna write it..) then we need to send the reset again so that 
; 2309 :   // the reset code can do cleanup after the WOM_DONE messages are processed.
; 2310 :   if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )

  00aa2	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00aa5	83 c4 14	 add	 esp, 20			; 00000014H
  00aa8	83 f8 02	 cmp	 eax, 2
  00aab	75 0d		 jne	 SHORT $L71186

; 2311 :   {  
; 2312 : #ifdef AUD_DEBUG
; 2313 : 	  {
; 2314 : 		  char szTemp[256];
; 2315 : 		  sprintf(szTemp,"PA_Reset resending ID_Reset_Audio at %ld\n",
; 2316 : 			  timeGetTime());
; 2317 : 		  OutputDebugString(szTemp);
; 2318 : 	  }
; 2319 : #endif //AUD_DEBUG
; 2320 : 	  SendPlayAudioMessage( pPlayAudio,
; 2321 : 		  ID_Reset_Audio,
; 2322 : 		  0L );

  00aad	6a 00		 push	 0
  00aaf	6a 01		 push	 1
  00ab1	56		 push	 esi
  00ab2	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00ab7	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71186:

; 2323 :   }
; 2324 : 
; 2325 :   /********************************************************************/
; 2326 :   /*  If audio is playing then wait for the reset to complete.        */
; 2327 :   /********************************************************************/
; 2328 : 
; 2329 :   OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  00aba	8b 56 70	 mov	 edx, DWORD PTR [esi+112]
  00abd	52		 push	 edx
  00abe	e8 00 00 00 00	 call	 _OP_LockMutex

; 2330 : 
; 2331 :   if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )

  00ac3	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00ac6	83 c4 04	 add	 esp, 4
  00ac9	83 f8 02	 cmp	 eax, 2
  00acc	75 2e		 jne	 SHORT $L71187

; 2332 :   {
; 2333 :     OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  00ace	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  00ad1	50		 push	 eax
  00ad2	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 2334 : 
; 2335 :     OP_WaitForEvent( pPlayAudio->hevResetComplete,
; 2336 :                      MAXIMUM_RESET_WAIT_IN_MSEC );

  00ad7	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00ada	68 88 13 00 00	 push	 5000			; 00001388H
  00adf	51		 push	 ecx
  00ae0	e8 00 00 00 00	 call	 _OP_WaitForEvent

; 2341 :   }
; 2342 : 
; 2343 :   /********************************************************************/
; 2344 :   /*  Release the audio queue.                                        */
; 2345 :   /********************************************************************/
; 2346 : 
; 2347 :   OP_UnlockMutex( pPlayAudio->hmxQueueAudioBusy );

  00ae5	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  00aeb	83 c4 0c	 add	 esp, 12			; 0000000cH
  00aee	50		 push	 eax
  00aef	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00af4	83 c4 04	 add	 esp, 4

; 2348 : 
; 2349 :   return mmStatus;

  00af7	8b c7		 mov	 eax, edi
  00af9	5f		 pop	 edi
  00afa	5e		 pop	 esi

; 2350 : }

  00afb	c3		 ret	 0
$L71187:

; 2337 :   }
; 2338 :   else
; 2339 :   {
; 2340 :     OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  00afc	8b 56 70	 mov	 edx, DWORD PTR [esi+112]
  00aff	52		 push	 edx
  00b00	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 2341 :   }
; 2342 : 
; 2343 :   /********************************************************************/
; 2344 :   /*  Release the audio queue.                                        */
; 2345 :   /********************************************************************/
; 2346 : 
; 2347 :   OP_UnlockMutex( pPlayAudio->hmxQueueAudioBusy );

  00b05	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  00b0b	83 c4 04	 add	 esp, 4
  00b0e	50		 push	 eax
  00b0f	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00b14	83 c4 04	 add	 esp, 4

; 2348 : 
; 2349 :   return mmStatus;

  00b17	8b c7		 mov	 eax, edi
  00b19	5f		 pop	 edi
  00b1a	5e		 pop	 esi

; 2350 : }

  00b1b	c3		 ret	 0
_PA_Reset ENDP
_TEXT	ENDS
PUBLIC	_PA_Pause
_TEXT	SEGMENT
_pPlayAudio$ = 8
_PA_Pause PROC NEAR

; 2378 :   /********************************************************************/
; 2379 :   /*  Return an error if NULL handle.                                 */
; 2380 :   /********************************************************************/
; 2381 : 
; 2382 :   if ( pPlayAudio == NULL )

  00b20	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  00b24	85 c0		 test	 eax, eax
  00b26	75 06		 jne	 SHORT $L71193

; 2383 :     return MMSYSERR_INVALHANDLE;

  00b28	b8 05 00 00 00	 mov	 eax, 5

; 2392 : }

  00b2d	c3		 ret	 0
$L71193:

; 2384 : 
; 2385 :   /********************************************************************/
; 2386 :   /*  Pause the wave output device.                                   */
; 2387 :   /********************************************************************/
; 2388 : 
; 2389 :   return (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2390 :                                          ID_Pause_Audio,
; 2391 :                                          0L );

  00b2e	6a 00		 push	 0
  00b30	6a 02		 push	 2
  00b32	50		 push	 eax
  00b33	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00b38	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2392 : }

  00b3b	c3		 ret	 0
_PA_Pause ENDP
_TEXT	ENDS
PUBLIC	_PA_Resume
_TEXT	SEGMENT
_pPlayAudio$ = 8
_PA_Resume PROC NEAR

; 2419 : {

  00b40	56		 push	 esi

; 2420 :   MMRESULT mmStatus;
; 2421 : 
; 2422 :   /********************************************************************/
; 2423 :   /*  Return an error if NULL handle.                                 */
; 2424 :   /********************************************************************/
; 2425 : 
; 2426 :   if ( pPlayAudio == NULL )

  00b41	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  00b45	85 f6		 test	 esi, esi
  00b47	75 07		 jne	 SHORT $L71200

; 2427 :     return MMSYSERR_INVALPARAM;

  00b49	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00b4e	5e		 pop	 esi

; 2453 : }

  00b4f	c3		 ret	 0
$L71200:
  00b50	57		 push	 edi

; 2428 : 
; 2429 :   /********************************************************************/
; 2430 :   /*  Resume paused audio output.                                     */
; 2431 :   /********************************************************************/
; 2432 : 
; 2433 :   mmStatus =  (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2434 :                                               ID_Resume_Audio,
; 2435 :                                               0L );

  00b51	6a 00		 push	 0
  00b53	6a 03		 push	 3
  00b55	56		 push	 esi
  00b56	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00b5b	8b f8		 mov	 edi, eax

; 2436 : 
; 2437 :   /********************************************************************/
; 2438 :   /*  If the audio is not playing and there are enough audio samples  */
; 2439 :   /*  then start playing audio. Note that the following test do NOT   */
; 2440 :   /*  have to be performed in a thread safe manner.                   */
; 2441 :   /********************************************************************/
; 2442 : 
; 2443 :   if (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )
; 2444 :    && ( pPlayAudio->pPlayAudioRing->iQueueCount
; 2445 :           >= (int)pPlayAudio->uiMinimumStartupBytes ))

  00b5d	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00b60	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b63	85 c0		 test	 eax, eax
  00b65	75 1d		 jne	 SHORT $L71203
  00b67	8b 86 98 00 00
	00		 mov	 eax, DWORD PTR [esi+152]
  00b6d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00b70	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00b73	3b c8		 cmp	 ecx, eax
  00b75	7c 0d		 jl	 SHORT $L71203

; 2446 :   {
; 2447 :     SendPlayAudioMessage( pPlayAudio,
; 2448 :                           ID_Open_Wave_Output_Device,
; 2449 :                           0L );

  00b77	6a 00		 push	 0
  00b79	6a 00		 push	 0
  00b7b	56		 push	 esi
  00b7c	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00b81	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71203:

; 2450 :   }
; 2451 : 
; 2452 :   return mmStatus;

  00b84	8b c7		 mov	 eax, edi
  00b86	5f		 pop	 edi
  00b87	5e		 pop	 esi

; 2453 : }

  00b88	c3		 ret	 0
_PA_Resume ENDP
_TEXT	ENDS
PUBLIC	_PA_GetFormat
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pWaveFormat$ = 12
_PA_GetFormat PROC NEAR

; 2487 :   /********************************************************************/
; 2488 :   /*  Return an error if NULL handle.                                 */
; 2489 :   /********************************************************************/
; 2490 : 
; 2491 :   if ( pPlayAudio == NULL )

  00b90	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  00b94	85 c0		 test	 eax, eax
  00b96	75 06		 jne	 SHORT $L71210

; 2492 :     return MMSYSERR_INVALHANDLE;

  00b98	b8 05 00 00 00	 mov	 eax, 5

; 2501 : }

  00b9d	c3		 ret	 0
$L71210:

; 2493 : 
; 2494 :   /********************************************************************/
; 2495 :   /*  Get the audio format.                                           */
; 2496 :   /********************************************************************/
; 2497 : 
; 2498 :   return (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2499 :                                          ID_Get_Audio_Format,
; 2500 :                                          (ATYPE_T)pWaveFormat );

  00b9e	8b 4c 24 08	 mov	 ecx, DWORD PTR _pWaveFormat$[esp-4]
  00ba2	51		 push	 ecx
  00ba3	6a 05		 push	 5
  00ba5	50		 push	 eax
  00ba6	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00bab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2501 : }

  00bae	c3		 ret	 0
_PA_GetFormat ENDP
_pPlayAudio$ = 8
_pWaveFormat$ = 12
_PA_SetFormat PROC NEAR

; 2537 : {

  00bb0	53		 push	 ebx
  00bb1	55		 push	 ebp

; 2538 :   MMRESULT mmStatus;
; 2539 :   DWORD dwWaveFormatSize;
; 2540 :   LPWAVEFORMATEX pWaveFormatTemp;
; 2541 : #ifdef AUD_DEBUG
; 2542 :   OutputDebugString("PA_SetFormat()\n");
; 2543 : #endif
; 2544 :   /********************************************************************/
; 2545 :   /*  Return an error if NULL handle.                                 */
; 2546 :   /********************************************************************/
; 2547 : 
; 2548 :   if ( pPlayAudio == NULL )

  00bb2	8b 6c 24 0c	 mov	 ebp, DWORD PTR _pPlayAudio$[esp+4]
  00bb6	56		 push	 esi
  00bb7	85 ed		 test	 ebp, ebp
  00bb9	57		 push	 edi
  00bba	75 0a		 jne	 SHORT $L71222
  00bbc	5f		 pop	 edi
  00bbd	5e		 pop	 esi
  00bbe	5d		 pop	 ebp

; 2549 :     return MMSYSERR_INVALHANDLE;

  00bbf	b8 05 00 00 00	 mov	 eax, 5
  00bc4	5b		 pop	 ebx

; 2607 : }

  00bc5	c3		 ret	 0
$L71222:

; 2550 : 
; 2551 :   /********************************************************************/
; 2552 :   /*  Allocate shared memory for the MME server.                      */
; 2553 :   /*  First Get the size of the WAVEFORMATEX structure.               */
; 2554 :   /********************************************************************/
; 2555 : 
; 2556 :   dwWaveFormatSize = GetWaveFormatSize( pWaveFormat );

  00bc6	8b 74 24 18	 mov	 esi, DWORD PTR _pWaveFormat$[esp+12]
  00bca	56		 push	 esi
  00bcb	e8 00 00 00 00	 call	 _GetWaveFormatSize
  00bd0	8b f8		 mov	 edi, eax

; 2557 : 
; 2558 :   /********************************************************************/
; 2559 :   /*  Allocate memory for the play audio handle WAVEFORMATEX          */
; 2560 :   /*  structure.                                                      */
; 2561 :   /********************************************************************/
; 2562 : 
; 2563 :   LOCK_MME_CALL(
; 2564 :     pWaveFormatTemp =
; 2565 :       (LPWAVEFORMATEX)ALLOCATE_SERVER_MEM( dwWaveFormatSize ))

  00bd2	57		 push	 edi
  00bd3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00bd9	8b d8		 mov	 ebx, eax
  00bdb	83 c4 08	 add	 esp, 8

; 2566 : 
; 2567 :   if ( pWaveFormatTemp == NULL )

  00bde	85 db		 test	 ebx, ebx
  00be0	75 0a		 jne	 SHORT $L71225
  00be2	5f		 pop	 edi
  00be3	5e		 pop	 esi
  00be4	5d		 pop	 ebp

; 2568 :   {
; 2569 :     return MMSYSERR_NOMEM;

  00be5	b8 07 00 00 00	 mov	 eax, 7
  00bea	5b		 pop	 ebx

; 2607 : }

  00beb	c3		 ret	 0
$L71225:

; 2570 :   }
; 2571 : 
; 2572 :   /********************************************************************/
; 2573 :   /*  Copy the WAVEFORMATEX structure passed to this function to      */
; 2574 :   /*  audio handles WAVEFORMATEX structure.                           */
; 2575 :   /********************************************************************/
; 2576 : 
; 2577 :   memcpy( pWaveFormatTemp,
; 2578 :           pWaveFormat,
; 2579 :           dwWaveFormatSize );

  00bec	8b cf		 mov	 ecx, edi
  00bee	8b fb		 mov	 edi, ebx
  00bf0	8b c1		 mov	 eax, ecx

; 2580 : 
; 2581 :   /********************************************************************/
; 2582 :   /*  Set the audio format.                                           */
; 2583 :   /********************************************************************/
; 2584 : #ifdef AUD_DEBUG
; 2585 :   OutputDebugString("Calling  SendPlayAudioMessage()\n");
; 2586 : #endif
; 2587 :   mmStatus = SendPlayAudioMessage( pPlayAudio,
; 2588 :                                    ID_Set_Audio_Format,
; 2589 :                                    (ATYPE_T)pWaveFormatTemp );

  00bf2	53		 push	 ebx
  00bf3	c1 e9 02	 shr	 ecx, 2
  00bf6	f3 a5		 rep movsd
  00bf8	8b c8		 mov	 ecx, eax
  00bfa	6a 04		 push	 4
  00bfc	83 e1 03	 and	 ecx, 3
  00bff	55		 push	 ebp
  00c00	f3 a4		 rep movsb
  00c02	e8 00 00 00 00	 call	 _SendPlayAudioMessage

; 2590 : 
; 2591 :   /******************************************************************/
; 2592 :   /*  Free the temporary WAVEFORMATEX structure.                    */
; 2593 :   /******************************************************************/
; 2594 : 
; 2595 :   LOCK_MME_CALL( FREE_SERVER_MEM( pWaveFormatTemp ))

  00c07	53		 push	 ebx
  00c08	8b f0		 mov	 esi, eax
  00c0a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00c10	83 c4 10	 add	 esp, 16			; 00000010H

; 2596 : #ifdef AUD_DEBUG
; 2597 :   {
; 2598 : #include <stdio.h>
; 2599 : 		  char  szTemp[256]="";
; 2600 : 		  sprintf(szTemp,"PA_SetFormat: SendPlayAudioMessage status=%lu (%08lx)\n",
; 2601 : 			  mmStatus, mmStatus);
; 2602 : 		  OutputDebugString(szTemp);
; 2603 :   }
; 2604 : #endif //AUD_DEBUG
; 2605 : 
; 2606 :   return mmStatus;

  00c13	8b c6		 mov	 eax, esi
  00c15	5f		 pop	 edi
  00c16	5e		 pop	 esi
  00c17	5d		 pop	 ebp
  00c18	5b		 pop	 ebx

; 2607 : }

  00c19	c3		 ret	 0
_PA_SetFormat ENDP
_TEXT	ENDS
PUBLIC	_PA_GetVolume
EXTRN	__imp__waveOutGetVolume@8:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pdwVolume$ = 12
_PA_GetVolume PROC NEAR

; 2639 : #if !defined _WIN32 && !defined __linux__ // NAL warning removal
; 2640 :   LPDWORD pdwVol;
; 2641 : #endif
; 2642 : 
; 2643 :   MMRESULT mmStatus;
; 2644 : 
; 2645 :   // tek 12nov97 bats517 change this to just do it, rather than
; 2646 :   // passing messages around..
; 2647 :   /********************************************************************/
; 2648 :   /*  Return an error if NULL handle.                                 */
; 2649 :   /********************************************************************/
; 2650 : 
; 2651 :   if ( pPlayAudio == NULL )

  00c20	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  00c24	85 c0		 test	 eax, eax
  00c26	75 06		 jne	 SHORT $L71234

; 2652 :     return MMSYSERR_INVALHANDLE;

  00c28	b8 05 00 00 00	 mov	 eax, 5

; 2657 : #else // not win32 or linux; do it the slow way.
; 2658 :   /********************************************************************/
; 2659 :   /*  Allocate memory to return the volume setting.                   */
; 2660 :   /********************************************************************/
; 2661 : 
; 2662 :   LOCK_MME_CALL( pdwVol = (LPDWORD)ALLOCATE_SERVER_MEM(sizeof(DWORD)))
; 2663 : 
; 2664 :   if ( pdwVol == NULL )
; 2665 :   {
; 2666 :     return MMSYSERR_NOMEM;
; 2667 :   }
; 2668 : 
; 2669 :   /********************************************************************/
; 2670 :   /*  Get the wave output device volume.                              */
; 2671 :   /********************************************************************/
; 2672 : 
; 2673 :   mmStatus = (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2674 :                                              ID_Get_Audio_Volume,
; 2675 :                                              (ATYPE_T)pdwVol );
; 2676 :   *pdwVolume = *pdwVol;
; 2677 : 
; 2678 :   /********************************************************************/
; 2679 :   /*  Free the memory used to return the volume setting.              */
; 2680 :   /********************************************************************/
; 2681 : 
; 2682 :   LOCK_MME_CALL( FREE_SERVER_MEM( pdwVol ))
; 2683 : #endif //_WIN32
; 2684 : 
; 2685 :   return mmStatus;
; 2686 : }

  00c2d	c3		 ret	 0
$L71234:

; 2653 : 
; 2654 : #if defined _WIN32 || defined __linux__
; 2655 : 
; 2656 :   mmStatus = waveOutGetVolume((HWAVEOUT)pPlayAudio->uiSelectedDeviceID,pdwVolume);

  00c2e	8b 4c 24 08	 mov	 ecx, DWORD PTR _pdwVolume$[esp-4]
  00c32	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  00c35	51		 push	 ecx
  00c36	52		 push	 edx
  00c37	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetVolume@8

; 2657 : #else // not win32 or linux; do it the slow way.
; 2658 :   /********************************************************************/
; 2659 :   /*  Allocate memory to return the volume setting.                   */
; 2660 :   /********************************************************************/
; 2661 : 
; 2662 :   LOCK_MME_CALL( pdwVol = (LPDWORD)ALLOCATE_SERVER_MEM(sizeof(DWORD)))
; 2663 : 
; 2664 :   if ( pdwVol == NULL )
; 2665 :   {
; 2666 :     return MMSYSERR_NOMEM;
; 2667 :   }
; 2668 : 
; 2669 :   /********************************************************************/
; 2670 :   /*  Get the wave output device volume.                              */
; 2671 :   /********************************************************************/
; 2672 : 
; 2673 :   mmStatus = (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2674 :                                              ID_Get_Audio_Volume,
; 2675 :                                              (ATYPE_T)pdwVol );
; 2676 :   *pdwVolume = *pdwVol;
; 2677 : 
; 2678 :   /********************************************************************/
; 2679 :   /*  Free the memory used to return the volume setting.              */
; 2680 :   /********************************************************************/
; 2681 : 
; 2682 :   LOCK_MME_CALL( FREE_SERVER_MEM( pdwVol ))
; 2683 : #endif //_WIN32
; 2684 : 
; 2685 :   return mmStatus;
; 2686 : }

  00c3d	c3		 ret	 0
_PA_GetVolume ENDP
_TEXT	ENDS
PUBLIC	_PA_SetVolume
EXTRN	__imp__waveOutSetVolume@8:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_dwVolume$ = 12
_PA_SetVolume PROC NEAR

; 2716 : 
; 2717 :    // tek 12nov97	bats517 change to just do it rather than pass messages
; 2718 : 
; 2719 :   /********************************************************************/
; 2720 :   /*  Return an error if NULL handle.                                 */
; 2721 :   /********************************************************************/
; 2722 : 
; 2723 :   if ( pPlayAudio == NULL )

  00c40	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  00c44	85 c0		 test	 eax, eax
  00c46	75 06		 jne	 SHORT $L71242

; 2724 :     return MMSYSERR_INVALHANDLE;

  00c48	b8 05 00 00 00	 mov	 eax, 5

; 2731 : #else // not win32
; 2732 :   return (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2733 :                                          ID_Set_Audio_Volume,
; 2734 :                                          (ATYPE_T)dwVolume );
; 2735 : #endif //_WIN32
; 2736 : }

  00c4d	c3		 ret	 0
$L71242:

; 2725 : 
; 2726 :   /********************************************************************/
; 2727 :   /*  Set the wave output device volume.                              */
; 2728 :   /********************************************************************/
; 2729 : #ifdef _WIN32
; 2730 :   return waveOutSetVolume((HWAVEOUT)pPlayAudio->uiSelectedDeviceID,dwVolume);

  00c4e	8b 4c 24 08	 mov	 ecx, DWORD PTR _dwVolume$[esp-4]
  00c52	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  00c55	51		 push	 ecx
  00c56	52		 push	 edx
  00c57	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutSetVolume@8

; 2731 : #else // not win32
; 2732 :   return (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2733 :                                          ID_Set_Audio_Volume,
; 2734 :                                          (ATYPE_T)dwVolume );
; 2735 : #endif //_WIN32
; 2736 : }

  00c5d	c3		 ret	 0
_PA_SetVolume ENDP
_TEXT	ENDS
PUBLIC	_PA_SynchronizationMark
_TEXT	SEGMENT
_pPlayAudio$ = 8
_aTag$ = 12
_PA_SynchronizationMark PROC NEAR

; 2772 :   /********************************************************************/
; 2773 :   /*  Return an error if NULL handle.                                 */
; 2774 :   /********************************************************************/
; 2775 : 
; 2776 :   if ( pPlayAudio == NULL )

  00c60	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  00c64	85 c0		 test	 eax, eax
  00c66	75 06		 jne	 SHORT $L71250

; 2777 :     return MMSYSERR_INVALHANDLE;

  00c68	b8 05 00 00 00	 mov	 eax, 5

; 2786 : }

  00c6d	c3		 ret	 0
$L71250:

; 2778 : 
; 2779 :   /********************************************************************/
; 2780 :   /*  Set the wave output Synchronization Mark.                       */
; 2781 :   /********************************************************************/
; 2782 : 
; 2783 :   return (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2784 :                                          ID_Synchronization_Mark,
; 2785 :                                          aTag );

  00c6e	8b 4c 24 08	 mov	 ecx, DWORD PTR _aTag$[esp-4]
  00c72	51		 push	 ecx
  00c73	6a 08		 push	 8
  00c75	50		 push	 eax
  00c76	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00c7b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2786 : }

  00c7e	c3		 ret	 0
_PA_SynchronizationMark ENDP
_TEXT	ENDS
PUBLIC	_PA_GetPosition
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pdwPosition$ = 12
_bFast$ = 16
_PA_GetPosition PROC NEAR

; 2841 : {

  00c80	53		 push	 ebx
  00c81	56		 push	 esi
  00c82	57		 push	 edi

; 2842 :   LPDWORD pdwPos;
; 2843 :   MMRESULT mmStatus;
; 2844 : 
; 2845 :   /********************************************************************/
; 2846 :   /*  Return an error if NULL handle.                                 */
; 2847 :   /********************************************************************/
; 2848 : 
; 2849 :   if ( pPlayAudio == NULL )

  00c83	8b 7c 24 10	 mov	 edi, DWORD PTR _pPlayAudio$[esp+8]
  00c87	85 ff		 test	 edi, edi
  00c89	75 09		 jne	 SHORT $L71262
  00c8b	5f		 pop	 edi
  00c8c	5e		 pop	 esi

; 2850 :     return MMSYSERR_INVALHANDLE;

  00c8d	b8 05 00 00 00	 mov	 eax, 5
  00c92	5b		 pop	 ebx

; 2899 : }

  00c93	c3		 ret	 0
$L71262:

; 2851 : 
; 2852 :   /********************************************************************/
; 2853 :   /*  Either get a quick coarse position or a slower but more         */
; 2854 :   /*  accurate position.                                              */
; 2855 :   /********************************************************************/
; 2856 : 
; 2857 :   if ( bFast )

  00c94	8b 44 24 18	 mov	 eax, DWORD PTR _bFast$[esp+8]
  00c98	85 c0		 test	 eax, eax
  00c9a	74 26		 je	 SHORT $L71263

; 2858 :   {
; 2859 :     /******************************************************************/
; 2860 :     /*  Get the coarse wave output position.                          */
; 2861 :     /******************************************************************/
; 2862 : 
; 2863 :     mmStatus = MMSYSERR_NOERROR;
; 2864 : 
; 2865 :     OP_LockMutex( pPlayAudio->hmxBytesPlayed );

  00c9c	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  00c9f	33 db		 xor	 ebx, ebx
  00ca1	50		 push	 eax
  00ca2	e8 00 00 00 00	 call	 _OP_LockMutex

; 2866 :     *pdwPosition = pPlayAudio->dwBytesPlayed;

  00ca7	8b 54 24 18	 mov	 edx, DWORD PTR _pdwPosition$[esp+12]
  00cab	8b 4f 44	 mov	 ecx, DWORD PTR [edi+68]
  00cae	89 0a		 mov	 DWORD PTR [edx], ecx

; 2867 :     OP_UnlockMutex( pPlayAudio->hmxBytesPlayed );

  00cb0	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  00cb3	50		 push	 eax
  00cb4	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00cb9	83 c4 08	 add	 esp, 8

; 2896 :   }
; 2897 : 
; 2898 :   return mmStatus;

  00cbc	8b c3		 mov	 eax, ebx
  00cbe	5f		 pop	 edi
  00cbf	5e		 pop	 esi
  00cc0	5b		 pop	 ebx

; 2899 : }

  00cc1	c3		 ret	 0
$L71263:

; 2868 :   }
; 2869 :   else
; 2870 :   {
; 2871 :     /******************************************************************/
; 2872 :     /*  Allocate memory to return the audio position.                 */
; 2873 :     /******************************************************************/
; 2874 : 
; 2875 :     pdwPos = (LPDWORD)malloc(sizeof(DWORD));

  00cc2	6a 04		 push	 4
  00cc4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00cca	8b f0		 mov	 esi, eax
  00ccc	83 c4 04	 add	 esp, 4

; 2876 : 
; 2877 :     if ( pdwPos == NULL )

  00ccf	85 f6		 test	 esi, esi
  00cd1	75 09		 jne	 SHORT $L71268
  00cd3	5f		 pop	 edi
  00cd4	5e		 pop	 esi

; 2878 :     {
; 2879 :       return MMSYSERR_NOMEM;

  00cd5	b8 07 00 00 00	 mov	 eax, 7
  00cda	5b		 pop	 ebx

; 2899 : }

  00cdb	c3		 ret	 0
$L71268:

; 2880 :     }
; 2881 : 
; 2882 :     /******************************************************************/
; 2883 :     /*  Get the fine wave output position.                            */
; 2884 :     /******************************************************************/
; 2885 : 
; 2886 :     mmStatus = (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2887 :                                                ID_Get_Audio_Position,
; 2888 :                                                (ATYPE_T)pdwPos );

  00cdc	56		 push	 esi
  00cdd	6a 09		 push	 9
  00cdf	57		 push	 edi
  00ce0	e8 00 00 00 00	 call	 _SendPlayAudioMessage

; 2889 :     *pdwPosition = *pdwPos;

  00ce5	8b 54 24 20	 mov	 edx, DWORD PTR _pdwPosition$[esp+20]
  00ce9	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 2890 : 
; 2891 :     /******************************************************************/
; 2892 :     /*  Free the memory used to return the audio position.            */
; 2893 :     /******************************************************************/
; 2894 : 
; 2895 :     free( pdwPos );

  00ceb	56		 push	 esi
  00cec	8b d8		 mov	 ebx, eax
  00cee	89 0a		 mov	 DWORD PTR [edx], ecx
  00cf0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00cf6	83 c4 10	 add	 esp, 16			; 00000010H

; 2896 :   }
; 2897 : 
; 2898 :   return mmStatus;

  00cf9	8b c3		 mov	 eax, ebx
  00cfb	5f		 pop	 edi
  00cfc	5e		 pop	 esi
  00cfd	5b		 pop	 ebx

; 2899 : }

  00cfe	c3		 ret	 0
_PA_GetPosition ENDP
_TEXT	ENDS
PUBLIC	_PA_Status
_TEXT	SEGMENT
_pPlayAudio$ = 8
_dwIdentifierArray$ = 12
_dwStatusArray$ = 16
_dwNumberOfStatusValues$ = 20
_uiQueueCount$ = -8
_bGotQueueCount$ = 8
_mmStatus$ = -4
_PA_Status PROC NEAR

; 2981 : {

  00d00	83 ec 08	 sub	 esp, 8
  00d03	55		 push	 ebp
  00d04	56		 push	 esi

; 2982 :   unsigned int uiI;
; 2983 :   unsigned int uiQueueCount=0;
; 2984 :   unsigned int bGotQueueCount;
; 2985 :   DWORD dwAudioDeviceState;
; 2986 :   LPPLAY_RING_T pPlayAudioRing=NULL;
; 2987 :   MMRESULT mmStatus;
; 2988 : 
; 2989 :   /********************************************************************/
; 2990 :   /*  Return an error if NULL handle.                                 */
; 2991 :   /********************************************************************/
; 2992 : 
; 2993 :   if ( pPlayAudio == NULL )

  00d05	8b 74 24 14	 mov	 esi, DWORD PTR _pPlayAudio$[esp+12]
  00d09	33 d2		 xor	 edx, edx
  00d0b	33 ed		 xor	 ebp, ebp
  00d0d	3b f2		 cmp	 esi, edx
  00d0f	89 54 24 08	 mov	 DWORD PTR _uiQueueCount$[esp+16], edx
  00d13	75 0b		 jne	 SHORT $L71288
  00d15	5e		 pop	 esi

; 2994 :     return MMSYSERR_INVALHANDLE;

  00d16	b8 05 00 00 00	 mov	 eax, 5
  00d1b	5d		 pop	 ebp

; 3088 : }

  00d1c	83 c4 08	 add	 esp, 8
  00d1f	c3		 ret	 0
$L71288:

; 2995 : 
; 2996 :   /********************************************************************/
; 2997 :   /*  Range check the number of status values requested.              */
; 2998 :   /********************************************************************/
; 2999 : 
; 3000 :   if (( dwNumberOfStatusValues == 0 )
; 3001 :     || ( dwNumberOfStatusValues > MAXIMUM_STATUS_VALUES ))

  00d20	8b 44 24 20	 mov	 eax, DWORD PTR _dwNumberOfStatusValues$[esp+12]
  00d24	3b c2		 cmp	 eax, edx
  00d26	0f 84 3a 01 00
	00		 je	 $L71290
  00d2c	83 f8 04	 cmp	 eax, 4
  00d2f	0f 87 31 01 00
	00		 ja	 $L71290

; 3009 : 
; 3010 :   /********************************************************************/
; 3011 :   /*  Loop and fill in array puiStatus[].                             */
; 3012 :   /********************************************************************/
; 3013 : 
; 3014 :   bGotQueueCount = FALSE;
; 3015 : 
; 3016 :   for ( uiI = 0; uiI < dwNumberOfStatusValues; uiI++ )

  00d35	3b c2		 cmp	 eax, edx
  00d37	89 54 24 0c	 mov	 DWORD PTR _mmStatus$[esp+16], edx
  00d3b	89 54 24 14	 mov	 DWORD PTR _bGotQueueCount$[esp+12], edx
  00d3f	0f 86 17 01 00
	00		 jbe	 $L71293

; 3029 :       else
; 3030 :         dwStatusArray[uiI] = TRUE;

  00d45	8b 4c 24 18	 mov	 ecx, DWORD PTR _dwIdentifierArray$[esp+12]
  00d49	53		 push	 ebx
  00d4a	57		 push	 edi
  00d4b	8b 7c 24 24	 mov	 edi, DWORD PTR _dwStatusArray$[esp+20]
  00d4f	2b cf		 sub	 ecx, edi
  00d51	89 44 24 28	 mov	 DWORD PTR 20+[esp+20], eax
  00d55	89 4c 24 24	 mov	 DWORD PTR 16+[esp+20], ecx
  00d59	eb 08		 jmp	 SHORT $L71291
$L72123:

; 3003 : 
; 3004 :   /********************************************************************/
; 3005 :   /*  Set the default error return value to indicate success.         */
; 3006 :   /********************************************************************/
; 3007 : 
; 3008 :   mmStatus = MMSYSERR_NOERROR;

  00d5b	8b 4c 24 24	 mov	 ecx, DWORD PTR 16+[esp+20]
  00d5f	8b 54 24 1c	 mov	 edx, DWORD PTR _bGotQueueCount$[esp+20]
$L71291:

; 3017 :   {
; 3018 :     switch( dwIdentifierArray[uiI] )
; 3019 :     {

  00d63	8b 04 39	 mov	 eax, DWORD PTR [ecx+edi]
  00d66	83 f8 03	 cmp	 eax, 3
  00d69	0f 87 cb 00 00
	00		 ja	 $L71313
  00d6f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72124[eax*4]
$L71298:

; 3020 :     case PA_DEVICE_PLAYING:
; 3021 : 
; 3022 :       OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  00d76	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  00d79	50		 push	 eax
  00d7a	e8 00 00 00 00	 call	 _OP_LockMutex

; 3023 :       dwAudioDeviceState = pPlayAudio->dwAudioDeviceState;
; 3024 :       OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  00d7f	8b 4e 70	 mov	 ecx, DWORD PTR [esi+112]
  00d82	8b 5e 34	 mov	 ebx, DWORD PTR [esi+52]
  00d85	51		 push	 ecx
  00d86	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00d8b	83 c4 08	 add	 esp, 8

; 3025 : 
; 3026 :       if (( dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )
; 3027 :         || ( dwAudioDeviceState == AUDIO_DEVICE_SHUTTING_DOWN ))

  00d8e	85 db		 test	 ebx, ebx
  00d90	74 10		 je	 SHORT $L71300
  00d92	83 fb 03	 cmp	 ebx, 3
  00d95	74 0b		 je	 SHORT $L71300

; 3029 :       else
; 3030 :         dwStatusArray[uiI] = TRUE;

  00d97	c7 07 01 00 00
	00		 mov	 DWORD PTR [edi], 1
  00d9d	e9 a6 00 00 00	 jmp	 $L71292
$L71300:

; 3028 :         dwStatusArray[uiI] = FALSE;

  00da2	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 3031 : 
; 3032 :       break;

  00da8	e9 9b 00 00 00	 jmp	 $L71292
$L71302:

; 3033 : 
; 3034 :     case PA_FREE_SPACE:
; 3035 : 
; 3036 :       if ( ! bGotQueueCount )

  00dad	85 d2		 test	 edx, edx
  00daf	75 2a		 jne	 SHORT $L71303

; 3037 :       {
; 3038 :         bGotQueueCount = TRUE;
; 3039 : 
; 3040 :         pPlayAudioRing = pPlayAudio->pPlayAudioRing;
; 3041 : 
; 3042 :         OP_LockMutex( pPlayAudio->hmxQueueCount );

  00db1	8b 56 7c	 mov	 edx, DWORD PTR [esi+124]
  00db4	8b ae 98 00 00
	00		 mov	 ebp, DWORD PTR [esi+152]
  00dba	52		 push	 edx
  00dbb	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR _bGotQueueCount$[esp+24], 1
  00dc3	e8 00 00 00 00	 call	 _OP_LockMutex

; 3043 :         uiQueueCount = (unsigned int)pPlayAudioRing->iQueueCount;
; 3044 : 		// tek 07nov97 BATS 514this was a very bad typo! change to UNlock!
; 3045 :         OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  00dc8	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  00dcb	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  00dce	51		 push	 ecx
  00dcf	89 44 24 18	 mov	 DWORD PTR _uiQueueCount$[esp+32], eax
  00dd3	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00dd8	83 c4 08	 add	 esp, 8
$L71303:

; 3046 :       }
; 3047 : 
; 3048 :       dwStatusArray[uiI] = (DWORD)
; 3049 :         ((unsigned int )pPlayAudioRing->iQueueLength - uiQueueCount );

  00ddb	8b 55 1c	 mov	 edx, DWORD PTR [ebp+28]
  00dde	8b 44 24 10	 mov	 eax, DWORD PTR _uiQueueCount$[esp+24]
  00de2	2b d0		 sub	 edx, eax
  00de4	89 17		 mov	 DWORD PTR [edi], edx

; 3050 : 
; 3051 :       break;

  00de6	eb 60		 jmp	 SHORT $L71292
$L71307:

; 3052 : 
; 3053 :     case PA_QUEUE_COUNT:
; 3054 : 
; 3055 :       if ( ! bGotQueueCount )

  00de8	85 d2		 test	 edx, edx
  00dea	75 2a		 jne	 SHORT $L71308

; 3056 :       {
; 3057 :         bGotQueueCount = TRUE;
; 3058 : 
; 3059 :         pPlayAudioRing = pPlayAudio->pPlayAudioRing;
; 3060 : 
; 3061 :         OP_LockMutex( pPlayAudio->hmxQueueCount );

  00dec	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  00def	8b ae 98 00 00
	00		 mov	 ebp, DWORD PTR [esi+152]
  00df5	50		 push	 eax
  00df6	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR _bGotQueueCount$[esp+24], 1
  00dfe	e8 00 00 00 00	 call	 _OP_LockMutex

; 3062 :         uiQueueCount = (unsigned int)pPlayAudioRing->iQueueCount;
; 3063 :         OP_LockMutex( pPlayAudio->hmxQueueCount );

  00e03	8b 56 7c	 mov	 edx, DWORD PTR [esi+124]
  00e06	8b 4d 18	 mov	 ecx, DWORD PTR [ebp+24]
  00e09	52		 push	 edx
  00e0a	89 4c 24 18	 mov	 DWORD PTR _uiQueueCount$[esp+32], ecx
  00e0e	e8 00 00 00 00	 call	 _OP_LockMutex
  00e13	83 c4 08	 add	 esp, 8
$L71308:

; 3064 :       }
; 3065 : 
; 3066 :       dwStatusArray[uiI] = (DWORD)uiQueueCount;

  00e16	8b 44 24 10	 mov	 eax, DWORD PTR _uiQueueCount$[esp+24]
  00e1a	89 07		 mov	 DWORD PTR [edi], eax

; 3067 : 
; 3068 :       break;

  00e1c	eb 2a		 jmp	 SHORT $L71292
$L71311:

; 3069 : 
; 3070 :     case PA_DEVICE_ID:
; 3071 : 
; 3072 :       OP_LockMutex( pPlayAudio->hmxSelectedDeviceID );

  00e1e	8b 4e 78	 mov	 ecx, DWORD PTR [esi+120]
  00e21	51		 push	 ecx
  00e22	e8 00 00 00 00	 call	 _OP_LockMutex

; 3073 :       dwStatusArray[uiI] = (DWORD)pPlayAudio->uiSelectedDeviceID;

  00e27	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00e2a	89 17		 mov	 DWORD PTR [edi], edx

; 3074 :       OP_UnlockMutex( pPlayAudio->hmxSelectedDeviceID );

  00e2c	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  00e2f	50		 push	 eax
  00e30	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00e35	83 c4 08	 add	 esp, 8

; 3075 : 
; 3076 :       break;

  00e38	eb 0e		 jmp	 SHORT $L71292
$L71313:

; 3077 : 
; 3078 :     default:
; 3079 : 
; 3080 :       dwStatusArray[uiI] = 0xFFFFFFFF;

  00e3a	c7 07 ff ff ff
	ff		 mov	 DWORD PTR [edi], -1

; 3081 :       mmStatus = MMSYSERR_INVALPARAM;

  00e40	c7 44 24 14 0b
	00 00 00	 mov	 DWORD PTR _mmStatus$[esp+24], 11 ; 0000000bH
$L71292:
  00e48	8b 44 24 28	 mov	 eax, DWORD PTR 20+[esp+20]
  00e4c	83 c7 04	 add	 edi, 4
  00e4f	48		 dec	 eax
  00e50	89 44 24 28	 mov	 DWORD PTR 20+[esp+20], eax
  00e54	0f 85 01 ff ff
	ff		 jne	 $L72123
  00e5a	5f		 pop	 edi
  00e5b	5b		 pop	 ebx
$L71293:

; 3082 : 
; 3083 :       break;
; 3084 :     }
; 3085 :   }
; 3086 : 
; 3087 :   return mmStatus;

  00e5c	8b 44 24 0c	 mov	 eax, DWORD PTR _mmStatus$[esp+16]
  00e60	5e		 pop	 esi
  00e61	5d		 pop	 ebp

; 3088 : }

  00e62	83 c4 08	 add	 esp, 8
  00e65	c3		 ret	 0
$L71290:
  00e66	5e		 pop	 esi

; 3002 :     return MMSYSERR_INVALPARAM;

  00e67	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00e6c	5d		 pop	 ebp

; 3088 : }

  00e6d	83 c4 08	 add	 esp, 8
  00e70	c3		 ret	 0
  00e71	8d 49 00	 npad	 3
$L72124:
  00e74	00 00 00 00	 DD	 $L71298
  00e78	00 00 00 00	 DD	 $L71302
  00e7c	00 00 00 00	 DD	 $L71307
  00e80	00 00 00 00	 DD	 $L71311
_PA_Status ENDP
_TEXT	ENDS
PUBLIC	_PA_WaitForPlayToComplete
EXTRN	_OP_Sleep:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_PA_WaitForPlayToComplete PROC NEAR

; 3117 : {

  00e90	56		 push	 esi

; 3118 :   int iQueueCount;
; 3119 :   PLAYAUD_BOOL_T bAudioPlaying;
; 3120 :   LPPLAY_RING_T pPlayAudioRing;
; 3121 : 
; 3122 :   /********************************************************************/
; 3123 :   /*  Return an error if NULL handle.                                 */
; 3124 :   /********************************************************************/
; 3125 : 
; 3126 :   if ( pPlayAudio == NULL )

  00e91	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  00e95	85 f6		 test	 esi, esi
  00e97	75 07		 jne	 SHORT $L71321

; 3127 :     return MMSYSERR_INVALHANDLE;

  00e99	b8 05 00 00 00	 mov	 eax, 5
  00e9e	5e		 pop	 esi

; 3164 : }

  00e9f	c3		 ret	 0
$L71321:
  00ea0	53		 push	 ebx

; 3128 : 
; 3129 :   /********************************************************************/
; 3130 :   /*  Loop and wait for all queued audio samples to complete.         */
; 3131 :   /********************************************************************/
; 3132 : 
; 3133 :   pPlayAudioRing = pPlayAudio->pPlayAudioRing;

  00ea1	8b 9e 98 00 00
	00		 mov	 ebx, DWORD PTR [esi+152]
  00ea7	57		 push	 edi
$L71323:

; 3134 :   bAudioPlaying = TRUE;
; 3135 : 
; 3136 :   while( bAudioPlaying )
; 3137 :   {
; 3138 :     /******************************************************************/
; 3139 :     /*  Wait on the Audio Device Inactive Event.                      */
; 3140 :     /******************************************************************/
; 3141 : 
; 3142 :     OP_WaitForEvent( pPlayAudio->hevAudioDeviceInactive, OP_INFINITE );

  00ea8	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00eab	6a ff		 push	 -1
  00ead	50		 push	 eax
  00eae	e8 00 00 00 00	 call	 _OP_WaitForEvent

; 3143 : 
; 3144 :     /******************************************************************/
; 3145 :     /*  Check the Audio Queue Count. If there is any audio to be      */
; 3146 :     /*  played then go to sleep and contine to wait.                  */
; 3147 :     /******************************************************************/
; 3148 : 
; 3149 :     OP_LockMutex( pPlayAudio->hmxQueueCount );

  00eb3	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  00eb6	51		 push	 ecx
  00eb7	e8 00 00 00 00	 call	 _OP_LockMutex

; 3150 :     iQueueCount = pPlayAudioRing->iQueueCount;
; 3151 :     OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  00ebc	8b 56 7c	 mov	 edx, DWORD PTR [esi+124]
  00ebf	8b 7b 18	 mov	 edi, DWORD PTR [ebx+24]
  00ec2	52		 push	 edx
  00ec3	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00ec8	83 c4 10	 add	 esp, 16			; 00000010H

; 3152 : 
; 3153 :     if ( iQueueCount == 0 )

  00ecb	85 ff		 test	 edi, edi
  00ecd	74 0c		 je	 SHORT $L72127

; 3154 :     {
; 3155 :       bAudioPlaying = FALSE;
; 3156 :     }
; 3157 :     else
; 3158 :     {
; 3159 :       OP_Sleep( PLAY_WAIT_SLEEP_TIME_IN_MSEC );

  00ecf	6a 32		 push	 50			; 00000032H
  00ed1	e8 00 00 00 00	 call	 _OP_Sleep
  00ed6	83 c4 04	 add	 esp, 4
  00ed9	eb cd		 jmp	 SHORT $L71323
$L72127:
  00edb	5f		 pop	 edi
  00edc	5b		 pop	 ebx

; 3160 :     }
; 3161 :   }
; 3162 : 
; 3163 :   return MMSYSERR_NOERROR;

  00edd	33 c0		 xor	 eax, eax
  00edf	5e		 pop	 esi

; 3164 : }

  00ee0	c3		 ret	 0
_PA_WaitForPlayToComplete ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutGetDevCapsA@12:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_uiNumberOfWaveOutDevices$ = 12
_pWaveFormat$ = 16
_bGotDeviceID$ = -8
_bAllocated$ = -4
_DetermineDeviceID PROC NEAR

; 3205 : {

  00ef0	83 ec 08	 sub	 esp, 8
  00ef3	53		 push	 ebx
  00ef4	55		 push	 ebp

; 3206 :   unsigned int bGotDeviceID;
; 3207 :   unsigned int bAllocated;
; 3208 :   unsigned int bIsStandardFormat;
; 3209 :   unsigned int uiDeviceID;
; 3210 :   DWORD dwDesiredFormat=0;
; 3211 :   LPWAVEOUTCAPS pWaveOutCaps;
; 3212 :   MMRESULT mmStatus;
; 3213 : #ifdef AUD_DEBUG
; 3214 :   OutputDebugString("DetermineDeviceID()\n");
; 3215 : #endif
; 3216 :   /********************************************************************/
; 3217 :   /*  Query each device until a non-allocated device that supports    */
; 3218 :   /*  the requested format is found.                                  */
; 3219 :   /********************************************************************/
; 3220 : 
; 3221 :   bGotDeviceID = FALSE;
; 3222 :   bAllocated = FALSE;
; 3223 : 
; 3224 :   for ( uiDeviceID = 0;
; 3225 :         uiDeviceID < uiNumberOfWaveOutDevices;
; 3226 :         uiDeviceID++ )

  00ef5	8b 6c 24 18	 mov	 ebp, DWORD PTR _uiNumberOfWaveOutDevices$[esp+12]
  00ef9	56		 push	 esi
  00efa	57		 push	 edi
  00efb	33 ff		 xor	 edi, edi
  00efd	3b ef		 cmp	 ebp, edi
  00eff	89 7c 24 10	 mov	 DWORD PTR _bGotDeviceID$[esp+24], edi
  00f03	89 7c 24 14	 mov	 DWORD PTR _bAllocated$[esp+24], edi
  00f07	76 6a		 jbe	 SHORT $L72140

; 3227 :   {
; 3228 :     pPlayAudio->uiSelectedDeviceID = uiDeviceID;

  00f09	8b 74 24 24	 mov	 esi, DWORD PTR _pWaveFormat$[esp+20]
$L71341:
  00f0d	8b 5c 24 1c	 mov	 ebx, DWORD PTR _pPlayAudio$[esp+20]

; 3229 : 
; 3230 :     mmStatus = PA_SetFormat( pPlayAudio, pWaveFormat );

  00f11	56		 push	 esi
  00f12	53		 push	 ebx
  00f13	89 7b 20	 mov	 DWORD PTR [ebx+32], edi
  00f16	e8 00 00 00 00	 call	 _PA_SetFormat
  00f1b	83 c4 08	 add	 esp, 8

; 3231 : 
; 3232 :     if ( mmStatus == MMSYSERR_NOERROR )

  00f1e	85 c0		 test	 eax, eax
  00f20	74 14		 je	 SHORT $L72132

; 3235 :       break;
; 3236 :     }
; 3237 :     else if ( mmStatus == MMSYSERR_ALLOCATED )

  00f22	83 f8 04	 cmp	 eax, 4
  00f25	75 08		 jne	 SHORT $L71342

; 3238 :     {
; 3239 :       bAllocated = TRUE;

  00f27	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _bAllocated$[esp+24], 1
$L71342:

; 3206 :   unsigned int bGotDeviceID;
; 3207 :   unsigned int bAllocated;
; 3208 :   unsigned int bIsStandardFormat;
; 3209 :   unsigned int uiDeviceID;
; 3210 :   DWORD dwDesiredFormat=0;
; 3211 :   LPWAVEOUTCAPS pWaveOutCaps;
; 3212 :   MMRESULT mmStatus;
; 3213 : #ifdef AUD_DEBUG
; 3214 :   OutputDebugString("DetermineDeviceID()\n");
; 3215 : #endif
; 3216 :   /********************************************************************/
; 3217 :   /*  Query each device until a non-allocated device that supports    */
; 3218 :   /*  the requested format is found.                                  */
; 3219 :   /********************************************************************/
; 3220 : 
; 3221 :   bGotDeviceID = FALSE;
; 3222 :   bAllocated = FALSE;
; 3223 : 
; 3224 :   for ( uiDeviceID = 0;
; 3225 :         uiDeviceID < uiNumberOfWaveOutDevices;
; 3226 :         uiDeviceID++ )

  00f2f	47		 inc	 edi
  00f30	3b fd		 cmp	 edi, ebp
  00f32	72 d9		 jb	 SHORT $L71341

; 3545 :         {
; 3546 :           break;
; 3547 :         }
; 3548 : 
; 3549 :         if ( pWaveOutCaps->dwFormats == dwDesiredFormat )

  00f34	eb 08		 jmp	 SHORT $L71343
$L72132:

; 3233 :     {
; 3234 :       bGotDeviceID = TRUE;

  00f36	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _bGotDeviceID$[esp+24], 1
$L71343:

; 3240 :     }
; 3241 :   }
; 3242 : 
; 3243 :   /********************************************************************/
; 3244 :   /*  There were no devices available that support the requested      */
; 3245 :   /*  format. Query each device until a device that supports the      */
; 3246 :   /*  requested format is found, even if the device is allocated.     */
; 3247 :   /********************************************************************/
; 3248 : 
; 3249 :   if ( bAllocated )

  00f3e	8b 44 24 14	 mov	 eax, DWORD PTR _bAllocated$[esp+24]
  00f42	85 c0		 test	 eax, eax
  00f44	74 1d		 je	 SHORT $L71350

; 3250 :   {
; 3251 :     for ( uiDeviceID = 0;
; 3252 :           uiDeviceID < uiNumberOfWaveOutDevices;
; 3253 :           uiDeviceID++ )

  00f46	33 ff		 xor	 edi, edi
$L71348:

; 3254 :     {
; 3255 :       pPlayAudio->uiSelectedDeviceID = uiDeviceID;
; 3256 : 
; 3257 :       mmStatus = PA_SetFormat( pPlayAudio, pWaveFormat );

  00f48	56		 push	 esi
  00f49	53		 push	 ebx
  00f4a	89 7b 20	 mov	 DWORD PTR [ebx+32], edi
  00f4d	e8 00 00 00 00	 call	 _PA_SetFormat
  00f52	83 c4 08	 add	 esp, 8

; 3258 : 
; 3259 :       if (( mmStatus == MMSYSERR_NOERROR )
; 3260 :         || ( mmStatus == MMSYSERR_ALLOCATED ))

  00f55	85 c0		 test	 eax, eax
  00f57	74 27		 je	 SHORT $L72133
  00f59	83 f8 04	 cmp	 eax, 4
  00f5c	74 22		 je	 SHORT $L72133
  00f5e	47		 inc	 edi
  00f5f	3b fd		 cmp	 edi, ebp
  00f61	72 e5		 jb	 SHORT $L71348
$L71350:

; 3263 :         break;
; 3264 :       }
; 3265 :     }
; 3266 :   }
; 3267 : 
; 3268 :   // tek 24sep96 if we didn't find an unallocated device that 
; 3269 :   // supports this format, and we didn't find an allocated device, 
; 3270 :   // bail out.
; 3271 :   if ((!bGotDeviceID) && (!bAllocated))

  00f63	8b 44 24 10	 mov	 eax, DWORD PTR _bGotDeviceID$[esp+24]
  00f67	85 c0		 test	 eax, eax
  00f69	75 1d		 jne	 SHORT $L71353
  00f6b	8b 44 24 14	 mov	 eax, DWORD PTR _bAllocated$[esp+24]
  00f6f	85 c0		 test	 eax, eax
  00f71	75 15		 jne	 SHORT $L71353
$L72140:
  00f73	5f		 pop	 edi
  00f74	5e		 pop	 esi
  00f75	5d		 pop	 ebp

; 3272 :   {
; 3273 : #ifdef AUD_DEBUG
; 3274 : 	  OutputDebugString("no devices support format.\n");
; 3275 : #endif
; 3276 : 	  return WAVERR_BADFORMAT;

  00f76	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00f7b	5b		 pop	 ebx

; 3587 : }

  00f7c	83 c4 08	 add	 esp, 8
  00f7f	c3		 ret	 0
$L72133:

; 3261 :       {
; 3262 :         bGotDeviceID = TRUE;

  00f80	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _bGotDeviceID$[esp+24], 1
$L71353:

; 3277 :   }
; 3278 : 
; 3279 : 
; 3280 :   /********************************************************************/
; 3281 :   /*  If a wave output device supporting the request format was not   */
; 3282 :   /*  found, it might be because all devices supporting the requested */
; 3283 :   /*  format are busy and busy devices do not return a bad format     */
; 3284 :   /*  status even if the format is unsupported. This not the case for */
; 3285 :   /*  the MME server, but in any event, this extra check cannot hurt. */
; 3286 :   /*  In this case, device support only for mulaw and certain PCM     */
; 3287 :   /*  formats can be checked.                                         */
; 3288 :   /********************************************************************/
; 3289 : 
; 3290 :   mmStatus = MMSYSERR_NOERROR;
; 3291 : 
; 3292 :   if (( ! bGotDeviceID ) && ( bAllocated ))

  00f88	8b 44 24 10	 mov	 eax, DWORD PTR _bGotDeviceID$[esp+24]
  00f8c	33 ff		 xor	 edi, edi
  00f8e	85 c0		 test	 eax, eax
  00f90	75 74		 jne	 SHORT $L71447
  00f92	8b 44 24 14	 mov	 eax, DWORD PTR _bAllocated$[esp+24]
  00f96	85 c0		 test	 eax, eax
  00f98	74 6c		 je	 SHORT $L71447

; 3293 :   {
; 3294 :     /********************************************************************/
; 3295 :     /*  If the wave format tag is equal to either WAVE_FORMAT_PCM or to */
; 3296 :     /*  WAVE_FORMAT_08M08 then test the device capabilities.            */
; 3297 :     /********************************************************************/
; 3298 : 
; 3299 :     bIsStandardFormat = TRUE;
; 3300 : 
; 3301 :     switch ( pWaveFormat->wFormatTag )
; 3302 :     {

  00f9a	33 c0		 xor	 eax, eax
  00f9c	66 8b 06	 mov	 ax, WORD PTR [esi]
  00f9f	48		 dec	 eax
  00fa0	74 22		 je	 SHORT $L71359
  00fa2	83 e8 06	 sub	 eax, 6
  00fa5	75 53		 jne	 SHORT $L71435

; 3489 :       }
; 3490 : 
; 3491 :       break;
; 3492 : 
; 3493 :     case WAVE_FORMAT_08M08:
; 3494 : 
; 3495 :         if (( pWaveFormat->nSamplesPerSec == 8000 )
; 3496 :           && ( pWaveFormat->nChannels == 1 )
; 3497 :           && ( pWaveFormat->wBitsPerSample == 8 ))

  00fa7	81 7e 04 40 1f
	00 00		 cmp	 DWORD PTR [esi+4], 8000	; 00001f40H
  00fae	75 4a		 jne	 SHORT $L71435
  00fb0	66 83 7e 02 01	 cmp	 WORD PTR [esi+2], 1
  00fb5	75 43		 jne	 SHORT $L71435
  00fb7	66 83 7e 0e 08	 cmp	 WORD PTR [esi+14], 8

; 3498 :         {
; 3499 :           dwDesiredFormat = WAVE_FORMAT_08M08;
; 3500 :         }
; 3501 :         else

  00fbc	0f 84 82 00 00
	00		 je	 $L72141

; 3502 :         {
; 3503 :           bIsStandardFormat = FALSE;;
; 3504 :         }
; 3505 : 
; 3506 :         break;

  00fc2	eb 36		 jmp	 SHORT $L71435
$L71359:

; 3303 :     /********************************************************************/
; 3304 :     /*  Determine the identifier returned in the dwFormat element       */
; 3305 :     /*  of the WAVEOUTCAPS structure that corresponds to the            */
; 3306 :     /*  requested audio format.                                         */
; 3307 :     /********************************************************************/
; 3308 : 
; 3309 :     case WAVE_FORMAT_PCM:
; 3310 : 
; 3311 :       switch ( pWaveFormat->nSamplesPerSec )
; 3312 :       {

  00fc4	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00fc7	3d 11 2b 00 00	 cmp	 eax, 11025		; 00002b11H
  00fcc	74 5c		 je	 SHORT $L71364
  00fce	3d 22 56 00 00	 cmp	 eax, 22050		; 00005622H
  00fd3	74 3b		 je	 SHORT $L71386
  00fd5	3d 44 ac 00 00	 cmp	 eax, 44100		; 0000ac44H

; 3437 :           case 8:
; 3438 : 
; 3439 :             dwDesiredFormat = WAVE_FORMAT_4M08;
; 3440 :             break;
; 3441 : 
; 3442 :           case 16:
; 3443 : 
; 3444 :             dwDesiredFormat = WAVE_FORMAT_4M16;
; 3445 :             break;
; 3446 : 
; 3447 :           default:
; 3448 : 
; 3449 :             bIsStandardFormat = FALSE;;
; 3450 :             break;
; 3451 :           }
; 3452 : 
; 3453 :         case 2:
; 3454 : 
; 3455 :           switch ( pWaveFormat->wBitsPerSample )
; 3456 :           {
; 3457 :           case 8:
; 3458 : 
; 3459 :             dwDesiredFormat = WAVE_FORMAT_4S08;
; 3460 :             break;
; 3461 : 
; 3462 :           case 16:
; 3463 : 
; 3464 :             dwDesiredFormat = WAVE_FORMAT_4S16;
; 3465 :             break;
; 3466 : 
; 3467 :           default:
; 3468 : 
; 3469 :             bIsStandardFormat = FALSE;;
; 3470 :             break;
; 3471 :           }
; 3472 : 
; 3473 :         default:
; 3474 : 
; 3475 :           bIsStandardFormat = FALSE;;
; 3476 :           break;
; 3477 :         }
; 3478 : 
; 3479 :         break;
; 3480 : 
; 3481 :       /****************************************************************/
; 3482 :       /*  The sample rate is not a standard value.                    */
; 3483 :       /****************************************************************/
; 3484 : 
; 3485 :       default:
; 3486 : 
; 3487 :         bIsStandardFormat = FALSE;;
; 3488 :         break;

  00fda	75 1e		 jne	 SHORT $L71435
  00fdc	33 c0		 xor	 eax, eax
  00fde	66 8b 46 02	 mov	 ax, WORD PTR [esi+2]
  00fe2	48		 dec	 eax
  00fe3	74 05		 je	 SHORT $L71413

; 3424 : 
; 3425 :       /****************************************************************/
; 3426 :       /*  The sample rate equals 44100 Hz.                            */
; 3427 :       /****************************************************************/
; 3428 : 
; 3429 :       case 44100:
; 3430 : 
; 3431 :         switch ( pWaveFormat->nChannels )
; 3432 :         {

  00fe5	48		 dec	 eax
  00fe6	74 0c		 je	 SHORT $L71415
  00fe8	eb 10		 jmp	 SHORT $L71435
$L71413:

; 3433 :         case 1:
; 3434 : 
; 3435 :           switch ( pWaveFormat->wBitsPerSample )
; 3436 :           {

  00fea	33 c0		 xor	 eax, eax
  00fec	66 8b 46 0e	 mov	 ax, WORD PTR [esi+14]
  00ff0	89 44 24 20	 mov	 DWORD PTR 12+[esp+20], eax
$L71415:
  00ff4	33 c0		 xor	 eax, eax
  00ff6	66 8b 46 0e	 mov	 ax, WORD PTR [esi+14]
$L71435:

; 3568 :       {
; 3569 :         mmStatus = MMSYSERR_NOTSUPPORTED;
; 3570 :       }
; 3571 :     }
; 3572 :     else
; 3573 :     {
; 3574 :       /******************************************************************/
; 3575 :       /*  A non standard format is requested and some devices are busy  */
; 3576 :       /*  so they cannot be queried. Exit with failure and inform the   */
; 3577 :       /*  application that some devices are allocated.                  */
; 3578 :       /******************************************************************/
; 3579 : 
; 3580 :       pPlayAudio->uiSelectedDeviceID = WAVE_MAPPER;

  00ffa	c7 43 20 ff ff
	ff ff		 mov	 DWORD PTR [ebx+32], -1

; 3581 : 
; 3582 :       mmStatus = MMSYSERR_NOTSUPPORTED;

  01001	bf 08 00 00 00	 mov	 edi, 8
$L71447:

; 3583 :     }
; 3584 :   }
; 3585 : 
; 3586 :   return mmStatus;

  01006	8b c7		 mov	 eax, edi
  01008	5f		 pop	 edi
  01009	5e		 pop	 esi
  0100a	5d		 pop	 ebp
  0100b	5b		 pop	 ebx

; 3587 : }

  0100c	83 c4 08	 add	 esp, 8
  0100f	c3		 ret	 0
$L71386:

; 3325 :           case 8:
; 3326 : 
; 3327 :             dwDesiredFormat = WAVE_FORMAT_1M08;
; 3328 :             break;
; 3329 : 
; 3330 :           case 16:
; 3331 : 
; 3332 :             dwDesiredFormat = WAVE_FORMAT_1M16;
; 3333 :             break;
; 3334 : 
; 3335 :           default:
; 3336 : 
; 3337 :             bIsStandardFormat = FALSE;;
; 3338 :             break;
; 3339 :           }
; 3340 : 
; 3341 :         case 2:
; 3342 : 
; 3343 :           switch ( pWaveFormat->wBitsPerSample )
; 3344 :           {
; 3345 :           case 8:
; 3346 : 
; 3347 :             dwDesiredFormat = WAVE_FORMAT_1S08;
; 3348 :             break;
; 3349 : 
; 3350 :           case 16:
; 3351 : 
; 3352 :             dwDesiredFormat = WAVE_FORMAT_1S16;
; 3353 :             break;
; 3354 : 
; 3355 :           default:
; 3356 : 
; 3357 :             bIsStandardFormat = FALSE;;
; 3358 :             break;
; 3359 :           }
; 3360 : 
; 3361 :         default:
; 3362 : 
; 3363 :           bIsStandardFormat = FALSE;;
; 3364 :           break;
; 3365 :         }
; 3366 : 
; 3367 :         break;
; 3368 : 
; 3369 :       /****************************************************************/
; 3370 :       /*  The sample rate equals 22050 Hz.                            */
; 3371 :       /****************************************************************/
; 3372 : 
; 3373 :       case 22050:
; 3374 : 
; 3375 :         switch ( pWaveFormat->nChannels )
; 3376 :         {

  01010	33 c0		 xor	 eax, eax
  01012	66 8b 46 02	 mov	 ax, WORD PTR [esi+2]
  01016	48		 dec	 eax
  01017	74 05		 je	 SHORT $L71391
  01019	48		 dec	 eax
  0101a	74 d8		 je	 SHORT $L71415
  0101c	eb dc		 jmp	 SHORT $L71435
$L71391:

; 3377 :         case 1:
; 3378 : 
; 3379 :           switch ( pWaveFormat->wBitsPerSample )
; 3380 :           {

  0101e	33 c9		 xor	 ecx, ecx
  01020	66 8b 4e 0e	 mov	 cx, WORD PTR [esi+14]
  01024	89 4c 24 20	 mov	 DWORD PTR 12+[esp+20], ecx

; 3381 :           case 8:
; 3382 : 
; 3383 :             dwDesiredFormat = WAVE_FORMAT_2M08;
; 3384 :             break;
; 3385 : 
; 3386 :           case 16:
; 3387 : 
; 3388 :             dwDesiredFormat = WAVE_FORMAT_2M16;
; 3389 :             break;
; 3390 : 
; 3391 :           default:
; 3392 : 
; 3393 :             bIsStandardFormat = FALSE;;
; 3394 :             break;
; 3395 :           }
; 3396 : 
; 3397 :         case 2:
; 3398 : 
; 3399 :           switch ( pWaveFormat->wBitsPerSample )
; 3400 :           {
; 3401 :           case 8:
; 3402 : 
; 3403 :             dwDesiredFormat = WAVE_FORMAT_2S08;
; 3404 :             break;
; 3405 : 
; 3406 :           case 16:
; 3407 : 
; 3408 :             dwDesiredFormat = WAVE_FORMAT_2S16;
; 3409 :             break;
; 3410 : 
; 3411 :           default:
; 3412 : 
; 3413 :             bIsStandardFormat = FALSE;;
; 3414 :             break;
; 3415 :           }
; 3416 : 
; 3417 :         default:
; 3418 : 
; 3419 :           bIsStandardFormat = FALSE;;
; 3420 :           break;
; 3421 :         }
; 3422 : 
; 3423 :         break;

  01028	eb ca		 jmp	 SHORT $L71415
$L71364:

; 3313 :       /******************************************************************/
; 3314 :       /*  The sample rate equals 11025 Hz.                              */
; 3315 :       /******************************************************************/
; 3316 : 
; 3317 :       case 11025:
; 3318 : 
; 3319 :         switch ( pWaveFormat->nChannels )
; 3320 :         {

  0102a	33 c0		 xor	 eax, eax
  0102c	66 8b 46 02	 mov	 ax, WORD PTR [esi+2]
  01030	48		 dec	 eax
  01031	74 05		 je	 SHORT $L71369
  01033	48		 dec	 eax
  01034	74 be		 je	 SHORT $L71415
  01036	eb c2		 jmp	 SHORT $L71435
$L71369:

; 3321 :         case 1:
; 3322 : 
; 3323 :           switch ( pWaveFormat->wBitsPerSample )
; 3324 :           {

  01038	33 d2		 xor	 edx, edx
  0103a	66 8b 56 0e	 mov	 dx, WORD PTR [esi+14]
  0103e	89 54 24 20	 mov	 DWORD PTR 12+[esp+20], edx

; 3507 : 
; 3508 :     default:
; 3509 : 
; 3510 :       bIsStandardFormat = FALSE;;
; 3511 :       break;
; 3512 :     }
; 3513 : 
; 3514 :     if ( bIsStandardFormat )

  01042	eb b0		 jmp	 SHORT $L71415
$L72141:

; 3515 :     {
; 3516 :       /******************************************************************/
; 3517 :       /*  Get the wave output device capabilities.                      */
; 3518 :       /*  First allocate memory for the WAVEOUTCAPS structure.          */
; 3519 :       /******************************************************************/
; 3520 : 
; 3521 :       LOCK_MME_CALL(
; 3522 :         pWaveOutCaps = (LPWAVEOUTCAPS)ALLOCATE_SERVER_MEM(sizeof(WAVEOUTCAPS)))

  01044	6a 34		 push	 52			; 00000034H
  01046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0104c	8b d8		 mov	 ebx, eax

; 3523 : 
; 3524 :       if ( pWaveOutCaps == NULL )

  0104e	33 f6		 xor	 esi, esi
  01050	83 c4 04	 add	 esp, 4
  01053	3b de		 cmp	 ebx, esi
  01055	75 0d		 jne	 SHORT $L71439
  01057	5f		 pop	 edi
  01058	5e		 pop	 esi
  01059	5d		 pop	 ebp

; 3525 :       {
; 3526 :         return MMSYSERR_NOMEM;

  0105a	b8 07 00 00 00	 mov	 eax, 7
  0105f	5b		 pop	 ebx

; 3587 : }

  01060	83 c4 08	 add	 esp, 8
  01063	c3		 ret	 0
$L71439:

; 3527 :       }
; 3528 : 
; 3529 :       /******************************************************************/
; 3530 :       /*  Test for the supported format.                                */
; 3531 :       /******************************************************************/
; 3532 : 
; 3533 :       bGotDeviceID = FALSE;
; 3534 : 
; 3535 :       for ( uiDeviceID = 0;
; 3536 :             uiDeviceID <= uiNumberOfWaveOutDevices - 1;
; 3537 :             uiDeviceID++ )

  01064	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__waveOutGetDevCapsA@12
  0106a	89 74 24 10	 mov	 DWORD PTR _bGotDeviceID$[esp+24], esi
$L71440:

; 3538 :       {
; 3539 :         LOCK_MME_CALL(
; 3540 :           mmStatus = waveOutGetDevCaps( uiDeviceID,
; 3541 :                                         pWaveOutCaps,
; 3542 :                                         sizeof(WAVEOUTCAPS)))

  0106e	6a 34		 push	 52			; 00000034H
  01070	53		 push	 ebx
  01071	56		 push	 esi
  01072	ff d5		 call	 ebp
  01074	8b f8		 mov	 edi, eax

; 3543 : 	 
; 3544 :         if ( mmStatus )

  01076	85 ff		 test	 edi, edi
  01078	75 21		 jne	 SHORT $L71442

; 3545 :         {
; 3546 :           break;
; 3547 :         }
; 3548 : 
; 3549 :         if ( pWaveOutCaps->dwFormats == dwDesiredFormat )

  0107a	83 7b 28 07	 cmp	 DWORD PTR [ebx+40], 7
  0107e	74 0c		 je	 SHORT $L72135
  01080	8b 44 24 20	 mov	 eax, DWORD PTR _uiNumberOfWaveOutDevices$[esp+20]
  01084	46		 inc	 esi
  01085	48		 dec	 eax
  01086	3b f0		 cmp	 esi, eax
  01088	76 e4		 jbe	 SHORT $L71440
  0108a	eb 0f		 jmp	 SHORT $L71442
$L72135:

; 3550 :         {
; 3551 :           bGotDeviceID = TRUE;
; 3552 :           pPlayAudio->uiSelectedDeviceID = uiDeviceID;

  0108c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _pPlayAudio$[esp+20]
  01090	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _bGotDeviceID$[esp+24], 1
  01098	89 71 20	 mov	 DWORD PTR [ecx+32], esi
$L71442:

; 3553 :           break;
; 3554 :         }
; 3555 :       }
; 3556 : 
; 3557 :       /******************************************************************/
; 3558 :       /*  Free memory for the WAVEOUTCAPS structure.                    */
; 3559 :       /******************************************************************/
; 3560 : 
; 3561 :       LOCK_MME_CALL( FREE_SERVER_MEM( pWaveOutCaps ))

  0109b	53		 push	 ebx
  0109c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free

; 3562 : 	  
; 3563 :       /******************************************************************/
; 3564 :       /*  If no device supported the format then return an error.       */
; 3565 :       /******************************************************************/
; 3566 : 	  
; 3567 :       if ( ! bGotDeviceID )

  010a2	8b 44 24 14	 mov	 eax, DWORD PTR _bGotDeviceID$[esp+28]
  010a6	83 c4 04	 add	 esp, 4
  010a9	85 c0		 test	 eax, eax
  010ab	0f 85 55 ff ff
	ff		 jne	 $L71447

; 3581 : 
; 3582 :       mmStatus = MMSYSERR_NOTSUPPORTED;

  010b1	bf 08 00 00 00	 mov	 edi, 8

; 3583 :     }
; 3584 :   }
; 3585 : 
; 3586 :   return mmStatus;

  010b6	8b c7		 mov	 eax, edi
  010b8	5f		 pop	 edi
  010b9	5e		 pop	 esi
  010ba	5d		 pop	 ebp
  010bb	5b		 pop	 ebx

; 3587 : }

  010bc	83 c4 08	 add	 esp, 8
  010bf	c3		 ret	 0
_DetermineDeviceID ENDP
_TEXT	ENDS
PUBLIC	__real@8@4008fa00000000000000
EXTRN	__ftol:NEAR
EXTRN	__fltused:NEAR
EXTRN	_OP_ExitThread:NEAR
;	COMDAT __real@8@4008fa00000000000000
; File D:\work\Product\dapi\src\NT\playaud.c
CONST	SEGMENT
__real@8@4008fa00000000000000 DQ 0408f400000000000r ; 1000
CONST	ENDS
_TEXT	SEGMENT
_pPlayAudio$ = 8
_uiStartupTimeoutTime$ = -24
_bDidBlock$ = -20
_dwSyncMarkPosition$ = -28
_dwCurrentPosition$ = 8
_pPlayAudioRing$ = -32
_TimerThreadMain PROC NEAR

; 3683 : {

  010c0	83 ec 20	 sub	 esp, 32			; 00000020H
  010c3	55		 push	 ebp
  010c4	56		 push	 esi

; 3684 :   unsigned int uiAvgBytesPerSec;
; 3685 :   unsigned int uiFlowCheckTime;
; 3686 :   unsigned int uiLastQueueCount;
; 3687 :   unsigned int uiCurrentQueueCount;
; 3688 :   unsigned int uiStartupTimeoutTime;
; 3689 :   unsigned int uiElapsedTime;
; 3690 :   unsigned int uiWaitTime;
; 3691 :   BOOL	bDidBlock=FALSE;	//tek 28jan98 BATS 532 reduce CPU consumption
; 3692 :   DWORD dwSyncMarkPosition=0;
; 3693 :   DWORD dwCurrentPosition;
; 3694 :   MMRESULT mmStatus;
; 3695 :   ATYPE_T aSyncMarkTag;
; 3696 :   LPSYNC_MARK_T pSyncMark;
; 3697 :   LPSYNC_MARK_T pNextSyncMark;
; 3698 :   LPPLAY_RING_T pPlayAudioRing;
; 3699 : 
; 3700 :   /********************************************************************/
; 3701 :   /*  Initialize the timer count to 0. This is used to count the      */
; 3702 :   /*  number of consecutive times that audio is in the queue and the  */
; 3703 :   /*  audio device is not active.                                     */
; 3704 :   /********************************************************************/
; 3705 : 
; 3706 :   uiElapsedTime = 0;
; 3707 : 
; 3708 :   pPlayAudioRing = pPlayAudio->pPlayAudioRing;

  010c5	8b 74 24 2c	 mov	 esi, DWORD PTR _pPlayAudio$[esp+36]
  010c9	33 ed		 xor	 ebp, ebp
  010cb	89 6c 24 0c	 mov	 DWORD PTR _dwSyncMarkPosition$[esp+40], ebp
  010cf	8b 86 98 00 00
	00		 mov	 eax, DWORD PTR [esi+152]
  010d5	89 44 24 08	 mov	 DWORD PTR _pPlayAudioRing$[esp+40], eax

; 3709 : 
; 3710 :   /********************************************************************/
; 3711 :   /*  Loop forever until thread shutdown time.                        */
; 3712 :   /********************************************************************/
; 3713 : 
; 3714 :   while( ! pPlayAudio->bTimerExit )

  010d9	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  010dc	85 c0		 test	 eax, eax
  010de	0f 85 d5 03 00
	00		 jne	 $L72155
  010e4	53		 push	 ebx
  010e5	57		 push	 edi
$L71468:

; 3715 :   {
; 3716 :     pPlayAudio->bTimerThreadReset = FALSE;
; 3717 : 	bDidBlock = FALSE; //tek 28jan98 keep track when we block ourselves
; 3718 : 
; 3719 :     /******************************************************************/
; 3720 :     /******************************************************************/
; 3721 :     /*  If audio is playing then test to see if there are any         */
; 3722 :     /*  synchronization marks that need to be reported.               */
; 3723 :     /*  If there are then get the current "play audio" position.      */
; 3724 :     /******************************************************************/
; 3725 :     /******************************************************************/
; 3726 : 
; 3727 :     if (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )
; 3728 :         && ( pPlayAudio->pSyncMarkList != NULL ))

  010e6	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  010e9	bb 02 00 00 00	 mov	 ebx, 2
  010ee	33 ff		 xor	 edi, edi
  010f0	3b c3		 cmp	 eax, ebx
  010f2	89 7e 6c	 mov	 DWORD PTR [esi+108], edi
  010f5	89 7c 24 1c	 mov	 DWORD PTR _bDidBlock$[esp+48], edi
  010f9	75 29		 jne	 SHORT $L71471
  010fb	39 be 9c 00 00
	00		 cmp	 DWORD PTR [esi+156], edi
  01101	74 21		 je	 SHORT $L71471

; 3729 :     {
; 3730 :       /****************************************************************/
; 3731 :       /*  Get the current audio position.                             */
; 3732 :       /****************************************************************/
; 3733 : 
; 3734 :       mmStatus = PA_GetPosition( pPlayAudio,
; 3735 :                                  &dwCurrentPosition,
; 3736 :                                  FALSE );

  01103	8d 4c 24 34	 lea	 ecx, DWORD PTR _dwCurrentPosition$[esp+44]
  01107	57		 push	 edi
  01108	51		 push	 ecx
  01109	56		 push	 esi
  0110a	e8 00 00 00 00	 call	 _PA_GetPosition
  0110f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3737 :       if ( mmStatus )

  01112	3b c7		 cmp	 eax, edi
  01114	74 48		 je	 SHORT $L72148

; 3738 :       {
; 3739 : #ifdef AUD_DEBUG
; 3740 : 		OutputDebugString("TimerThreadMain: PA_GetPosition failed {1}\n");
; 3741 : #endif
; 3742 :         ReportStatusToApplication( pPlayAudio,
; 3743 :                                    PA_SYNC_ERROR,
; 3744 :                                    mmStatus );

  01116	50		 push	 eax
  01117	6a 05		 push	 5
  01119	56		 push	 esi
  0111a	e8 00 00 00 00	 call	 _ReportStatusToApplication
  0111f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3745 :       }
; 3746 :     }
; 3747 :     else

  01122	eb 3a		 jmp	 SHORT $L72148
$L71471:

; 3748 :     {
; 3749 :       /****************************************************************/
; 3750 :       /*  In case the audio device becomes active between this if     */
; 3751 :       /*  statement and the following code (this will only happen     */
; 3752 :       /*  very infrequently) make sure that the current position      */
; 3753 :       /*  variable is less than any non-zero synchronization mark     */
; 3754 :       /*  position.                                                   */
; 3755 :       /****************************************************************/
; 3756 : 
; 3757 :       OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  01124	8b 96 8c 00 00
	00		 mov	 edx, DWORD PTR [esi+140]
  0112a	52		 push	 edx
  0112b	e8 00 00 00 00	 call	 _OP_LockMutex

; 3758 : 
; 3759 :       if ( pPlayAudio->pSyncMarkList != NULL )

  01130	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  01136	83 c4 04	 add	 esp, 4
  01139	3b c7		 cmp	 eax, edi
  0113b	74 12		 je	 SHORT $L71477

; 3760 :       {
; 3761 :         if ( pPlayAudio->pSyncMarkList->dwPosition == 0 )

  0113d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  01140	3b c7		 cmp	 eax, edi
  01142	75 06		 jne	 SHORT $L71476

; 3762 :         {
; 3763 :           dwCurrentPosition = 0;

  01144	89 7c 24 34	 mov	 DWORD PTR _dwCurrentPosition$[esp+44], edi

; 3764 :         }
; 3765 :         else

  01148	eb 05		 jmp	 SHORT $L71477
$L71476:

; 3766 :         {
; 3767 :           dwCurrentPosition = pPlayAudio->pSyncMarkList->dwPosition - 1;

  0114a	48		 dec	 eax
  0114b	89 44 24 34	 mov	 DWORD PTR _dwCurrentPosition$[esp+44], eax
$L71477:

; 3768 :         }
; 3769 :       }
; 3770 : 
; 3771 :       OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  0114f	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  01155	50		 push	 eax
  01156	e8 00 00 00 00	 call	 _OP_UnlockMutex
  0115b	83 c4 04	 add	 esp, 4
$L72148:

; 3772 :     }
; 3773 : 
; 3774 :     /******************************************************************/
; 3775 :     /******************************************************************/
; 3776 :     /*  If audio is playing then loop while there are synchronization */
; 3777 :     /*  marks that need to be reported. Don't bother if the audio is  */
; 3778 :     /*  paused.                                                       */
; 3779 :     /******************************************************************/
; 3780 :     /******************************************************************/
; 3781 : 
; 3782 :     while (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )
; 3783 :         && ( pPlayAudio->pSyncMarkList != NULL )
; 3784 :         && ( ! pPlayAudio->bPaused )
; 3785 :         && ( ! pPlayAudio->bTimerThreadReset ))

  0115e	39 5e 34	 cmp	 DWORD PTR [esi+52], ebx
  01161	0f 85 3d 01 00
	00		 jne	 $L71481
$L71480:
  01167	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  0116d	85 c0		 test	 eax, eax
  0116f	0f 84 2f 01 00
	00		 je	 $L71481
  01175	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  01178	85 c0		 test	 eax, eax
  0117a	0f 85 24 01 00
	00		 jne	 $L71481
  01180	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  01183	85 c0		 test	 eax, eax
  01185	0f 85 19 01 00
	00		 jne	 $L71481

; 3786 :     {
; 3787 :       /****************************************************************/
; 3788 :       /*  See if the marked position has been encountered yet.        */
; 3789 :       /*  Synchonization mark information is protected by mutex's in  */
; 3790 :       /*  case the synchronization linked list is emptied when the    */
; 3791 :       /*  PA_Reset() function is called.                              */
; 3792 :       /****************************************************************/
; 3793 : 
; 3794 :       OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  0118b	8b 8e 8c 00 00
	00		 mov	 ecx, DWORD PTR [esi+140]
  01191	51		 push	 ecx
  01192	e8 00 00 00 00	 call	 _OP_LockMutex

; 3795 : 
; 3796 :       pSyncMark = pPlayAudio->pSyncMarkList;

  01197	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  0119d	83 c4 04	 add	 esp, 4

; 3797 : 
; 3798 :       if ( pSyncMark != NULL )

  011a0	85 c0		 test	 eax, eax
  011a2	74 09		 je	 SHORT $L71483

; 3799 :       {
; 3800 :         dwSyncMarkPosition = pSyncMark->dwPosition;

  011a4	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  011a7	89 54 24 14	 mov	 DWORD PTR _dwSyncMarkPosition$[esp+48], edx
  011ab	8b ea		 mov	 ebp, edx
$L71483:

; 3801 :       }
; 3802 : 
; 3803 :       OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  011ad	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  011b3	50		 push	 eax
  011b4	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 3804 : 
; 3805 :       /****************************************************************/
; 3806 :       /*  Tsst to see if the position counter has wrapped back to     */
; 3807 :       /*  zero. This will only happen after audio has been playing a  */
; 3808 :       /*  very long time. The marked position count and the current   */
; 3809 :       /*  position count can only differ by the time it takes to play */
; 3810 :       /*  all of the audio in the ring buffer. This is at most a few  */
; 3811 :       /*  seconds, even at the lowest supported sample rate. So if    */
; 3812 :       /*  the wait time is more than a few seconds then the position  */
; 3813 :       /*  count has wrapped and the synchronization mark should be    */
; 3814 :       /*  reported immediately.                                       */
; 3815 :       /****************************************************************/
; 3816 : 
; 3817 :       uiWaitTime = dwSyncMarkPosition - dwCurrentPosition;

  011b9	8b 44 24 38	 mov	 eax, DWORD PTR _dwCurrentPosition$[esp+48]
  011bd	8b fd		 mov	 edi, ebp
  011bf	83 c4 04	 add	 esp, 4
  011c2	2b f8		 sub	 edi, eax

; 3818 : 
; 3819 :       while (( dwCurrentPosition < dwSyncMarkPosition )
; 3820 :         && ( uiWaitTime < POSITION_COUNT_WRAP_TIME )
; 3821 :         && ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )
; 3822 :         && ( pPlayAudio->pSyncMarkList != NULL )
; 3823 :         && ( ! pPlayAudio->bPaused )
; 3824 :         && ( ! pPlayAudio->bTimerThreadReset ))

  011c4	3b c5		 cmp	 eax, ebp
  011c6	73 5b		 jae	 SHORT $L71487
$L71486:
  011c8	81 ff 40 42 0f
	00		 cmp	 edi, 1000000		; 000f4240H
  011ce	73 53		 jae	 SHORT $L71487
  011d0	39 5e 34	 cmp	 DWORD PTR [esi+52], ebx
  011d3	75 4e		 jne	 SHORT $L71487
  011d5	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  011db	85 c0		 test	 eax, eax
  011dd	74 44		 je	 SHORT $L71487
  011df	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  011e2	85 c0		 test	 eax, eax
  011e4	75 3d		 jne	 SHORT $L71487
  011e6	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  011e9	85 c0		 test	 eax, eax
  011eb	75 36		 jne	 SHORT $L71487

; 3825 :       {
; 3826 :         if ( uiWaitTime > MAXIMUM_POSITION_SLEEP_TIME )

  011ed	83 ff 64	 cmp	 edi, 100		; 00000064H
  011f0	76 05		 jbe	 SHORT $L71488

; 3827 :         {
; 3828 :           uiWaitTime = MAXIMUM_POSITION_SLEEP_TIME;

  011f2	bf 64 00 00 00	 mov	 edi, 100		; 00000064H
$L71488:

; 3829 :         }
; 3830 : 
; 3831 :         OP_Sleep( uiWaitTime );

  011f7	57		 push	 edi
  011f8	e8 00 00 00 00	 call	 _OP_Sleep

; 3832 : 
; 3833 :         /**************************************************************/
; 3834 :         /*  Get the current audio position.                           */
; 3835 :         /**************************************************************/
; 3836 : 
; 3837 :         mmStatus = PA_GetPosition( pPlayAudio,
; 3838 :                                    &dwCurrentPosition,
; 3839 :                                    FALSE );

  011fd	8d 4c 24 38	 lea	 ecx, DWORD PTR _dwCurrentPosition$[esp+48]
  01201	6a 00		 push	 0
  01203	51		 push	 ecx
  01204	56		 push	 esi
  01205	e8 00 00 00 00	 call	 _PA_GetPosition
  0120a	83 c4 10	 add	 esp, 16			; 00000010H

; 3840 : 
; 3841 :         if ( mmStatus )

  0120d	85 c0		 test	 eax, eax
  0120f	74 0c		 je	 SHORT $L71489

; 3842 :         {
; 3843 : #ifdef AUD_DEBUG
; 3844 : 		  OutputDebugString("TimerThreadMain: PA_GetPosition failed {2}\n");
; 3845 : #endif
; 3846 :           ReportStatusToApplication( pPlayAudio,
; 3847 :                                      PA_SYNC_ERROR,
; 3848 :                                      mmStatus );

  01211	50		 push	 eax
  01212	6a 05		 push	 5
  01214	56		 push	 esi
  01215	e8 00 00 00 00	 call	 _ReportStatusToApplication
  0121a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71489:
  0121d	39 6c 24 34	 cmp	 DWORD PTR _dwCurrentPosition$[esp+44], ebp
  01221	72 a5		 jb	 SHORT $L71486
$L71487:

; 3849 :         }
; 3850 :       }
; 3851 : 
; 3852 :       /****************************************************************/
; 3853 :       /*  Report the mark to the application.                         */
; 3854 :       /****************************************************************/
; 3855 : 
; 3856 :       OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  01223	8b 96 8c 00 00
	00		 mov	 edx, DWORD PTR [esi+140]
  01229	52		 push	 edx
  0122a	e8 00 00 00 00	 call	 _OP_LockMutex

; 3857 : 
; 3858 :       pSyncMark = pPlayAudio->pSyncMarkList;

  0122f	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  01235	83 c4 04	 add	 esp, 4

; 3859 : 
; 3860 :       if (( pSyncMark != NULL )
; 3861 :         && (( dwCurrentPosition >= pSyncMark->dwPosition )
; 3862 :         || ( uiWaitTime >= POSITION_COUNT_WRAP_TIME ))
; 3863 :         && ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )
; 3864 :         && ( ! pPlayAudio->bTimerThreadReset ))

  01238	85 c0		 test	 eax, eax
  0123a	74 50		 je	 SHORT $L71491
  0123c	8b 4c 24 34	 mov	 ecx, DWORD PTR _dwCurrentPosition$[esp+44]
  01240	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  01243	3b ca		 cmp	 ecx, edx
  01245	73 08		 jae	 SHORT $L71492
  01247	81 ff 40 42 0f
	00		 cmp	 edi, 1000000		; 000f4240H
  0124d	72 3d		 jb	 SHORT $L71491
$L71492:
  0124f	39 5e 34	 cmp	 DWORD PTR [esi+52], ebx
  01252	75 38		 jne	 SHORT $L71491
  01254	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  01257	85 c9		 test	 ecx, ecx
  01259	75 31		 jne	 SHORT $L71491

; 3865 :       {
; 3866 :         /**************************************************************/
; 3867 :         /*  Remove the pointer to the next synchronization mark       */
; 3868 :         /*  structure from the top of the synchronization mark        */
; 3869 :         /*  linked list.                                              */
; 3870 :         /**************************************************************/
; 3871 : 
; 3872 :         aSyncMarkTag = pSyncMark->aTag;

  0125b	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 3873 :         pNextSyncMark = pSyncMark->pLink;

  0125e	8b 18		 mov	 ebx, DWORD PTR [eax]

; 3874 : 
; 3875 :         free( pSyncMark );

  01260	50		 push	 eax
  01261	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free

; 3876 : 
; 3877 :         pPlayAudio->pSyncMarkList = pNextSyncMark;
; 3878 : 
; 3879 :         OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  01267	8b 96 8c 00 00
	00		 mov	 edx, DWORD PTR [esi+140]
  0126d	89 9e 9c 00 00
	00		 mov	 DWORD PTR [esi+156], ebx
  01273	52		 push	 edx
  01274	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 3880 : 
; 3881 :         /**************************************************************/
; 3882 :         /*  Report the synchronization mark.                          */
; 3883 :         /**************************************************************/
; 3884 : 
; 3885 :         ReportStatusToApplication( pPlayAudio,
; 3886 :                                    PA_SYNC_MARK,
; 3887 :                                    aSyncMarkTag );

  01279	57		 push	 edi
  0127a	6a 04		 push	 4
  0127c	56		 push	 esi
  0127d	e8 00 00 00 00	 call	 _ReportStatusToApplication
  01282	83 c4 14	 add	 esp, 20			; 00000014H

; 3888 :       }
; 3889 :       else

  01285	bb 02 00 00 00	 mov	 ebx, 2
  0128a	eb 0f		 jmp	 SHORT $L71493
$L71491:

; 3890 :       {
; 3891 :         OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  0128c	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  01292	50		 push	 eax
  01293	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01298	83 c4 04	 add	 esp, 4
$L71493:
  0129b	39 5e 34	 cmp	 DWORD PTR [esi+52], ebx
  0129e	0f 84 c3 fe ff
	ff		 je	 $L71480
$L71481:

; 3892 :       }
; 3893 :     }
; 3894 : 
; 3895 :     /******************************************************************/
; 3896 :     /******************************************************************/
; 3897 :     /*  If audio is NOT playing and the system is NOT paused and      */
; 3898 :     /*  there are samples in the queue then test to see if it will    */
; 3899 :     /*  be necessary to start playing audio.                          */
; 3900 :     /******************************************************************/
; 3901 :     /******************************************************************/
; 3902 : 
; 3903 :     /******************************************************************/
; 3904 :     /*  Calculate how long to sleep.                                  */
; 3905 :     /******************************************************************/
; 3906 : 
; 3907 : 		// 22may97 tek remove KSBs NEED_FOR_SPEED.
; 3908 :     OP_LockMutex( pPlayAudio->hmxWaveFormat );

  012a4	8b 8e 90 00 00
	00		 mov	 ecx, DWORD PTR [esi+144]
  012aa	51		 push	 ecx
  012ab	e8 00 00 00 00	 call	 _OP_LockMutex

; 3909 :     uiAvgBytesPerSec = pPlayAudio->pWaveFormat->nAvgBytesPerSec;

  012b0	8b 96 a0 00 00
	00		 mov	 edx, DWORD PTR [esi+160]

; 3910 :     OP_UnlockMutex( pPlayAudio->hmxWaveFormat );

  012b6	8b 86 90 00 00
	00		 mov	 eax, DWORD PTR [esi+144]
  012bc	50		 push	 eax
  012bd	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
  012c0	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 3911 : 
; 3912 :     uiStartupTimeoutTime = (unsigned int)( 1000.0 *
; 3913 :       (double)(pPlayAudio->uiMinimumStartupBytes) /
; 3914 :         (double)uiAvgBytesPerSec );

  012c5	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  012c8	33 c0		 xor	 eax, eax
  012ca	89 4c 24 28	 mov	 DWORD PTR -16+[esp+56], ecx
  012ce	89 44 24 2c	 mov	 DWORD PTR -16+[esp+60], eax
  012d2	df 6c 24 28	 fild	 QWORD PTR -16+[esp+56]
  012d6	89 7c 24 30	 mov	 DWORD PTR -8+[esp+56], edi
  012da	89 44 24 34	 mov	 DWORD PTR -8+[esp+60], eax
  012de	83 c4 08	 add	 esp, 8
  012e1	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@8@4008fa00000000000000
  012e7	df 6c 24 28	 fild	 QWORD PTR -8+[esp+48]
  012eb	de f9		 fdivp	 ST(1), ST(0)
  012ed	e8 00 00 00 00	 call	 __ftol

; 3915 : 
; 3916 :     /******************************************************************/
; 3917 :     /*  Limit the total startup check wait time to 1 second.          */
; 3918 :     /******************************************************************/
; 3919 : 
; 3920 :     if ( uiStartupTimeoutTime > 1000 )

  012f2	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  012f7	89 44 24 18	 mov	 DWORD PTR _uiStartupTimeoutTime$[esp+48], eax
  012fb	76 08		 jbe	 SHORT $L72150

; 3921 :     {
; 3922 :       uiStartupTimeoutTime = 1000;

  012fd	c7 44 24 18 e8
	03 00 00	 mov	 DWORD PTR _uiStartupTimeoutTime$[esp+48], 1000 ; 000003e8H
$L72150:

; 3923 :     }
; 3924 : 
; 3925 :     while (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )
; 3926 :       && ( ! pPlayAudio->bPaused )
; 3927 :       && ( pPlayAudio->pPlayAudioRing->iQueueCount > 0 ))

  01305	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  01308	85 c0		 test	 eax, eax
  0130a	0f 85 a1 00 00
	00		 jne	 $L72153
  01310	eb 09		 jmp	 SHORT $L71499
$L72161:
  01312	8b 6c 24 14	 mov	 ebp, DWORD PTR _dwSyncMarkPosition$[esp+48]
  01316	bb 02 00 00 00	 mov	 ebx, 2
$L71499:
  0131b	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  0131e	85 c0		 test	 eax, eax
  01320	0f 85 8b 00 00
	00		 jne	 $L72153
  01326	8b 96 98 00 00
	00		 mov	 edx, DWORD PTR [esi+152]
  0132c	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0132f	85 c0		 test	 eax, eax
  01331	7e 7e		 jle	 SHORT $L72153

; 3928 :     {
; 3929 : 		// 22may97 tek remove KSBs NEED_FOR_SPEED.
; 3930 :       /****************************************************************/
; 3931 :       /*  Wait for "uiStartupTimeoutTime" milliseconds.               */
; 3932 :       /****************************************************************/
; 3933 : 
; 3934 :       uiElapsedTime = 0;
; 3935 :       uiFlowCheckTime = 0;
; 3936 :       uiLastQueueCount = pPlayAudioRing->iQueueCount;

  01333	8b 44 24 10	 mov	 eax, DWORD PTR _pPlayAudioRing$[esp+48]
  01337	33 ed		 xor	 ebp, ebp
  01339	33 ff		 xor	 edi, edi
  0133b	8b 58 18	 mov	 ebx, DWORD PTR [eax+24]

; 3937 : 
; 3938 :       while (( uiElapsedTime < uiStartupTimeoutTime )
; 3939 :         && ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE ))

  0133e	8b 44 24 18	 mov	 eax, DWORD PTR _uiStartupTimeoutTime$[esp+48]
  01342	85 c0		 test	 eax, eax
  01344	76 31		 jbe	 SHORT $L72152
$L71502:
  01346	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  01349	85 c0		 test	 eax, eax
  0134b	75 5b		 jne	 SHORT $L72164

; 3940 :       {
; 3941 :         OP_Sleep( TIMER_SLEEP_TIME_IN_MSEC );

  0134d	6a 0a		 push	 10			; 0000000aH
  0134f	e8 00 00 00 00	 call	 _OP_Sleep

; 3942 : 
; 3943 :         uiElapsedTime += TIMER_SLEEP_TIME_IN_MSEC;
; 3944 :         uiFlowCheckTime += TIMER_SLEEP_TIME_IN_MSEC;

  01354	83 c7 0a	 add	 edi, 10			; 0000000aH
  01357	83 c4 04	 add	 esp, 4
  0135a	83 c5 0a	 add	 ebp, 10			; 0000000aH

; 3945 : 
; 3946 :         /**************************************************************/
; 3947 :         /*  If the queue input flow rate to the PA_Queue() function   */
; 3948 :         /*  has been slower than real-time over the entire            */
; 3949 :         /*  QUEUE_FLOW_CHECK_TIME_IN_MSEC interval then start the     */
; 3950 :         /*  open now.                                                 */
; 3951 :         /**************************************************************/
; 3952 : 
; 3953 :         if ( uiFlowCheckTime > QUEUE_FLOW_CHECK_TIME_IN_MSEC )

  0135d	83 ff 64	 cmp	 edi, 100		; 00000064H
  01360	76 0f		 jbe	 SHORT $L71504

; 3954 :         {
; 3955 :           uiCurrentQueueCount = (unsigned int)pPlayAudioRing->iQueueCount;

  01362	8b 4c 24 10	 mov	 ecx, DWORD PTR _pPlayAudioRing$[esp+48]
  01366	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]

; 3956 : 
; 3957 :           if ( uiCurrentQueueCount == uiLastQueueCount )

  01369	3b c3		 cmp	 eax, ebx
  0136b	74 0a		 je	 SHORT $L72152

; 3958 :           {
; 3959 :             break;
; 3960 :           }
; 3961 : 
; 3962 :           uiLastQueueCount = uiCurrentQueueCount;

  0136d	8b d8		 mov	 ebx, eax

; 3963 :           uiFlowCheckTime = 0;

  0136f	33 ff		 xor	 edi, edi
$L71504:
  01371	3b 6c 24 18	 cmp	 ebp, DWORD PTR _uiStartupTimeoutTime$[esp+48]
  01375	72 cf		 jb	 SHORT $L71502
$L72152:

; 3964 :         }
; 3965 :       }
; 3966 : 
; 3967 :       /****************************************************************/
; 3968 :       /*  If the audio device starts playing then exit this loop.     */
; 3969 :       /****************************************************************/
; 3970 : 
; 3971 :       if ( pPlayAudio->dwAudioDeviceState != AUDIO_DEVICE_INACTIVE )

  01377	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0137a	85 c0		 test	 eax, eax
  0137c	75 2a		 jne	 SHORT $L72164

; 3972 :       {
; 3973 :         break;
; 3974 :       }
; 3975 : 
; 3976 :       /****************************************************************/
; 3977 :       /*  If audio is still NOT playing and there are samples in the  */
; 3978 :       /*  audio queue then start playing audio. It does not matter    */
; 3979 :       /*  that all of the tests this section of code are not          */
; 3980 :       /*  protected by mutex's. This is because an unnecessary        */
; 3981 :       /*  ID_Open_Wave_Output_Device messages will be discarded in    */
; 3982 :       /*  the "play audio" thread.                                    */
; 3983 :       /****************************************************************/
; 3984 : 
; 3985 :       if (( pPlayAudio->dwAudioDeviceState != AUDIO_DEVICE_ACTIVE )
; 3986 :         && ( pPlayAudioRing->iQueueCount > 0 ))

  0137e	8b 54 24 10	 mov	 edx, DWORD PTR _pPlayAudioRing$[esp+48]
  01382	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  01385	85 c0		 test	 eax, eax
  01387	7e 0d		 jle	 SHORT $L71508

; 3987 :       {
; 3988 :         SendPlayAudioMessage( pPlayAudio,
; 3989 :                               ID_Open_Wave_Output_Device,
; 3990 :                               0L );

  01389	6a 00		 push	 0
  0138b	6a 00		 push	 0
  0138d	56		 push	 esi
  0138e	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  01393	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71508:

; 3991 :       }
; 3992 : 
; 3993 :       /****************************************************************/
; 3994 :       /*  Test for thread shutdown. Shutdown is caused by the         */
; 3995 :       /*  PA_DestroyPlayHandle() function.                            */
; 3996 :       /****************************************************************/
; 3997 : 
; 3998 :       if ( pPlayAudio->bTimerExit )

  01396	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  01399	85 c0		 test	 eax, eax
  0139b	75 0b		 jne	 SHORT $L72164
  0139d	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  013a0	85 c0		 test	 eax, eax
  013a2	0f 84 6a ff ff
	ff		 je	 $L72161
$L72164:

; 3923 :     }
; 3924 : 
; 3925 :     while (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )
; 3926 :       && ( ! pPlayAudio->bPaused )
; 3927 :       && ( pPlayAudio->pPlayAudioRing->iQueueCount > 0 ))

  013a8	8b 6c 24 14	 mov	 ebp, DWORD PTR _dwSyncMarkPosition$[esp+48]
  013ac	bb 02 00 00 00	 mov	 ebx, 2
$L72153:

; 3999 :       {
; 4000 :         break;
; 4001 :       }
; 4002 :     }
; 4003 : 
; 4004 :     /******************************************************************/
; 4005 :     /*  This thread is blocked if there are no synchronization marks  */
; 4006 :     /*  waiting to be processed or the audio is paused and either     */
; 4007 :     /*  the audio device is active or the queue count is zero         */
; 4008 :     /******************************************************************/
; 4009 : 
; 4010 : 	//tek 07nov97 bats508
; 4011 : 	// as originally written, this code wants to take all the mutexes
; 4012 : 	// involved; it really need not do that, because if we make a
; 4013 : 	// mistake here we can always check before exit and fix it.
; 4014 :     OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  013b1	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  013b7	50		 push	 eax
  013b8	e8 00 00 00 00	 call	 _OP_LockMutex

; 4015 :     OP_LockMutex( pPlayAudio->hmxPauseFlag );

  013bd	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  013c3	51		 push	 ecx
  013c4	e8 00 00 00 00	 call	 _OP_LockMutex

; 4016 : 
; 4017 :     if ((( pPlayAudio->pSyncMarkList == NULL )
; 4018 :       || ( pPlayAudio->bPaused ))
; 4019 :       && ( ! pPlayAudio->bTimerExit ))

  013c9	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  013cf	83 c4 08	 add	 esp, 8
  013d2	85 c0		 test	 eax, eax
  013d4	74 0b		 je	 SHORT $L71512
  013d6	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  013d9	85 c0		 test	 eax, eax
  013db	0f 84 ea 00 00
	00		 je	 $L71511
$L71512:
  013e1	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  013e4	85 c0		 test	 eax, eax
  013e6	0f 85 df 00 00
	00		 jne	 $L71511

; 4020 :     {
; 4021 : 	  // let these go here.
; 4022 :       OP_UnlockMutex( pPlayAudio->hmxPauseFlag );

  013ec	8b 96 88 00 00
	00		 mov	 edx, DWORD PTR [esi+136]
  013f2	52		 push	 edx
  013f3	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 4023 :       OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  013f8	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  013fe	50		 push	 eax
  013ff	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 4024 :       OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  01404	8b 4e 70	 mov	 ecx, DWORD PTR [esi+112]
  01407	51		 push	 ecx
  01408	e8 00 00 00 00	 call	 _OP_LockMutex

; 4025 : 	  // tek 07nov97 bats508
; 4026 : 	  // don't need to hold the queue count mutex this early; move
; 4027 : 	  // it into the if branch
; 4028 :       //OP_LockMutex( pPlayAudio->hmxQueueCount );
; 4029 : 
; 4030 :       if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )

  0140d	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  01410	83 c4 0c	 add	 esp, 12			; 0000000cH
  01413	3b c3		 cmp	 eax, ebx
  01415	75 16		 jne	 SHORT $L71513

; 4031 :       {
; 4032 :         OP_ResetEvent( pPlayAudio->hevTimerThreadActive );

  01417	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0141a	52		 push	 edx
  0141b	e8 00 00 00 00	 call	 _OP_ResetEvent
  01420	83 c4 04	 add	 esp, 4

; 4033 : 		bDidBlock = TRUE; // tek 29jan98

  01423	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _bDidBlock$[esp+48], 1

; 4034 :       }
; 4035 :       else

  0142b	eb 37		 jmp	 SHORT $L71514
$L71513:

; 4036 :       {
; 4037 :       OP_LockMutex( pPlayAudio->hmxQueueCount );

  0142d	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  01430	50		 push	 eax
  01431	e8 00 00 00 00	 call	 _OP_LockMutex

; 4038 :         if ( pPlayAudioRing->iQueueCount == 0 )

  01436	8b 4c 24 14	 mov	 ecx, DWORD PTR _pPlayAudioRing$[esp+52]
  0143a	83 c4 04	 add	 esp, 4
  0143d	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  01440	85 c0		 test	 eax, eax
  01442	75 14		 jne	 SHORT $L71515

; 4039 :         {
; 4040 :           OP_ResetEvent( pPlayAudio->hevTimerThreadActive );

  01444	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  01447	52		 push	 edx
  01448	e8 00 00 00 00	 call	 _OP_ResetEvent
  0144d	83 c4 04	 add	 esp, 4

; 4041 : 		  bDidBlock = TRUE; // tek 29jan98

  01450	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _bDidBlock$[esp+48], 1
$L71515:

; 4042 :         }
; 4043 : 	  // tek 07nov97 move this in closer
; 4044 :       OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  01458	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  0145b	50		 push	 eax
  0145c	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01461	83 c4 04	 add	 esp, 4
$L71514:

; 4045 :       }
; 4046 : 
; 4047 : 
; 4048 :       OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  01464	8b 4e 70	 mov	 ecx, DWORD PTR [esi+112]
  01467	51		 push	 ecx
  01468	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 4055 : 	}
; 4056 : 
; 4057 : 	// tek 07nov97 moved inside the if..
; 4058 :     //OP_UnlockMutex( pPlayAudio->hmxPauseFlag );
; 4059 :     //OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );
; 4060 : 
; 4061 : 
; 4062 : 	// tek 07nov97 
; 4063 : 	// now, after all that, it is (I suppose) possible that 
; 4064 : 	// something happened that might cause us to not block;
; 4065 : 	// we'll just check those cases here after the fact, and 
; 4066 : 	// unblock ourselves.
; 4067 : 	// tek 28jan98 be careful here, or we'll suck down all the CPU.
; 4068 : 	if (bDidBlock)

  0146d	8b 44 24 20	 mov	 eax, DWORD PTR _bDidBlock$[esp+52]
  01471	83 c4 04	 add	 esp, 4
  01474	85 c0		 test	 eax, eax
  01476	74 26		 je	 SHORT $L71519

; 4069 : 	{
; 4070 : 		if (   (pPlayAudio->pSyncMarkList != NULL )
; 4071 : 				 ||(   (pPlayAudioRing->iQueueCount != 0 )
; 4072 : 					&& (pPlayAudio->dwAudioDeviceState != AUDIO_DEVICE_ACTIVE)
; 4073 : 				   )
; 4074 : 		   )

  01478	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  0147e	85 c0		 test	 eax, eax
  01480	75 10		 jne	 SHORT $L71520
  01482	8b 4c 24 10	 mov	 ecx, DWORD PTR _pPlayAudioRing$[esp+48]
  01486	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  01489	85 c0		 test	 eax, eax
  0148b	74 11		 je	 SHORT $L71519
  0148d	39 5e 34	 cmp	 DWORD PTR [esi+52], ebx
  01490	74 0c		 je	 SHORT $L71519
$L71520:

; 4075 : 		{
; 4076 : 			OP_SetEvent( pPlayAudio->hevTimerThreadActive );

  01492	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  01495	52		 push	 edx
  01496	e8 00 00 00 00	 call	 _OP_SetEvent
  0149b	83 c4 04	 add	 esp, 4
$L71519:

; 4077 : 		}
; 4078 : 	}
; 4079 : 
; 4080 :     /******************************************************************/
; 4081 :     /*  Wait for the thread to unblock.                               */
; 4082 :     /******************************************************************/
; 4083 : 
; 4084 :     OP_WaitForEvent( pPlayAudio->hevTimerThreadActive, OP_INFINITE );

  0149e	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  014a1	6a ff		 push	 -1
  014a3	50		 push	 eax
  014a4	e8 00 00 00 00	 call	 _OP_WaitForEvent

; 4085 : 
; 4086 :     /******************************************************************/
; 4087 :     /*  Test for thread shutdown. Shutdown is caused by the           */
; 4088 :     /*  PA_DestroyPlayHandle() function.                              */
; 4089 :     /******************************************************************/
; 4090 : 
; 4091 :     if ( pPlayAudio->bTimerExit )

  014a9	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  014ac	83 c4 08	 add	 esp, 8
  014af	85 c0		 test	 eax, eax
  014b1	0f 84 2f fc ff
	ff		 je	 $L71468
  014b7	5f		 pop	 edi
  014b8	5b		 pop	 ebx
$L72155:

; 4092 :     {
; 4093 :       break;
; 4094 :     }
; 4095 :   }
; 4096 : 
; 4097 :   /********************************************************************/
; 4098 :   /*  Exit the thread.                                                */
; 4099 :   /********************************************************************/
; 4100 : 
; 4101 :   OP_ExitThread( 0 );

  014b9	6a 00		 push	 0
  014bb	e8 00 00 00 00	 call	 _OP_ExitThread
  014c0	83 c4 04	 add	 esp, 4

; 4102 : 
; 4103 :   OP_THREAD_RETURN;

  014c3	33 c0		 xor	 eax, eax
  014c5	5e		 pop	 esi
  014c6	5d		 pop	 ebp

; 4104 : }

  014c7	83 c4 20	 add	 esp, 32			; 00000020H
  014ca	c3		 ret	 0
$L71511:

; 4049 :     }
; 4050 : 	else
; 4051 : 	{
; 4052 : 		// tek 07nov97 gotta let these go..
; 4053 :     OP_UnlockMutex( pPlayAudio->hmxPauseFlag );

  014cb	8b 96 88 00 00
	00		 mov	 edx, DWORD PTR [esi+136]
  014d1	52		 push	 edx
  014d2	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 4054 :     OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  014d7	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  014dd	50		 push	 eax
  014de	e8 00 00 00 00	 call	 _OP_UnlockMutex
  014e3	83 c4 08	 add	 esp, 8

; 4055 : 	}
; 4056 : 
; 4057 : 	// tek 07nov97 moved inside the if..
; 4058 :     //OP_UnlockMutex( pPlayAudio->hmxPauseFlag );
; 4059 :     //OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );
; 4060 : 
; 4061 : 
; 4062 : 	// tek 07nov97 
; 4063 : 	// now, after all that, it is (I suppose) possible that 
; 4064 : 	// something happened that might cause us to not block;
; 4065 : 	// we'll just check those cases here after the fact, and 
; 4066 : 	// unblock ourselves.
; 4067 : 	// tek 28jan98 be careful here, or we'll suck down all the CPU.
; 4068 : 	if (bDidBlock)

  014e6	eb b6		 jmp	 SHORT $L71519
_TimerThreadMain ENDP
_uiMessage$ = -12
_pPlayAudio$ = -4
_aParam$ = -8
_PlayAudioThreadMain PROC NEAR

; 4123 :   unsigned int uiResult;
; 4124 :   unsigned int uiMessage;
; 4125 :   HPLAY_AUDIO_T pPlayAudio;
; 4126 :   ATYPE_T aParam;
; 4127 : 
; 4128 :   /********************************************************************/
; 4129 :   /*  Audio message loop.                                             */
; 4130 :   /********************************************************************/
; 4131 : 
; 4132 :   pShm_t->bGlobalPlayAudioThreadExit = FALSE;

  014f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  014f5	83 ec 0c	 sub	 esp, 12			; 0000000cH
  014f8	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 4133 : 
; 4134 :   while( ! pShm_t->bGlobalPlayAudioThreadExit )

  014ff	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  01504	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01507	85 c9		 test	 ecx, ecx
  01509	75 6d		 jne	 SHORT $L71531
$L71530:

; 4135 :   {
; 4136 :     ReadMessageQueue( pShm_t->pGlobalPlayAudioMessageQueue,
; 4137 :                       (LPATYPE_T)&pPlayAudio,
; 4138 :                       (LPATYPE_T)&uiMessage,
; 4139 :                       &aParam );

  0150b	8d 4c 24 04	 lea	 ecx, DWORD PTR _aParam$[esp+12]
  0150f	8d 54 24 00	 lea	 edx, DWORD PTR _uiMessage$[esp+12]
  01513	51		 push	 ecx
  01514	52		 push	 edx
  01515	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  01518	8d 4c 24 10	 lea	 ecx, DWORD PTR _pPlayAudio$[esp+20]
  0151c	51		 push	 ecx
  0151d	52		 push	 edx
  0151e	e8 00 00 00 00	 call	 _ReadMessageQueue

; 4140 :     uiResult = PlayAudioProcedure( pPlayAudio, uiMessage, aParam );

  01523	8b 44 24 14	 mov	 eax, DWORD PTR _aParam$[esp+28]
  01527	8b 4c 24 10	 mov	 ecx, DWORD PTR _uiMessage$[esp+28]
  0152b	8b 54 24 18	 mov	 edx, DWORD PTR _pPlayAudio$[esp+28]
  0152f	50		 push	 eax
  01530	51		 push	 ecx
  01531	52		 push	 edx
  01532	e8 00 00 00 00	 call	 _PlayAudioProcedure

; 4141 :     /******************************************************************/
; 4142 :     /*  If this is not a driver message then put result into the      */
; 4143 :     /*  report message queue.                                         */
; 4144 :     /******************************************************************/
; 4145 : 
; 4146 :     if  (( uiMessage != MM_WOM_OPEN )
; 4147 :       && ( uiMessage != MM_WOM_DONE )
; 4148 :       && ( uiMessage != MM_WOM_CLOSE ))

  01537	8b 4c 24 1c	 mov	 ecx, DWORD PTR _uiMessage$[esp+40]
  0153b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0153e	81 f9 bb 03 00
	00		 cmp	 ecx, 955		; 000003bbH
  01544	74 26		 je	 SHORT $L71534
  01546	81 f9 bd 03 00
	00		 cmp	 ecx, 957		; 000003bdH
  0154c	74 1e		 je	 SHORT $L71534
  0154e	81 f9 bc 03 00
	00		 cmp	 ecx, 956		; 000003bcH
  01554	74 16		 je	 SHORT $L71534

; 4149 :     {
; 4150 :       WriteMessageQueue( pShm_t->pGlobalReportMessageQueue,
; 4151 :                          (ATYPE_T)0,
; 4152 :                          (ATYPE_T)0,
; 4153 :                          (ATYPE_T)uiResult );

  01556	50		 push	 eax
  01557	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  0155c	6a 00		 push	 0
  0155e	6a 00		 push	 0
  01560	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  01563	51		 push	 ecx
  01564	e8 00 00 00 00	 call	 _WriteMessageQueue
  01569	83 c4 10	 add	 esp, 16			; 00000010H
$L71534:
  0156c	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  01571	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01574	85 c9		 test	 ecx, ecx
  01576	74 93		 je	 SHORT $L71530
$L71531:

; 4154 :     }
; 4155 :   }
; 4156 :   
; 4157 :   /********************************************************************/
; 4158 :   /*  Exit the thread.                                                */
; 4159 :   /********************************************************************/
; 4160 :  
; 4161 :   OP_ExitThread( 0 );

  01578	6a 00		 push	 0
  0157a	e8 00 00 00 00	 call	 _OP_ExitThread

; 4162 :   OP_THREAD_RETURN;

  0157f	33 c0		 xor	 eax, eax

; 4163 : }

  01581	83 c4 10	 add	 esp, 16			; 00000010H
  01584	c3		 ret	 0
_PlayAudioThreadMain ENDP
_pPlayAudio$ = 8
_uiMessage$ = 12
_aParam$ = 16
_PlayAudioProcedure PROC NEAR

; 4181 :   switch( uiMessage )
; 4182 :   {

  01590	8b 44 24 08	 mov	 eax, DWORD PTR _uiMessage$[esp-4]
  01594	3d bb 03 00 00	 cmp	 eax, 955		; 000003bbH
  01599	0f 87 e3 00 00
	00		 ja	 $L72172
  0159f	0f 84 ca 00 00
	00		 je	 $L71549
  015a5	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  015a8	0f 87 de 00 00
	00		 ja	 $L71568
  015ae	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72174[eax*4]
$L71552:

; 4211 : 
; 4212 :   /********************************************************************/
; 4213 :   /*  This message is sent by the the PA_Queue() function or by the   */
; 4214 :   /*  timer thread, "TimerThreadMain()", to open the wave output      */
; 4215 :   /*  device.                                                         */
; 4216 :   /********************************************************************/
; 4217 : 
; 4218 :   case ID_Open_Wave_Output_Device:
; 4219 :     return ProcessOpenWaveOutputDeviceMessage( pPlayAudio );

  015b5	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  015b9	50		 push	 eax
  015ba	e8 00 00 00 00	 call	 _ProcessOpenWaveOutputDeviceMessage
  015bf	83 c4 04	 add	 esp, 4

; 4309 : }

  015c2	c3		 ret	 0
$L71553:

; 4220 : 
; 4221 :   /********************************************************************/
; 4222 :   /*  An application uses this message to cancel audio output.        */
; 4223 :   /********************************************************************/
; 4224 : 
; 4225 :   case ID_Reset_Audio:
; 4226 :     return ProcessResetMessage( pPlayAudio );

  015c3	8b 4c 24 04	 mov	 ecx, DWORD PTR _pPlayAudio$[esp-4]
  015c7	51		 push	 ecx
  015c8	e8 00 00 00 00	 call	 _ProcessResetMessage
  015cd	83 c4 04	 add	 esp, 4

; 4309 : }

  015d0	c3		 ret	 0
$L71554:

; 4227 : 
; 4228 :   /********************************************************************/
; 4229 :   /*  An application uses this message to pause audio output.         */
; 4230 :   /********************************************************************/
; 4231 : 
; 4232 :   case ID_Pause_Audio:
; 4233 :     return ProcessPauseMessage( pPlayAudio );

  015d1	8b 54 24 04	 mov	 edx, DWORD PTR _pPlayAudio$[esp-4]
  015d5	52		 push	 edx
  015d6	e8 00 00 00 00	 call	 _ProcessPauseMessage
  015db	83 c4 04	 add	 esp, 4

; 4309 : }

  015de	c3		 ret	 0
$L71555:

; 4234 : 
; 4235 :   /********************************************************************/
; 4236 :   /*  An application uses this message to resume audio output.        */
; 4237 :   /********************************************************************/
; 4238 : 
; 4239 :   case ID_Resume_Audio:
; 4240 :     return ProcessResumeMessage( pPlayAudio );

  015df	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  015e3	50		 push	 eax
  015e4	e8 00 00 00 00	 call	 _ProcessResumeMessage
  015e9	83 c4 04	 add	 esp, 4

; 4309 : }

  015ec	c3		 ret	 0
$L71556:

; 4241 : 
; 4242 :   /********************************************************************/
; 4243 :   /*  An application uses this message to set audio parameters.       */
; 4244 :   /********************************************************************/
; 4245 : 
; 4246 :   case ID_Set_Audio_Format:
; 4247 :     return ProcessSetFormatMessage( pPlayAudio,
; 4248 :                                     (LPWAVEFORMATEX)aParam );

  015ed	8b 4c 24 0c	 mov	 ecx, DWORD PTR _aParam$[esp-4]
  015f1	8b 54 24 04	 mov	 edx, DWORD PTR _pPlayAudio$[esp-4]
  015f5	51		 push	 ecx
  015f6	52		 push	 edx
  015f7	e8 00 00 00 00	 call	 _ProcessSetFormatMessage
  015fc	83 c4 08	 add	 esp, 8

; 4309 : }

  015ff	c3		 ret	 0
$L71558:

; 4249 : 
; 4250 :   /********************************************************************/
; 4251 :   /*  An application uses this message to get audio parameters.       */
; 4252 :   /********************************************************************/
; 4253 : 
; 4254 :   case ID_Get_Audio_Format:
; 4255 :     return ProcessGetFormatMessage( pPlayAudio,
; 4256 :                                     (LPWAVEFORMATEX)aParam );

  01600	8b 44 24 0c	 mov	 eax, DWORD PTR _aParam$[esp-4]
  01604	8b 4c 24 04	 mov	 ecx, DWORD PTR _pPlayAudio$[esp-4]
  01608	50		 push	 eax
  01609	51		 push	 ecx
  0160a	e8 00 00 00 00	 call	 _ProcessGetFormatMessage
  0160f	83 c4 08	 add	 esp, 8

; 4309 : }

  01612	c3		 ret	 0
$L71560:

; 4257 : 
; 4258 :   /********************************************************************/
; 4259 :   /*  An application uses this message to get the wave output device  */
; 4260 :   /*  volume.                                                         */
; 4261 :   /********************************************************************/
; 4262 : 
; 4263 :   case ID_Get_Audio_Volume:
; 4264 :     return ProcessGetVolumeMessage( pPlayAudio, (LPDWORD)aParam );

  01613	8b 54 24 0c	 mov	 edx, DWORD PTR _aParam$[esp-4]
  01617	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  0161b	52		 push	 edx
  0161c	50		 push	 eax
  0161d	e8 00 00 00 00	 call	 _ProcessGetVolumeMessage
  01622	83 c4 08	 add	 esp, 8

; 4309 : }

  01625	c3		 ret	 0
$L71562:

; 4265 : 
; 4266 :   /********************************************************************/
; 4267 :   /*  An application uses this message to set the wave output device  */
; 4268 :   /*  volume.                                                         */
; 4269 :   /********************************************************************/
; 4270 : 
; 4271 :   case ID_Set_Audio_Volume:
; 4272 :     return ProcessSetVolumeMessage( pPlayAudio, (DWORD)aParam );

  01626	8b 4c 24 0c	 mov	 ecx, DWORD PTR _aParam$[esp-4]
  0162a	8b 54 24 04	 mov	 edx, DWORD PTR _pPlayAudio$[esp-4]
  0162e	51		 push	 ecx
  0162f	52		 push	 edx
  01630	e8 00 00 00 00	 call	 _ProcessSetVolumeMessage
  01635	83 c4 08	 add	 esp, 8

; 4309 : }

  01638	c3		 ret	 0
$L71564:

; 4273 : 
; 4274 :   /********************************************************************/
; 4275 :   /*  An application uses this message to mark the current audio      */
; 4276 :   /*  position.                                                       */
; 4277 :   /********************************************************************/
; 4278 : 
; 4279 :   case ID_Synchronization_Mark:
; 4280 :     return ProcessSynchronizationMarkMessage( pPlayAudio, aParam );

  01639	8b 44 24 0c	 mov	 eax, DWORD PTR _aParam$[esp-4]
  0163d	8b 4c 24 04	 mov	 ecx, DWORD PTR _pPlayAudio$[esp-4]
  01641	50		 push	 eax
  01642	51		 push	 ecx
  01643	e8 00 00 00 00	 call	 _ProcessSynchronizationMarkMessage
  01648	83 c4 08	 add	 esp, 8

; 4309 : }

  0164b	c3		 ret	 0
$L71565:

; 4281 : 
; 4282 :   /********************************************************************/
; 4283 :   /*  An application uses this message to get the position of the     */
; 4284 :   /*  last sample played by the wave output device.                   */
; 4285 :   /********************************************************************/
; 4286 : 
; 4287 :   case ID_Get_Audio_Position:
; 4288 :     return ProcessGetPositionMessage( pPlayAudio, (LPDWORD)aParam );

  0164c	8b 54 24 0c	 mov	 edx, DWORD PTR _aParam$[esp-4]
  01650	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  01654	52		 push	 edx
  01655	50		 push	 eax
  01656	e8 00 00 00 00	 call	 _ProcessGetPositionMessage
  0165b	83 c4 08	 add	 esp, 8

; 4309 : }

  0165e	c3		 ret	 0
$L71567:

; 4289 : 
; 4290 :   /********************************************************************/
; 4291 :   /*  The ID_Destroy_Message is used to shut down the audio thread.   */
; 4292 :   /********************************************************************/
; 4293 : 
; 4294 :   case ID_Destroy_Message:
; 4295 :     pShm_t->bGlobalPlayAudioThreadExit = TRUE;

  0165f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t

; 4296 : 
; 4297 :     break;
; 4298 : 
; 4299 :   /********************************************************************/
; 4300 :   /*  Default message processing. This should never execute.          */
; 4301 :   /********************************************************************/
; 4302 : 
; 4303 :   default:
; 4304 : 
; 4305 :     break;
; 4306 :   }
; 4307 : 
; 4308 :   return 0;

  01665	33 c0		 xor	 eax, eax
  01667	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1

; 4309 : }

  0166e	c3		 ret	 0
$L71549:

; 4183 :   
; 4184 :   /********************************************************************/
; 4185 :   /*  The MM_WOM_OPEN message is received after the waveOutOpen()     */
; 4186 :   /*  function opens the waveform output device.                      */
; 4187 :   /********************************************************************/
; 4188 : 
; 4189 :   case MM_WOM_OPEN:
; 4190 :     return Process_MM_WOM_OPEN_Message( pPlayAudio, aParam );

  0166f	8b 54 24 0c	 mov	 edx, DWORD PTR _aParam$[esp-4]
  01673	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  01677	52		 push	 edx
  01678	50		 push	 eax
  01679	e8 00 00 00 00	 call	 _Process_MM_WOM_OPEN_Message
  0167e	83 c4 08	 add	 esp, 8

; 4309 : }

  01681	c3		 ret	 0
$L72172:

; 4181 :   switch( uiMessage )
; 4182 :   {

  01682	2d bc 03 00 00	 sub	 eax, 956		; 000003bcH
  01687	74 19		 je	 SHORT $L71551
  01689	48		 dec	 eax
  0168a	74 03		 je	 SHORT $L71550
$L71568:

; 4296 : 
; 4297 :     break;
; 4298 : 
; 4299 :   /********************************************************************/
; 4300 :   /*  Default message processing. This should never execute.          */
; 4301 :   /********************************************************************/
; 4302 : 
; 4303 :   default:
; 4304 : 
; 4305 :     break;
; 4306 :   }
; 4307 : 
; 4308 :   return 0;

  0168c	33 c0		 xor	 eax, eax

; 4309 : }

  0168e	c3		 ret	 0
$L71550:

; 4191 : 
; 4192 :   /********************************************************************/
; 4193 :   /*  The MM_WOM_DONE message is received when a buffer queued by the */
; 4194 :   /*  waveOutWrite() function has been played.                        */
; 4195 :   /********************************************************************/
; 4196 : 
; 4197 :   case MM_WOM_DONE:
; 4198 :     return Process_MM_WOM_DONE_Message( pPlayAudio, aParam );

  0168f	8b 4c 24 0c	 mov	 ecx, DWORD PTR _aParam$[esp-4]
  01693	8b 54 24 04	 mov	 edx, DWORD PTR _pPlayAudio$[esp-4]
  01697	51		 push	 ecx
  01698	52		 push	 edx
  01699	e8 00 00 00 00	 call	 _Process_MM_WOM_DONE_Message
  0169e	83 c4 08	 add	 esp, 8

; 4309 : }

  016a1	c3		 ret	 0
$L71551:

; 4199 : 
; 4200 :   /********************************************************************/
; 4201 :   /*  The MM_WOM_CLOSE message is received when the waveOutClose()    */
; 4202 :   /*  function completes closing the waveform output device.          */
; 4203 :   /*  pPlayAudio->dwAudioDeviceState is set to                        */
; 4204 :   /*  AUDIO_DEVICE_INACTIVE in the                                    */
; 4205 :   /*  Process_Process_MM_WOM_DONE_Message() function after the call   */
; 4206 :   /*  to the waveOutClose() function.                                 */
; 4207 :   /********************************************************************/
; 4208 : 
; 4209 :   case MM_WOM_CLOSE:
; 4210 :     return Process_MM_WOM_CLOSE_Message( pPlayAudio );

  016a2	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  016a6	50		 push	 eax
  016a7	e8 00 00 00 00	 call	 _Process_MM_WOM_CLOSE_Message
  016ac	83 c4 04	 add	 esp, 4

; 4309 : }

  016af	c3		 ret	 0
$L72174:
  016b0	00 00 00 00	 DD	 $L71552
  016b4	00 00 00 00	 DD	 $L71553
  016b8	00 00 00 00	 DD	 $L71554
  016bc	00 00 00 00	 DD	 $L71555
  016c0	00 00 00 00	 DD	 $L71556
  016c4	00 00 00 00	 DD	 $L71558
  016c8	00 00 00 00	 DD	 $L71562
  016cc	00 00 00 00	 DD	 $L71560
  016d0	00 00 00 00	 DD	 $L71564
  016d4	00 00 00 00	 DD	 $L71565
  016d8	00 00 00 00	 DD	 $L71567
_PlayAudioProcedure ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutGetID@8:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_uiSelectedDeviceID$ = 8
_Process_MM_WOM_OPEN_Message PROC NEAR

; 4341 : {

  016e0	56		 push	 esi

; 4342 :   unsigned int uiSelectedDeviceID;
; 4343 :   MMRESULT mmStatus;
; 4344 : #ifdef AUD_DEBUG //tek 13may97
; 4345 :   {
; 4346 : 		  char  szTemp[256]="";
; 4347 : 		  sprintf(szTemp,"ProcWOMOPEN: outstanding now %d at %08lu\n",
; 4348 : 			  pPlayAudio->iOutstandingBuffers,timeGetTime());
; 4349 : 		  OutputDebugString(szTemp);
; 4350 : 		  if ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )
; 4351 : 		  {
; 4352 : 			  sprintf(szTemp,"ProcWOMOPEN: PA_OWN_DEVICE is SET\n");
; 4353 : 		  }
; 4354 : 		  else
; 4355 : 		  {
; 4356 : 			  sprintf(szTemp,"ProcWOMOPEN: PA_OWN_DEVICE is NOT set\n");
; 4357 : 		  }
; 4358 : 		  OutputDebugString(szTemp);
; 4359 :   }
; 4360 : #endif //AUD_DEBUG
; 4361 : 
; 4362 :   /********************************************************************/
; 4363 :   /*  It is NOT possible that the selected device ID is equal to      */
; 4364 :   /*  WAVE_MAPPER because the DetermineDeviceID() function will have  */
; 4365 :   /*  already set the selected device ID. This legacy code provides   */
; 4366 :   /*  another check of the device ID in case a strange error occurs.  */
; 4367 :   /********************************************************************/
; 4368 : 
; 4369 :   if ( pPlayAudio->uiSelectedDeviceID == (unsigned int)WAVE_MAPPER )

  016e1	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  016e5	83 7e 20 ff	 cmp	 DWORD PTR [esi+32], -1
  016e9	75 50		 jne	 SHORT $L71582

; 4370 :   {
; 4371 :     LOCK_MME_CALL( waveOutGetID( pPlayAudio->hWaveOut,
; 4372 :                                  &uiSelectedDeviceID ))

  016eb	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  016ee	8d 44 24 08	 lea	 eax, DWORD PTR _uiSelectedDeviceID$[esp]
  016f2	50		 push	 eax
  016f3	51		 push	 ecx
  016f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetID@8

; 4373 : 
; 4374 :     /******************************************************************/
; 4375 :     /*  Attempt to fix BUG in MARCH 1993 Beta version of Windows/NT.  */
; 4376 :     /*  If WAVE_MAPPER was the device ID when the waveOutOpen()       */
; 4377 :     /*  function was called and a valid hWaveOut is passed to the     */
; 4378 :     /*  waveOutGetID() function then it returns WAVE_MAPPER instead   */
; 4379 :     /*  of the device ID of the wave out device !                     */
; 4380 :     /*  If WAVE_MAPPER is used, then hope that the device ID is zero. */
; 4381 :     /******************************************************************/
; 4382 : 
; 4383 :     if ( uiSelectedDeviceID == (unsigned int)WAVE_MAPPER )

  016fa	83 7c 24 08 ff	 cmp	 DWORD PTR _uiSelectedDeviceID$[esp], -1
  016ff	75 08		 jne	 SHORT $L71581

; 4384 :     {
; 4385 :       uiSelectedDeviceID = 0;

  01701	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR _uiSelectedDeviceID$[esp], 0
$L71581:

; 4386 :     }
; 4387 : 
; 4388 :     /******************************************************************/
; 4389 :     /*  Save the selected device ID in the handle.                    */
; 4390 :     /******************************************************************/
; 4391 : 
; 4392 :     OP_LockMutex( pPlayAudio->hmxSelectedDeviceID );

  01709	8b 56 78	 mov	 edx, DWORD PTR [esi+120]
  0170c	52		 push	 edx
  0170d	e8 00 00 00 00	 call	 _OP_LockMutex

; 4393 :     pPlayAudio->uiSelectedDeviceID = uiSelectedDeviceID;
; 4394 :     OP_UnlockMutex( pPlayAudio->hmxSelectedDeviceID );

  01712	8b 4e 78	 mov	 ecx, DWORD PTR [esi+120]
  01715	8b 44 24 0c	 mov	 eax, DWORD PTR _uiSelectedDeviceID$[esp+4]
  01719	51		 push	 ecx
  0171a	89 46 20	 mov	 DWORD PTR [esi+32], eax
  0171d	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 4395 : 
; 4396 :     /******************************************************************/
; 4397 :     /*  Set the dwDeviceSupport member of the play audio handle       */
; 4398 :     /*  pointed to by "pPlayAudio" to the dwSupport field of the      */
; 4399 :     /*  WAVEOUTCAPS structure. The device ID is specified by the      */
; 4400 :     /*  uiSelectedDeviceID field of the play audio handle.            */
; 4401 :     /******************************************************************/
; 4402 : 
; 4403 :     mmStatus = GetWaveOutDeviceCaps( pPlayAudio );

  01722	56		 push	 esi
  01723	e8 00 00 00 00	 call	 _GetWaveOutDeviceCaps
  01728	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4404 : 
; 4405 :     if ( mmStatus )

  0172b	85 c0		 test	 eax, eax
  0172d	74 0c		 je	 SHORT $L71582

; 4406 :     {
; 4407 : #ifdef AUD_DEBUG
; 4408 : 		OutputDebugString("Process_MM_WOM_OPEN_Message: GetWaveOutDeviceCaps failed.\n");
; 4409 : #endif
; 4410 : 		ReportStatusToApplication( pPlayAudio,
; 4411 :                                  PA_GET_CAPS_ERROR,
; 4412 :                                  mmStatus );

  0172f	50		 push	 eax
  01730	6a 06		 push	 6
  01732	56		 push	 esi
  01733	e8 00 00 00 00	 call	 _ReportStatusToApplication
  01738	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71582:

; 4413 :     }
; 4414 :   }
; 4415 : 
; 4416 :   /********************************************************************/
; 4417 :   /*  Start Audio Playing.                                            */
; 4418 :   /********************************************************************/
; 4419 : 
; 4420 :   StartAudioPlaying( pPlayAudio );

  0173b	56		 push	 esi
  0173c	e8 00 00 00 00	 call	 _StartAudioPlaying
  01741	83 c4 04	 add	 esp, 4

; 4421 : 
; 4422 :   return FALSE;

  01744	33 c0		 xor	 eax, eax
  01746	5e		 pop	 esi

; 4423 : }

  01747	c3		 ret	 0
_Process_MM_WOM_OPEN_Message ENDP
_pPlayAudio$ = 8
_GetWaveOutDeviceCaps PROC NEAR

; 4455 : {

  01750	56		 push	 esi

; 4456 :   LPWAVEOUTCAPS pWaveOutCaps;
; 4457 :   MMRESULT mmStatus;
; 4458 : 
; 4459 :   /********************************************************************/
; 4460 :   /*  Get the wave output device capabilities.                        */
; 4461 :   /*  First allocate memory for the WAVEOUTCAPS structure.            */
; 4462 :   /********************************************************************/
; 4463 : 
; 4464 :   LOCK_MME_CALL(
; 4465 :     pWaveOutCaps = (LPWAVEOUTCAPS)ALLOCATE_SERVER_MEM(sizeof(WAVEOUTCAPS)))

  01751	6a 34		 push	 52			; 00000034H
  01753	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  01759	8b f0		 mov	 esi, eax
  0175b	83 c4 04	 add	 esp, 4

; 4466 : 
; 4467 :   if ( pWaveOutCaps == NULL )

  0175e	85 f6		 test	 esi, esi
  01760	75 07		 jne	 SHORT $L71591

; 4468 :   {
; 4469 :     return MMSYSERR_NOMEM;

  01762	b8 07 00 00 00	 mov	 eax, 7
  01767	5e		 pop	 esi

; 4490 : }

  01768	c3		 ret	 0
$L71591:
  01769	53		 push	 ebx
  0176a	57		 push	 edi

; 4470 :   }
; 4471 : 
; 4472 :   LOCK_MME_CALL(
; 4473 :     mmStatus = waveOutGetDevCaps( pPlayAudio->uiSelectedDeviceID,
; 4474 :                                   pWaveOutCaps,
; 4475 :                                   sizeof(WAVEOUTCAPS)))

  0176b	8b 7c 24 10	 mov	 edi, DWORD PTR _pPlayAudio$[esp+8]
  0176f	6a 34		 push	 52			; 00000034H
  01771	56		 push	 esi
  01772	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  01775	50		 push	 eax
  01776	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetDevCapsA@12

; 4476 : 
; 4477 :   /********************************************************************/
; 4478 :   /*  Store the device capabilities in the handle.                    */
; 4479 :   /********************************************************************/
; 4480 : 
; 4481 :   pPlayAudio->dwDeviceSupport = pWaveOutCaps->dwSupport;

  0177c	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]

; 4482 : 
; 4483 :   /********************************************************************/
; 4484 :   /*  Free memory for the WAVEOUTCAPS structure.                      */
; 4485 :   /********************************************************************/
; 4486 : 
; 4487 :   LOCK_MME_CALL( FREE_SERVER_MEM( pWaveOutCaps ))

  0177f	56		 push	 esi
  01780	8b d8		 mov	 ebx, eax
  01782	89 4f 48	 mov	 DWORD PTR [edi+72], ecx
  01785	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0178b	83 c4 04	 add	 esp, 4

; 4488 : 
; 4489 :   return mmStatus;

  0178e	8b c3		 mov	 eax, ebx
  01790	5f		 pop	 edi
  01791	5b		 pop	 ebx
  01792	5e		 pop	 esi

; 4490 : }

  01793	c3		 ret	 0
_GetWaveOutDeviceCaps ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutPause@4:NEAR
EXTRN	__imp__waveOutRestart@4:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_StartAudioPlaying PROC NEAR

; 4520 : {

  017a0	53		 push	 ebx
  017a1	55		 push	 ebp
  017a2	56		 push	 esi

; 4521 :   unsigned int uiI;
; 4522 :   unsigned int uiQueueCount=0;
; 4523 :   unsigned int uiWriteLength=0;
; 4524 :   LPPLAY_RING_T pPlayAudioRing;
; 4525 : #ifdef __linux__
; 4526 :   struct timespec tv;
; 4527 : #endif
; 4528 : 
; 4529 :   /********************************************************************/
; 4530 :   /*  Get the Queue Count. If it changes between here and the end of  */
; 4531 :   /*  this function, that's OK.                                       */
; 4532 :   /********************************************************************/
; 4533 : 
; 4534 :   pPlayAudioRing = pPlayAudio->pPlayAudioRing;

  017a3	8b 74 24 10	 mov	 esi, DWORD PTR _pPlayAudio$[esp+8]
  017a7	57		 push	 edi

; 4535 : 
; 4536 :   OP_LockMutex( pPlayAudio->hmxQueueCount );

  017a8	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  017ab	8b ae 98 00 00
	00		 mov	 ebp, DWORD PTR [esi+152]
  017b1	50		 push	 eax
  017b2	e8 00 00 00 00	 call	 _OP_LockMutex

; 4537 : 
; 4538 : #ifdef AUD_DEBUG //tek 13may97
; 4539 :   {
; 4540 :     char  szTemp[256]="";
; 4541 :     sprintf(szTemp,"SAP: state=%ld QCount=%d new=%d outstanding=%d at %lu\n",
; 4542 : 	    pPlayAudio->dwAudioDeviceState,
; 4543 : 	    pPlayAudioRing->iQueueCount,
; 4544 : 	    uiQueueCount, 
; 4545 : 	    pPlayAudio->iOutstandingBuffers,
; 4546 : 	    timeGetTime()
; 4547 : 	    );
; 4548 :     OutputDebugString(szTemp);
; 4549 :     if (uiQueueCount < (pPlayAudio->uiStartupWriteLength-1))
; 4550 :       {
; 4551 : 	OutputDebugString("SAP: runt start packet?\n");
; 4552 :       }
; 4553 :     
; 4554 :   }
; 4555 : #endif //AUD_DEBUG
; 4556 :   
; 4557 :   uiQueueCount = (unsigned int)pPlayAudioRing->iQueueCount;
; 4558 :   // tek 06nov97 hold this mutex for the duration
; 4559 :   //OP_UnlockMutex( pPlayAudio->hmxQueueCount );
; 4560 : 
; 4561 :   /********************************************************************/
; 4562 :   /*  If the PA_Reset() function clears the audio queue just after    */
; 4563 :   /*  the waveOutOpen() function completes, then it is possible to    */
; 4564 :   /*  get here with no audio in the queue. In this case, close the    */
; 4565 :   /*  wave output device.                                             */
; 4566 :   /********************************************************************/
; 4567 : 
; 4568 :   if ( uiQueueCount == 0 )

  017b7	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  017ba	83 c4 04	 add	 esp, 4
  017bd	85 c0		 test	 eax, eax
  017bf	75 1a		 jne	 SHORT $L71601

; 4569 :   {
; 4570 :     ClosePlayDevice( pPlayAudio );

  017c1	56		 push	 esi
  017c2	e8 00 00 00 00	 call	 _ClosePlayDevice

; 4759 : 	  }
; 4760 : 	  else
; 4761 : 	  {
; 4762 : #ifdef AUD_DEBUG
; 4763 : 		  {
; 4764 : 		    char  szTemp[256]="";
; 4765 : 		    sprintf(szTemp,"SAP: header %d (%08lx) is busy at %lu\n",
; 4766 : 			    uiI,
; 4767 : 			    pPlayAudio->ppWaveHdr[uiI],
; 4768 : 			    timeGetTime()
; 4769 : 			    );
; 4770 : 		    OutputDebugString(szTemp);
; 4771 : 		  }
; 4772 : #endif //AUD_DEBUG  
; 4773 : 	  }
; 4774 :     }
; 4775 :   }
; 4776 : #ifdef AUD_DEBUG
; 4777 :   {
; 4778 : 		  char  szTemp[256]="";
; 4779 : 		  sprintf(szTemp,"SAP: exit at %lu\n",
; 4780 : 			  timeGetTime()
; 4781 : 			  );
; 4782 : 		  OutputDebugString(szTemp);
; 4783 :   }
; 4784 : #endif //AUD_DEBUG  
; 4785 :   // finally release the mutex here.
; 4786 :   OP_UnlockMutex(pPlayAudio->hmxQueueCount);

  017c7	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  017ca	83 c4 04	 add	 esp, 4
  017cd	51		 push	 ecx
  017ce	e8 00 00 00 00	 call	 _OP_UnlockMutex
  017d3	83 c4 04	 add	 esp, 4
  017d6	5f		 pop	 edi
  017d7	5e		 pop	 esi
  017d8	5d		 pop	 ebp
  017d9	5b		 pop	 ebx

; 4787 : 	
; 4788 : #ifdef __linux__ 
; 4789 : //necessary for proper multithreading, this may be fixed in newer kernels
; 4790 :     tv.tv_sec=0;
; 4791 :     tv.tv_nsec=1;
; 4792 :     nanosleep(&tv,NULL);
; 4793 :     //usleep(1);
; 4794 : #endif
; 4795 : 
; 4796 :   return;
; 4797 : }

  017da	c3		 ret	 0
$L71601:

; 4571 :   }
; 4572 :   else
; 4573 :   {
; 4574 : 	  // tek 13may97
; 4575 : 	  // we can now be re-entered after audio is actually playing; 
; 4576 : 	  // if we're using hte MME_SERVER we'll just bail out here, but
; 4577 : 	  // if not then we need to correctly atempt to send more samples.
; 4578 : 	  // we can tell if we're already running by the AudioDeviceState.
; 4579 : 
; 4580 :     if (pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE)

  017db	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  017de	bf 02 00 00 00	 mov	 edi, 2
  017e3	3b c7		 cmp	 eax, edi
  017e5	74 53		 je	 SHORT $L71605

; 4581 : 	{
; 4582 : #ifdef USE_MME_SERVER
; 4583 : 	OP_UnlockMutex(pPlayAudio->hmxQueueCount);
; 4584 : 		return;
; 4585 : #endif //USE_MME_SERVER
; 4586 : 	}
; 4587 : 	else // audio device is not active; do all the things we
; 4588 : 		 // do on startup..
; 4589 : 	{
; 4590 : 
; 4591 :     /******************************************************************/
; 4592 :     /*  Signal the application that we are starting to play audio.    */
; 4593 :     /*  Set a flag to indicate that a PA_PLAY_STOP message may be     */
; 4594 :     /*  sent. This flag is necessary in case the                      */
; 4595 :     /*  Process_MM_WOM_CLOSE() function is called after the audio     */
; 4596 :     /*  device is opened, but no audio is played (that is, the        */
; 4597 :     /*  ClosePlayDevice() function is called above. This can occur    */
; 4598 :     /*  if the timer thread and the PA_Queue() function both send     */
; 4599 :     /*  ID_Open_Wave_Output_Device messages in rapid succession.)     */
; 4600 :     /******************************************************************/
; 4601 : 
; 4602 :     ReportStatusToApplication( pPlayAudio,
; 4603 :                                PA_PLAY_START,
; 4604 :                                0 );

  017e7	bb 01 00 00 00	 mov	 ebx, 1
  017ec	6a 00		 push	 0
  017ee	53		 push	 ebx
  017ef	56		 push	 esi
  017f0	e8 00 00 00 00	 call	 _ReportStatusToApplication

; 4605 : 
; 4606 :     pPlayAudio->bReportPlayStop = TRUE;
; 4607 : 
; 4608 :     /******************************************************************/
; 4609 :     /*  Set the Audio Device State to AUDIO_DEVICE_ACTIVE.            */
; 4610 :     /******************************************************************/
; 4611 : 
; 4612 : 	// tek 07nov97 unfortunately, with the longer hold of the 
; 4613 : 	// QueueCount mutex, this can deadlock with TimerThreadMain.
; 4614 : 	// But, the audio device is not active, so we release the
; 4615 : 	// mutex while we're doing this, and then take it back.
; 4616 :     OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  017f5	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  017f8	89 5e 64	 mov	 DWORD PTR [esi+100], ebx
  017fb	51		 push	 ecx
  017fc	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 4617 :     OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  01801	8b 56 70	 mov	 edx, DWORD PTR [esi+112]
  01804	52		 push	 edx
  01805	e8 00 00 00 00	 call	 _OP_LockMutex

; 4618 :     pPlayAudio->dwAudioDeviceState = AUDIO_DEVICE_ACTIVE;
; 4619 :     OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  0180a	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  0180d	89 7e 34	 mov	 DWORD PTR [esi+52], edi
  01810	50		 push	 eax
  01811	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 4620 :     OP_LockMutex( pPlayAudio->hmxQueueCount );

  01816	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  01819	51		 push	 ecx
  0181a	e8 00 00 00 00	 call	 _OP_LockMutex

; 4621 : 
; 4622 :     /******************************************************************/
; 4623 :     /*  If the Audio Device State is NOT PA_OWN_DEVICE and the pause  */
; 4624 :     /*  flag is set then pause the wave output device. This is        */
; 4625 :     /*  necessary in case the pause message was received in between   */
; 4626 :     /*  the open wave out device message and the MM_WOM_OPEN message. */
; 4627 :     /******************************************************************/
; 4628 : 
; 4629 :     if ( ! ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )
; 4630 :       && ( pPlayAudio->bPaused ))

  0181f	8a 46 3c	 mov	 al, BYTE PTR [esi+60]
  01822	83 c4 1c	 add	 esp, 28			; 0000001cH
  01825	84 c3		 test	 al, bl
  01827	75 11		 jne	 SHORT $L71605
  01829	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  0182c	85 c0		 test	 eax, eax
  0182e	74 0a		 je	 SHORT $L71605

; 4631 :     {
; 4632 :       LOCK_MME_CALL( waveOutPause( pPlayAudio->hWaveOut ))

  01830	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  01833	52		 push	 edx
  01834	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutPause@4
$L71605:

; 4633 :     }
; 4634 : 
; 4635 : #ifdef USE_MME_SERVER
; 4636 : 
; 4637 :     /******************************************************************/
; 4638 :     /*  MME BUG WORKAROUND. Because the MME server currently does not */
; 4639 :     /*  return wave headers in the correct order, it is necessary to  */
; 4640 :     /*  put wave headers on a list whenever a wave header is written  */
; 4641 :     /*  by the waveOutWrite() function. This list is accessed in the  */
; 4642 :     /*  wave output callback routine to determine the current header. */
; 4643 :     /******************************************************************/
; 4644 : 
; 4645 :     pPlayAudio->uiWaveHdrWriteIndex = 0;
; 4646 :     pPlayAudio->uiWaveHdrReadIndex = 0;
; 4647 : 
; 4648 : #endif
; 4649 : 	}
; 4650 : 
; 4651 : 	// In case we got a reset without a resume...
; 4652 : 	if (pPlayAudio->bResetPaused && !pPlayAudio->bPaused)

  0183a	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  0183d	85 c0		 test	 eax, eax
  0183f	74 11		 je	 SHORT $L71606
  01841	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  01844	85 c0		 test	 eax, eax
  01846	75 0a		 jne	 SHORT $L71606

; 4653 : 	{
; 4654 : 		LOCK_MME_CALL( waveOutRestart( pPlayAudio->hWaveOut ))

  01848	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0184b	50		 push	 eax
  0184c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutRestart@4
$L71606:

; 4655 : 	}
; 4656 : 
; 4657 : 	// if there are samples outstanding, we have to recalculate the 
; 4658 : 	// correct number of samples that are still waiting to go
; 4659 : 	// hold this mutex up above.
; 4660 : 	//OP_LockMutex( pPlayAudio->hmxQueueCount );
; 4661 : 	// tek 06nov97 bats508 it is possible that ResetAudioQueue
; 4662 : 	// came along and clobbered the queue. If so, we need to
; 4663 : 	// gracefully bow out here..
; 4664 : 	  if ( pPlayAudioRing->iQueueCount == 0 )

  01852	8b 5d 18	 mov	 ebx, DWORD PTR [ebp+24]
  01855	85 db		 test	 ebx, ebx
  01857	75 17		 jne	 SHORT $L71607

; 4665 : 	  {
; 4666 : 		ClosePlayDevice( pPlayAudio );

  01859	56		 push	 esi
  0185a	e8 00 00 00 00	 call	 _ClosePlayDevice

; 4667 : 		OP_UnlockMutex(pPlayAudio->hmxQueueCount);

  0185f	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  01862	51		 push	 ecx
  01863	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01868	83 c4 08	 add	 esp, 8
  0186b	5f		 pop	 edi
  0186c	5e		 pop	 esi
  0186d	5d		 pop	 ebp
  0186e	5b		 pop	 ebx

; 4787 : 	
; 4788 : #ifdef __linux__ 
; 4789 : //necessary for proper multithreading, this may be fixed in newer kernels
; 4790 :     tv.tv_sec=0;
; 4791 :     tv.tv_nsec=1;
; 4792 :     nanosleep(&tv,NULL);
; 4793 :     //usleep(1);
; 4794 : #endif
; 4795 : 
; 4796 :   return;
; 4797 : }

  0186f	c3		 ret	 0
$L71607:

; 4668 : #ifdef AUD_DEBUG
; 4669 : 		{
; 4670 : 		  char  szTemp[256]="";
; 4671 : 		  sprintf(szTemp,"SAP: iQueueCount=0 abort at %lu\n",
; 4672 : 			  timeGetTime()
; 4673 : 			  );
; 4674 : 		  OutputDebugString(szTemp);
; 4675 : 		}
; 4676 : #endif //AUD_DEBUG 
; 4677 : 		return;
; 4678 : 	  }
; 4679 : 	uiQueueCount = pPlayAudioRing->iQueueCount
; 4680 : 					- pPlayAudio->iSamplesWaitingForCompletion;

  01870	8b 46 30	 mov	 eax, DWORD PTR [esi+48]

; 4681 : 	// hold the mutex so PROCWOMDONE won't collide..
; 4682 : 
; 4683 : #ifdef AUD_DEBUG
; 4684 :   {
; 4685 :     char  szTemp[256]="";
; 4686 :     sprintf(szTemp,"SAP: %d samples to write at %lu\n",
; 4687 : 	    uiQueueCount,
; 4688 : 	    timeGetTime()
; 4689 : 	    );
; 4690 :     OutputDebugString(szTemp);
; 4691 :   }
; 4692 : #endif //AUD_DEBUG 
; 4693 : 
; 4694 :     /******************************************************************/
; 4695 :     /*  If the number of samples in the queue is less than the        */
; 4696 :     /*  minimum samples to start playing audio then this is a flush   */
; 4697 :     /*  that was started by the timer thread (TimerThreadMain).       */
; 4698 :     /******************************************************************/
; 4699 : 	// tek 13may97
; 4700 : 	// this is no longer true. We can start up with less data if we're
; 4701 : 	// being forced to speak.
; 4702 : 
; 4703 :     /******************************************************************/
; 4704 :     /*  Loop and write buffers to the wave output device.             */
; 4705 :     /******************************************************************/
; 4706 : 
; 4707 :     uiWriteLength = pPlayAudio->uiStartupWriteLength;

  01873	8b 7e 28	 mov	 edi, DWORD PTR [esi+40]
  01876	2b d8		 sub	 ebx, eax
  01878	33 ed		 xor	 ebp, ebp
$L71608:

; 4708 : 
; 4709 : 	// tek 13may97
; 4710 : 	//// if we have less than the normal startup number of bytes, then
; 4711 : 	//// try to split the buffer into at least two buffers.
; 4712 : 	//
; 4713 : 	//if (  (uiQueueCount < uiWriteLength)
; 4714 : 	//	&&(uiQueueCount > 100) // but don't break up really tiny packets..
; 4715 : 	//   )
; 4716 : 	//{
; 4717 : 	//	uiWriteLength = (uiQueueCount>>4)<<3; // div by two, 8-byte chunksize
; 4718 : 	//}
; 4719 : 
; 4720 :     for ( uiI = 0;
; 4721 :           ( uiI < MAXIMUM_BUFFERS_QUEUED ) && ( uiQueueCount > 0 );
; 4722 :           uiI++ )

  0187a	85 db		 test	 ebx, ebx
  0187c	76 3f		 jbe	 SHORT $L71610

; 4723 :     {
; 4724 :       if ( uiWriteLength > uiQueueCount)

  0187e	3b fb		 cmp	 edi, ebx
  01880	76 02		 jbe	 SHORT $L71611

; 4725 :       {
; 4726 :         uiWriteLength = uiQueueCount;

  01882	8b fb		 mov	 edi, ebx
$L71611:

; 4727 :       }
; 4728 : 	  // tek 21nov97 make sure we don't leave a tiny buffer laying around to 
; 4729 : 	  // be sent..
; 4730 : #if !defined NOWIN && defined UNDER_CE
; 4731 : 	if (!pPlayAudio->bConvertToEightBit && (uiQueueCount & 0x01))
; 4732 : 	{
; 4733 : 		MessageBox(NULL, "Eight-Bit sample in 16-bit mode!", NULL, MB_OK);
; 4734 : 	}
; 4735 : #endif
; 4736 : 	  if (uiQueueCount < uiWriteLength+1000)

  01884	8d 97 e8 03 00
	00		 lea	 edx, DWORD PTR [edi+1000]
  0188a	3b da		 cmp	 ebx, edx
  0188c	73 0c		 jae	 SHORT $L71613

; 4737 :       {
; 4738 : 		uiWriteLength = uiQueueCount;
; 4739 : #if !defined NOWIN && defined UNDER_CE
; 4740 : 		if (!pPlayAudio->bConvertToEightBit && (uiQueueCount & 0x01))
; 4741 : 		{
; 4742 : 			MessageBox(NULL, "Eight-Bit sample in 16-bit mode!", NULL, MB_OK);
; 4743 : 		}
; 4744 : #endif
; 4745 :         if (!pPlayAudio->bConvertToEightBit)	uiWriteLength = (uiQueueCount & 0xFFFFFFFE);		// Let's not send in a half-block

  0188e	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  01891	8b fb		 mov	 edi, ebx
  01893	85 c0		 test	 eax, eax
  01895	75 03		 jne	 SHORT $L71613
  01897	83 e7 fe	 and	 edi, -2			; fffffffeH
$L71613:

; 4746 : 
; 4747 : #ifdef __ipaq__
; 4748 : 	uiWriteLength&=~0x03;
; 4749 : #endif
; 4750 :       }
; 4751 : 	  // check to make sure that this is a free waveheader, and
; 4752 : 	  // write it if it is. (tek 13may97)
; 4753 : 	  if (pPlayAudio->ppWaveHdr[uiI]->lpData == NULL)

  0189a	8b 86 94 00 00
	00		 mov	 eax, DWORD PTR [esi+148]
  018a0	8b 04 28	 mov	 eax, DWORD PTR [eax+ebp]
  018a3	83 38 00	 cmp	 DWORD PTR [eax], 0
  018a6	75 0d		 jne	 SHORT $L71609

; 4754 : 	  {
; 4755 : 
; 4756 :       uiQueueCount -= WriteBufferToWaveDevice( pPlayAudio,
; 4757 :                                                pPlayAudio->ppWaveHdr[uiI],
; 4758 :                                                uiWriteLength );

  018a8	57		 push	 edi
  018a9	50		 push	 eax
  018aa	56		 push	 esi
  018ab	e8 00 00 00 00	 call	 _WriteBufferToWaveDevice
  018b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  018b3	2b d8		 sub	 ebx, eax
$L71609:
  018b5	83 c5 04	 add	 ebp, 4
  018b8	83 fd 20	 cmp	 ebp, 32			; 00000020H
  018bb	7c bd		 jl	 SHORT $L71608
$L71610:

; 4759 : 	  }
; 4760 : 	  else
; 4761 : 	  {
; 4762 : #ifdef AUD_DEBUG
; 4763 : 		  {
; 4764 : 		    char  szTemp[256]="";
; 4765 : 		    sprintf(szTemp,"SAP: header %d (%08lx) is busy at %lu\n",
; 4766 : 			    uiI,
; 4767 : 			    pPlayAudio->ppWaveHdr[uiI],
; 4768 : 			    timeGetTime()
; 4769 : 			    );
; 4770 : 		    OutputDebugString(szTemp);
; 4771 : 		  }
; 4772 : #endif //AUD_DEBUG  
; 4773 : 	  }
; 4774 :     }
; 4775 :   }
; 4776 : #ifdef AUD_DEBUG
; 4777 :   {
; 4778 : 		  char  szTemp[256]="";
; 4779 : 		  sprintf(szTemp,"SAP: exit at %lu\n",
; 4780 : 			  timeGetTime()
; 4781 : 			  );
; 4782 : 		  OutputDebugString(szTemp);
; 4783 :   }
; 4784 : #endif //AUD_DEBUG  
; 4785 :   // finally release the mutex here.
; 4786 :   OP_UnlockMutex(pPlayAudio->hmxQueueCount);

  018bd	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  018c0	51		 push	 ecx
  018c1	e8 00 00 00 00	 call	 _OP_UnlockMutex
  018c6	83 c4 04	 add	 esp, 4
  018c9	5f		 pop	 edi
  018ca	5e		 pop	 esi
  018cb	5d		 pop	 ebp
  018cc	5b		 pop	 ebx

; 4787 : 	
; 4788 : #ifdef __linux__ 
; 4789 : //necessary for proper multithreading, this may be fixed in newer kernels
; 4790 :     tv.tv_sec=0;
; 4791 :     tv.tv_nsec=1;
; 4792 :     nanosleep(&tv,NULL);
; 4793 :     //usleep(1);
; 4794 : #endif
; 4795 : 
; 4796 :   return;
; 4797 : }

  018cd	c3		 ret	 0
_StartAudioPlaying ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutUnprepareHeader@12:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_aParam$ = 12
_Process_MM_WOM_DONE_Message PROC NEAR

; 4834 : {

  018d0	53		 push	 ebx
  018d1	55		 push	 ebp

; 4835 :   int dwRemaining;
; 4836 :   unsigned int uiOldWriteLength;
; 4837 :   LPWAVEHDR pWaveHdr;
; 4838 :   LPPLAY_RING_T pPlayAudioRing;
; 4839 : 
; 4840 : #ifdef __linux__
; 4841 :   struct timespec tv;
; 4842 : #endif
; 4843 : 
; 4844 :   //tek 24jul97
; 4845 :   UINT	uiI=0;
; 4846 : 
; 4847 :   /********************************************************************/
; 4848 :   /*  Get the pointer to the wave header from the aParam of the       */
; 4849 :   /*  MM_WOM_DONE message and the pointer to the audio queue from the */
; 4850 :   /*  audio handle.                                                   */
; 4851 :   /********************************************************************/
; 4852 : 
; 4853 :   pWaveHdr = (LPWAVEHDR)aParam;
; 4854 : 
; 4855 :   /********************************************************************/
; 4856 :   /*  Get the number of samples previously written by the             */
; 4857 :   /*  waveOutWrite() function.                                        */
; 4858 :   /********************************************************************/
; 4859 : 
; 4860 :   uiOldWriteLength = (unsigned int)pWaveHdr->dwUser;

  018d2	8b 6c 24 10	 mov	 ebp, DWORD PTR _aParam$[esp+4]
  018d6	56		 push	 esi

; 4861 : 
; 4862 : #ifdef __arm__
; 4863 : #ifndef __ipaq__
; 4864 :   if( pPlayAudio->bPipesNotEmpty )
; 4865 :     {
; 4866 :       //setpriority(PRIO_PROCESS, 0, 20);
; 4867 :       // OP_SetThreadPriority works better, why? 
; 4868 :       OP_SetThreadPriority( pShm_t->hGlobalPlayAudioThread, OP_PRIORITY_NORMAL );
; 4869 :       if ( (uiOldWriteLength<<5) > 50000 )
; 4870 :       	usleep(50000); // tek 13oct98 defer buffer processing
; 4871 :       else
; 4872 :       	usleep(uiOldWriteLength<<5);
; 4873 :       //ETT 10/13/98 this has to be just right other wise it will stutter worse
; 4874 :       //setpriority(PRIO_PROCESS, 0, -20);
; 4875 :       OP_SetThreadPriority( pShm_t->hGlobalPlayAudioThread, OP_PRIORITY_HIGHEST );
; 4876 :     }
; 4877 : #endif //__ipaq__
; 4878 : #endif //__arm__
; 4879 : 
; 4880 :   /********************************************************************/
; 4881 :   /*  Unprepare the old header.                                       */
; 4882 :   /********************************************************************/
; 4883 : 
; 4884 : #ifndef USE_MME_SERVER
; 4885 :   _ASSERTE(pWaveHdr->lpData != NULL); // tek 22jan99 make sure this isn't a bogus
; 4886 : 									  // and/or idle header
; 4887 : 
; 4888 :   waveOutUnprepareHeader( pPlayAudio->hWaveOut,
; 4889 :                           pWaveHdr,
; 4890 :                           sizeof(WAVEHDR));

  018d7	8b 74 24 10	 mov	 esi, DWORD PTR _pPlayAudio$[esp+8]
  018db	57		 push	 edi
  018dc	8b 5d 0c	 mov	 ebx, DWORD PTR [ebp+12]
  018df	6a 20		 push	 32			; 00000020H
  018e1	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  018e4	55		 push	 ebp
  018e5	50		 push	 eax
  018e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutUnprepareHeader@12

; 4891 : #endif
; 4892 :   // tek 06nov97 we have to take this mutex earlier to avoid collisions
; 4893 :   OP_LockMutex( pPlayAudio->hmxQueueCount );

  018ec	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  018ef	51		 push	 ecx
  018f0	e8 00 00 00 00	 call	 _OP_LockMutex

; 4894 :   // tek 09may97
; 4895 :   pPlayAudio->iOutstandingBuffers--;  // keep track of these for debugging

  018f5	8b 96 a4 00 00
	00		 mov	 edx, DWORD PTR [esi+164]

; 4896 : 
; 4897 :   /********************************************************************/
; 4898 :   /*  Subtract number of samples just output from the samples waiting */
; 4899 :   /*  for completion count.                                           */
; 4900 :   /********************************************************************/
; 4901 : 
; 4902 :   pPlayAudio->iSamplesWaitingForCompletion -= uiOldWriteLength;

  018fb	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]

; 4903 : #ifdef AUD_DEBUG	//13may97 tek
; 4904 :   {
; 4905 : 		  char  szTemp[256]="";
; 4906 : 		  sprintf(szTemp,"ProcWOMDONE: %08lx; outst buffs now=%d; samp waiting=%dat %08lu\n",
; 4907 : 			  pWaveHdr,
; 4908 : 			  pPlayAudio->iOutstandingBuffers,
; 4909 : 			  pPlayAudio->iSamplesWaitingForCompletion,
; 4910 : 			  timeGetTime()
; 4911 : 			  );
; 4912 : 		  OutputDebugString(szTemp);
; 4913 :   }
; 4914 : #endif //AUD_DEBUG
; 4915 : 
; 4916 :   /********************************************************************/
; 4917 :   /*  Do if the audio state isn't equal to AUDIO_STATE_PLAY then it   */
; 4918 :   /*  is equal to AUDIO_STATE_RESET.                                  */
; 4919 :   /********************************************************************/
; 4920 : 
; 4921 :   if ( pPlayAudio->dwAudioPlayState == AUDIO_STATE_PLAY )

  018fe	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  01901	83 c4 04	 add	 esp, 4
  01904	4a		 dec	 edx
  01905	2b cb		 sub	 ecx, ebx
  01907	85 c0		 test	 eax, eax
  01909	89 96 a4 00 00
	00		 mov	 DWORD PTR [esi+164], edx
  0190f	89 4e 30	 mov	 DWORD PTR [esi+48], ecx
  01912	0f 85 d2 00 00
	00		 jne	 $L71631

; 4922 :   {
; 4923 :     /******************************************************************/
; 4924 :     /*  Subtract the number of samples from the queue count.          */
; 4925 :     /******************************************************************/
; 4926 : 
; 4927 :     pPlayAudioRing = pPlayAudio->pPlayAudioRing;

  01918	8b be 98 00 00
	00		 mov	 edi, DWORD PTR [esi+152]

; 4928 : 
; 4929 : 	// tek 06nov97 (during bats508) hold this earlier (above).
; 4930 :     //OP_LockMutex( pPlayAudio->hmxQueueCount );
; 4931 :     pPlayAudioRing->iQueueCount -= (int)uiOldWriteLength;

  0191e	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  01921	2b cb		 sub	 ecx, ebx
  01923	89 4f 18	 mov	 DWORD PTR [edi+24], ecx

; 4932 : #ifdef AUD_DEBUG // tek 13may97
; 4933 :   {
; 4934 :     char  szTemp[256]="";
; 4935 :     sprintf(szTemp,"ProcWOMDONE: iQueueCount=%ld\n",
; 4936 : 	    pPlayAudioRing->iQueueCount);
; 4937 :     OutputDebugString(szTemp);
; 4938 :     
; 4939 :     if (pPlayAudioRing->iQueueCount < 0)
; 4940 :       {
; 4941 : 	sprintf(szTemp,"ProcWOMDONE: iQueueCount is negative? %d at %08lu\n",
; 4942 : 		pPlayAudioRing->iQueueCount,
; 4943 : 		timeGetTime()
; 4944 : 		);
; 4945 : 	OutputDebugString(szTemp);
; 4946 :       }
; 4947 :   }
; 4948 : #endif //AUD_DEBUG
; 4949 : 
; 4950 :     // tek 06nov97 this is now part of the larger mutex range
; 4951 :     //OP_UnlockMutex( pPlayAudio->hmxQueueCount );
; 4952 : 
; 4953 :     /******************************************************************/
; 4954 :     /*  Also update the "Bytes Played" count.                         */
; 4955 :     /******************************************************************/
; 4956 : 
; 4957 :     OP_LockMutex( pPlayAudio->hmxBytesPlayed );

  01926	8b 56 74	 mov	 edx, DWORD PTR [esi+116]
  01929	52		 push	 edx
  0192a	e8 00 00 00 00	 call	 _OP_LockMutex

; 4958 :     pPlayAudio->dwBytesPlayed += (DWORD)uiOldWriteLength;

  0192f	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  01932	03 c3		 add	 eax, ebx
  01934	89 46 44	 mov	 DWORD PTR [esi+68], eax

; 4959 :     OP_UnlockMutex( pPlayAudio->hmxBytesPlayed );

  01937	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  0193a	50		 push	 eax
  0193b	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 4960 : 
; 4961 :     /******************************************************************/
; 4962 :     /*  If there are no samples waiting for completion then there     */
; 4963 :     /*  are no more buffers queued by the waveOutWrite() function.    */
; 4964 :     /*  In this case release the wave output device by calling the    */
; 4965 :     /*  waveOutClose() function. If there are more samples in the     */
; 4966 :     /*  audio queue then a restart will eventually occur.             */
; 4967 :     /******************************************************************/
; 4968 : 
; 4969 : 	// tek 13may97
; 4970 : 	// this was a check on ( pPlayAudio->iSamplesWaitingForCompletion <= 0 )
; 4971 : 	// but I don't think that is quite correct; we could have no 
; 4972 : 	// samples waiting for completion (in the queue, but sent to the 
; 4973 : 	// device) but still have samples that haven't been sent yet. 
; 4974 : 	// if there are any samples left in the queue after the above update,
; 4975 : 	// then either we still have buffers at the device OR we have
; 4976 : 	// samples that have not yet been sent to the device.
; 4977 : 
; 4978 :     if ( pPlayAudioRing->iQueueCount <= 0 ) //tek 13may97

  01940	8b 7f 18	 mov	 edi, DWORD PTR [edi+24]
  01943	83 c4 08	 add	 esp, 8
  01946	85 ff		 test	 edi, edi
  01948	7f 15		 jg	 SHORT $L71634

; 4979 :     {
; 4980 : 
; 4981 : #ifdef AUD_DEBUG  //tek 13may97
; 4982 :   {
; 4983 : 		  char  szTemp[256]="";
; 4984 : 		  sprintf(szTemp,"ProcWOMDONE: Closing. iQueueCount=%ld\n",
; 4985 : 					pPlayAudioRing->iQueueCount);
; 4986 : 		  OutputDebugString(szTemp);
; 4987 :   }
; 4988 : #endif //AUD_DEBUG
; 4989 : 		// because we're done with this waveheader, clear the lpData field
; 4990 : 		// so that we can reuse it later.. 
; 4991 : 		pWaveHdr->lpData = NULL;
; 4992 :       ClosePlayDevice( pPlayAudio );

  0194a	56		 push	 esi
  0194b	c7 45 00 00 00
	00 00		 mov	 DWORD PTR [ebp], 0
  01952	e8 00 00 00 00	 call	 _ClosePlayDevice
  01957	83 c4 04	 add	 esp, 4

; 4993 :     }
; 4994 :     else

  0195a	e9 b2 00 00 00	 jmp	 $L71657
$L71634:

; 4995 :     {
; 4996 :       /****************************************************************/
; 4997 :       /*  Determine the number of unwritten samples remaining in the  */
; 4998 :       /*  audio queue. Protect the Queue Count.                       */
; 4999 :       /****************************************************************/
; 5000 : 	  // tek 16may97
; 5001 : 	  // we need to hold the mutex while we do the buffer write, else 
; 5002 : 	  // StartAudioPlaying may collide with this and write the same
; 5003 : 	  // thing twice.
; 5004 : 	  // tek 06nov97 this is now part of the larger mutex range
; 5005 :       //OP_LockMutex( pPlayAudio->hmxQueueCount );
; 5006 :       dwRemaining = pPlayAudioRing->iQueueCount -
; 5007 :                      pPlayAudio->iSamplesWaitingForCompletion;

  0195f	2b 7e 30	 sub	 edi, DWORD PTR [esi+48]

; 5008 : #ifdef AUD_DEBUG  //tek 13may97
; 5009 :   {
; 5010 : 		  char  szTemp[256]="";
; 5011 : 		  sprintf(szTemp,"ProcWOMDONE: dwRemaining=%ld\n",
; 5012 : 					dwRemaining);
; 5013 : 		  OutputDebugString(szTemp);
; 5014 :   }
; 5015 : #endif //AUD_DEBUG
; 5016 : 
; 5017 :       /****************************************************************/
; 5018 :       /*  If there are any samples remaining in the audio queue then  */
; 5019 :       /*  write up as many samples as the WriteBufferToWaveDevice()   */
; 5020 :       /*  function allows.                                            */
; 5021 :       /****************************************************************/
; 5022 : 
; 5023 :       if ( dwRemaining > 0 )

  01962	85 ff		 test	 edi, edi
  01964	7e 7b		 jle	 SHORT $L71637

; 5024 :       {
; 5025 :         /**************************************************************/
; 5026 :         /*  Write the next buffer to the output device.               */
; 5027 :         /**************************************************************/	
; 5028 : 		// tek 24jul97 in the presence of SYNCs, we can end up with 
; 5029 : 		// only a single buffer outstanding. To correct this, we'll try 
; 5030 : 		// to write several buffers if we don't have all of them outstanding
; 5031 : 		UINT uiWriteSize = dwRemaining;
; 5032 : 
; 5033 : 		if (pPlayAudio->iOutstandingBuffers < MAXIMUM_BUFFERS_QUEUED-2)

  01966	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  0196c	8b df		 mov	 ebx, edi
  0196e	83 f8 06	 cmp	 eax, 6
  01971	7d 19		 jge	 SHORT $L71639

; 5034 : 		{
; 5035 : #ifndef UNDER_CE // tek 23mar99 write fewer, larger buffers for CE
; 5036 : 			if (pPlayAudio->iOutstandingBuffers < MAXIMUM_BUFFERS_QUEUED-3)

  01973	83 f8 05	 cmp	 eax, 5
  01976	7d 05		 jge	 SHORT $L71640

; 5037 : 			{
; 5038 : 				uiWriteSize = dwRemaining>>2; // try to write 4

  01978	c1 fb 02	 sar	 ebx, 2

; 5039 : 			}
; 5040 : 			else

  0197b	eb 02		 jmp	 SHORT $L71641
$L71640:

; 5041 : #endif //UNDER_CE
; 5042 : 			{
; 5043 : 				uiWriteSize = dwRemaining>>1; // try to write 2

  0197d	d1 fb		 sar	 ebx, 1
$L71641:

; 5044 : 			}
; 5045 : 			// but don't write too little
; 5046 : 			// (make sure that we don't leave a tiny amount behind..)
; 5047 : 			if (uiWriteSize < MINIMUM_STARTUP_WRITE_SIZE)

  0197f	81 fb 40 06 00
	00		 cmp	 ebx, 1600		; 00000640H
  01985	73 02		 jae	 SHORT $L71642

; 5048 : 				uiWriteSize = dwRemaining;

  01987	8b df		 mov	 ebx, edi
$L71642:

; 5049 : 			// 015	MGS		12/15/1998	Fixed odd byte problem to audio device and BATS #844
; 5050 : 			uiWriteSize &= ~0x01;

  01989	83 e3 fe	 and	 ebx, -2			; fffffffeH
$L71639:

; 5051 : 
; 5052 : 		}
; 5053 : #ifdef UNDER_CE
; 5054 : 		if (!pPlayAudio->bConvertToEightBit)	uiWriteSize &= 0xFFFFFFFE;		// Let's not send in a half-block
; 5055 : #endif
; 5056 : #ifdef __ipaq__
; 5057 : 	uiWriteSize&=~0x03;
; 5058 : #endif
; 5059 : 
; 5060 :         dwRemaining -= WriteBufferToWaveDevice( pPlayAudio,
; 5061 :                                  pWaveHdr,
; 5062 :                                  (unsigned int)uiWriteSize );

  0198c	53		 push	 ebx
  0198d	55		 push	 ebp
  0198e	56		 push	 esi
  0198f	e8 00 00 00 00	 call	 _WriteBufferToWaveDevice
  01994	83 c4 0c	 add	 esp, 12			; 0000000cH
  01997	2b f8		 sub	 edi, eax
  01999	33 ed		 xor	 ebp, ebp
$L71644:

; 5063 : 
; 5064 : 		// now, go find a free header to write what's left. This 
; 5065 : 		// loop is copied from StartAudioPlaying.
; 5066 : 		for ( uiI = 0;
; 5067 : 			  ( uiI < MAXIMUM_BUFFERS_QUEUED ) && ( dwRemaining > 0 ) && (pPlayAudio->iOutstandingBuffers < MAXIMUM_BUFFERS_QUEUED) ;
; 5068 : 			  uiI++ )

  0199b	85 ff		 test	 edi, edi
  0199d	7e 72		 jle	 SHORT $L71657
  0199f	83 be a4 00 00
	00 08		 cmp	 DWORD PTR [esi+164], 8
  019a6	7d 69		 jge	 SHORT $L71657

; 5069 : 		{
; 5070 : 		  if ( uiWriteSize > (unsigned int) dwRemaining) // NAL warning removal

  019a8	3b df		 cmp	 ebx, edi
  019aa	76 02		 jbe	 SHORT $L71648

; 5071 : 		  {
; 5072 : 			uiWriteSize = dwRemaining;

  019ac	8b df		 mov	 ebx, edi
$L71648:

; 5073 : 		  }
; 5074 : 		  // check to make sure that this is a free waveheader, and
; 5075 : 		  // write it if it is. (tek 13may97)
; 5076 : 		  if (pPlayAudio->ppWaveHdr[uiI]->lpData == NULL)

  019ae	8b 8e 94 00 00
	00		 mov	 ecx, DWORD PTR [esi+148]
  019b4	8b 04 29	 mov	 eax, DWORD PTR [ecx+ebp]
  019b7	83 38 00	 cmp	 DWORD PTR [eax], 0
  019ba	75 1b		 jne	 SHORT $L71645

; 5077 : 		  {
; 5078 : #ifdef AUD_DEBUG
; 5079 : 		    {
; 5080 : 		      char  szTemp[256]="";
; 5081 : 		      sprintf(szTemp,"ProcWOMDONE: dwRemaining=%ld, uiWriteLength=%d, using header %d (%08lx) at %lu\n",
; 5082 : 			      dwRemaining,
; 5083 : 			      uiWriteSize,
; 5084 : 			      uiI,
; 5085 : 			      pPlayAudio->ppWaveHdr[uiI],
; 5086 : 			      timeGetTime()
; 5087 : 			      );
; 5088 : 		      OutputDebugString(szTemp);
; 5089 : 		    }
; 5090 : #endif //AUD_DEBUG  
; 5091 : 		    
; 5092 : #ifdef UNDER_CE
; 5093 : 		    if (!pPlayAudio->bConvertToEightBit)	uiWriteSize &= 0xFFFFFFFE;		// Let's not send in a half-block
; 5094 : #endif
; 5095 : #ifdef __ipaq__
; 5096 : 	uiWriteSize&=0x03;
; 5097 : #endif
; 5098 : 		    
; 5099 : 		    dwRemaining -= WriteBufferToWaveDevice( pPlayAudio,
; 5100 : 												   pPlayAudio->ppWaveHdr[uiI],
; 5101 : 												   uiWriteSize );

  019bc	53		 push	 ebx
  019bd	50		 push	 eax
  019be	56		 push	 esi
  019bf	e8 00 00 00 00	 call	 _WriteBufferToWaveDevice
  019c4	2b f8		 sub	 edi, eax
  019c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5102 : 		  // don't leave a runt around..
; 5103 : 		  if (dwRemaining - uiWriteSize < MINIMUM_STARTUP_WRITE_SIZE)

  019c9	8b d7		 mov	 edx, edi
  019cb	2b d3		 sub	 edx, ebx
  019cd	81 fa 40 06 00
	00		 cmp	 edx, 1600		; 00000640H
  019d3	73 02		 jae	 SHORT $L71645

; 5104 : 				uiWriteSize = dwRemaining;

  019d5	8b df		 mov	 ebx, edi
$L71645:

; 5063 : 
; 5064 : 		// now, go find a free header to write what's left. This 
; 5065 : 		// loop is copied from StartAudioPlaying.
; 5066 : 		for ( uiI = 0;
; 5067 : 			  ( uiI < MAXIMUM_BUFFERS_QUEUED ) && ( dwRemaining > 0 ) && (pPlayAudio->iOutstandingBuffers < MAXIMUM_BUFFERS_QUEUED) ;
; 5068 : 			  uiI++ )

  019d7	83 c5 04	 add	 ebp, 4
  019da	83 fd 20	 cmp	 ebp, 32			; 00000020H
  019dd	7c bc		 jl	 SHORT $L71644

; 5105 : 
; 5106 : 		  }
; 5107 : 		  else
; 5108 : 		  {
; 5109 : #ifdef AUD_DEBUG
; 5110 : 			  {
; 5111 : 					  char  szTemp[256]="";
; 5112 : 					  sprintf(szTemp,"ProcWOMDONE: header %d (%08lx) is busy at %lu\n",
; 5113 : 						  uiI,
; 5114 : 						  pPlayAudio->ppWaveHdr[uiI],
; 5115 : 						  timeGetTime()
; 5116 : 						  );
; 5117 : 					  OutputDebugString(szTemp);
; 5118 : 			  }
; 5119 : #endif //AUD_DEBUG  
; 5120 : 		  }
; 5121 : 		}
; 5122 : 		
; 5123 :       }
; 5124 : 	  else //tek 13may97 if we're done with the header, null the 

  019df	eb 30		 jmp	 SHORT $L71657
$L71637:

; 5125 : 		   // lpData field so we know it is free.
; 5126 : 	  {
; 5127 : 		  pWaveHdr->lpData = NULL;

  019e1	c7 45 00 00 00
	00 00		 mov	 DWORD PTR [ebp], 0

; 5128 : 	  }
; 5129 : 	  // tek 06nov97 move this out of this branch
; 5130 :       //OP_UnlockMutex( pPlayAudio->hmxQueueCount );
; 5131 : 
; 5132 :     }
; 5133 :   }
; 5134 :   else

  019e8	eb 27		 jmp	 SHORT $L71657
$L71631:

; 5135 :   {
; 5136 : 	  // tek 13may97 in any event, we're done with this header..
; 5137 : 	  pWaveHdr->lpData = NULL;

  019ea	c7 45 00 00 00
	00 00		 mov	 DWORD PTR [ebp], 0

; 5138 :     /******************************************************************/
; 5139 :     /*  The audio state is equal to AUDIO_STATE_RESET. In reset mode  */
; 5140 :     /*  the queue count has already been set to zero. If there are no */
; 5141 :     /*  samples playing then signal that the reset is complete.       */
; 5142 :     /******************************************************************/
; 5143 : 
; 5144 :     if ( pPlayAudio->iSamplesWaitingForCompletion <= 0 )

  019f1	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  019f4	85 c0		 test	 eax, eax
  019f6	7f 19		 jg	 SHORT $L71657

; 5145 :     {
; 5146 :       pPlayAudio->dwAudioPlayState = AUDIO_STATE_PLAY;
; 5147 : 
; 5148 :       ClosePlayDevice( pPlayAudio );

  019f8	56		 push	 esi
  019f9	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  01a00	e8 00 00 00 00	 call	 _ClosePlayDevice

; 5149 : 
; 5150 :       OP_SetEvent( pPlayAudio->hevResetComplete );

  01a05	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  01a08	50		 push	 eax
  01a09	e8 00 00 00 00	 call	 _OP_SetEvent
  01a0e	83 c4 08	 add	 esp, 8
$L71657:

; 5151 :     }
; 5152 :   }
; 5153 : 
; 5154 :   /********************************************************************/
; 5155 :   /*  Signal that the Queue is not full.                              */
; 5156 :   /********************************************************************/
; 5157 : 
; 5158 :   OP_SetEvent( pPlayAudio->hevQueueNotFull );

  01a11	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  01a14	51		 push	 ecx
  01a15	e8 00 00 00 00	 call	 _OP_SetEvent

; 5159 :   //tek 06nov97 finally release the mutex here.
; 5160 :   OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  01a1a	8b 56 7c	 mov	 edx, DWORD PTR [esi+124]
  01a1d	52		 push	 edx
  01a1e	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01a23	83 c4 08	 add	 esp, 8

; 5161 : #ifdef __linux__ 
; 5162 : //necessary for proper multithreading, this may be fixed in newer kernels
; 5163 :   tv.tv_sec=0;
; 5164 :   tv.tv_nsec=1;
; 5165 :   nanosleep(&tv,NULL);
; 5166 :   //usleep(1);
; 5167 : #endif
; 5168 :   return FALSE;

  01a26	33 c0		 xor	 eax, eax
  01a28	5f		 pop	 edi
  01a29	5e		 pop	 esi
  01a2a	5d		 pop	 ebp
  01a2b	5b		 pop	 ebx

; 5169 : }

  01a2c	c3		 ret	 0
_Process_MM_WOM_DONE_Message ENDP
_pPlayAudio$ = 8
_Process_MM_WOM_CLOSE_Message PROC NEAR

; 5198 : {

  01a30	56		 push	 esi

; 5199 : #ifdef AUD_DEBUG	 // tek 13may97
; 5200 :   {
; 5201 : 		  char  szTemp[256]="";
; 5202 : 		  sprintf(szTemp,"ProcWOMCLOSE: outstanding now %d at %08lu\n",
; 5203 : 			  pPlayAudio->iOutstandingBuffers,
; 5204 : 			  timeGetTime()
; 5205 : 			  );
; 5206 : 		  OutputDebugString(szTemp);
; 5207 :   }
; 5208 : #endif //AUD_DEBUG
; 5209 :   /********************************************************************/
; 5210 :   /*  If the audio device is not owned then clear the handle now.     */
; 5211 :   /********************************************************************/
; 5212 : 
; 5213 :   if (( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE ) == 0 )

  01a31	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  01a35	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  01a39	75 07		 jne	 SHORT $L71661

; 5214 :   {
; 5215 :     pPlayAudio->hWaveOut = (int)NULL;

  01a3b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$L71661:

; 5216 :   }
; 5217 : 
; 5218 :   /********************************************************************/
; 5219 :   /*  Set the audio device state and unblock the timer thread.        */
; 5220 :   /********************************************************************/
; 5221 : 
; 5222 :   OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  01a42	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  01a45	50		 push	 eax
  01a46	e8 00 00 00 00	 call	 _OP_LockMutex

; 5223 :   pPlayAudio->dwAudioDeviceState = AUDIO_DEVICE_INACTIVE;
; 5224 :   OP_SetEvent( pPlayAudio->hevTimerThreadActive );

  01a4b	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  01a4e	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
  01a55	51		 push	 ecx
  01a56	e8 00 00 00 00	 call	 _OP_SetEvent

; 5225 :   OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  01a5b	8b 56 70	 mov	 edx, DWORD PTR [esi+112]
  01a5e	52		 push	 edx
  01a5f	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 5226 : 
; 5227 :   /********************************************************************/
; 5228 :   /*  Unblock the PA_WaitForPlayToComplete() function.                */
; 5229 :   /********************************************************************/
; 5230 : 
; 5231 :   OP_SetEvent( pPlayAudio->hevAudioDeviceInactive );

  01a64	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  01a67	50		 push	 eax
  01a68	e8 00 00 00 00	 call	 _OP_SetEvent

; 5232 : 
; 5233 :   /********************************************************************/
; 5234 :   /*  Signal the application that the audio has stopped.              */
; 5235 :   /********************************************************************/
; 5236 : 
; 5237 :   if ( pPlayAudio->bReportPlayStop )

  01a6d	8b 46 64	 mov	 eax, DWORD PTR [esi+100]
  01a70	83 c4 10	 add	 esp, 16			; 00000010H
  01a73	85 c0		 test	 eax, eax
  01a75	74 14		 je	 SHORT $L72187

; 5238 :   {
; 5239 :     ReportStatusToApplication( pPlayAudio,
; 5240 :                                PA_PLAY_STOP,
; 5241 :                                0 );

  01a77	6a 00		 push	 0
  01a79	6a 02		 push	 2
  01a7b	56		 push	 esi
  01a7c	e8 00 00 00 00	 call	 _ReportStatusToApplication
  01a81	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5242 : 
; 5243 :     pPlayAudio->bReportPlayStop = FALSE;

  01a84	c7 46 64 00 00
	00 00		 mov	 DWORD PTR [esi+100], 0
$L72187:

; 5244 :   }
; 5245 : 
; 5246 :   return FALSE;

  01a8b	33 c0		 xor	 eax, eax
  01a8d	5e		 pop	 esi

; 5247 : }

  01a8e	c3		 ret	 0
_Process_MM_WOM_CLOSE_Message ENDP
_pPlayAudio$ = 8
_dwPosition$ = 8
_ClosePlayDevice PROC NEAR

; 5277 : {

  01a90	56		 push	 esi

; 5278 :   DWORD dwPosition;
; 5279 : 
; 5280 :   /********************************************************************/
; 5281 :   /*  If the user owns the audio device then just perform the same    */
; 5282 :   /*  processing that receiving a MM_WOM_CLOSE message would cause.   */
; 5283 :   /*  Otherwise call the waveOutClose() function to release the wave  */
; 5284 :   /*  output device. This will cause the wave device driver to send   */
; 5285 :   /*  an MM_WOM_CLOSE message when the wave output device is          */
; 5286 :   /*  released. At that time the Audio Device State will be set to    */
; 5287 :   /*  AUDIO_DEVICE_INACTIVE.                                          */
; 5288 :   /********************************************************************/
; 5289 : 
; 5290 :   if ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )

  01a91	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  01a95	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  01a99	74 0b		 je	 SHORT $L71669

; 5291 :   {
; 5292 :     Process_MM_WOM_CLOSE_Message( pPlayAudio );

  01a9b	56		 push	 esi
  01a9c	e8 00 00 00 00	 call	 _Process_MM_WOM_CLOSE_Message

; 5312 : 	pPlayAudio->bResetPaused = FALSE;
; 5313 : 	/* wake up the timer thread just in case */
; 5314 : 	OP_SetEvent(pPlayAudio->hevTimerThreadActive);

  01aa1	83 c4 04	 add	 esp, 4
  01aa4	5e		 pop	 esi

; 5315 : 
; 5316 :   }
; 5317 : 
; 5318 :   return;
; 5319 : }

  01aa5	c3		 ret	 0
$L71669:

; 5293 :   }
; 5294 :   else
; 5295 :   {
; 5296 :     OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  01aa6	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  01aa9	50		 push	 eax
  01aaa	e8 00 00 00 00	 call	 _OP_LockMutex

; 5297 :     pPlayAudio->dwAudioDeviceState = AUDIO_DEVICE_SHUTTING_DOWN;
; 5298 :     OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  01aaf	8b 4e 70	 mov	 ecx, DWORD PTR [esi+112]
  01ab2	c7 46 34 03 00
	00 00		 mov	 DWORD PTR [esi+52], 3
  01ab9	51		 push	 ecx
  01aba	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 5299 : 
; 5300 : #ifdef WIN32
; 5301 : 	OP_Sleep(1);

  01abf	6a 01		 push	 1
  01ac1	e8 00 00 00 00	 call	 _OP_Sleep

; 5302 : #endif
; 5303 : 
; 5304 :     AudioPosition( pPlayAudio, &dwPosition );

  01ac6	8d 54 24 14	 lea	 edx, DWORD PTR _dwPosition$[esp+12]
  01aca	52		 push	 edx
  01acb	56		 push	 esi
  01acc	e8 00 00 00 00	 call	 _AudioPosition

; 5305 : 
; 5306 :     pPlayAudio->dwPositionBase += dwPosition;

  01ad1	8b 44 24 1c	 mov	 eax, DWORD PTR _dwPosition$[esp+20]
  01ad5	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  01ad8	03 c8		 add	 ecx, eax
  01ada	83 c4 14	 add	 esp, 20			; 00000014H
  01add	89 4e 40	 mov	 DWORD PTR [esi+64], ecx

; 5307 : 	// MGS  The audio device seems to be lying when it says taht is is done playing.
; 5308 : 	// the last bit of audio doesn't seem to be played even when the audio position
; 5309 : 	// is at the end of the data sent.  The Sleep(1) seems to fix this problem.
; 5310 : 
; 5311 :     LOCK_MME_CALL( waveOutClose( pPlayAudio->hWaveOut ))

  01ae0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01ae3	51		 push	 ecx
  01ae4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutClose@4

; 5312 : 	pPlayAudio->bResetPaused = FALSE;
; 5313 : 	/* wake up the timer thread just in case */
; 5314 : 	OP_SetEvent(pPlayAudio->hevTimerThreadActive);

  01aea	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  01aed	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0
  01af4	52		 push	 edx
  01af5	e8 00 00 00 00	 call	 _OP_SetEvent
  01afa	83 c4 04	 add	 esp, 4
  01afd	5e		 pop	 esi

; 5315 : 
; 5316 :   }
; 5317 : 
; 5318 :   return;
; 5319 : }

  01afe	c3		 ret	 0
_ClosePlayDevice ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutPrepareHeader@12:NEAR
EXTRN	__imp__waveOutWrite@12:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pWaveHdr$ = 12
_uiLength$ = 16
_WriteBufferToWaveDevice PROC NEAR

; 5357 :   unsigned int uiI;
; 5358 :   int iNumberToMoveToQueueTop;
; 5359 :   unsigned int uiWriteLength;
; 5360 :   short * pWordSource;
; 5361 :   LPAUDIO_T pByteDest;
; 5362 :   LPPLAY_RING_T pPlayAudioRing;
; 5363 :   MMRESULT mmStatus;
; 5364 : //  int vol_att;
; 5365 : 
; 5366 : #ifdef AUD_DEBUG  //tek 13may97
; 5367 :   {
; 5368 : 		  char  szTemp[256]="";
; 5369 : 		  pPlayAudioRing = pPlayAudio->pPlayAudioRing;
; 5370 : 		  sprintf(szTemp,"WBTWOD size=%d at %08lx; out=%d; waiting=%d qcount=%d at %08lu\n",
; 5371 : 			  uiLength, 
; 5372 : 			  pWaveHdr,
; 5373 : 			  pPlayAudio->iOutstandingBuffers, 
; 5374 : 			  pPlayAudio->iSamplesWaitingForCompletion,
; 5375 : 			  pPlayAudioRing->iQueueCount,
; 5376 : 			  timeGetTime()
; 5377 : 			  );
; 5378 : 		  OutputDebugString(szTemp);
; 5379 :   }
; 5380 : #endif //AUD_DEBUG
; 5381 : 
; 5382 :   /********************************************************************/
; 5383 :   /*  Limit the length to be written.                                 */
; 5384 :   /********************************************************************/
; 5385 : 
; 5386 :   if ( uiLength > pPlayAudio->uiMaximumWriteLength )

  01b00	8b 54 24 04	 mov	 edx, DWORD PTR _pPlayAudio$[esp-4]
  01b04	53		 push	 ebx
  01b05	55		 push	 ebp
  01b06	8b 6c 24 14	 mov	 ebp, DWORD PTR _uiLength$[esp+4]
  01b0a	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  01b0d	56		 push	 esi
  01b0e	3b e8		 cmp	 ebp, eax
  01b10	57		 push	 edi
  01b11	76 02		 jbe	 SHORT $L71685

; 5387 :   {
; 5388 :     uiLength = pPlayAudio->uiMaximumWriteLength;

  01b13	8b e8		 mov	 ebp, eax
$L71685:

; 5389 :   }
; 5390 : 
; 5391 :   /********************************************************************/
; 5392 :   /*  If necessary, wrap the output pointer and move data.            */
; 5393 :   /*  First ensure that the next buffer of data that is written does  */
; 5394 :   /*  not extend beyond the end of the queue. If it does then all     */
; 5395 :   /*  samples starting at the the current output pointer to the last  */
; 5396 :   /*  location at the end of the queue will be moved to the extra     */
; 5397 :   /*  space above the queue start. Set the output pointer to the      */
; 5398 :   /*  start of this data and set the output position relative to      */
; 5399 :   /*  the buffer start (i.e. the output buffer position will end      */
; 5400 :   /*  up either negative or zero).                                    */
; 5401 :   /********************************************************************/
; 5402 : 
; 5403 :   pPlayAudioRing = pPlayAudio->pPlayAudioRing;

  01b15	8b 9a 98 00 00
	00		 mov	 ebx, DWORD PTR [edx+152]

; 5404 : 
; 5405 :   if ( pPlayAudioRing->iOutputPosition + (int)uiLength
; 5406 :                                     > pPlayAudioRing->iQueueLength )

  01b1b	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  01b1e	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  01b21	8d 34 29	 lea	 esi, DWORD PTR [ecx+ebp]
  01b24	3b f0		 cmp	 esi, eax
  01b26	7e 2b		 jle	 SHORT $L71687

; 5407 :   {
; 5408 :     /******************************************************************/
; 5409 :     /*  Move samples to the top of the queue.                         */
; 5410 :     /******************************************************************/
; 5411 : 
; 5412 :     iNumberToMoveToQueueTop =
; 5413 :       pPlayAudioRing->iQueueLength - pPlayAudioRing->iOutputPosition;
; 5414 : 
; 5415 :     /******************************************************************/
; 5416 :     /*  pByteSource = pPlayAudioRing->pQueueOutput;                   */
; 5417 :     /*  pByteDest =                                                   */
; 5418 :     /*    pPlayAudioRing->pQueueStart - iNumberToMoveToQueueTop;      */
; 5419 :     /*                                                                */
; 5420 :     /*  for ( uiI = 0; uiI < iNumberToMoveToQueueTop; uiI++ )         */
; 5421 :     /*    *pByteDest++ = *pByteSource++;                              */
; 5422 :     /******************************************************************/
; 5423 : 
; 5424 :     memcpy( pPlayAudioRing->pQueueStart - iNumberToMoveToQueueTop,
; 5425 :             pPlayAudioRing->pQueueOutput,
; 5426 :             iNumberToMoveToQueueTop );

  01b28	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  01b2b	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
  01b2e	2b c1		 sub	 eax, ecx
  01b30	8b c8		 mov	 ecx, eax
  01b32	2b f8		 sub	 edi, eax
  01b34	8b d1		 mov	 edx, ecx
  01b36	c1 e9 02	 shr	 ecx, 2
  01b39	f3 a5		 rep movsd
  01b3b	8b ca		 mov	 ecx, edx

; 5427 : 
; 5428 :     pPlayAudioRing->pQueueOutput =
; 5429 :       pPlayAudioRing->pQueueStart - iNumberToMoveToQueueTop;
; 5430 :     pPlayAudioRing->iOutputPosition = - iNumberToMoveToQueueTop;

  01b3d	8b 54 24 14	 mov	 edx, DWORD PTR _pPlayAudio$[esp+12]
  01b41	83 e1 03	 and	 ecx, 3
  01b44	f3 a4		 rep movsb
  01b46	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  01b49	2b c8		 sub	 ecx, eax
  01b4b	f7 d8		 neg	 eax
  01b4d	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx
  01b50	89 43 14	 mov	 DWORD PTR [ebx+20], eax
$L71687:

; 5431 :   }
; 5432 : 
; 5433 :   /********************************************************************/
; 5434 :   /*  If the waveOutOpen() function has opened a device that requires */
; 5435 :   /*  8 bit samples and 16 bit samples were queued, then convert the  */
; 5436 :   /*  samples to 8 bits here.                                         */
; 5437 :   /********************************************************************/
; 5438 : 
; 5439 : #ifdef VOLUME_MOVED_TO_VTM
; 5440 : 	if ((((LPTTS_HANDLE_T)(pPlayAudio->aInstance))->pKernelShareData->vol_att)!=100)
; 5441 : 	{
; 5442 : 		vol_att=int_volume_table[(((LPTTS_HANDLE_T)(pPlayAudio->aInstance))->pKernelShareData->vol_att)];
; 5443 : 		pWordSource=(short *)pPlayAudioRing->pQueueOutput;
; 5444 : 
; 5445 : 
; 5446 : 		for (uiI=0;uiI<uiLength ;uiI+=2)
; 5447 : 		{
; 5448 : 			*pWordSource=(short)((vol_att * (int)(*pWordSource)) >> 15);
; 5449 : 			pWordSource++;
; 5450 : 		}
; 5451 : 	}
; 5452 : #endif
; 5453 : 
; 5454 :   if ( pPlayAudio->bConvertToEightBit )

  01b53	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  01b56	33 ff		 xor	 edi, edi
  01b58	3b c7		 cmp	 eax, edi
  01b5a	74 28		 je	 SHORT $L71688

; 5455 :   {
; 5456 :     pByteDest = pPlayAudioRing->pQueueOutput;

  01b5c	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 5457 :     pWordSource = (short *)pByteDest;
; 5458 : 
; 5459 :     for ( uiI = 0; uiI < uiLength; uiI+=2 )

  01b5f	3b ef		 cmp	 ebp, edi
  01b61	8b f0		 mov	 esi, eax
  01b63	76 19		 jbe	 SHORT $L71692
  01b65	8d 7d 01	 lea	 edi, DWORD PTR [ebp+1]
  01b68	d1 ef		 shr	 edi, 1
$L71690:

; 5460 :       *pByteDest++ = (unsigned char)((*pWordSource++) >> 8 ) ^ 0x80;

  01b6a	66 8b 0e	 mov	 cx, WORD PTR [esi]
  01b6d	83 c6 02	 add	 esi, 2
  01b70	c1 f9 08	 sar	 ecx, 8
  01b73	80 f1 80	 xor	 cl, 128			; 00000080H
  01b76	88 08		 mov	 BYTE PTR [eax], cl
  01b78	40		 inc	 eax
  01b79	4f		 dec	 edi
  01b7a	75 ee		 jne	 SHORT $L71690

; 5457 :     pWordSource = (short *)pByteDest;
; 5458 : 
; 5459 :     for ( uiI = 0; uiI < uiLength; uiI+=2 )

  01b7c	33 ff		 xor	 edi, edi
$L71692:

; 5461 : 
; 5462 :     uiWriteLength = uiLength >> 1;

  01b7e	8b c5		 mov	 eax, ebp
  01b80	d1 e8		 shr	 eax, 1

; 5463 :   }
; 5464 :   else

  01b82	eb 02		 jmp	 SHORT $L71694
$L71688:

; 5465 :   {
; 5466 :     uiWriteLength = uiLength;

  01b84	8b c5		 mov	 eax, ebp
$L71694:

; 5467 :   }
; 5468 : 
; 5469 :   /********************************************************************/
; 5470 :   /*  Set up the WAVEHDR structure.                                   */
; 5471 :   /*  Save the buffer length in the high 16 bits of the dwUser        */
; 5472 :   /*  element of the wave header.                                     */
; 5473 :   /********************************************************************/
; 5474 : 
; 5475 : #ifdef UNDER_CE
; 5476 :   if (!pPlayAudio->bConvertToEightBit && uiWriteLength & 0x01) {
; 5477 : 
; 5478 : #ifndef NOWIN
; 5479 : 	  if (uiWriteLength & 0x01)			  
; 5480 : 		  MessageBox(NULL, _T("Misalligned data"), _T("DECtalk"), MB_OK);
; 5481 : #endif
; 5482 : 
; 5483 : 	  return uiWriteLength;			// Throw away the packet!!!
; 5484 :   }
; 5485 : #endif
; 5486 : #ifdef __ipaq__
; 5487 : 	uiWriteLength&=~0x03;
; 5488 : #endif
; 5489 :   pWaveHdr->lpData          = (char *)pPlayAudioRing->pQueueOutput;

  01b86	8b 74 24 18	 mov	 esi, DWORD PTR _pWaveHdr$[esp+12]
  01b8a	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]

; 5490 :   pWaveHdr->dwBufferLength  = uiWriteLength;
; 5491 :   pWaveHdr->dwBytesRecorded = 0L;
; 5492 :   pWaveHdr->dwUser          = (DWORD)uiLength;
; 5493 :   pWaveHdr->dwFlags         = 0L;
; 5494 :   pWaveHdr->dwLoops         = 0L;
; 5495 :   pWaveHdr->lpNext          = NULL;
; 5496 :   pWaveHdr->reserved        = 0L;
; 5497 : 
; 5498 :   /********************************************************************/
; 5499 :   /*  Prepare the header for the waveOutWrite() function.             */
; 5500 :   /********************************************************************/
; 5501 : 
; 5502 : #ifndef USE_MME_SERVER
; 5503 : 
; 5504 :   mmStatus = waveOutPrepareHeader( pPlayAudio->hWaveOut,
; 5505 :                                    pWaveHdr,
; 5506 :                                    sizeof(WAVEHDR));

  01b8d	6a 20		 push	 32			; 00000020H
  01b8f	56		 push	 esi
  01b90	89 0e		 mov	 DWORD PTR [esi], ecx
  01b92	89 46 04	 mov	 DWORD PTR [esi+4], eax
  01b95	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  01b98	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  01b9b	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  01b9e	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  01ba1	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  01ba4	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  01ba7	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  01baa	52		 push	 edx
  01bab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutPrepareHeader@12

; 5507 : 
; 5508 :   if ( mmStatus != MMSYSERR_NOERROR )

  01bb1	3b c7		 cmp	 eax, edi
  01bb3	74 17		 je	 SHORT $L71699

; 5509 :   {
; 5510 : #ifdef AUD_DEBUG
; 5511 : 	  OutputDebugString("WriteBufferToWaveDevice: waveOutPrepareHeader failed.\n");
; 5512 : #endif
; 5513 : 	  ReportStatusToApplication( pPlayAudio,
; 5514 :                                PA_WRITE_ERROR,
; 5515 :                                mmStatus );

  01bb5	50		 push	 eax
  01bb6	8b 44 24 18	 mov	 eax, DWORD PTR _pPlayAudio$[esp+16]
  01bba	6a 07		 push	 7
  01bbc	50		 push	 eax

; 5561 :   }
; 5562 :   else
; 5563 :   {
; 5564 :     /******************************************************************/
; 5565 :     /*  Report any errors that occured.                               */
; 5566 :     /******************************************************************/
; 5567 : #ifdef AUD_DEBUG
; 5568 : 	OutputDebugString("WriteBufferToWaveDevice: waveOutWrite failed.\n");
; 5569 : #endif
; 5570 :     ReportStatusToApplication( pPlayAudio,
; 5571 :                                PA_WRITE_ERROR,
; 5572 :                                mmStatus );

  01bbd	e8 00 00 00 00	 call	 _ReportStatusToApplication
  01bc2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5573 :     return 0;

  01bc5	33 c0		 xor	 eax, eax
  01bc7	5f		 pop	 edi
  01bc8	5e		 pop	 esi
  01bc9	5d		 pop	 ebp
  01bca	5b		 pop	 ebx

; 5577 : }

  01bcb	c3		 ret	 0
$L71699:

; 5516 :     return 0;
; 5517 :   }
; 5518 : 
; 5519 : #endif
; 5520 : 
; 5521 :   /********************************************************************/
; 5522 :   /*  Write the buffer to the wave output device.                     */
; 5523 :   /********************************************************************/
; 5524 : 
; 5525 :   LOCK_MME_CALL( mmStatus = waveOutWrite( pPlayAudio->hWaveOut,
; 5526 :                                           pWaveHdr,
; 5527 :                                           sizeof(WAVEHDR)))

  01bcc	6a 20		 push	 32			; 00000020H
  01bce	56		 push	 esi
  01bcf	8b 74 24 1c	 mov	 esi, DWORD PTR _pPlayAudio$[esp+20]
  01bd3	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01bd6	51		 push	 ecx
  01bd7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutWrite@12

; 5528 : 
; 5529 :   if ( mmStatus == MMSYSERR_NOERROR )

  01bdd	3b c7		 cmp	 eax, edi
  01bdf	75 2c		 jne	 SHORT $L71701

; 5530 :   {
; 5531 : 	  // tek 09may97
; 5532 : 	  pPlayAudio->iOutstandingBuffers++;// keep track..

  01be1	8b be a4 00 00
	00		 mov	 edi, DWORD PTR [esi+164]

; 5533 : #ifdef USE_MME_SERVER
; 5534 : 
; 5535 :     /******************************************************************/
; 5536 :     /*  MME BUG WORKAROUND. Because the MME server currently does not */
; 5537 :     /*  return wave headers in the correct order, it is necessary to  */
; 5538 :     /*  put wave headers on a list whenever a wave header is written  */
; 5539 :     /*  by the waveOutWrite() function. This list is accessed in the  */
; 5540 :     /*  wave output callback routine to determine the current header. */
; 5541 :     /******************************************************************/
; 5542 : 
; 5543 :     pPlayAudio->ppWaveHdrInUseList[pPlayAudio->uiWaveHdrWriteIndex] = pWaveHdr;
; 5544 : 
; 5545 :     pPlayAudio->uiWaveHdrWriteIndex++;
; 5546 : 
; 5547 :     if ( pPlayAudio->uiWaveHdrWriteIndex >= MAXIMUM_BUFFERS_QUEUED )
; 5548 :     {
; 5549 :       pPlayAudio->uiWaveHdrWriteIndex = 0;
; 5550 :     }
; 5551 : 
; 5552 : #endif
; 5553 : 
; 5554 :     /******************************************************************/
; 5555 :     /*  Update the output pointers and the "samples waiting" count.   */
; 5556 :     /******************************************************************/
; 5557 : 
; 5558 :     pPlayAudio->iSamplesWaitingForCompletion += uiLength;

  01be7	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  01bea	47		 inc	 edi
  01beb	03 d5		 add	 edx, ebp
  01bed	89 be a4 00 00
	00		 mov	 DWORD PTR [esi+164], edi
  01bf3	89 56 30	 mov	 DWORD PTR [esi+48], edx

; 5559 :     pPlayAudioRing->pQueueOutput += uiLength;

  01bf6	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]

; 5560 :     pPlayAudioRing->iOutputPosition += uiLength;

  01bf9	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  01bfc	03 cd		 add	 ecx, ebp
  01bfe	03 c5		 add	 eax, ebp
  01c00	89 43 14	 mov	 DWORD PTR [ebx+20], eax
  01c03	5f		 pop	 edi

; 5574 :   }
; 5575 : 
; 5576 :   return uiLength;

  01c04	8b c5		 mov	 eax, ebp
  01c06	5e		 pop	 esi
  01c07	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx
  01c0a	5d		 pop	 ebp
  01c0b	5b		 pop	 ebx

; 5577 : }

  01c0c	c3		 ret	 0
$L71701:

; 5561 :   }
; 5562 :   else
; 5563 :   {
; 5564 :     /******************************************************************/
; 5565 :     /*  Report any errors that occured.                               */
; 5566 :     /******************************************************************/
; 5567 : #ifdef AUD_DEBUG
; 5568 : 	OutputDebugString("WriteBufferToWaveDevice: waveOutWrite failed.\n");
; 5569 : #endif
; 5570 :     ReportStatusToApplication( pPlayAudio,
; 5571 :                                PA_WRITE_ERROR,
; 5572 :                                mmStatus );

  01c0d	50		 push	 eax
  01c0e	6a 07		 push	 7
  01c10	56		 push	 esi
  01c11	e8 00 00 00 00	 call	 _ReportStatusToApplication
  01c16	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5573 :     return 0;

  01c19	33 c0		 xor	 eax, eax
  01c1b	5f		 pop	 edi
  01c1c	5e		 pop	 esi
  01c1d	5d		 pop	 ebp
  01c1e	5b		 pop	 ebx

; 5577 : }

  01c1f	c3		 ret	 0
_WriteBufferToWaveDevice ENDP
_pPlayAudio$ = 8
_ProcessOpenWaveOutputDeviceMessage PROC NEAR

; 5605 : {

  01c20	56		 push	 esi

; 5606 :   /********************************************************************/
; 5607 :   /*  If the wave output device is not closed then abort.             */
; 5608 :   /*  This check is necessary because the PA_Queue() function and     */
; 5609 :   /*  the Timer thread might send both the ID_Open_Wave_Output_Device */
; 5610 :   /*  message before either occurence of the message can be processed */
; 5611 :   /*  Also abort if the pause flag is set.                            */
; 5612 :   /********************************************************************/
; 5613 : 
; 5614 :   if (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )
; 5615 :     && ( ! pPlayAudio->bPaused ))

  01c21	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  01c25	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  01c28	85 c0		 test	 eax, eax
  01c2a	75 5c		 jne	 SHORT $L72195
  01c2c	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  01c2f	85 c0		 test	 eax, eax
  01c31	75 55		 jne	 SHORT $L72195

; 5616 :   {
; 5617 :     /******************************************************************/
; 5618 :     /*  IF the wave output device is owned by the application and     */
; 5619 :     /*     the wave output device is already opened,                  */
; 5620 :     /*  THEN                                                          */
; 5621 :     /*    There will be no MM_WOM_OPEN message generated so start     */
; 5622 :     /*    audio playing right now.                                    */
; 5623 :     /*  ELSE                                                          */
; 5624 :     /*    Open the wave audio device.                                 */
; 5625 :     /*    The Process_MM_WOM_OPEN_Message function will start audio   */
; 5626 :     /*    playing later.                                              */
; 5627 :     /******************************************************************/
; 5628 : 
; 5629 :     if (( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )
; 5630 :       && ( pPlayAudio->hWaveOut != (int)NULL ))

  01c33	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  01c37	74 1d		 je	 SHORT $L71709
  01c39	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01c3c	85 c0		 test	 eax, eax
  01c3e	74 16		 je	 SHORT $L71709

; 5631 :     {
; 5632 :       /****************************************************************/
; 5633 :       /*  Block the PA_WaitForPlayToComplete() function.              */
; 5634 :       /****************************************************************/
; 5635 : 
; 5636 :       OP_ResetEvent( pPlayAudio->hevAudioDeviceInactive );

  01c40	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  01c43	50		 push	 eax
  01c44	e8 00 00 00 00	 call	 _OP_ResetEvent

; 5637 : 
; 5638 :       /****************************************************************/
; 5639 :       /*  Set the device state.                                       */
; 5640 :       /****************************************************************/
; 5641 : 
; 5642 : 	  // tek 16mar98 we should never set the device state, because 
; 5643 : 	  // StartAudioPlaying manages that..! (bats622)
; 5644 :       //OP_LockMutex( pPlayAudio->hmxAudioDeviceState );
; 5645 :       //pPlayAudio->dwAudioDeviceState = AUDIO_DEVICE_ACTIVE;
; 5646 :       //OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );
; 5647 : 
; 5648 :       StartAudioPlaying( pPlayAudio );

  01c49	56		 push	 esi
  01c4a	e8 00 00 00 00	 call	 _StartAudioPlaying
  01c4f	83 c4 08	 add	 esp, 8

; 5667 :       }
; 5668 :     }
; 5669 :   }
; 5670 : 
; 5671 :   return FALSE;

  01c52	33 c0		 xor	 eax, eax
  01c54	5e		 pop	 esi

; 5672 : }

  01c55	c3		 ret	 0
$L71709:

; 5649 :     }
; 5650 :     else
; 5651 :     {
; 5652 :       if ( OpenWaveOutputDevice( pPlayAudio ) == MMSYSERR_NOERROR )

  01c56	56		 push	 esi
  01c57	e8 00 00 00 00	 call	 _OpenWaveOutputDevice
  01c5c	83 c4 04	 add	 esp, 4
  01c5f	85 c0		 test	 eax, eax
  01c61	75 25		 jne	 SHORT $L72195

; 5653 :       {
; 5654 :         /**************************************************************/
; 5655 :         /*  Block the PA_WaitForPlayToComplete() function.            */
; 5656 :         /**************************************************************/
; 5657 : 
; 5658 :         OP_ResetEvent( pPlayAudio->hevAudioDeviceInactive );

  01c63	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  01c66	51		 push	 ecx
  01c67	e8 00 00 00 00	 call	 _OP_ResetEvent

; 5659 : 
; 5660 :         /**************************************************************/
; 5661 :         /*  Set the device state.                                     */
; 5662 :         /**************************************************************/
; 5663 : 
; 5664 :         OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  01c6c	8b 56 70	 mov	 edx, DWORD PTR [esi+112]
  01c6f	52		 push	 edx
  01c70	e8 00 00 00 00	 call	 _OP_LockMutex

; 5665 :         pPlayAudio->dwAudioDeviceState = AUDIO_DEVICE_STARTING_UP;
; 5666 :         OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  01c75	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  01c78	c7 46 34 01 00
	00 00		 mov	 DWORD PTR [esi+52], 1
  01c7f	50		 push	 eax
  01c80	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01c85	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72195:

; 5667 :       }
; 5668 :     }
; 5669 :   }
; 5670 : 
; 5671 :   return FALSE;

  01c88	33 c0		 xor	 eax, eax
  01c8a	5e		 pop	 esi

; 5672 : }

  01c8b	c3		 ret	 0
_ProcessOpenWaveOutputDeviceMessage ENDP
_TEXT	ENDS
PUBLIC	_WaveOutCallbackRoutine@20
EXTRN	__imp__waveOutOpen@24:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_dwSampleRate$ = -4
_mmStatus$ = 8
_OpenWaveOutputDevice PROC NEAR

; 5701 : {

  01c90	51		 push	 ecx
  01c91	53		 push	 ebx
  01c92	55		 push	 ebp
  01c93	56		 push	 esi
  01c94	57		 push	 edi

; 5702 :   DWORD dwSampleRate=0;
; 5703 :   DWORD dwNumberOfChannels=0;
; 5704 :   DWORD dwBytesPerSample=0;
; 5705 :   DWORD dwOpenFlags=0;
; 5706 :   LPWAVEFORMATEX pWaveFormat;
; 5707 :   MMRESULT mmStatus;
; 5708 : 
; 5709 :   /********************************************************************/
; 5710 :   /*  The default state is no sample conversion.                      */
; 5711 :   /********************************************************************/
; 5712 : 
; 5713 :   pPlayAudio->bConvertToEightBit = FALSE;

  01c95	8b 7c 24 18	 mov	 edi, DWORD PTR _pPlayAudio$[esp+16]
  01c99	33 d2		 xor	 edx, edx
  01c9b	33 db		 xor	 ebx, ebx
  01c9d	89 54 24 10	 mov	 DWORD PTR _dwSampleRate$[esp+20], edx

; 5714 : 
; 5715 :   /********************************************************************/
; 5716 :   /*  Initialize the local WAVEFORMATEX structure.                    */
; 5717 :   /********************************************************************/
; 5718 : 
; 5719 :   pWaveFormat = pPlayAudio->pWaveFormat;

  01ca1	8b b7 a0 00 00
	00		 mov	 esi, DWORD PTR [edi+160]
  01ca7	89 57 50	 mov	 DWORD PTR [edi+80], edx

; 5720 : 
; 5721 :   /********************************************************************/
; 5722 :   /*  If the WAVEFORMATEX data structure has a wFormatTag element     */
; 5723 :   /*  equal to WAVE_FORMAT_PCM then the device is opened for either   */
; 5724 :   /*  16 or 8 bit output. Whether 8 or 16 bits will succeed depends   */
; 5725 :   /*  on the audio data size and the audio driver. If the audio       */
; 5726 :   /*  samples are 16 bits and only 8 bit output is supported by the   */
; 5727 :   /*  audio driver then the 16 bit audio samples are converted to 8   */
; 5728 :   /*  bit audio samples in the WriteBufferToWaveDevice() function.    */
; 5729 :   /*  This conversion is indicated by the bConvertToEightBit flag.    */
; 5730 :   /*  The wBitsPerSample element, the nChannels element , and         */
; 5731 :   /*  the nSamplesPerSec element of the WAVEFORMATEX structure are    */
; 5732 :   /*  used to calculate the values of the other elements of the       */
; 5733 :   /*  WAVEFORMATEX structure.                                         */
; 5734 :   /*                                                                  */
; 5735 :   /*  If the wFormatTag element of the WAVEFORMATEX structure         */
; 5736 :   /*  is NOT equal to WAVE_FORMAT_PCM then all of the fields of the   */
; 5737 :   /*  WAVEFORMATEX structure must be filled in and are used in the    */
; 5738 :   /*  call to the waveOutOpen() function.                             */
; 5739 :   /********************************************************************/
; 5740 : 
; 5741 :   if ( pWaveFormat->wFormatTag == WAVE_FORMAT_PCM )

  01caa	66 83 3e 01	 cmp	 WORD PTR [esi], 1
  01cae	75 2a		 jne	 SHORT $L71721

; 5742 :   {
; 5743 :     /******************************************************************/
; 5744 :     /*  The wFormatTag element is equal to WAVE_FORMAT_PCM.           */
; 5745 :     /******************************************************************/
; 5746 : 
; 5747 :     dwSampleRate = pWaveFormat->nSamplesPerSec;
; 5748 :     dwNumberOfChannels = pWaveFormat->nChannels;

  01cb0	66 8b 5e 02	 mov	 bx, WORD PTR [esi+2]

; 5749 :     dwBytesPerSample = pWaveFormat->wBitsPerSample >> 3;

  01cb4	33 c0		 xor	 eax, eax
  01cb6	66 8b 46 0e	 mov	 ax, WORD PTR [esi+14]
  01cba	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  01cbd	c1 e8 03	 shr	 eax, 3

; 5750 : 
; 5751 :     /******************************************************************/
; 5752 :     /*  Initialize other WAVEFORMATEX structure elements.             */
; 5753 :     /******************************************************************/
; 5754 : 
; 5755 :     pWaveFormat->nAvgBytesPerSec =
; 5756 :       dwSampleRate * dwNumberOfChannels * dwBytesPerSample;

  01cc0	8b e8		 mov	 ebp, eax
  01cc2	89 4c 24 10	 mov	 DWORD PTR _dwSampleRate$[esp+20], ecx
  01cc6	0f af eb	 imul	 ebp, ebx
  01cc9	0f af e9	 imul	 ebp, ecx

; 5757 : #ifdef __ipaq__
; 5758 :     pWaveFormat->nBlockAlign =
; 5759 :       (WORD)( dwNumberOfChannels * dwBytesPerSample * 2 );
; 5760 : #else
; 5761 :     pWaveFormat->nBlockAlign =
; 5762 :       (WORD)( dwNumberOfChannels * dwBytesPerSample );

  01ccc	0f af c3	 imul	 eax, ebx
  01ccf	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  01cd2	66 89 46 0c	 mov	 WORD PTR [esi+12], ax

; 5763 : #endif
; 5764 :     pWaveFormat->cbSize = 0;

  01cd6	66 89 56 10	 mov	 WORD PTR [esi+16], dx
$L71721:

; 5765 : 
; 5766 :   }
; 5767 : 
; 5768 :   /********************************************************************/
; 5769 :   /*  Set the wave out device open flags.                             */
; 5770 :   /********************************************************************/
; 5771 : 
; 5772 :   dwOpenFlags = CALLBACK_FUNCTION;
; 5773 :   
; 5774 : #ifdef USE_MME_SERVER
; 5775 : 
; 5776 :   /********************************************************************/
; 5777 :   /*  If the WAVE_OPEN_SHARE bit is set in the device options then    */
; 5778 :   /*  enable device sharing.                                          */
; 5779 :   /********************************************************************/
; 5780 : 
; 5781 :   if ( pPlayAudio->dwDeviceOptions & WAVE_OPEN_SHAREABLE )
; 5782 :   {
; 5783 :     dwOpenFlags |= WAVE_OPEN_SHAREABLE;
; 5784 :   }
; 5785 : 
; 5786 : #endif
; 5787 : 
; 5788 :   /********************************************************************/
; 5789 :   /*  Attempt to open the wave output device.                         */
; 5790 :   /********************************************************************/
; 5791 : #ifdef AUD_DEBUG
; 5792 :   OutputDebugString("OpenWaveOutputDevice: waveOutOpen() {1}\n");
; 5793 : #endif
; 5794 : 
; 5795 : #ifdef OS_SIXTY_FOUR_BIT
; 5796 :  
; 5797 :   LOCK_MME_CALL(
; 5798 :     mmStatus = waveOutOpen( &(pPlayAudio->hWaveOut),
; 5799 :                             pPlayAudio->uiSelectedDeviceID,
; 5800 :                             (LPWAVEFORMAT)pWaveFormat,
; 5801 :                             WaveOutCallbackRoutine,
; 5802 :                             pPlayAudio->uiHandleListIndex,
; 5803 :                             dwOpenFlags ))
; 5804 : #else
; 5805 :  
; 5806 :   LOCK_MME_CALL(
; 5807 :     mmStatus = waveOutOpen( &(pPlayAudio->hWaveOut),
; 5808 :                             pPlayAudio->uiSelectedDeviceID,
; 5809 :                             (LPWAVEFORMATEX)pWaveFormat,
; 5810 :                             (DWORD)WaveOutCallbackRoutine,
; 5811 :                             (DWORD)pPlayAudio,
; 5812 :                             dwOpenFlags ))

  01cda	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  01cdd	68 00 00 03 00	 push	 196608			; 00030000H
  01ce2	57		 push	 edi
  01ce3	68 00 00 00 00	 push	 OFFSET FLAT:_WaveOutCallbackRoutine@20
  01ce8	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  01ceb	56		 push	 esi
  01cec	51		 push	 ecx
  01ced	50		 push	 eax
  01cee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutOpen@24
  01cf4	8b e8		 mov	 ebp, eax

; 5813 : #endif
; 5814 : 
; 5815 : #ifdef USE_MME_SERVER
; 5816 : 
; 5817 :   /********************************************************************/
; 5818 :   /*  THIS IS PROBABLY NOT NECESSARY, BUT IT CANNOT HURT.             */
; 5819 :   /*  The MME servers waveOutOpen() function returns a value of       */
; 5820 :   /*  WAVERR_DEVICESHAREABLE if the device is shareable. Change       */
; 5821 :   /*  this to MMSYSERR_NOERROR.                                       */
; 5822 :   /********************************************************************/
; 5823 : 
; 5824 :   if (( pPlayAudio->dwDeviceOptions & WAVE_OPEN_SHAREABLE )
; 5825 :     && ( mmStatus == WAVERR_DEVICESHAREABLE ))
; 5826 :   {
; 5827 :     mmStatus = MMSYSERR_NOERROR;
; 5828 :   }
; 5829 : 
; 5830 : #endif
; 5831 : 
; 5832 :   /********************************************************************/
; 5833 :   /*  If the requested wave output format is WAVE_FORMAT_PCM and the  */
; 5834 :   /*  number of bits per sample is 16 and the format is not supported */
; 5835 :   /*  then try to open the wave output device for 8 bit samples.      */
; 5836 :   /********************************************************************/
; 5837 : 
; 5838 :   if  (( mmStatus == WAVERR_BADFORMAT )
; 5839 :     && ( pWaveFormat->wFormatTag == WAVE_FORMAT_PCM )
; 5840 :     && ( pWaveFormat->wBitsPerSample == 16 ))

  01cf6	83 fd 20	 cmp	 ebp, 32			; 00000020H
  01cf9	75 5e		 jne	 SHORT $L71726
  01cfb	66 83 3e 01	 cmp	 WORD PTR [esi], 1
  01cff	75 5c		 jne	 SHORT $L72199
  01d01	66 83 7e 0e 10	 cmp	 WORD PTR [esi+14], 16	; 00000010H
  01d06	75 55		 jne	 SHORT $L72199

; 5841 :   {
; 5842 :     /******************************************************************/
; 5843 :     /*  Initialize other WAVEFORMATEX structure elements for 8 bit    */
; 5844 :     /*  data.                                                         */
; 5845 :     /******************************************************************/
; 5846 : 
; 5847 :     pWaveFormat->nAvgBytesPerSec = dwSampleRate * dwNumberOfChannels;

  01d08	8b eb		 mov	 ebp, ebx

; 5848 :     pWaveFormat->nBlockAlign = (WORD)dwNumberOfChannels;
; 5849 :     pWaveFormat->wBitsPerSample = 8;
; 5850 : 
; 5851 :     /******************************************************************/
; 5852 :     /*  Attempt to open the wave output device.                       */
; 5853 :     /******************************************************************/
; 5854 : #ifdef AUD_DEBUG
; 5855 :     OutputDebugString("OpenWaveOutputDevice: waveOutOpen() {2}\n");
; 5856 : #endif
; 5857 : 
; 5858 : #ifdef OS_SIXTY_FOUR_BIT
; 5859 : 
; 5860 :     LOCK_MME_CALL(
; 5861 :       mmStatus = waveOutOpen( &(pPlayAudio->hWaveOut),
; 5862 :                               pPlayAudio->uiSelectedDeviceID,
; 5863 :                               (LPWAVEFORMAT)pWaveFormat,
; 5864 :                               WaveOutCallbackRoutine,
; 5865 :                               pPlayAudio->uiHandleListIndex,
; 5866 :                               dwOpenFlags ))
; 5867 : #else
; 5868 : 
; 5869 :     LOCK_MME_CALL(
; 5870 :       mmStatus = waveOutOpen( &(pPlayAudio->hWaveOut),
; 5871 :                               pPlayAudio->uiSelectedDeviceID,
; 5872 :                               (LPWAVEFORMATEX)pWaveFormat,
; 5873 :                               (DWORD)WaveOutCallbackRoutine,
; 5874 :                               (DWORD)pPlayAudio,
; 5875 :                               dwOpenFlags ))

  01d0a	68 00 00 03 00	 push	 196608			; 00030000H
  01d0f	0f af 6c 24 14	 imul	 ebp, DWORD PTR _dwSampleRate$[esp+24]
  01d14	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  01d17	66 89 5e 0c	 mov	 WORD PTR [esi+12], bx
  01d1b	66 c7 46 0e 08
	00		 mov	 WORD PTR [esi+14], 8
  01d21	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
  01d24	57		 push	 edi
  01d25	68 00 00 00 00	 push	 OFFSET FLAT:_WaveOutCallbackRoutine@20
  01d2a	56		 push	 esi
  01d2b	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  01d2e	52		 push	 edx
  01d2f	50		 push	 eax
  01d30	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutOpen@24
  01d36	89 44 24 18	 mov	 DWORD PTR _mmStatus$[esp+16], eax

; 5876 : #endif
; 5877 : 
; 5878 : #ifdef USE_MME_SERVER
; 5879 : 
; 5880 :     /******************************************************************/
; 5881 :     /*  THIS IS PROBABLY NOT NECESSARY, BUT IT CANNOT HURT.           */
; 5882 :     /*  The MME servers waveOutOpen() function returns a value of     */
; 5883 :     /*  WAVERR_DEVICESHAREABLE if the device is shareable. Change     */
; 5884 :     /*  this to MMSYSERR_NOERROR.                                     */
; 5885 :     /******************************************************************/
; 5886 : 
; 5887 :     if (( pPlayAudio->dwDeviceOptions & WAVE_OPEN_SHAREABLE )
; 5888 :       && ( mmStatus == WAVERR_DEVICESHAREABLE ))
; 5889 :     {
; 5890 :       mmStatus = MMSYSERR_NOERROR;
; 5891 :     }
; 5892 : 
; 5893 : #endif
; 5894 : 
; 5895 :     /******************************************************************/
; 5896 :     /*  Reset the WAVEFORMATEX structure elements for 16 bit data.    */
; 5897 :     /******************************************************************/
; 5898 : 
; 5899 :     pWaveFormat->nAvgBytesPerSec =
; 5900 :       dwSampleRate * dwNumberOfChannels << 1;

  01d3a	8d 44 2d 00	 lea	 eax, DWORD PTR [ebp+ebp]

; 5901 :     pWaveFormat->nBlockAlign = (WORD)( dwNumberOfChannels << 1 );
; 5902 :     pWaveFormat->wBitsPerSample = 16;
; 5903 : 
; 5904 :     pPlayAudio->bConvertToEightBit = TRUE;

  01d3e	8b 6c 24 18	 mov	 ebp, DWORD PTR _mmStatus$[esp+16]
  01d42	8d 0c 1b	 lea	 ecx, DWORD PTR [ebx+ebx]
  01d45	89 46 08	 mov	 DWORD PTR [esi+8], eax
  01d48	66 89 4e 0c	 mov	 WORD PTR [esi+12], cx
  01d4c	66 c7 46 0e 10
	00		 mov	 WORD PTR [esi+14], 16	; 00000010H
  01d52	c7 47 50 01 00
	00 00		 mov	 DWORD PTR [edi+80], 1
$L71726:

; 5905 :   }
; 5906 : 
; 5907 :   /********************************************************************/
; 5908 :   /*  Test for an open error.                                         */
; 5909 :   /********************************************************************/
; 5910 : 
; 5911 :   if ( mmStatus )

  01d59	85 ed		 test	 ebp, ebp
  01d5b	74 1a		 je	 SHORT $L72200
$L72199:

; 5912 :   {
; 5913 :     /******************************************************************/
; 5914 :     /*  The error that occured WAS caused by another application      */
; 5915 :     /*  owning the wave output device.                                */
; 5916 :     /******************************************************************/
; 5917 : #ifdef AUD_DEBUG
; 5918 : 	  {
; 5919 : #include <stdio.h>
; 5920 : 		  char szTemp[256]="";
; 5921 : 		  sprintf(szTemp,"OpenWaveOutputDevice: waveOutOpen failed: status=%lu (%08lx)\n",
; 5922 : 			  mmStatus, mmStatus);
; 5923 : 		  OutputDebugString(szTemp);
; 5924 : 	  }
; 5925 : #endif //AUD_DEBUG
; 5926 :     if ( pPlayAudio->bEnableOpenErrorMessage )

  01d5d	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  01d60	85 c0		 test	 eax, eax
  01d62	74 13		 je	 SHORT $L72200

; 5927 :     {
; 5928 :       if ( ! ReportStatusToApplication( pPlayAudio,
; 5929 :                                         PA_DEVICE_OPEN_FAILURE,
; 5930 :                                         mmStatus ))

  01d64	55		 push	 ebp
  01d65	6a 03		 push	 3
  01d67	57		 push	 edi
  01d68	e8 00 00 00 00	 call	 _ReportStatusToApplication
  01d6d	83 c4 0c	 add	 esp, 12			; 0000000cH
  01d70	85 c0		 test	 eax, eax
  01d72	75 03		 jne	 SHORT $L72200

; 5931 :       {
; 5932 :         pPlayAudio->bEnableOpenErrorMessage = FALSE;

  01d74	89 47 60	 mov	 DWORD PTR [edi+96], eax
$L72200:
  01d77	5f		 pop	 edi

; 5933 :       }
; 5934 :     }
; 5935 :   }
; 5936 : 
; 5937 :   return mmStatus;

  01d78	8b c5		 mov	 eax, ebp
  01d7a	5e		 pop	 esi
  01d7b	5d		 pop	 ebp
  01d7c	5b		 pop	 ebx

; 5938 : }

  01d7d	59		 pop	 ecx
  01d7e	c3		 ret	 0
_OpenWaveOutputDevice ENDP
_pWaveFormat$ = 8
_GetWaveFormatSize PROC NEAR

; 5966 :   DWORD dwSize;
; 5967 : 
; 5968 :   if ( pWaveFormat->wFormatTag == WAVE_FORMAT_PCM )

  01d80	8b 44 24 04	 mov	 eax, DWORD PTR _pWaveFormat$[esp-4]
  01d84	66 83 38 01	 cmp	 WORD PTR [eax], 1
  01d88	75 06		 jne	 SHORT $L71739

; 5969 :   {
; 5970 :     dwSize = sizeof(WAVEFORMATEX);

  01d8a	b8 12 00 00 00	 mov	 eax, 18			; 00000012H

; 5975 :   }
; 5976 : 
; 5977 :   return dwSize;
; 5978 : }

  01d8f	c3		 ret	 0
$L71739:

; 5971 :   }
; 5972 :   else
; 5973 :   {
; 5974 :     dwSize = sizeof(WAVEFORMATEX) + pWaveFormat->cbSize;

  01d90	33 c9		 xor	 ecx, ecx
  01d92	66 8b 48 10	 mov	 cx, WORD PTR [eax+16]
  01d96	8b c1		 mov	 eax, ecx
  01d98	83 c0 12	 add	 eax, 18			; 00000012H

; 5975 :   }
; 5976 : 
; 5977 :   return dwSize;
; 5978 : }

  01d9b	c3		 ret	 0
_GetWaveFormatSize ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutReset@4:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_dwVolume$71748 = 8
_ProcessResetMessage PROC NEAR

; 6006 : {

  01da0	53		 push	 ebx
  01da1	56		 push	 esi

; 6007 :   MMRESULT mmStatus;
; 6008 : 
; 6009 :   /********************************************************************/
; 6010 :   /*  This flag causes the timer thread to abandon sending any        */
; 6011 :   /*  synchronization marks until it reaches the start of the timer   */
; 6012 :   /*  thread main loop.                                               */
; 6013 :   /********************************************************************/
; 6014 : 
; 6015 :   pPlayAudio->bTimerThreadReset = TRUE;

  01da2	8b 74 24 0c	 mov	 esi, DWORD PTR _pPlayAudio$[esp+4]
  01da6	57		 push	 edi
  01da7	bf 01 00 00 00	 mov	 edi, 1

; 6016 : 
; 6017 :   // tek 22jan99 ResetAudioQueue now happens further down
; 6018 : 
; 6019 :   /********************************************************************/
; 6020 :   /*  Set audio position counts to zero.                              */
; 6021 :   /********************************************************************/
; 6022 : 
; 6023 :   pPlayAudio->dwPositionBase = 0;
; 6024 : 
; 6025 :   OP_LockMutex( pPlayAudio->hmxBytesPlayed );

  01dac	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  01daf	89 7e 6c	 mov	 DWORD PTR [esi+108], edi
  01db2	50		 push	 eax
  01db3	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], 0
  01dba	e8 00 00 00 00	 call	 _OP_LockMutex

; 6026 :   pPlayAudio->dwBytesPlayed = 0;
; 6027 :   OP_UnlockMutex( pPlayAudio->hmxBytesPlayed );

  01dbf	8b 4e 74	 mov	 ecx, DWORD PTR [esi+116]
  01dc2	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0
  01dc9	51		 push	 ecx
  01dca	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 6028 : 
; 6029 :   /********************************************************************/
; 6030 :   /*  Zero the "queued byte" counter.                                 */
; 6031 :   /********************************************************************/
; 6032 : 
; 6033 :   OP_LockMutex( pPlayAudio->hmxQueuedByteCount );

  01dcf	8b 96 84 00 00
	00		 mov	 edx, DWORD PTR [esi+132]
  01dd5	52		 push	 edx
  01dd6	e8 00 00 00 00	 call	 _OP_LockMutex

; 6034 :   pPlayAudio->dwQueuedByteCount = 0;
; 6035 :   OP_UnlockMutex( pPlayAudio->hmxQueuedByteCount );

  01ddb	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01de1	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
  01de8	50		 push	 eax
  01de9	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 6036 : 
; 6037 :   /********************************************************************/
; 6038 :   /*  Free all synchronization marks in the synchronization mark      */
; 6039 :   /*  linked list.                                                    */
; 6040 :   /********************************************************************/
; 6041 : 
; 6042 :   ClearSynchronizationMarkList( pPlayAudio );

  01dee	56		 push	 esi
  01def	e8 00 00 00 00	 call	 _ClearSynchronizationMarkList

; 6043 : 
; 6044 :   /********************************************************************/
; 6045 :   /*  If the audio device is open then reset it and return all wave   */
; 6046 :   /*  headers. Then the Process_MM_WOM_DONE_Message() function will   */
; 6047 :   /*  clear the "Reset Complete" event when all buffers have          */
; 6048 :   /*  completed. Otherwise clear the "Reset Complete" event here.     */
; 6049 :   /********************************************************************/
; 6050 : 
; 6051 :   if (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )
; 6052 :       && ( pPlayAudio->iSamplesWaitingForCompletion != 0 ))

  01df4	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  01df7	83 c4 14	 add	 esp, 20			; 00000014H
  01dfa	83 f8 02	 cmp	 eax, 2
  01dfd	0f 85 82 00 00
	00		 jne	 $L71747
  01e03	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  01e06	85 c0		 test	 eax, eax
  01e08	74 7b		 je	 SHORT $L71747

; 6053 :     {
; 6054 : #ifdef TYPING_MODE
; 6055 :       DWORD dwVolume; // tek 19nov97
; 6056 :       MMRESULT mmVolSetStatus; // tek 19nov97
; 6057 : #endif //TYPING_MODE
; 6058 :       
; 6059 :       pPlayAudio->dwAudioPlayState = AUDIO_STATE_RESET;
; 6060 : #ifdef TYPING_MODE
; 6061 :       // tek 19nov97 set the volume to zero before doing the reset, 
; 6062 :       // and put it back later.
; 6063 :       // this is part of bats518, but we need to do it here at a very
; 6064 :       // low level so we don't leave the wave device in a bad state if we
; 6065 :       // get aborted
; 6066 :       mmVolSetStatus = waveOutGetVolume(pPlayAudio->hWaveOut,&dwVolume);

  01e0a	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  01e0d	8d 4c 24 10	 lea	 ecx, DWORD PTR _dwVolume$71748[esp+8]
  01e11	51		 push	 ecx
  01e12	52		 push	 edx
  01e13	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  01e16	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetVolume@8
  01e1c	8b f8		 mov	 edi, eax

; 6067 :       if (mmVolSetStatus ==  MMSYSERR_NOERROR)

  01e1e	85 ff		 test	 edi, edi
  01e20	75 0d		 jne	 SHORT $L71750

; 6068 : 	{
; 6069 : 	  mmVolSetStatus = waveOutSetVolume(pPlayAudio->hWaveOut,0);

  01e22	50		 push	 eax
  01e23	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01e26	50		 push	 eax
  01e27	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutSetVolume@8
  01e2d	8b f8		 mov	 edi, eax
$L71750:

; 6070 : 	}
; 6071 : #endif //TYPING_MODE
; 6072 :   
; 6073 : //	We're gonna do a PAUSE / RESET / RESET
; 6074 : 	  LOCK_MME_CALL( mmStatus = waveOutPause( pPlayAudio->hWaveOut ))

  01e2f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01e32	51		 push	 ecx
  01e33	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutPause@4

; 6075 : 	  pPlayAudio->bResetPaused = TRUE;
; 6076 : 
; 6077 : 	  LOCK_MME_CALL( mmStatus = waveOutReset( pPlayAudio->hWaveOut ))

  01e39	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  01e3c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__waveOutReset@4
  01e42	52		 push	 edx
  01e43	c7 46 5c 01 00
	00 00		 mov	 DWORD PTR [esi+92], 1
  01e4a	ff d3		 call	 ebx

; 6078 : 
; 6079 :       LOCK_MME_CALL( mmStatus = waveOutReset( pPlayAudio->hWaveOut ))

  01e4c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01e4f	50		 push	 eax
  01e50	ff d3		 call	 ebx

; 6080 : 
; 6081 : #ifdef TYPING_MODE
; 6082 : 	if (mmVolSetStatus ==  MMSYSERR_NOERROR)

  01e52	85 ff		 test	 edi, edi
  01e54	8b d8		 mov	 ebx, eax
  01e56	75 0f		 jne	 SHORT $L72207

; 6083 : 	  {
; 6084 : 	    mmVolSetStatus = waveOutSetVolume(pPlayAudio->hWaveOut,dwVolume);

  01e58	8b 4c 24 10	 mov	 ecx, DWORD PTR _dwVolume$71748[esp+8]
  01e5c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  01e5f	51		 push	 ecx
  01e60	52		 push	 edx
  01e61	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutSetVolume@8
$L72207:

; 6085 : 	  }
; 6086 : #endif //TYPING_MODE
; 6087 :       
; 6088 :     }  // if (( pPlayAudio...
; 6089 :   else

  01e67	bf 01 00 00 00	 mov	 edi, 1
$L71752:

; 6103 :   }
; 6104 :   // tek 22jan99 if audio is truly dead, we can call ResetAudioQueue now.
; 6105 :   if ( pPlayAudio->iSamplesWaitingForCompletion == 0 )

  01e6c	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  01e6f	85 c0		 test	 eax, eax
  01e71	75 09		 jne	 SHORT $L72206

; 6106 :   {
; 6107 : 	  ResetAudioQueue(pPlayAudio);

  01e73	56		 push	 esi
  01e74	e8 00 00 00 00	 call	 _ResetAudioQueue
  01e79	83 c4 04	 add	 esp, 4
$L72206:

; 6108 :   }
; 6109 : 
; 6110 : 
; 6111 :   /********************************************************************/
; 6112 :   /*  Enable the sending of Device open failure error messages.       */
; 6113 :   /********************************************************************/
; 6114 : 
; 6115 :   pPlayAudio->bEnableOpenErrorMessage = TRUE;

  01e7c	89 7e 60	 mov	 DWORD PTR [esi+96], edi
  01e7f	5f		 pop	 edi

; 6116 : 
; 6117 :   return mmStatus;

  01e80	8b c3		 mov	 eax, ebx
  01e82	5e		 pop	 esi
  01e83	5b		 pop	 ebx

; 6118 : }

  01e84	c3		 ret	 0
$L71747:
  01e85	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  01e88	50		 push	 eax
  01e89	e8 00 00 00 00	 call	 _OP_SetEvent

; 6090 :     {
; 6091 :       OP_SetEvent( pPlayAudio->hevResetComplete );

  01e8e	83 c4 04	 add	 esp, 4

; 6092 : #ifdef AUD_DEBUG //tek 22may97
; 6093 :       {
; 6094 : 		  char szTemp[256]="";
; 6095 : 		  sprintf(szTemp,"ProcResetMsg: calling waveOutReset at %ld\n",
; 6096 : 			  timeGetTime()
; 6097 : 			  );
; 6098 : 		  OutputDebugString(szTemp);
; 6099 : 	  }
; 6100 : #endif //AUD_DEBUG
; 6101 : 	  
; 6102 :     mmStatus = MMSYSERR_NOERROR;

  01e91	33 db		 xor	 ebx, ebx
  01e93	eb d7		 jmp	 SHORT $L71752
_ProcessResetMessage ENDP
_pPlayAudio$ = 8
_ClearSynchronizationMarkList PROC NEAR

; 6146 : {

  01ea0	53		 push	 ebx

; 6147 :   LPSYNC_MARK_T pSyncMark;
; 6148 :   LPSYNC_MARK_T pNextSyncMark;
; 6149 : 
; 6150 :   /********************************************************************/
; 6151 :   /*  Free all synchronization marks in the synchronization mark      */
; 6152 :   /*  linked list.                                                    */
; 6153 :   /********************************************************************/
; 6154 : 
; 6155 :   OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  01ea1	8b 5c 24 08	 mov	 ebx, DWORD PTR _pPlayAudio$[esp]
  01ea5	8b 83 8c 00 00
	00		 mov	 eax, DWORD PTR [ebx+140]
  01eab	50		 push	 eax
  01eac	e8 00 00 00 00	 call	 _OP_LockMutex

; 6156 : 
; 6157 :   pSyncMark = pPlayAudio->pSyncMarkList;

  01eb1	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [ebx+156]
  01eb7	83 c4 04	 add	 esp, 4

; 6158 :   pPlayAudio->pSyncMarkList = NULL;
; 6159 : 
; 6160 :   while ( pSyncMark != NULL )

  01eba	85 c0		 test	 eax, eax
  01ebc	c7 83 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+156], 0
  01ec6	74 18		 je	 SHORT $L71763
  01ec8	56		 push	 esi
  01ec9	57		 push	 edi
  01eca	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
$L71762:

; 6161 :   {
; 6162 :     pNextSyncMark = pSyncMark->pLink;

  01ed0	8b 30		 mov	 esi, DWORD PTR [eax]

; 6163 : 
; 6164 :     free( pSyncMark );

  01ed2	50		 push	 eax
  01ed3	ff d7		 call	 edi
  01ed5	83 c4 04	 add	 esp, 4

; 6165 : 
; 6166 :     pSyncMark = pNextSyncMark;

  01ed8	8b c6		 mov	 eax, esi
  01eda	85 f6		 test	 esi, esi
  01edc	75 f2		 jne	 SHORT $L71762
  01ede	5f		 pop	 edi
  01edf	5e		 pop	 esi
$L71763:

; 6167 :   }
; 6168 : 
; 6169 :   OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  01ee0	8b 8b 8c 00 00
	00		 mov	 ecx, DWORD PTR [ebx+140]
  01ee6	51		 push	 ecx
  01ee7	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01eec	83 c4 04	 add	 esp, 4
  01eef	5b		 pop	 ebx

; 6170 : 
; 6171 :   return;
; 6172 : }

  01ef0	c3		 ret	 0
_ClearSynchronizationMarkList ENDP
_pPlayAudio$ = 8
_ResetAudioQueue PROC NEAR

; 6201 : {

  01f00	56		 push	 esi
  01f01	57		 push	 edi

; 6202 :   LPPLAY_RING_T pPlayAudioRing;
; 6203 :   unsigned int uiI; //tek 22may97
; 6204 :   pPlayAudioRing = pPlayAudio->pPlayAudioRing;

  01f02	8b 7c 24 0c	 mov	 edi, DWORD PTR _pPlayAudio$[esp+4]

; 6205 : 
; 6206 : //tek 22may97
; 6207 : #ifdef AUD_DEBUG
; 6208 :   {
; 6209 : 		  char  szTemp[256]="";
; 6210 : 		  sprintf(szTemp,"ResetAudioQueue: at %08lu\n",
; 6211 : 			  timeGetTime()
; 6212 : 			  );
; 6213 : 		  OutputDebugString(szTemp);
; 6214 :   }
; 6215 : #endif //AUD_DEBUG
; 6216 :   // tek 05nov97 bats 508? (HJ Echo problem)
; 6217 :   // this needs to be done under the QueueCount mutex..
; 6218 : 
; 6219 :   OP_LockMutex( pPlayAudio->hmxQueueCount ); // own the audio queue...

  01f06	8b 47 7c	 mov	 eax, DWORD PTR [edi+124]
  01f09	8b b7 98 00 00
	00		 mov	 esi, DWORD PTR [edi+152]
  01f0f	50		 push	 eax
  01f10	e8 00 00 00 00	 call	 _OP_LockMutex

; 6220 :   pPlayAudioRing->pQueueInput = pPlayAudioRing->pQueueStart;

  01f15	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 6221 :   pPlayAudioRing->pQueueOutput = pPlayAudioRing->pQueueStart;
; 6222 :   pPlayAudioRing->iInputPosition = 0;

  01f18	33 c9		 xor	 ecx, ecx
  01f1a	83 c4 04	 add	 esp, 4
  01f1d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  01f20	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  01f23	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 6223 :   pPlayAudioRing->iOutputPosition = 0;

  01f26	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 6224 :   pPlayAudioRing->iQueueCount = 0;

  01f29	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
  01f2c	33 c0		 xor	 eax, eax
$L71769:

; 6225 : 
; 6226 :   // we use the lpData field of each wave header to signal free/busy
; 6227 :   // for that header; so, zero them out here..
; 6228 :   for ( uiI = 0; uiI < MAXIMUM_BUFFERS_QUEUED; uiI++ )
; 6229 :       pPlayAudio->ppWaveHdr[uiI]->lpData = NULL;

  01f2e	8b 97 94 00 00
	00		 mov	 edx, DWORD PTR [edi+148]
  01f34	83 c0 04	 add	 eax, 4
  01f37	83 f8 20	 cmp	 eax, 32			; 00000020H
  01f3a	8b 54 10 fc	 mov	 edx, DWORD PTR [eax+edx-4]
  01f3e	89 0a		 mov	 DWORD PTR [edx], ecx
  01f40	7c ec		 jl	 SHORT $L71769

; 6230 : 
; 6231 :   OP_SetEvent( pPlayAudio->hevQueueNotFull );

  01f42	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  01f45	50		 push	 eax
  01f46	e8 00 00 00 00	 call	 _OP_SetEvent

; 6232 :   OP_UnlockMutex( pPlayAudio->hmxQueueCount ); // tek 05nov97 unlock..

  01f4b	8b 4f 7c	 mov	 ecx, DWORD PTR [edi+124]
  01f4e	51		 push	 ecx
  01f4f	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01f54	83 c4 08	 add	 esp, 8
  01f57	5f		 pop	 edi
  01f58	5e		 pop	 esi

; 6233 : #ifdef AUD_DEBUG
; 6234 :   {
; 6235 : 		  char  szTemp[256]="";
; 6236 : 		  sprintf(szTemp,"ResetAudioQueue: exit at %08lu\n",
; 6237 : 			  timeGetTime()
; 6238 : 			  );
; 6239 : 		  OutputDebugString(szTemp);
; 6240 :   }
; 6241 : #endif //AUD_DEBUG
; 6242 :   return;
; 6243 : }

  01f59	c3		 ret	 0
_ResetAudioQueue ENDP
_pPlayAudio$ = 8
_ProcessPauseMessage PROC NEAR

; 6270 : {

  01f60	56		 push	 esi

; 6271 :   MMRESULT mmStatus;
; 6272 : 
; 6273 :   /********************************************************************/
; 6274 :   /*  If the wave output device is active then pause it. If it is not */
; 6275 :   /*  active then set the pause flag.                                 */
; 6276 :   /********************************************************************/
; 6277 : 
; 6278 :   if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )

  01f61	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  01f65	57		 push	 edi
  01f66	83 7e 34 02	 cmp	 DWORD PTR [esi+52], 2
  01f6a	75 3e		 jne	 SHORT $L71777

; 6279 :   {
; 6280 :     LOCK_MME_CALL( mmStatus = waveOutPause( pPlayAudio->hWaveOut ))

  01f6c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01f6f	50		 push	 eax
  01f70	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutPause@4
  01f76	8b f8		 mov	 edi, eax

; 6285 :   }
; 6286 : 
; 6287 :   /********************************************************************/
; 6288 :   /*  If the restart was successful then set the pause flag.          */
; 6289 :   /********************************************************************/
; 6290 : 
; 6291 :   if ( mmStatus == MMSYSERR_NOERROR )

  01f78	85 ff		 test	 edi, edi
  01f7a	75 29		 jne	 SHORT $L72216
$L72215:

; 6292 :   {
; 6293 :     OP_LockMutex( pPlayAudio->hmxPauseFlag );

  01f7c	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  01f82	51		 push	 ecx
  01f83	e8 00 00 00 00	 call	 _OP_LockMutex

; 6294 :     pPlayAudio->bPaused = TRUE;
; 6295 : 	// Clear the reset pause, we're really paused now.
; 6296 : 	pPlayAudio->bResetPaused = FALSE;
; 6297 :     OP_UnlockMutex( pPlayAudio->hmxPauseFlag );

  01f88	8b 96 88 00 00
	00		 mov	 edx, DWORD PTR [esi+136]
  01f8e	c7 46 58 01 00
	00 00		 mov	 DWORD PTR [esi+88], 1
  01f95	52		 push	 edx
  01f96	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0
  01f9d	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01fa2	83 c4 08	 add	 esp, 8
$L72216:

; 6298 :   }
; 6299 : 
; 6300 :   return mmStatus;

  01fa5	8b c7		 mov	 eax, edi
  01fa7	5f		 pop	 edi
  01fa8	5e		 pop	 esi

; 6301 : }

  01fa9	c3		 ret	 0
$L71777:

; 6281 :   }
; 6282 :   else
; 6283 :   {
; 6284 :     mmStatus = MMSYSERR_NOERROR;

  01faa	33 ff		 xor	 edi, edi

; 6285 :   }
; 6286 : 
; 6287 :   /********************************************************************/
; 6288 :   /*  If the restart was successful then set the pause flag.          */
; 6289 :   /********************************************************************/
; 6290 : 
; 6291 :   if ( mmStatus == MMSYSERR_NOERROR )

  01fac	eb ce		 jmp	 SHORT $L72215
_ProcessPauseMessage ENDP
_pPlayAudio$ = 8
_ProcessResumeMessage PROC NEAR

; 6328 : {

  01fb0	56		 push	 esi

; 6329 :   MMRESULT mmStatus;
; 6330 : 
; 6331 :   /********************************************************************/
; 6332 :   /*  If the wave output device was paused then restart it.           */
; 6333 :   /********************************************************************/
; 6334 : 
; 6335 :   if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )

  01fb1	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  01fb5	57		 push	 edi
  01fb6	83 7e 34 02	 cmp	 DWORD PTR [esi+52], 2
  01fba	75 40		 jne	 SHORT $L71784

; 6336 :   {
; 6337 :     LOCK_MME_CALL( mmStatus = waveOutRestart( pPlayAudio->hWaveOut ))

  01fbc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01fbf	50		 push	 eax
  01fc0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutRestart@4
  01fc6	8b f8		 mov	 edi, eax

; 6342 :   }
; 6343 : 
; 6344 :   /********************************************************************/
; 6345 :   /*  If the restart was successful then reset the pause flag.        */
; 6346 :   /********************************************************************/
; 6347 : 
; 6348 :   if ( mmStatus == MMSYSERR_NOERROR )

  01fc8	85 ff		 test	 edi, edi
  01fca	75 2b		 jne	 SHORT $L72219
$L72218:

; 6349 :   {
; 6350 :     OP_LockMutex( pPlayAudio->hmxPauseFlag );

  01fcc	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  01fd2	51		 push	 ecx
  01fd3	e8 00 00 00 00	 call	 _OP_LockMutex

; 6351 :     pPlayAudio->bPaused = FALSE;
; 6352 :     OP_SetEvent( pPlayAudio->hevTimerThreadActive );

  01fd8	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  01fdb	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  01fe2	52		 push	 edx
  01fe3	e8 00 00 00 00	 call	 _OP_SetEvent

; 6353 :     OP_UnlockMutex( pPlayAudio->hmxPauseFlag );

  01fe8	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  01fee	50		 push	 eax
  01fef	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01ff4	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72219:

; 6354 :   }
; 6355 : 
; 6356 :   return mmStatus;

  01ff7	8b c7		 mov	 eax, edi
  01ff9	5f		 pop	 edi
  01ffa	5e		 pop	 esi

; 6357 : }

  01ffb	c3		 ret	 0
$L71784:

; 6338 :   }
; 6339 :   else
; 6340 :   {
; 6341 :     mmStatus = MMSYSERR_NOERROR;

  01ffc	33 ff		 xor	 edi, edi

; 6342 :   }
; 6343 : 
; 6344 :   /********************************************************************/
; 6345 :   /*  If the restart was successful then reset the pause flag.        */
; 6346 :   /********************************************************************/
; 6347 : 
; 6348 :   if ( mmStatus == MMSYSERR_NOERROR )

  01ffe	eb cc		 jmp	 SHORT $L72218
_ProcessResumeMessage ENDP
_pPlayAudio$ = 8
_pWaveFormat$ = 12
_dwSampleRate$ = -4
_ProcessSetFormatMessage PROC NEAR

; 6392 : {

  02000	51		 push	 ecx
  02001	53		 push	 ebx
  02002	55		 push	 ebp
  02003	56		 push	 esi

; 6393 :   DWORD dwSampleRate=0;
; 6394 :   DWORD dwNumberOfChannels=0;
; 6395 :   DWORD dwBytesPerSample=0;
; 6396 :   DWORD dwQueryFlags=0;
; 6397 :   MMRESULT mmStatus;
; 6398 : 
; 6399 :   /********************************************************************/
; 6400 :   /*  The wBitsPerSample element, the nChannels element, and the      */
; 6401 :   /*  nSamplesPerSec element of the WAVEFORMATEX structure are        */
; 6402 :   /*  used to calculate the values of the other elements of the       */
; 6403 :   /*  WAVEFORMATEX structure.                                         */
; 6404 :   /*                                                                  */
; 6405 :   /*  If the wFormatTag element of the WAVEFORMATEX structure         */
; 6406 :   /*  is NOT equal to WAVE_FORMAT_PCM then all of the fields of       */
; 6407 :   /*  the WAVEFORMATEX structure must be filled in and are used       */
; 6408 :   /*  in the call to the waveOutOpen() function.                      */
; 6409 :   /********************************************************************/
; 6410 : 
; 6411 :   if ( pWaveFormat->wFormatTag == WAVE_FORMAT_PCM )

  02004	8b 74 24 18	 mov	 esi, DWORD PTR _pWaveFormat$[esp+12]
  02008	57		 push	 edi
  02009	33 db		 xor	 ebx, ebx
  0200b	66 8b 0e	 mov	 cx, WORD PTR [esi]
  0200e	33 ff		 xor	 edi, edi
  02010	66 83 f9 01	 cmp	 cx, 1
  02014	89 5c 24 10	 mov	 DWORD PTR _dwSampleRate$[esp+20], ebx
  02018	75 2a		 jne	 SHORT $L71797

; 6412 :   {
; 6413 :     /******************************************************************/
; 6414 :     /*  The wFormatTag element is equal to WAVE_FORMAT_PCM.           */
; 6415 :     /******************************************************************/
; 6416 : 
; 6417 :     dwSampleRate = pWaveFormat->nSamplesPerSec;
; 6418 :     dwNumberOfChannels = pWaveFormat->nChannels;

  0201a	66 8b 7e 02	 mov	 di, WORD PTR [esi+2]

; 6419 :     dwBytesPerSample = pWaveFormat->wBitsPerSample >> 3;

  0201e	33 c0		 xor	 eax, eax
  02020	66 8b 46 0e	 mov	 ax, WORD PTR [esi+14]
  02024	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  02027	c1 e8 03	 shr	 eax, 3

; 6420 : 
; 6421 :     /******************************************************************/
; 6422 :     /*  Initialize other WAVEFORMATEX structure elements.             */
; 6423 :     /******************************************************************/
; 6424 : 
; 6425 :     pWaveFormat->nAvgBytesPerSec =
; 6426 :       dwSampleRate * dwNumberOfChannels * dwBytesPerSample;

  0202a	8b e8		 mov	 ebp, eax
  0202c	89 54 24 10	 mov	 DWORD PTR _dwSampleRate$[esp+20], edx
  02030	0f af ef	 imul	 ebp, edi
  02033	0f af ea	 imul	 ebp, edx

; 6427 :     pWaveFormat->nBlockAlign =
; 6428 :       (WORD)( dwNumberOfChannels * dwBytesPerSample );

  02036	0f af c7	 imul	 eax, edi
  02039	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  0203c	66 89 46 0c	 mov	 WORD PTR [esi+12], ax

; 6429 :     pWaveFormat->cbSize = 0;

  02040	66 89 5e 10	 mov	 WORD PTR [esi+16], bx
$L71797:

; 6430 :   }
; 6431 : 
; 6432 :   /********************************************************************/
; 6433 :   /*  If PA_OWN_DEVICE is specified AND the requested Sample Rate and */
; 6434 :   /*  the requested Number Of Channels do NOT match the current       */
; 6435 :   /*  settings then an error is returned.                             */
; 6436 :   /********************************************************************/
; 6437 : 
; 6438 :   if ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )

  02044	8b 6c 24 18	 mov	 ebp, DWORD PTR _pPlayAudio$[esp+16]
  02048	f6 45 3c 01	 test	 BYTE PTR [ebp+60], 1
  0204c	74 61		 je	 SHORT $L71799

; 6439 :   {
; 6440 :     /******************************************************************/
; 6441 :     /*  The audio device is owned. This means that the wave output    */
; 6442 :     /*  device will not be closed unless the PA_DestroyPlayHandle()   */
; 6443 :     /*  function is called. In this case, the requested format must   */
; 6444 :     /*  match the actual data format currently being used.            */
; 6445 :     /*  One exception is that if the wFormatTag is equal to           */
; 6446 :     /*  WAVE_FORMAT_PCM then the several other fields will            */
; 6447 :     /*  automatically match (Except the wBitsPerSample field that     */
; 6448 :     /*  does not necessarily to match in this case).                  */
; 6449 :     /******************************************************************/
; 6450 : 
; 6451 :     if (( pWaveFormat->wFormatTag != pPlayAudio->pWaveFormat->wFormatTag )
; 6452 :       || ( pWaveFormat->nSamplesPerSec
; 6453 :                 != pPlayAudio->pWaveFormat->nSamplesPerSec )
; 6454 :       || ( pWaveFormat->nChannels != pPlayAudio->pWaveFormat->nChannels ))

  0204e	8b ad a0 00 00
	00		 mov	 ebp, DWORD PTR [ebp+160]
  02054	66 3b 4d 00	 cmp	 cx, WORD PTR [ebp]
  02058	75 4a		 jne	 SHORT $L71801
  0205a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0205d	8b 55 04	 mov	 edx, DWORD PTR [ebp+4]
  02060	3b c2		 cmp	 eax, edx
  02062	75 40		 jne	 SHORT $L71801
  02064	66 8b 56 02	 mov	 dx, WORD PTR [esi+2]
  02068	66 3b 55 02	 cmp	 dx, WORD PTR [ebp+2]
  0206c	75 36		 jne	 SHORT $L71801

; 6455 :       return MMSYSERR_ERROR;
; 6456 : 
; 6457 :     if ( pWaveFormat->wFormatTag != WAVE_FORMAT_PCM )

  0206e	66 83 f9 01	 cmp	 cx, 1
  02072	0f 84 b5 00 00
	00		 je	 $L71816

; 6458 :     {
; 6459 :       if (( pWaveFormat->nAvgBytesPerSec
; 6460 :                   != pPlayAudio->pWaveFormat->nAvgBytesPerSec )
; 6461 :         || ( pWaveFormat->nBlockAlign
; 6462 :                   != pPlayAudio->pWaveFormat->nBlockAlign )
; 6463 :         || ( pWaveFormat->wBitsPerSample
; 6464 :                   != pPlayAudio->pWaveFormat->wBitsPerSample )
; 6465 :         || ( pWaveFormat->cbSize != pPlayAudio->pWaveFormat->cbSize ))

  02078	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0207b	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  0207e	3b c1		 cmp	 eax, ecx
  02080	75 22		 jne	 SHORT $L71801
  02082	66 8b 4e 0c	 mov	 cx, WORD PTR [esi+12]
  02086	66 3b 4d 0c	 cmp	 cx, WORD PTR [ebp+12]
  0208a	75 18		 jne	 SHORT $L71801
  0208c	66 8b 56 0e	 mov	 dx, WORD PTR [esi+14]
  02090	66 3b 55 0e	 cmp	 dx, WORD PTR [ebp+14]
  02094	75 0e		 jne	 SHORT $L71801
  02096	66 8b 46 10	 mov	 ax, WORD PTR [esi+16]
  0209a	66 3b 45 10	 cmp	 ax, WORD PTR [ebp+16]
  0209e	0f 84 89 00 00
	00		 je	 $L71816
$L71801:
  020a4	5f		 pop	 edi
  020a5	5e		 pop	 esi
  020a6	5d		 pop	 ebp

; 6466 :       return MMSYSERR_ERROR;

  020a7	b8 01 00 00 00	 mov	 eax, 1
  020ac	5b		 pop	 ebx

; 6660 : }

  020ad	59		 pop	 ecx
  020ae	c3		 ret	 0
$L71799:

; 6467 :     }
; 6468 :   }
; 6469 :   else
; 6470 :   {
; 6471 :     /******************************************************************/
; 6472 :     /*  If the audio device is not inactive then return an error.     */
; 6473 :     /******************************************************************/
; 6474 : 
; 6475 :     if ( pPlayAudio->dwAudioDeviceState != AUDIO_DEVICE_INACTIVE )

  020af	39 5d 34	 cmp	 DWORD PTR [ebp+52], ebx
  020b2	74 0b		 je	 SHORT $L71806
  020b4	5f		 pop	 edi
  020b5	5e		 pop	 esi
  020b6	5d		 pop	 ebp

; 6476 :     {
; 6477 :       return MMSYSERR_ALLOCATED;

  020b7	b8 04 00 00 00	 mov	 eax, 4
  020bc	5b		 pop	 ebx

; 6660 : }

  020bd	59		 pop	 ecx
  020be	c3		 ret	 0
$L71806:

; 6478 :     }
; 6479 :     else
; 6480 :     {
; 6481 :       /****************************************************************/
; 6482 :       /*  If the WAVEFORMATEX data structure has a wFormatTag         */
; 6483 :       /*  element equal to WAVE_FORMAT_PCM then the device is tested  */
; 6484 :       /*  for either 16 or 8 bit output. Whether 8 or 16 bits will    */
; 6485 :       /*  succeed depends on the audio data size and the audio        */
; 6486 :       /*  driver. If the audio samples are 16 bits and only 8 bit     */
; 6487 :       /*  output is supported by the audio driver then the 16 bit     */
; 6488 :       /*  audio samples are converted to 8 bit audio samples in the   */
; 6489 :       /*  WriteBufferToWaveDevice() function. This conversion is      */
; 6490 :       /*  indicated by the bConvertToEightBit flag.                   */
; 6491 :       /*                                                              */
; 6492 :       /*  If the wFormatTag element of the WAVEFORMATEX structure     */
; 6493 :       /*  is NOT equal to WAVE_FORMAT_PCM then all of the fields of   */
; 6494 :       /*  the WAVEFORMATEX structure must be filled in and are used   */
; 6495 :       /*  in the call to the waveOutOpen() function.                  */
; 6496 :       /****************************************************************/
; 6497 : 
; 6498 :       /****************************************************************/
; 6499 :       /*  Set the wave out device query flags.                        */
; 6500 :       /****************************************************************/
; 6501 : 
; 6502 :       dwQueryFlags = WAVE_FORMAT_QUERY;
; 6503 :   
; 6504 : #ifdef USE_MME_SERVER
; 6505 : 
; 6506 :       /****************************************************************/
; 6507 :       /*  If the WAVE_OPEN_SHARE bit is set in the device options     */
; 6508 :       /*  then enable device sharing.                                 */
; 6509 :       /****************************************************************/
; 6510 : 
; 6511 :       if ( pPlayAudio->dwDeviceOptions & WAVE_OPEN_SHAREABLE )
; 6512 :       {
; 6513 :         dwQueryFlags |= WAVE_OPEN_SHAREABLE;
; 6514 :       }
; 6515 : 
; 6516 : #endif
; 6517 : 
; 6518 : 	
; 6519 :       /****************************************************************/
; 6520 :       /*  Query the wave output device.                               */
; 6521 :       /****************************************************************/
; 6522 : 
; 6523 : #ifdef USE_MME_SERVER
; 6524 : 
; 6525 :       LOCK_MME_CALL(
; 6526 :         mmStatus = waveOutOpen( NULL,
; 6527 :                                 pPlayAudio->uiSelectedDeviceID,
; 6528 :                                 (LPWAVEFORMAT)pWaveFormat,
; 6529 :                                 0,
; 6530 :                                 0,
; 6531 :                                 dwQueryFlags ))
; 6532 : #else
; 6533 :       LOCK_MME_CALL(
; 6534 :         mmStatus = waveOutOpen( NULL,
; 6535 :                                 pPlayAudio->uiSelectedDeviceID,
; 6536 :                                 (LPWAVEFORMATEX)pWaveFormat,
; 6537 :                                 0,
; 6538 :                                 0,
; 6539 :                                 dwQueryFlags ))

  020bf	8b 4d 20	 mov	 ecx, DWORD PTR [ebp+32]
  020c2	6a 01		 push	 1
  020c4	53		 push	 ebx
  020c5	53		 push	 ebx
  020c6	56		 push	 esi
  020c7	51		 push	 ecx
  020c8	53		 push	 ebx
  020c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutOpen@24

; 6540 : #endif
; 6541 : 
; 6542 : #ifdef USE_MME_SERVER
; 6543 : 
; 6544 :       /****************************************************************/
; 6545 :       /*  THIS IS PROBABLY NOT NECESSARY, BUT IT CANNOT HURT.         */
; 6546 :       /*  The MME servers waveOutOpen() function returns a value of   */
; 6547 :       /*  WAVERR_DEVICESHAREABLE if the device is shareable. Change   */
; 6548 :       /*  this to MMSYSERR_NOERROR.                                   */
; 6549 :       /****************************************************************/
; 6550 : 
; 6551 :       if (( pPlayAudio->dwDeviceOptions & WAVE_OPEN_SHAREABLE )
; 6552 :         && ( mmStatus == WAVERR_DEVICESHAREABLE ))
; 6553 :       {
; 6554 :         mmStatus = MMSYSERR_NOERROR;
; 6555 :       }
; 6556 : 
; 6557 : #endif
; 6558 : 
; 6559 :       /****************************************************************/
; 6560 :       /*  If the requested wave output format is WAVE_FORMAT_PCM and  */
; 6561 :       /*  the number of bits per sample is 16 and the format is not   */
; 6562 :       /*  supported then try to query the wave output device for 8    */
; 6563 :       /*  bit samples.                                                */
; 6564 :       /****************************************************************/
; 6565 : 
; 6566 : /* TQL 05/21/1997  change this for OSF build */
; 6567 :       if(
; 6568 : #if defined WIN32
; 6569 : 	 ( mmStatus == WAVERR_BADFORMAT )
; 6570 : #endif
; 6571 : #if defined __osf__ || defined __linux__  
; 6572 : 	 ( mmStatus == MMSYSERR_NOTSUPPORTED )
; 6573 : #endif
; 6574 : 	 && ( pWaveFormat->wFormatTag == WAVE_FORMAT_PCM )
; 6575 : 	 && ( pWaveFormat->wBitsPerSample == 16 ))

  020cf	83 f8 20	 cmp	 eax, 32			; 00000020H
  020d2	75 47		 jne	 SHORT $L71810
  020d4	66 83 3e 01	 cmp	 WORD PTR [esi], 1
  020d8	75 55		 jne	 SHORT $L71791
  020da	66 83 7e 0e 10	 cmp	 WORD PTR [esi+14], 16	; 00000010H
  020df	75 4e		 jne	 SHORT $L71791

; 6576 : 	{
; 6577 : 	  /**************************************************************/
; 6578 : 	  /*  Initialize other WAVEFORMATEX structure elements for 8    */
; 6579 : 	  /*  bit data.                                                 */
; 6580 : 	  /**************************************************************/
; 6581 : 	  
; 6582 : 	  pWaveFormat->nAvgBytesPerSec = dwSampleRate * dwNumberOfChannels;

  020e1	8b df		 mov	 ebx, edi

; 6583 : 	  pWaveFormat->nBlockAlign = (WORD)dwNumberOfChannels;
; 6584 : 	  pWaveFormat->wBitsPerSample = 8;
; 6585 : 	  
; 6586 : 	  /**************************************************************/
; 6587 : 	  /*  Query the wave output device.                             */
; 6588 : 	  /**************************************************************/
; 6589 : 	  
; 6590 : #ifdef USE_MME_SERVER
; 6591 : 	  
; 6592 : 	  LOCK_MME_CALL(
; 6593 : 			mmStatus = waveOutOpen( NULL,
; 6594 : 						pPlayAudio->uiSelectedDeviceID,
; 6595 : 						(LPWAVEFORMAT)pWaveFormat,
; 6596 : 						0,
; 6597 : 						0,
; 6598 : 						dwQueryFlags ))
; 6599 : #else
; 6600 : 	    LOCK_MME_CALL(
; 6601 : 			  mmStatus = waveOutOpen( NULL,
; 6602 : 						  pPlayAudio->uiSelectedDeviceID,
; 6603 : 						  (LPWAVEFORMATEX)pWaveFormat,
; 6604 : 						  0,
; 6605 : 						  0,
; 6606 : 						  dwQueryFlags ))

  020e3	6a 01		 push	 1
  020e5	0f af 5c 24 14	 imul	 ebx, DWORD PTR _dwSampleRate$[esp+24]
  020ea	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  020ed	66 89 7e 0c	 mov	 WORD PTR [esi+12], di
  020f1	66 c7 46 0e 08
	00		 mov	 WORD PTR [esi+14], 8
  020f7	8b 55 20	 mov	 edx, DWORD PTR [ebp+32]
  020fa	6a 00		 push	 0
  020fc	6a 00		 push	 0
  020fe	56		 push	 esi
  020ff	52		 push	 edx
  02100	6a 00		 push	 0
  02102	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutOpen@24

; 6607 : #endif
; 6608 : 	    
; 6609 : #ifdef USE_MME_SERVER
; 6610 : 	    
; 6611 : 	    /**************************************************************/
; 6612 : 	    /*  THIS IS PROBABLY NOT NECESSARY, BUT IT CANNOT HURT.       */
; 6613 : 	    /*  The MME servers waveOutOpen() function returns a value of */
; 6614 : 	    /*  WAVERR_DEVICESHAREABLE if the device is shareable. Change */
; 6615 : 	    /*  this to MMSYSERR_NOERROR.                                 */
; 6616 : 	    /**************************************************************/
; 6617 : 	    
; 6618 : 	    if (( pPlayAudio->dwDeviceOptions & WAVE_OPEN_SHAREABLE )
; 6619 : 		&& ( mmStatus == WAVERR_DEVICESHAREABLE ))
; 6620 : 	      {
; 6621 : 		mmStatus = MMSYSERR_NOERROR;
; 6622 : 	      }
; 6623 : 	  
; 6624 : #endif
; 6625 : 	  
; 6626 : 	  /**************************************************************/
; 6627 : 	  /*  Reset the WAVEFORMATEX structure elements for 16 bit      */
; 6628 : 	  /*  data.                                                     */
; 6629 : 	  /**************************************************************/
; 6630 : 	  
; 6631 : 	  pWaveFormat->nAvgBytesPerSec =
; 6632 : 	    dwSampleRate * dwNumberOfChannels << 1;

  02108	8d 0c 1b	 lea	 ecx, DWORD PTR [ebx+ebx]

; 6633 : 	  pWaveFormat->nBlockAlign = (WORD)( dwNumberOfChannels << 1 );

  0210b	8d 14 3f	 lea	 edx, DWORD PTR [edi+edi]
  0210e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  02111	66 89 56 0c	 mov	 WORD PTR [esi+12], dx

; 6634 : 	  pWaveFormat->wBitsPerSample = 16;

  02115	66 c7 46 0e 10
	00		 mov	 WORD PTR [esi+14], 16	; 00000010H
$L71810:

; 6635 : 	}
; 6636 :       
; 6637 :       /****************************************************************/
; 6638 :       /*  Test for a "query failure" error.                           */
; 6639 :       /****************************************************************/
; 6640 :       
; 6641 :       if ( mmStatus )

  0211b	85 c0		 test	 eax, eax

; 6642 : 	{
; 6643 : 	  return mmStatus;

  0211d	75 10		 jne	 SHORT $L71791

; 6644 : 	}
; 6645 :       
; 6646 :       /****************************************************************/
; 6647 :       /*  Set the new device format.                                  */
; 6648 :       /****************************************************************/
; 6649 :       
; 6650 :       mmStatus = SetNewFormat( pPlayAudio, pWaveFormat );

  0211f	56		 push	 esi
  02120	55		 push	 ebp
  02121	e8 00 00 00 00	 call	 _SetNewFormat
  02126	83 c4 08	 add	 esp, 8

; 6651 :       
; 6652 :       if ( mmStatus )

  02129	85 c0		 test	 eax, eax

; 6653 : 	{
; 6654 : 	  return mmStatus;

  0212b	75 02		 jne	 SHORT $L71791
$L71816:

; 6655 : 	}
; 6656 :     }
; 6657 :   }
; 6658 :   
; 6659 :   return MMSYSERR_NOERROR;

  0212d	33 c0		 xor	 eax, eax
$L71791:
  0212f	5f		 pop	 edi
  02130	5e		 pop	 esi
  02131	5d		 pop	 ebp
  02132	5b		 pop	 ebx

; 6660 : }

  02133	59		 pop	 ecx
  02134	c3		 ret	 0
_ProcessSetFormatMessage ENDP
_TEXT	ENDS
PUBLIC	__real@8@3ff8ccccccccccccd000
PUBLIC	__real@8@3ffb851eb851eb852000
;	COMDAT __real@8@3ff8ccccccccccccd000
; File D:\work\Product\dapi\src\NT\playaud.c
CONST	SEGMENT
__real@8@3ff8ccccccccccccd000 DQ 03f8999999999999ar ; 0.0125
CONST	ENDS
;	COMDAT __real@8@3ffb851eb851eb852000
CONST	SEGMENT
__real@8@3ffb851eb851eb852000 DQ 03fb0a3d70a3d70a4r ; 0.065
CONST	ENDS
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pWaveFormat$ = 12
_uiWriteLength$ = 12
_pWaveFormatNew$ = 12
_SetNewFormat PROC NEAR

; 6700 : {

  02140	83 ec 08	 sub	 esp, 8
  02143	53		 push	 ebx

; 6701 :   unsigned int uiBlockAlign;
; 6702 :   unsigned int uiWriteLength;
; 6703 :   DWORD dwWaveFormatSize;
; 6704 :   LPWAVEFORMATEX pWaveFormatNew;
; 6705 :   LPWAVEFORMATEX pWaveFormatOld;
; 6706 : 
; 6707 :   /******************************************************************/
; 6708 :   /*  Get the size of the WAVEFORMATEX structure including the      */
; 6709 :   /*  possible data space indicated by the cbSize element.          */
; 6710 :   /******************************************************************/
; 6711 : 
; 6712 :   dwWaveFormatSize = GetWaveFormatSize( pWaveFormat );

  02144	8b 5c 24 14	 mov	 ebx, DWORD PTR _pWaveFormat$[esp+8]
  02148	56		 push	 esi
  02149	53		 push	 ebx
  0214a	e8 00 00 00 00	 call	 _GetWaveFormatSize
  0214f	83 c4 04	 add	 esp, 4

; 6713 : 
; 6714 :   // MGS change this back for osf so that we don't divide by 0 !
; 6715 : /* TQL 05/21/1997  change this for OSF build */
; 6716 :   //#ifdef WIN32
; 6717 :   if (pWaveFormat->wFormatTag == WAVE_FORMAT_PCM)

  02152	66 83 3b 01	 cmp	 WORD PTR [ebx], 1
  02156	8b f0		 mov	 esi, eax
  02158	75 25		 jne	 SHORT $L71827

; 6718 :   {
; 6719 :     /******************************************************************/
; 6720 :     /*  Initialize other WAVEFORMATEX structure elements.             */
; 6721 :     /******************************************************************/
; 6722 : 
; 6723 :     pWaveFormat->nBlockAlign = pWaveFormat->nChannels * (pWaveFormat->wBitsPerSample >> 3);

  0215a	66 8b 43 0e	 mov	 ax, WORD PTR [ebx+14]

; 6724 :     pWaveFormat->nAvgBytesPerSec = pWaveFormat->nSamplesPerSec * pWaveFormat->nBlockAlign;

  0215e	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  02161	66 c1 e8 03	 shr	 ax, 3
  02165	66 0f af 43 02	 imul	 ax, WORD PTR [ebx+2]
  0216a	66 89 43 0c	 mov	 WORD PTR [ebx+12], ax
  0216e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  02173	0f af c8	 imul	 ecx, eax
  02176	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx

; 6725 :     pWaveFormat->cbSize = 0;

  02179	66 c7 43 10 00
	00		 mov	 WORD PTR [ebx+16], 0
$L71827:

; 6726 :   }
; 6727 :   ///#endif
; 6728 : 
; 6729 :   /******************************************************************/
; 6730 :   /*  Allocate space for the new WAVEFORMATEX structure.            */
; 6731 :   /******************************************************************/
; 6732 : 
; 6733 :   LOCK_MME_CALL(
; 6734 :     pWaveFormatNew = ALLOCATE_SERVER_MEM( dwWaveFormatSize ))

  0217f	56		 push	 esi
  02180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  02186	83 c4 04	 add	 esp, 4
  02189	89 44 24 18	 mov	 DWORD PTR _pWaveFormatNew$[esp+12], eax

; 6735 : 
; 6736 :   if ( pWaveFormatNew == NULL )

  0218d	85 c0		 test	 eax, eax
  0218f	75 0b		 jne	 SHORT $L71829
  02191	5e		 pop	 esi

; 6737 :   {
; 6738 :     return MMSYSERR_NOMEM;

  02192	b8 07 00 00 00	 mov	 eax, 7
  02197	5b		 pop	 ebx

; 6857 : }

  02198	83 c4 08	 add	 esp, 8
  0219b	c3		 ret	 0
$L71829:

; 6739 :   }
; 6740 : 
; 6741 :   /******************************************************************/
; 6742 :   /*  copy the WAVEFORMATEX structure.                              */
; 6743 :   /******************************************************************/
; 6744 : 
; 6745 :   memcpy( pWaveFormatNew,
; 6746 :           pWaveFormat,
; 6747 :           dwWaveFormatSize );

  0219c	8b ce		 mov	 ecx, esi
  0219e	55		 push	 ebp
  0219f	8b d1		 mov	 edx, ecx
  021a1	57		 push	 edi
  021a2	8b f3		 mov	 esi, ebx
  021a4	8b f8		 mov	 edi, eax
  021a6	c1 e9 02	 shr	 ecx, 2
  021a9	f3 a5		 rep movsd

; 6748 : 
; 6749 :   /******************************************************************/
; 6750 :   /*  Save the old wave format structure so it can be freed.        */
; 6751 :   /******************************************************************/
; 6752 : 
; 6753 :   pWaveFormatOld = pPlayAudio->pWaveFormat;

  021ab	8b 6c 24 1c	 mov	 ebp, DWORD PTR _pPlayAudio$[esp+20]
  021af	8b ca		 mov	 ecx, edx
  021b1	83 e1 03	 and	 ecx, 3
  021b4	f3 a4		 rep movsb

; 6754 : 
; 6755 :   /******************************************************************/
; 6756 :   /*  It is important that the assignment statement on the          */
; 6757 :   /*  following line executes automically so the timer thread does  */
; 6758 :   /*  not create an error.                                          */
; 6759 :   /******************************************************************/
; 6760 : 
; 6761 :   OP_LockMutex( pPlayAudio->hmxWaveFormat );

  021b6	8b 85 90 00 00
	00		 mov	 eax, DWORD PTR [ebp+144]
  021bc	8b b5 a0 00 00
	00		 mov	 esi, DWORD PTR [ebp+160]
  021c2	50		 push	 eax
  021c3	e8 00 00 00 00	 call	 _OP_LockMutex

; 6762 :   pPlayAudio->pWaveFormat = pWaveFormatNew;
; 6763 :   OP_UnlockMutex( pPlayAudio->hmxWaveFormat );

  021c8	8b 8d 90 00 00
	00		 mov	 ecx, DWORD PTR [ebp+144]
  021ce	8b 7c 24 24	 mov	 edi, DWORD PTR _pWaveFormatNew$[esp+24]
  021d2	51		 push	 ecx
  021d3	89 bd a0 00 00
	00		 mov	 DWORD PTR [ebp+160], edi
  021d9	e8 00 00 00 00	 call	 _OP_UnlockMutex
  021de	83 c4 08	 add	 esp, 8

; 6764 : 
; 6765 :   if ( pWaveFormatOld != NULL )

  021e1	85 f6		 test	 esi, esi
  021e3	74 0a		 je	 SHORT $L71831

; 6766 :   {
; 6767 :     LOCK_MME_CALL( FREE_SERVER_MEM( pWaveFormatOld ))

  021e5	56		 push	 esi
  021e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  021ec	83 c4 04	 add	 esp, 4
$L71831:

; 6768 :   }
; 6769 : 
; 6770 :   /********************************************************************/
; 6771 :   /*  Only write blocks that are a multiple of the block alignment.   */
; 6772 :   /********************************************************************/
; 6773 : 
; 6774 :   uiBlockAlign = pWaveFormatNew->nBlockAlign;

  021ef	33 f6		 xor	 esi, esi
  021f1	66 8b 77 0c	 mov	 si, WORD PTR [edi+12]

; 6775 : 
; 6776 :   if ( uiBlockAlign == 0 )

  021f5	85 f6		 test	 esi, esi
  021f7	75 05		 jne	 SHORT $L71832

; 6777 :   {
; 6778 :     uiBlockAlign = 1;

  021f9	be 01 00 00 00	 mov	 esi, 1
$L71832:

; 6779 :   }
; 6780 : #ifdef __ipaq__
; 6781 :   uiBlockAlign=4;
; 6782 : #endif
; 6783 : 
; 6784 :   /********************************************************************/
; 6785 :   /*  Calculate the maximum write length written by the               */
; 6786 :   /*  WriteBufferToWaveDevice() function.                             */
; 6787 :   /********************************************************************/
; 6788 : 
; 6789 :   uiWriteLength = MAXIMUM_WRITE_LENGTH;
; 6790 :   uiWriteLength = uiWriteLength / uiBlockAlign;

  021fe	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H
  02203	33 d2		 xor	 edx, edx
  02205	f7 f6		 div	 esi

; 6791 :   pPlayAudio->uiMaximumWriteLength = uiWriteLength * uiBlockAlign;
; 6792 : 
; 6793 :   /********************************************************************/
; 6794 :   /*  Calculate the maximum startup length written to the             */
; 6795 :   /*  WriteBufferToWaveDevice() function.                             */
; 6796 :   /********************************************************************/
; 6797 : 
; 6798 :   uiWriteLength = (unsigned int)
; 6799 :     ( (STARTUP_BUFFER_SECONDS/MAXIMUM_BUFFERS_QUEUED) * (double)pWaveFormat->nAvgBytesPerSec );

  02207	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR -8+[esp+28], 0
  0220f	8b f8		 mov	 edi, eax
  02211	0f af fe	 imul	 edi, esi
  02214	89 7d 24	 mov	 DWORD PTR [ebp+36], edi
  02217	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  0221a	89 54 24 10	 mov	 DWORD PTR -8+[esp+24], edx
  0221e	df 6c 24 10	 fild	 QWORD PTR -8+[esp+24]
  02222	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@8@3ff8ccccccccccccd000
  02228	e8 00 00 00 00	 call	 __ftol

; 6800 : 
; 6801 :   if ( uiWriteLength < MINIMUM_STARTUP_WRITE_SIZE )

  0222d	3d 40 06 00 00	 cmp	 eax, 1600		; 00000640H
  02232	73 05		 jae	 SHORT $L71835

; 6802 :   {
; 6803 :     uiWriteLength = MINIMUM_STARTUP_WRITE_SIZE;

  02234	b8 40 06 00 00	 mov	 eax, 1600		; 00000640H
$L71835:

; 6804 :   }
; 6805 : 
; 6806 : #ifdef UNDER_CE
; 6807 :   // tek 23mar99 stretch the startup packet to try to avoid stutter.
; 6808 :   uiWriteLength = uiWriteLength*2;
; 6809 : #endif //UNDER_CE
; 6810 : 
; 6811 :   uiWriteLength = uiWriteLength / uiBlockAlign;

  02239	33 d2		 xor	 edx, edx
  0223b	f7 f6		 div	 esi

; 6812 :   uiWriteLength = uiWriteLength * uiBlockAlign;

  0223d	0f af c6	 imul	 eax, esi

; 6813 : #ifdef __ipaq__
; 6814 :   uiWriteLength&=0x03;
; 6815 : #endif
; 6816 :   /********************************************************************/
; 6817 :   /*  Limit the maximum startup length written so that if             */
; 6818 :   /*  MAXIMUM_BUFFERS_QUEUED buffers are written, there is still      */
; 6819 :   /*  space for at least MAXIMUM_WRITE_LENGTH bytes left in the       */
; 6820 :   /*  audio queue.                                                    */
; 6821 :   /********************************************************************/
; 6822 : 
; 6823 :   if ( uiWriteLength > pPlayAudio->uiMaximumWriteLength )

  02240	3b c7		 cmp	 eax, edi
  02242	89 44 24 20	 mov	 DWORD PTR _uiWriteLength$[esp+20], eax
  02246	76 06		 jbe	 SHORT $L71836

; 6824 :   {
; 6825 :     uiWriteLength = pPlayAudio->uiMaximumWriteLength;

  02248	89 7c 24 20	 mov	 DWORD PTR _uiWriteLength$[esp+20], edi
  0224c	8b c7		 mov	 eax, edi
$L71836:

; 6826 :   }
; 6827 : 
; 6828 :   pPlayAudio->uiStartupWriteLength = uiWriteLength;

  0224e	89 45 28	 mov	 DWORD PTR [ebp+40], eax

; 6829 : 
; 6830 : #ifdef TYPING_MODE
; 6831 :   // when we're doing fast starts, we have to make sure we write 
; 6832 :   // at least 65msec or so of audio on the first shot to keep 
; 6833 :   // the Win multimedia services from getting confused and stuttering.
; 6834 :   {
; 6835 : 	  UINT uiStutterMinWrite = (DWORD)((0.065) * (double)(pWaveFormat->nAvgBytesPerSec));

  02251	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  02254	89 44 24 10	 mov	 DWORD PTR -8+[esp+24], eax
  02258	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR -8+[esp+28], 0
  02260	df 6c 24 10	 fild	 QWORD PTR -8+[esp+24]
  02264	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@8@3ffb851eb851eb852000
  0226a	e8 00 00 00 00	 call	 __ftol

; 6836 : 
; 6837 : 	  if (pPlayAudio->uiStartupWriteLength < uiStutterMinWrite)

  0226f	39 44 24 20	 cmp	 DWORD PTR _uiWriteLength$[esp+20], eax
  02273	73 03		 jae	 SHORT $L71840

; 6838 : 			   pPlayAudio->uiStartupWriteLength = uiStutterMinWrite;

  02275	89 45 28	 mov	 DWORD PTR [ebp+40], eax
$L71840:

; 6839 :   }
; 6840 : #endif //TYPING_MODE
; 6841 : 
; 6842 :   /********************************************************************/
; 6843 :   /*  Set the minimum startup bytes value.                            */
; 6844 :   /********************************************************************/
; 6845 :  
; 6846 : #if (defined TYPING_MODE) || (defined UNDER_CE) //mfg 21jul1999 ifdef UNDER_CE to avoid 1 sec startup delay 
; 6847 :   {
; 6848 : 	  pPlayAudio->uiMinimumStartupBytes =
; 6849 : 		2 * pPlayAudio->uiStartupWriteLength;

  02278	8b 4d 28	 mov	 ecx, DWORD PTR [ebp+40]
  0227b	5f		 pop	 edi
  0227c	d1 e1		 shl	 ecx, 1
  0227e	89 4d 2c	 mov	 DWORD PTR [ebp+44], ecx
  02281	5d		 pop	 ebp
  02282	5e		 pop	 esi

; 6850 :   }
; 6851 : #else
; 6852 :   pPlayAudio->uiMinimumStartupBytes =
; 6853 :     MAXIMUM_BUFFERS_QUEUED * pPlayAudio->uiStartupWriteLength;
; 6854 : #endif //TYPING_MODE
; 6855 : 
; 6856 :   return MMSYSERR_NOERROR;

  02283	33 c0		 xor	 eax, eax
  02285	5b		 pop	 ebx

; 6857 : }

  02286	83 c4 08	 add	 esp, 8
  02289	c3		 ret	 0
_SetNewFormat ENDP
_pPlayAudio$ = 8
_pWaveFormat$ = 12
_ProcessGetFormatMessage PROC NEAR

; 6890 : {

  02290	56		 push	 esi

; 6891 :   DWORD dwWaveFormatSize;
; 6892 : 
; 6893 :   /********************************************************************/
; 6894 :   /*  Get the size of the WAVEFORMATEX structure including the        */
; 6895 :   /*  possible data space indicated by the cbSize element.            */
; 6896 :   /********************************************************************/
; 6897 : 
; 6898 :   dwWaveFormatSize = GetWaveFormatSize( pPlayAudio->pWaveFormat );

  02291	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  02295	57		 push	 edi
  02296	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  0229c	50		 push	 eax
  0229d	e8 00 00 00 00	 call	 _GetWaveFormatSize

; 6899 : 
; 6900 :   /********************************************************************/
; 6901 :   /*  Copy to the new WAVEFORMATEX structure.                         */
; 6902 :   /********************************************************************/
; 6903 : 
; 6904 :   memcpy( pWaveFormat,
; 6905 :           pPlayAudio->pWaveFormat,
; 6906 :           dwWaveFormatSize );

  022a2	8b b6 a0 00 00
	00		 mov	 esi, DWORD PTR [esi+160]
  022a8	8b 7c 24 14	 mov	 edi, DWORD PTR _pWaveFormat$[esp+8]
  022ac	8b c8		 mov	 ecx, eax
  022ae	83 c4 04	 add	 esp, 4
  022b1	8b d1		 mov	 edx, ecx

; 6907 : 
; 6908 :   return MMSYSERR_NOERROR;

  022b3	33 c0		 xor	 eax, eax
  022b5	c1 e9 02	 shr	 ecx, 2
  022b8	f3 a5		 rep movsd
  022ba	8b ca		 mov	 ecx, edx
  022bc	83 e1 03	 and	 ecx, 3
  022bf	f3 a4		 rep movsb
  022c1	5f		 pop	 edi
  022c2	5e		 pop	 esi

; 6909 : }

  022c3	c3		 ret	 0
_ProcessGetFormatMessage ENDP
_pPlayAudio$ = 8
_pdwVolume$ = 12
_ProcessGetVolumeMessage PROC NEAR

; 6941 :   MMRESULT mmStatus;
; 6942 : 
; 6943 :   /********************************************************************/
; 6944 :   /*  Get the wave output device volume.                              */
; 6945 :   /********************************************************************/
; 6946 : 
; 6947 :   LOCK_MME_CALL(
; 6948 :     mmStatus = waveOutGetVolume((HWAVEOUT)pPlayAudio->uiSelectedDeviceID,
; 6949 :                                 pdwVolume ))

  022d0	8b 4c 24 04	 mov	 ecx, DWORD PTR _pPlayAudio$[esp-4]
  022d4	8b 44 24 08	 mov	 eax, DWORD PTR _pdwVolume$[esp-4]
  022d8	50		 push	 eax
  022d9	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  022dc	52		 push	 edx
  022dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetVolume@8

; 6950 :   return mmStatus;
; 6951 : }

  022e3	c3		 ret	 0
_ProcessGetVolumeMessage ENDP
_pPlayAudio$ = 8
_dwVolume$ = 12
_ProcessSetVolumeMessage PROC NEAR

; 6983 :   MMRESULT mmStatus;
; 6984 : 
; 6985 :   /********************************************************************/
; 6986 :   /*  If volume control is supported then set the volume.             */
; 6987 :   /********************************************************************/
; 6988 : 
; 6989 :   if ( pPlayAudio->dwDeviceSupport &
; 6990 :      ( WAVECAPS_LRVOLUME | WAVECAPS_VOLUME ))

  022f0	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  022f4	f6 40 48 0c	 test	 BYTE PTR [eax+72], 12	; 0000000cH
  022f8	74 10		 je	 SHORT $L71860

; 6991 :   {
; 6992 :     LOCK_MME_CALL(
; 6993 :       mmStatus = waveOutSetVolume((HWAVEOUT)pPlayAudio->uiSelectedDeviceID,
; 6994 :                                   dwVolume ))

  022fa	8b 4c 24 08	 mov	 ecx, DWORD PTR _dwVolume$[esp-4]
  022fe	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  02301	51		 push	 ecx
  02302	52		 push	 edx
  02303	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutSetVolume@8

; 6999 :   }
; 7000 : 
; 7001 :   return mmStatus;
; 7002 : }

  02309	c3		 ret	 0
$L71860:

; 6995 :   }
; 6996 :   else
; 6997 :   {
; 6998 :     mmStatus = MMSYSERR_NOTSUPPORTED;

  0230a	b8 08 00 00 00	 mov	 eax, 8

; 6999 :   }
; 7000 : 
; 7001 :   return mmStatus;
; 7002 : }

  0230f	c3		 ret	 0
_ProcessSetVolumeMessage ENDP
_pPlayAudio$ = 8
_aTag$ = 12
_ProcessSynchronizationMarkMessage PROC NEAR

; 7038 : {

  02310	57		 push	 edi

; 7039 :   LPSYNC_MARK_T pSyncMark;
; 7040 :   LPSYNC_MARK_T pNextSyncMark;
; 7041 : 
; 7042 :   /********************************************************************/
; 7043 :   /*  Allocate memory for the synchronization mark structure.         */
; 7044 :   /********************************************************************/
; 7045 : 
; 7046 :   pSyncMark = (LPSYNC_MARK_T)malloc( sizeof(SYNC_MARK_T));

  02311	6a 0c		 push	 12			; 0000000cH
  02313	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  02319	8b f8		 mov	 edi, eax
  0231b	83 c4 04	 add	 esp, 4

; 7047 : 
; 7048 :   if ( pSyncMark == NULL )

  0231e	85 ff		 test	 edi, edi
  02320	75 07		 jne	 SHORT $L71873

; 7049 :   {
; 7050 :     return MMSYSERR_NOMEM;

  02322	b8 07 00 00 00	 mov	 eax, 7
  02327	5f		 pop	 edi

; 7104 : }

  02328	c3		 ret	 0
$L71873:
  02329	56		 push	 esi

; 7051 :   }
; 7052 : 
; 7053 :   /********************************************************************/
; 7054 :   /*  Fill in the synchonization mark structure.                      */
; 7055 :   /********************************************************************/
; 7056 : 
; 7057 :   OP_LockMutex( pPlayAudio->hmxQueuedByteCount );

  0232a	8b 74 24 0c	 mov	 esi, DWORD PTR _pPlayAudio$[esp+4]
  0232e	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  02334	50		 push	 eax
  02335	e8 00 00 00 00	 call	 _OP_LockMutex

; 7058 :   pSyncMark->dwPosition = pPlayAudio->dwQueuedByteCount;

  0233a	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  0233d	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 7059 :   OP_UnlockMutex( pPlayAudio->hmxQueuedByteCount );

  02340	8b 96 84 00 00
	00		 mov	 edx, DWORD PTR [esi+132]
  02346	52		 push	 edx
  02347	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 7060 : 
; 7061 :   pSyncMark->aTag = aTag;

  0234c	8b 44 24 18	 mov	 eax, DWORD PTR _aTag$[esp+12]

; 7062 :   pSyncMark->pLink = NULL;

  02350	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  02356	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 7063 : 
; 7064 :   /********************************************************************/
; 7065 :   /*  Lock the synchronization mark linked list.                      */
; 7066 :   /********************************************************************/
; 7067 : 
; 7068 :   OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  02359	8b 8e 8c 00 00
	00		 mov	 ecx, DWORD PTR [esi+140]
  0235f	51		 push	 ecx
  02360	e8 00 00 00 00	 call	 _OP_LockMutex

; 7069 : 
; 7070 :   /********************************************************************/
; 7071 :   /*  Put the synchronization mark at the end of the linked list.     */
; 7072 :   /********************************************************************/
; 7073 : 
; 7074 :   if ( pPlayAudio->pSyncMarkList == NULL )

  02365	8b 8e 9c 00 00
	00		 mov	 ecx, DWORD PTR [esi+156]
  0236b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0236e	85 c9		 test	 ecx, ecx
  02370	75 08		 jne	 SHORT $L71876

; 7075 :   {
; 7076 :     pPlayAudio->pSyncMarkList = pSyncMark;

  02372	89 be 9c 00 00
	00		 mov	 DWORD PTR [esi+156], edi

; 7077 :   }
; 7078 :   else

  02378	eb 10		 jmp	 SHORT $L71877
$L71876:

; 7079 :   {
; 7080 :     pNextSyncMark = pPlayAudio->pSyncMarkList;
; 7081 : 
; 7082 :     while ( pNextSyncMark->pLink != NULL )

  0237a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0237c	85 c0		 test	 eax, eax
  0237e	74 08		 je	 SHORT $L71881
$L71880:

; 7083 :     {
; 7084 :       pNextSyncMark = pNextSyncMark->pLink;

  02380	8b c8		 mov	 ecx, eax
  02382	8b 01		 mov	 eax, DWORD PTR [ecx]
  02384	85 c0		 test	 eax, eax
  02386	75 f8		 jne	 SHORT $L71880
$L71881:

; 7085 :     }
; 7086 : 
; 7087 :     pNextSyncMark->pLink = pSyncMark;

  02388	89 39		 mov	 DWORD PTR [ecx], edi
$L71877:

; 7088 :   }
; 7089 : 
; 7090 :   /********************************************************************/
; 7091 :   /*  Set the timer thread active so it can process synchronization   */
; 7092 :   /*  marks.                                                          */
; 7093 :   /********************************************************************/
; 7094 : 
; 7095 :   OP_SetEvent( pPlayAudio->hevTimerThreadActive );

  0238a	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0238d	52		 push	 edx
  0238e	e8 00 00 00 00	 call	 _OP_SetEvent

; 7096 : 
; 7097 :   /********************************************************************/
; 7098 :   /*  Unlock the synchronization mark linked list.                    */
; 7099 :   /********************************************************************/
; 7100 : 
; 7101 :   OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  02393	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  02399	50		 push	 eax
  0239a	e8 00 00 00 00	 call	 _OP_UnlockMutex
  0239f	83 c4 08	 add	 esp, 8

; 7102 : 
; 7103 :   return MMSYSERR_NOERROR;

  023a2	33 c0		 xor	 eax, eax
  023a4	5e		 pop	 esi
  023a5	5f		 pop	 edi

; 7104 : }

  023a6	c3		 ret	 0
_ProcessSynchronizationMarkMessage ENDP
_pPlayAudio$ = 8
_pdwPosition$ = 12
_ProcessGetPositionMessage PROC NEAR

; 7137 : {

  023b0	57		 push	 edi

; 7138 :   MMRESULT mmStatus;
; 7139 : 
; 7140 :   if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )

  023b1	8b 7c 24 08	 mov	 edi, DWORD PTR _pPlayAudio$[esp]
  023b5	83 7f 34 02	 cmp	 DWORD PTR [edi+52], 2
  023b9	75 1b		 jne	 SHORT $L71888
  023bb	56		 push	 esi

; 7141 :   {
; 7142 :     mmStatus = AudioPosition( pPlayAudio, pdwPosition );

  023bc	8b 74 24 10	 mov	 esi, DWORD PTR _pdwPosition$[esp+4]
  023c0	56		 push	 esi
  023c1	57		 push	 edi
  023c2	e8 00 00 00 00	 call	 _AudioPosition

; 7143 : 
; 7144 :     *pdwPosition += pPlayAudio->dwPositionBase;

  023c7	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  023ca	8b 16		 mov	 edx, DWORD PTR [esi]
  023cc	83 c4 08	 add	 esp, 8
  023cf	03 d1		 add	 edx, ecx
  023d1	89 16		 mov	 DWORD PTR [esi], edx
  023d3	5e		 pop	 esi
  023d4	5f		 pop	 edi

; 7151 :   }
; 7152 : 
; 7153 :   return mmStatus;
; 7154 : }

  023d5	c3		 ret	 0
$L71888:

; 7145 :   }
; 7146 :   else
; 7147 :   {
; 7148 :     mmStatus = MMSYSERR_NOERROR;
; 7149 : 
; 7150 :     *pdwPosition = pPlayAudio->dwPositionBase;

  023d6	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pdwPosition$[esp]
  023da	8b 57 40	 mov	 edx, DWORD PTR [edi+64]
  023dd	33 c0		 xor	 eax, eax
  023df	5f		 pop	 edi
  023e0	89 11		 mov	 DWORD PTR [ecx], edx

; 7151 :   }
; 7152 : 
; 7153 :   return mmStatus;
; 7154 : }

  023e2	c3		 ret	 0
_ProcessGetPositionMessage ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutGetPosition@12:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pdwPosition$ = 12
_AudioPosition PROC NEAR

; 7192 : {

  023f0	56		 push	 esi

; 7193 :   MMRESULT mmStatus;
; 7194 :   LPMMTIME pMmt;
; 7195 : 
; 7196 :   /********************************************************************/
; 7197 :   /*  Get the wave output device position.                            */
; 7198 :   /*  First allocate memory for the MMTIME structure.                 */
; 7199 :   /********************************************************************/
; 7200 : 
; 7201 :   LOCK_MME_CALL( pMmt = (LPMMTIME)ALLOCATE_SERVER_MEM(sizeof(MMTIME)))

  023f1	6a 0c		 push	 12			; 0000000cH
  023f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  023f9	8b f0		 mov	 esi, eax
  023fb	83 c4 04	 add	 esp, 4

; 7202 : 
; 7203 :   if ( pMmt == NULL )

  023fe	85 f6		 test	 esi, esi
  02400	75 07		 jne	 SHORT $L71900

; 7204 :   {
; 7205 :     return MMSYSERR_NOMEM;

  02402	b8 07 00 00 00	 mov	 eax, 7
  02407	5e		 pop	 esi

; 7277 : }

  02408	c3		 ret	 0
$L71900:
  02409	53		 push	 ebx
  0240a	57		 push	 edi

; 7206 :   }
; 7207 : 
; 7208 :   /********************************************************************/
; 7209 :   /*  Get the position of the last sample played by the wave output   */
; 7210 :   /*  device.                                                         */
; 7211 :   /********************************************************************/
; 7212 : 
; 7213 :   pMmt->wType = TIME_BYTES;
; 7214 : 
; 7215 :   LOCK_MME_CALL( mmStatus = waveOutGetPosition( pPlayAudio->hWaveOut,
; 7216 :                                                 pMmt,
; 7217 :                                                 sizeof(MMTIME)))

  0240b	8b 7c 24 10	 mov	 edi, DWORD PTR _pPlayAudio$[esp+8]
  0240f	c7 06 04 00 00
	00		 mov	 DWORD PTR [esi], 4
  02415	6a 0c		 push	 12			; 0000000cH
  02417	56		 push	 esi
  02418	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0241b	50		 push	 eax
  0241c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetPosition@12
  02422	8b d8		 mov	 ebx, eax

; 7218 :   if ( mmStatus )

  02424	85 db		 test	 ebx, ebx
  02426	74 1a		 je	 SHORT $L71902

; 7219 :   {
; 7220 :     *pdwPosition = 0xFFFFFFFF;

  02428	8b 4c 24 14	 mov	 ecx, DWORD PTR _pdwPosition$[esp+8]

; 7265 :       mmStatus = MMSYSERR_ERROR;
; 7266 : 
; 7267 :       break;
; 7268 :     }
; 7269 :   }
; 7270 :   /********************************************************************/
; 7271 :   /*  Free memory for the MMTIME structure.                           */
; 7272 :   /********************************************************************/
; 7273 : 
; 7274 :   LOCK_MME_CALL( FREE_SERVER_MEM( pMmt ))

  0242c	56		 push	 esi
  0242d	c7 01 ff ff ff
	ff		 mov	 DWORD PTR [ecx], -1
  02433	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  02439	83 c4 04	 add	 esp, 4

; 7275 : 
; 7276 :   return mmStatus;

  0243c	8b c3		 mov	 eax, ebx
  0243e	5f		 pop	 edi
  0243f	5b		 pop	 ebx
  02440	5e		 pop	 esi

; 7277 : }

  02441	c3		 ret	 0
$L71902:

; 7221 :   }
; 7222 :   else
; 7223 :   {
; 7224 :     switch ( pMmt->wType )
; 7225 :     {

  02442	8b 06		 mov	 eax, DWORD PTR [esi]
  02444	48		 dec	 eax
  02445	74 7d		 je	 SHORT $L71908
  02447	48		 dec	 eax
  02448	74 48		 je	 SHORT $L71910
  0244a	83 e8 02	 sub	 eax, 2
  0244d	74 1f		 je	 SHORT $L71912

; 7258 :       }
; 7259 : 
; 7260 :       break;
; 7261 : 
; 7262 :     default:
; 7263 : 
; 7264 :       *pdwPosition = 0xFFFFFFFF;

  0244f	8b 54 24 14	 mov	 edx, DWORD PTR _pdwPosition$[esp+8]

; 7265 :       mmStatus = MMSYSERR_ERROR;
; 7266 : 
; 7267 :       break;
; 7268 :     }
; 7269 :   }
; 7270 :   /********************************************************************/
; 7271 :   /*  Free memory for the MMTIME structure.                           */
; 7272 :   /********************************************************************/
; 7273 : 
; 7274 :   LOCK_MME_CALL( FREE_SERVER_MEM( pMmt ))

  02453	56		 push	 esi
  02454	bb 01 00 00 00	 mov	 ebx, 1
  02459	c7 02 ff ff ff
	ff		 mov	 DWORD PTR [edx], -1
  0245f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  02465	83 c4 04	 add	 esp, 4

; 7275 : 
; 7276 :   return mmStatus;

  02468	8b c3		 mov	 eax, ebx
  0246a	5f		 pop	 edi
  0246b	5b		 pop	 ebx
  0246c	5e		 pop	 esi

; 7277 : }

  0246d	c3		 ret	 0
$L71912:

; 7247 :       }
; 7248 : 
; 7249 :       break;
; 7250 : 
; 7251 :     case TIME_BYTES:
; 7252 : 
; 7253 :       *pdwPosition = pMmt->u.cb;

  0246e	8b 4c 24 14	 mov	 ecx, DWORD PTR _pdwPosition$[esp+8]
  02472	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  02475	89 01		 mov	 DWORD PTR [ecx], eax

; 7254 : 
; 7255 :       if ( pPlayAudio->bConvertToEightBit )

  02477	8b 57 50	 mov	 edx, DWORD PTR [edi+80]
  0247a	85 d2		 test	 edx, edx
  0247c	74 75		 je	 SHORT $L71909

; 7256 :       {
; 7257 :         *pdwPosition = *pdwPosition << 1;

  0247e	03 c0		 add	 eax, eax

; 7265 :       mmStatus = MMSYSERR_ERROR;
; 7266 : 
; 7267 :       break;
; 7268 :     }
; 7269 :   }
; 7270 :   /********************************************************************/
; 7271 :   /*  Free memory for the MMTIME structure.                           */
; 7272 :   /********************************************************************/
; 7273 : 
; 7274 :   LOCK_MME_CALL( FREE_SERVER_MEM( pMmt ))

  02480	56		 push	 esi
  02481	89 01		 mov	 DWORD PTR [ecx], eax
  02483	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  02489	83 c4 04	 add	 esp, 4

; 7275 : 
; 7276 :   return mmStatus;

  0248c	8b c3		 mov	 eax, ebx
  0248e	5f		 pop	 edi
  0248f	5b		 pop	 ebx
  02490	5e		 pop	 esi

; 7277 : }

  02491	c3		 ret	 0
$L71910:

; 7235 :       }
; 7236 : 
; 7237 :       break;
; 7238 : 
; 7239 :     case TIME_SAMPLES:
; 7240 : 
; 7241 :       *pdwPosition = pMmt->u.sample
; 7242 :         * pPlayAudio->pWaveFormat->nBlockAlign;

  02492	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
  02498	33 c0		 xor	 eax, eax
  0249a	66 8b 41 0c	 mov	 ax, WORD PTR [ecx+12]
  0249e	8b 4c 24 14	 mov	 ecx, DWORD PTR _pdwPosition$[esp+8]
  024a2	0f af 46 04	 imul	 eax, DWORD PTR [esi+4]
  024a6	89 01		 mov	 DWORD PTR [ecx], eax

; 7243 : 
; 7244 :       if ( pPlayAudio->bConvertToEightBit )

  024a8	8b 57 50	 mov	 edx, DWORD PTR [edi+80]
  024ab	85 d2		 test	 edx, edx
  024ad	74 44		 je	 SHORT $L71909

; 7245 :       {
; 7246 :         *pdwPosition = *pdwPosition << 1;

  024af	8d 14 00	 lea	 edx, DWORD PTR [eax+eax]

; 7265 :       mmStatus = MMSYSERR_ERROR;
; 7266 : 
; 7267 :       break;
; 7268 :     }
; 7269 :   }
; 7270 :   /********************************************************************/
; 7271 :   /*  Free memory for the MMTIME structure.                           */
; 7272 :   /********************************************************************/
; 7273 : 
; 7274 :   LOCK_MME_CALL( FREE_SERVER_MEM( pMmt ))

  024b2	56		 push	 esi
  024b3	89 11		 mov	 DWORD PTR [ecx], edx
  024b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  024bb	83 c4 04	 add	 esp, 4

; 7275 : 
; 7276 :   return mmStatus;

  024be	8b c3		 mov	 eax, ebx
  024c0	5f		 pop	 edi
  024c1	5b		 pop	 ebx
  024c2	5e		 pop	 esi

; 7277 : }

  024c3	c3		 ret	 0
$L71908:

; 7226 :     case TIME_MS:
; 7227 : 
; 7228 :       *pdwPosition =
; 7229 :         ( pMmt->u.ms * pPlayAudio->pWaveFormat->nSamplesPerSec
; 7230 :             * pPlayAudio->pWaveFormat->nBlockAlign ) / 1000;

  024c4	8b 87 a0 00 00
	00		 mov	 eax, DWORD PTR [edi+160]
  024ca	33 c9		 xor	 ecx, ecx
  024cc	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  024d0	0f af 48 04	 imul	 ecx, DWORD PTR [eax+4]
  024d4	0f af 4e 04	 imul	 ecx, DWORD PTR [esi+4]
  024d8	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  024dd	f7 e1		 mul	 ecx
  024df	8b 44 24 14	 mov	 eax, DWORD PTR _pdwPosition$[esp+8]
  024e3	c1 ea 06	 shr	 edx, 6
  024e6	89 10		 mov	 DWORD PTR [eax], edx

; 7231 : 
; 7232 :       if ( pPlayAudio->bConvertToEightBit )

  024e8	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  024eb	85 c9		 test	 ecx, ecx
  024ed	74 04		 je	 SHORT $L71909

; 7233 :       {
; 7234 :         *pdwPosition = *pdwPosition << 1;

  024ef	03 d2		 add	 edx, edx
  024f1	89 10		 mov	 DWORD PTR [eax], edx
$L71909:

; 7265 :       mmStatus = MMSYSERR_ERROR;
; 7266 : 
; 7267 :       break;
; 7268 :     }
; 7269 :   }
; 7270 :   /********************************************************************/
; 7271 :   /*  Free memory for the MMTIME structure.                           */
; 7272 :   /********************************************************************/
; 7273 : 
; 7274 :   LOCK_MME_CALL( FREE_SERVER_MEM( pMmt ))

  024f3	56		 push	 esi
  024f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  024fa	83 c4 04	 add	 esp, 4

; 7275 : 
; 7276 :   return mmStatus;

  024fd	8b c3		 mov	 eax, ebx
  024ff	5f		 pop	 edi
  02500	5b		 pop	 ebx
  02501	5e		 pop	 esi

; 7277 : }

  02502	c3		 ret	 0
_AudioPosition ENDP
_pPlayAudio$ = 8
_aItem_0$ = 12
_aItem_1$ = 16
_ReportStatusToApplication PROC NEAR

; 7321 :   unsigned int uiRet;
; 7322 : 
; 7323 : #ifdef AUD_DEBUG
; 7324 :   OutputDebugString("PA: ReportStatusToApplication()\n");
; 7325 : #endif
; 7326 :   /********************************************************************/
; 7327 :   /*  If no callback routine is specified then discard the message.   */
; 7328 :   /********************************************************************/
; 7329 : 
; 7330 :   if ( 
; 7331 : 	  (pPlayAudio->CallbackRoutine != NULL )
; 7332 : #ifdef TYPING_MODE //13may97 tek don't return these in typing mode..!
; 7333 : 	  && ( !(((LPTTS_HANDLE_T)(pPlayAudio->aInstance))->bInTypingMode) )
; 7334 : #endif
; 7335 : 	 )

  02510	8b 4c 24 04	 mov	 ecx, DWORD PTR _pPlayAudio$[esp-4]
  02514	56		 push	 esi
  02515	8b 11		 mov	 edx, DWORD PTR [ecx]
  02517	85 d2		 test	 edx, edx
  02519	74 20		 je	 SHORT $L71925
  0251b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0251e	8b b0 dc 00 00
	00		 mov	 esi, DWORD PTR [eax+220]
  02524	85 f6		 test	 esi, esi
  02526	75 13		 jne	 SHORT $L71925

; 7336 :   {
; 7337 :     uiRet = ( *pPlayAudio->CallbackRoutine )( pPlayAudio,
; 7338 :                                               pPlayAudio->aInstance,
; 7339 :                                               aItem_0,
; 7340 :                                               aItem_1 );

  02528	8b 74 24 10	 mov	 esi, DWORD PTR _aItem_1$[esp]
  0252c	56		 push	 esi
  0252d	8b 74 24 10	 mov	 esi, DWORD PTR _aItem_0$[esp+4]
  02531	56		 push	 esi
  02532	50		 push	 eax
  02533	51		 push	 ecx
  02534	ff d2		 call	 edx
  02536	83 c4 10	 add	 esp, 16			; 00000010H
  02539	5e		 pop	 esi

; 7345 :   }
; 7346 : 
; 7347 :   return uiRet;
; 7348 : }

  0253a	c3		 ret	 0
$L71925:

; 7341 :   }
; 7342 :   else
; 7343 :   {
; 7344 :     uiRet = 0;

  0253b	33 c0		 xor	 eax, eax
  0253d	5e		 pop	 esi

; 7345 :   }
; 7346 : 
; 7347 :   return uiRet;
; 7348 : }

  0253e	c3		 ret	 0
_ReportStatusToApplication ENDP
_pPlayAudio$ = 8
_uiMessage$ = 12
_aParam$ = 16
_mDummy0$ = -4
_mDummy1$ = -8
_mReturn$ = -12
_SendPlayAudioMessage PROC NEAR

; 7386 :   ATYPE_T mDummy0;
; 7387 :   ATYPE_T mDummy1;
; 7388 :   ATYPE_T mReturn;
; 7389 : 
; 7390 :   /********************************************************************/
; 7391 :   /*  Put the message into the "play audio" message queue.            */
; 7392 :   /********************************************************************/
; 7393 : 
; 7394 :   OP_LockMutex( pShm_t->hmxGlobalSendPlayAudio );

  02540	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  02545	83 ec 0c	 sub	 esp, 12			; 0000000cH
  02548	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0254b	51		 push	 ecx
  0254c	e8 00 00 00 00	 call	 _OP_LockMutex

; 7395 : 
; 7396 :   WriteMessageQueue( pShm_t->pGlobalPlayAudioMessageQueue,
; 7397 :                      (ATYPE_T)pPlayAudio,
; 7398 :                      uiMessage,
; 7399 :                      aParam );

  02551	8b 54 24 1c	 mov	 edx, DWORD PTR _aParam$[esp+12]
  02555	8b 44 24 18	 mov	 eax, DWORD PTR _uiMessage$[esp+12]
  02559	8b 4c 24 14	 mov	 ecx, DWORD PTR _pPlayAudio$[esp+12]
  0255d	52		 push	 edx
  0255e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  02564	50		 push	 eax
  02565	51		 push	 ecx
  02566	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  02569	50		 push	 eax
  0256a	e8 00 00 00 00	 call	 _WriteMessageQueue

; 7400 : 
; 7401 :   /********************************************************************/
; 7402 :   /*  Get the result from the report message queue.                   */
; 7403 :   /********************************************************************/
; 7404 : 
; 7405 :   ReadMessageQueue( pShm_t->pGlobalReportMessageQueue,
; 7406 :                     &mDummy0,
; 7407 :                     &mDummy1,
; 7408 :                     &mReturn );

  0256f	8d 4c 24 14	 lea	 ecx, DWORD PTR _mReturn$[esp+32]
  02573	8d 54 24 18	 lea	 edx, DWORD PTR _mDummy1$[esp+32]
  02577	51		 push	 ecx
  02578	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t
  0257e	52		 push	 edx
  0257f	8d 44 24 24	 lea	 eax, DWORD PTR _mDummy0$[esp+40]
  02583	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  02586	50		 push	 eax
  02587	52		 push	 edx
  02588	e8 00 00 00 00	 call	 _ReadMessageQueue

; 7409 :   OP_UnlockMutex( pShm_t->hmxGlobalSendPlayAudio );

  0258d	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  02592	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  02595	51		 push	 ecx
  02596	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 7410 :   return (SENDRET_T)mReturn;

  0259b	8b 44 24 28	 mov	 eax, DWORD PTR _mReturn$[esp+52]

; 7411 : }

  0259f	83 c4 34	 add	 esp, 52			; 00000034H
  025a2	c3		 ret	 0
_SendPlayAudioMessage ENDP
_uiQueueLength$ = 8
_CreateMessageQueue PROC NEAR

; 7441 : {

  025b0	53		 push	 ebx
  025b1	55		 push	 ebp

; 7442 :   unsigned int uiBufferLength;
; 7443 :   LPMESSAGE_QUEUE_T pMessageQueue;
; 7444 : 
; 7445 :   /********************************************************************/
; 7446 :   /*  Allocate the message queue structure.                           */
; 7447 :   /********************************************************************/
; 7448 : 
; 7449 :   pMessageQueue = (LPMESSAGE_QUEUE_T)malloc( sizeof( MESSAGE_QUEUE_T ));

  025b2	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__malloc
  025b8	56		 push	 esi
  025b9	57		 push	 edi
  025ba	6a 28		 push	 40			; 00000028H
  025bc	ff d5		 call	 ebp
  025be	8b f0		 mov	 esi, eax

; 7450 : 
; 7451 :   if ( pMessageQueue == NULL )

  025c0	33 ff		 xor	 edi, edi
  025c2	83 c4 04	 add	 esp, 4
  025c5	3b f7		 cmp	 esi, edi
  025c7	75 07		 jne	 SHORT $L71947
  025c9	5f		 pop	 edi
  025ca	5e		 pop	 esi
  025cb	5d		 pop	 ebp

; 7452 :   {
; 7453 :     return NULL;

  025cc	33 c0		 xor	 eax, eax
  025ce	5b		 pop	 ebx

; 7530 : }

  025cf	c3		 ret	 0
$L71947:

; 7454 :   }
; 7455 : 
; 7456 :   /********************************************************************/
; 7457 :   /*  Initialize message queue structure elements.                    */
; 7458 :   /********************************************************************/
; 7459 : 
; 7460 :   pMessageQueue->pStart = NULL;
; 7461 :   pMessageQueue->hevNotFull = NULL;
; 7462 :   pMessageQueue->hevNotEmpty = NULL;
; 7463 :   pMessageQueue->hmxMessageQueue = NULL;
; 7464 : 
; 7465 :   /********************************************************************/
; 7466 :   /*  Allocate the message queue buffer in multiples of 3 ATYPE_T     */
; 7467 :   /*  items.                                                          */
; 7468 :   /********************************************************************/
; 7469 : 
; 7470 :   uiBufferLength = NUMBER_OF_ITEMS_IN_MESSAGE * uiQueueLength;

  025d0	8b 44 24 14	 mov	 eax, DWORD PTR _uiQueueLength$[esp+12]
  025d4	89 3e		 mov	 DWORD PTR [esi], edi
  025d6	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  025d9	89 7e 20	 mov	 DWORD PTR [esi+32], edi
  025dc	8d 1c 40	 lea	 ebx, DWORD PTR [eax+eax*2]
  025df	89 7e 24	 mov	 DWORD PTR [esi+36], edi

; 7471 : 
; 7472 :   pMessageQueue->pStart =
; 7473 :     (LPATYPE_T)malloc( uiBufferLength * sizeof(ATYPE_T));

  025e2	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  025e9	50		 push	 eax
  025ea	ff d5		 call	 ebp
  025ec	83 c4 04	 add	 esp, 4

; 7474 : 
; 7475 :   if ( pMessageQueue->pStart == NULL )

  025ef	3b c7		 cmp	 eax, edi
  025f1	89 06		 mov	 DWORD PTR [esi], eax
  025f3	75 10		 jne	 SHORT $L71956

; 7476 :   {
; 7477 :     DestroyMessageQueue( pMessageQueue );

  025f5	56		 push	 esi
  025f6	e8 00 00 00 00	 call	 _DestroyMessageQueue
  025fb	83 c4 04	 add	 esp, 4

; 7478 :     return NULL;

  025fe	33 c0		 xor	 eax, eax
  02600	5f		 pop	 edi
  02601	5e		 pop	 esi
  02602	5d		 pop	 ebp
  02603	5b		 pop	 ebx

; 7530 : }

  02604	c3		 ret	 0
$L71956:

; 7479 :   }
; 7480 : 
; 7481 :   /********************************************************************/
; 7482 :   /*  Allocate the message queue mutex object.                        */
; 7483 :   /********************************************************************/
; 7484 : 
; 7485 :   pMessageQueue->hmxMessageQueue = OP_CreateMutex();

  02605	e8 00 00 00 00	 call	 _OP_CreateMutex

; 7486 : 
; 7487 :   if ( pMessageQueue->hmxMessageQueue == NULL )

  0260a	3b c7		 cmp	 eax, edi
  0260c	89 46 24	 mov	 DWORD PTR [esi+36], eax
  0260f	75 10		 jne	 SHORT $L71959

; 7488 :   {
; 7489 :     DestroyMessageQueue( pMessageQueue );

  02611	56		 push	 esi
  02612	e8 00 00 00 00	 call	 _DestroyMessageQueue
  02617	83 c4 04	 add	 esp, 4

; 7490 :     return NULL;

  0261a	33 c0		 xor	 eax, eax
  0261c	5f		 pop	 edi
  0261d	5e		 pop	 esi
  0261e	5d		 pop	 ebp
  0261f	5b		 pop	 ebx

; 7530 : }

  02620	c3		 ret	 0
$L71959:

; 7491 :   }
; 7492 : 
; 7493 :   /********************************************************************/
; 7494 :   /*  Initialize the message queue structure.                         */
; 7495 :   /********************************************************************/
; 7496 : 
; 7497 :   pMessageQueue->pInput = pMessageQueue->pStart;

  02621	8b 06		 mov	 eax, DWORD PTR [esi]

; 7498 :   pMessageQueue->pOutput = pMessageQueue->pStart;
; 7499 :   pMessageQueue->uiInputPosition = 0;
; 7500 :   pMessageQueue->uiOutputPosition = 0;
; 7501 :   pMessageQueue->uiLength = uiBufferLength;
; 7502 :   pMessageQueue->uiCount = 0;
; 7503 : 
; 7504 :   /********************************************************************/
; 7505 :   /*  Create the "Not Empty" Event. The initial state is not          */
; 7506 :   /*  signalled.                                                      */
; 7507 :   /********************************************************************/
; 7508 : 
; 7509 :   pMessageQueue->hevNotEmpty = OP_CreateEvent( TRUE, FALSE );

  02623	57		 push	 edi
  02624	6a 01		 push	 1
  02626	89 46 04	 mov	 DWORD PTR [esi+4], eax
  02629	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0262c	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0262f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  02632	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  02635	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  02638	e8 00 00 00 00	 call	 _OP_CreateEvent
  0263d	83 c4 08	 add	 esp, 8

; 7510 : 
; 7511 :   if ( pMessageQueue->hevNotEmpty == NULL )

  02640	3b c7		 cmp	 eax, edi
  02642	89 46 20	 mov	 DWORD PTR [esi+32], eax
  02645	75 10		 jne	 SHORT $L71962

; 7512 :   {
; 7513 :     DestroyMessageQueue( pMessageQueue );

  02647	56		 push	 esi
  02648	e8 00 00 00 00	 call	 _DestroyMessageQueue
  0264d	83 c4 04	 add	 esp, 4

; 7514 :     return NULL;

  02650	33 c0		 xor	 eax, eax
  02652	5f		 pop	 edi
  02653	5e		 pop	 esi
  02654	5d		 pop	 ebp
  02655	5b		 pop	 ebx

; 7530 : }

  02656	c3		 ret	 0
$L71962:

; 7515 :   }
; 7516 : 
; 7517 :   /********************************************************************/
; 7518 :   /*  Create the "Not Full" Event. The initial state is signalled.    */
; 7519 :   /********************************************************************/
; 7520 : 
; 7521 :   pMessageQueue->hevNotFull = OP_CreateEvent( TRUE, TRUE );

  02657	6a 01		 push	 1
  02659	6a 01		 push	 1
  0265b	e8 00 00 00 00	 call	 _OP_CreateEvent
  02660	83 c4 08	 add	 esp, 8

; 7522 : 
; 7523 :   if ( pMessageQueue->hevNotFull == NULL )

  02663	3b c7		 cmp	 eax, edi
  02665	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  02668	75 10		 jne	 SHORT $L71965

; 7524 :   {
; 7525 :     DestroyMessageQueue( pMessageQueue );

  0266a	56		 push	 esi
  0266b	e8 00 00 00 00	 call	 _DestroyMessageQueue
  02670	83 c4 04	 add	 esp, 4

; 7526 :     return NULL;

  02673	33 c0		 xor	 eax, eax
  02675	5f		 pop	 edi
  02676	5e		 pop	 esi
  02677	5d		 pop	 ebp
  02678	5b		 pop	 ebx

; 7530 : }

  02679	c3		 ret	 0
$L71965:

; 7527 :   }
; 7528 : 
; 7529 :   return pMessageQueue;

  0267a	8b c6		 mov	 eax, esi
  0267c	5f		 pop	 edi
  0267d	5e		 pop	 esi
  0267e	5d		 pop	 ebp
  0267f	5b		 pop	 ebx

; 7530 : }

  02680	c3		 ret	 0
_CreateMessageQueue ENDP
_pMessageQueue$ = 8
_DestroyMessageQueue PROC NEAR

; 7557 : {

  02690	56		 push	 esi

; 7558 :   if ( pMessageQueue != NULL )

  02691	8b 74 24 08	 mov	 esi, DWORD PTR _pMessageQueue$[esp]
  02695	85 f6		 test	 esi, esi
  02697	74 38		 je	 SHORT $L71971

; 7559 :   {
; 7560 :     /******************************************************************/
; 7561 :     /*  Delete the mutex object.                                      */
; 7562 :     /******************************************************************/
; 7563 : 
; 7564 :     OP_DestroyMutex( pMessageQueue->hmxMessageQueue );

  02699	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0269c	57		 push	 edi
  0269d	50		 push	 eax
  0269e	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 7565 : 
; 7566 :     /******************************************************************/
; 7567 :     /*  Free the message queue events.                                */
; 7568 :     /******************************************************************/
; 7569 : 
; 7570 :     OP_DestroyEvent( pMessageQueue->hevNotEmpty );

  026a3	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  026a6	51		 push	 ecx
  026a7	e8 00 00 00 00	 call	 _OP_DestroyEvent

; 7571 : 
; 7572 :     OP_DestroyEvent( pMessageQueue->hevNotFull );

  026ac	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  026af	52		 push	 edx
  026b0	e8 00 00 00 00	 call	 _OP_DestroyEvent

; 7573 : 
; 7574 :     /******************************************************************/
; 7575 :     /*  Deallocate the message queue buffer and the message queue     */
; 7576 :     /*  structure.                                                    */
; 7577 :     /******************************************************************/
; 7578 : 
; 7579 :     if ( pMessageQueue->pStart != NULL )

  026b5	8b 06		 mov	 eax, DWORD PTR [esi]
  026b7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
  026bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  026c0	85 c0		 test	 eax, eax
  026c2	74 06		 je	 SHORT $L71973

; 7580 :     {
; 7581 :       free( pMessageQueue->pStart );

  026c4	50		 push	 eax
  026c5	ff d7		 call	 edi
  026c7	83 c4 04	 add	 esp, 4
$L71973:

; 7582 :     }
; 7583 : 
; 7584 :     free( pMessageQueue );

  026ca	56		 push	 esi
  026cb	ff d7		 call	 edi
  026cd	83 c4 04	 add	 esp, 4
  026d0	5f		 pop	 edi
$L71971:
  026d1	5e		 pop	 esi

; 7585 :   }
; 7586 : 
; 7587 :   return;
; 7588 : }

  026d2	c3		 ret	 0
_DestroyMessageQueue ENDP
_pMessageQueue$ = 8
_aItem_0$ = 12
_aItem_1$ = 16
_aItem_2$ = 20
_aArray$ = -12
_WriteMessageQueue PROC NEAR

; 7629 : {

  026e0	83 ec 0c	 sub	 esp, 12			; 0000000cH
  026e3	53		 push	 ebx
  026e4	55		 push	 ebp
  026e5	56		 push	 esi

; 7630 :   unsigned int uiI;
; 7631 :   unsigned int uiRemaining;
; 7632 :   unsigned int uiNumberToWrite;
; 7633 :   ATYPE_T aArray[NUMBER_OF_ITEMS_IN_MESSAGE];
; 7634 :   LPATYPE_T pItems;
; 7635 : 
; 7636 :   /********************************************************************/
; 7637 :   /*  Block if the message queue is busy.                             */
; 7638 :   /********************************************************************/
; 7639 : 
; 7640 :   OP_LockMutex( pMessageQueue->hmxMessageQueue );

  026e6	8b 74 24 1c	 mov	 esi, DWORD PTR _pMessageQueue$[esp+20]
  026ea	57		 push	 edi
  026eb	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  026ee	50		 push	 eax
  026ef	e8 00 00 00 00	 call	 _OP_LockMutex

; 7641 : 
; 7642 :   aArray[0] = aItem_0;

  026f4	8b 4c 24 28	 mov	 ecx, DWORD PTR _aItem_0$[esp+28]

; 7643 :   aArray[1] = aItem_1;
; 7644 :   aArray[2] = aItem_2;

  026f8	8b 44 24 30	 mov	 eax, DWORD PTR _aItem_2$[esp+28]
  026fc	8b 54 24 2c	 mov	 edx, DWORD PTR _aItem_1$[esp+28]
  02700	89 4c 24 14	 mov	 DWORD PTR _aArray$[esp+32], ecx

; 7645 :   pItems = &aArray[0];
; 7646 : 
; 7647 :   /********************************************************************/
; 7648 :   /*  If there's not enough room for the items then block.            */
; 7649 :   /*  WriteMessageQueue must own pMessageQueue->uiCount               */
; 7650 :   /*  during the compare in case multiple threads are trying to write */
; 7651 :   /*  the queue at the same time.                                     */
; 7652 :   /********************************************************************/
; 7653 : 
; 7654 :   uiNumberToWrite = NUMBER_OF_ITEMS_IN_MESSAGE;
; 7655 :   
; 7656 :   while ( pMessageQueue->uiCount + uiNumberToWrite > pMessageQueue->uiLength )

  02704	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  02707	89 44 24 1c	 mov	 DWORD PTR _aArray$[esp+40], eax
  0270b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0270e	83 c1 03	 add	 ecx, 3
  02711	83 c4 04	 add	 esp, 4
  02714	3b c8		 cmp	 ecx, eax
  02716	89 54 24 14	 mov	 DWORD PTR _aArray$[esp+32], edx
  0271a	8d 7c 24 10	 lea	 edi, DWORD PTR _aArray$[esp+28]
  0271e	76 36		 jbe	 SHORT $L71990
$L71989:

; 7657 :   {
; 7658 :   
; 7659 :     OP_ResetEvent( pMessageQueue->hevNotFull );

  02720	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  02723	52		 push	 edx
  02724	e8 00 00 00 00	 call	 _OP_ResetEvent

; 7660 : 
; 7661 :     OP_UnlockMutex( pMessageQueue->hmxMessageQueue );

  02729	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0272c	50		 push	 eax
  0272d	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 7662 :   
; 7663 :     OP_WaitForEvent( pMessageQueue->hevNotFull, OP_INFINITE );

  02732	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  02735	6a ff		 push	 -1
  02737	51		 push	 ecx
  02738	e8 00 00 00 00	 call	 _OP_WaitForEvent

; 7664 :   
; 7665 :     OP_LockMutex( pMessageQueue->hmxMessageQueue );

  0273d	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  02740	52		 push	 edx
  02741	e8 00 00 00 00	 call	 _OP_LockMutex
  02746	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  02749	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0274c	83 c0 03	 add	 eax, 3
  0274f	83 c4 14	 add	 esp, 20			; 00000014H
  02752	3b c1		 cmp	 eax, ecx
  02754	77 ca		 ja	 SHORT $L71989
$L71990:

; 7666 :   }
; 7667 : 
; 7668 :   /********************************************************************/
; 7669 :   /*  There is enough space in the message queue.                     */
; 7670 :   /*  Test to see if the data will wrap around the circular queue.    */
; 7671 :   /********************************************************************/
; 7672 : 
; 7673 :   if (( pMessageQueue->uiInputPosition + uiNumberToWrite )
; 7674 :          > pMessageQueue->uiLength )

  02756	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  02759	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0275c	8d 51 03	 lea	 edx, DWORD PTR [ecx+3]
  0275f	3b d0		 cmp	 edx, eax
  02761	76 50		 jbe	 SHORT $L71991

; 7675 :   {
; 7676 :     /******************************************************************/
; 7677 :     /*  The data will wrap around the circular queue.                 */
; 7678 :     /******************************************************************/
; 7679 : 
; 7680 :     uiRemaining = pMessageQueue->uiLength - pMessageQueue->uiInputPosition;

  02763	2b c1		 sub	 eax, ecx

; 7681 : 
; 7682 :     for ( uiI = 0; uiI < uiRemaining; uiI++ )

  02765	ba 04 00 00 00	 mov	 edx, 4
  0276a	74 16		 je	 SHORT $L71994

; 7675 :   {
; 7676 :     /******************************************************************/
; 7677 :     /*  The data will wrap around the circular queue.                 */
; 7678 :     /******************************************************************/
; 7679 : 
; 7680 :     uiRemaining = pMessageQueue->uiLength - pMessageQueue->uiInputPosition;

  0276c	8b c8		 mov	 ecx, eax
$L71992:

; 7683 :      *pMessageQueue->pInput++ = *pItems++;

  0276e	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  02771	8b 2f		 mov	 ebp, DWORD PTR [edi]
  02773	03 fa		 add	 edi, edx
  02775	89 2b		 mov	 DWORD PTR [ebx], ebp
  02777	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0277a	03 da		 add	 ebx, edx
  0277c	49		 dec	 ecx
  0277d	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  02780	75 ec		 jne	 SHORT $L71992
$L71994:

; 7684 : 
; 7685 :     pMessageQueue->pInput = pMessageQueue->pStart;

  02782	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 7686 : 
; 7687 :     for ( uiI = uiRemaining; uiI < uiNumberToWrite; uiI++ )

  02784	83 f8 03	 cmp	 eax, 3
  02787	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0278a	73 1b		 jae	 SHORT $L71997
  0278c	b9 03 00 00 00	 mov	 ecx, 3
  02791	2b c8		 sub	 ecx, eax
$L71995:

; 7688 :      *pMessageQueue->pInput++ = *pItems++;

  02793	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  02796	8b 2f		 mov	 ebp, DWORD PTR [edi]
  02798	03 fa		 add	 edi, edx
  0279a	89 2b		 mov	 DWORD PTR [ebx], ebp
  0279c	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0279f	03 da		 add	 ebx, edx
  027a1	49		 dec	 ecx
  027a2	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  027a5	75 ec		 jne	 SHORT $L71995
$L71997:

; 7689 : 
; 7690 :     /******************************************************************/
; 7691 :     /*  Update the input position in a circular fashion.              */
; 7692 :     /******************************************************************/
; 7693 : 
; 7694 :     pMessageQueue->uiInputPosition = uiNumberToWrite - uiRemaining;

  027a7	ba 03 00 00 00	 mov	 edx, 3
  027ac	2b d0		 sub	 edx, eax
  027ae	89 56 0c	 mov	 DWORD PTR [esi+12], edx

; 7695 :   }
; 7696 :   else

  027b1	eb 22		 jmp	 SHORT $L71998
$L71991:

; 7697 :   {
; 7698 :     /******************************************************************/
; 7699 :     /*  The data will NOT wrap around the circular queue.             */
; 7700 :     /******************************************************************/
; 7701 : 
; 7702 :     for ( uiI = 0; uiI < uiNumberToWrite; uiI++ )

  027b3	b8 03 00 00 00	 mov	 eax, 3
  027b8	ba 04 00 00 00	 mov	 edx, 4
$L71999:

; 7703 :      *pMessageQueue->pInput++ = *pItems++;

  027bd	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  027c0	8b 1f		 mov	 ebx, DWORD PTR [edi]
  027c2	03 fa		 add	 edi, edx
  027c4	89 19		 mov	 DWORD PTR [ecx], ebx
  027c6	8b 6e 04	 mov	 ebp, DWORD PTR [esi+4]
  027c9	03 ea		 add	 ebp, edx
  027cb	48		 dec	 eax
  027cc	89 6e 04	 mov	 DWORD PTR [esi+4], ebp
  027cf	75 ec		 jne	 SHORT $L71999

; 7704 : 
; 7705 :     /******************************************************************/
; 7706 :     /*  Update the input position.                                    */
; 7707 :     /******************************************************************/
; 7708 : 
; 7709 :     pMessageQueue->uiInputPosition += uiNumberToWrite;

  027d1	83 46 0c 03	 add	 DWORD PTR [esi+12], 3
$L71998:

; 7710 :   }
; 7711 : 
; 7712 :   /********************************************************************/
; 7713 :   /*  Update the count of items in the message queue.                 */
; 7714 :   /********************************************************************/
; 7715 : 
; 7716 :   pMessageQueue->uiCount += uiNumberToWrite;

  027d5	8b 5e 18	 mov	 ebx, DWORD PTR [esi+24]

; 7717 : 
; 7718 :   /********************************************************************/
; 7719 :   /*  Set the "Not Empty" condition.                                  */
; 7720 :   /********************************************************************/
; 7721 : 
; 7722 :   OP_SetEvent( pMessageQueue->hevNotEmpty );

  027d8	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  027db	83 c3 03	 add	 ebx, 3
  027de	52		 push	 edx
  027df	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  027e2	e8 00 00 00 00	 call	 _OP_SetEvent

; 7723 : 
; 7724 :   /********************************************************************/
; 7725 :   /*  Free the message queue.                                         */
; 7726 :   /********************************************************************/
; 7727 : 
; 7728 :   OP_UnlockMutex( pMessageQueue->hmxMessageQueue );

  027e7	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  027ea	50		 push	 eax
  027eb	e8 00 00 00 00	 call	 _OP_UnlockMutex
  027f0	83 c4 08	 add	 esp, 8
  027f3	5f		 pop	 edi
  027f4	5e		 pop	 esi
  027f5	5d		 pop	 ebp
  027f6	5b		 pop	 ebx

; 7729 : 
; 7730 :   return;
; 7731 : }

  027f7	83 c4 0c	 add	 esp, 12			; 0000000cH
  027fa	c3		 ret	 0
_WriteMessageQueue ENDP
_pMessageQueue$ = 8
_paItem_0$ = 12
_paItem_1$ = 16
_paItem_2$ = 20
_aArray$ = -12
_ReadMessageQueue PROC NEAR

; 7770 : {

  02800	83 ec 0c	 sub	 esp, 12			; 0000000cH
  02803	53		 push	 ebx
  02804	56		 push	 esi

; 7771 :   unsigned int uiI;
; 7772 :   unsigned int uiRemaining;
; 7773 :   unsigned int uiNumberToRead;
; 7774 :   ATYPE_T aArray[NUMBER_OF_ITEMS_IN_MESSAGE];
; 7775 :   LPATYPE_T pItems;
; 7776 : 
; 7777 :   /********************************************************************/
; 7778 :   /*  Block if the message queue is busy.                             */
; 7779 :   /********************************************************************/
; 7780 : 
; 7781 :   OP_LockMutex( pMessageQueue->hmxMessageQueue );

  02805	8b 74 24 18	 mov	 esi, DWORD PTR _pMessageQueue$[esp+16]
  02809	57		 push	 edi
  0280a	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0280d	50		 push	 eax
  0280e	e8 00 00 00 00	 call	 _OP_LockMutex

; 7782 : 
; 7783 :   pItems = &aArray[0];
; 7784 : 
; 7785 :   /********************************************************************/
; 7786 :   /*  If there is no message in the message queue then block.         */
; 7787 :   /*  The ReadMessageQueue() function must own pMessageQueue->uiCount */
; 7788 :   /*  during the compare in case multiple threads are trying to read  */
; 7789 :   /*  the message queue at the same time.                             */
; 7790 :   /********************************************************************/
; 7791 : 
; 7792 :   uiNumberToRead = NUMBER_OF_ITEMS_IN_MESSAGE;
; 7793 : 
; 7794 :   while ( pMessageQueue->uiCount < uiNumberToRead )

  02813	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  02816	bb 03 00 00 00	 mov	 ebx, 3
  0281b	83 c4 04	 add	 esp, 4
  0281e	3b c3		 cmp	 eax, ebx
  02820	8d 7c 24 0c	 lea	 edi, DWORD PTR _aArray$[esp+24]
  02824	73 30		 jae	 SHORT $L72018
$L72017:

; 7795 :   {
; 7796 : 
; 7797 :     OP_ResetEvent( pMessageQueue->hevNotEmpty );

  02826	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  02829	51		 push	 ecx
  0282a	e8 00 00 00 00	 call	 _OP_ResetEvent

; 7798 : 
; 7799 :     OP_UnlockMutex( pMessageQueue->hmxMessageQueue );

  0282f	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  02832	52		 push	 edx
  02833	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 7800 : 
; 7801 :     OP_WaitForEvent( pMessageQueue->hevNotEmpty, OP_INFINITE );

  02838	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0283b	6a ff		 push	 -1
  0283d	50		 push	 eax
  0283e	e8 00 00 00 00	 call	 _OP_WaitForEvent

; 7802 : 
; 7803 :     OP_LockMutex( pMessageQueue->hmxMessageQueue );

  02843	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  02846	51		 push	 ecx
  02847	e8 00 00 00 00	 call	 _OP_LockMutex
  0284c	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0284f	83 c4 14	 add	 esp, 20			; 00000014H
  02852	3b c3		 cmp	 eax, ebx
  02854	72 d0		 jb	 SHORT $L72017
$L72018:

; 7804 :   }
; 7805 : 
; 7806 :   /********************************************************************/
; 7807 :   /*  There is a message in the queue.                                */
; 7808 :   /*  Test to see if the read of the data wraps around the queue.     */
; 7809 :   /********************************************************************/
; 7810 : 
; 7811 :   if (( pMessageQueue->uiOutputPosition + uiNumberToRead )
; 7812 :           > pMessageQueue->uiLength )

  02856	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  02859	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0285c	8d 51 03	 lea	 edx, DWORD PTR [ecx+3]
  0285f	3b d0		 cmp	 edx, eax
  02861	76 46		 jbe	 SHORT $L72019

; 7813 :   {
; 7814 :     /******************************************************************/
; 7815 :     /*  The read of the data will wrap around the circular queue.     */
; 7816 :     /******************************************************************/
; 7817 : 
; 7818 :     uiRemaining = pMessageQueue->uiLength - pMessageQueue->uiOutputPosition;

  02863	2b c1		 sub	 eax, ecx
  02865	55		 push	 ebp
  02866	8b d0		 mov	 edx, eax

; 7819 : 
; 7820 :     for ( uiI = 0; uiI < uiRemaining; uiI++ )

  02868	74 16		 je	 SHORT $L72022

; 7813 :   {
; 7814 :     /******************************************************************/
; 7815 :     /*  The read of the data will wrap around the circular queue.     */
; 7816 :     /******************************************************************/
; 7817 : 
; 7818 :     uiRemaining = pMessageQueue->uiLength - pMessageQueue->uiOutputPosition;

  0286a	8b ca		 mov	 ecx, edx
$L72020:

; 7821 :       *pItems++ = *pMessageQueue->pOutput++;

  0286c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0286f	83 c7 04	 add	 edi, 4
  02872	8b 28		 mov	 ebp, DWORD PTR [eax]
  02874	83 c0 04	 add	 eax, 4
  02877	89 6f fc	 mov	 DWORD PTR [edi-4], ebp
  0287a	49		 dec	 ecx
  0287b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0287e	75 ec		 jne	 SHORT $L72020
$L72022:

; 7822 : 
; 7823 :     pMessageQueue->pOutput = pMessageQueue->pStart;

  02880	8b 06		 mov	 eax, DWORD PTR [esi]

; 7824 : 
; 7825 :     for ( uiI = uiRemaining; uiI < uiNumberToRead; uiI++ )

  02882	3b d3		 cmp	 edx, ebx
  02884	89 46 08	 mov	 DWORD PTR [esi+8], eax
  02887	73 18		 jae	 SHORT $L72025
  02889	8b cb		 mov	 ecx, ebx
  0288b	2b ca		 sub	 ecx, edx
$L72023:

; 7826 :       *pItems++ = *pMessageQueue->pOutput++;

  0288d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  02890	83 c7 04	 add	 edi, 4
  02893	8b 28		 mov	 ebp, DWORD PTR [eax]
  02895	83 c0 04	 add	 eax, 4
  02898	89 6f fc	 mov	 DWORD PTR [edi-4], ebp
  0289b	49		 dec	 ecx
  0289c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0289f	75 ec		 jne	 SHORT $L72023
$L72025:

; 7827 : 
; 7828 :     /******************************************************************/
; 7829 :     /*  Update the output position in a circular fashion.             */
; 7830 :     /******************************************************************/
; 7831 : 
; 7832 :     pMessageQueue->uiOutputPosition = uiNumberToRead - uiRemaining;

  028a1	2b da		 sub	 ebx, edx
  028a3	5d		 pop	 ebp
  028a4	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 7833 :   }
; 7834 :   else

  028a7	eb 19		 jmp	 SHORT $L72026
$L72019:

; 7835 :   {
; 7836 :     /******************************************************************/
; 7837 :     /*  The read of the data will NOT wrap around the circular queue. */
; 7838 :     /******************************************************************/
; 7839 : 
; 7840 :     for ( uiI = 0; uiI < uiNumberToRead; uiI++ )

  028a9	8b cb		 mov	 ecx, ebx
$L72027:

; 7841 :       *pItems++ = *pMessageQueue->pOutput++;

  028ab	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  028ae	83 c7 04	 add	 edi, 4
  028b1	8b 18		 mov	 ebx, DWORD PTR [eax]
  028b3	83 c0 04	 add	 eax, 4
  028b6	89 5f fc	 mov	 DWORD PTR [edi-4], ebx
  028b9	49		 dec	 ecx
  028ba	89 46 08	 mov	 DWORD PTR [esi+8], eax
  028bd	75 ec		 jne	 SHORT $L72027

; 7842 : 
; 7843 :     /******************************************************************/
; 7844 :     /*  Update the output position.                                   */
; 7845 :     /******************************************************************/
; 7846 : 
; 7847 :     pMessageQueue->uiOutputPosition += uiNumberToRead;

  028bf	89 56 10	 mov	 DWORD PTR [esi+16], edx
$L72026:

; 7848 :   }
; 7849 : 
; 7850 :   /********************************************************************/
; 7851 :   /*  Update the count of items in the message queue.                 */
; 7852 :   /********************************************************************/
; 7853 : 
; 7854 :   pMessageQueue->uiCount -= uiNumberToRead;

  028c2	8b 5e 18	 mov	 ebx, DWORD PTR [esi+24]

; 7855 : 
; 7856 :   /********************************************************************/
; 7857 :   /*  Set the "Not Full" condition.                                   */
; 7858 :   /********************************************************************/
; 7859 : 
; 7860 :   OP_SetEvent( pMessageQueue->hevNotFull );

  028c5	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  028c8	83 c3 fd	 add	 ebx, -3			; fffffffdH
  028cb	51		 push	 ecx
  028cc	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  028cf	e8 00 00 00 00	 call	 _OP_SetEvent

; 7861 : 
; 7862 :   /********************************************************************/
; 7863 :   /*  Copy the data to the output arguments.                          */
; 7864 :   /********************************************************************/
; 7865 : 
; 7866 :   *paItem_0 = aArray[0];

  028d4	8b 54 24 24	 mov	 edx, DWORD PTR _paItem_0$[esp+24]
  028d8	8b 44 24 10	 mov	 eax, DWORD PTR _aArray$[esp+28]

; 7867 :   *paItem_1 = aArray[1];

  028dc	8b 4c 24 28	 mov	 ecx, DWORD PTR _paItem_1$[esp+24]
  028e0	89 02		 mov	 DWORD PTR [edx], eax
  028e2	8b 54 24 14	 mov	 edx, DWORD PTR _aArray$[esp+32]

; 7868 :   *paItem_2 = aArray[2];

  028e6	8b 44 24 2c	 mov	 eax, DWORD PTR _paItem_2$[esp+24]
  028ea	89 11		 mov	 DWORD PTR [ecx], edx
  028ec	8b 4c 24 18	 mov	 ecx, DWORD PTR _aArray$[esp+36]
  028f0	89 08		 mov	 DWORD PTR [eax], ecx

; 7869 : 
; 7870 :   /******************************************************************/
; 7871 :   /*  Free the message queue.                                       */
; 7872 :   /******************************************************************/
; 7873 : 
; 7874 :   OP_UnlockMutex( pMessageQueue->hmxMessageQueue );

  028f2	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  028f5	52		 push	 edx
  028f6	e8 00 00 00 00	 call	 _OP_UnlockMutex
  028fb	83 c4 08	 add	 esp, 8
  028fe	5f		 pop	 edi
  028ff	5e		 pop	 esi
  02900	5b		 pop	 ebx

; 7875 :   return;
; 7876 : }

  02901	83 c4 0c	 add	 esp, 12			; 0000000cH
  02904	c3		 ret	 0
_ReadMessageQueue ENDP
_uiMessage$ = 12
_dwInstance$ = 16
_lParam1$ = 20
_WaveOutCallbackRoutine@20 PROC NEAR

; 7920 :   HPLAY_AUDIO_T pPlayAudio;
; 7921 :   switch ( uiMessage )
; 7922 :   {

  02910	8b 44 24 08	 mov	 eax, DWORD PTR _uiMessage$[esp-4]
  02914	2d bb 03 00 00	 sub	 eax, 955		; 000003bbH
  02919	74 1b		 je	 SHORT $L72046
  0291b	48		 dec	 eax
  0291c	74 0f		 je	 SHORT $L72056
  0291e	48		 dec	 eax
  0291f	75 33		 jne	 SHORT $L72043

; 7950 :     break;
; 7951 : 
; 7952 :   case MM_WOM_DONE:
; 7953 : 
; 7954 :     /******************************************************************/
; 7955 :     /*  Get the audio handle.                                         */
; 7956 :     /******************************************************************/
; 7957 : 
; 7958 : #ifdef OS_SIXTY_FOUR_BIT
; 7959 : 
; 7960 :     OP_LockMutex( pShm_t->hmxGlobalHandleList );
; 7961 :     pPlayAudio = pShm_t->ppGlobalHandleList[dwInstance];
; 7962 :     OP_UnlockMutex( pShm_t->hmxGlobalHandleList );
; 7963 : 
; 7964 : #else
; 7965 : 
; 7966 :     pPlayAudio = (HPLAY_AUDIO_T)dwInstance;
; 7967 : 
; 7968 : #endif
; 7969 : 
; 7970 :   /********************************************************************/
; 7971 :   /*  Determine the address of the WAVEHDR structure. For Windows,    */
; 7972 :   /*  the address is the same as the address written by the           */
; 7973 :   /*  waveOutWrite() function call that caused this MM_WOM_DONE       */
; 7974 :   /*  message. For the MME Server the returned WAVEHDR address is     */
; 7975 :   /*  different.                                                      */
; 7976 :   /********************************************************************/
; 7977 : 
; 7978 : #ifdef USE_MME_SERVER
; 7979 : 
; 7980 :     /******************************************************************/
; 7981 :     /*  MME BUG WORKAROUND. Because the MME server currently does not */
; 7982 :     /*  return wave headers in the correct order, it is necessary to  */
; 7983 :     /*  put wave headers on a list whenever a wave header is written  */
; 7984 :     /*  by the waveOutWrite() function. This list is accessed in the  */
; 7985 :     /*  wave output callback routine to determine the current header. */
; 7986 :     /******************************************************************/
; 7987 : 
; 7988 :     lParam1 =
; 7989 :       (LPARAM)pPlayAudio->ppWaveHdrInUseList[pPlayAudio->uiWaveHdrReadIndex];
; 7990 : 
; 7991 :     pPlayAudio->uiWaveHdrReadIndex++;
; 7992 : 
; 7993 :     if ( pPlayAudio->uiWaveHdrReadIndex >= MAXIMUM_BUFFERS_QUEUED )
; 7994 :     {
; 7995 :       pPlayAudio->uiWaveHdrReadIndex = 0;
; 7996 :     }
; 7997 : 
; 7998 : #endif
; 7999 : 
; 8000 :     /******************************************************************/
; 8001 :     /*  Put the MM_WOM_DONE message into the "play audio" message     */
; 8002 :     /*  queue. Send the address of the returned wave header.          */
; 8003 :     /******************************************************************/
; 8004 : 
; 8005 :     WriteMessageQueue( pShm_t->pGlobalPlayAudioMessageQueue,
; 8006 :                        (ATYPE_T)pPlayAudio,
; 8007 :                        (ATYPE_T)uiMessage,
; 8008 :                        (ATYPE_T)lParam1 );

  02921	8b 44 24 10	 mov	 eax, DWORD PTR _lParam1$[esp-4]
  02925	50		 push	 eax
  02926	68 bd 03 00 00	 push	 957			; 000003bdH

; 8009 : 
; 8010 :     break;

  0292b	eb 10		 jmp	 SHORT $L72259
$L72056:

; 8011 : 
; 8012 :   case MM_WOM_CLOSE:
; 8013 : 
; 8014 :     /******************************************************************/
; 8015 :     /*  Get the audio handle.                                         */
; 8016 :     /******************************************************************/
; 8017 : 
; 8018 : #ifdef OS_SIXTY_FOUR_BIT
; 8019 : 
; 8020 :     OP_LockMutex( pShm_t->hmxGlobalHandleList );
; 8021 :     pPlayAudio = pShm_t->ppGlobalHandleList[dwInstance];
; 8022 :     OP_UnlockMutex( pShm_t->hmxGlobalHandleList );
; 8023 : 
; 8024 : #else
; 8025 : 
; 8026 :     pPlayAudio = (HPLAY_AUDIO_T)dwInstance;
; 8027 : 
; 8028 : #endif
; 8029 : 
; 8030 :     /******************************************************************/
; 8031 :     /*  Put the MM_WOM_CLOSE message into the "play audio" message    */
; 8032 :     /*  queue.                                                        */
; 8033 :     /******************************************************************/
; 8034 : 
; 8035 :     WriteMessageQueue( pShm_t->pGlobalPlayAudioMessageQueue,
; 8036 :                        (ATYPE_T)pPlayAudio,
; 8037 :                        (ATYPE_T)uiMessage,
; 8038 :                        (ATYPE_T)0 );

  0292d	6a 00		 push	 0
  0292f	68 bc 03 00 00	 push	 956			; 000003bcH

; 8039 :     break;

  02934	eb 07		 jmp	 SHORT $L72259
$L72046:

; 7923 :   case MM_WOM_OPEN:
; 7924 : 
; 7925 :     /******************************************************************/
; 7926 :     /*  Get the audio handle.                                         */
; 7927 :     /******************************************************************/
; 7928 : 
; 7929 : #ifdef OS_SIXTY_FOUR_BIT
; 7930 : 
; 7931 :     OP_LockMutex( pShm_t->hmxGlobalHandleList );
; 7932 :     pPlayAudio = pShm_t->ppGlobalHandleList[dwInstance];
; 7933 :     OP_UnlockMutex( pShm_t->hmxGlobalHandleList );
; 7934 : 
; 7935 : #else
; 7936 : 
; 7937 :     pPlayAudio = (HPLAY_AUDIO_T)dwInstance;
; 7938 : 
; 7939 : #endif
; 7940 : 
; 7941 :     /******************************************************************/
; 7942 :     /*  Put the MM_WOM_OPEN message into the "play audio" message     */
; 7943 :     /*  queue.                                                        */
; 7944 :     /******************************************************************/
; 7945 : 
; 7946 :     WriteMessageQueue( pShm_t->pGlobalPlayAudioMessageQueue,
; 7947 :                        (ATYPE_T)pPlayAudio,
; 7948 :                        (ATYPE_T)uiMessage,
; 7949 :                        (ATYPE_T)0 );

  02936	6a 00		 push	 0
  02938	68 bb 03 00 00	 push	 955			; 000003bbH
$L72259:
  0293d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  02943	8b 4c 24 14	 mov	 ecx, DWORD PTR _dwInstance$[esp+4]
  02947	51		 push	 ecx
  02948	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0294b	50		 push	 eax
  0294c	e8 00 00 00 00	 call	 _WriteMessageQueue
  02951	83 c4 10	 add	 esp, 16			; 00000010H
$L72043:

; 8040 : 
; 8041 :   default:
; 8042 : 
; 8043 :     break;
; 8044 :   }
; 8045 : 
; 8046 :   return;
; 8047 : }

  02954	c2 14 00	 ret	 20			; 00000014H
_WaveOutCallbackRoutine@20 ENDP
_TEXT	ENDS
PUBLIC	_PA_DoSync
_TEXT	SEGMENT
_pPlayAudio$ = 8
_PA_DoSync PROC NEAR

; 8056 : 	// tek 19jun97 we do nothing if we're not working to a device..
; 8057 : 	if (pPlayAudio == NULL)

  02960	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  02964	85 c0		 test	 eax, eax
  02966	74 2a		 je	 SHORT $L72071

; 8058 : 		return;
; 8059 : 
; 8060 : 	  // if there are audio samples to
; 8061 : 	  // play, and the audio device isn't playing them, then start
; 8062 : 	  // the audio device.
; 8063 : #ifdef AUD_DEBUG
; 8064 :   {
; 8065 : 	  // tek 12nov97 corrected as part of the BATS508 edits
; 8066 : 		  char  szTemp[256]="";
; 8067 : 		  sprintf(szTemp,"DoSync at %08lu\n",
; 8068 : 			  timeGetTime()
; 8069 : 			  );	  
; 8070 : 		  OutputDebugString(szTemp);
; 8071 :   }
; 8072 : #endif //AUD_DEBUG
; 8073 :   {
; 8074 :     // tek 19nov97 restructured this logic..
; 8075 :     // if we have something to do..
; 8076 :     if (pPlayAudio->pPlayAudioRing->iQueueCount)

  02968	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  0296e	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  02971	85 d2		 test	 edx, edx
  02973	74 1d		 je	 SHORT $L72071

; 8077 : 		  {
; 8078 : 			  // if we own the device, just do it.
; 8079 : 			  if ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )

  02975	f6 40 3c 01	 test	 BYTE PTR [eax+60], 1
  02979	74 0a		 je	 SHORT $L72069

; 8080 : 			  {
; 8081 : 			 StartAudioPlaying(pPlayAudio);

  0297b	50		 push	 eax
  0297c	e8 00 00 00 00	 call	 _StartAudioPlaying
  02981	83 c4 04	 add	 esp, 4

; 8090 : 				  }
; 8091 : 			  }
; 8092 : 		  } // if we have something to do..
; 8093 : 	  }
; 8094 : 
; 8095 : }

  02984	c3		 ret	 0
$L72069:

; 8082 : 			  }
; 8083 : 			  else // we don't own the device..
; 8084 : 			  {
; 8085 : 				  // if the device is running, do this. if not, it is up to the
; 8086 : 				  // timer thread to start things.
; 8087 : 				  if (AUDIO_DEVICE_ACTIVE == pPlayAudio->dwAudioDeviceState)

  02985	83 78 34 02	 cmp	 DWORD PTR [eax+52], 2
  02989	75 07		 jne	 SHORT $L72071

; 8088 : 				  {
; 8089 : 					StartAudioPlaying(pPlayAudio);

  0298b	50		 push	 eax
  0298c	e8 00 00 00 00	 call	 _StartAudioPlaying
  02991	59		 pop	 ecx
$L72071:

; 8090 : 				  }
; 8091 : 			  }
; 8092 : 		  } // if we have something to do..
; 8093 : 	  }
; 8094 : 
; 8095 : }

  02992	c3		 ret	 0
_PA_DoSync ENDP
_TEXT	ENDS
PUBLIC	_PA_GetBytesPerSecond
_TEXT	SEGMENT
_pPlayAudio$ = 8
_PA_GetBytesPerSecond PROC NEAR

; 8102 : 	return(pPlayAudio->pWaveFormat->nAvgBytesPerSec);

  029a0	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  029a4	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  029aa	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 8103 : }

  029ad	c3		 ret	 0
_PA_GetBytesPerSecond ENDP
_TEXT	ENDS
END
