	TITLE	D:\work\product\dapi\src\NT\playaud.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_Shm_t
PUBLIC	_pShm_t
PUBLIC	_tlPlayAudio
_BSS	SEGMENT
_tlPlayAudio DB	0cH DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_Shm_t	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_pShm_t	DD	FLAT:_Shm_t
_DATA	ENDS
PUBLIC	_PA_CreatePlayHandle
PUBLIC	_PA_CreatePlayHandleEx
EXTRN	_ThreadLock:NEAR
EXTRN	_ThreadUnlock:NEAR
_TEXT	SEGMENT
_ppPlayAudio$ = 8
_uiWaveOutDeviceID$ = 12
_pWaveFormat$ = 16
_dwDeviceOptions$ = 20
_CallbackRoutine$ = 24
_aInstance$ = 28
_PA_CreatePlayHandle PROC NEAR

; 612  : {

  00000	56		 push	 esi

; 613  :   
; 614  :   MMRESULT mmResult=MMSYSERR_ERROR; // the default error
; 615  :   BOOL bGotLock=FALSE;	// whether we got the lock
; 616  :   
; 617  :   // try to gain control of the resources
; 618  :   bGotLock = ThreadLock(&tlPlayAudio,5);

  00001	6a 05		 push	 5
  00003	68 00 00 00 00	 push	 OFFSET FLAT:_tlPlayAudio
  00008	be 01 00 00 00	 mov	 esi, 1
  0000d	e8 00 00 00 00	 call	 _ThreadLock
  00012	83 c4 08	 add	 esp, 8

; 619  :   if (bGotLock)

  00015	85 c0		 test	 eax, eax
  00017	74 32		 je	 SHORT $L72018

; 620  :     {	// do the actual call..
; 621  :       mmResult = PA_CreatePlayHandleEx(ppPlayAudio,
; 622  : 				       uiWaveOutDeviceID,
; 623  : 				       pWaveFormat,
; 624  : 				       dwDeviceOptions,
; 625  : 				       CallbackRoutine,
; 626  : 				       aInstance);

  00019	8b 44 24 1c	 mov	 eax, DWORD PTR _aInstance$[esp]
  0001d	8b 4c 24 18	 mov	 ecx, DWORD PTR _CallbackRoutine$[esp]
  00021	8b 54 24 14	 mov	 edx, DWORD PTR _dwDeviceOptions$[esp]
  00025	50		 push	 eax
  00026	8b 44 24 14	 mov	 eax, DWORD PTR _pWaveFormat$[esp+4]
  0002a	51		 push	 ecx
  0002b	8b 4c 24 14	 mov	 ecx, DWORD PTR _uiWaveOutDeviceID$[esp+8]
  0002f	52		 push	 edx
  00030	8b 54 24 14	 mov	 edx, DWORD PTR _ppPlayAudio$[esp+12]
  00034	50		 push	 eax
  00035	51		 push	 ecx
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 _PA_CreatePlayHandleEx

; 627  :       // unlock the resources
; 628  :       ThreadUnlock(&tlPlayAudio);

  0003c	68 00 00 00 00	 push	 OFFSET FLAT:_tlPlayAudio
  00041	8b f0		 mov	 esi, eax
  00043	e8 00 00 00 00	 call	 _ThreadUnlock
  00048	83 c4 1c	 add	 esp, 28			; 0000001cH
$L72018:

; 629  :     }
; 630  :   // return our result
; 631  :   return (mmResult);

  0004b	8b c6		 mov	 eax, esi
  0004d	5e		 pop	 esi

; 632  : }

  0004e	c3		 ret	 0
_PA_CreatePlayHandle ENDP
_TEXT	ENDS
PUBLIC	_PA_DestroyPlayHandle
PUBLIC	_PA_SetFormat
PUBLIC	_PlayAudioThreadMain
PUBLIC	_TimerThreadMain
EXTRN	__imp__malloc:NEAR
EXTRN	__imp__waveOutGetNumDevs@0:NEAR
EXTRN	_OP_CreateThread:NEAR
EXTRN	_OP_SetThreadPriority:NEAR
EXTRN	_OP_CreateMutex:NEAR
EXTRN	_OP_CreateEvent:NEAR
EXTRN	_mallocLock:NEAR
_TEXT	SEGMENT
_ppPlayAudio$ = 8
_uiWaveOutDeviceID$ = 12
_pWaveFormat$ = 16
_dwDeviceOptions$ = 20
_CallbackRoutine$ = 24
_aInstance$ = 28
_uiNumberOfWaveOutDevices$ = -24
_WaveFormat$ = -20
_PA_CreatePlayHandleEx PROC NEAR

; 644  : {

  00050	83 ec 18	 sub	 esp, 24			; 00000018H

; 645  :   unsigned int uiI;
; 646  :   unsigned int uiNumberOfWaveOutDevices;
; 647  :   MMRESULT mmStatus;
; 648  :   WAVEFORMATEX WaveFormat;
; 649  :   LPPLAY_RING_T pPlayAudioRing;
; 650  :   HPLAY_AUDIO_T pPlayAudio = NULL;
; 651  : 
; 652  : #ifdef OS_SIXTY_FOUR_BIT
; 653  :   unsigned int bHandleSaved;
; 654  :   HPLAY_AUDIO_T * ppGlobalHandleListTemp;
; 655  : #endif
; 656  :   
; 657  : #ifdef AUD_DEBUG
; 658  :   OutputDebugString("PA_CreatePlayHandle()\n");
; 659  : #endif
; 660  :   
; 661  :   /********************************************************************/
; 662  :   /*  Set the return handle to NULL in case this function fails.      */
; 663  :   /********************************************************************/
; 664  : 
; 665  :   *ppPlayAudio = NULL;

  00053	8b 44 24 1c	 mov	 eax, DWORD PTR _ppPlayAudio$[esp+20]
  00057	53		 push	 ebx
  00058	55		 push	 ebp
  00059	56		 push	 esi
  0005a	57		 push	 edi
  0005b	33 ff		 xor	 edi, edi
  0005d	89 38		 mov	 DWORD PTR [eax], edi

; 666  : 
; 667  :   /********************************************************************/
; 668  :   /*  Increment the play audio instance count.                        */
; 669  :   /********************************************************************/
; 670  : 
; 671  :   pShm_t->uiGlobalPlayAudioInstance++;

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  00064	ff 00		 inc	 DWORD PTR [eax]

; 672  : 
; 673  : #ifdef MME_THREAD_SAFE
; 674  : 
; 675  :   /********************************************************************/
; 676  :   /*  If this is the first instance then create a global mutex to     */
; 677  :   /*  protect MME server calls.                                       */
; 678  :   /********************************************************************/
; 679  : 
; 680  :   if ( pShm_t->uiGlobalPlayAudioInstance == 1 )
; 681  :   {
; 682  :     /******************************************************************/
; 683  :     /*  Create the "Multimedia" mutex.                                */
; 684  :     /******************************************************************/
; 685  : 
; 686  :     pShm_t->hmxGlobalMmeServer = OP_CreateMutex();
; 687  : 
; 688  :     if ( pShm_t->hmxGlobalMmeServer == NULL )
; 689  :     {
; 690  :       PA_DestroyPlayHandle( pPlayAudio );
; 691  :       return MMSYSERR_ERROR;
; 692  :     }
; 693  :   }
; 694  : 
; 695  : #endif
; 696  : 
; 697  : 
; 698  : #ifdef OS_SIXTY_FOUR_BIT
; 699  : 
; 700  :   /********************************************************************/
; 701  :   /*  If this is the first instance then create a global mutex to     */
; 702  :   /*  protect the global Handle List.                                 */
; 703  :   /********************************************************************/
; 704  : 
; 705  :   if ( pShm_t->uiGlobalPlayAudioInstance == 1 )
; 706  :   {
; 707  :     /******************************************************************/
; 708  :     /*  Create the global handle mutex.                               */
; 709  :     /******************************************************************/
; 710  : 
; 711  :     pShm_t->hmxGlobalHandleList = OP_CreateMutex();
; 712  : 
; 713  :     if ( pShm_t->hmxGlobalHandleList == NULL )
; 714  :     {
; 715  :       PA_DestroyPlayHandle( pPlayAudio );
; 716  :       return MMSYSERR_ERROR;
; 717  :     }
; 718  :   }
; 719  : 
; 720  : #endif
; 721  : 
; 722  :   /********************************************************************/
; 723  :   /*  Make sure the system has an audio card.                         */
; 724  :   /********************************************************************/
; 725  : 
; 726  :   LOCK_MME_CALL( uiNumberOfWaveOutDevices = waveOutGetNumDevs() )

  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetNumDevs@0

; 727  : 
; 728  :   if ( uiNumberOfWaveOutDevices == 0 )

  0006c	3b c7		 cmp	 eax, edi
  0006e	89 44 24 10	 mov	 DWORD PTR _uiNumberOfWaveOutDevices$[esp+40], eax
  00072	75 16		 jne	 SHORT $L70922

; 729  :   {
; 730  : #ifdef AUD_DEBUG
; 731  : 	OutputDebugString("PA_: No wave output device found.\n");
; 732  : #endif
; 733  :     PA_DestroyPlayHandle( pPlayAudio );

  00074	57		 push	 edi
  00075	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  0007a	83 c4 04	 add	 esp, 4

; 734  :     return MMSYSERR_NODRIVER;

  0007d	b8 06 00 00 00	 mov	 eax, 6
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5d		 pop	 ebp
  00085	5b		 pop	 ebx

; 1416 : }

  00086	83 c4 18	 add	 esp, 24			; 00000018H
  00089	c3		 ret	 0
$L70922:

; 735  :   }
; 736  :   else
; 737  :   {
; 738  : #ifdef AUD_DEBUG
; 739  : 	  OutputDebugString("PA_: Wave device found.\n");
; 740  : #endif
; 741  :   }
; 742  : 
; 743  :   /********************************************************************/
; 744  :   /*  Make sure the device ID is valid. This is tested as an integer  */
; 745  :   /*  so that a device ID of WAVE_MAPPER ( which is equal to -1 )     */
; 746  :   /*  passes as a valid device ID.                                    */
; 747  :   /********************************************************************/
; 748  :   if ((int)uiWaveOutDeviceID >= (int)uiNumberOfWaveOutDevices )

  0008a	39 44 24 30	 cmp	 DWORD PTR _uiWaveOutDeviceID$[esp+36], eax
  0008e	7c 16		 jl	 SHORT $L70926

; 749  :   {
; 750  : #ifdef AUD_DEBUG
; 751  : 	OutputDebugString("PA_: Bad Device ID\n");
; 752  : #endif
; 753  :     PA_DestroyPlayHandle( pPlayAudio );

  00090	57		 push	 edi
  00091	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00096	83 c4 04	 add	 esp, 4

; 754  :     return MMSYSERR_BADDEVICEID;

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5d		 pop	 ebp
  000a1	5b		 pop	 ebx

; 1416 : }

  000a2	83 c4 18	 add	 esp, 24			; 00000018H
  000a5	c3		 ret	 0
$L70926:

; 755  :   }
; 756  :    else
; 757  :   {
; 758  : #ifdef AUD_DEBUG
; 759  : 	OutputDebugString("PA_: Device ID OK\n");
; 760  : #endif
; 761  :    }
; 762  :   /********************************************************************/
; 763  :   /*  Allocate memory for the play audio handle structure.            */
; 764  :   /********************************************************************/
; 765  : 
; 766  :   pPlayAudio = (HPLAY_AUDIO_T)malloc(sizeof(PLAY_AUDIO_T));

  000a6	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__malloc
  000ac	68 c0 00 00 00	 push	 192			; 000000c0H
  000b1	ff d3		 call	 ebx
  000b3	8b f0		 mov	 esi, eax
  000b5	83 c4 04	 add	 esp, 4

; 767  : 
; 768  :   if ( pPlayAudio == NULL )

  000b8	3b f7		 cmp	 esi, edi
  000ba	75 16		 jne	 SHORT $L70931

; 769  :   {
; 770  :     PA_DestroyPlayHandle( pPlayAudio );

  000bc	56		 push	 esi
  000bd	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  000c2	83 c4 04	 add	 esp, 4

; 771  :     return MMSYSERR_NOMEM;

  000c5	b8 07 00 00 00	 mov	 eax, 7
  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5d		 pop	 ebp
  000cd	5b		 pop	 ebx

; 1416 : }

  000ce	83 c4 18	 add	 esp, 24			; 00000018H
  000d1	c3		 ret	 0
$L70931:

; 772  :   }
; 773  : 
; 774  :   pPlayAudio->bHandleValid = FALSE;
; 775  : 
; 776  :   /********************************************************************/
; 777  :   /*  Initialize several handle elements to NULL.                     */
; 778  :   /********************************************************************/
; 779  : 
; 780  :   pPlayAudio->CallbackRoutine = NULL;
; 781  :   pPlayAudio->hWaveOut = (int)NULL;
; 782  :   pPlayAudio->hTimerThread = NULL;
; 783  :   pPlayAudio->hevAudioDeviceInactive = NULL;
; 784  :   pPlayAudio->hevTimerThreadActive = NULL;
; 785  :   pPlayAudio->hevQueueNotFull = NULL;
; 786  :   pPlayAudio->hevResetComplete = NULL;
; 787  :   pPlayAudio->hmxAudioDeviceState = NULL;
; 788  :   pPlayAudio->hmxBytesPlayed = NULL;
; 789  :   pPlayAudio->hmxSelectedDeviceID = NULL;
; 790  :   pPlayAudio->hmxQueueCount = NULL;
; 791  :   pPlayAudio->hmxQueueAudioBusy = NULL;
; 792  :   pPlayAudio->hmxPauseFlag = NULL;
; 793  :   pPlayAudio->ppWaveHdr = NULL;
; 794  :   pPlayAudio->pPlayAudioRing = NULL;
; 795  :   pPlayAudio->pSyncMarkList = NULL;
; 796  :   pPlayAudio->pWaveFormat = NULL;
; 797  :   //tek 09may97
; 798  :   pPlayAudio->iOutstandingBuffers=0;
; 799  :   pPlayAudio->iFirstFreeBuffer=0; //tek
; 800  : 
; 801  : #ifdef OS_SIXTY_FOUR_BIT
; 802  : 
; 803  :   /********************************************************************/
; 804  :   /*  Store the handle in the first free location in the global       */
; 805  :   /*  instance array so the wave output callback function can access  */
; 806  :   /*  the handle. This is necessary because for Digital UNIX,         */
; 807  :   /*  pointers are 64 bit and the dwInstance parameter (that is       */
; 808  :   /*  passed to the waveOutOpen() function and later returned in      */
; 809  :   /*  a callback) cannot hold a pointer to the play audio handle.     */
; 810  :   /********************************************************************/
; 811  : 
; 812  :   /********************************************************************/
; 813  :   /*  Set the audio instance to an illegal value. This is tested in   */
; 814  :   /*  the PA_DestroyPlayHandle() function.                            */
; 815  :   /********************************************************************/
; 816  : 
; 817  :   pPlayAudio->uiHandleListIndex = (unsigned int)(-1);
; 818  : 
; 819  :   /********************************************************************/
; 820  :   /*  Protect the Handle List.                                        */
; 821  :   /********************************************************************/
; 822  : 
; 823  :   OP_LockMutex( pShm_t->hmxGlobalHandleList );
; 824  : 
; 825  :   /********************************************************************/
; 826  :   /*  If this is the first "play audio" instance, then allocate the   */
; 827  :   /*  global handle array.                                            */
; 828  :   /********************************************************************/
; 829  : 
; 830  :   if ( pShm_t->ppGlobalHandleList == NULL )
; 831  :   {
; 832  :     pShm_t->ppGlobalHandleList = (HPLAY_AUDIO_T *)malloc( sizeof(HPLAY_AUDIO_T ));
; 833  : 
; 834  :     if ( pShm_t->ppGlobalHandleList == NULL )
; 835  :     {
; 836  :       PA_DestroyPlayHandle( pPlayAudio );
; 837  :       return MMSYSERR_NOMEM;
; 838  :     }
; 839  : 
; 840  :     pShm_t->ppGlobalHandleList[0] = NULL;
; 841  :     pShm_t->uiGlobalHandleListLength = 1;
; 842  :   }
; 843  : 
; 844  :   /********************************************************************/
; 845  :   /*  Attempt to save the handle in the handle list. There might be   */
; 846  :   /*  space in the handle array because a previous "play audio"       */
; 847  :   /*  instance was destroyed by the PA_DestroyPlayHandle() function.  */
; 848  :   /********************************************************************/
; 849  : 
; 850  :   bHandleSaved = FALSE;
; 851  : 
; 852  :   for ( uiI = 0; uiI < pShm_t->uiGlobalHandleListLength; uiI++ )
; 853  :   {
; 854  :     if ( pShm_t->ppGlobalHandleList[uiI] == NULL )
; 855  :     {
; 856  :       pShm_t->ppGlobalHandleList[uiI] = pPlayAudio;
; 857  :       pPlayAudio->uiHandleListIndex = uiI;
; 858  :       bHandleSaved = TRUE;
; 859  :       break;
; 860  :     }
; 861  :   }
; 862  : 
; 863  :   /******************************************************************/
; 864  :   /*  If there was no space in the handle list to save the handle   */
; 865  :   /*  then extend the handle list. Then save the handle.            */
; 866  :   /******************************************************************/
; 867  : 
; 868  :   if ( ! bHandleSaved )
; 869  :   {
; 870  :     ppGlobalHandleListTemp = ( HPLAY_AUDIO_T * )
; 871  :       realloc( pShm_t->ppGlobalHandleList,
; 872  :                ( pShm_t->uiGlobalHandleListLength + 1 ) * sizeof(HPLAY_AUDIO_T ));
; 873  : 
; 874  :     if ( ppGlobalHandleListTemp == NULL )
; 875  :     {
; 876  :       PA_DestroyPlayHandle( pPlayAudio );
; 877  :       return MMSYSERR_NOMEM;
; 878  :     }
; 879  : 
; 880  :     pShm_t->ppGlobalHandleList = ppGlobalHandleListTemp;
; 881  :     pShm_t->ppGlobalHandleList[pShm_t->uiGlobalHandleListLength] = pPlayAudio;
; 882  :     pPlayAudio->uiHandleListIndex = pShm_t->uiGlobalHandleListLength;
; 883  :     pShm_t->uiGlobalHandleListLength++;
; 884  :   }
; 885  : 
; 886  :   /********************************************************************/
; 887  :   /*  Release the Handle List.                                        */
; 888  :   /********************************************************************/
; 889  : 
; 890  :   OP_UnlockMutex( pShm_t->hmxGlobalHandleList );
; 891  : 
; 892  : #endif
; 893  : 
; 894  :   /********************************************************************/
; 895  :   /*  Save the input parameters in the play audio handle.             */
; 896  :   /********************************************************************/
; 897  : 
; 898  :   pPlayAudio->CallbackRoutine = CallbackRoutine;

  000d2	8b 4c 24 3c	 mov	 ecx, DWORD PTR _CallbackRoutine$[esp+36]

; 899  :   pPlayAudio->aInstance = aInstance;

  000d6	8b 54 24 40	 mov	 edx, DWORD PTR _aInstance$[esp+36]

; 900  :   pPlayAudio->dwDeviceOptions = dwDeviceOptions;

  000da	8b 44 24 38	 mov	 eax, DWORD PTR _dwDeviceOptions$[esp+36]
  000de	89 7e 68	 mov	 DWORD PTR [esi+104], edi

; 901  : 
; 902  :   /********************************************************************/
; 903  :   /*  Initialize some Audio parameter handles and flags.              */
; 904  :   /********************************************************************/
; 905  : 
; 906  :   pPlayAudio->bTimerExit = FALSE;
; 907  :   pPlayAudio->bPaused = FALSE;
; 908  :   pPlayAudio->bEnableOpenErrorMessage = TRUE;

  000e1	bd 01 00 00 00	 mov	 ebp, 1
  000e6	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  000e9	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 909  :   pPlayAudio->bReportPlayStop = FALSE;
; 910  : 
; 911  :   /********************************************************************/
; 912  :   /*  Initialize the wave out device state flags.                     */
; 913  :   /********************************************************************/
; 914  : 
; 915  :   pPlayAudio->dwAudioDeviceState = AUDIO_DEVICE_INACTIVE;
; 916  :   pPlayAudio->dwAudioPlayState = AUDIO_STATE_PLAY;
; 917  : 
; 918  :   /********************************************************************/
; 919  :   /*  Set both audio position counts to zero.                         */
; 920  :   /********************************************************************/
; 921  : 
; 922  :   pPlayAudio->dwPositionBase = 0;
; 923  :   pPlayAudio->dwBytesPlayed = 0;
; 924  :   pPlayAudio->dwQueuedByteCount = 0;
; 925  : 
; 926  :   /********************************************************************/
; 927  :   /*  Create an "Audio Device Inactive" event. The initial state is   */
; 928  :   /*  signalled.                                                      */
; 929  :   /********************************************************************/
; 930  : 
; 931  :   pPlayAudio->hevAudioDeviceInactive = OP_CreateEvent( TRUE, TRUE );

  000ec	55		 push	 ebp
  000ed	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000f0	55		 push	 ebp
  000f1	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  000f4	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  000f7	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  000fa	89 7e 70	 mov	 DWORD PTR [esi+112], edi
  000fd	89 7e 74	 mov	 DWORD PTR [esi+116], edi
  00100	89 7e 78	 mov	 DWORD PTR [esi+120], edi
  00103	89 7e 7c	 mov	 DWORD PTR [esi+124], edi
  00106	89 be 80 00 00
	00		 mov	 DWORD PTR [esi+128], edi
  0010c	89 be 88 00 00
	00		 mov	 DWORD PTR [esi+136], edi
  00112	89 be 94 00 00
	00		 mov	 DWORD PTR [esi+148], edi
  00118	89 be 98 00 00
	00		 mov	 DWORD PTR [esi+152], edi
  0011e	89 be 9c 00 00
	00		 mov	 DWORD PTR [esi+156], edi
  00124	89 be a0 00 00
	00		 mov	 DWORD PTR [esi+160], edi
  0012a	89 be a4 00 00
	00		 mov	 DWORD PTR [esi+164], edi
  00130	89 be a8 00 00
	00		 mov	 DWORD PTR [esi+168], edi
  00136	89 0e		 mov	 DWORD PTR [esi], ecx
  00138	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0013b	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  0013e	89 7e 54	 mov	 DWORD PTR [esi+84], edi
  00141	89 7e 58	 mov	 DWORD PTR [esi+88], edi
  00144	89 6e 60	 mov	 DWORD PTR [esi+96], ebp
  00147	89 7e 64	 mov	 DWORD PTR [esi+100], edi
  0014a	89 7e 34	 mov	 DWORD PTR [esi+52], edi
  0014d	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  00150	89 7e 40	 mov	 DWORD PTR [esi+64], edi
  00153	89 7e 44	 mov	 DWORD PTR [esi+68], edi
  00156	89 7e 4c	 mov	 DWORD PTR [esi+76], edi
  00159	e8 00 00 00 00	 call	 _OP_CreateEvent
  0015e	83 c4 08	 add	 esp, 8

; 932  : 
; 933  :   if ( pPlayAudio->hevAudioDeviceInactive == NULL )

  00161	3b c7		 cmp	 eax, edi
  00163	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00166	75 13		 jne	 SHORT $L70951

; 934  :   {
; 935  :     PA_DestroyPlayHandle( pPlayAudio );

  00168	56		 push	 esi
  00169	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  0016e	83 c4 04	 add	 esp, 4

; 936  :     return MMSYSERR_ERROR;

  00171	8b c5		 mov	 eax, ebp
  00173	5f		 pop	 edi
  00174	5e		 pop	 esi
  00175	5d		 pop	 ebp
  00176	5b		 pop	 ebx

; 1416 : }

  00177	83 c4 18	 add	 esp, 24			; 00000018H
  0017a	c3		 ret	 0
$L70951:

; 937  :   }
; 938  : 
; 939  :   /********************************************************************/
; 940  :   /*  Create an "Timer Thread Active" event. The initial state is     */
; 941  :   /*  signalled.                                                      */
; 942  :   /********************************************************************/
; 943  : 
; 944  :   pPlayAudio->hevTimerThreadActive = OP_CreateEvent( TRUE, TRUE );

  0017b	55		 push	 ebp
  0017c	55		 push	 ebp
  0017d	e8 00 00 00 00	 call	 _OP_CreateEvent
  00182	83 c4 08	 add	 esp, 8

; 945  : 
; 946  :   if ( pPlayAudio->hevTimerThreadActive == NULL )

  00185	3b c7		 cmp	 eax, edi
  00187	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0018a	75 13		 jne	 SHORT $L70953

; 947  :   {
; 948  :     PA_DestroyPlayHandle( pPlayAudio );

  0018c	56		 push	 esi
  0018d	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00192	83 c4 04	 add	 esp, 4

; 949  :     return MMSYSERR_ERROR;

  00195	8b c5		 mov	 eax, ebp
  00197	5f		 pop	 edi
  00198	5e		 pop	 esi
  00199	5d		 pop	 ebp
  0019a	5b		 pop	 ebx

; 1416 : }

  0019b	83 c4 18	 add	 esp, 24			; 00000018H
  0019e	c3		 ret	 0
$L70953:

; 950  :   }
; 951  : 
; 952  :   /********************************************************************/
; 953  :   /*  Create a "Queue Not Full" event. The initial state is           */
; 954  :   /*  signalled.                                                      */
; 955  :   /********************************************************************/
; 956  : 
; 957  :   pPlayAudio->hevQueueNotFull = OP_CreateEvent( TRUE, TRUE );

  0019f	55		 push	 ebp
  001a0	55		 push	 ebp
  001a1	e8 00 00 00 00	 call	 _OP_CreateEvent
  001a6	83 c4 08	 add	 esp, 8

; 958  : 
; 959  :   if ( pPlayAudio->hevQueueNotFull == NULL )

  001a9	3b c7		 cmp	 eax, edi
  001ab	89 46 18	 mov	 DWORD PTR [esi+24], eax
  001ae	75 13		 jne	 SHORT $L70955

; 960  :   {
; 961  :     PA_DestroyPlayHandle( pPlayAudio );

  001b0	56		 push	 esi
  001b1	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  001b6	83 c4 04	 add	 esp, 4

; 962  :     return MMSYSERR_ERROR;

  001b9	8b c5		 mov	 eax, ebp
  001bb	5f		 pop	 edi
  001bc	5e		 pop	 esi
  001bd	5d		 pop	 ebp
  001be	5b		 pop	 ebx

; 1416 : }

  001bf	83 c4 18	 add	 esp, 24			; 00000018H
  001c2	c3		 ret	 0
$L70955:

; 963  :   }
; 964  : 
; 965  :   /********************************************************************/
; 966  :   /*  Create a "Reset Complete" event. The initial state is not       */
; 967  :   /*  signalled.                                                      */
; 968  :   /********************************************************************/
; 969  : 
; 970  :   pPlayAudio->hevResetComplete = OP_CreateEvent( TRUE, TRUE );

  001c3	55		 push	 ebp
  001c4	55		 push	 ebp
  001c5	e8 00 00 00 00	 call	 _OP_CreateEvent
  001ca	83 c4 08	 add	 esp, 8

; 971  : 
; 972  :   if ( pPlayAudio->hevResetComplete == NULL )

  001cd	3b c7		 cmp	 eax, edi
  001cf	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  001d2	75 13		 jne	 SHORT $L70957

; 973  :   {
; 974  :     PA_DestroyPlayHandle( pPlayAudio );

  001d4	56		 push	 esi
  001d5	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  001da	83 c4 04	 add	 esp, 4

; 975  :     return MMSYSERR_ERROR;

  001dd	8b c5		 mov	 eax, ebp
  001df	5f		 pop	 edi
  001e0	5e		 pop	 esi
  001e1	5d		 pop	 ebp
  001e2	5b		 pop	 ebx

; 1416 : }

  001e3	83 c4 18	 add	 esp, 24			; 00000018H
  001e6	c3		 ret	 0
$L70957:

; 976  :   }
; 977  : 
; 978  :   /********************************************************************/
; 979  :   /*  Create the "Audio Device State" mutex.                          */
; 980  :   /********************************************************************/
; 981  : 
; 982  :   pPlayAudio->hmxAudioDeviceState = OP_CreateMutex();

  001e7	e8 00 00 00 00	 call	 _OP_CreateMutex

; 983  : 
; 984  :   if ( pPlayAudio->hmxAudioDeviceState == NULL )

  001ec	3b c7		 cmp	 eax, edi
  001ee	89 46 70	 mov	 DWORD PTR [esi+112], eax
  001f1	75 13		 jne	 SHORT $L70959

; 985  :   {
; 986  :     PA_DestroyPlayHandle( pPlayAudio );

  001f3	56		 push	 esi
  001f4	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  001f9	83 c4 04	 add	 esp, 4

; 987  :     return MMSYSERR_ERROR;

  001fc	8b c5		 mov	 eax, ebp
  001fe	5f		 pop	 edi
  001ff	5e		 pop	 esi
  00200	5d		 pop	 ebp
  00201	5b		 pop	 ebx

; 1416 : }

  00202	83 c4 18	 add	 esp, 24			; 00000018H
  00205	c3		 ret	 0
$L70959:

; 988  :   }
; 989  : 
; 990  :   /********************************************************************/
; 991  :   /*  Create the "Bytes Played" mutex.                                */
; 992  :   /********************************************************************/
; 993  : 
; 994  :   pPlayAudio->hmxBytesPlayed = OP_CreateMutex();

  00206	e8 00 00 00 00	 call	 _OP_CreateMutex

; 995  : 
; 996  :   if ( pPlayAudio->hmxBytesPlayed == NULL )

  0020b	3b c7		 cmp	 eax, edi
  0020d	89 46 74	 mov	 DWORD PTR [esi+116], eax
  00210	75 13		 jne	 SHORT $L70961

; 997  :   {
; 998  :     PA_DestroyPlayHandle( pPlayAudio );

  00212	56		 push	 esi
  00213	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00218	83 c4 04	 add	 esp, 4

; 999  :     return MMSYSERR_ERROR;

  0021b	8b c5		 mov	 eax, ebp
  0021d	5f		 pop	 edi
  0021e	5e		 pop	 esi
  0021f	5d		 pop	 ebp
  00220	5b		 pop	 ebx

; 1416 : }

  00221	83 c4 18	 add	 esp, 24			; 00000018H
  00224	c3		 ret	 0
$L70961:

; 1000 :   }
; 1001 : 
; 1002 :   /********************************************************************/
; 1003 :   /*  Create the "Selected Device ID" mutex.                          */
; 1004 :   /********************************************************************/
; 1005 : 
; 1006 :   pPlayAudio->hmxSelectedDeviceID = OP_CreateMutex();

  00225	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1007 : 
; 1008 :   if ( pPlayAudio->hmxSelectedDeviceID == NULL )

  0022a	3b c7		 cmp	 eax, edi
  0022c	89 46 78	 mov	 DWORD PTR [esi+120], eax
  0022f	75 13		 jne	 SHORT $L70963

; 1009 :   {
; 1010 :     PA_DestroyPlayHandle( pPlayAudio );

  00231	56		 push	 esi
  00232	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00237	83 c4 04	 add	 esp, 4

; 1011 :     return MMSYSERR_ERROR;

  0023a	8b c5		 mov	 eax, ebp
  0023c	5f		 pop	 edi
  0023d	5e		 pop	 esi
  0023e	5d		 pop	 ebp
  0023f	5b		 pop	 ebx

; 1416 : }

  00240	83 c4 18	 add	 esp, 24			; 00000018H
  00243	c3		 ret	 0
$L70963:

; 1012 :   }
; 1013 : 
; 1014 :   /********************************************************************/
; 1015 :   /*  Create the "Queue Count" mutex.                                 */
; 1016 :   /********************************************************************/
; 1017 : 
; 1018 :   pPlayAudio->hmxQueueCount = OP_CreateMutex();

  00244	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1019 : 
; 1020 :   if ( pPlayAudio->hmxQueueCount == NULL )

  00249	3b c7		 cmp	 eax, edi
  0024b	89 46 7c	 mov	 DWORD PTR [esi+124], eax
  0024e	75 13		 jne	 SHORT $L70965

; 1021 :   {
; 1022 :     PA_DestroyPlayHandle( pPlayAudio );

  00250	56		 push	 esi
  00251	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00256	83 c4 04	 add	 esp, 4

; 1023 :     return MMSYSERR_ERROR;

  00259	8b c5		 mov	 eax, ebp
  0025b	5f		 pop	 edi
  0025c	5e		 pop	 esi
  0025d	5d		 pop	 ebp
  0025e	5b		 pop	 ebx

; 1416 : }

  0025f	83 c4 18	 add	 esp, 24			; 00000018H
  00262	c3		 ret	 0
$L70965:

; 1024 :   }
; 1025 : 
; 1026 :   /********************************************************************/
; 1027 :   /*  Create the "Queue Audio Busy" mutex.                            */
; 1028 :   /********************************************************************/
; 1029 : 
; 1030 :   pPlayAudio->hmxQueueAudioBusy = OP_CreateMutex();

  00263	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1031 : 
; 1032 :   if ( pPlayAudio->hmxQueueAudioBusy == NULL )

  00268	3b c7		 cmp	 eax, edi
  0026a	89 86 80 00 00
	00		 mov	 DWORD PTR [esi+128], eax
  00270	75 13		 jne	 SHORT $L70967

; 1033 :   {
; 1034 :     PA_DestroyPlayHandle( pPlayAudio );

  00272	56		 push	 esi
  00273	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00278	83 c4 04	 add	 esp, 4

; 1035 :     return MMSYSERR_ERROR;

  0027b	8b c5		 mov	 eax, ebp
  0027d	5f		 pop	 edi
  0027e	5e		 pop	 esi
  0027f	5d		 pop	 ebp
  00280	5b		 pop	 ebx

; 1416 : }

  00281	83 c4 18	 add	 esp, 24			; 00000018H
  00284	c3		 ret	 0
$L70967:

; 1036 :   }
; 1037 : 
; 1038 :   /********************************************************************/
; 1039 :   /*  Create the "Queued Byte Count" mutex.                           */
; 1040 :   /********************************************************************/
; 1041 : 
; 1042 :   pPlayAudio->hmxQueuedByteCount = OP_CreateMutex();

  00285	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1043 : 
; 1044 :   if ( pPlayAudio->hmxQueuedByteCount == NULL )

  0028a	3b c7		 cmp	 eax, edi
  0028c	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  00292	75 13		 jne	 SHORT $L70969

; 1045 :   {
; 1046 :     PA_DestroyPlayHandle( pPlayAudio );

  00294	56		 push	 esi
  00295	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  0029a	83 c4 04	 add	 esp, 4

; 1047 :     return MMSYSERR_ERROR;

  0029d	8b c5		 mov	 eax, ebp
  0029f	5f		 pop	 edi
  002a0	5e		 pop	 esi
  002a1	5d		 pop	 ebp
  002a2	5b		 pop	 ebx

; 1416 : }

  002a3	83 c4 18	 add	 esp, 24			; 00000018H
  002a6	c3		 ret	 0
$L70969:

; 1048 :   }
; 1049 : 
; 1050 :   /********************************************************************/
; 1051 :   /*  Create the "Pause Flag" mutex.                                  */
; 1052 :   /********************************************************************/
; 1053 : 
; 1054 :   pPlayAudio->hmxPauseFlag = OP_CreateMutex();

  002a7	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1055 : 
; 1056 :   if ( pPlayAudio->hmxPauseFlag == NULL )

  002ac	3b c7		 cmp	 eax, edi
  002ae	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  002b4	75 13		 jne	 SHORT $L70971

; 1057 :   {
; 1058 :     PA_DestroyPlayHandle( pPlayAudio );

  002b6	56		 push	 esi
  002b7	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  002bc	83 c4 04	 add	 esp, 4

; 1059 :     return MMSYSERR_ERROR;

  002bf	8b c5		 mov	 eax, ebp
  002c1	5f		 pop	 edi
  002c2	5e		 pop	 esi
  002c3	5d		 pop	 ebp
  002c4	5b		 pop	 ebx

; 1416 : }

  002c5	83 c4 18	 add	 esp, 24			; 00000018H
  002c8	c3		 ret	 0
$L70971:

; 1060 :   }
; 1061 : 
; 1062 :   /********************************************************************/
; 1063 :   /*  Create the "Synchronization Mark List" mutex.                   */
; 1064 :   /********************************************************************/
; 1065 : 
; 1066 :   pPlayAudio->hmxSynchronizationMarkList = OP_CreateMutex();

  002c9	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1067 : 
; 1068 :   if ( pPlayAudio->hmxSynchronizationMarkList == NULL )

  002ce	3b c7		 cmp	 eax, edi
  002d0	89 86 8c 00 00
	00		 mov	 DWORD PTR [esi+140], eax
  002d6	75 13		 jne	 SHORT $L70973

; 1069 :   {
; 1070 :     PA_DestroyPlayHandle( pPlayAudio );

  002d8	56		 push	 esi
  002d9	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  002de	83 c4 04	 add	 esp, 4

; 1071 :     return MMSYSERR_ERROR;

  002e1	8b c5		 mov	 eax, ebp
  002e3	5f		 pop	 edi
  002e4	5e		 pop	 esi
  002e5	5d		 pop	 ebp
  002e6	5b		 pop	 ebx

; 1416 : }

  002e7	83 c4 18	 add	 esp, 24			; 00000018H
  002ea	c3		 ret	 0
$L70973:

; 1072 :   }
; 1073 : 
; 1074 :   /********************************************************************/
; 1075 :   /*  Create the "Wave Format" mutex.                                 */
; 1076 :   /********************************************************************/
; 1077 : 
; 1078 :   pPlayAudio->hmxWaveFormat = OP_CreateMutex();

  002eb	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1079 : 
; 1080 :   if ( pPlayAudio->hmxWaveFormat == NULL )

  002f0	3b c7		 cmp	 eax, edi
  002f2	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax
  002f8	75 13		 jne	 SHORT $L70975

; 1081 :   {
; 1082 :     PA_DestroyPlayHandle( pPlayAudio );

  002fa	56		 push	 esi
  002fb	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00300	83 c4 04	 add	 esp, 4

; 1083 :     return MMSYSERR_ERROR;

  00303	8b c5		 mov	 eax, ebp
  00305	5f		 pop	 edi
  00306	5e		 pop	 esi
  00307	5d		 pop	 ebp
  00308	5b		 pop	 ebx

; 1416 : }

  00309	83 c4 18	 add	 esp, 24			; 00000018H
  0030c	c3		 ret	 0
$L70975:

; 1084 :   }
; 1085 : 
; 1086 :   /********************************************************************/
; 1087 :   /*  Set the wave format data in the "play audio" handle.            */
; 1088 :   /********************************************************************/
; 1089 : #ifdef AUD_DEBUG
; 1090 :   OutputDebugString("PA_: setting format in handle..\n");
; 1091 : #endif
; 1092 :   if ( pWaveFormat != NULL )

  0030d	8b 44 24 34	 mov	 eax, DWORD PTR _pWaveFormat$[esp+36]
  00311	3b c7		 cmp	 eax, edi
  00313	74 03		 je	 SHORT $L70977

; 1093 :   {
; 1094 : #ifdef AUD_DEBUG
; 1095 : 	  OutputDebugString("PA_: SetNewFormat {1}\n");
; 1096 : #endif
; 1097 : 	  mmStatus = SetNewFormat( pPlayAudio, pWaveFormat );

  00315	50		 push	 eax

; 1098 :   }
; 1099 :   else

  00316	eb 32		 jmp	 SHORT $L72025
$L70977:

; 1100 :   {
; 1101 :     /******************************************************************/
; 1102 :     /*  The default format is 11 Khz. 16 bit PCM.                     */
; 1103 :     /******************************************************************/
; 1104 : 
; 1105 :     WaveFormat.wFormatTag = WAVE_FORMAT_PCM;
; 1106 :     WaveFormat.nSamplesPerSec = 11025;
; 1107 :     WaveFormat.nChannels = 1;
; 1108 :     WaveFormat.nAvgBytesPerSec = 22050;
; 1109 :     WaveFormat.nBlockAlign = 2;
; 1110 :     WaveFormat.wBitsPerSample = 16;
; 1111 :     WaveFormat.cbSize = 0;
; 1112 : 
; 1113 : #ifdef AUD_DEBUG
; 1114 : 	OutputDebugString("PA_: SetNewFormat {2}\n");
; 1115 : #endif
; 1116 :     mmStatus = SetNewFormat( pPlayAudio, &WaveFormat );

  00318	8d 4c 24 14	 lea	 ecx, DWORD PTR _WaveFormat$[esp+40]
  0031c	66 89 6c 24 14	 mov	 WORD PTR _WaveFormat$[esp+40], bp
  00321	c7 44 24 18 11
	2b 00 00	 mov	 DWORD PTR _WaveFormat$[esp+44], 11025 ; 00002b11H
  00329	66 89 6c 24 16	 mov	 WORD PTR _WaveFormat$[esp+42], bp
  0032e	c7 44 24 1c 22
	56 00 00	 mov	 DWORD PTR _WaveFormat$[esp+48], 22050 ; 00005622H
  00336	66 c7 44 24 20
	02 00		 mov	 WORD PTR _WaveFormat$[esp+52], 2
  0033d	66 c7 44 24 22
	10 00		 mov	 WORD PTR _WaveFormat$[esp+54], 16 ; 00000010H
  00344	66 89 7c 24 24	 mov	 WORD PTR _WaveFormat$[esp+56], di
  00349	51		 push	 ecx
$L72025:
  0034a	56		 push	 esi
  0034b	e8 00 00 00 00	 call	 _SetNewFormat
  00350	8b e8		 mov	 ebp, eax
  00352	83 c4 08	 add	 esp, 8

; 1117 :   }
; 1118 : 
; 1119 :   if ( mmStatus )

  00355	3b ef		 cmp	 ebp, edi
  00357	74 13		 je	 SHORT $L70979

; 1120 :   {
; 1121 : #ifdef AUD_DEBUG
; 1122 : 	OutputDebugString("PA_: SetNewFormat failed\n");
; 1123 : #endif
; 1124 :     PA_DestroyPlayHandle( pPlayAudio );

  00359	56		 push	 esi
  0035a	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  0035f	83 c4 04	 add	 esp, 4

; 1125 :     return mmStatus;

  00362	8b c5		 mov	 eax, ebp
  00364	5f		 pop	 edi
  00365	5e		 pop	 esi
  00366	5d		 pop	 ebp
  00367	5b		 pop	 ebx

; 1416 : }

  00368	83 c4 18	 add	 esp, 24			; 00000018H
  0036b	c3		 ret	 0
$L70979:

; 1126 :   }
; 1127 : 
; 1128 :   /********************************************************************/
; 1129 :   /*  Allocate Memory for Wave Header pointer array.                  */
; 1130 :   /********************************************************************/
; 1131 : 
; 1132 :   pPlayAudio->ppWaveHdr =
; 1133 :     (LPWAVEHDR *)malloc( MAXIMUM_BUFFERS_QUEUED * sizeof(LPWAVEHDR));

  0036c	6a 20		 push	 32			; 00000020H
  0036e	ff d3		 call	 ebx
  00370	83 c4 04	 add	 esp, 4

; 1134 : 
; 1135 :   if ( pPlayAudio->ppWaveHdr == NULL )

  00373	3b c7		 cmp	 eax, edi
  00375	89 86 94 00 00
	00		 mov	 DWORD PTR [esi+148], eax
  0037b	75 16		 jne	 SHORT $L70983

; 1136 :   {
; 1137 :     PA_DestroyPlayHandle( pPlayAudio );

  0037d	56		 push	 esi
  0037e	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00383	83 c4 04	 add	 esp, 4

; 1138 :     return MMSYSERR_NOMEM;

  00386	b8 07 00 00 00	 mov	 eax, 7
  0038b	5f		 pop	 edi
  0038c	5e		 pop	 esi
  0038d	5d		 pop	 ebp
  0038e	5b		 pop	 ebx

; 1416 : }

  0038f	83 c4 18	 add	 esp, 24			; 00000018H
  00392	c3		 ret	 0
$L70983:

; 1139 :   }
; 1140 :   else
; 1141 :   {
; 1142 :     for ( uiI = 0; uiI < MAXIMUM_BUFFERS_QUEUED; uiI++ )

  00393	33 c0		 xor	 eax, eax
$L70985:

; 1143 :       pPlayAudio->ppWaveHdr[uiI] = NULL;

  00395	8b 96 94 00 00
	00		 mov	 edx, DWORD PTR [esi+148]
  0039b	83 c0 04	 add	 eax, 4
  0039e	83 f8 20	 cmp	 eax, 32			; 00000020H
  003a1	89 7c 10 fc	 mov	 DWORD PTR [eax+edx-4], edi
  003a5	7c ee		 jl	 SHORT $L70985

; 1144 : 
; 1145 :     /******************************************************************/
; 1146 :     /*  Allocate Memory for the Wave Headers.                         */
; 1147 :     /******************************************************************/
; 1148 : 
; 1149 :     for ( uiI = 0; uiI < MAXIMUM_BUFFERS_QUEUED; uiI++ )

  003a7	33 ed		 xor	 ebp, ebp
$L70989:

; 1150 :     {
; 1151 :       LOCK_MME_CALL(
; 1152 :         pPlayAudio->ppWaveHdr[uiI] =
; 1153 :           (LPWAVEHDR)ALLOCATE_LOCKED_MEMORY( sizeof(WAVEHDR)))

  003a9	6a 20		 push	 32			; 00000020H
  003ab	e8 00 00 00 00	 call	 _mallocLock
  003b0	8b 8e 94 00 00
	00		 mov	 ecx, DWORD PTR [esi+148]
  003b6	83 c4 04	 add	 esp, 4
  003b9	89 04 29	 mov	 DWORD PTR [ecx+ebp], eax

; 1154 : 
; 1155 :       if ( pPlayAudio->ppWaveHdr[uiI] == NULL )

  003bc	8b 96 94 00 00
	00		 mov	 edx, DWORD PTR [esi+148]
  003c2	39 3c 2a	 cmp	 DWORD PTR [edx+ebp], edi
  003c5	74 48		 je	 SHORT $L72022
  003c7	83 c5 04	 add	 ebp, 4
  003ca	83 fd 20	 cmp	 ebp, 32			; 00000020H
  003cd	7c da		 jl	 SHORT $L70989

; 1156 :       {
; 1157 :         PA_DestroyPlayHandle( pPlayAudio );
; 1158 :         return MMSYSERR_NOMEM;
; 1159 :       }
; 1160 :     }
; 1161 :   }
; 1162 : 
; 1163 :   /********************************************************************/
; 1164 :   /*  Allocate Memory for the Audio Queue Structure.                  */
; 1165 :   /********************************************************************/
; 1166 : 
; 1167 :   pPlayAudioRing = (LPPLAY_RING_T)malloc(sizeof(PLAY_RING_T));

  003cf	6a 20		 push	 32			; 00000020H
  003d1	ff d3		 call	 ebx
  003d3	8b e8		 mov	 ebp, eax
  003d5	83 c4 04	 add	 esp, 4

; 1168 : 
; 1169 :   if ( pPlayAudioRing == NULL )

  003d8	3b ef		 cmp	 ebp, edi
  003da	75 16		 jne	 SHORT $L70999

; 1170 :   {
; 1171 :     PA_DestroyPlayHandle( pPlayAudio );

  003dc	56		 push	 esi
  003dd	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  003e2	83 c4 04	 add	 esp, 4

; 1172 :     return MMSYSERR_NOMEM;

  003e5	b8 07 00 00 00	 mov	 eax, 7
  003ea	5f		 pop	 edi
  003eb	5e		 pop	 esi
  003ec	5d		 pop	 ebp
  003ed	5b		 pop	 ebx

; 1416 : }

  003ee	83 c4 18	 add	 esp, 24			; 00000018H
  003f1	c3		 ret	 0
$L70999:

; 1173 :   }
; 1174 : 
; 1175 :   pPlayAudio->pPlayAudioRing = pPlayAudioRing;

  003f2	89 ae 98 00 00
	00		 mov	 DWORD PTR [esi+152], ebp

; 1176 : 
; 1177 :   /********************************************************************/
; 1178 :   /*  Initialize several of the audio queue elements to NULL.         */
; 1179 :   /********************************************************************/
; 1180 : 
; 1181 :   pPlayAudioRing->pQueueTop = NULL;
; 1182 : 
; 1183 :   /********************************************************************/
; 1184 :   /*  Allocate Memory for the audio buffer.                           */
; 1185 :   /********************************************************************/
; 1186 : 
; 1187 :   LOCK_MME_CALL(
; 1188 :     pPlayAudioRing->pQueueTop = (LPAUDIO_T)
; 1189 :       ALLOCATE_SERVER_BUFFER(( AUDIO_BUFFER_SIZE + MAXIMUM_WRITE_LENGTH ) *
; 1190 :         sizeof(AUDIO_T)))

  003f8	68 00 80 02 00	 push	 163840			; 00028000H
  003fd	89 7d 00	 mov	 DWORD PTR [ebp], edi
  00400	e8 00 00 00 00	 call	 _mallocLock
  00405	83 c4 04	 add	 esp, 4

; 1191 : 
; 1192 :   if ( pPlayAudioRing->pQueueTop == NULL )

  00408	3b c7		 cmp	 eax, edi
  0040a	89 45 00	 mov	 DWORD PTR [ebp], eax
  0040d	75 16		 jne	 SHORT $L71004
$L72022:

; 1193 :   {
; 1194 :     PA_DestroyPlayHandle( pPlayAudio );

  0040f	56		 push	 esi
  00410	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00415	83 c4 04	 add	 esp, 4

; 1195 :     return MMSYSERR_NOMEM;

  00418	b8 07 00 00 00	 mov	 eax, 7
  0041d	5f		 pop	 edi
  0041e	5e		 pop	 esi
  0041f	5d		 pop	 ebp
  00420	5b		 pop	 ebx

; 1416 : }

  00421	83 c4 18	 add	 esp, 24			; 00000018H
  00424	c3		 ret	 0
$L71004:

; 1196 :   }
; 1197 : 
; 1198 :   /********************************************************************/
; 1199 :   /*  Initialize the audio queue buffer start and length.             */
; 1200 :   /********************************************************************/
; 1201 : 
; 1202 :   pPlayAudioRing->pQueueStart =
; 1203 :     pPlayAudioRing->pQueueTop + MAXIMUM_WRITE_LENGTH;

  00425	05 00 40 00 00	 add	 eax, 16384		; 00004000H

; 1204 :   pPlayAudioRing->iQueueLength = AUDIO_BUFFER_SIZE;
; 1205 : 
; 1206 :   /********************************************************************/
; 1207 :   /*  Initialize the audio queue and the completion count.            */
; 1208 :   /********************************************************************/
; 1209 : 
; 1210 :   ResetAudioQueue( pPlayAudio );

  0042a	56		 push	 esi
  0042b	89 45 04	 mov	 DWORD PTR [ebp+4], eax
  0042e	c7 45 1c 00 40
	02 00		 mov	 DWORD PTR [ebp+28], 147456 ; 00024000H
  00435	e8 00 00 00 00	 call	 _ResetAudioQueue

; 1211 : 
; 1212 :   pPlayAudio->iSamplesWaitingForCompletion = 0;

  0043a	89 7e 30	 mov	 DWORD PTR [esi+48], edi

; 1213 : 
; 1214 :   /********************************************************************/
; 1215 :   /*  If this is the first instance then create a message queue and   */
; 1216 :   /*  a "play audio" thread.                                          */
; 1217 :   /********************************************************************/
; 1218 : 
; 1219 :   if ( pShm_t->uiGlobalPlayAudioInstance == 1 )

  0043d	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  00442	83 c4 04	 add	 esp, 4
  00445	83 38 01	 cmp	 DWORD PTR [eax], 1
  00448	0f 85 df 00 00
	00		 jne	 $L71005

; 1220 :   {
; 1221 :     /******************************************************************/
; 1222 :     /*  Create the "play audio" message queue.                        */
; 1223 :     /******************************************************************/
; 1224 : 
; 1225 :     pShm_t->pGlobalPlayAudioMessageQueue = CreateMessageQueue( MESSAGE_QUEUE_LENGTH );

  0044e	68 00 01 00 00	 push	 256			; 00000100H
  00453	e8 00 00 00 00	 call	 _CreateMessageQueue
  00458	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t
  0045e	83 c4 04	 add	 esp, 4
  00461	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1226 : 
; 1227 :     if ( pShm_t->pGlobalPlayAudioMessageQueue == NULL )

  00464	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  0046a	39 7a 14	 cmp	 DWORD PTR [edx+20], edi
  0046d	75 16		 jne	 SHORT $L71007

; 1228 :     {
; 1229 :       PA_DestroyPlayHandle( pPlayAudio );

  0046f	56		 push	 esi
  00470	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00475	83 c4 04	 add	 esp, 4

; 1230 :       return MMSYSERR_ERROR;

  00478	b8 01 00 00 00	 mov	 eax, 1
  0047d	5f		 pop	 edi
  0047e	5e		 pop	 esi
  0047f	5d		 pop	 ebp
  00480	5b		 pop	 ebx

; 1416 : }

  00481	83 c4 18	 add	 esp, 24			; 00000018H
  00484	c3		 ret	 0
$L71007:

; 1231 :     }
; 1232 : 
; 1233 :     /******************************************************************/
; 1234 :     /*  Create the "report" message queue.                            */
; 1235 :     /******************************************************************/
; 1236 : 
; 1237 :     pShm_t->pGlobalReportMessageQueue = CreateMessageQueue( 1 );

  00485	6a 01		 push	 1
  00487	e8 00 00 00 00	 call	 _CreateMessageQueue
  0048c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t
  00492	83 c4 04	 add	 esp, 4
  00495	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 1238 : 
; 1239 :     if ( pShm_t->pGlobalReportMessageQueue == NULL )

  00498	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  0049e	39 7a 10	 cmp	 DWORD PTR [edx+16], edi
  004a1	75 16		 jne	 SHORT $L71009

; 1240 :     {
; 1241 :       PA_DestroyPlayHandle( pPlayAudio );

  004a3	56		 push	 esi
  004a4	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  004a9	83 c4 04	 add	 esp, 4

; 1242 :       return MMSYSERR_ERROR;

  004ac	b8 01 00 00 00	 mov	 eax, 1
  004b1	5f		 pop	 edi
  004b2	5e		 pop	 esi
  004b3	5d		 pop	 ebp
  004b4	5b		 pop	 ebx

; 1416 : }

  004b5	83 c4 18	 add	 esp, 24			; 00000018H
  004b8	c3		 ret	 0
$L71009:

; 1243 :     }
; 1244 : 
; 1245 :     /******************************************************************/
; 1246 :     /*  Create the global "Send Play Audio" mutex.                    */
; 1247 :     /******************************************************************/
; 1248 : 
; 1249 :     pShm_t->hmxGlobalSendPlayAudio = OP_CreateMutex();

  004b9	e8 00 00 00 00	 call	 _OP_CreateMutex
  004be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t

; 1250 : 
; 1251 :     if ( pShm_t->hmxGlobalSendPlayAudio == NULL )
; 1252 :     {
; 1253 :       PA_DestroyPlayHandle( pPlayAudio );

  004c4	56		 push	 esi
  004c5	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  004c8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  004ce	39 7a 0c	 cmp	 DWORD PTR [edx+12], edi
  004d1	75 15		 jne	 SHORT $L71011
  004d3	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  004d8	83 c4 04	 add	 esp, 4

; 1254 :       return MMSYSERR_ERROR;

  004db	b8 01 00 00 00	 mov	 eax, 1
  004e0	5f		 pop	 edi
  004e1	5e		 pop	 esi
  004e2	5d		 pop	 ebp
  004e3	5b		 pop	 ebx

; 1416 : }

  004e4	83 c4 18	 add	 esp, 24			; 00000018H
  004e7	c3		 ret	 0
$L71011:

; 1255 :     }
; 1256 : 
; 1257 :     /******************************************************************/
; 1258 :     /*  Create the play audio thread.                                 */
; 1259 :     /******************************************************************/
; 1260 : 
; 1261 :     pShm_t->hGlobalPlayAudioThread =
; 1262 :               OP_CreateThread( 0,
; 1263 :                                (THREAD_PROCEDURE_T)PlayAudioThreadMain,
; 1264 :                                pPlayAudio );

  004e8	68 00 00 00 00	 push	 OFFSET FLAT:_PlayAudioThreadMain
  004ed	57		 push	 edi
  004ee	e8 00 00 00 00	 call	 _OP_CreateThread
  004f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t
  004f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  004fc	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1265 : 
; 1266 :     if ( pShm_t->hGlobalPlayAudioThread == NULL )

  004ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  00505	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00508	3b c7		 cmp	 eax, edi
  0050a	75 16		 jne	 SHORT $L71014

; 1267 :     {
; 1268 :       PA_DestroyPlayHandle( pPlayAudio );

  0050c	56		 push	 esi
  0050d	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00512	83 c4 04	 add	 esp, 4

; 1269 :       return MMSYSERR_ERROR;

  00515	b8 01 00 00 00	 mov	 eax, 1
  0051a	5f		 pop	 edi
  0051b	5e		 pop	 esi
  0051c	5d		 pop	 ebp
  0051d	5b		 pop	 ebx

; 1416 : }

  0051e	83 c4 18	 add	 esp, 24			; 00000018H
  00521	c3		 ret	 0
$L71014:

; 1270 :     }
; 1271 : 
; 1272 :     OP_SetThreadPriority( pShm_t->hGlobalPlayAudioThread, OP_PRIORITY_HIGHEST );

  00522	6a 02		 push	 2
  00524	50		 push	 eax
  00525	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  0052a	83 c4 08	 add	 esp, 8
$L71005:

; 1273 : 
; 1274 : #ifdef USE_MME_SERVER
; 1275 : 
; 1276 :     /******************************************************************/
; 1277 :     /*  Create the MME callback thread.                               */
; 1278 :     /******************************************************************/
; 1279 : 
; 1280 :     pShm_t->bGlobalMmeCallbackExit = FALSE;
; 1281 : 
; 1282 :     pShm_t->hGlobalMmeCallbackThread =
; 1283 :             OP_CreateThread( 0,
; 1284 :                              (THREAD_PROCEDURE_T)MmeCallbackThreadMain,
; 1285 :                              pPlayAudio );
; 1286 : 
; 1287 : /* TQL 05/21/1997  change this for OSF build */
; 1288 : #ifdef WIN32
; 1289 :     if ( pShm_t->hGlobalPlayAudioThread == NULL )
; 1290 : #endif
; 1291 : #ifdef __osf__
; 1292 :     if ( pShm_t->hGlobalMmeCallbackThread == NULL )
; 1293 : #endif
; 1294 :     {
; 1295 :       PA_DestroyPlayHandle( pPlayAudio );
; 1296 :       return MMSYSERR_ERROR;
; 1297 :     }
; 1298 : 
; 1299 : #endif
; 1300 : 
; 1301 :   }
; 1302 :   // tek 30sep96 move this thread creation up here (BATS 136)
; 1303 :   /********************************************************************/
; 1304 :   /*  Create the Timer Thread.                                        */
; 1305 :   /********************************************************************/
; 1306 : 
; 1307 :   pPlayAudio->hTimerThread =
; 1308 :                   OP_CreateThread( 0,
; 1309 :                                    (THREAD_PROCEDURE_T)TimerThreadMain,
; 1310 :                                    pPlayAudio );

  0052d	56		 push	 esi
  0052e	68 00 00 00 00	 push	 OFFSET FLAT:_TimerThreadMain
  00533	57		 push	 edi
  00534	e8 00 00 00 00	 call	 _OP_CreateThread
  00539	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1311 : 
; 1312 :   if ( pPlayAudio->hTimerThread == NULL )

  0053c	3b c7		 cmp	 eax, edi
  0053e	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00541	75 16		 jne	 SHORT $L71017

; 1313 :   {
; 1314 :     PA_DestroyPlayHandle( pPlayAudio );

  00543	56		 push	 esi
  00544	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00549	83 c4 04	 add	 esp, 4

; 1315 :     return MMSYSERR_ERROR;

  0054c	b8 01 00 00 00	 mov	 eax, 1
  00551	5f		 pop	 edi
  00552	5e		 pop	 esi
  00553	5d		 pop	 ebp
  00554	5b		 pop	 ebx

; 1416 : }

  00555	83 c4 18	 add	 esp, 24			; 00000018H
  00558	c3		 ret	 0
$L71017:

; 1316 :   }
; 1317 : 
; 1318 :   /********************************************************************/
; 1319 :   /*  Selected a device ID into the "play audio" handle.              */
; 1320 :   /********************************************************************/
; 1321 : 
; 1322 :   if ( uiWaveOutDeviceID == (unsigned int)WAVE_MAPPER )

  00559	8b 44 24 30	 mov	 eax, DWORD PTR _uiWaveOutDeviceID$[esp+36]
  0055d	83 f8 ff	 cmp	 eax, -1
  00560	75 2e		 jne	 SHORT $L71020

; 1323 :   {
; 1324 : #ifdef AUD_DEBUG
; 1325 : 	OutputDebugString("PA_: device is WAVE_MAPPER\n");
; 1326 : #endif
; 1327 :     mmStatus = DetermineDeviceID( pPlayAudio,
; 1328 :                                   uiNumberOfWaveOutDevices,
; 1329 :                                   pPlayAudio->pWaveFormat );

  00562	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  00568	8b 4c 24 10	 mov	 ecx, DWORD PTR _uiNumberOfWaveOutDevices$[esp+40]
  0056c	50		 push	 eax
  0056d	51		 push	 ecx
  0056e	56		 push	 esi
  0056f	e8 00 00 00 00	 call	 _DetermineDeviceID
  00574	8b e8		 mov	 ebp, eax
  00576	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1330 :     if ( mmStatus )

  00579	3b ef		 cmp	 ebp, edi
  0057b	74 45		 je	 SHORT $L71023

; 1331 :     {
; 1332 : #ifdef AUD_DEBUG
; 1333 : 	  OutputDebugString("PA_: DetermineDeviceID failed\n");
; 1334 : #endif
; 1335 :       PA_DestroyPlayHandle( pPlayAudio );

  0057d	56		 push	 esi
  0057e	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00583	83 c4 04	 add	 esp, 4

; 1336 :       return mmStatus;

  00586	8b c5		 mov	 eax, ebp
  00588	5f		 pop	 edi
  00589	5e		 pop	 esi
  0058a	5d		 pop	 ebp
  0058b	5b		 pop	 ebx

; 1416 : }

  0058c	83 c4 18	 add	 esp, 24			; 00000018H
  0058f	c3		 ret	 0
$L71020:

; 1337 :     }
; 1338 :   }
; 1339 :   else
; 1340 :   {
; 1341 : #ifdef AUD_DEBUG
; 1342 :     {
; 1343 :       char  szTemp[256]="";
; 1344 :       sprintf(szTemp,"PA_: device is not WAVE_MAPPER, it is: %i\n"
; 1345 : 	      ,uiWaveOutDeviceID);
; 1346 :       OutputDebugString(szTemp);
; 1347 :     }
; 1348 : #endif
; 1349 :     pPlayAudio->uiSelectedDeviceID = uiWaveOutDeviceID;
; 1350 : 
; 1351 :     mmStatus = PA_SetFormat( pPlayAudio, pPlayAudio->pWaveFormat );

  00590	8b 96 a0 00 00
	00		 mov	 edx, DWORD PTR [esi+160]
  00596	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00599	52		 push	 edx
  0059a	56		 push	 esi
  0059b	e8 00 00 00 00	 call	 _PA_SetFormat
  005a0	83 c4 08	 add	 esp, 8

; 1352 : 
; 1353 :     if (( mmStatus != MMSYSERR_NOERROR )
; 1354 :       && ( mmStatus != MMSYSERR_ALLOCATED ))

  005a3	3b c7		 cmp	 eax, edi
  005a5	74 1b		 je	 SHORT $L71023
  005a7	83 f8 04	 cmp	 eax, 4
  005aa	74 16		 je	 SHORT $L71023

; 1355 :     {
; 1356 : #ifdef AUD_DEBUG
; 1357 : 	  OutputDebugString("PA_: PA_SetFormat failed\n");
; 1358 : #endif
; 1359 :       PA_DestroyPlayHandle( pPlayAudio );

  005ac	56		 push	 esi
  005ad	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  005b2	83 c4 04	 add	 esp, 4

; 1360 :       return MMSYSERR_NOTSUPPORTED;

  005b5	b8 08 00 00 00	 mov	 eax, 8
  005ba	5f		 pop	 edi
  005bb	5e		 pop	 esi
  005bc	5d		 pop	 ebp
  005bd	5b		 pop	 ebx

; 1416 : }

  005be	83 c4 18	 add	 esp, 24			; 00000018H
  005c1	c3		 ret	 0
$L71023:

; 1361 :     }
; 1362 :   }
; 1363 : 
; 1364 :   /********************************************************************/
; 1365 :   /*  Set the dwDeviceSupport member of the play audio handle         */
; 1366 :   /*  pointed to by "pPlayAudio" to the dwSupport field of the        */
; 1367 :   /*  WAVEOUTCAPS structure. The device ID is specified by the        */
; 1368 :   /*  uiSelectedDeviceID field of the play audio handle.              */
; 1369 :   /********************************************************************/
; 1370 : 
; 1371 :   if ( pPlayAudio->uiSelectedDeviceID != (unsigned int)WAVE_MAPPER )

  005c2	83 7e 20 ff	 cmp	 DWORD PTR [esi+32], -1
  005c6	74 22		 je	 SHORT $L71027

; 1372 :   {
; 1373 :     mmStatus = GetWaveOutDeviceCaps( pPlayAudio );

  005c8	56		 push	 esi
  005c9	e8 00 00 00 00	 call	 _GetWaveOutDeviceCaps
  005ce	8b e8		 mov	 ebp, eax
  005d0	83 c4 04	 add	 esp, 4

; 1374 : 
; 1375 :     if ( mmStatus )

  005d3	3b ef		 cmp	 ebp, edi
  005d5	74 13		 je	 SHORT $L71027

; 1376 :     {
; 1377 : #ifdef AUD_DEBUG
; 1378 : 	  OutputDebugString("PA_: GetWaveOutDeviceCaps failed\n");
; 1379 : #endif
; 1380 :       PA_DestroyPlayHandle( pPlayAudio );

  005d7	56		 push	 esi
  005d8	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  005dd	83 c4 04	 add	 esp, 4

; 1381 :       return mmStatus;

  005e0	8b c5		 mov	 eax, ebp
  005e2	5f		 pop	 edi
  005e3	5e		 pop	 esi
  005e4	5d		 pop	 ebp
  005e5	5b		 pop	 ebx

; 1416 : }

  005e6	83 c4 18	 add	 esp, 24			; 00000018H
  005e9	c3		 ret	 0
$L71027:

; 1382 :     }
; 1383 :   }
; 1384 : 
; 1385 :   /********************************************************************/
; 1386 :   /*  If the application will own the audio device then try to open   */
; 1387 :   /*  it now.                                                         */
; 1388 :   /********************************************************************/
; 1389 : 
; 1390 :   if ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )

  005ea	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  005ee	74 26		 je	 SHORT $L71029

; 1391 :   {
; 1392 :     if ( SendPlayAudioMessage( pPlayAudio,
; 1393 :                                ID_Open_Wave_Output_Device,
; 1394 :                                0L ) == MMSYSERR_NOTSUPPORTED )

  005f0	57		 push	 edi
  005f1	57		 push	 edi
  005f2	56		 push	 esi
  005f3	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  005f8	83 c4 0c	 add	 esp, 12			; 0000000cH
  005fb	83 f8 08	 cmp	 eax, 8
  005fe	75 16		 jne	 SHORT $L71029

; 1395 :     {
; 1396 : #ifdef AUD_DEBUG
; 1397 : 	  OutputDebugString("PA_: SendPlayAudioMessage failed\n");
; 1398 : #endif
; 1399 : 	  PA_DestroyPlayHandle( pPlayAudio );

  00600	56		 push	 esi
  00601	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00606	83 c4 04	 add	 esp, 4

; 1400 :       return MMSYSERR_NOTSUPPORTED;

  00609	b8 08 00 00 00	 mov	 eax, 8
  0060e	5f		 pop	 edi
  0060f	5e		 pop	 esi
  00610	5d		 pop	 ebp
  00611	5b		 pop	 ebx

; 1416 : }

  00612	83 c4 18	 add	 esp, 24			; 00000018H
  00615	c3		 ret	 0
$L71029:

; 1401 :     }
; 1402 :   }
; 1403 : 
; 1404 :   /********************************************************************/
; 1405 :   /*  Pass the play audio handle back to the application.             */
; 1406 :   /********************************************************************/
; 1407 : 
; 1408 :   pPlayAudio->bHandleValid = TRUE;
; 1409 : 
; 1410 :   *ppPlayAudio = pPlayAudio;

  00616	8b 44 24 2c	 mov	 eax, DWORD PTR _ppPlayAudio$[esp+36]
  0061a	c7 46 68 01 00
	00 00		 mov	 DWORD PTR [esi+104], 1
  00621	5f		 pop	 edi
  00622	89 30		 mov	 DWORD PTR [eax], esi
  00624	5e		 pop	 esi
  00625	5d		 pop	 ebp

; 1411 : 
; 1412 : #ifdef AUD_DEBUG
; 1413 :   OutputDebugString("PA_: Successful exit.\n");
; 1414 : #endif
; 1415 :   return MMSYSERR_NOERROR;

  00626	33 c0		 xor	 eax, eax
  00628	5b		 pop	 ebx

; 1416 : }

  00629	83 c4 18	 add	 esp, 24			; 00000018H
  0062c	c3		 ret	 0
_PA_CreatePlayHandleEx ENDP
_TEXT	ENDS
PUBLIC	_PA_DestroyPlayHandleEx
_TEXT	SEGMENT
_pPlayAudio$ = 8
_PA_DestroyPlayHandle PROC NEAR

; 1452 : {

  00630	56		 push	 esi

; 1453 : 
; 1454 : 	MMRESULT mmResult=MMSYSERR_ERROR; // the default error
; 1455 : 	BOOL bGotLock=FALSE;	// whether we got the lock
; 1456 : 
; 1457 : 	// try to gain control of the resources
; 1458 : 	bGotLock = ThreadLock(&tlPlayAudio,5);

  00631	6a 05		 push	 5
  00633	68 00 00 00 00	 push	 OFFSET FLAT:_tlPlayAudio
  00638	be 01 00 00 00	 mov	 esi, 1
  0063d	e8 00 00 00 00	 call	 _ThreadLock
  00642	83 c4 08	 add	 esp, 8

; 1459 : 	if (bGotLock)

  00645	85 c0		 test	 eax, eax
  00647	74 19		 je	 SHORT $L72027

; 1460 : 	{	// do the actual call..
; 1461 : 		mmResult = PA_DestroyPlayHandleEx( pPlayAudio );

  00649	8b 44 24 08	 mov	 eax, DWORD PTR _pPlayAudio$[esp]
  0064d	50		 push	 eax
  0064e	e8 00 00 00 00	 call	 _PA_DestroyPlayHandleEx

; 1462 : 		// unlock the resources
; 1463 : 		ThreadUnlock(&tlPlayAudio);

  00653	68 00 00 00 00	 push	 OFFSET FLAT:_tlPlayAudio
  00658	8b f0		 mov	 esi, eax
  0065a	e8 00 00 00 00	 call	 _ThreadUnlock
  0065f	83 c4 08	 add	 esp, 8
$L72027:

; 1464 : 	}
; 1465 : 	// return our result
; 1466 : 	return (mmResult);

  00662	8b c6		 mov	 eax, esi
  00664	5e		 pop	 esi

; 1467 : }

  00665	c3		 ret	 0
_PA_DestroyPlayHandle ENDP
_TEXT	ENDS
PUBLIC	_PA_Reset
EXTRN	__imp__free:NEAR
EXTRN	__imp__waveOutClose@4:NEAR
EXTRN	_OP_WaitForThreadTermination:NEAR
EXTRN	_OP_DestroyMutex:NEAR
EXTRN	_OP_LockMutex:NEAR
EXTRN	_OP_UnlockMutex:NEAR
EXTRN	_OP_DestroyEvent:NEAR
EXTRN	_OP_SetEvent:NEAR
EXTRN	_OP_ResetEvent:NEAR
EXTRN	_OP_WaitForEvent:NEAR
EXTRN	_freeLock:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_ThreadStatus$ = -4
_PA_DestroyPlayHandleEx PROC NEAR

; 1471 : {

  00670	51		 push	 ecx

; 1472 :   unsigned int uiI;
; 1473 :   MMRESULT mmStatus;
; 1474 :   THREAD_STATUS_T ThreadStatus;
; 1475 :   LPPLAY_RING_T pPlayAudioRing;
; 1476 :   
; 1477 :   /********************************************************************/
; 1478 :   /*  Decrement the play audio instance count.                        */
; 1479 :   /********************************************************************/
; 1480 :   
; 1481 :   pShm_t->uiGlobalPlayAudioInstance--;

  00671	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  00676	55		 push	 ebp
  00677	56		 push	 esi

; 1482 :   
; 1483 :   /********************************************************************/
; 1484 :   /*  Destroy the play audio handle.                                  */
; 1485 :   /********************************************************************/
; 1486 :   
; 1487 :   if ( pPlayAudio != NULL )

  00678	8b 74 24 10	 mov	 esi, DWORD PTR _pPlayAudio$[esp+8]
  0067c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0067e	33 ed		 xor	 ebp, ebp
  00680	49		 dec	 ecx
  00681	3b f5		 cmp	 esi, ebp
  00683	89 08		 mov	 DWORD PTR [eax], ecx
  00685	0f 84 0f 02 00
	00		 je	 $L71047

; 1488 :     {
; 1489 :       /******************************************************************/
; 1490 :       /*  If the audio system is playing then a reset is necessary      */
; 1491 :       /*  before shutting down.                                         */
; 1492 :       /******************************************************************/
; 1493 :       
; 1494 :       if ( pPlayAudio->bHandleValid )

  0068b	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  0068e	53		 push	 ebx
  0068f	3b c5		 cmp	 eax, ebp
  00691	bb 01 00 00 00	 mov	 ebx, 1
  00696	74 3a		 je	 SHORT $L71049

; 1495 : 	{
; 1496 : 	  PA_Reset( pPlayAudio );

  00698	56		 push	 esi
  00699	e8 00 00 00 00	 call	 _PA_Reset

; 1497 : 	  
; 1498 : 	  /****************************************************************/
; 1499 : 	  /*  The audio system has already been reset so we can close the */
; 1500 : 	  /*  wave output device here.                                    */
; 1501 : 	  /****************************************************************/
; 1502 : 	  
; 1503 : 	  pPlayAudio->bReportPlayStop = FALSE;
; 1504 : 	  
; 1505 : 	  OP_ResetEvent( pPlayAudio->hevAudioDeviceInactive );

  0069e	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  006a1	89 6e 64	 mov	 DWORD PTR [esi+100], ebp
  006a4	50		 push	 eax
  006a5	e8 00 00 00 00	 call	 _OP_ResetEvent

; 1506 : 	  
; 1507 : 	  if ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )

  006aa	8a 46 3c	 mov	 al, BYTE PTR [esi+60]
  006ad	83 c4 08	 add	 esp, 8
  006b0	84 c3		 test	 al, bl
  006b2	74 1e		 je	 SHORT $L71049

; 1508 : 	    {
; 1509 : 	      LOCK_MME_CALL( waveOutClose( pPlayAudio->hWaveOut ))

  006b4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  006b7	51		 push	 ecx
  006b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutClose@4

; 1510 : 		  pPlayAudio->bResetPaused = FALSE;
; 1511 : 		OP_WaitForEvent( pPlayAudio->hevAudioDeviceInactive,
; 1512 : 				 MAXIMUM_CLOSE_WAIT_IN_MSEC );

  006be	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  006c1	68 88 13 00 00	 push	 5000			; 00001388H
  006c6	52		 push	 edx
  006c7	89 6e 5c	 mov	 DWORD PTR [esi+92], ebp
  006ca	e8 00 00 00 00	 call	 _OP_WaitForEvent
  006cf	83 c4 08	 add	 esp, 8
$L71049:

; 1513 : 	    }
; 1514 : 	}
; 1515 :       
; 1516 :       /******************************************************************/
; 1517 :       /*  Cause the timer thread to exit.                               */
; 1518 :       /*  The only place in the code where the hevTimerThreadActive     */
; 1519 :       /*  event is reset is locked by the synchronization mark mutex so */
; 1520 :       /*  we use that also to lock the thread exit flag. Since this is  */
; 1521 :       /*  only used for shutdown, it seemed unnecessary to create       */
; 1522 :       /*  an additional mutex.                                          */
; 1523 :       /******************************************************************/
; 1524 :       
; 1525 :       if ( pPlayAudio->hTimerThread != NULL )

  006d2	39 6e 0c	 cmp	 DWORD PTR [esi+12], ebp
  006d5	74 3f		 je	 SHORT $L71051

; 1526 : 	{
; 1527 : 	  OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  006d7	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  006dd	50		 push	 eax
  006de	e8 00 00 00 00	 call	 _OP_LockMutex

; 1528 : 	  pPlayAudio->bTimerExit = TRUE;
; 1529 : 	  OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  006e3	8b 8e 8c 00 00
	00		 mov	 ecx, DWORD PTR [esi+140]
  006e9	89 5e 54	 mov	 DWORD PTR [esi+84], ebx
  006ec	51		 push	 ecx
  006ed	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 1530 : 	  
; 1531 : 	  if ( pPlayAudio->hevTimerThreadActive != NULL )

  006f2	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  006f5	83 c4 08	 add	 esp, 8
  006f8	3b c5		 cmp	 eax, ebp
  006fa	74 09		 je	 SHORT $L71053

; 1532 : 	    {
; 1533 : 	      OP_SetEvent( pPlayAudio->hevTimerThreadActive );

  006fc	50		 push	 eax
  006fd	e8 00 00 00 00	 call	 _OP_SetEvent
  00702	83 c4 04	 add	 esp, 4
$L71053:

; 1534 : 	    }
; 1535 : 	  /* TQL 05/21/1997  change this for OSF build */  
; 1536 : 	  OP_WaitForThreadTermination( pPlayAudio->hTimerThread,
; 1537 : #ifdef WIN32
; 1538 : 				       &ThreadStatus
; 1539 : #endif
; 1540 : #if defined __osf__ || defined __linux__
; 1541 : 	                               &ThreadStatus, OP_INFINITE
; 1542 : #endif
; 1543 : 				       );

  00705	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00708	8d 54 24 0c	 lea	 edx, DWORD PTR _ThreadStatus$[esp+16]
  0070c	52		 push	 edx
  0070d	50		 push	 eax
  0070e	e8 00 00 00 00	 call	 _OP_WaitForThreadTermination
  00713	83 c4 08	 add	 esp, 8
$L71051:

; 1544 :         }
; 1545 :       
; 1546 : #ifdef OS_SIXTY_FOUR_BIT
; 1547 :       
; 1548 :       /******************************************************************/
; 1549 :       /*  Set the instance location in the global audio handle array    */
; 1550 :       /*  to NULL.                                                      */
; 1551 :       /******************************************************************/
; 1552 :       
; 1553 :       uiI = pPlayAudio->uiHandleListIndex;
; 1554 :       
; 1555 :       if ( uiI != (unsigned int)(-1))
; 1556 : 	{
; 1557 : 	  pShm_t->ppGlobalHandleList[uiI] = pPlayAudio;
; 1558 : 	}
; 1559 :       
; 1560 : #endif
; 1561 :       
; 1562 :       /******************************************************************/
; 1563 :       /*  If there are no more "play audio" instances then destroy the  */
; 1564 :       /*  "play audio" thread and the message queue.                    */
; 1565 :       /******************************************************************/
; 1566 :       
; 1567 :       if ( pShm_t->uiGlobalPlayAudioInstance == 0 )

  00716	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  0071b	39 28		 cmp	 DWORD PTR [eax], ebp
  0071d	75 7c		 jne	 SHORT $L71062

; 1568 : 	{
; 1569 : 	  
; 1570 : #ifdef USE_MME_SERVER
; 1571 : 	  
; 1572 : 	  /****************************************************************/
; 1573 : 	  /*  Destroy the MME callback thread.                            */
; 1574 : 	  /****************************************************************/
; 1575 : 	  
; 1576 : 	  if ( pShm_t->hGlobalMmeCallbackThread != NULL )
; 1577 : 	    {
; 1578 : 	      pShm_t->bGlobalMmeCallbackExit = TRUE;
; 1579 : 	      
; 1580 : 	      OP_WaitForThreadTermination( pShm_t->hGlobalMmeCallbackThread,
; 1581 : 					   /* TQL 05/21/1997  change this for OSF build */
; 1582 : #ifdef WIN32
; 1583 : 					   &ThreadStatus
; 1584 : #endif
; 1585 : #ifdef __osf__
; 1586 : 					   &ThreadStatus, OP_INFINITE
; 1587 : #endif
; 1588 : 					   );
; 1589 : 	      pShm_t->hGlobalMmeCallbackThread = NULL;
; 1590 : 	    }
; 1591 : 	  
; 1592 : #endif
; 1593 : 	  
; 1594 : 	  /****************************************************************/
; 1595 : 	  /*  Destroy the play audio thread.                              */
; 1596 : 	  /****************************************************************/
; 1597 : 	  
; 1598 : 	  if ( pShm_t->hGlobalPlayAudioThread != NULL ) {

  0071f	39 68 08	 cmp	 DWORD PTR [eax+8], ebp
  00722	74 2e		 je	 SHORT $L71056

; 1599 : 	    SendPlayAudioMessage( pPlayAudio, ID_Destroy_Message, 0 );

  00724	55		 push	 ebp
  00725	6a 0a		 push	 10			; 0000000aH
  00727	56		 push	 esi
  00728	e8 00 00 00 00	 call	 _SendPlayAudioMessage

; 1600 : 	    
; 1601 : 	    OP_WaitForThreadTermination( pShm_t->hGlobalPlayAudioThread,
; 1602 : #ifdef WIN32
; 1603 : 					 &ThreadStatus
; 1604 : #endif
; 1605 : #if defined __osf__ || defined __linux__
; 1606 : 					 &ThreadStatus, OP_INFINITE
; 1607 : #endif
; 1608 : 					 );

  0072d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  00733	8d 4c 24 18	 lea	 ecx, DWORD PTR _ThreadStatus$[esp+28]
  00737	51		 push	 ecx
  00738	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0073b	50		 push	 eax
  0073c	e8 00 00 00 00	 call	 _OP_WaitForThreadTermination

; 1609 : 	    pShm_t->hGlobalPlayAudioThread = NULL;

  00741	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t
  00747	83 c4 14	 add	 esp, 20			; 00000014H
  0074a	89 69 08	 mov	 DWORD PTR [ecx+8], ebp
  0074d	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
$L71056:

; 1610 : 	  }
; 1611 : 	  
; 1612 : 	  /****************************************************************/
; 1613 : 	  /*  Destroy the "Play Audio" message queue.                     */
; 1614 : 	  /****************************************************************/
; 1615 : 	  
; 1616 : 	  if ( pShm_t->pGlobalPlayAudioMessageQueue != NULL )

  00752	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00755	3b cd		 cmp	 ecx, ebp
  00757	74 17		 je	 SHORT $L71059

; 1617 : 	    {
; 1618 : 	      DestroyMessageQueue( pShm_t->pGlobalPlayAudioMessageQueue );

  00759	51		 push	 ecx
  0075a	e8 00 00 00 00	 call	 _DestroyMessageQueue

; 1619 : 	      pShm_t->pGlobalPlayAudioMessageQueue = NULL;

  0075f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  00765	83 c4 04	 add	 esp, 4
  00768	89 6a 14	 mov	 DWORD PTR [edx+20], ebp
  0076b	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
$L71059:

; 1620 : 	    }
; 1621 : 	  
; 1622 : 	  /****************************************************************/
; 1623 : 	  /*  Destroy the "Send Play Audio" mutex.                        */
; 1624 : 	  /****************************************************************/
; 1625 : 	  
; 1626 : 	  OP_DestroyMutex( pShm_t->hmxGlobalSendPlayAudio );

  00770	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00773	50		 push	 eax
  00774	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1627 : 	  
; 1628 : 	  /****************************************************************/
; 1629 : 	  /*  Destroy the "Report" message queue.                         */
; 1630 : 	  /****************************************************************/
; 1631 : 	  
; 1632 : 	  if ( pShm_t->pGlobalReportMessageQueue != NULL )

  00779	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t
  0077f	83 c4 04	 add	 esp, 4
  00782	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00785	3b c5		 cmp	 eax, ebp
  00787	74 12		 je	 SHORT $L71062

; 1633 : 	    {
; 1634 : 	      DestroyMessageQueue( pShm_t->pGlobalReportMessageQueue );

  00789	50		 push	 eax
  0078a	e8 00 00 00 00	 call	 _DestroyMessageQueue

; 1635 : 	      pShm_t->pGlobalReportMessageQueue = NULL;

  0078f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  00795	83 c4 04	 add	 esp, 4
  00798	89 6a 10	 mov	 DWORD PTR [edx+16], ebp
$L71062:

; 1636 : 	    }
; 1637 : 	  
; 1638 : #ifdef OS_SIXTY_FOUR_BIT
; 1639 : 	  
; 1640 : 	  /****************************************************************/
; 1641 : 	  /*  Free the global "play audio" handle list.                   */
; 1642 : 	  /****************************************************************/
; 1643 : 	  
; 1644 : 	  if ( pShm_t->ppGlobalHandleList != NULL )
; 1645 : 	    {
; 1646 : 	      free( pShm_t->ppGlobalHandleList );
; 1647 : 	      pShm_t->ppGlobalHandleList = NULL;
; 1648 : 	    }
; 1649 : 	  
; 1650 : 	  pShm_t->uiGlobalHandleListLength = 0;
; 1651 : 	  
; 1652 : 	  /****************************************************************/
; 1653 : 	  /*  Destroy the "Handle List" mutex.                            */
; 1654 : 	  /****************************************************************/
; 1655 : 	  
; 1656 : 	  OP_DestroyMutex( pShm_t->hmxGlobalHandleList );
; 1657 : 	  
; 1658 : #endif
; 1659 : 	  
; 1660 : 	}
; 1661 :       
; 1662 :       /******************************************************************/
; 1663 :       /*  Free the Audio Queue memory.                                  */
; 1664 :       /******************************************************************/
; 1665 :       
; 1666 :       pPlayAudioRing = pPlayAudio->pPlayAudioRing;
; 1667 :       
; 1668 :       if ( pPlayAudioRing != NULL )

  0079b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__free
  007a1	57		 push	 edi
  007a2	8b be 98 00 00
	00		 mov	 edi, DWORD PTR [esi+152]
  007a8	3b fd		 cmp	 edi, ebp
  007aa	74 15		 je	 SHORT $L71065

; 1669 : 	{
; 1670 : 	  /****************************************************************/
; 1671 : 	  /*  Free Memory for the Audio Queue sample buffer.              */
; 1672 : 	  /****************************************************************/
; 1673 : 	  
; 1674 : 	  if ( pPlayAudioRing->pQueueTop != NULL )

  007ac	8b 07		 mov	 eax, DWORD PTR [edi]
  007ae	3b c5		 cmp	 eax, ebp
  007b0	74 09		 je	 SHORT $L71067

; 1675 : 	    {
; 1676 : 	      LOCK_MME_CALL( FREE_SERVER_BUFFER( pPlayAudioRing->pQueueTop ))

  007b2	50		 push	 eax
  007b3	e8 00 00 00 00	 call	 _freeLock
  007b8	83 c4 04	 add	 esp, 4
$L71067:

; 1677 : 		}
; 1678 : 	  
; 1679 : 	  /****************************************************************/
; 1680 : 	  /*  Free Memory for the Audio Queue Structure.                  */
; 1681 : 	  /****************************************************************/
; 1682 : 	  
; 1683 : 	  free( pPlayAudioRing );

  007bb	57		 push	 edi
  007bc	ff d3		 call	 ebx
  007be	83 c4 04	 add	 esp, 4
$L71065:

; 1684 : 	}
; 1685 :       
; 1686 :       /******************************************************************/
; 1687 :       /*  Free Memory for Wave Headers.                                 */
; 1688 :       /******************************************************************/
; 1689 :       
; 1690 :       if ( pPlayAudio->ppWaveHdr != NULL )

  007c1	39 ae 94 00 00
	00		 cmp	 DWORD PTR [esi+148], ebp
  007c7	74 2c		 je	 SHORT $L71069

; 1691 : 	{
; 1692 : 	  for ( uiI = 0; uiI < MAXIMUM_BUFFERS_QUEUED; uiI++ )

  007c9	33 ff		 xor	 edi, edi
$L71070:

; 1693 : 	    {
; 1694 : 	      if ( pPlayAudio->ppWaveHdr[uiI] != NULL )

  007cb	8b 86 94 00 00
	00		 mov	 eax, DWORD PTR [esi+148]
  007d1	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  007d4	3b c5		 cmp	 eax, ebp
  007d6	74 09		 je	 SHORT $L71071

; 1695 : 		{
; 1696 : 		  LOCK_MME_CALL( FREE_LOCKED_MEMORY( pPlayAudio->ppWaveHdr[uiI] ))

  007d8	50		 push	 eax
  007d9	e8 00 00 00 00	 call	 _freeLock
  007de	83 c4 04	 add	 esp, 4
$L71071:
  007e1	83 c7 04	 add	 edi, 4
  007e4	83 ff 20	 cmp	 edi, 32			; 00000020H
  007e7	7c e2		 jl	 SHORT $L71070

; 1697 : 		    }
; 1698 : 	    }
; 1699 : 	  
; 1700 : 	  /****************************************************************/
; 1701 : 	  /*  Free the Wave Header pointer array memory.                  */
; 1702 : 	  /****************************************************************/
; 1703 : 	  
; 1704 : 	  free( pPlayAudio->ppWaveHdr );

  007e9	8b 8e 94 00 00
	00		 mov	 ecx, DWORD PTR [esi+148]
  007ef	51		 push	 ecx
  007f0	ff d3		 call	 ebx
  007f2	83 c4 04	 add	 esp, 4
$L71069:

; 1705 : 	}
; 1706 :       
; 1707 :       /******************************************************************/
; 1708 :       /*  Destroy the "WaveFormat" mutex.                               */
; 1709 :       /******************************************************************/
; 1710 :       
; 1711 :       OP_DestroyMutex( pPlayAudio->hmxWaveFormat );

  007f5	8b 96 90 00 00
	00		 mov	 edx, DWORD PTR [esi+144]
  007fb	52		 push	 edx
  007fc	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1712 :       
; 1713 :       /******************************************************************/
; 1714 :       /*  Destroy the "Synchronization Mark List" mutex.                */
; 1715 :       /******************************************************************/
; 1716 :       
; 1717 :       OP_DestroyMutex( pPlayAudio->hmxSynchronizationMarkList );

  00801	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  00807	50		 push	 eax
  00808	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1718 :       
; 1719 :       /******************************************************************/
; 1720 :       /*  Destroy the ""Pause Flag" mutex.                              */
; 1721 :       /******************************************************************/
; 1722 :       
; 1723 :       OP_DestroyMutex( pPlayAudio->hmxPauseFlag );

  0080d	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  00813	51		 push	 ecx
  00814	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1724 :       
; 1725 :       /******************************************************************/
; 1726 :       /*  Destroy the "Queued Byte Count" mutex.                        */
; 1727 :       /******************************************************************/
; 1728 :       
; 1729 :       OP_DestroyMutex( pPlayAudio->hmxQueuedByteCount );

  00819	8b 96 84 00 00
	00		 mov	 edx, DWORD PTR [esi+132]
  0081f	52		 push	 edx
  00820	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1730 :       
; 1731 :       /******************************************************************/
; 1732 :       /*  Destroy the "Queue Audio Busy" mutex.                         */
; 1733 :       /******************************************************************/
; 1734 :       
; 1735 :       OP_DestroyMutex( pPlayAudio->hmxQueueAudioBusy );

  00825	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  0082b	50		 push	 eax
  0082c	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1736 :       
; 1737 :       /******************************************************************/
; 1738 :       /*  Destroy the "Queue Count" mutex.                              */
; 1739 :       /******************************************************************/
; 1740 : 
; 1741 :     OP_DestroyMutex( pPlayAudio->hmxQueueCount );

  00831	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  00834	51		 push	 ecx
  00835	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1742 : 
; 1743 :     /******************************************************************/
; 1744 :     /*  Destroy the "Selected Device ID" mutex.                       */
; 1745 :     /******************************************************************/
; 1746 : 
; 1747 :     OP_DestroyMutex( pPlayAudio->hmxSelectedDeviceID );

  0083a	8b 56 78	 mov	 edx, DWORD PTR [esi+120]
  0083d	52		 push	 edx
  0083e	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1748 : 
; 1749 :     /******************************************************************/
; 1750 :     /*  Destroy the "Bytes Played" mutex.                             */
; 1751 :     /******************************************************************/
; 1752 : 
; 1753 :     OP_DestroyMutex( pPlayAudio->hmxBytesPlayed );

  00843	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00846	50		 push	 eax
  00847	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1754 : 
; 1755 :     /******************************************************************/
; 1756 :     /*  Destroy the "Audio Device State" mutex.                       */
; 1757 :     /******************************************************************/
; 1758 : 
; 1759 :     OP_DestroyMutex( pPlayAudio->hmxAudioDeviceState );

  0084c	8b 4e 70	 mov	 ecx, DWORD PTR [esi+112]
  0084f	51		 push	 ecx
  00850	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1760 : 
; 1761 :     /******************************************************************/
; 1762 :     /*  Destroy the "Reset Complete" event.                           */
; 1763 :     /******************************************************************/
; 1764 : 
; 1765 :     OP_DestroyEvent( pPlayAudio->hevResetComplete );

  00855	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00858	52		 push	 edx
  00859	e8 00 00 00 00	 call	 _OP_DestroyEvent

; 1766 : 
; 1767 :     /******************************************************************/
; 1768 :     /*  Destroy the "Queue Not Full" event.                           */
; 1769 :     /******************************************************************/
; 1770 : 
; 1771 :     OP_DestroyEvent( pPlayAudio->hevQueueNotFull );

  0085e	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00861	50		 push	 eax
  00862	e8 00 00 00 00	 call	 _OP_DestroyEvent

; 1772 : 
; 1773 :     /******************************************************************/
; 1774 :     /*  Destroy the "Timer Thread Active" event.                      */
; 1775 :     /******************************************************************/
; 1776 : 
; 1777 :     OP_DestroyEvent( pPlayAudio->hevTimerThreadActive );

  00867	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0086a	51		 push	 ecx
  0086b	e8 00 00 00 00	 call	 _OP_DestroyEvent

; 1778 : 
; 1779 :     /******************************************************************/
; 1780 :     /*  Destroy the "Audio Device Inactive" event.                    */
; 1781 :     /******************************************************************/
; 1782 : 
; 1783 :     OP_DestroyEvent( pPlayAudio->hevAudioDeviceInactive );

  00870	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00873	52		 push	 edx
  00874	e8 00 00 00 00	 call	 _OP_DestroyEvent

; 1784 : 
; 1785 :     /******************************************************************/
; 1786 :     /*  Free the play audio handle WAVEFORMATEX structure.            */
; 1787 :     /******************************************************************/
; 1788 : 
; 1789 :     if ( pPlayAudio->pWaveFormat != NULL )

  00879	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  0087f	83 c4 34	 add	 esp, 52			; 00000034H
  00882	3b c5		 cmp	 eax, ebp
  00884	5f		 pop	 edi
  00885	74 06		 je	 SHORT $L71076

; 1790 :     {
; 1791 :       LOCK_MME_CALL( FREE_SERVER_MEM( pPlayAudio->pWaveFormat ))

  00887	50		 push	 eax
  00888	ff d3		 call	 ebx
  0088a	83 c4 04	 add	 esp, 4
$L71076:

; 1792 :     }
; 1793 : 
; 1794 :     /******************************************************************/
; 1795 :     /*  Free the play audio handle.                                   */
; 1796 :     /******************************************************************/
; 1797 : 
; 1798 :     free( pPlayAudio );

  0088d	56		 push	 esi
  0088e	ff d3		 call	 ebx
  00890	83 c4 04	 add	 esp, 4

; 1799 :     
; 1800 :     mmStatus = MMSYSERR_NOERROR;

  00893	33 c0		 xor	 eax, eax
  00895	5b		 pop	 ebx
  00896	5e		 pop	 esi
  00897	5d		 pop	 ebp

; 1805 :     }
; 1806 : 
; 1807 : #ifdef MME_THREAD_SAFE
; 1808 :   
; 1809 :   /********************************************************************/
; 1810 :   /*  If this is the last instance then destroy the global mutex that */
; 1811 :   /*  is used to protect MME server calls.                            */
; 1812 :   /********************************************************************/
; 1813 :   
; 1814 :   if ( pShm_t->uiGlobalPlayAudioInstance == 0 )
; 1815 :     {
; 1816 :       OP_DestroyMutex( pShm_t->hmxGlobalMmeServer );
; 1817 :     }
; 1818 :   
; 1819 : #endif
; 1820 : 
; 1821 :   return mmStatus;
; 1822 : }

  00898	59		 pop	 ecx
  00899	c3		 ret	 0
$L71047:
  0089a	5e		 pop	 esi

; 1801 :     }
; 1802 :   else
; 1803 :     {
; 1804 :       mmStatus = MMSYSERR_INVALHANDLE;

  0089b	b8 05 00 00 00	 mov	 eax, 5
  008a0	5d		 pop	 ebp

; 1805 :     }
; 1806 : 
; 1807 : #ifdef MME_THREAD_SAFE
; 1808 :   
; 1809 :   /********************************************************************/
; 1810 :   /*  If this is the last instance then destroy the global mutex that */
; 1811 :   /*  is used to protect MME server calls.                            */
; 1812 :   /********************************************************************/
; 1813 :   
; 1814 :   if ( pShm_t->uiGlobalPlayAudioInstance == 0 )
; 1815 :     {
; 1816 :       OP_DestroyMutex( pShm_t->hmxGlobalMmeServer );
; 1817 :     }
; 1818 :   
; 1819 : #endif
; 1820 : 
; 1821 :   return mmStatus;
; 1822 : }

  008a1	59		 pop	 ecx
  008a2	c3		 ret	 0
_PA_DestroyPlayHandleEx ENDP
_TEXT	ENDS
PUBLIC	_PA_Queue
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pBuffer$ = 12
_dwLength$ = 16
_PA_Queue PROC NEAR

; 1900 : {

  008b0	55		 push	 ebp

; 1901 :   DWORD dwWrap;
; 1902 :   DWORD dwRemaining;
; 1903 :   LPPLAY_RING_T pPlayAudioRing;
; 1904 : #ifdef AUD_DEBUG  // 13may97 tek 
; 1905 :   {
; 1906 : 		  char  szTemp[256]="";
; 1907 : 		  sprintf(szTemp,"PA_Queue: size=%lu at %lu\n",
; 1908 : 			  dwLength, timeGetTime());
; 1909 : 		  //OutputDebugString(szTemp); // tek 21nov97 make less verbose
; 1910 :   }
; 1911 : #endif //AUD_DEBUG
; 1912 : 
; 1913 :   /********************************************************************/
; 1914 :   /*  Return an error if NULL handle.                                 */
; 1915 :   /********************************************************************/
; 1916 : 
; 1917 :   if ( pPlayAudio == NULL )

  008b1	8b 6c 24 08	 mov	 ebp, DWORD PTR _pPlayAudio$[esp]
  008b5	85 ed		 test	 ebp, ebp
  008b7	56		 push	 esi
  008b8	75 08		 jne	 SHORT $L71089
  008ba	5e		 pop	 esi

; 1918 :     return MMSYSERR_INVALHANDLE;

  008bb	b8 05 00 00 00	 mov	 eax, 5
  008c0	5d		 pop	 ebp

; 2065 : }

  008c1	c3		 ret	 0
$L71089:

; 1919 : 
; 1920 :   /********************************************************************/
; 1921 :   /*  If too many samples then exit with error status.                */
; 1922 :   /********************************************************************/
; 1923 : 
; 1924 :   if ( dwLength > AUDIO_BUFFER_SIZE )

  008c2	8b 74 24 14	 mov	 esi, DWORD PTR _dwLength$[esp+4]
  008c6	81 fe 00 40 02
	00		 cmp	 esi, 147456		; 00024000H
  008cc	76 08		 jbe	 SHORT $L71090
  008ce	5e		 pop	 esi

; 1925 :     return MMSYSERR_INVALPARAM;

  008cf	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  008d4	5d		 pop	 ebp

; 2065 : }

  008d5	c3		 ret	 0
$L71090:

; 1926 : 
; 1927 :   pPlayAudioRing = pPlayAudio->pPlayAudioRing;
; 1928 : 
; 1929 :   /********************************************************************/
; 1930 :   /*  Block if another thread is queueing audio or performing a       */
; 1931 :   /*  reset.                                                          */
; 1932 :   /********************************************************************/
; 1933 : 
; 1934 :   OP_LockMutex( pPlayAudio->hmxQueueAudioBusy );

  008d6	8b 85 80 00 00
	00		 mov	 eax, DWORD PTR [ebp+128]
  008dc	53		 push	 ebx
  008dd	8b 9d 98 00 00
	00		 mov	 ebx, DWORD PTR [ebp+152]
  008e3	50		 push	 eax
  008e4	e8 00 00 00 00	 call	 _OP_LockMutex

; 1935 : 
; 1936 :   /********************************************************************/
; 1937 :   /*  Wait for space in the queue before adding the new audio buffer. */
; 1938 :   /*  Block if another thread is manipulating the queue count.        */
; 1939 :   /********************************************************************/
; 1940 : 
; 1941 :   OP_LockMutex( pPlayAudio->hmxQueueCount );

  008e9	8b 4d 7c	 mov	 ecx, DWORD PTR [ebp+124]
  008ec	51		 push	 ecx
  008ed	e8 00 00 00 00	 call	 _OP_LockMutex

; 1942 : 
; 1943 :   while ( pPlayAudioRing->iQueueCount + (int)dwLength
; 1944 :             > pPlayAudioRing->iQueueLength )

  008f2	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  008f5	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  008f8	03 d6		 add	 edx, esi
  008fa	83 c4 08	 add	 esp, 8
  008fd	3b d0		 cmp	 edx, eax
  008ff	7e 4d		 jle	 SHORT $L71094
$L71093:

; 1945 :   {
; 1946 :     OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  00901	8b 45 7c	 mov	 eax, DWORD PTR [ebp+124]
  00904	50		 push	 eax
  00905	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 1947 :     OP_UnlockMutex( pPlayAudio->hmxQueueAudioBusy );

  0090a	8b 8d 80 00 00
	00		 mov	 ecx, DWORD PTR [ebp+128]
  00910	51		 push	 ecx
  00911	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 1948 : 
; 1949 :     OP_ResetEvent( pPlayAudio->hevQueueNotFull );

  00916	8b 55 18	 mov	 edx, DWORD PTR [ebp+24]
  00919	52		 push	 edx
  0091a	e8 00 00 00 00	 call	 _OP_ResetEvent

; 1950 : 
; 1951 :     OP_WaitForEvent( pPlayAudio->hevQueueNotFull, OP_INFINITE );

  0091f	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  00922	6a ff		 push	 -1
  00924	50		 push	 eax
  00925	e8 00 00 00 00	 call	 _OP_WaitForEvent

; 1952 : 
; 1953 :     OP_LockMutex( pPlayAudio->hmxQueueAudioBusy );

  0092a	8b 8d 80 00 00
	00		 mov	 ecx, DWORD PTR [ebp+128]
  00930	51		 push	 ecx
  00931	e8 00 00 00 00	 call	 _OP_LockMutex

; 1954 :     OP_LockMutex( pPlayAudio->hmxQueueCount );

  00936	8b 55 7c	 mov	 edx, DWORD PTR [ebp+124]
  00939	52		 push	 edx
  0093a	e8 00 00 00 00	 call	 _OP_LockMutex
  0093f	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00942	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  00945	03 c6		 add	 eax, esi
  00947	83 c4 1c	 add	 esp, 28			; 0000001cH
  0094a	3b c1		 cmp	 eax, ecx
  0094c	7f b3		 jg	 SHORT $L71093
$L71094:

; 1955 :   }
; 1956 : 
; 1957 :   OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  0094e	8b 4d 7c	 mov	 ecx, DWORD PTR [ebp+124]
  00951	57		 push	 edi
  00952	51		 push	 ecx
  00953	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 1958 : 
; 1959 :   /********************************************************************/
; 1960 :   /*  There is enough space in the audio queue. Test to see if the    */
; 1961 :   /*  data will wrap around the circular queue.                       */
; 1962 :   /********************************************************************/
; 1963 : 
; 1964 :   if ( pPlayAudioRing->iInputPosition + (int)dwLength
; 1965 :          > pPlayAudioRing->iQueueLength )

  00958	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  0095b	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  0095e	83 c4 04	 add	 esp, 4
  00961	8d 14 31	 lea	 edx, DWORD PTR [ecx+esi]
  00964	3b d0		 cmp	 edx, eax
  00966	7e 48		 jle	 SHORT $L71096

; 1966 :   {
; 1967 :     /******************************************************************/
; 1968 :     /*  The data will wrap around the circular queue.                 */
; 1969 :     /******************************************************************/
; 1970 : 
; 1971 :     dwRemaining =
; 1972 :       pPlayAudioRing->iQueueLength - pPlayAudioRing->iInputPosition;
; 1973 : 
; 1974 :     /******************************************************************/
; 1975 :     /*  for ( uiI = 0; uiI < dwRemaining; uiI++ )                     */
; 1976 :     /*    *pPlayAudioRing->pQueueInput++ = *pBuffer++;                */
; 1977 :     /******************************************************************/
; 1978 : 
; 1979 :     memcpy( pPlayAudioRing->pQueueInput, pBuffer, dwRemaining );

  00968	8b 74 24 18	 mov	 esi, DWORD PTR _pBuffer$[esp+12]
  0096c	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  0096f	2b c1		 sub	 eax, ecx
  00971	8b d0		 mov	 edx, eax
  00973	8b ca		 mov	 ecx, edx
  00975	c1 e9 02	 shr	 ecx, 2
  00978	f3 a5		 rep movsd
  0097a	8b c8		 mov	 ecx, eax

; 1980 : 
; 1981 :     pBuffer += dwRemaining;
; 1982 : 
; 1983 :     /******************************************************************/
; 1984 :     /*  Reset to the start of the audio queue.                        */
; 1985 :     /******************************************************************/
; 1986 : 
; 1987 :     pPlayAudioRing->pQueueInput = pPlayAudioRing->pQueueStart;
; 1988 : 
; 1989 :     /******************************************************************/
; 1990 :     /*  for ( uiI = dwRemaining; uiI < dwLength; uiI++ )              */
; 1991 :     /*    *pPlayAudioRing->pQueueInput++ = *pBuffer++;                */
; 1992 :     /******************************************************************/
; 1993 : 
; 1994 :     dwWrap = dwLength - dwRemaining;

  0097c	8b 44 24 1c	 mov	 eax, DWORD PTR _dwLength$[esp+12]
  00980	83 e1 03	 and	 ecx, 3
  00983	2b c2		 sub	 eax, edx
  00985	f3 a4		 rep movsb
  00987	8b 74 24 18	 mov	 esi, DWORD PTR _pBuffer$[esp+12]
  0098b	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]

; 1995 : 
; 1996 :     memcpy( pPlayAudioRing->pQueueInput, pBuffer, dwWrap );

  0098e	8b c8		 mov	 ecx, eax
  00990	03 f2		 add	 esi, edx
  00992	8b d1		 mov	 edx, ecx
  00994	89 7b 08	 mov	 DWORD PTR [ebx+8], edi
  00997	c1 e9 02	 shr	 ecx, 2
  0099a	f3 a5		 rep movsd
  0099c	8b ca		 mov	 ecx, edx
  0099e	83 e1 03	 and	 ecx, 3
  009a1	f3 a4		 rep movsb

; 1997 : 
; 1998 :     pPlayAudioRing->pQueueInput += dwWrap;

  009a3	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 1999 :     pPlayAudioRing->iInputPosition = (int)dwWrap;

  009a6	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  009a9	03 c8		 add	 ecx, eax
  009ab	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx

; 2000 :   }
; 2001 :   else

  009ae	eb 2b		 jmp	 SHORT $L71098
$L71096:

; 2002 :   {
; 2003 :     /******************************************************************/
; 2004 :     /*  The data will NOT wrap around the circular queue.             */
; 2005 :     /******************************************************************/
; 2006 :     /******************************************************************/
; 2007 :     /*  for ( uiI = 0; uiI < dwLength; uiI++ )                        */
; 2008 :     /*    *pPlayAudioRing->pQueueInput++ = *pBuffer++;                */
; 2009 :     /******************************************************************/
; 2010 : 
; 2011 :     memcpy( pPlayAudioRing->pQueueInput, pBuffer, dwLength );

  009b0	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  009b3	8b ce		 mov	 ecx, esi
  009b5	8b 74 24 18	 mov	 esi, DWORD PTR _pBuffer$[esp+12]
  009b9	8b c1		 mov	 eax, ecx
  009bb	c1 e9 02	 shr	 ecx, 2
  009be	f3 a5		 rep movsd
  009c0	8b c8		 mov	 ecx, eax

; 2012 : 
; 2013 :     pPlayAudioRing->pQueueInput += dwLength;

  009c2	8b 44 24 1c	 mov	 eax, DWORD PTR _dwLength$[esp+12]
  009c6	83 e1 03	 and	 ecx, 3
  009c9	f3 a4		 rep movsb
  009cb	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]

; 2014 :     pPlayAudioRing->iInputPosition += (int)dwLength;

  009ce	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  009d1	03 d0		 add	 edx, eax
  009d3	03 c8		 add	 ecx, eax
  009d5	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  009d8	89 4b 10	 mov	 DWORD PTR [ebx+16], ecx
$L71098:

; 2015 :   }
; 2016 : 
; 2017 :   /********************************************************************/
; 2018 :   /*  Atomically update the audio queue count.                        */
; 2019 :   /********************************************************************/
; 2020 : 
; 2021 :   OP_LockMutex( pPlayAudio->hmxQueueCount );

  009db	8b 4d 7c	 mov	 ecx, DWORD PTR [ebp+124]
  009de	51		 push	 ecx
  009df	e8 00 00 00 00	 call	 _OP_LockMutex

; 2022 :   pPlayAudioRing->iQueueCount += (int)dwLength;

  009e4	8b 74 24 20	 mov	 esi, DWORD PTR _dwLength$[esp+16]
  009e8	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  009eb	03 d6		 add	 edx, esi
  009ed	89 53 18	 mov	 DWORD PTR [ebx+24], edx

; 2023 :   OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  009f0	8b 55 7c	 mov	 edx, DWORD PTR [ebp+124]
  009f3	52		 push	 edx
  009f4	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 2024 : 
; 2025 :   /********************************************************************/
; 2026 :   /*  Atomically update the queued byte count.                        */
; 2027 :   /*  If audio is not playing then activate the timer thread.         */
; 2028 :   /********************************************************************/
; 2029 : 
; 2030 :   OP_LockMutex( pPlayAudio->hmxQueuedByteCount );

  009f9	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR [ebp+132]
  009ff	50		 push	 eax
  00a00	e8 00 00 00 00	 call	 _OP_LockMutex

; 2031 : 
; 2032 :   pPlayAudio->dwQueuedByteCount += dwLength;

  00a05	8b 4d 4c	 mov	 ecx, DWORD PTR [ebp+76]

; 2033 : 
; 2034 :   if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )

  00a08	8b 45 34	 mov	 eax, DWORD PTR [ebp+52]
  00a0b	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a0e	03 ce		 add	 ecx, esi
  00a10	85 c0		 test	 eax, eax
  00a12	89 4d 4c	 mov	 DWORD PTR [ebp+76], ecx
  00a15	5f		 pop	 edi
  00a16	75 0c		 jne	 SHORT $L71101

; 2035 :   {
; 2036 :     OP_SetEvent( pPlayAudio->hevTimerThreadActive );

  00a18	8b 4d 14	 mov	 ecx, DWORD PTR [ebp+20]
  00a1b	51		 push	 ecx
  00a1c	e8 00 00 00 00	 call	 _OP_SetEvent
  00a21	83 c4 04	 add	 esp, 4
$L71101:

; 2037 :   }
; 2038 : 
; 2039 :   OP_UnlockMutex( pPlayAudio->hmxQueuedByteCount );

  00a24	8b 95 84 00 00
	00		 mov	 edx, DWORD PTR [ebp+132]
  00a2a	52		 push	 edx
  00a2b	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 2040 : 
; 2041 :   /********************************************************************/
; 2042 :   /*  If the audio is not playing and there are enough audio samples  */
; 2043 :   /*  and the system is not paused then start playing audio. Note     */
; 2044 :   /*  that the following tests do NOT have to be performed in a       */
; 2045 :   /*  thread-safe manner.                                             */
; 2046 :   /********************************************************************/
; 2047 : 
; 2048 :   if (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )
; 2049 :     && ( pPlayAudioRing->iQueueCount
; 2050 : 	>= (int)pPlayAudio->uiMinimumStartupBytes )
; 2051 :    && ( ! pPlayAudio->bPaused ))

  00a30	8b 45 34	 mov	 eax, DWORD PTR [ebp+52]
  00a33	83 c4 04	 add	 esp, 4
  00a36	85 c0		 test	 eax, eax
  00a38	75 1e		 jne	 SHORT $L71103
  00a3a	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00a3d	8b 4d 2c	 mov	 ecx, DWORD PTR [ebp+44]
  00a40	3b c1		 cmp	 eax, ecx
  00a42	7c 14		 jl	 SHORT $L71103
  00a44	8b 45 58	 mov	 eax, DWORD PTR [ebp+88]
  00a47	85 c0		 test	 eax, eax
  00a49	75 0d		 jne	 SHORT $L71103

; 2052 :   {
; 2053 :     SendPlayAudioMessage( pPlayAudio,
; 2054 :                           ID_Open_Wave_Output_Device,
; 2055 :                           0L );

  00a4b	6a 00		 push	 0
  00a4d	6a 00		 push	 0
  00a4f	55		 push	 ebp
  00a50	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00a55	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71103:

; 2056 :   }
; 2057 : 
; 2058 :   /********************************************************************/
; 2059 :   /*  Release the PA_Queue() function for use in another thread.      */
; 2060 :   /********************************************************************/
; 2061 : 
; 2062 :   OP_UnlockMutex( pPlayAudio->hmxQueueAudioBusy );

  00a58	8b 8d 80 00 00
	00		 mov	 ecx, DWORD PTR [ebp+128]
  00a5e	51		 push	 ecx
  00a5f	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00a64	83 c4 04	 add	 esp, 4

; 2063 : 
; 2064 :   return MMSYSERR_NOERROR;

  00a67	33 c0		 xor	 eax, eax
  00a69	5b		 pop	 ebx
  00a6a	5e		 pop	 esi
  00a6b	5d		 pop	 ebp

; 2065 : }

  00a6c	c3		 ret	 0
_PA_Queue ENDP
_pPlayAudio$ = 8
_PA_Reset PROC NEAR

; 2095 : {

  00a70	56		 push	 esi

; 2096 :   MMRESULT mmStatus;
; 2097 : #ifdef AUD_DEBUG //tek 22may97
; 2098 :   {
; 2099 :     char szTemp[256]="";
; 2100 :     sprintf(szTemp,"PA_Reset: at %ld\n",timeGetTime());
; 2101 :     OutputDebugString(szTemp);
; 2102 :   }
; 2103 : #endif //AUD_DEBUG
; 2104 :   
; 2105 :   /********************************************************************/
; 2106 :   /*  Return an error if NULL handle.                                 */
; 2107 :   /********************************************************************/
; 2108 :   
; 2109 :   if ( pPlayAudio == NULL )

  00a71	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  00a75	85 f6		 test	 esi, esi
  00a77	75 07		 jne	 SHORT $L71109

; 2110 :     return MMSYSERR_INVALPARAM;

  00a79	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00a7e	5e		 pop	 esi

; 2175 : }

  00a7f	c3		 ret	 0
$L71109:

; 2111 : 
; 2112 :   /********************************************************************/
; 2113 :   /*  Block if another thread is queueing audio.                      */
; 2114 :   /********************************************************************/
; 2115 : 
; 2116 :   OP_LockMutex( pPlayAudio->hmxQueueAudioBusy );

  00a80	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  00a86	57		 push	 edi
  00a87	50		 push	 eax
  00a88	e8 00 00 00 00	 call	 _OP_LockMutex

; 2117 : 
; 2118 :   /********************************************************************/
; 2119 :   /*  Reset the "Reset Complete" event.                               */
; 2120 :   /********************************************************************/
; 2121 : 
; 2122 :   OP_ResetEvent( pPlayAudio->hevResetComplete );

  00a8d	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00a90	51		 push	 ecx
  00a91	e8 00 00 00 00	 call	 _OP_ResetEvent

; 2123 : 
; 2124 :   /********************************************************************/
; 2125 :   /*  Cancel all audio output and initialize the audio queue.         */
; 2126 :   /********************************************************************/
; 2127 : 
; 2128 :   mmStatus = (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2129 : 	  ID_Reset_Audio,
; 2130 : 	  0L );

  00a96	6a 00		 push	 0
  00a98	6a 01		 push	 1
  00a9a	56		 push	 esi
  00a9b	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00aa0	8b f8		 mov	 edi, eax

; 2131 :   // tek 22jan99 if the audio device is still busy (we really don't
; 2132 :   // care if there is another writer of the status word, because we're
; 2133 :   // not gonna write it..) then we need to send the reset again so that 
; 2134 :   // the reset code can do cleanup after the WOM_DONE messages are processed.
; 2135 :   if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )

  00aa2	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00aa5	83 c4 14	 add	 esp, 20			; 00000014H
  00aa8	83 f8 02	 cmp	 eax, 2
  00aab	75 0d		 jne	 SHORT $L71111

; 2136 :   {  
; 2137 : #ifdef AUD_DEBUG
; 2138 : 	  {
; 2139 : 		  char szTemp[256];
; 2140 : 		  sprintf(szTemp,"PA_Reset resending ID_Reset_Audio at %ld\n",
; 2141 : 			  timeGetTime());
; 2142 : 		  OutputDebugString(szTemp);
; 2143 : 	  }
; 2144 : #endif //AUD_DEBUG
; 2145 : 	  SendPlayAudioMessage( pPlayAudio,
; 2146 : 		  ID_Reset_Audio,
; 2147 : 		  0L );

  00aad	6a 00		 push	 0
  00aaf	6a 01		 push	 1
  00ab1	56		 push	 esi
  00ab2	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00ab7	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71111:

; 2148 :   }
; 2149 : 
; 2150 :   /********************************************************************/
; 2151 :   /*  If audio is playing then wait for the reset to complete.        */
; 2152 :   /********************************************************************/
; 2153 : 
; 2154 :   OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  00aba	8b 56 70	 mov	 edx, DWORD PTR [esi+112]
  00abd	52		 push	 edx
  00abe	e8 00 00 00 00	 call	 _OP_LockMutex

; 2155 : 
; 2156 :   if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )

  00ac3	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00ac6	83 c4 04	 add	 esp, 4
  00ac9	83 f8 02	 cmp	 eax, 2
  00acc	75 2e		 jne	 SHORT $L71112

; 2157 :   {
; 2158 :     OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  00ace	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  00ad1	50		 push	 eax
  00ad2	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 2159 : 
; 2160 :     OP_WaitForEvent( pPlayAudio->hevResetComplete,
; 2161 :                      MAXIMUM_RESET_WAIT_IN_MSEC );

  00ad7	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00ada	68 88 13 00 00	 push	 5000			; 00001388H
  00adf	51		 push	 ecx
  00ae0	e8 00 00 00 00	 call	 _OP_WaitForEvent

; 2166 :   }
; 2167 : 
; 2168 :   /********************************************************************/
; 2169 :   /*  Release the audio queue.                                        */
; 2170 :   /********************************************************************/
; 2171 : 
; 2172 :   OP_UnlockMutex( pPlayAudio->hmxQueueAudioBusy );

  00ae5	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  00aeb	83 c4 0c	 add	 esp, 12			; 0000000cH
  00aee	50		 push	 eax
  00aef	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00af4	83 c4 04	 add	 esp, 4

; 2173 : 
; 2174 :   return mmStatus;

  00af7	8b c7		 mov	 eax, edi
  00af9	5f		 pop	 edi
  00afa	5e		 pop	 esi

; 2175 : }

  00afb	c3		 ret	 0
$L71112:

; 2162 :   }
; 2163 :   else
; 2164 :   {
; 2165 :     OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  00afc	8b 56 70	 mov	 edx, DWORD PTR [esi+112]
  00aff	52		 push	 edx
  00b00	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 2166 :   }
; 2167 : 
; 2168 :   /********************************************************************/
; 2169 :   /*  Release the audio queue.                                        */
; 2170 :   /********************************************************************/
; 2171 : 
; 2172 :   OP_UnlockMutex( pPlayAudio->hmxQueueAudioBusy );

  00b05	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  00b0b	83 c4 04	 add	 esp, 4
  00b0e	50		 push	 eax
  00b0f	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00b14	83 c4 04	 add	 esp, 4

; 2173 : 
; 2174 :   return mmStatus;

  00b17	8b c7		 mov	 eax, edi
  00b19	5f		 pop	 edi
  00b1a	5e		 pop	 esi

; 2175 : }

  00b1b	c3		 ret	 0
_PA_Reset ENDP
_TEXT	ENDS
PUBLIC	_PA_Pause
_TEXT	SEGMENT
_pPlayAudio$ = 8
_PA_Pause PROC NEAR

; 2203 :   /********************************************************************/
; 2204 :   /*  Return an error if NULL handle.                                 */
; 2205 :   /********************************************************************/
; 2206 : 
; 2207 :   if ( pPlayAudio == NULL )

  00b20	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  00b24	85 c0		 test	 eax, eax
  00b26	75 06		 jne	 SHORT $L71118

; 2208 :     return MMSYSERR_INVALHANDLE;

  00b28	b8 05 00 00 00	 mov	 eax, 5

; 2217 : }

  00b2d	c3		 ret	 0
$L71118:

; 2209 : 
; 2210 :   /********************************************************************/
; 2211 :   /*  Pause the wave output device.                                   */
; 2212 :   /********************************************************************/
; 2213 : 
; 2214 :   return (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2215 :                                          ID_Pause_Audio,
; 2216 :                                          0L );

  00b2e	6a 00		 push	 0
  00b30	6a 02		 push	 2
  00b32	50		 push	 eax
  00b33	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00b38	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2217 : }

  00b3b	c3		 ret	 0
_PA_Pause ENDP
_TEXT	ENDS
PUBLIC	_PA_Resume
_TEXT	SEGMENT
_pPlayAudio$ = 8
_PA_Resume PROC NEAR

; 2244 : {

  00b40	56		 push	 esi

; 2245 :   MMRESULT mmStatus;
; 2246 : 
; 2247 :   /********************************************************************/
; 2248 :   /*  Return an error if NULL handle.                                 */
; 2249 :   /********************************************************************/
; 2250 : 
; 2251 :   if ( pPlayAudio == NULL )

  00b41	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  00b45	85 f6		 test	 esi, esi
  00b47	75 07		 jne	 SHORT $L71125

; 2252 :     return MMSYSERR_INVALPARAM;

  00b49	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00b4e	5e		 pop	 esi

; 2278 : }

  00b4f	c3		 ret	 0
$L71125:
  00b50	57		 push	 edi

; 2253 : 
; 2254 :   /********************************************************************/
; 2255 :   /*  Resume paused audio output.                                     */
; 2256 :   /********************************************************************/
; 2257 : 
; 2258 :   mmStatus =  (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2259 :                                               ID_Resume_Audio,
; 2260 :                                               0L );

  00b51	6a 00		 push	 0
  00b53	6a 03		 push	 3
  00b55	56		 push	 esi
  00b56	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00b5b	8b f8		 mov	 edi, eax

; 2261 : 
; 2262 :   /********************************************************************/
; 2263 :   /*  If the audio is not playing and there are enough audio samples  */
; 2264 :   /*  then start playing audio. Note that the following test do NOT   */
; 2265 :   /*  have to be performed in a thread safe manner.                   */
; 2266 :   /********************************************************************/
; 2267 : 
; 2268 :   if (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )
; 2269 :    && ( pPlayAudio->pPlayAudioRing->iQueueCount
; 2270 :           >= (int)pPlayAudio->uiMinimumStartupBytes ))

  00b5d	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00b60	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b63	85 c0		 test	 eax, eax
  00b65	75 1d		 jne	 SHORT $L71128
  00b67	8b 86 98 00 00
	00		 mov	 eax, DWORD PTR [esi+152]
  00b6d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00b70	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00b73	3b c8		 cmp	 ecx, eax
  00b75	7c 0d		 jl	 SHORT $L71128

; 2271 :   {
; 2272 :     SendPlayAudioMessage( pPlayAudio,
; 2273 :                           ID_Open_Wave_Output_Device,
; 2274 :                           0L );

  00b77	6a 00		 push	 0
  00b79	6a 00		 push	 0
  00b7b	56		 push	 esi
  00b7c	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00b81	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71128:

; 2275 :   }
; 2276 : 
; 2277 :   return mmStatus;

  00b84	8b c7		 mov	 eax, edi
  00b86	5f		 pop	 edi
  00b87	5e		 pop	 esi

; 2278 : }

  00b88	c3		 ret	 0
_PA_Resume ENDP
_TEXT	ENDS
PUBLIC	_PA_GetFormat
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pWaveFormat$ = 12
_PA_GetFormat PROC NEAR

; 2312 :   /********************************************************************/
; 2313 :   /*  Return an error if NULL handle.                                 */
; 2314 :   /********************************************************************/
; 2315 : 
; 2316 :   if ( pPlayAudio == NULL )

  00b90	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  00b94	85 c0		 test	 eax, eax
  00b96	75 06		 jne	 SHORT $L71135

; 2317 :     return MMSYSERR_INVALHANDLE;

  00b98	b8 05 00 00 00	 mov	 eax, 5

; 2326 : }

  00b9d	c3		 ret	 0
$L71135:

; 2318 : 
; 2319 :   /********************************************************************/
; 2320 :   /*  Get the audio format.                                           */
; 2321 :   /********************************************************************/
; 2322 : 
; 2323 :   return (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2324 :                                          ID_Get_Audio_Format,
; 2325 :                                          (ATYPE_T)pWaveFormat );

  00b9e	8b 4c 24 08	 mov	 ecx, DWORD PTR _pWaveFormat$[esp-4]
  00ba2	51		 push	 ecx
  00ba3	6a 05		 push	 5
  00ba5	50		 push	 eax
  00ba6	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00bab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2326 : }

  00bae	c3		 ret	 0
_PA_GetFormat ENDP
_pPlayAudio$ = 8
_pWaveFormat$ = 12
_PA_SetFormat PROC NEAR

; 2362 : {

  00bb0	53		 push	 ebx
  00bb1	55		 push	 ebp

; 2363 :   MMRESULT mmStatus;
; 2364 :   DWORD dwWaveFormatSize;
; 2365 :   LPWAVEFORMATEX pWaveFormatTemp;
; 2366 : #ifdef AUD_DEBUG
; 2367 :   OutputDebugString("PA_SetFormat()\n");
; 2368 : #endif
; 2369 :   /********************************************************************/
; 2370 :   /*  Return an error if NULL handle.                                 */
; 2371 :   /********************************************************************/
; 2372 : 
; 2373 :   if ( pPlayAudio == NULL )

  00bb2	8b 6c 24 0c	 mov	 ebp, DWORD PTR _pPlayAudio$[esp+4]
  00bb6	56		 push	 esi
  00bb7	85 ed		 test	 ebp, ebp
  00bb9	57		 push	 edi
  00bba	75 0a		 jne	 SHORT $L71147
  00bbc	5f		 pop	 edi
  00bbd	5e		 pop	 esi
  00bbe	5d		 pop	 ebp

; 2374 :     return MMSYSERR_INVALHANDLE;

  00bbf	b8 05 00 00 00	 mov	 eax, 5
  00bc4	5b		 pop	 ebx

; 2432 : }

  00bc5	c3		 ret	 0
$L71147:

; 2375 : 
; 2376 :   /********************************************************************/
; 2377 :   /*  Allocate shared memory for the MME server.                      */
; 2378 :   /*  First Get the size of the WAVEFORMATEX structure.               */
; 2379 :   /********************************************************************/
; 2380 : 
; 2381 :   dwWaveFormatSize = GetWaveFormatSize( pWaveFormat );

  00bc6	8b 74 24 18	 mov	 esi, DWORD PTR _pWaveFormat$[esp+12]
  00bca	56		 push	 esi
  00bcb	e8 00 00 00 00	 call	 _GetWaveFormatSize
  00bd0	8b f8		 mov	 edi, eax

; 2382 : 
; 2383 :   /********************************************************************/
; 2384 :   /*  Allocate memory for the play audio handle WAVEFORMATEX          */
; 2385 :   /*  structure.                                                      */
; 2386 :   /********************************************************************/
; 2387 : 
; 2388 :   LOCK_MME_CALL(
; 2389 :     pWaveFormatTemp =
; 2390 :       (LPWAVEFORMATEX)ALLOCATE_SERVER_MEM( dwWaveFormatSize ))

  00bd2	57		 push	 edi
  00bd3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00bd9	8b d8		 mov	 ebx, eax
  00bdb	83 c4 08	 add	 esp, 8

; 2391 : 
; 2392 :   if ( pWaveFormatTemp == NULL )

  00bde	85 db		 test	 ebx, ebx
  00be0	75 0a		 jne	 SHORT $L71150
  00be2	5f		 pop	 edi
  00be3	5e		 pop	 esi
  00be4	5d		 pop	 ebp

; 2393 :   {
; 2394 :     return MMSYSERR_NOMEM;

  00be5	b8 07 00 00 00	 mov	 eax, 7
  00bea	5b		 pop	 ebx

; 2432 : }

  00beb	c3		 ret	 0
$L71150:

; 2395 :   }
; 2396 : 
; 2397 :   /********************************************************************/
; 2398 :   /*  Copy the WAVEFORMATEX structure passed to this function to      */
; 2399 :   /*  audio handles WAVEFORMATEX structure.                           */
; 2400 :   /********************************************************************/
; 2401 : 
; 2402 :   memcpy( pWaveFormatTemp,
; 2403 :           pWaveFormat,
; 2404 :           dwWaveFormatSize );

  00bec	8b cf		 mov	 ecx, edi
  00bee	8b fb		 mov	 edi, ebx
  00bf0	8b c1		 mov	 eax, ecx

; 2405 : 
; 2406 :   /********************************************************************/
; 2407 :   /*  Set the audio format.                                           */
; 2408 :   /********************************************************************/
; 2409 : #ifdef AUD_DEBUG
; 2410 :   OutputDebugString("Calling  SendPlayAudioMessage()\n");
; 2411 : #endif
; 2412 :   mmStatus = SendPlayAudioMessage( pPlayAudio,
; 2413 :                                    ID_Set_Audio_Format,
; 2414 :                                    (ATYPE_T)pWaveFormatTemp );

  00bf2	53		 push	 ebx
  00bf3	c1 e9 02	 shr	 ecx, 2
  00bf6	f3 a5		 rep movsd
  00bf8	8b c8		 mov	 ecx, eax
  00bfa	6a 04		 push	 4
  00bfc	83 e1 03	 and	 ecx, 3
  00bff	55		 push	 ebp
  00c00	f3 a4		 rep movsb
  00c02	e8 00 00 00 00	 call	 _SendPlayAudioMessage

; 2415 : 
; 2416 :   /******************************************************************/
; 2417 :   /*  Free the temporary WAVEFORMATEX structure.                    */
; 2418 :   /******************************************************************/
; 2419 : 
; 2420 :   LOCK_MME_CALL( FREE_SERVER_MEM( pWaveFormatTemp ))

  00c07	53		 push	 ebx
  00c08	8b f0		 mov	 esi, eax
  00c0a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00c10	83 c4 10	 add	 esp, 16			; 00000010H

; 2421 : #ifdef AUD_DEBUG
; 2422 :   {
; 2423 : #include <stdio.h>
; 2424 : 		  char  szTemp[256]="";
; 2425 : 		  sprintf(szTemp,"PA_SetFormat: SendPlayAudioMessage status=%lu (%08lx)\n",
; 2426 : 			  mmStatus, mmStatus);
; 2427 : 		  OutputDebugString(szTemp);
; 2428 :   }
; 2429 : #endif //AUD_DEBUG
; 2430 : 
; 2431 :   return mmStatus;

  00c13	8b c6		 mov	 eax, esi
  00c15	5f		 pop	 edi
  00c16	5e		 pop	 esi
  00c17	5d		 pop	 ebp
  00c18	5b		 pop	 ebx

; 2432 : }

  00c19	c3		 ret	 0
_PA_SetFormat ENDP
_TEXT	ENDS
PUBLIC	_PA_GetVolume
EXTRN	__imp__waveOutGetVolume@8:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pdwVolume$ = 12
_PA_GetVolume PROC NEAR

; 2464 :   LPDWORD pdwVol;
; 2465 :   MMRESULT mmStatus;
; 2466 : 
; 2467 :   // tek 12nov97 bats517 change this to just do it, rather than
; 2468 :   // passing messages around..
; 2469 :   /********************************************************************/
; 2470 :   /*  Return an error if NULL handle.                                 */
; 2471 :   /********************************************************************/
; 2472 : 
; 2473 :   if ( pPlayAudio == NULL )

  00c20	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  00c24	85 c0		 test	 eax, eax
  00c26	75 06		 jne	 SHORT $L71160

; 2474 :     return MMSYSERR_INVALHANDLE;

  00c28	b8 05 00 00 00	 mov	 eax, 5

; 2479 : #else // not win32 or linux; do it the slow way.
; 2480 :   /********************************************************************/
; 2481 :   /*  Allocate memory to return the volume setting.                   */
; 2482 :   /********************************************************************/
; 2483 : 
; 2484 :   LOCK_MME_CALL( pdwVol = (LPDWORD)ALLOCATE_SERVER_MEM(sizeof(DWORD)))
; 2485 : 
; 2486 :   if ( pdwVol == NULL )
; 2487 :   {
; 2488 :     return MMSYSERR_NOMEM;
; 2489 :   }
; 2490 : 
; 2491 :   /********************************************************************/
; 2492 :   /*  Get the wave output device volume.                              */
; 2493 :   /********************************************************************/
; 2494 : 
; 2495 :   mmStatus = (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2496 :                                              ID_Get_Audio_Volume,
; 2497 :                                              (ATYPE_T)pdwVol );
; 2498 :   *pdwVolume = *pdwVol;
; 2499 : 
; 2500 :   /********************************************************************/
; 2501 :   /*  Free the memory used to return the volume setting.              */
; 2502 :   /********************************************************************/
; 2503 : 
; 2504 :   LOCK_MME_CALL( FREE_SERVER_MEM( pdwVol ))
; 2505 : #endif //_WIN32
; 2506 : 
; 2507 :   return mmStatus;
; 2508 : }

  00c2d	c3		 ret	 0
$L71160:

; 2475 : 
; 2476 : #if defined _WIN32 || defined __linux__
; 2477 : 
; 2478 :   mmStatus = waveOutGetVolume((HWAVEOUT)pPlayAudio->uiSelectedDeviceID,pdwVolume);

  00c2e	8b 4c 24 08	 mov	 ecx, DWORD PTR _pdwVolume$[esp-4]
  00c32	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  00c35	51		 push	 ecx
  00c36	52		 push	 edx
  00c37	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetVolume@8

; 2479 : #else // not win32 or linux; do it the slow way.
; 2480 :   /********************************************************************/
; 2481 :   /*  Allocate memory to return the volume setting.                   */
; 2482 :   /********************************************************************/
; 2483 : 
; 2484 :   LOCK_MME_CALL( pdwVol = (LPDWORD)ALLOCATE_SERVER_MEM(sizeof(DWORD)))
; 2485 : 
; 2486 :   if ( pdwVol == NULL )
; 2487 :   {
; 2488 :     return MMSYSERR_NOMEM;
; 2489 :   }
; 2490 : 
; 2491 :   /********************************************************************/
; 2492 :   /*  Get the wave output device volume.                              */
; 2493 :   /********************************************************************/
; 2494 : 
; 2495 :   mmStatus = (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2496 :                                              ID_Get_Audio_Volume,
; 2497 :                                              (ATYPE_T)pdwVol );
; 2498 :   *pdwVolume = *pdwVol;
; 2499 : 
; 2500 :   /********************************************************************/
; 2501 :   /*  Free the memory used to return the volume setting.              */
; 2502 :   /********************************************************************/
; 2503 : 
; 2504 :   LOCK_MME_CALL( FREE_SERVER_MEM( pdwVol ))
; 2505 : #endif //_WIN32
; 2506 : 
; 2507 :   return mmStatus;
; 2508 : }

  00c3d	c3		 ret	 0
_PA_GetVolume ENDP
_TEXT	ENDS
PUBLIC	_PA_SetVolume
EXTRN	__imp__waveOutSetVolume@8:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_dwVolume$ = 12
_PA_SetVolume PROC NEAR

; 2538 : 
; 2539 :    // tek 12nov97	bats517 change to just do it rather than pass messages
; 2540 : 
; 2541 :   /********************************************************************/
; 2542 :   /*  Return an error if NULL handle.                                 */
; 2543 :   /********************************************************************/
; 2544 : 
; 2545 :   if ( pPlayAudio == NULL )

  00c40	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  00c44	85 c0		 test	 eax, eax
  00c46	75 06		 jne	 SHORT $L71168

; 2546 :     return MMSYSERR_INVALHANDLE;

  00c48	b8 05 00 00 00	 mov	 eax, 5

; 2553 : #else // not win32
; 2554 :   return (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2555 :                                          ID_Set_Audio_Volume,
; 2556 :                                          (ATYPE_T)dwVolume );
; 2557 : #endif //_WIN32
; 2558 : }

  00c4d	c3		 ret	 0
$L71168:

; 2547 : 
; 2548 :   /********************************************************************/
; 2549 :   /*  Set the wave output device volume.                              */
; 2550 :   /********************************************************************/
; 2551 : #ifdef _WIN32
; 2552 :   return waveOutSetVolume((HWAVEOUT)pPlayAudio->uiSelectedDeviceID,dwVolume);

  00c4e	8b 4c 24 08	 mov	 ecx, DWORD PTR _dwVolume$[esp-4]
  00c52	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  00c55	51		 push	 ecx
  00c56	52		 push	 edx
  00c57	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutSetVolume@8

; 2553 : #else // not win32
; 2554 :   return (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2555 :                                          ID_Set_Audio_Volume,
; 2556 :                                          (ATYPE_T)dwVolume );
; 2557 : #endif //_WIN32
; 2558 : }

  00c5d	c3		 ret	 0
_PA_SetVolume ENDP
_TEXT	ENDS
PUBLIC	_PA_SynchronizationMark
_TEXT	SEGMENT
_pPlayAudio$ = 8
_aTag$ = 12
_PA_SynchronizationMark PROC NEAR

; 2594 :   /********************************************************************/
; 2595 :   /*  Return an error if NULL handle.                                 */
; 2596 :   /********************************************************************/
; 2597 : 
; 2598 :   if ( pPlayAudio == NULL )

  00c60	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  00c64	85 c0		 test	 eax, eax
  00c66	75 06		 jne	 SHORT $L71176

; 2599 :     return MMSYSERR_INVALHANDLE;

  00c68	b8 05 00 00 00	 mov	 eax, 5

; 2608 : }

  00c6d	c3		 ret	 0
$L71176:

; 2600 : 
; 2601 :   /********************************************************************/
; 2602 :   /*  Set the wave output Synchronization Mark.                       */
; 2603 :   /********************************************************************/
; 2604 : 
; 2605 :   return (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2606 :                                          ID_Synchronization_Mark,
; 2607 :                                          aTag );

  00c6e	8b 4c 24 08	 mov	 ecx, DWORD PTR _aTag$[esp-4]
  00c72	51		 push	 ecx
  00c73	6a 08		 push	 8
  00c75	50		 push	 eax
  00c76	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00c7b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2608 : }

  00c7e	c3		 ret	 0
_PA_SynchronizationMark ENDP
_TEXT	ENDS
PUBLIC	_PA_GetPosition
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pdwPosition$ = 12
_bFast$ = 16
_PA_GetPosition PROC NEAR

; 2663 : {

  00c80	53		 push	 ebx
  00c81	56		 push	 esi
  00c82	57		 push	 edi

; 2664 :   LPDWORD pdwPos;
; 2665 :   MMRESULT mmStatus;
; 2666 : 
; 2667 :   /********************************************************************/
; 2668 :   /*  Return an error if NULL handle.                                 */
; 2669 :   /********************************************************************/
; 2670 : 
; 2671 :   if ( pPlayAudio == NULL )

  00c83	8b 7c 24 10	 mov	 edi, DWORD PTR _pPlayAudio$[esp+8]
  00c87	85 ff		 test	 edi, edi
  00c89	75 09		 jne	 SHORT $L71188
  00c8b	5f		 pop	 edi
  00c8c	5e		 pop	 esi

; 2672 :     return MMSYSERR_INVALHANDLE;

  00c8d	b8 05 00 00 00	 mov	 eax, 5
  00c92	5b		 pop	 ebx

; 2721 : }

  00c93	c3		 ret	 0
$L71188:

; 2673 : 
; 2674 :   /********************************************************************/
; 2675 :   /*  Either get a quick coarse position or a slower but more         */
; 2676 :   /*  accurate position.                                              */
; 2677 :   /********************************************************************/
; 2678 : 
; 2679 :   if ( bFast )

  00c94	8b 44 24 18	 mov	 eax, DWORD PTR _bFast$[esp+8]
  00c98	85 c0		 test	 eax, eax
  00c9a	74 26		 je	 SHORT $L71189

; 2680 :   {
; 2681 :     /******************************************************************/
; 2682 :     /*  Get the coarse wave output position.                          */
; 2683 :     /******************************************************************/
; 2684 : 
; 2685 :     mmStatus = MMSYSERR_NOERROR;
; 2686 : 
; 2687 :     OP_LockMutex( pPlayAudio->hmxBytesPlayed );

  00c9c	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  00c9f	33 db		 xor	 ebx, ebx
  00ca1	50		 push	 eax
  00ca2	e8 00 00 00 00	 call	 _OP_LockMutex

; 2688 :     *pdwPosition = pPlayAudio->dwBytesPlayed;

  00ca7	8b 54 24 18	 mov	 edx, DWORD PTR _pdwPosition$[esp+12]
  00cab	8b 4f 44	 mov	 ecx, DWORD PTR [edi+68]
  00cae	89 0a		 mov	 DWORD PTR [edx], ecx

; 2689 :     OP_UnlockMutex( pPlayAudio->hmxBytesPlayed );

  00cb0	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  00cb3	50		 push	 eax
  00cb4	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00cb9	83 c4 08	 add	 esp, 8

; 2718 :   }
; 2719 : 
; 2720 :   return mmStatus;

  00cbc	8b c3		 mov	 eax, ebx
  00cbe	5f		 pop	 edi
  00cbf	5e		 pop	 esi
  00cc0	5b		 pop	 ebx

; 2721 : }

  00cc1	c3		 ret	 0
$L71189:

; 2690 :   }
; 2691 :   else
; 2692 :   {
; 2693 :     /******************************************************************/
; 2694 :     /*  Allocate memory to return the audio position.                 */
; 2695 :     /******************************************************************/
; 2696 : 
; 2697 :     pdwPos = (LPDWORD)malloc(sizeof(DWORD));

  00cc2	6a 04		 push	 4
  00cc4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00cca	8b f0		 mov	 esi, eax
  00ccc	83 c4 04	 add	 esp, 4

; 2698 : 
; 2699 :     if ( pdwPos == NULL )

  00ccf	85 f6		 test	 esi, esi
  00cd1	75 09		 jne	 SHORT $L71194
  00cd3	5f		 pop	 edi
  00cd4	5e		 pop	 esi

; 2700 :     {
; 2701 :       return MMSYSERR_NOMEM;

  00cd5	b8 07 00 00 00	 mov	 eax, 7
  00cda	5b		 pop	 ebx

; 2721 : }

  00cdb	c3		 ret	 0
$L71194:

; 2702 :     }
; 2703 : 
; 2704 :     /******************************************************************/
; 2705 :     /*  Get the fine wave output position.                            */
; 2706 :     /******************************************************************/
; 2707 : 
; 2708 :     mmStatus = (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2709 :                                                ID_Get_Audio_Position,
; 2710 :                                                (ATYPE_T)pdwPos );

  00cdc	56		 push	 esi
  00cdd	6a 09		 push	 9
  00cdf	57		 push	 edi
  00ce0	e8 00 00 00 00	 call	 _SendPlayAudioMessage

; 2711 :     *pdwPosition = *pdwPos;

  00ce5	8b 54 24 20	 mov	 edx, DWORD PTR _pdwPosition$[esp+20]
  00ce9	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 2712 : 
; 2713 :     /******************************************************************/
; 2714 :     /*  Free the memory used to return the audio position.            */
; 2715 :     /******************************************************************/
; 2716 : 
; 2717 :     free( pdwPos );

  00ceb	56		 push	 esi
  00cec	8b d8		 mov	 ebx, eax
  00cee	89 0a		 mov	 DWORD PTR [edx], ecx
  00cf0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00cf6	83 c4 10	 add	 esp, 16			; 00000010H

; 2718 :   }
; 2719 : 
; 2720 :   return mmStatus;

  00cf9	8b c3		 mov	 eax, ebx
  00cfb	5f		 pop	 edi
  00cfc	5e		 pop	 esi
  00cfd	5b		 pop	 ebx

; 2721 : }

  00cfe	c3		 ret	 0
_PA_GetPosition ENDP
_TEXT	ENDS
PUBLIC	_PA_Status
_TEXT	SEGMENT
_pPlayAudio$ = 8
_dwIdentifierArray$ = 12
_dwStatusArray$ = 16
_dwNumberOfStatusValues$ = 20
_uiQueueCount$ = -8
_bGotQueueCount$ = 8
_mmStatus$ = -4
_PA_Status PROC NEAR

; 2803 : {

  00d00	83 ec 08	 sub	 esp, 8
  00d03	55		 push	 ebp
  00d04	56		 push	 esi

; 2804 :   unsigned int uiI;
; 2805 :   unsigned int uiQueueCount=0;
; 2806 :   unsigned int bGotQueueCount;
; 2807 :   DWORD dwAudioDeviceState;
; 2808 :   LPPLAY_RING_T pPlayAudioRing=NULL;
; 2809 :   MMRESULT mmStatus;
; 2810 : 
; 2811 :   /********************************************************************/
; 2812 :   /*  Return an error if NULL handle.                                 */
; 2813 :   /********************************************************************/
; 2814 : 
; 2815 :   if ( pPlayAudio == NULL )

  00d05	8b 74 24 14	 mov	 esi, DWORD PTR _pPlayAudio$[esp+12]
  00d09	33 d2		 xor	 edx, edx
  00d0b	33 ed		 xor	 ebp, ebp
  00d0d	3b f2		 cmp	 esi, edx
  00d0f	89 54 24 08	 mov	 DWORD PTR _uiQueueCount$[esp+16], edx
  00d13	75 0b		 jne	 SHORT $L71214
  00d15	5e		 pop	 esi

; 2816 :     return MMSYSERR_INVALHANDLE;

  00d16	b8 05 00 00 00	 mov	 eax, 5
  00d1b	5d		 pop	 ebp

; 2910 : }

  00d1c	83 c4 08	 add	 esp, 8
  00d1f	c3		 ret	 0
$L71214:

; 2817 : 
; 2818 :   /********************************************************************/
; 2819 :   /*  Range check the number of status values requested.              */
; 2820 :   /********************************************************************/
; 2821 : 
; 2822 :   if (( dwNumberOfStatusValues == 0 )
; 2823 :     || ( dwNumberOfStatusValues > MAXIMUM_STATUS_VALUES ))

  00d20	8b 44 24 20	 mov	 eax, DWORD PTR _dwNumberOfStatusValues$[esp+12]
  00d24	3b c2		 cmp	 eax, edx
  00d26	0f 84 3a 01 00
	00		 je	 $L71216
  00d2c	83 f8 04	 cmp	 eax, 4
  00d2f	0f 87 31 01 00
	00		 ja	 $L71216

; 2831 : 
; 2832 :   /********************************************************************/
; 2833 :   /*  Loop and fill in array puiStatus[].                             */
; 2834 :   /********************************************************************/
; 2835 : 
; 2836 :   bGotQueueCount = FALSE;
; 2837 : 
; 2838 :   for ( uiI = 0; uiI < dwNumberOfStatusValues; uiI++ )

  00d35	3b c2		 cmp	 eax, edx
  00d37	89 54 24 0c	 mov	 DWORD PTR _mmStatus$[esp+16], edx
  00d3b	89 54 24 14	 mov	 DWORD PTR _bGotQueueCount$[esp+12], edx
  00d3f	0f 86 17 01 00
	00		 jbe	 $L71219

; 2851 :       else
; 2852 :         dwStatusArray[uiI] = TRUE;

  00d45	8b 4c 24 18	 mov	 ecx, DWORD PTR _dwIdentifierArray$[esp+12]
  00d49	53		 push	 ebx
  00d4a	57		 push	 edi
  00d4b	8b 7c 24 24	 mov	 edi, DWORD PTR _dwStatusArray$[esp+20]
  00d4f	2b cf		 sub	 ecx, edi
  00d51	89 44 24 28	 mov	 DWORD PTR 20+[esp+20], eax
  00d55	89 4c 24 24	 mov	 DWORD PTR 16+[esp+20], ecx
  00d59	eb 08		 jmp	 SHORT $L71217
$L72046:

; 2825 : 
; 2826 :   /********************************************************************/
; 2827 :   /*  Set the default error return value to indicate success.         */
; 2828 :   /********************************************************************/
; 2829 : 
; 2830 :   mmStatus = MMSYSERR_NOERROR;

  00d5b	8b 4c 24 24	 mov	 ecx, DWORD PTR 16+[esp+20]
  00d5f	8b 54 24 1c	 mov	 edx, DWORD PTR _bGotQueueCount$[esp+20]
$L71217:

; 2839 :   {
; 2840 :     switch( dwIdentifierArray[uiI] )
; 2841 :     {

  00d63	8b 04 39	 mov	 eax, DWORD PTR [ecx+edi]
  00d66	83 f8 03	 cmp	 eax, 3
  00d69	0f 87 cb 00 00
	00		 ja	 $L71239
  00d6f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72047[eax*4]
$L71224:

; 2842 :     case PA_DEVICE_PLAYING:
; 2843 : 
; 2844 :       OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  00d76	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  00d79	50		 push	 eax
  00d7a	e8 00 00 00 00	 call	 _OP_LockMutex

; 2845 :       dwAudioDeviceState = pPlayAudio->dwAudioDeviceState;
; 2846 :       OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  00d7f	8b 4e 70	 mov	 ecx, DWORD PTR [esi+112]
  00d82	8b 5e 34	 mov	 ebx, DWORD PTR [esi+52]
  00d85	51		 push	 ecx
  00d86	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00d8b	83 c4 08	 add	 esp, 8

; 2847 : 
; 2848 :       if (( dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )
; 2849 :         || ( dwAudioDeviceState == AUDIO_DEVICE_SHUTTING_DOWN ))

  00d8e	85 db		 test	 ebx, ebx
  00d90	74 10		 je	 SHORT $L71226
  00d92	83 fb 03	 cmp	 ebx, 3
  00d95	74 0b		 je	 SHORT $L71226

; 2851 :       else
; 2852 :         dwStatusArray[uiI] = TRUE;

  00d97	c7 07 01 00 00
	00		 mov	 DWORD PTR [edi], 1
  00d9d	e9 a6 00 00 00	 jmp	 $L71218
$L71226:

; 2850 :         dwStatusArray[uiI] = FALSE;

  00da2	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 2853 : 
; 2854 :       break;

  00da8	e9 9b 00 00 00	 jmp	 $L71218
$L71228:

; 2855 : 
; 2856 :     case PA_FREE_SPACE:
; 2857 : 
; 2858 :       if ( ! bGotQueueCount )

  00dad	85 d2		 test	 edx, edx
  00daf	75 2a		 jne	 SHORT $L71229

; 2859 :       {
; 2860 :         bGotQueueCount = TRUE;
; 2861 : 
; 2862 :         pPlayAudioRing = pPlayAudio->pPlayAudioRing;
; 2863 : 
; 2864 :         OP_LockMutex( pPlayAudio->hmxQueueCount );

  00db1	8b 56 7c	 mov	 edx, DWORD PTR [esi+124]
  00db4	8b ae 98 00 00
	00		 mov	 ebp, DWORD PTR [esi+152]
  00dba	52		 push	 edx
  00dbb	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR _bGotQueueCount$[esp+24], 1
  00dc3	e8 00 00 00 00	 call	 _OP_LockMutex

; 2865 :         uiQueueCount = (unsigned int)pPlayAudioRing->iQueueCount;
; 2866 : 		// tek 07nov97 BATS 514this was a very bad typo! change to UNlock!
; 2867 :         OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  00dc8	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  00dcb	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  00dce	51		 push	 ecx
  00dcf	89 44 24 18	 mov	 DWORD PTR _uiQueueCount$[esp+32], eax
  00dd3	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00dd8	83 c4 08	 add	 esp, 8
$L71229:

; 2868 :       }
; 2869 : 
; 2870 :       dwStatusArray[uiI] = (DWORD)
; 2871 :         ((unsigned int )pPlayAudioRing->iQueueLength - uiQueueCount );

  00ddb	8b 55 1c	 mov	 edx, DWORD PTR [ebp+28]
  00dde	8b 44 24 10	 mov	 eax, DWORD PTR _uiQueueCount$[esp+24]
  00de2	2b d0		 sub	 edx, eax
  00de4	89 17		 mov	 DWORD PTR [edi], edx

; 2872 : 
; 2873 :       break;

  00de6	eb 60		 jmp	 SHORT $L71218
$L71233:

; 2874 : 
; 2875 :     case PA_QUEUE_COUNT:
; 2876 : 
; 2877 :       if ( ! bGotQueueCount )

  00de8	85 d2		 test	 edx, edx
  00dea	75 2a		 jne	 SHORT $L71234

; 2878 :       {
; 2879 :         bGotQueueCount = TRUE;
; 2880 : 
; 2881 :         pPlayAudioRing = pPlayAudio->pPlayAudioRing;
; 2882 : 
; 2883 :         OP_LockMutex( pPlayAudio->hmxQueueCount );

  00dec	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  00def	8b ae 98 00 00
	00		 mov	 ebp, DWORD PTR [esi+152]
  00df5	50		 push	 eax
  00df6	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR _bGotQueueCount$[esp+24], 1
  00dfe	e8 00 00 00 00	 call	 _OP_LockMutex

; 2884 :         uiQueueCount = (unsigned int)pPlayAudioRing->iQueueCount;
; 2885 :         OP_LockMutex( pPlayAudio->hmxQueueCount );

  00e03	8b 56 7c	 mov	 edx, DWORD PTR [esi+124]
  00e06	8b 4d 18	 mov	 ecx, DWORD PTR [ebp+24]
  00e09	52		 push	 edx
  00e0a	89 4c 24 18	 mov	 DWORD PTR _uiQueueCount$[esp+32], ecx
  00e0e	e8 00 00 00 00	 call	 _OP_LockMutex
  00e13	83 c4 08	 add	 esp, 8
$L71234:

; 2886 :       }
; 2887 : 
; 2888 :       dwStatusArray[uiI] = (DWORD)uiQueueCount;

  00e16	8b 44 24 10	 mov	 eax, DWORD PTR _uiQueueCount$[esp+24]
  00e1a	89 07		 mov	 DWORD PTR [edi], eax

; 2889 : 
; 2890 :       break;

  00e1c	eb 2a		 jmp	 SHORT $L71218
$L71237:

; 2891 : 
; 2892 :     case PA_DEVICE_ID:
; 2893 : 
; 2894 :       OP_LockMutex( pPlayAudio->hmxSelectedDeviceID );

  00e1e	8b 4e 78	 mov	 ecx, DWORD PTR [esi+120]
  00e21	51		 push	 ecx
  00e22	e8 00 00 00 00	 call	 _OP_LockMutex

; 2895 :       dwStatusArray[uiI] = (DWORD)pPlayAudio->uiSelectedDeviceID;

  00e27	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00e2a	89 17		 mov	 DWORD PTR [edi], edx

; 2896 :       OP_UnlockMutex( pPlayAudio->hmxSelectedDeviceID );

  00e2c	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  00e2f	50		 push	 eax
  00e30	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00e35	83 c4 08	 add	 esp, 8

; 2897 : 
; 2898 :       break;

  00e38	eb 0e		 jmp	 SHORT $L71218
$L71239:

; 2899 : 
; 2900 :     default:
; 2901 : 
; 2902 :       dwStatusArray[uiI] = 0xFFFFFFFF;

  00e3a	c7 07 ff ff ff
	ff		 mov	 DWORD PTR [edi], -1

; 2903 :       mmStatus = MMSYSERR_INVALPARAM;

  00e40	c7 44 24 14 0b
	00 00 00	 mov	 DWORD PTR _mmStatus$[esp+24], 11 ; 0000000bH
$L71218:
  00e48	8b 44 24 28	 mov	 eax, DWORD PTR 20+[esp+20]
  00e4c	83 c7 04	 add	 edi, 4
  00e4f	48		 dec	 eax
  00e50	89 44 24 28	 mov	 DWORD PTR 20+[esp+20], eax
  00e54	0f 85 01 ff ff
	ff		 jne	 $L72046
  00e5a	5f		 pop	 edi
  00e5b	5b		 pop	 ebx
$L71219:

; 2904 : 
; 2905 :       break;
; 2906 :     }
; 2907 :   }
; 2908 : 
; 2909 :   return mmStatus;

  00e5c	8b 44 24 0c	 mov	 eax, DWORD PTR _mmStatus$[esp+16]
  00e60	5e		 pop	 esi
  00e61	5d		 pop	 ebp

; 2910 : }

  00e62	83 c4 08	 add	 esp, 8
  00e65	c3		 ret	 0
$L71216:
  00e66	5e		 pop	 esi

; 2824 :     return MMSYSERR_INVALPARAM;

  00e67	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00e6c	5d		 pop	 ebp

; 2910 : }

  00e6d	83 c4 08	 add	 esp, 8
  00e70	c3		 ret	 0
  00e71	8d 49 00	 npad	 3
$L72047:
  00e74	00 00 00 00	 DD	 $L71224
  00e78	00 00 00 00	 DD	 $L71228
  00e7c	00 00 00 00	 DD	 $L71233
  00e80	00 00 00 00	 DD	 $L71237
_PA_Status ENDP
_TEXT	ENDS
PUBLIC	_PA_WaitForPlayToComplete
EXTRN	_OP_Sleep:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_PA_WaitForPlayToComplete PROC NEAR

; 2939 : {

  00e90	56		 push	 esi

; 2940 :   int iQueueCount;
; 2941 :   PLAYAUD_BOOL_T bAudioPlaying;
; 2942 :   LPPLAY_RING_T pPlayAudioRing;
; 2943 : 
; 2944 :   /********************************************************************/
; 2945 :   /*  Return an error if NULL handle.                                 */
; 2946 :   /********************************************************************/
; 2947 : 
; 2948 :   if ( pPlayAudio == NULL )

  00e91	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  00e95	85 f6		 test	 esi, esi
  00e97	75 07		 jne	 SHORT $L71247

; 2949 :     return MMSYSERR_INVALHANDLE;

  00e99	b8 05 00 00 00	 mov	 eax, 5
  00e9e	5e		 pop	 esi

; 2986 : }

  00e9f	c3		 ret	 0
$L71247:
  00ea0	53		 push	 ebx

; 2950 : 
; 2951 :   /********************************************************************/
; 2952 :   /*  Loop and wait for all queued audio samples to complete.         */
; 2953 :   /********************************************************************/
; 2954 : 
; 2955 :   pPlayAudioRing = pPlayAudio->pPlayAudioRing;

  00ea1	8b 9e 98 00 00
	00		 mov	 ebx, DWORD PTR [esi+152]
  00ea7	57		 push	 edi
$L71249:

; 2956 :   bAudioPlaying = TRUE;
; 2957 : 
; 2958 :   while( bAudioPlaying )
; 2959 :   {
; 2960 :     /******************************************************************/
; 2961 :     /*  Wait on the Audio Device Inactive Event.                      */
; 2962 :     /******************************************************************/
; 2963 : 
; 2964 :     OP_WaitForEvent( pPlayAudio->hevAudioDeviceInactive, OP_INFINITE );

  00ea8	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00eab	6a ff		 push	 -1
  00ead	50		 push	 eax
  00eae	e8 00 00 00 00	 call	 _OP_WaitForEvent

; 2965 : 
; 2966 :     /******************************************************************/
; 2967 :     /*  Check the Audio Queue Count. If there is any audio to be      */
; 2968 :     /*  played then go to sleep and contine to wait.                  */
; 2969 :     /******************************************************************/
; 2970 : 
; 2971 :     OP_LockMutex( pPlayAudio->hmxQueueCount );

  00eb3	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  00eb6	51		 push	 ecx
  00eb7	e8 00 00 00 00	 call	 _OP_LockMutex

; 2972 :     iQueueCount = pPlayAudioRing->iQueueCount;
; 2973 :     OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  00ebc	8b 56 7c	 mov	 edx, DWORD PTR [esi+124]
  00ebf	8b 7b 18	 mov	 edi, DWORD PTR [ebx+24]
  00ec2	52		 push	 edx
  00ec3	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00ec8	83 c4 10	 add	 esp, 16			; 00000010H

; 2974 : 
; 2975 :     if ( iQueueCount == 0 )

  00ecb	85 ff		 test	 edi, edi
  00ecd	74 0c		 je	 SHORT $L72050

; 2976 :     {
; 2977 :       bAudioPlaying = FALSE;
; 2978 :     }
; 2979 :     else
; 2980 :     {
; 2981 :       OP_Sleep( PLAY_WAIT_SLEEP_TIME_IN_MSEC );

  00ecf	6a 32		 push	 50			; 00000032H
  00ed1	e8 00 00 00 00	 call	 _OP_Sleep
  00ed6	83 c4 04	 add	 esp, 4
  00ed9	eb cd		 jmp	 SHORT $L71249
$L72050:
  00edb	5f		 pop	 edi
  00edc	5b		 pop	 ebx

; 2982 :     }
; 2983 :   }
; 2984 : 
; 2985 :   return MMSYSERR_NOERROR;

  00edd	33 c0		 xor	 eax, eax
  00edf	5e		 pop	 esi

; 2986 : }

  00ee0	c3		 ret	 0
_PA_WaitForPlayToComplete ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutGetDevCapsA@12:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_uiNumberOfWaveOutDevices$ = 12
_pWaveFormat$ = 16
_bGotDeviceID$ = -8
_bAllocated$ = -4
_DetermineDeviceID PROC NEAR

; 3027 : {

  00ef0	83 ec 08	 sub	 esp, 8
  00ef3	53		 push	 ebx
  00ef4	55		 push	 ebp

; 3028 :   unsigned int bGotDeviceID;
; 3029 :   unsigned int bAllocated;
; 3030 :   unsigned int bIsStandardFormat;
; 3031 :   unsigned int uiDeviceID;
; 3032 :   DWORD dwDesiredFormat=0;
; 3033 :   LPWAVEOUTCAPS pWaveOutCaps;
; 3034 :   MMRESULT mmStatus;
; 3035 : #ifdef AUD_DEBUG
; 3036 :   OutputDebugString("DetermineDeviceID()\n");
; 3037 : #endif
; 3038 :   /********************************************************************/
; 3039 :   /*  Query each device until a non-allocated device that supports    */
; 3040 :   /*  the requested format is found.                                  */
; 3041 :   /********************************************************************/
; 3042 : 
; 3043 :   bGotDeviceID = FALSE;
; 3044 :   bAllocated = FALSE;
; 3045 : 
; 3046 :   for ( uiDeviceID = 0;
; 3047 :         uiDeviceID < uiNumberOfWaveOutDevices;
; 3048 :         uiDeviceID++ )

  00ef5	8b 6c 24 18	 mov	 ebp, DWORD PTR _uiNumberOfWaveOutDevices$[esp+12]
  00ef9	56		 push	 esi
  00efa	57		 push	 edi
  00efb	33 ff		 xor	 edi, edi
  00efd	3b ef		 cmp	 ebp, edi
  00eff	89 7c 24 10	 mov	 DWORD PTR _bGotDeviceID$[esp+24], edi
  00f03	89 7c 24 14	 mov	 DWORD PTR _bAllocated$[esp+24], edi
  00f07	76 6a		 jbe	 SHORT $L72063

; 3049 :   {
; 3050 :     pPlayAudio->uiSelectedDeviceID = uiDeviceID;

  00f09	8b 74 24 24	 mov	 esi, DWORD PTR _pWaveFormat$[esp+20]
$L71267:
  00f0d	8b 5c 24 1c	 mov	 ebx, DWORD PTR _pPlayAudio$[esp+20]

; 3051 : 
; 3052 :     mmStatus = PA_SetFormat( pPlayAudio, pWaveFormat );

  00f11	56		 push	 esi
  00f12	53		 push	 ebx
  00f13	89 7b 20	 mov	 DWORD PTR [ebx+32], edi
  00f16	e8 00 00 00 00	 call	 _PA_SetFormat
  00f1b	83 c4 08	 add	 esp, 8

; 3053 : 
; 3054 :     if ( mmStatus == MMSYSERR_NOERROR )

  00f1e	85 c0		 test	 eax, eax
  00f20	74 14		 je	 SHORT $L72055

; 3057 :       break;
; 3058 :     }
; 3059 :     else if ( mmStatus == MMSYSERR_ALLOCATED )

  00f22	83 f8 04	 cmp	 eax, 4
  00f25	75 08		 jne	 SHORT $L71268

; 3060 :     {
; 3061 :       bAllocated = TRUE;

  00f27	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _bAllocated$[esp+24], 1
$L71268:

; 3028 :   unsigned int bGotDeviceID;
; 3029 :   unsigned int bAllocated;
; 3030 :   unsigned int bIsStandardFormat;
; 3031 :   unsigned int uiDeviceID;
; 3032 :   DWORD dwDesiredFormat=0;
; 3033 :   LPWAVEOUTCAPS pWaveOutCaps;
; 3034 :   MMRESULT mmStatus;
; 3035 : #ifdef AUD_DEBUG
; 3036 :   OutputDebugString("DetermineDeviceID()\n");
; 3037 : #endif
; 3038 :   /********************************************************************/
; 3039 :   /*  Query each device until a non-allocated device that supports    */
; 3040 :   /*  the requested format is found.                                  */
; 3041 :   /********************************************************************/
; 3042 : 
; 3043 :   bGotDeviceID = FALSE;
; 3044 :   bAllocated = FALSE;
; 3045 : 
; 3046 :   for ( uiDeviceID = 0;
; 3047 :         uiDeviceID < uiNumberOfWaveOutDevices;
; 3048 :         uiDeviceID++ )

  00f2f	47		 inc	 edi
  00f30	3b fd		 cmp	 edi, ebp
  00f32	72 d9		 jb	 SHORT $L71267

; 3367 :         {
; 3368 :           break;
; 3369 :         }
; 3370 : 
; 3371 :         if ( pWaveOutCaps->dwFormats == dwDesiredFormat )

  00f34	eb 08		 jmp	 SHORT $L71269
$L72055:

; 3055 :     {
; 3056 :       bGotDeviceID = TRUE;

  00f36	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _bGotDeviceID$[esp+24], 1
$L71269:

; 3062 :     }
; 3063 :   }
; 3064 : 
; 3065 :   /********************************************************************/
; 3066 :   /*  There were no devices available that support the requested      */
; 3067 :   /*  format. Query each device until a device that supports the      */
; 3068 :   /*  requested format is found, even if the device is allocated.     */
; 3069 :   /********************************************************************/
; 3070 : 
; 3071 :   if ( bAllocated )

  00f3e	8b 44 24 14	 mov	 eax, DWORD PTR _bAllocated$[esp+24]
  00f42	85 c0		 test	 eax, eax
  00f44	74 1d		 je	 SHORT $L71276

; 3072 :   {
; 3073 :     for ( uiDeviceID = 0;
; 3074 :           uiDeviceID < uiNumberOfWaveOutDevices;
; 3075 :           uiDeviceID++ )

  00f46	33 ff		 xor	 edi, edi
$L71274:

; 3076 :     {
; 3077 :       pPlayAudio->uiSelectedDeviceID = uiDeviceID;
; 3078 : 
; 3079 :       mmStatus = PA_SetFormat( pPlayAudio, pWaveFormat );

  00f48	56		 push	 esi
  00f49	53		 push	 ebx
  00f4a	89 7b 20	 mov	 DWORD PTR [ebx+32], edi
  00f4d	e8 00 00 00 00	 call	 _PA_SetFormat
  00f52	83 c4 08	 add	 esp, 8

; 3080 : 
; 3081 :       if (( mmStatus == MMSYSERR_NOERROR )
; 3082 :         || ( mmStatus == MMSYSERR_ALLOCATED ))

  00f55	85 c0		 test	 eax, eax
  00f57	74 27		 je	 SHORT $L72056
  00f59	83 f8 04	 cmp	 eax, 4
  00f5c	74 22		 je	 SHORT $L72056
  00f5e	47		 inc	 edi
  00f5f	3b fd		 cmp	 edi, ebp
  00f61	72 e5		 jb	 SHORT $L71274
$L71276:

; 3085 :         break;
; 3086 :       }
; 3087 :     }
; 3088 :   }
; 3089 : 
; 3090 :   // tek 24sep96 if we didn't find an unallocated device that 
; 3091 :   // supports this format, and we didn't find an allocated device, 
; 3092 :   // bail out.
; 3093 :   if ((!bGotDeviceID) && (!bAllocated))

  00f63	8b 44 24 10	 mov	 eax, DWORD PTR _bGotDeviceID$[esp+24]
  00f67	85 c0		 test	 eax, eax
  00f69	75 1d		 jne	 SHORT $L71279
  00f6b	8b 44 24 14	 mov	 eax, DWORD PTR _bAllocated$[esp+24]
  00f6f	85 c0		 test	 eax, eax
  00f71	75 15		 jne	 SHORT $L71279
$L72063:
  00f73	5f		 pop	 edi
  00f74	5e		 pop	 esi
  00f75	5d		 pop	 ebp

; 3094 :   {
; 3095 : #ifdef AUD_DEBUG
; 3096 : 	  OutputDebugString("no devices support format.\n");
; 3097 : #endif
; 3098 : 	  return WAVERR_BADFORMAT;

  00f76	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00f7b	5b		 pop	 ebx

; 3409 : }

  00f7c	83 c4 08	 add	 esp, 8
  00f7f	c3		 ret	 0
$L72056:

; 3083 :       {
; 3084 :         bGotDeviceID = TRUE;

  00f80	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _bGotDeviceID$[esp+24], 1
$L71279:

; 3099 :   }
; 3100 : 
; 3101 : 
; 3102 :   /********************************************************************/
; 3103 :   /*  If a wave output device supporting the request format was not   */
; 3104 :   /*  found, it might be because all devices supporting the requested */
; 3105 :   /*  format are busy and busy devices do not return a bad format     */
; 3106 :   /*  status even if the format is unsupported. This not the case for */
; 3107 :   /*  the MME server, but in any event, this extra check cannot hurt. */
; 3108 :   /*  In this case, device support only for mulaw and certain PCM     */
; 3109 :   /*  formats can be checked.                                         */
; 3110 :   /********************************************************************/
; 3111 : 
; 3112 :   mmStatus = MMSYSERR_NOERROR;
; 3113 : 
; 3114 :   if (( ! bGotDeviceID ) && ( bAllocated ))

  00f88	8b 44 24 10	 mov	 eax, DWORD PTR _bGotDeviceID$[esp+24]
  00f8c	33 ff		 xor	 edi, edi
  00f8e	85 c0		 test	 eax, eax
  00f90	75 74		 jne	 SHORT $L71373
  00f92	8b 44 24 14	 mov	 eax, DWORD PTR _bAllocated$[esp+24]
  00f96	85 c0		 test	 eax, eax
  00f98	74 6c		 je	 SHORT $L71373

; 3115 :   {
; 3116 :     /********************************************************************/
; 3117 :     /*  If the wave format tag is equal to either WAVE_FORMAT_PCM or to */
; 3118 :     /*  WAVE_FORMAT_08M08 then test the device capabilities.            */
; 3119 :     /********************************************************************/
; 3120 : 
; 3121 :     bIsStandardFormat = TRUE;
; 3122 : 
; 3123 :     switch ( pWaveFormat->wFormatTag )
; 3124 :     {

  00f9a	33 c0		 xor	 eax, eax
  00f9c	66 8b 06	 mov	 ax, WORD PTR [esi]
  00f9f	48		 dec	 eax
  00fa0	74 22		 je	 SHORT $L71285
  00fa2	83 e8 06	 sub	 eax, 6
  00fa5	75 53		 jne	 SHORT $L71361

; 3311 :       }
; 3312 : 
; 3313 :       break;
; 3314 : 
; 3315 :     case WAVE_FORMAT_08M08:
; 3316 : 
; 3317 :         if (( pWaveFormat->nSamplesPerSec == 8000 )
; 3318 :           && ( pWaveFormat->nChannels == 1 )
; 3319 :           && ( pWaveFormat->wBitsPerSample == 8 ))

  00fa7	81 7e 04 40 1f
	00 00		 cmp	 DWORD PTR [esi+4], 8000	; 00001f40H
  00fae	75 4a		 jne	 SHORT $L71361
  00fb0	66 83 7e 02 01	 cmp	 WORD PTR [esi+2], 1
  00fb5	75 43		 jne	 SHORT $L71361
  00fb7	66 83 7e 0e 08	 cmp	 WORD PTR [esi+14], 8

; 3320 :         {
; 3321 :           dwDesiredFormat = WAVE_FORMAT_08M08;
; 3322 :         }
; 3323 :         else

  00fbc	0f 84 82 00 00
	00		 je	 $L72064

; 3324 :         {
; 3325 :           bIsStandardFormat = FALSE;;
; 3326 :         }
; 3327 : 
; 3328 :         break;

  00fc2	eb 36		 jmp	 SHORT $L71361
$L71285:

; 3125 :     /********************************************************************/
; 3126 :     /*  Determine the identifier returned in the dwFormat element       */
; 3127 :     /*  of the WAVEOUTCAPS structure that corresponds to the            */
; 3128 :     /*  requested audio format.                                         */
; 3129 :     /********************************************************************/
; 3130 : 
; 3131 :     case WAVE_FORMAT_PCM:
; 3132 : 
; 3133 :       switch ( pWaveFormat->nSamplesPerSec )
; 3134 :       {

  00fc4	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00fc7	3d 11 2b 00 00	 cmp	 eax, 11025		; 00002b11H
  00fcc	74 5c		 je	 SHORT $L71290
  00fce	3d 22 56 00 00	 cmp	 eax, 22050		; 00005622H
  00fd3	74 3b		 je	 SHORT $L71312
  00fd5	3d 44 ac 00 00	 cmp	 eax, 44100		; 0000ac44H

; 3259 :           case 8:
; 3260 : 
; 3261 :             dwDesiredFormat = WAVE_FORMAT_4M08;
; 3262 :             break;
; 3263 : 
; 3264 :           case 16:
; 3265 : 
; 3266 :             dwDesiredFormat = WAVE_FORMAT_4M16;
; 3267 :             break;
; 3268 : 
; 3269 :           default:
; 3270 : 
; 3271 :             bIsStandardFormat = FALSE;;
; 3272 :             break;
; 3273 :           }
; 3274 : 
; 3275 :         case 2:
; 3276 : 
; 3277 :           switch ( pWaveFormat->wBitsPerSample )
; 3278 :           {
; 3279 :           case 8:
; 3280 : 
; 3281 :             dwDesiredFormat = WAVE_FORMAT_4S08;
; 3282 :             break;
; 3283 : 
; 3284 :           case 16:
; 3285 : 
; 3286 :             dwDesiredFormat = WAVE_FORMAT_4S16;
; 3287 :             break;
; 3288 : 
; 3289 :           default:
; 3290 : 
; 3291 :             bIsStandardFormat = FALSE;;
; 3292 :             break;
; 3293 :           }
; 3294 : 
; 3295 :         default:
; 3296 : 
; 3297 :           bIsStandardFormat = FALSE;;
; 3298 :           break;
; 3299 :         }
; 3300 : 
; 3301 :         break;
; 3302 : 
; 3303 :       /****************************************************************/
; 3304 :       /*  The sample rate is not a standard value.                    */
; 3305 :       /****************************************************************/
; 3306 : 
; 3307 :       default:
; 3308 : 
; 3309 :         bIsStandardFormat = FALSE;;
; 3310 :         break;

  00fda	75 1e		 jne	 SHORT $L71361
  00fdc	33 c0		 xor	 eax, eax
  00fde	66 8b 46 02	 mov	 ax, WORD PTR [esi+2]
  00fe2	48		 dec	 eax
  00fe3	74 05		 je	 SHORT $L71339

; 3246 : 
; 3247 :       /****************************************************************/
; 3248 :       /*  The sample rate equals 44100 Hz.                            */
; 3249 :       /****************************************************************/
; 3250 : 
; 3251 :       case 44100:
; 3252 : 
; 3253 :         switch ( pWaveFormat->nChannels )
; 3254 :         {

  00fe5	48		 dec	 eax
  00fe6	74 0c		 je	 SHORT $L71341
  00fe8	eb 10		 jmp	 SHORT $L71361
$L71339:

; 3255 :         case 1:
; 3256 : 
; 3257 :           switch ( pWaveFormat->wBitsPerSample )
; 3258 :           {

  00fea	33 c0		 xor	 eax, eax
  00fec	66 8b 46 0e	 mov	 ax, WORD PTR [esi+14]
  00ff0	89 44 24 20	 mov	 DWORD PTR 12+[esp+20], eax
$L71341:
  00ff4	33 c0		 xor	 eax, eax
  00ff6	66 8b 46 0e	 mov	 ax, WORD PTR [esi+14]
$L71361:

; 3390 :       {
; 3391 :         mmStatus = MMSYSERR_NOTSUPPORTED;
; 3392 :       }
; 3393 :     }
; 3394 :     else
; 3395 :     {
; 3396 :       /******************************************************************/
; 3397 :       /*  A non standard format is requested and some devices are busy  */
; 3398 :       /*  so they cannot be queried. Exit with failure and inform the   */
; 3399 :       /*  application that some devices are allocated.                  */
; 3400 :       /******************************************************************/
; 3401 : 
; 3402 :       pPlayAudio->uiSelectedDeviceID = WAVE_MAPPER;

  00ffa	c7 43 20 ff ff
	ff ff		 mov	 DWORD PTR [ebx+32], -1

; 3403 : 
; 3404 :       mmStatus = MMSYSERR_NOTSUPPORTED;

  01001	bf 08 00 00 00	 mov	 edi, 8
$L71373:

; 3405 :     }
; 3406 :   }
; 3407 : 
; 3408 :   return mmStatus;

  01006	8b c7		 mov	 eax, edi
  01008	5f		 pop	 edi
  01009	5e		 pop	 esi
  0100a	5d		 pop	 ebp
  0100b	5b		 pop	 ebx

; 3409 : }

  0100c	83 c4 08	 add	 esp, 8
  0100f	c3		 ret	 0
$L71312:

; 3147 :           case 8:
; 3148 : 
; 3149 :             dwDesiredFormat = WAVE_FORMAT_1M08;
; 3150 :             break;
; 3151 : 
; 3152 :           case 16:
; 3153 : 
; 3154 :             dwDesiredFormat = WAVE_FORMAT_1M16;
; 3155 :             break;
; 3156 : 
; 3157 :           default:
; 3158 : 
; 3159 :             bIsStandardFormat = FALSE;;
; 3160 :             break;
; 3161 :           }
; 3162 : 
; 3163 :         case 2:
; 3164 : 
; 3165 :           switch ( pWaveFormat->wBitsPerSample )
; 3166 :           {
; 3167 :           case 8:
; 3168 : 
; 3169 :             dwDesiredFormat = WAVE_FORMAT_1S08;
; 3170 :             break;
; 3171 : 
; 3172 :           case 16:
; 3173 : 
; 3174 :             dwDesiredFormat = WAVE_FORMAT_1S16;
; 3175 :             break;
; 3176 : 
; 3177 :           default:
; 3178 : 
; 3179 :             bIsStandardFormat = FALSE;;
; 3180 :             break;
; 3181 :           }
; 3182 : 
; 3183 :         default:
; 3184 : 
; 3185 :           bIsStandardFormat = FALSE;;
; 3186 :           break;
; 3187 :         }
; 3188 : 
; 3189 :         break;
; 3190 : 
; 3191 :       /****************************************************************/
; 3192 :       /*  The sample rate equals 22050 Hz.                            */
; 3193 :       /****************************************************************/
; 3194 : 
; 3195 :       case 22050:
; 3196 : 
; 3197 :         switch ( pWaveFormat->nChannels )
; 3198 :         {

  01010	33 c0		 xor	 eax, eax
  01012	66 8b 46 02	 mov	 ax, WORD PTR [esi+2]
  01016	48		 dec	 eax
  01017	74 05		 je	 SHORT $L71317
  01019	48		 dec	 eax
  0101a	74 d8		 je	 SHORT $L71341
  0101c	eb dc		 jmp	 SHORT $L71361
$L71317:

; 3199 :         case 1:
; 3200 : 
; 3201 :           switch ( pWaveFormat->wBitsPerSample )
; 3202 :           {

  0101e	33 c9		 xor	 ecx, ecx
  01020	66 8b 4e 0e	 mov	 cx, WORD PTR [esi+14]
  01024	89 4c 24 20	 mov	 DWORD PTR 12+[esp+20], ecx

; 3203 :           case 8:
; 3204 : 
; 3205 :             dwDesiredFormat = WAVE_FORMAT_2M08;
; 3206 :             break;
; 3207 : 
; 3208 :           case 16:
; 3209 : 
; 3210 :             dwDesiredFormat = WAVE_FORMAT_2M16;
; 3211 :             break;
; 3212 : 
; 3213 :           default:
; 3214 : 
; 3215 :             bIsStandardFormat = FALSE;;
; 3216 :             break;
; 3217 :           }
; 3218 : 
; 3219 :         case 2:
; 3220 : 
; 3221 :           switch ( pWaveFormat->wBitsPerSample )
; 3222 :           {
; 3223 :           case 8:
; 3224 : 
; 3225 :             dwDesiredFormat = WAVE_FORMAT_2S08;
; 3226 :             break;
; 3227 : 
; 3228 :           case 16:
; 3229 : 
; 3230 :             dwDesiredFormat = WAVE_FORMAT_2S16;
; 3231 :             break;
; 3232 : 
; 3233 :           default:
; 3234 : 
; 3235 :             bIsStandardFormat = FALSE;;
; 3236 :             break;
; 3237 :           }
; 3238 : 
; 3239 :         default:
; 3240 : 
; 3241 :           bIsStandardFormat = FALSE;;
; 3242 :           break;
; 3243 :         }
; 3244 : 
; 3245 :         break;

  01028	eb ca		 jmp	 SHORT $L71341
$L71290:

; 3135 :       /******************************************************************/
; 3136 :       /*  The sample rate equals 11025 Hz.                              */
; 3137 :       /******************************************************************/
; 3138 : 
; 3139 :       case 11025:
; 3140 : 
; 3141 :         switch ( pWaveFormat->nChannels )
; 3142 :         {

  0102a	33 c0		 xor	 eax, eax
  0102c	66 8b 46 02	 mov	 ax, WORD PTR [esi+2]
  01030	48		 dec	 eax
  01031	74 05		 je	 SHORT $L71295
  01033	48		 dec	 eax
  01034	74 be		 je	 SHORT $L71341
  01036	eb c2		 jmp	 SHORT $L71361
$L71295:

; 3143 :         case 1:
; 3144 : 
; 3145 :           switch ( pWaveFormat->wBitsPerSample )
; 3146 :           {

  01038	33 d2		 xor	 edx, edx
  0103a	66 8b 56 0e	 mov	 dx, WORD PTR [esi+14]
  0103e	89 54 24 20	 mov	 DWORD PTR 12+[esp+20], edx

; 3329 : 
; 3330 :     default:
; 3331 : 
; 3332 :       bIsStandardFormat = FALSE;;
; 3333 :       break;
; 3334 :     }
; 3335 : 
; 3336 :     if ( bIsStandardFormat )

  01042	eb b0		 jmp	 SHORT $L71341
$L72064:

; 3337 :     {
; 3338 :       /******************************************************************/
; 3339 :       /*  Get the wave output device capabilities.                      */
; 3340 :       /*  First allocate memory for the WAVEOUTCAPS structure.          */
; 3341 :       /******************************************************************/
; 3342 : 
; 3343 :       LOCK_MME_CALL(
; 3344 :         pWaveOutCaps = (LPWAVEOUTCAPS)ALLOCATE_SERVER_MEM(sizeof(WAVEOUTCAPS)))

  01044	6a 34		 push	 52			; 00000034H
  01046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0104c	8b d8		 mov	 ebx, eax

; 3345 : 
; 3346 :       if ( pWaveOutCaps == NULL )

  0104e	33 f6		 xor	 esi, esi
  01050	83 c4 04	 add	 esp, 4
  01053	3b de		 cmp	 ebx, esi
  01055	75 0d		 jne	 SHORT $L71365
  01057	5f		 pop	 edi
  01058	5e		 pop	 esi
  01059	5d		 pop	 ebp

; 3347 :       {
; 3348 :         return MMSYSERR_NOMEM;

  0105a	b8 07 00 00 00	 mov	 eax, 7
  0105f	5b		 pop	 ebx

; 3409 : }

  01060	83 c4 08	 add	 esp, 8
  01063	c3		 ret	 0
$L71365:

; 3349 :       }
; 3350 : 
; 3351 :       /******************************************************************/
; 3352 :       /*  Test for the supported format.                                */
; 3353 :       /******************************************************************/
; 3354 : 
; 3355 :       bGotDeviceID = FALSE;
; 3356 : 
; 3357 :       for ( uiDeviceID = 0;
; 3358 :             uiDeviceID <= uiNumberOfWaveOutDevices - 1;
; 3359 :             uiDeviceID++ )

  01064	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__waveOutGetDevCapsA@12
  0106a	89 74 24 10	 mov	 DWORD PTR _bGotDeviceID$[esp+24], esi
$L71366:

; 3360 :       {
; 3361 :         LOCK_MME_CALL(
; 3362 :           mmStatus = waveOutGetDevCaps( uiDeviceID,
; 3363 :                                         pWaveOutCaps,
; 3364 :                                         sizeof(WAVEOUTCAPS)))

  0106e	6a 34		 push	 52			; 00000034H
  01070	53		 push	 ebx
  01071	56		 push	 esi
  01072	ff d5		 call	 ebp
  01074	8b f8		 mov	 edi, eax

; 3365 : 	 
; 3366 :         if ( mmStatus )

  01076	85 ff		 test	 edi, edi
  01078	75 21		 jne	 SHORT $L71368

; 3367 :         {
; 3368 :           break;
; 3369 :         }
; 3370 : 
; 3371 :         if ( pWaveOutCaps->dwFormats == dwDesiredFormat )

  0107a	83 7b 28 07	 cmp	 DWORD PTR [ebx+40], 7
  0107e	74 0c		 je	 SHORT $L72058
  01080	8b 44 24 20	 mov	 eax, DWORD PTR _uiNumberOfWaveOutDevices$[esp+20]
  01084	46		 inc	 esi
  01085	48		 dec	 eax
  01086	3b f0		 cmp	 esi, eax
  01088	76 e4		 jbe	 SHORT $L71366
  0108a	eb 0f		 jmp	 SHORT $L71368
$L72058:

; 3372 :         {
; 3373 :           bGotDeviceID = TRUE;
; 3374 :           pPlayAudio->uiSelectedDeviceID = uiDeviceID;

  0108c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _pPlayAudio$[esp+20]
  01090	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _bGotDeviceID$[esp+24], 1
  01098	89 71 20	 mov	 DWORD PTR [ecx+32], esi
$L71368:

; 3375 :           break;
; 3376 :         }
; 3377 :       }
; 3378 : 
; 3379 :       /******************************************************************/
; 3380 :       /*  Free memory for the WAVEOUTCAPS structure.                    */
; 3381 :       /******************************************************************/
; 3382 : 
; 3383 :       LOCK_MME_CALL( FREE_SERVER_MEM( pWaveOutCaps ))

  0109b	53		 push	 ebx
  0109c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free

; 3384 : 	  
; 3385 :       /******************************************************************/
; 3386 :       /*  If no device supported the format then return an error.       */
; 3387 :       /******************************************************************/
; 3388 : 	  
; 3389 :       if ( ! bGotDeviceID )

  010a2	8b 44 24 14	 mov	 eax, DWORD PTR _bGotDeviceID$[esp+28]
  010a6	83 c4 04	 add	 esp, 4
  010a9	85 c0		 test	 eax, eax
  010ab	0f 85 55 ff ff
	ff		 jne	 $L71373

; 3403 : 
; 3404 :       mmStatus = MMSYSERR_NOTSUPPORTED;

  010b1	bf 08 00 00 00	 mov	 edi, 8

; 3405 :     }
; 3406 :   }
; 3407 : 
; 3408 :   return mmStatus;

  010b6	8b c7		 mov	 eax, edi
  010b8	5f		 pop	 edi
  010b9	5e		 pop	 esi
  010ba	5d		 pop	 ebp
  010bb	5b		 pop	 ebx

; 3409 : }

  010bc	83 c4 08	 add	 esp, 8
  010bf	c3		 ret	 0
_DetermineDeviceID ENDP
_TEXT	ENDS
PUBLIC	__real@8@4008fa00000000000000
EXTRN	__ftol:NEAR
EXTRN	__fltused:NEAR
EXTRN	_OP_ExitThread:NEAR
;	COMDAT __real@8@4008fa00000000000000
; File D:\work\product\dapi\src\NT\playaud.c
CONST	SEGMENT
__real@8@4008fa00000000000000 DQ 0408f400000000000r ; 1000
CONST	ENDS
_TEXT	SEGMENT
_pPlayAudio$ = 8
_uiStartupTimeoutTime$ = -24
_bDidBlock$ = -20
_dwSyncMarkPosition$ = -28
_dwCurrentPosition$ = 8
_pPlayAudioRing$ = -32
_TimerThreadMain PROC NEAR

; 3505 : {

  010c0	83 ec 20	 sub	 esp, 32			; 00000020H
  010c3	55		 push	 ebp
  010c4	56		 push	 esi

; 3506 :   unsigned int uiAvgBytesPerSec;
; 3507 :   unsigned int uiFlowCheckTime;
; 3508 :   unsigned int uiLastQueueCount;
; 3509 :   unsigned int uiCurrentQueueCount;
; 3510 :   unsigned int uiStartupTimeoutTime;
; 3511 :   unsigned int uiElapsedTime;
; 3512 :   unsigned int uiWaitTime;
; 3513 :   BOOL	bDidBlock=FALSE;	//tek 28jan98 BATS 532 reduce CPU consumption
; 3514 :   DWORD dwSyncMarkPosition=0;
; 3515 :   DWORD dwCurrentPosition;
; 3516 :   MMRESULT mmStatus;
; 3517 :   ATYPE_T aSyncMarkTag;
; 3518 :   LPSYNC_MARK_T pSyncMark;
; 3519 :   LPSYNC_MARK_T pNextSyncMark;
; 3520 :   LPPLAY_RING_T pPlayAudioRing;
; 3521 : 
; 3522 :   /********************************************************************/
; 3523 :   /*  Initialize the timer count to 0. This is used to count the      */
; 3524 :   /*  number of consecutive times that audio is in the queue and the  */
; 3525 :   /*  audio device is not active.                                     */
; 3526 :   /********************************************************************/
; 3527 : 
; 3528 :   uiElapsedTime = 0;
; 3529 : 
; 3530 :   pPlayAudioRing = pPlayAudio->pPlayAudioRing;

  010c5	8b 74 24 2c	 mov	 esi, DWORD PTR _pPlayAudio$[esp+36]
  010c9	33 ed		 xor	 ebp, ebp
  010cb	89 6c 24 0c	 mov	 DWORD PTR _dwSyncMarkPosition$[esp+40], ebp
  010cf	8b 86 98 00 00
	00		 mov	 eax, DWORD PTR [esi+152]
  010d5	89 44 24 08	 mov	 DWORD PTR _pPlayAudioRing$[esp+40], eax

; 3531 : 
; 3532 :   /********************************************************************/
; 3533 :   /*  Loop forever until thread shutdown time.                        */
; 3534 :   /********************************************************************/
; 3535 : 
; 3536 :   while( ! pPlayAudio->bTimerExit )

  010d9	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  010dc	85 c0		 test	 eax, eax
  010de	0f 85 d5 03 00
	00		 jne	 $L72078
  010e4	53		 push	 ebx
  010e5	57		 push	 edi
$L71394:

; 3537 :   {
; 3538 :     pPlayAudio->bTimerThreadReset = FALSE;
; 3539 : 	bDidBlock = FALSE; //tek 28jan98 keep track when we block ourselves
; 3540 : 
; 3541 :     /******************************************************************/
; 3542 :     /******************************************************************/
; 3543 :     /*  If audio is playing then test to see if there are any         */
; 3544 :     /*  synchronization marks that need to be reported.               */
; 3545 :     /*  If there are then get the current "play audio" position.      */
; 3546 :     /******************************************************************/
; 3547 :     /******************************************************************/
; 3548 : 
; 3549 :     if (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )
; 3550 :         && ( pPlayAudio->pSyncMarkList != NULL ))

  010e6	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  010e9	bb 02 00 00 00	 mov	 ebx, 2
  010ee	33 ff		 xor	 edi, edi
  010f0	3b c3		 cmp	 eax, ebx
  010f2	89 7e 6c	 mov	 DWORD PTR [esi+108], edi
  010f5	89 7c 24 1c	 mov	 DWORD PTR _bDidBlock$[esp+48], edi
  010f9	75 29		 jne	 SHORT $L71397
  010fb	39 be 9c 00 00
	00		 cmp	 DWORD PTR [esi+156], edi
  01101	74 21		 je	 SHORT $L71397

; 3551 :     {
; 3552 :       /****************************************************************/
; 3553 :       /*  Get the current audio position.                             */
; 3554 :       /****************************************************************/
; 3555 : 
; 3556 :       mmStatus = PA_GetPosition( pPlayAudio,
; 3557 :                                  &dwCurrentPosition,
; 3558 :                                  FALSE );

  01103	8d 4c 24 34	 lea	 ecx, DWORD PTR _dwCurrentPosition$[esp+44]
  01107	57		 push	 edi
  01108	51		 push	 ecx
  01109	56		 push	 esi
  0110a	e8 00 00 00 00	 call	 _PA_GetPosition
  0110f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3559 :       if ( mmStatus )

  01112	3b c7		 cmp	 eax, edi
  01114	74 48		 je	 SHORT $L72071

; 3560 :       {
; 3561 : #ifdef AUD_DEBUG
; 3562 : 		OutputDebugString("TimerThreadMain: PA_GetPosition failed {1}\n");
; 3563 : #endif
; 3564 :         ReportStatusToApplication( pPlayAudio,
; 3565 :                                    PA_SYNC_ERROR,
; 3566 :                                    mmStatus );

  01116	50		 push	 eax
  01117	6a 05		 push	 5
  01119	56		 push	 esi
  0111a	e8 00 00 00 00	 call	 _ReportStatusToApplication
  0111f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3567 :       }
; 3568 :     }
; 3569 :     else

  01122	eb 3a		 jmp	 SHORT $L72071
$L71397:

; 3570 :     {
; 3571 :       /****************************************************************/
; 3572 :       /*  In case the audio device becomes active between this if     */
; 3573 :       /*  statement and the following code (this will only happen     */
; 3574 :       /*  very infrequently) make sure that the current position      */
; 3575 :       /*  variable is less than any non-zero synchronization mark     */
; 3576 :       /*  position.                                                   */
; 3577 :       /****************************************************************/
; 3578 : 
; 3579 :       OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  01124	8b 96 8c 00 00
	00		 mov	 edx, DWORD PTR [esi+140]
  0112a	52		 push	 edx
  0112b	e8 00 00 00 00	 call	 _OP_LockMutex

; 3580 : 
; 3581 :       if ( pPlayAudio->pSyncMarkList != NULL )

  01130	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  01136	83 c4 04	 add	 esp, 4
  01139	3b c7		 cmp	 eax, edi
  0113b	74 12		 je	 SHORT $L71403

; 3582 :       {
; 3583 :         if ( pPlayAudio->pSyncMarkList->dwPosition == 0 )

  0113d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  01140	3b c7		 cmp	 eax, edi
  01142	75 06		 jne	 SHORT $L71402

; 3584 :         {
; 3585 :           dwCurrentPosition = 0;

  01144	89 7c 24 34	 mov	 DWORD PTR _dwCurrentPosition$[esp+44], edi

; 3586 :         }
; 3587 :         else

  01148	eb 05		 jmp	 SHORT $L71403
$L71402:

; 3588 :         {
; 3589 :           dwCurrentPosition = pPlayAudio->pSyncMarkList->dwPosition - 1;

  0114a	48		 dec	 eax
  0114b	89 44 24 34	 mov	 DWORD PTR _dwCurrentPosition$[esp+44], eax
$L71403:

; 3590 :         }
; 3591 :       }
; 3592 : 
; 3593 :       OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  0114f	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  01155	50		 push	 eax
  01156	e8 00 00 00 00	 call	 _OP_UnlockMutex
  0115b	83 c4 04	 add	 esp, 4
$L72071:

; 3594 :     }
; 3595 : 
; 3596 :     /******************************************************************/
; 3597 :     /******************************************************************/
; 3598 :     /*  If audio is playing then loop while there are synchronization */
; 3599 :     /*  marks that need to be reported. Don't bother if the audio is  */
; 3600 :     /*  paused.                                                       */
; 3601 :     /******************************************************************/
; 3602 :     /******************************************************************/
; 3603 : 
; 3604 :     while (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )
; 3605 :         && ( pPlayAudio->pSyncMarkList != NULL )
; 3606 :         && ( ! pPlayAudio->bPaused )
; 3607 :         && ( ! pPlayAudio->bTimerThreadReset ))

  0115e	39 5e 34	 cmp	 DWORD PTR [esi+52], ebx
  01161	0f 85 3d 01 00
	00		 jne	 $L71407
$L71406:
  01167	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  0116d	85 c0		 test	 eax, eax
  0116f	0f 84 2f 01 00
	00		 je	 $L71407
  01175	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  01178	85 c0		 test	 eax, eax
  0117a	0f 85 24 01 00
	00		 jne	 $L71407
  01180	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  01183	85 c0		 test	 eax, eax
  01185	0f 85 19 01 00
	00		 jne	 $L71407

; 3608 :     {
; 3609 :       /****************************************************************/
; 3610 :       /*  See if the marked position has been encountered yet.        */
; 3611 :       /*  Synchonization mark information is protected by mutex's in  */
; 3612 :       /*  case the synchronization linked list is emptied when the    */
; 3613 :       /*  PA_Reset() function is called.                              */
; 3614 :       /****************************************************************/
; 3615 : 
; 3616 :       OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  0118b	8b 8e 8c 00 00
	00		 mov	 ecx, DWORD PTR [esi+140]
  01191	51		 push	 ecx
  01192	e8 00 00 00 00	 call	 _OP_LockMutex

; 3617 : 
; 3618 :       pSyncMark = pPlayAudio->pSyncMarkList;

  01197	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  0119d	83 c4 04	 add	 esp, 4

; 3619 : 
; 3620 :       if ( pSyncMark != NULL )

  011a0	85 c0		 test	 eax, eax
  011a2	74 09		 je	 SHORT $L71409

; 3621 :       {
; 3622 :         dwSyncMarkPosition = pSyncMark->dwPosition;

  011a4	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  011a7	89 54 24 14	 mov	 DWORD PTR _dwSyncMarkPosition$[esp+48], edx
  011ab	8b ea		 mov	 ebp, edx
$L71409:

; 3623 :       }
; 3624 : 
; 3625 :       OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  011ad	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  011b3	50		 push	 eax
  011b4	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 3626 : 
; 3627 :       /****************************************************************/
; 3628 :       /*  Tsst to see if the position counter has wrapped back to     */
; 3629 :       /*  zero. This will only happen after audio has been playing a  */
; 3630 :       /*  very long time. The marked position count and the current   */
; 3631 :       /*  position count can only differ by the time it takes to play */
; 3632 :       /*  all of the audio in the ring buffer. This is at most a few  */
; 3633 :       /*  seconds, even at the lowest supported sample rate. So if    */
; 3634 :       /*  the wait time is more than a few seconds then the position  */
; 3635 :       /*  count has wrapped and the synchronization mark should be    */
; 3636 :       /*  reported immediately.                                       */
; 3637 :       /****************************************************************/
; 3638 : 
; 3639 :       uiWaitTime = dwSyncMarkPosition - dwCurrentPosition;

  011b9	8b 44 24 38	 mov	 eax, DWORD PTR _dwCurrentPosition$[esp+48]
  011bd	8b fd		 mov	 edi, ebp
  011bf	83 c4 04	 add	 esp, 4
  011c2	2b f8		 sub	 edi, eax

; 3640 : 
; 3641 :       while (( dwCurrentPosition < dwSyncMarkPosition )
; 3642 :         && ( uiWaitTime < POSITION_COUNT_WRAP_TIME )
; 3643 :         && ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )
; 3644 :         && ( pPlayAudio->pSyncMarkList != NULL )
; 3645 :         && ( ! pPlayAudio->bPaused )
; 3646 :         && ( ! pPlayAudio->bTimerThreadReset ))

  011c4	3b c5		 cmp	 eax, ebp
  011c6	73 5b		 jae	 SHORT $L71413
$L71412:
  011c8	81 ff 40 42 0f
	00		 cmp	 edi, 1000000		; 000f4240H
  011ce	73 53		 jae	 SHORT $L71413
  011d0	39 5e 34	 cmp	 DWORD PTR [esi+52], ebx
  011d3	75 4e		 jne	 SHORT $L71413
  011d5	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  011db	85 c0		 test	 eax, eax
  011dd	74 44		 je	 SHORT $L71413
  011df	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  011e2	85 c0		 test	 eax, eax
  011e4	75 3d		 jne	 SHORT $L71413
  011e6	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  011e9	85 c0		 test	 eax, eax
  011eb	75 36		 jne	 SHORT $L71413

; 3647 :       {
; 3648 :         if ( uiWaitTime > MAXIMUM_POSITION_SLEEP_TIME )

  011ed	83 ff 64	 cmp	 edi, 100		; 00000064H
  011f0	76 05		 jbe	 SHORT $L71414

; 3649 :         {
; 3650 :           uiWaitTime = MAXIMUM_POSITION_SLEEP_TIME;

  011f2	bf 64 00 00 00	 mov	 edi, 100		; 00000064H
$L71414:

; 3651 :         }
; 3652 : 
; 3653 :         OP_Sleep( uiWaitTime );

  011f7	57		 push	 edi
  011f8	e8 00 00 00 00	 call	 _OP_Sleep

; 3654 : 
; 3655 :         /**************************************************************/
; 3656 :         /*  Get the current audio position.                           */
; 3657 :         /**************************************************************/
; 3658 : 
; 3659 :         mmStatus = PA_GetPosition( pPlayAudio,
; 3660 :                                    &dwCurrentPosition,
; 3661 :                                    FALSE );

  011fd	8d 4c 24 38	 lea	 ecx, DWORD PTR _dwCurrentPosition$[esp+48]
  01201	6a 00		 push	 0
  01203	51		 push	 ecx
  01204	56		 push	 esi
  01205	e8 00 00 00 00	 call	 _PA_GetPosition
  0120a	83 c4 10	 add	 esp, 16			; 00000010H

; 3662 : 
; 3663 :         if ( mmStatus )

  0120d	85 c0		 test	 eax, eax
  0120f	74 0c		 je	 SHORT $L71415

; 3664 :         {
; 3665 : #ifdef AUD_DEBUG
; 3666 : 		  OutputDebugString("TimerThreadMain: PA_GetPosition failed {2}\n");
; 3667 : #endif
; 3668 :           ReportStatusToApplication( pPlayAudio,
; 3669 :                                      PA_SYNC_ERROR,
; 3670 :                                      mmStatus );

  01211	50		 push	 eax
  01212	6a 05		 push	 5
  01214	56		 push	 esi
  01215	e8 00 00 00 00	 call	 _ReportStatusToApplication
  0121a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71415:
  0121d	39 6c 24 34	 cmp	 DWORD PTR _dwCurrentPosition$[esp+44], ebp
  01221	72 a5		 jb	 SHORT $L71412
$L71413:

; 3671 :         }
; 3672 :       }
; 3673 : 
; 3674 :       /****************************************************************/
; 3675 :       /*  Report the mark to the application.                         */
; 3676 :       /****************************************************************/
; 3677 : 
; 3678 :       OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  01223	8b 96 8c 00 00
	00		 mov	 edx, DWORD PTR [esi+140]
  01229	52		 push	 edx
  0122a	e8 00 00 00 00	 call	 _OP_LockMutex

; 3679 : 
; 3680 :       pSyncMark = pPlayAudio->pSyncMarkList;

  0122f	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  01235	83 c4 04	 add	 esp, 4

; 3681 : 
; 3682 :       if (( pSyncMark != NULL )
; 3683 :         && (( dwCurrentPosition >= pSyncMark->dwPosition )
; 3684 :         || ( uiWaitTime >= POSITION_COUNT_WRAP_TIME ))
; 3685 :         && ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )
; 3686 :         && ( ! pPlayAudio->bTimerThreadReset ))

  01238	85 c0		 test	 eax, eax
  0123a	74 50		 je	 SHORT $L71417
  0123c	8b 4c 24 34	 mov	 ecx, DWORD PTR _dwCurrentPosition$[esp+44]
  01240	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  01243	3b ca		 cmp	 ecx, edx
  01245	73 08		 jae	 SHORT $L71418
  01247	81 ff 40 42 0f
	00		 cmp	 edi, 1000000		; 000f4240H
  0124d	72 3d		 jb	 SHORT $L71417
$L71418:
  0124f	39 5e 34	 cmp	 DWORD PTR [esi+52], ebx
  01252	75 38		 jne	 SHORT $L71417
  01254	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  01257	85 c9		 test	 ecx, ecx
  01259	75 31		 jne	 SHORT $L71417

; 3687 :       {
; 3688 :         /**************************************************************/
; 3689 :         /*  Remove the pointer to the next synchronization mark       */
; 3690 :         /*  structure from the top of the synchronization mark        */
; 3691 :         /*  linked list.                                              */
; 3692 :         /**************************************************************/
; 3693 : 
; 3694 :         aSyncMarkTag = pSyncMark->aTag;

  0125b	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 3695 :         pNextSyncMark = pSyncMark->pLink;

  0125e	8b 18		 mov	 ebx, DWORD PTR [eax]

; 3696 : 
; 3697 :         free( pSyncMark );

  01260	50		 push	 eax
  01261	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free

; 3698 : 
; 3699 :         pPlayAudio->pSyncMarkList = pNextSyncMark;
; 3700 : 
; 3701 :         OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  01267	8b 96 8c 00 00
	00		 mov	 edx, DWORD PTR [esi+140]
  0126d	89 9e 9c 00 00
	00		 mov	 DWORD PTR [esi+156], ebx
  01273	52		 push	 edx
  01274	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 3702 : 
; 3703 :         /**************************************************************/
; 3704 :         /*  Report the synchronization mark.                          */
; 3705 :         /**************************************************************/
; 3706 : 
; 3707 :         ReportStatusToApplication( pPlayAudio,
; 3708 :                                    PA_SYNC_MARK,
; 3709 :                                    aSyncMarkTag );

  01279	57		 push	 edi
  0127a	6a 04		 push	 4
  0127c	56		 push	 esi
  0127d	e8 00 00 00 00	 call	 _ReportStatusToApplication
  01282	83 c4 14	 add	 esp, 20			; 00000014H

; 3710 :       }
; 3711 :       else

  01285	bb 02 00 00 00	 mov	 ebx, 2
  0128a	eb 0f		 jmp	 SHORT $L71419
$L71417:

; 3712 :       {
; 3713 :         OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  0128c	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  01292	50		 push	 eax
  01293	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01298	83 c4 04	 add	 esp, 4
$L71419:
  0129b	39 5e 34	 cmp	 DWORD PTR [esi+52], ebx
  0129e	0f 84 c3 fe ff
	ff		 je	 $L71406
$L71407:

; 3714 :       }
; 3715 :     }
; 3716 : 
; 3717 :     /******************************************************************/
; 3718 :     /******************************************************************/
; 3719 :     /*  If audio is NOT playing and the system is NOT paused and      */
; 3720 :     /*  there are samples in the queue then test to see if it will    */
; 3721 :     /*  be necessary to start playing audio.                          */
; 3722 :     /******************************************************************/
; 3723 :     /******************************************************************/
; 3724 : 
; 3725 :     /******************************************************************/
; 3726 :     /*  Calculate how long to sleep.                                  */
; 3727 :     /******************************************************************/
; 3728 : 
; 3729 : 		// 22may97 tek remove KSBs NEED_FOR_SPEED.
; 3730 :     OP_LockMutex( pPlayAudio->hmxWaveFormat );

  012a4	8b 8e 90 00 00
	00		 mov	 ecx, DWORD PTR [esi+144]
  012aa	51		 push	 ecx
  012ab	e8 00 00 00 00	 call	 _OP_LockMutex

; 3731 :     uiAvgBytesPerSec = pPlayAudio->pWaveFormat->nAvgBytesPerSec;

  012b0	8b 96 a0 00 00
	00		 mov	 edx, DWORD PTR [esi+160]

; 3732 :     OP_UnlockMutex( pPlayAudio->hmxWaveFormat );

  012b6	8b 86 90 00 00
	00		 mov	 eax, DWORD PTR [esi+144]
  012bc	50		 push	 eax
  012bd	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
  012c0	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 3733 : 
; 3734 :     uiStartupTimeoutTime = (unsigned int)( 1000.0 *
; 3735 :       (double)(pPlayAudio->uiMinimumStartupBytes) /
; 3736 :         (double)uiAvgBytesPerSec );

  012c5	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  012c8	33 c0		 xor	 eax, eax
  012ca	89 4c 24 28	 mov	 DWORD PTR -16+[esp+56], ecx
  012ce	89 44 24 2c	 mov	 DWORD PTR -16+[esp+60], eax
  012d2	df 6c 24 28	 fild	 QWORD PTR -16+[esp+56]
  012d6	89 7c 24 30	 mov	 DWORD PTR -8+[esp+56], edi
  012da	89 44 24 34	 mov	 DWORD PTR -8+[esp+60], eax
  012de	83 c4 08	 add	 esp, 8
  012e1	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@8@4008fa00000000000000
  012e7	df 6c 24 28	 fild	 QWORD PTR -8+[esp+48]
  012eb	de f9		 fdivp	 ST(1), ST(0)
  012ed	e8 00 00 00 00	 call	 __ftol

; 3737 : 
; 3738 :     /******************************************************************/
; 3739 :     /*  Limit the total startup check wait time to 1 second.          */
; 3740 :     /******************************************************************/
; 3741 : 
; 3742 :     if ( uiStartupTimeoutTime > 1000 )

  012f2	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  012f7	89 44 24 18	 mov	 DWORD PTR _uiStartupTimeoutTime$[esp+48], eax
  012fb	76 08		 jbe	 SHORT $L72073

; 3743 :     {
; 3744 :       uiStartupTimeoutTime = 1000;

  012fd	c7 44 24 18 e8
	03 00 00	 mov	 DWORD PTR _uiStartupTimeoutTime$[esp+48], 1000 ; 000003e8H
$L72073:

; 3745 :     }
; 3746 : 
; 3747 :     while (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )
; 3748 :       && ( ! pPlayAudio->bPaused )
; 3749 :       && ( pPlayAudio->pPlayAudioRing->iQueueCount > 0 ))

  01305	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  01308	85 c0		 test	 eax, eax
  0130a	0f 85 a1 00 00
	00		 jne	 $L72076
  01310	eb 09		 jmp	 SHORT $L71425
$L72084:
  01312	8b 6c 24 14	 mov	 ebp, DWORD PTR _dwSyncMarkPosition$[esp+48]
  01316	bb 02 00 00 00	 mov	 ebx, 2
$L71425:
  0131b	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  0131e	85 c0		 test	 eax, eax
  01320	0f 85 8b 00 00
	00		 jne	 $L72076
  01326	8b 96 98 00 00
	00		 mov	 edx, DWORD PTR [esi+152]
  0132c	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0132f	85 c0		 test	 eax, eax
  01331	7e 7e		 jle	 SHORT $L72076

; 3750 :     {
; 3751 : 		// 22may97 tek remove KSBs NEED_FOR_SPEED.
; 3752 :       /****************************************************************/
; 3753 :       /*  Wait for "uiStartupTimeoutTime" milliseconds.               */
; 3754 :       /****************************************************************/
; 3755 : 
; 3756 :       uiElapsedTime = 0;
; 3757 :       uiFlowCheckTime = 0;
; 3758 :       uiLastQueueCount = pPlayAudioRing->iQueueCount;

  01333	8b 44 24 10	 mov	 eax, DWORD PTR _pPlayAudioRing$[esp+48]
  01337	33 ed		 xor	 ebp, ebp
  01339	33 ff		 xor	 edi, edi
  0133b	8b 58 18	 mov	 ebx, DWORD PTR [eax+24]

; 3759 : 
; 3760 :       while (( uiElapsedTime < uiStartupTimeoutTime )
; 3761 :         && ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE ))

  0133e	8b 44 24 18	 mov	 eax, DWORD PTR _uiStartupTimeoutTime$[esp+48]
  01342	85 c0		 test	 eax, eax
  01344	76 31		 jbe	 SHORT $L72075
$L71428:
  01346	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  01349	85 c0		 test	 eax, eax
  0134b	75 5b		 jne	 SHORT $L72087

; 3762 :       {
; 3763 :         OP_Sleep( TIMER_SLEEP_TIME_IN_MSEC );

  0134d	6a 0a		 push	 10			; 0000000aH
  0134f	e8 00 00 00 00	 call	 _OP_Sleep

; 3764 : 
; 3765 :         uiElapsedTime += TIMER_SLEEP_TIME_IN_MSEC;
; 3766 :         uiFlowCheckTime += TIMER_SLEEP_TIME_IN_MSEC;

  01354	83 c7 0a	 add	 edi, 10			; 0000000aH
  01357	83 c4 04	 add	 esp, 4
  0135a	83 c5 0a	 add	 ebp, 10			; 0000000aH

; 3767 : 
; 3768 :         /**************************************************************/
; 3769 :         /*  If the queue input flow rate to the PA_Queue() function   */
; 3770 :         /*  has been slower than real-time over the entire            */
; 3771 :         /*  QUEUE_FLOW_CHECK_TIME_IN_MSEC interval then start the     */
; 3772 :         /*  open now.                                                 */
; 3773 :         /**************************************************************/
; 3774 : 
; 3775 :         if ( uiFlowCheckTime > QUEUE_FLOW_CHECK_TIME_IN_MSEC )

  0135d	83 ff 64	 cmp	 edi, 100		; 00000064H
  01360	76 0f		 jbe	 SHORT $L71430

; 3776 :         {
; 3777 :           uiCurrentQueueCount = (unsigned int)pPlayAudioRing->iQueueCount;

  01362	8b 4c 24 10	 mov	 ecx, DWORD PTR _pPlayAudioRing$[esp+48]
  01366	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]

; 3778 : 
; 3779 :           if ( uiCurrentQueueCount == uiLastQueueCount )

  01369	3b c3		 cmp	 eax, ebx
  0136b	74 0a		 je	 SHORT $L72075

; 3780 :           {
; 3781 :             break;
; 3782 :           }
; 3783 : 
; 3784 :           uiLastQueueCount = uiCurrentQueueCount;

  0136d	8b d8		 mov	 ebx, eax

; 3785 :           uiFlowCheckTime = 0;

  0136f	33 ff		 xor	 edi, edi
$L71430:
  01371	3b 6c 24 18	 cmp	 ebp, DWORD PTR _uiStartupTimeoutTime$[esp+48]
  01375	72 cf		 jb	 SHORT $L71428
$L72075:

; 3786 :         }
; 3787 :       }
; 3788 : 
; 3789 :       /****************************************************************/
; 3790 :       /*  If the audio device starts playing then exit this loop.     */
; 3791 :       /****************************************************************/
; 3792 : 
; 3793 :       if ( pPlayAudio->dwAudioDeviceState != AUDIO_DEVICE_INACTIVE )

  01377	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0137a	85 c0		 test	 eax, eax
  0137c	75 2a		 jne	 SHORT $L72087

; 3794 :       {
; 3795 :         break;
; 3796 :       }
; 3797 : 
; 3798 :       /****************************************************************/
; 3799 :       /*  If audio is still NOT playing and there are samples in the  */
; 3800 :       /*  audio queue then start playing audio. It does not matter    */
; 3801 :       /*  that all of the tests this section of code are not          */
; 3802 :       /*  protected by mutex's. This is because an unnecessary        */
; 3803 :       /*  ID_Open_Wave_Output_Device messages will be discarded in    */
; 3804 :       /*  the "play audio" thread.                                    */
; 3805 :       /****************************************************************/
; 3806 : 
; 3807 :       if (( pPlayAudio->dwAudioDeviceState != AUDIO_DEVICE_ACTIVE )
; 3808 :         && ( pPlayAudioRing->iQueueCount > 0 ))

  0137e	8b 54 24 10	 mov	 edx, DWORD PTR _pPlayAudioRing$[esp+48]
  01382	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  01385	85 c0		 test	 eax, eax
  01387	7e 0d		 jle	 SHORT $L71434

; 3809 :       {
; 3810 :         SendPlayAudioMessage( pPlayAudio,
; 3811 :                               ID_Open_Wave_Output_Device,
; 3812 :                               0L );

  01389	6a 00		 push	 0
  0138b	6a 00		 push	 0
  0138d	56		 push	 esi
  0138e	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  01393	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71434:

; 3813 :       }
; 3814 : 
; 3815 :       /****************************************************************/
; 3816 :       /*  Test for thread shutdown. Shutdown is caused by the         */
; 3817 :       /*  PA_DestroyPlayHandle() function.                            */
; 3818 :       /****************************************************************/
; 3819 : 
; 3820 :       if ( pPlayAudio->bTimerExit )

  01396	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  01399	85 c0		 test	 eax, eax
  0139b	75 0b		 jne	 SHORT $L72087
  0139d	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  013a0	85 c0		 test	 eax, eax
  013a2	0f 84 6a ff ff
	ff		 je	 $L72084
$L72087:

; 3745 :     }
; 3746 : 
; 3747 :     while (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )
; 3748 :       && ( ! pPlayAudio->bPaused )
; 3749 :       && ( pPlayAudio->pPlayAudioRing->iQueueCount > 0 ))

  013a8	8b 6c 24 14	 mov	 ebp, DWORD PTR _dwSyncMarkPosition$[esp+48]
  013ac	bb 02 00 00 00	 mov	 ebx, 2
$L72076:

; 3821 :       {
; 3822 :         break;
; 3823 :       }
; 3824 :     }
; 3825 : 
; 3826 :     /******************************************************************/
; 3827 :     /*  This thread is blocked if there are no synchronization marks  */
; 3828 :     /*  waiting to be processed or the audio is paused and either     */
; 3829 :     /*  the audio device is active or the queue count is zero         */
; 3830 :     /******************************************************************/
; 3831 : 
; 3832 : 	//tek 07nov97 bats508
; 3833 : 	// as originally written, this code wants to take all the mutexes
; 3834 : 	// involved; it really need not do that, because if we make a
; 3835 : 	// mistake here we can always check before exit and fix it.
; 3836 :     OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  013b1	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  013b7	50		 push	 eax
  013b8	e8 00 00 00 00	 call	 _OP_LockMutex

; 3837 :     OP_LockMutex( pPlayAudio->hmxPauseFlag );

  013bd	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  013c3	51		 push	 ecx
  013c4	e8 00 00 00 00	 call	 _OP_LockMutex

; 3838 : 
; 3839 :     if ((( pPlayAudio->pSyncMarkList == NULL )
; 3840 :       || ( pPlayAudio->bPaused ))
; 3841 :       && ( ! pPlayAudio->bTimerExit ))

  013c9	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  013cf	83 c4 08	 add	 esp, 8
  013d2	85 c0		 test	 eax, eax
  013d4	74 0b		 je	 SHORT $L71438
  013d6	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  013d9	85 c0		 test	 eax, eax
  013db	0f 84 ea 00 00
	00		 je	 $L71437
$L71438:
  013e1	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  013e4	85 c0		 test	 eax, eax
  013e6	0f 85 df 00 00
	00		 jne	 $L71437

; 3842 :     {
; 3843 : 	  // let these go here.
; 3844 :       OP_UnlockMutex( pPlayAudio->hmxPauseFlag );

  013ec	8b 96 88 00 00
	00		 mov	 edx, DWORD PTR [esi+136]
  013f2	52		 push	 edx
  013f3	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 3845 :       OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  013f8	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  013fe	50		 push	 eax
  013ff	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 3846 :       OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  01404	8b 4e 70	 mov	 ecx, DWORD PTR [esi+112]
  01407	51		 push	 ecx
  01408	e8 00 00 00 00	 call	 _OP_LockMutex

; 3847 : 	  // tek 07nov97 bats508
; 3848 : 	  // don't need to hold the queue count mutex this early; move
; 3849 : 	  // it into the if branch
; 3850 :       //OP_LockMutex( pPlayAudio->hmxQueueCount );
; 3851 : 
; 3852 :       if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )

  0140d	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  01410	83 c4 0c	 add	 esp, 12			; 0000000cH
  01413	3b c3		 cmp	 eax, ebx
  01415	75 16		 jne	 SHORT $L71439

; 3853 :       {
; 3854 :         OP_ResetEvent( pPlayAudio->hevTimerThreadActive );

  01417	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0141a	52		 push	 edx
  0141b	e8 00 00 00 00	 call	 _OP_ResetEvent
  01420	83 c4 04	 add	 esp, 4

; 3855 : 		bDidBlock = TRUE; // tek 29jan98

  01423	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _bDidBlock$[esp+48], 1

; 3856 :       }
; 3857 :       else

  0142b	eb 37		 jmp	 SHORT $L71440
$L71439:

; 3858 :       {
; 3859 :       OP_LockMutex( pPlayAudio->hmxQueueCount );

  0142d	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  01430	50		 push	 eax
  01431	e8 00 00 00 00	 call	 _OP_LockMutex

; 3860 :         if ( pPlayAudioRing->iQueueCount == 0 )

  01436	8b 4c 24 14	 mov	 ecx, DWORD PTR _pPlayAudioRing$[esp+52]
  0143a	83 c4 04	 add	 esp, 4
  0143d	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  01440	85 c0		 test	 eax, eax
  01442	75 14		 jne	 SHORT $L71441

; 3861 :         {
; 3862 :           OP_ResetEvent( pPlayAudio->hevTimerThreadActive );

  01444	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  01447	52		 push	 edx
  01448	e8 00 00 00 00	 call	 _OP_ResetEvent
  0144d	83 c4 04	 add	 esp, 4

; 3863 : 		  bDidBlock = TRUE; // tek 29jan98

  01450	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _bDidBlock$[esp+48], 1
$L71441:

; 3864 :         }
; 3865 : 	  // tek 07nov97 move this in closer
; 3866 :       OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  01458	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  0145b	50		 push	 eax
  0145c	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01461	83 c4 04	 add	 esp, 4
$L71440:

; 3867 :       }
; 3868 : 
; 3869 : 
; 3870 :       OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  01464	8b 4e 70	 mov	 ecx, DWORD PTR [esi+112]
  01467	51		 push	 ecx
  01468	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 3877 : 	}
; 3878 : 
; 3879 : 	// tek 07nov97 moved inside the if..
; 3880 :     //OP_UnlockMutex( pPlayAudio->hmxPauseFlag );
; 3881 :     //OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );
; 3882 : 
; 3883 : 
; 3884 : 	// tek 07nov97 
; 3885 : 	// now, after all that, it is (I suppose) possible that 
; 3886 : 	// something happened that might cause us to not block;
; 3887 : 	// we'll just check those cases here after the fact, and 
; 3888 : 	// unblock ourselves.
; 3889 : 	// tek 28jan98 be careful here, or we'll suck down all the CPU.
; 3890 : 	if (bDidBlock)

  0146d	8b 44 24 20	 mov	 eax, DWORD PTR _bDidBlock$[esp+52]
  01471	83 c4 04	 add	 esp, 4
  01474	85 c0		 test	 eax, eax
  01476	74 26		 je	 SHORT $L71445

; 3891 : 	{
; 3892 : 		if (   (pPlayAudio->pSyncMarkList != NULL )
; 3893 : 				 ||(   (pPlayAudioRing->iQueueCount != 0 )
; 3894 : 					&& (pPlayAudio->dwAudioDeviceState != AUDIO_DEVICE_ACTIVE)
; 3895 : 				   )
; 3896 : 		   )

  01478	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  0147e	85 c0		 test	 eax, eax
  01480	75 10		 jne	 SHORT $L71446
  01482	8b 4c 24 10	 mov	 ecx, DWORD PTR _pPlayAudioRing$[esp+48]
  01486	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  01489	85 c0		 test	 eax, eax
  0148b	74 11		 je	 SHORT $L71445
  0148d	39 5e 34	 cmp	 DWORD PTR [esi+52], ebx
  01490	74 0c		 je	 SHORT $L71445
$L71446:

; 3897 : 		{
; 3898 : 			OP_SetEvent( pPlayAudio->hevTimerThreadActive );

  01492	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  01495	52		 push	 edx
  01496	e8 00 00 00 00	 call	 _OP_SetEvent
  0149b	83 c4 04	 add	 esp, 4
$L71445:

; 3899 : 		}
; 3900 : 	}
; 3901 : 
; 3902 :     /******************************************************************/
; 3903 :     /*  Wait for the thread to unblock.                               */
; 3904 :     /******************************************************************/
; 3905 : 
; 3906 :     OP_WaitForEvent( pPlayAudio->hevTimerThreadActive, OP_INFINITE );

  0149e	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  014a1	6a ff		 push	 -1
  014a3	50		 push	 eax
  014a4	e8 00 00 00 00	 call	 _OP_WaitForEvent

; 3907 : 
; 3908 :     /******************************************************************/
; 3909 :     /*  Test for thread shutdown. Shutdown is caused by the           */
; 3910 :     /*  PA_DestroyPlayHandle() function.                              */
; 3911 :     /******************************************************************/
; 3912 : 
; 3913 :     if ( pPlayAudio->bTimerExit )

  014a9	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  014ac	83 c4 08	 add	 esp, 8
  014af	85 c0		 test	 eax, eax
  014b1	0f 84 2f fc ff
	ff		 je	 $L71394
  014b7	5f		 pop	 edi
  014b8	5b		 pop	 ebx
$L72078:

; 3914 :     {
; 3915 :       break;
; 3916 :     }
; 3917 :   }
; 3918 : 
; 3919 :   /********************************************************************/
; 3920 :   /*  Exit the thread.                                                */
; 3921 :   /********************************************************************/
; 3922 : 
; 3923 :   OP_ExitThread( 0 );

  014b9	6a 00		 push	 0
  014bb	e8 00 00 00 00	 call	 _OP_ExitThread
  014c0	83 c4 04	 add	 esp, 4

; 3924 : 
; 3925 :   OP_THREAD_RETURN;

  014c3	33 c0		 xor	 eax, eax
  014c5	5e		 pop	 esi
  014c6	5d		 pop	 ebp

; 3926 : }

  014c7	83 c4 20	 add	 esp, 32			; 00000020H
  014ca	c3		 ret	 0
$L71437:

; 3871 :     }
; 3872 : 	else
; 3873 : 	{
; 3874 : 		// tek 07nov97 gotta let these go..
; 3875 :     OP_UnlockMutex( pPlayAudio->hmxPauseFlag );

  014cb	8b 96 88 00 00
	00		 mov	 edx, DWORD PTR [esi+136]
  014d1	52		 push	 edx
  014d2	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 3876 :     OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  014d7	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  014dd	50		 push	 eax
  014de	e8 00 00 00 00	 call	 _OP_UnlockMutex
  014e3	83 c4 08	 add	 esp, 8

; 3877 : 	}
; 3878 : 
; 3879 : 	// tek 07nov97 moved inside the if..
; 3880 :     //OP_UnlockMutex( pPlayAudio->hmxPauseFlag );
; 3881 :     //OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );
; 3882 : 
; 3883 : 
; 3884 : 	// tek 07nov97 
; 3885 : 	// now, after all that, it is (I suppose) possible that 
; 3886 : 	// something happened that might cause us to not block;
; 3887 : 	// we'll just check those cases here after the fact, and 
; 3888 : 	// unblock ourselves.
; 3889 : 	// tek 28jan98 be careful here, or we'll suck down all the CPU.
; 3890 : 	if (bDidBlock)

  014e6	eb b6		 jmp	 SHORT $L71445
_TimerThreadMain ENDP
_uiMessage$ = -12
_pPlayAudio$ = -4
_aParam$ = -8
_PlayAudioThreadMain PROC NEAR

; 3945 :   unsigned int uiResult;
; 3946 :   unsigned int uiMessage;
; 3947 :   HPLAY_AUDIO_T pPlayAudio;
; 3948 :   ATYPE_T aParam;
; 3949 : 
; 3950 :   /********************************************************************/
; 3951 :   /*  Audio message loop.                                             */
; 3952 :   /********************************************************************/
; 3953 : 
; 3954 :   pShm_t->bGlobalPlayAudioThreadExit = FALSE;

  014f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  014f5	83 ec 0c	 sub	 esp, 12			; 0000000cH
  014f8	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 3955 : 
; 3956 :   while( ! pShm_t->bGlobalPlayAudioThreadExit )

  014ff	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  01504	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01507	85 c9		 test	 ecx, ecx
  01509	75 6d		 jne	 SHORT $L71457
$L71456:

; 3957 :   {
; 3958 :     ReadMessageQueue( pShm_t->pGlobalPlayAudioMessageQueue,
; 3959 :                       (LPATYPE_T)&pPlayAudio,
; 3960 :                       (LPATYPE_T)&uiMessage,
; 3961 :                       &aParam );

  0150b	8d 4c 24 04	 lea	 ecx, DWORD PTR _aParam$[esp+12]
  0150f	8d 54 24 00	 lea	 edx, DWORD PTR _uiMessage$[esp+12]
  01513	51		 push	 ecx
  01514	52		 push	 edx
  01515	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  01518	8d 4c 24 10	 lea	 ecx, DWORD PTR _pPlayAudio$[esp+20]
  0151c	51		 push	 ecx
  0151d	52		 push	 edx
  0151e	e8 00 00 00 00	 call	 _ReadMessageQueue

; 3962 :     uiResult = PlayAudioProcedure( pPlayAudio, uiMessage, aParam );

  01523	8b 44 24 14	 mov	 eax, DWORD PTR _aParam$[esp+28]
  01527	8b 4c 24 10	 mov	 ecx, DWORD PTR _uiMessage$[esp+28]
  0152b	8b 54 24 18	 mov	 edx, DWORD PTR _pPlayAudio$[esp+28]
  0152f	50		 push	 eax
  01530	51		 push	 ecx
  01531	52		 push	 edx
  01532	e8 00 00 00 00	 call	 _PlayAudioProcedure

; 3963 :     /******************************************************************/
; 3964 :     /*  If this is not a driver message then put result into the      */
; 3965 :     /*  report message queue.                                         */
; 3966 :     /******************************************************************/
; 3967 : 
; 3968 :     if  (( uiMessage != MM_WOM_OPEN )
; 3969 :       && ( uiMessage != MM_WOM_DONE )
; 3970 :       && ( uiMessage != MM_WOM_CLOSE ))

  01537	8b 4c 24 1c	 mov	 ecx, DWORD PTR _uiMessage$[esp+40]
  0153b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0153e	81 f9 bb 03 00
	00		 cmp	 ecx, 955		; 000003bbH
  01544	74 26		 je	 SHORT $L71460
  01546	81 f9 bd 03 00
	00		 cmp	 ecx, 957		; 000003bdH
  0154c	74 1e		 je	 SHORT $L71460
  0154e	81 f9 bc 03 00
	00		 cmp	 ecx, 956		; 000003bcH
  01554	74 16		 je	 SHORT $L71460

; 3971 :     {
; 3972 :       WriteMessageQueue( pShm_t->pGlobalReportMessageQueue,
; 3973 :                          (ATYPE_T)0,
; 3974 :                          (ATYPE_T)0,
; 3975 :                          (ATYPE_T)uiResult );

  01556	50		 push	 eax
  01557	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  0155c	6a 00		 push	 0
  0155e	6a 00		 push	 0
  01560	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  01563	51		 push	 ecx
  01564	e8 00 00 00 00	 call	 _WriteMessageQueue
  01569	83 c4 10	 add	 esp, 16			; 00000010H
$L71460:
  0156c	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  01571	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01574	85 c9		 test	 ecx, ecx
  01576	74 93		 je	 SHORT $L71456
$L71457:

; 3976 :     }
; 3977 :   }
; 3978 :   
; 3979 :   /********************************************************************/
; 3980 :   /*  Exit the thread.                                                */
; 3981 :   /********************************************************************/
; 3982 :  
; 3983 :   OP_ExitThread( 0 );

  01578	6a 00		 push	 0
  0157a	e8 00 00 00 00	 call	 _OP_ExitThread

; 3984 :   OP_THREAD_RETURN;

  0157f	33 c0		 xor	 eax, eax

; 3985 : }

  01581	83 c4 10	 add	 esp, 16			; 00000010H
  01584	c3		 ret	 0
_PlayAudioThreadMain ENDP
_pPlayAudio$ = 8
_uiMessage$ = 12
_aParam$ = 16
_PlayAudioProcedure PROC NEAR

; 4003 :   switch( uiMessage )
; 4004 :   {

  01590	8b 44 24 08	 mov	 eax, DWORD PTR _uiMessage$[esp-4]
  01594	3d bb 03 00 00	 cmp	 eax, 955		; 000003bbH
  01599	0f 87 e3 00 00
	00		 ja	 $L72095
  0159f	0f 84 ca 00 00
	00		 je	 $L71475
  015a5	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  015a8	0f 87 de 00 00
	00		 ja	 $L71494
  015ae	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72097[eax*4]
$L71478:

; 4033 : 
; 4034 :   /********************************************************************/
; 4035 :   /*  This message is sent by the the PA_Queue() function or by the   */
; 4036 :   /*  timer thread, "TimerThreadMain()", to open the wave output      */
; 4037 :   /*  device.                                                         */
; 4038 :   /********************************************************************/
; 4039 : 
; 4040 :   case ID_Open_Wave_Output_Device:
; 4041 :     return ProcessOpenWaveOutputDeviceMessage( pPlayAudio );

  015b5	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  015b9	50		 push	 eax
  015ba	e8 00 00 00 00	 call	 _ProcessOpenWaveOutputDeviceMessage
  015bf	83 c4 04	 add	 esp, 4

; 4131 : }

  015c2	c3		 ret	 0
$L71479:

; 4042 : 
; 4043 :   /********************************************************************/
; 4044 :   /*  An application uses this message to cancel audio output.        */
; 4045 :   /********************************************************************/
; 4046 : 
; 4047 :   case ID_Reset_Audio:
; 4048 :     return ProcessResetMessage( pPlayAudio );

  015c3	8b 4c 24 04	 mov	 ecx, DWORD PTR _pPlayAudio$[esp-4]
  015c7	51		 push	 ecx
  015c8	e8 00 00 00 00	 call	 _ProcessResetMessage
  015cd	83 c4 04	 add	 esp, 4

; 4131 : }

  015d0	c3		 ret	 0
$L71480:

; 4049 : 
; 4050 :   /********************************************************************/
; 4051 :   /*  An application uses this message to pause audio output.         */
; 4052 :   /********************************************************************/
; 4053 : 
; 4054 :   case ID_Pause_Audio:
; 4055 :     return ProcessPauseMessage( pPlayAudio );

  015d1	8b 54 24 04	 mov	 edx, DWORD PTR _pPlayAudio$[esp-4]
  015d5	52		 push	 edx
  015d6	e8 00 00 00 00	 call	 _ProcessPauseMessage
  015db	83 c4 04	 add	 esp, 4

; 4131 : }

  015de	c3		 ret	 0
$L71481:

; 4056 : 
; 4057 :   /********************************************************************/
; 4058 :   /*  An application uses this message to resume audio output.        */
; 4059 :   /********************************************************************/
; 4060 : 
; 4061 :   case ID_Resume_Audio:
; 4062 :     return ProcessResumeMessage( pPlayAudio );

  015df	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  015e3	50		 push	 eax
  015e4	e8 00 00 00 00	 call	 _ProcessResumeMessage
  015e9	83 c4 04	 add	 esp, 4

; 4131 : }

  015ec	c3		 ret	 0
$L71482:

; 4063 : 
; 4064 :   /********************************************************************/
; 4065 :   /*  An application uses this message to set audio parameters.       */
; 4066 :   /********************************************************************/
; 4067 : 
; 4068 :   case ID_Set_Audio_Format:
; 4069 :     return ProcessSetFormatMessage( pPlayAudio,
; 4070 :                                     (LPWAVEFORMATEX)aParam );

  015ed	8b 4c 24 0c	 mov	 ecx, DWORD PTR _aParam$[esp-4]
  015f1	8b 54 24 04	 mov	 edx, DWORD PTR _pPlayAudio$[esp-4]
  015f5	51		 push	 ecx
  015f6	52		 push	 edx
  015f7	e8 00 00 00 00	 call	 _ProcessSetFormatMessage
  015fc	83 c4 08	 add	 esp, 8

; 4131 : }

  015ff	c3		 ret	 0
$L71484:

; 4071 : 
; 4072 :   /********************************************************************/
; 4073 :   /*  An application uses this message to get audio parameters.       */
; 4074 :   /********************************************************************/
; 4075 : 
; 4076 :   case ID_Get_Audio_Format:
; 4077 :     return ProcessGetFormatMessage( pPlayAudio,
; 4078 :                                     (LPWAVEFORMATEX)aParam );

  01600	8b 44 24 0c	 mov	 eax, DWORD PTR _aParam$[esp-4]
  01604	8b 4c 24 04	 mov	 ecx, DWORD PTR _pPlayAudio$[esp-4]
  01608	50		 push	 eax
  01609	51		 push	 ecx
  0160a	e8 00 00 00 00	 call	 _ProcessGetFormatMessage
  0160f	83 c4 08	 add	 esp, 8

; 4131 : }

  01612	c3		 ret	 0
$L71486:

; 4079 : 
; 4080 :   /********************************************************************/
; 4081 :   /*  An application uses this message to get the wave output device  */
; 4082 :   /*  volume.                                                         */
; 4083 :   /********************************************************************/
; 4084 : 
; 4085 :   case ID_Get_Audio_Volume:
; 4086 :     return ProcessGetVolumeMessage( pPlayAudio, (LPDWORD)aParam );

  01613	8b 54 24 0c	 mov	 edx, DWORD PTR _aParam$[esp-4]
  01617	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  0161b	52		 push	 edx
  0161c	50		 push	 eax
  0161d	e8 00 00 00 00	 call	 _ProcessGetVolumeMessage
  01622	83 c4 08	 add	 esp, 8

; 4131 : }

  01625	c3		 ret	 0
$L71488:

; 4087 : 
; 4088 :   /********************************************************************/
; 4089 :   /*  An application uses this message to set the wave output device  */
; 4090 :   /*  volume.                                                         */
; 4091 :   /********************************************************************/
; 4092 : 
; 4093 :   case ID_Set_Audio_Volume:
; 4094 :     return ProcessSetVolumeMessage( pPlayAudio, (DWORD)aParam );

  01626	8b 4c 24 0c	 mov	 ecx, DWORD PTR _aParam$[esp-4]
  0162a	8b 54 24 04	 mov	 edx, DWORD PTR _pPlayAudio$[esp-4]
  0162e	51		 push	 ecx
  0162f	52		 push	 edx
  01630	e8 00 00 00 00	 call	 _ProcessSetVolumeMessage
  01635	83 c4 08	 add	 esp, 8

; 4131 : }

  01638	c3		 ret	 0
$L71490:

; 4095 : 
; 4096 :   /********************************************************************/
; 4097 :   /*  An application uses this message to mark the current audio      */
; 4098 :   /*  position.                                                       */
; 4099 :   /********************************************************************/
; 4100 : 
; 4101 :   case ID_Synchronization_Mark:
; 4102 :     return ProcessSynchronizationMarkMessage( pPlayAudio, aParam );

  01639	8b 44 24 0c	 mov	 eax, DWORD PTR _aParam$[esp-4]
  0163d	8b 4c 24 04	 mov	 ecx, DWORD PTR _pPlayAudio$[esp-4]
  01641	50		 push	 eax
  01642	51		 push	 ecx
  01643	e8 00 00 00 00	 call	 _ProcessSynchronizationMarkMessage
  01648	83 c4 08	 add	 esp, 8

; 4131 : }

  0164b	c3		 ret	 0
$L71491:

; 4103 : 
; 4104 :   /********************************************************************/
; 4105 :   /*  An application uses this message to get the position of the     */
; 4106 :   /*  last sample played by the wave output device.                   */
; 4107 :   /********************************************************************/
; 4108 : 
; 4109 :   case ID_Get_Audio_Position:
; 4110 :     return ProcessGetPositionMessage( pPlayAudio, (LPDWORD)aParam );

  0164c	8b 54 24 0c	 mov	 edx, DWORD PTR _aParam$[esp-4]
  01650	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  01654	52		 push	 edx
  01655	50		 push	 eax
  01656	e8 00 00 00 00	 call	 _ProcessGetPositionMessage
  0165b	83 c4 08	 add	 esp, 8

; 4131 : }

  0165e	c3		 ret	 0
$L71493:

; 4111 : 
; 4112 :   /********************************************************************/
; 4113 :   /*  The ID_Destroy_Message is used to shut down the audio thread.   */
; 4114 :   /********************************************************************/
; 4115 : 
; 4116 :   case ID_Destroy_Message:
; 4117 :     pShm_t->bGlobalPlayAudioThreadExit = TRUE;

  0165f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t

; 4118 : 
; 4119 :     break;
; 4120 : 
; 4121 :   /********************************************************************/
; 4122 :   /*  Default message processing. This should never execute.          */
; 4123 :   /********************************************************************/
; 4124 : 
; 4125 :   default:
; 4126 : 
; 4127 :     break;
; 4128 :   }
; 4129 : 
; 4130 :   return 0;

  01665	33 c0		 xor	 eax, eax
  01667	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1

; 4131 : }

  0166e	c3		 ret	 0
$L71475:

; 4005 :   
; 4006 :   /********************************************************************/
; 4007 :   /*  The MM_WOM_OPEN message is received after the waveOutOpen()     */
; 4008 :   /*  function opens the waveform output device.                      */
; 4009 :   /********************************************************************/
; 4010 : 
; 4011 :   case MM_WOM_OPEN:
; 4012 :     return Process_MM_WOM_OPEN_Message( pPlayAudio, aParam );

  0166f	8b 54 24 0c	 mov	 edx, DWORD PTR _aParam$[esp-4]
  01673	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  01677	52		 push	 edx
  01678	50		 push	 eax
  01679	e8 00 00 00 00	 call	 _Process_MM_WOM_OPEN_Message
  0167e	83 c4 08	 add	 esp, 8

; 4131 : }

  01681	c3		 ret	 0
$L72095:

; 4003 :   switch( uiMessage )
; 4004 :   {

  01682	2d bc 03 00 00	 sub	 eax, 956		; 000003bcH
  01687	74 19		 je	 SHORT $L71477
  01689	48		 dec	 eax
  0168a	74 03		 je	 SHORT $L71476
$L71494:

; 4118 : 
; 4119 :     break;
; 4120 : 
; 4121 :   /********************************************************************/
; 4122 :   /*  Default message processing. This should never execute.          */
; 4123 :   /********************************************************************/
; 4124 : 
; 4125 :   default:
; 4126 : 
; 4127 :     break;
; 4128 :   }
; 4129 : 
; 4130 :   return 0;

  0168c	33 c0		 xor	 eax, eax

; 4131 : }

  0168e	c3		 ret	 0
$L71476:

; 4013 : 
; 4014 :   /********************************************************************/
; 4015 :   /*  The MM_WOM_DONE message is received when a buffer queued by the */
; 4016 :   /*  waveOutWrite() function has been played.                        */
; 4017 :   /********************************************************************/
; 4018 : 
; 4019 :   case MM_WOM_DONE:
; 4020 :     return Process_MM_WOM_DONE_Message( pPlayAudio, aParam );

  0168f	8b 4c 24 0c	 mov	 ecx, DWORD PTR _aParam$[esp-4]
  01693	8b 54 24 04	 mov	 edx, DWORD PTR _pPlayAudio$[esp-4]
  01697	51		 push	 ecx
  01698	52		 push	 edx
  01699	e8 00 00 00 00	 call	 _Process_MM_WOM_DONE_Message
  0169e	83 c4 08	 add	 esp, 8

; 4131 : }

  016a1	c3		 ret	 0
$L71477:

; 4021 : 
; 4022 :   /********************************************************************/
; 4023 :   /*  The MM_WOM_CLOSE message is received when the waveOutClose()    */
; 4024 :   /*  function completes closing the waveform output device.          */
; 4025 :   /*  pPlayAudio->dwAudioDeviceState is set to                        */
; 4026 :   /*  AUDIO_DEVICE_INACTIVE in the                                    */
; 4027 :   /*  Process_Process_MM_WOM_DONE_Message() function after the call   */
; 4028 :   /*  to the waveOutClose() function.                                 */
; 4029 :   /********************************************************************/
; 4030 : 
; 4031 :   case MM_WOM_CLOSE:
; 4032 :     return Process_MM_WOM_CLOSE_Message( pPlayAudio );

  016a2	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  016a6	50		 push	 eax
  016a7	e8 00 00 00 00	 call	 _Process_MM_WOM_CLOSE_Message
  016ac	83 c4 04	 add	 esp, 4

; 4131 : }

  016af	c3		 ret	 0
$L72097:
  016b0	00 00 00 00	 DD	 $L71478
  016b4	00 00 00 00	 DD	 $L71479
  016b8	00 00 00 00	 DD	 $L71480
  016bc	00 00 00 00	 DD	 $L71481
  016c0	00 00 00 00	 DD	 $L71482
  016c4	00 00 00 00	 DD	 $L71484
  016c8	00 00 00 00	 DD	 $L71488
  016cc	00 00 00 00	 DD	 $L71486
  016d0	00 00 00 00	 DD	 $L71490
  016d4	00 00 00 00	 DD	 $L71491
  016d8	00 00 00 00	 DD	 $L71493
_PlayAudioProcedure ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutGetID@8:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_uiSelectedDeviceID$ = 8
_Process_MM_WOM_OPEN_Message PROC NEAR

; 4163 : {

  016e0	56		 push	 esi

; 4164 :   unsigned int uiSelectedDeviceID;
; 4165 :   MMRESULT mmStatus;
; 4166 : #ifdef AUD_DEBUG //tek 13may97
; 4167 :   {
; 4168 : 		  char  szTemp[256]="";
; 4169 : 		  sprintf(szTemp,"ProcWOMOPEN: outstanding now %d at %08lu\n",
; 4170 : 			  pPlayAudio->iOutstandingBuffers,timeGetTime());
; 4171 : 		  OutputDebugString(szTemp);
; 4172 : 		  if ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )
; 4173 : 		  {
; 4174 : 			  sprintf(szTemp,"ProcWOMOPEN: PA_OWN_DEVICE is SET\n");
; 4175 : 		  }
; 4176 : 		  else
; 4177 : 		  {
; 4178 : 			  sprintf(szTemp,"ProcWOMOPEN: PA_OWN_DEVICE is NOT set\n");
; 4179 : 		  }
; 4180 : 		  OutputDebugString(szTemp);
; 4181 :   }
; 4182 : #endif //AUD_DEBUG
; 4183 : 
; 4184 :   /********************************************************************/
; 4185 :   /*  It is NOT possible that the selected device ID is equal to      */
; 4186 :   /*  WAVE_MAPPER because the DetermineDeviceID() function will have  */
; 4187 :   /*  already set the selected device ID. This legacy code provides   */
; 4188 :   /*  another check of the device ID in case a strange error occurs.  */
; 4189 :   /********************************************************************/
; 4190 : 
; 4191 :   if ( pPlayAudio->uiSelectedDeviceID == (unsigned int)WAVE_MAPPER )

  016e1	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  016e5	83 7e 20 ff	 cmp	 DWORD PTR [esi+32], -1
  016e9	75 50		 jne	 SHORT $L71508

; 4192 :   {
; 4193 :     LOCK_MME_CALL( waveOutGetID( pPlayAudio->hWaveOut,
; 4194 :                                  &uiSelectedDeviceID ))

  016eb	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  016ee	8d 44 24 08	 lea	 eax, DWORD PTR _uiSelectedDeviceID$[esp]
  016f2	50		 push	 eax
  016f3	51		 push	 ecx
  016f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetID@8

; 4195 : 
; 4196 :     /******************************************************************/
; 4197 :     /*  Attempt to fix BUG in MARCH 1993 Beta version of Windows/NT.  */
; 4198 :     /*  If WAVE_MAPPER was the device ID when the waveOutOpen()       */
; 4199 :     /*  function was called and a valid hWaveOut is passed to the     */
; 4200 :     /*  waveOutGetID() function then it returns WAVE_MAPPER instead   */
; 4201 :     /*  of the device ID of the wave out device !                     */
; 4202 :     /*  If WAVE_MAPPER is used, then hope that the device ID is zero. */
; 4203 :     /******************************************************************/
; 4204 : 
; 4205 :     if ( uiSelectedDeviceID == (unsigned int)WAVE_MAPPER )

  016fa	83 7c 24 08 ff	 cmp	 DWORD PTR _uiSelectedDeviceID$[esp], -1
  016ff	75 08		 jne	 SHORT $L71507

; 4206 :     {
; 4207 :       uiSelectedDeviceID = 0;

  01701	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR _uiSelectedDeviceID$[esp], 0
$L71507:

; 4208 :     }
; 4209 : 
; 4210 :     /******************************************************************/
; 4211 :     /*  Save the selected device ID in the handle.                    */
; 4212 :     /******************************************************************/
; 4213 : 
; 4214 :     OP_LockMutex( pPlayAudio->hmxSelectedDeviceID );

  01709	8b 56 78	 mov	 edx, DWORD PTR [esi+120]
  0170c	52		 push	 edx
  0170d	e8 00 00 00 00	 call	 _OP_LockMutex

; 4215 :     pPlayAudio->uiSelectedDeviceID = uiSelectedDeviceID;
; 4216 :     OP_UnlockMutex( pPlayAudio->hmxSelectedDeviceID );

  01712	8b 4e 78	 mov	 ecx, DWORD PTR [esi+120]
  01715	8b 44 24 0c	 mov	 eax, DWORD PTR _uiSelectedDeviceID$[esp+4]
  01719	51		 push	 ecx
  0171a	89 46 20	 mov	 DWORD PTR [esi+32], eax
  0171d	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 4217 : 
; 4218 :     /******************************************************************/
; 4219 :     /*  Set the dwDeviceSupport member of the play audio handle       */
; 4220 :     /*  pointed to by "pPlayAudio" to the dwSupport field of the      */
; 4221 :     /*  WAVEOUTCAPS structure. The device ID is specified by the      */
; 4222 :     /*  uiSelectedDeviceID field of the play audio handle.            */
; 4223 :     /******************************************************************/
; 4224 : 
; 4225 :     mmStatus = GetWaveOutDeviceCaps( pPlayAudio );

  01722	56		 push	 esi
  01723	e8 00 00 00 00	 call	 _GetWaveOutDeviceCaps
  01728	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4226 : 
; 4227 :     if ( mmStatus )

  0172b	85 c0		 test	 eax, eax
  0172d	74 0c		 je	 SHORT $L71508

; 4228 :     {
; 4229 : #ifdef AUD_DEBUG
; 4230 : 		OutputDebugString("Process_MM_WOM_OPEN_Message: GetWaveOutDeviceCaps failed.\n");
; 4231 : #endif
; 4232 : 		ReportStatusToApplication( pPlayAudio,
; 4233 :                                  PA_GET_CAPS_ERROR,
; 4234 :                                  mmStatus );

  0172f	50		 push	 eax
  01730	6a 06		 push	 6
  01732	56		 push	 esi
  01733	e8 00 00 00 00	 call	 _ReportStatusToApplication
  01738	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71508:

; 4235 :     }
; 4236 :   }
; 4237 : 
; 4238 :   /********************************************************************/
; 4239 :   /*  Start Audio Playing.                                            */
; 4240 :   /********************************************************************/
; 4241 : 
; 4242 :   StartAudioPlaying( pPlayAudio );

  0173b	56		 push	 esi
  0173c	e8 00 00 00 00	 call	 _StartAudioPlaying
  01741	83 c4 04	 add	 esp, 4

; 4243 : 
; 4244 :   return FALSE;

  01744	33 c0		 xor	 eax, eax
  01746	5e		 pop	 esi

; 4245 : }

  01747	c3		 ret	 0
_Process_MM_WOM_OPEN_Message ENDP
_pPlayAudio$ = 8
_GetWaveOutDeviceCaps PROC NEAR

; 4277 : {

  01750	56		 push	 esi

; 4278 :   LPWAVEOUTCAPS pWaveOutCaps;
; 4279 :   MMRESULT mmStatus;
; 4280 : 
; 4281 :   /********************************************************************/
; 4282 :   /*  Get the wave output device capabilities.                        */
; 4283 :   /*  First allocate memory for the WAVEOUTCAPS structure.            */
; 4284 :   /********************************************************************/
; 4285 : 
; 4286 :   LOCK_MME_CALL(
; 4287 :     pWaveOutCaps = (LPWAVEOUTCAPS)ALLOCATE_SERVER_MEM(sizeof(WAVEOUTCAPS)))

  01751	6a 34		 push	 52			; 00000034H
  01753	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  01759	8b f0		 mov	 esi, eax
  0175b	83 c4 04	 add	 esp, 4

; 4288 : 
; 4289 :   if ( pWaveOutCaps == NULL )

  0175e	85 f6		 test	 esi, esi
  01760	75 07		 jne	 SHORT $L71517

; 4290 :   {
; 4291 :     return MMSYSERR_NOMEM;

  01762	b8 07 00 00 00	 mov	 eax, 7
  01767	5e		 pop	 esi

; 4312 : }

  01768	c3		 ret	 0
$L71517:
  01769	53		 push	 ebx
  0176a	57		 push	 edi

; 4292 :   }
; 4293 : 
; 4294 :   LOCK_MME_CALL(
; 4295 :     mmStatus = waveOutGetDevCaps( pPlayAudio->uiSelectedDeviceID,
; 4296 :                                   pWaveOutCaps,
; 4297 :                                   sizeof(WAVEOUTCAPS)))

  0176b	8b 7c 24 10	 mov	 edi, DWORD PTR _pPlayAudio$[esp+8]
  0176f	6a 34		 push	 52			; 00000034H
  01771	56		 push	 esi
  01772	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  01775	50		 push	 eax
  01776	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetDevCapsA@12

; 4298 : 
; 4299 :   /********************************************************************/
; 4300 :   /*  Store the device capabilities in the handle.                    */
; 4301 :   /********************************************************************/
; 4302 : 
; 4303 :   pPlayAudio->dwDeviceSupport = pWaveOutCaps->dwSupport;

  0177c	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]

; 4304 : 
; 4305 :   /********************************************************************/
; 4306 :   /*  Free memory for the WAVEOUTCAPS structure.                      */
; 4307 :   /********************************************************************/
; 4308 : 
; 4309 :   LOCK_MME_CALL( FREE_SERVER_MEM( pWaveOutCaps ))

  0177f	56		 push	 esi
  01780	8b d8		 mov	 ebx, eax
  01782	89 4f 48	 mov	 DWORD PTR [edi+72], ecx
  01785	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0178b	83 c4 04	 add	 esp, 4

; 4310 : 
; 4311 :   return mmStatus;

  0178e	8b c3		 mov	 eax, ebx
  01790	5f		 pop	 edi
  01791	5b		 pop	 ebx
  01792	5e		 pop	 esi

; 4312 : }

  01793	c3		 ret	 0
_GetWaveOutDeviceCaps ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutPause@4:NEAR
EXTRN	__imp__waveOutRestart@4:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_StartAudioPlaying PROC NEAR

; 4342 : {

  017a0	53		 push	 ebx
  017a1	55		 push	 ebp
  017a2	56		 push	 esi

; 4343 :   unsigned int uiI;
; 4344 :   unsigned int uiQueueCount;
; 4345 :   unsigned int uiWriteLength;
; 4346 :   LPPLAY_RING_T pPlayAudioRing;
; 4347 : 
; 4348 :   /********************************************************************/
; 4349 :   /*  Get the Queue Count. If it changes between here and the end of  */
; 4350 :   /*  this function, that's OK.                                       */
; 4351 :   /********************************************************************/
; 4352 : 
; 4353 :   pPlayAudioRing = pPlayAudio->pPlayAudioRing;

  017a3	8b 74 24 10	 mov	 esi, DWORD PTR _pPlayAudio$[esp+8]
  017a7	57		 push	 edi

; 4354 : 
; 4355 :   OP_LockMutex( pPlayAudio->hmxQueueCount );

  017a8	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  017ab	8b ae 98 00 00
	00		 mov	 ebp, DWORD PTR [esi+152]
  017b1	50		 push	 eax
  017b2	e8 00 00 00 00	 call	 _OP_LockMutex

; 4356 : 
; 4357 : #ifdef AUD_DEBUG //tek 13may97
; 4358 :   {
; 4359 :     char  szTemp[256]="";
; 4360 :     sprintf(szTemp,"SAP: state=%ld QCount=%d new=%d outstanding=%d at %lu\n",
; 4361 : 	    pPlayAudio->dwAudioDeviceState,
; 4362 : 	    pPlayAudioRing->iQueueCount,
; 4363 : 	    uiQueueCount, 
; 4364 : 	    pPlayAudio->iOutstandingBuffers,
; 4365 : 	    timeGetTime()
; 4366 : 	    );
; 4367 :     OutputDebugString(szTemp);
; 4368 :     if (uiQueueCount < (pPlayAudio->uiStartupWriteLength-1))
; 4369 :       {
; 4370 : 	OutputDebugString("SAP: runt start packet?\n");
; 4371 :       }
; 4372 :     
; 4373 :   }
; 4374 : #endif //AUD_DEBUG
; 4375 :   
; 4376 :   uiQueueCount = (unsigned int)pPlayAudioRing->iQueueCount;
; 4377 :   // tek 06nov97 hold this mutex for the duration
; 4378 :   //OP_UnlockMutex( pPlayAudio->hmxQueueCount );
; 4379 : 
; 4380 :   /********************************************************************/
; 4381 :   /*  If the PA_Reset() function clears the audio queue just after    */
; 4382 :   /*  the waveOutOpen() function completes, then it is possible to    */
; 4383 :   /*  get here with no audio in the queue. In this case, close the    */
; 4384 :   /*  wave output device.                                             */
; 4385 :   /********************************************************************/
; 4386 : 
; 4387 :   if ( uiQueueCount == 0 )

  017b7	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  017ba	83 c4 04	 add	 esp, 4
  017bd	85 c0		 test	 eax, eax
  017bf	75 1a		 jne	 SHORT $L71527

; 4388 :   {
; 4389 :     ClosePlayDevice( pPlayAudio );

  017c1	56		 push	 esi
  017c2	e8 00 00 00 00	 call	 _ClosePlayDevice

; 4565 : 	  }
; 4566 : 	  else
; 4567 : 	  {
; 4568 : #ifdef AUD_DEBUG
; 4569 : 		  {
; 4570 : 		    char  szTemp[256]="";
; 4571 : 		    sprintf(szTemp,"SAP: header %d (%08lx) is busy at %lu\n",
; 4572 : 			    uiI,
; 4573 : 			    pPlayAudio->ppWaveHdr[uiI],
; 4574 : 			    timeGetTime()
; 4575 : 			    );
; 4576 : 		    OutputDebugString(szTemp);
; 4577 : 		  }
; 4578 : #endif //AUD_DEBUG  
; 4579 : 	  }
; 4580 :     }
; 4581 :   }
; 4582 : #ifdef AUD_DEBUG
; 4583 :   {
; 4584 : 		  char  szTemp[256]="";
; 4585 : 		  sprintf(szTemp,"SAP: exit at %lu\n",
; 4586 : 			  timeGetTime()
; 4587 : 			  );
; 4588 : 		  OutputDebugString(szTemp);
; 4589 :   }
; 4590 : #endif //AUD_DEBUG  
; 4591 :   // finally release the mutex here.
; 4592 :   OP_UnlockMutex(pPlayAudio->hmxQueueCount);

  017c7	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  017ca	83 c4 04	 add	 esp, 4
  017cd	51		 push	 ecx
  017ce	e8 00 00 00 00	 call	 _OP_UnlockMutex
  017d3	83 c4 04	 add	 esp, 4
  017d6	5f		 pop	 edi
  017d7	5e		 pop	 esi
  017d8	5d		 pop	 ebp
  017d9	5b		 pop	 ebx

; 4593 : 
; 4594 :   return;
; 4595 : }

  017da	c3		 ret	 0
$L71527:

; 4390 :   }
; 4391 :   else
; 4392 :   {
; 4393 : 	  // tek 13may97
; 4394 : 	  // we can now be re-entered after audio is actually playing; 
; 4395 : 	  // if we're using hte MME_SERVER we'll just bail out here, but
; 4396 : 	  // if not then we need to correctly atempt to send more samples.
; 4397 : 	  // we can tell if we're already running by the AudioDeviceState.
; 4398 : 
; 4399 :     if (pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE)

  017db	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  017de	bf 02 00 00 00	 mov	 edi, 2
  017e3	3b c7		 cmp	 eax, edi
  017e5	74 53		 je	 SHORT $L71531

; 4400 : 	{
; 4401 : #ifdef USE_MME_SERVER
; 4402 : 	OP_UnlockMutex(pPlayAudio->hmxQueueCount);
; 4403 : 		return;
; 4404 : #endif //USE_MME_SERVER
; 4405 : 	}
; 4406 : 	else // audio device is not active; do all the things we
; 4407 : 		 // do on startup..
; 4408 : 	{
; 4409 : 
; 4410 :     /******************************************************************/
; 4411 :     /*  Signal the application that we are starting to play audio.    */
; 4412 :     /*  Set a flag to indicate that a PA_PLAY_STOP message may be     */
; 4413 :     /*  sent. This flag is necessary in case the                      */
; 4414 :     /*  Process_MM_WOM_CLOSE() function is called after the audio     */
; 4415 :     /*  device is opened, but no audio is played (that is, the        */
; 4416 :     /*  ClosePlayDevice() function is called above. This can occur    */
; 4417 :     /*  if the timer thread and the PA_Queue() function both send     */
; 4418 :     /*  ID_Open_Wave_Output_Device messages in rapid succession.)     */
; 4419 :     /******************************************************************/
; 4420 : 
; 4421 :     ReportStatusToApplication( pPlayAudio,
; 4422 :                                PA_PLAY_START,
; 4423 :                                0 );

  017e7	bb 01 00 00 00	 mov	 ebx, 1
  017ec	6a 00		 push	 0
  017ee	53		 push	 ebx
  017ef	56		 push	 esi
  017f0	e8 00 00 00 00	 call	 _ReportStatusToApplication

; 4424 : 
; 4425 :     pPlayAudio->bReportPlayStop = TRUE;
; 4426 : 
; 4427 :     /******************************************************************/
; 4428 :     /*  Set the Audio Device State to AUDIO_DEVICE_ACTIVE.            */
; 4429 :     /******************************************************************/
; 4430 : 
; 4431 : 	// tek 07nov97 unfortunately, with the longer hold of the 
; 4432 : 	// QueueCount mutex, this can deadlock with TimerThreadMain.
; 4433 : 	// But, the audio device is not active, so we release the
; 4434 : 	// mutex while we're doing this, and then take it back.
; 4435 :     OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  017f5	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  017f8	89 5e 64	 mov	 DWORD PTR [esi+100], ebx
  017fb	51		 push	 ecx
  017fc	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 4436 :     OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  01801	8b 56 70	 mov	 edx, DWORD PTR [esi+112]
  01804	52		 push	 edx
  01805	e8 00 00 00 00	 call	 _OP_LockMutex

; 4437 :     pPlayAudio->dwAudioDeviceState = AUDIO_DEVICE_ACTIVE;
; 4438 :     OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  0180a	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  0180d	89 7e 34	 mov	 DWORD PTR [esi+52], edi
  01810	50		 push	 eax
  01811	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 4439 :     OP_LockMutex( pPlayAudio->hmxQueueCount );

  01816	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  01819	51		 push	 ecx
  0181a	e8 00 00 00 00	 call	 _OP_LockMutex

; 4440 : 
; 4441 :     /******************************************************************/
; 4442 :     /*  If the Audio Device State is NOT PA_OWN_DEVICE and the pause  */
; 4443 :     /*  flag is set then pause the wave output device. This is        */
; 4444 :     /*  necessary in case the pause message was received in between   */
; 4445 :     /*  the open wave out device message and the MM_WOM_OPEN message. */
; 4446 :     /******************************************************************/
; 4447 : 
; 4448 :     if ( ! ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )
; 4449 :       && ( pPlayAudio->bPaused ))

  0181f	8a 46 3c	 mov	 al, BYTE PTR [esi+60]
  01822	83 c4 1c	 add	 esp, 28			; 0000001cH
  01825	84 c3		 test	 al, bl
  01827	75 11		 jne	 SHORT $L71531
  01829	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  0182c	85 c0		 test	 eax, eax
  0182e	74 0a		 je	 SHORT $L71531

; 4450 :     {
; 4451 :       LOCK_MME_CALL( waveOutPause( pPlayAudio->hWaveOut ))

  01830	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  01833	52		 push	 edx
  01834	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutPause@4
$L71531:

; 4452 :     }
; 4453 : 
; 4454 : #ifdef USE_MME_SERVER
; 4455 : 
; 4456 :     /******************************************************************/
; 4457 :     /*  MME BUG WORKAROUND. Because the MME server currently does not */
; 4458 :     /*  return wave headers in the correct order, it is necessary to  */
; 4459 :     /*  put wave headers on a list whenever a wave header is written  */
; 4460 :     /*  by the waveOutWrite() function. This list is accessed in the  */
; 4461 :     /*  wave output callback routine to determine the current header. */
; 4462 :     /******************************************************************/
; 4463 : 
; 4464 :     pPlayAudio->uiWaveHdrWriteIndex = 0;
; 4465 :     pPlayAudio->uiWaveHdrReadIndex = 0;
; 4466 : 
; 4467 : #endif
; 4468 : 	}
; 4469 : 
; 4470 : 	// In case we got a reset without a resume...
; 4471 : 	if (pPlayAudio->bResetPaused && !pPlayAudio->bPaused)

  0183a	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  0183d	85 c0		 test	 eax, eax
  0183f	74 11		 je	 SHORT $L71532
  01841	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  01844	85 c0		 test	 eax, eax
  01846	75 0a		 jne	 SHORT $L71532

; 4472 : 	{
; 4473 : 		LOCK_MME_CALL( waveOutRestart( pPlayAudio->hWaveOut ))

  01848	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0184b	50		 push	 eax
  0184c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutRestart@4
$L71532:

; 4474 : 	}
; 4475 : 
; 4476 : 	// if there are samples outstanding, we have to recalculate the 
; 4477 : 	// correct number of samples that are still waiting to go
; 4478 : 	// hold this mutex up above.
; 4479 : 	//OP_LockMutex( pPlayAudio->hmxQueueCount );
; 4480 : 	// tek 06nov97 bats508 it is possible that ResetAudioQueue
; 4481 : 	// came along and clobbered the queue. If so, we need to
; 4482 : 	// gracefully bow out here..
; 4483 : 	  if ( pPlayAudioRing->iQueueCount == 0 )

  01852	8b 7d 18	 mov	 edi, DWORD PTR [ebp+24]
  01855	85 ff		 test	 edi, edi
  01857	75 17		 jne	 SHORT $L71533

; 4484 : 	  {
; 4485 : 		ClosePlayDevice( pPlayAudio );

  01859	56		 push	 esi
  0185a	e8 00 00 00 00	 call	 _ClosePlayDevice

; 4486 : 		OP_UnlockMutex(pPlayAudio->hmxQueueCount);

  0185f	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  01862	51		 push	 ecx
  01863	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01868	83 c4 08	 add	 esp, 8
  0186b	5f		 pop	 edi
  0186c	5e		 pop	 esi
  0186d	5d		 pop	 ebp
  0186e	5b		 pop	 ebx

; 4593 : 
; 4594 :   return;
; 4595 : }

  0186f	c3		 ret	 0
$L71533:

; 4487 : #ifdef AUD_DEBUG
; 4488 : 		{
; 4489 : 		  char  szTemp[256]="";
; 4490 : 		  sprintf(szTemp,"SAP: iQueueCount=0 abort at %lu\n",
; 4491 : 			  timeGetTime()
; 4492 : 			  );
; 4493 : 		  OutputDebugString(szTemp);
; 4494 : 		}
; 4495 : #endif //AUD_DEBUG 
; 4496 : 		return;
; 4497 : 	  }
; 4498 : 	uiQueueCount = pPlayAudioRing->iQueueCount
; 4499 : 					- pPlayAudio->iSamplesWaitingForCompletion;

  01870	8b 46 30	 mov	 eax, DWORD PTR [esi+48]

; 4500 : 	// hold the mutex so PROCWOMDONE won't collide..
; 4501 : 
; 4502 : #ifdef AUD_DEBUG
; 4503 :   {
; 4504 :     char  szTemp[256]="";
; 4505 :     sprintf(szTemp,"SAP: %d samples to write at %lu\n",
; 4506 : 	    uiQueueCount,
; 4507 : 	    timeGetTime()
; 4508 : 	    );
; 4509 :     OutputDebugString(szTemp);
; 4510 :   }
; 4511 : #endif //AUD_DEBUG 
; 4512 : 
; 4513 :     /******************************************************************/
; 4514 :     /*  If the number of samples in the queue is less than the        */
; 4515 :     /*  minimum samples to start playing audio then this is a flush   */
; 4516 :     /*  that was started by the timer thread (TimerThreadMain).       */
; 4517 :     /******************************************************************/
; 4518 : 	// tek 13may97
; 4519 : 	// this is no longer true. We can start up with less data if we're
; 4520 : 	// being forced to speak.
; 4521 : 
; 4522 :     /******************************************************************/
; 4523 :     /*  Loop and write buffers to the wave output device.             */
; 4524 :     /******************************************************************/
; 4525 : 
; 4526 :     uiWriteLength = pPlayAudio->uiStartupWriteLength;

  01873	8b 5e 28	 mov	 ebx, DWORD PTR [esi+40]
  01876	2b f8		 sub	 edi, eax
  01878	33 ed		 xor	 ebp, ebp
$L71534:

; 4527 : 
; 4528 : 	// tek 13may97
; 4529 : 	//// if we have less than the normal startup number of bytes, then
; 4530 : 	//// try to split the buffer into at least two buffers.
; 4531 : 	//
; 4532 : 	//if (  (uiQueueCount < uiWriteLength)
; 4533 : 	//	&&(uiQueueCount > 100) // but don't break up really tiny packets..
; 4534 : 	//   )
; 4535 : 	//{
; 4536 : 	//	uiWriteLength = (uiQueueCount>>4)<<3; // div by two, 8-byte chunksize
; 4537 : 	//}
; 4538 : 
; 4539 :     for ( uiI = 0;
; 4540 :           ( uiI < MAXIMUM_BUFFERS_QUEUED ) && ( uiQueueCount > 0 );
; 4541 :           uiI++ )

  0187a	85 ff		 test	 edi, edi
  0187c	76 35		 jbe	 SHORT $L71536

; 4542 :     {
; 4543 :       if ( uiWriteLength > uiQueueCount)

  0187e	3b df		 cmp	 ebx, edi
  01880	76 02		 jbe	 SHORT $L71537

; 4544 :       {
; 4545 :         uiWriteLength = uiQueueCount;

  01882	8b df		 mov	 ebx, edi
$L71537:

; 4546 :       }
; 4547 : 	  // tek 21nov97 make sure we don't leave a tiny buffer laying around to 
; 4548 : 	  // be sent..
; 4549 : 	  if (uiQueueCount < uiWriteLength+1000)

  01884	8d 93 e8 03 00
	00		 lea	 edx, DWORD PTR [ebx+1000]
  0188a	3b fa		 cmp	 edi, edx
  0188c	73 02		 jae	 SHORT $L71538

; 4550 :       {
; 4551 : #ifndef UNDER_CE
; 4552 : 		uiWriteLength = uiQueueCount;

  0188e	8b df		 mov	 ebx, edi
$L71538:

; 4553 : #else
; 4554 :         if (!pPlayAudio->bConvertToEightBit)	uiWriteLength = (uiQueueCount & 0xFFFFFFFE);		// Let's not send in a half-block
; 4555 : #endif
; 4556 :       }
; 4557 : 	  // check to make sure that this is a free waveheader, and
; 4558 : 	  // write it if it is. (tek 13may97)
; 4559 : 	  if (pPlayAudio->ppWaveHdr[uiI]->lpData == NULL)

  01890	8b 86 94 00 00
	00		 mov	 eax, DWORD PTR [esi+148]
  01896	8b 04 28	 mov	 eax, DWORD PTR [eax+ebp]
  01899	83 38 00	 cmp	 DWORD PTR [eax], 0
  0189c	75 0d		 jne	 SHORT $L71535

; 4560 : 	  {
; 4561 : 
; 4562 :       uiQueueCount -= WriteBufferToWaveDevice( pPlayAudio,
; 4563 :                                                pPlayAudio->ppWaveHdr[uiI],
; 4564 :                                                uiWriteLength );

  0189e	53		 push	 ebx
  0189f	50		 push	 eax
  018a0	56		 push	 esi
  018a1	e8 00 00 00 00	 call	 _WriteBufferToWaveDevice
  018a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  018a9	2b f8		 sub	 edi, eax
$L71535:
  018ab	83 c5 04	 add	 ebp, 4
  018ae	83 fd 20	 cmp	 ebp, 32			; 00000020H
  018b1	7c c7		 jl	 SHORT $L71534
$L71536:

; 4565 : 	  }
; 4566 : 	  else
; 4567 : 	  {
; 4568 : #ifdef AUD_DEBUG
; 4569 : 		  {
; 4570 : 		    char  szTemp[256]="";
; 4571 : 		    sprintf(szTemp,"SAP: header %d (%08lx) is busy at %lu\n",
; 4572 : 			    uiI,
; 4573 : 			    pPlayAudio->ppWaveHdr[uiI],
; 4574 : 			    timeGetTime()
; 4575 : 			    );
; 4576 : 		    OutputDebugString(szTemp);
; 4577 : 		  }
; 4578 : #endif //AUD_DEBUG  
; 4579 : 	  }
; 4580 :     }
; 4581 :   }
; 4582 : #ifdef AUD_DEBUG
; 4583 :   {
; 4584 : 		  char  szTemp[256]="";
; 4585 : 		  sprintf(szTemp,"SAP: exit at %lu\n",
; 4586 : 			  timeGetTime()
; 4587 : 			  );
; 4588 : 		  OutputDebugString(szTemp);
; 4589 :   }
; 4590 : #endif //AUD_DEBUG  
; 4591 :   // finally release the mutex here.
; 4592 :   OP_UnlockMutex(pPlayAudio->hmxQueueCount);

  018b3	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  018b6	51		 push	 ecx
  018b7	e8 00 00 00 00	 call	 _OP_UnlockMutex
  018bc	83 c4 04	 add	 esp, 4
  018bf	5f		 pop	 edi
  018c0	5e		 pop	 esi
  018c1	5d		 pop	 ebp
  018c2	5b		 pop	 ebx

; 4593 : 
; 4594 :   return;
; 4595 : }

  018c3	c3		 ret	 0
_StartAudioPlaying ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutUnprepareHeader@12:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_aParam$ = 12
_Process_MM_WOM_DONE_Message PROC NEAR

; 4632 : {

  018d0	53		 push	 ebx
  018d1	55		 push	 ebp

; 4633 :   int dwRemaining;
; 4634 :   unsigned int uiOldWriteLength;
; 4635 :   LPWAVEHDR pWaveHdr;
; 4636 :   LPPLAY_RING_T pPlayAudioRing;
; 4637 : 
; 4638 :   //tek 24jul97
; 4639 :   UINT	uiI=0;
; 4640 : 
; 4641 :   /********************************************************************/
; 4642 :   /*  Get the pointer to the wave header from the aParam of the       */
; 4643 :   /*  MM_WOM_DONE message and the pointer to the audio queue from the */
; 4644 :   /*  audio handle.                                                   */
; 4645 :   /********************************************************************/
; 4646 : 
; 4647 :   pWaveHdr = (LPWAVEHDR)aParam;
; 4648 : 
; 4649 :   /********************************************************************/
; 4650 :   /*  Get the number of samples previously written by the             */
; 4651 :   /*  waveOutWrite() function.                                        */
; 4652 :   /********************************************************************/
; 4653 : 
; 4654 :   uiOldWriteLength = (unsigned int)pWaveHdr->dwUser;

  018d2	8b 6c 24 10	 mov	 ebp, DWORD PTR _aParam$[esp+4]
  018d6	56		 push	 esi

; 4655 : 
; 4656 : #ifdef __arm__
; 4657 :   if( pPlayAudio->bPipesNotEmpty )
; 4658 :     {
; 4659 :       //setpriority(PRIO_PROCESS, 0, 20);
; 4660 :       // OP_SetThreadPriority works better, why? 
; 4661 :       OP_SetThreadPriority( pShm_t->hGlobalPlayAudioThread, OP_PRIORITY_NORMAL );
; 4662 :       if ( (uiOldWriteLength<<5) > 50000 )
; 4663 :       	usleep(50000); // tek 13oct98 defer buffer processing
; 4664 :       else
; 4665 :       	usleep(uiOldWriteLength<<5);
; 4666 :       //ETT 10/13/98 this has to be just right other wise it will stutter worse
; 4667 :       //setpriority(PRIO_PROCESS, 0, -20);
; 4668 :       OP_SetThreadPriority( pShm_t->hGlobalPlayAudioThread, OP_PRIORITY_HIGHEST );
; 4669 :     }
; 4670 : #endif
; 4671 : 
; 4672 :   /********************************************************************/
; 4673 :   /*  Unprepare the old header.                                       */
; 4674 :   /********************************************************************/
; 4675 : 
; 4676 : #ifndef USE_MME_SERVER
; 4677 :   _ASSERTE(pWaveHdr->lpData != NULL); // tek 22jan99 make sure this isn't a bogus
; 4678 : 									  // and/or idle header
; 4679 : 
; 4680 :   waveOutUnprepareHeader( pPlayAudio->hWaveOut,
; 4681 :                           pWaveHdr,
; 4682 :                           sizeof(WAVEHDR));

  018d7	8b 74 24 10	 mov	 esi, DWORD PTR _pPlayAudio$[esp+8]
  018db	57		 push	 edi
  018dc	8b 5d 0c	 mov	 ebx, DWORD PTR [ebp+12]
  018df	6a 20		 push	 32			; 00000020H
  018e1	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  018e4	55		 push	 ebp
  018e5	50		 push	 eax
  018e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutUnprepareHeader@12

; 4683 : #endif
; 4684 :   // tek 06nov97 we have to take this mutex earlier to avoid collisions
; 4685 :   OP_LockMutex( pPlayAudio->hmxQueueCount );

  018ec	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  018ef	51		 push	 ecx
  018f0	e8 00 00 00 00	 call	 _OP_LockMutex

; 4686 :   // tek 09may97
; 4687 :   pPlayAudio->iOutstandingBuffers--;  // keep track of these for debugging

  018f5	8b 96 a4 00 00
	00		 mov	 edx, DWORD PTR [esi+164]

; 4688 : 
; 4689 :   /********************************************************************/
; 4690 :   /*  Subtract number of samples just output from the samples waiting */
; 4691 :   /*  for completion count.                                           */
; 4692 :   /********************************************************************/
; 4693 : 
; 4694 :   pPlayAudio->iSamplesWaitingForCompletion -= uiOldWriteLength;

  018fb	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]

; 4695 : #ifdef AUD_DEBUG	//13may97 tek
; 4696 :   {
; 4697 : 		  char  szTemp[256]="";
; 4698 : 		  sprintf(szTemp,"ProcWOMDONE: %08lx; outst buffs now=%d; samp waiting=%dat %08lu\n",
; 4699 : 			  pWaveHdr,
; 4700 : 			  pPlayAudio->iOutstandingBuffers,
; 4701 : 			  pPlayAudio->iSamplesWaitingForCompletion,
; 4702 : 			  timeGetTime()
; 4703 : 			  );
; 4704 : 		  OutputDebugString(szTemp);
; 4705 :   }
; 4706 : #endif //AUD_DEBUG
; 4707 : 
; 4708 :   /********************************************************************/
; 4709 :   /*  Do if the audio state isn't equal to AUDIO_STATE_PLAY then it   */
; 4710 :   /*  is equal to AUDIO_STATE_RESET.                                  */
; 4711 :   /********************************************************************/
; 4712 : 
; 4713 :   if ( pPlayAudio->dwAudioPlayState == AUDIO_STATE_PLAY )

  018fe	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  01901	83 c4 04	 add	 esp, 4
  01904	4a		 dec	 edx
  01905	2b cb		 sub	 ecx, ebx
  01907	85 c0		 test	 eax, eax
  01909	89 96 a4 00 00
	00		 mov	 DWORD PTR [esi+164], edx
  0190f	89 4e 30	 mov	 DWORD PTR [esi+48], ecx
  01912	0f 85 d2 00 00
	00		 jne	 $L71556

; 4714 :   {
; 4715 :     /******************************************************************/
; 4716 :     /*  Subtract the number of samples from the queue count.          */
; 4717 :     /******************************************************************/
; 4718 : 
; 4719 :     pPlayAudioRing = pPlayAudio->pPlayAudioRing;

  01918	8b be 98 00 00
	00		 mov	 edi, DWORD PTR [esi+152]

; 4720 : 
; 4721 : 	// tek 06nov97 (during bats508) hold this earlier (above).
; 4722 :     //OP_LockMutex( pPlayAudio->hmxQueueCount );
; 4723 :     pPlayAudioRing->iQueueCount -= (int)uiOldWriteLength;

  0191e	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  01921	2b cb		 sub	 ecx, ebx
  01923	89 4f 18	 mov	 DWORD PTR [edi+24], ecx

; 4724 : #ifdef AUD_DEBUG // tek 13may97
; 4725 :   {
; 4726 :     char  szTemp[256]="";
; 4727 :     sprintf(szTemp,"ProcWOMDONE: iQueueCount=%ld\n",
; 4728 : 	    pPlayAudioRing->iQueueCount);
; 4729 :     OutputDebugString(szTemp);
; 4730 :     
; 4731 :     if (pPlayAudioRing->iQueueCount < 0)
; 4732 :       {
; 4733 : 	sprintf(szTemp,"ProcWOMDONE: iQueueCount is negative? %d at %08lu\n",
; 4734 : 		pPlayAudioRing->iQueueCount,
; 4735 : 		timeGetTime()
; 4736 : 		);
; 4737 : 	OutputDebugString(szTemp);
; 4738 :       }
; 4739 :   }
; 4740 : #endif //AUD_DEBUG
; 4741 : 
; 4742 :     // tek 06nov97 this is now part of the larger mutex range
; 4743 :     //OP_UnlockMutex( pPlayAudio->hmxQueueCount );
; 4744 : 
; 4745 :     /******************************************************************/
; 4746 :     /*  Also update the "Bytes Played" count.                         */
; 4747 :     /******************************************************************/
; 4748 : 
; 4749 :     OP_LockMutex( pPlayAudio->hmxBytesPlayed );

  01926	8b 56 74	 mov	 edx, DWORD PTR [esi+116]
  01929	52		 push	 edx
  0192a	e8 00 00 00 00	 call	 _OP_LockMutex

; 4750 :     pPlayAudio->dwBytesPlayed += (DWORD)uiOldWriteLength;

  0192f	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  01932	03 c3		 add	 eax, ebx
  01934	89 46 44	 mov	 DWORD PTR [esi+68], eax

; 4751 :     OP_UnlockMutex( pPlayAudio->hmxBytesPlayed );

  01937	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  0193a	50		 push	 eax
  0193b	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 4752 : 
; 4753 :     /******************************************************************/
; 4754 :     /*  If there are no samples waiting for completion then there     */
; 4755 :     /*  are no more buffers queued by the waveOutWrite() function.    */
; 4756 :     /*  In this case release the wave output device by calling the    */
; 4757 :     /*  waveOutClose() function. If there are more samples in the     */
; 4758 :     /*  audio queue then a restart will eventually occur.             */
; 4759 :     /******************************************************************/
; 4760 : 
; 4761 : 	// tek 13may97
; 4762 : 	// this was a check on ( pPlayAudio->iSamplesWaitingForCompletion <= 0 )
; 4763 : 	// but I don't think that is quite correct; we could have no 
; 4764 : 	// samples waiting for completion (in the queue, but sent to the 
; 4765 : 	// device) but still have samples that haven't been sent yet. 
; 4766 : 	// if there are any samples left in the queue after the above update,
; 4767 : 	// then either we still have buffers at the device OR we have
; 4768 : 	// samples that have not yet been sent to the device.
; 4769 : 
; 4770 :     if ( pPlayAudioRing->iQueueCount <= 0 ) //tek 13may97

  01940	8b 7f 18	 mov	 edi, DWORD PTR [edi+24]
  01943	83 c4 08	 add	 esp, 8
  01946	85 ff		 test	 edi, edi
  01948	7f 15		 jg	 SHORT $L71559

; 4771 :     {
; 4772 : 
; 4773 : #ifdef AUD_DEBUG  //tek 13may97
; 4774 :   {
; 4775 : 		  char  szTemp[256]="";
; 4776 : 		  sprintf(szTemp,"ProcWOMDONE: Closing. iQueueCount=%ld\n",
; 4777 : 					pPlayAudioRing->iQueueCount);
; 4778 : 		  OutputDebugString(szTemp);
; 4779 :   }
; 4780 : #endif //AUD_DEBUG
; 4781 : 		// because we're done with this waveheader, clear the lpData field
; 4782 : 		// so that we can reuse it later.. 
; 4783 : 		pWaveHdr->lpData = NULL;
; 4784 :       ClosePlayDevice( pPlayAudio );

  0194a	56		 push	 esi
  0194b	c7 45 00 00 00
	00 00		 mov	 DWORD PTR [ebp], 0
  01952	e8 00 00 00 00	 call	 _ClosePlayDevice
  01957	83 c4 04	 add	 esp, 4

; 4785 :     }
; 4786 :     else

  0195a	e9 b2 00 00 00	 jmp	 $L71581
$L71559:

; 4787 :     {
; 4788 :       /****************************************************************/
; 4789 :       /*  Determine the number of unwritten samples remaining in the  */
; 4790 :       /*  audio queue. Protect the Queue Count.                       */
; 4791 :       /****************************************************************/
; 4792 : 	  // tek 16may97
; 4793 : 	  // we need to hold the mutex while we do the buffer write, else 
; 4794 : 	  // StartAudioPlaying may collide with this and write the same
; 4795 : 	  // thing twice.
; 4796 : 	  // tek 06nov97 this is now part of the larger mutex range
; 4797 :       //OP_LockMutex( pPlayAudio->hmxQueueCount );
; 4798 :       dwRemaining = pPlayAudioRing->iQueueCount -
; 4799 :                      pPlayAudio->iSamplesWaitingForCompletion;

  0195f	2b 7e 30	 sub	 edi, DWORD PTR [esi+48]

; 4800 : #ifdef AUD_DEBUG  //tek 13may97
; 4801 :   {
; 4802 : 		  char  szTemp[256]="";
; 4803 : 		  sprintf(szTemp,"ProcWOMDONE: dwRemaining=%ld\n",
; 4804 : 					dwRemaining);
; 4805 : 		  OutputDebugString(szTemp);
; 4806 :   }
; 4807 : #endif //AUD_DEBUG
; 4808 : 
; 4809 :       /****************************************************************/
; 4810 :       /*  If there are any samples remaining in the audio queue then  */
; 4811 :       /*  write up as many samples as the WriteBufferToWaveDevice()   */
; 4812 :       /*  function allows.                                            */
; 4813 :       /****************************************************************/
; 4814 : 
; 4815 :       if ( dwRemaining > 0 )

  01962	85 ff		 test	 edi, edi
  01964	7e 7b		 jle	 SHORT $L71562

; 4816 :       {
; 4817 :         /**************************************************************/
; 4818 :         /*  Write the next buffer to the output device.               */
; 4819 :         /**************************************************************/	
; 4820 : 		// tek 24jul97 in the presence of SYNCs, we can end up with 
; 4821 : 		// only a single buffer outstanding. To correct this, we'll try 
; 4822 : 		// to write several buffers if we don't have all of them outstanding
; 4823 : 		UINT uiWriteSize = dwRemaining;
; 4824 : 
; 4825 : 		if (pPlayAudio->iOutstandingBuffers < MAXIMUM_BUFFERS_QUEUED-2)

  01966	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  0196c	8b df		 mov	 ebx, edi
  0196e	83 f8 06	 cmp	 eax, 6
  01971	7d 19		 jge	 SHORT $L71564

; 4826 : 		{
; 4827 : #ifndef UNDER_CE // tek 23mar99 write fewer, larger buffers for CE
; 4828 : 			if (pPlayAudio->iOutstandingBuffers < MAXIMUM_BUFFERS_QUEUED-3)

  01973	83 f8 05	 cmp	 eax, 5
  01976	7d 05		 jge	 SHORT $L71565

; 4829 : 			{
; 4830 : 				uiWriteSize = dwRemaining>>2; // try to write 4

  01978	c1 fb 02	 sar	 ebx, 2

; 4831 : 			}
; 4832 : 			else

  0197b	eb 02		 jmp	 SHORT $L71566
$L71565:

; 4833 : #endif //UNDER_CE
; 4834 : 			{
; 4835 : 				uiWriteSize = dwRemaining>>1; // try to write 2

  0197d	d1 fb		 sar	 ebx, 1
$L71566:

; 4836 : 			}
; 4837 : 			// but don't write too little
; 4838 : 			// (make sure that we don't leave a tiny amount behind..)
; 4839 : 			if (uiWriteSize < MINIMUM_STARTUP_WRITE_SIZE)

  0197f	81 fb 40 06 00
	00		 cmp	 ebx, 1600		; 00000640H
  01985	73 02		 jae	 SHORT $L71567

; 4840 : 				uiWriteSize = dwRemaining;

  01987	8b df		 mov	 ebx, edi
$L71567:

; 4841 : 			// 015	MGS		12/15/1998	Fixed odd byte problem to audio device and BATS #844
; 4842 : 			uiWriteSize &= ~0x01;

  01989	83 e3 fe	 and	 ebx, -2			; fffffffeH
$L71564:

; 4843 : 
; 4844 : 		}
; 4845 : #ifdef UNDER_CE
; 4846 : 		if (!pPlayAudio->bConvertToEightBit)	uiWriteSize &= 0xFFFFFFFE;		// Let's not send in a half-block
; 4847 : #endif
; 4848 : 
; 4849 :         dwRemaining -= WriteBufferToWaveDevice( pPlayAudio,
; 4850 :                                  pWaveHdr,
; 4851 :                                  (unsigned int)uiWriteSize );

  0198c	53		 push	 ebx
  0198d	55		 push	 ebp
  0198e	56		 push	 esi
  0198f	e8 00 00 00 00	 call	 _WriteBufferToWaveDevice
  01994	83 c4 0c	 add	 esp, 12			; 0000000cH
  01997	2b f8		 sub	 edi, eax
  01999	33 ed		 xor	 ebp, ebp
$L71569:

; 4852 : 
; 4853 : 
; 4854 : 		// now, go find a free header to write what's left. This 
; 4855 : 		// loop is copied from StartAudioPlaying.
; 4856 : 		for ( uiI = 0;
; 4857 : 			  ( uiI < MAXIMUM_BUFFERS_QUEUED ) && ( dwRemaining > 0 ) && (pPlayAudio->iOutstandingBuffers < MAXIMUM_BUFFERS_QUEUED) ;
; 4858 : 			  uiI++ )

  0199b	85 ff		 test	 edi, edi
  0199d	7e 72		 jle	 SHORT $L71581
  0199f	83 be a4 00 00
	00 08		 cmp	 DWORD PTR [esi+164], 8
  019a6	7d 69		 jge	 SHORT $L71581

; 4859 : 		{
; 4860 : 		  if ( uiWriteSize > dwRemaining)

  019a8	3b df		 cmp	 ebx, edi
  019aa	76 02		 jbe	 SHORT $L71572

; 4861 : 		  {
; 4862 : 			uiWriteSize = dwRemaining;

  019ac	8b df		 mov	 ebx, edi
$L71572:

; 4863 : 		  }
; 4864 : 		  // check to make sure that this is a free waveheader, and
; 4865 : 		  // write it if it is. (tek 13may97)
; 4866 : 		  if (pPlayAudio->ppWaveHdr[uiI]->lpData == NULL)

  019ae	8b 8e 94 00 00
	00		 mov	 ecx, DWORD PTR [esi+148]
  019b4	8b 04 29	 mov	 eax, DWORD PTR [ecx+ebp]
  019b7	83 38 00	 cmp	 DWORD PTR [eax], 0
  019ba	75 1b		 jne	 SHORT $L71570

; 4867 : 		  {
; 4868 : #ifdef AUD_DEBUG
; 4869 : 		    {
; 4870 : 		      char  szTemp[256]="";
; 4871 : 		      sprintf(szTemp,"ProcWOMDONE: dwRemaining=%ld, uiWriteLength=%d, using header %d (%08lx) at %lu\n",
; 4872 : 			      dwRemaining,
; 4873 : 			      uiWriteSize,
; 4874 : 			      uiI,
; 4875 : 			      pPlayAudio->ppWaveHdr[uiI],
; 4876 : 			      timeGetTime()
; 4877 : 			      );
; 4878 : 		      OutputDebugString(szTemp);
; 4879 : 		    }
; 4880 : #endif //AUD_DEBUG  
; 4881 : 		    
; 4882 : #ifdef UNDER_CE
; 4883 : 		    if (!pPlayAudio->bConvertToEightBit)	uiWriteSize &= 0xFFFFFFFE;		// Let's not send in a half-block
; 4884 : #endif
; 4885 : 		    
; 4886 : 		    dwRemaining -= WriteBufferToWaveDevice( pPlayAudio,
; 4887 : 												   pPlayAudio->ppWaveHdr[uiI],
; 4888 : 												   uiWriteSize );

  019bc	53		 push	 ebx
  019bd	50		 push	 eax
  019be	56		 push	 esi
  019bf	e8 00 00 00 00	 call	 _WriteBufferToWaveDevice
  019c4	2b f8		 sub	 edi, eax
  019c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4889 : 		  // don't leave a runt around..
; 4890 : 		  if (dwRemaining - uiWriteSize < MINIMUM_STARTUP_WRITE_SIZE)

  019c9	8b d7		 mov	 edx, edi
  019cb	2b d3		 sub	 edx, ebx
  019cd	81 fa 40 06 00
	00		 cmp	 edx, 1600		; 00000640H
  019d3	73 02		 jae	 SHORT $L71570

; 4891 : 				uiWriteSize = dwRemaining;

  019d5	8b df		 mov	 ebx, edi
$L71570:

; 4852 : 
; 4853 : 
; 4854 : 		// now, go find a free header to write what's left. This 
; 4855 : 		// loop is copied from StartAudioPlaying.
; 4856 : 		for ( uiI = 0;
; 4857 : 			  ( uiI < MAXIMUM_BUFFERS_QUEUED ) && ( dwRemaining > 0 ) && (pPlayAudio->iOutstandingBuffers < MAXIMUM_BUFFERS_QUEUED) ;
; 4858 : 			  uiI++ )

  019d7	83 c5 04	 add	 ebp, 4
  019da	83 fd 20	 cmp	 ebp, 32			; 00000020H
  019dd	7c bc		 jl	 SHORT $L71569

; 4892 : 
; 4893 : 		  }
; 4894 : 		  else
; 4895 : 		  {
; 4896 : #ifdef AUD_DEBUG
; 4897 : 			  {
; 4898 : 					  char  szTemp[256]="";
; 4899 : 					  sprintf(szTemp,"ProcWOMDONE: header %d (%08lx) is busy at %lu\n",
; 4900 : 						  uiI,
; 4901 : 						  pPlayAudio->ppWaveHdr[uiI],
; 4902 : 						  timeGetTime()
; 4903 : 						  );
; 4904 : 					  OutputDebugString(szTemp);
; 4905 : 			  }
; 4906 : #endif //AUD_DEBUG  
; 4907 : 		  }
; 4908 : 		}
; 4909 : 		
; 4910 :       }
; 4911 : 	  else //tek 13may97 if we're done with the header, null the 

  019df	eb 30		 jmp	 SHORT $L71581
$L71562:

; 4912 : 		   // lpData field so we know it is free.
; 4913 : 	  {
; 4914 : 		  pWaveHdr->lpData = NULL;

  019e1	c7 45 00 00 00
	00 00		 mov	 DWORD PTR [ebp], 0

; 4915 : 	  }
; 4916 : 	  // tek 06nov97 move this out of this branch
; 4917 :       //OP_UnlockMutex( pPlayAudio->hmxQueueCount );
; 4918 : 
; 4919 :     }
; 4920 :   }
; 4921 :   else

  019e8	eb 27		 jmp	 SHORT $L71581
$L71556:

; 4922 :   {
; 4923 : 	  // tek 13may97 in any event, we're done with this header..
; 4924 : 	  pWaveHdr->lpData = NULL;

  019ea	c7 45 00 00 00
	00 00		 mov	 DWORD PTR [ebp], 0

; 4925 :     /******************************************************************/
; 4926 :     /*  The audio state is equal to AUDIO_STATE_RESET. In reset mode  */
; 4927 :     /*  the queue count has already been set to zero. If there are no */
; 4928 :     /*  samples playing then signal that the reset is complete.       */
; 4929 :     /******************************************************************/
; 4930 : 
; 4931 :     if ( pPlayAudio->iSamplesWaitingForCompletion <= 0 )

  019f1	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  019f4	85 c0		 test	 eax, eax
  019f6	7f 19		 jg	 SHORT $L71581

; 4932 :     {
; 4933 :       pPlayAudio->dwAudioPlayState = AUDIO_STATE_PLAY;
; 4934 : 
; 4935 :       ClosePlayDevice( pPlayAudio );

  019f8	56		 push	 esi
  019f9	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  01a00	e8 00 00 00 00	 call	 _ClosePlayDevice

; 4936 : 
; 4937 :       OP_SetEvent( pPlayAudio->hevResetComplete );

  01a05	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  01a08	50		 push	 eax
  01a09	e8 00 00 00 00	 call	 _OP_SetEvent
  01a0e	83 c4 08	 add	 esp, 8
$L71581:

; 4938 :     }
; 4939 :   }
; 4940 : 
; 4941 :   /********************************************************************/
; 4942 :   /*  Signal that the Queue is not full.                              */
; 4943 :   /********************************************************************/
; 4944 : 
; 4945 :   OP_SetEvent( pPlayAudio->hevQueueNotFull );

  01a11	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  01a14	51		 push	 ecx
  01a15	e8 00 00 00 00	 call	 _OP_SetEvent

; 4946 :   //tek 06nov97 finally release the mutex here.
; 4947 :   OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  01a1a	8b 56 7c	 mov	 edx, DWORD PTR [esi+124]
  01a1d	52		 push	 edx
  01a1e	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01a23	83 c4 08	 add	 esp, 8

; 4948 :   return FALSE;

  01a26	33 c0		 xor	 eax, eax
  01a28	5f		 pop	 edi
  01a29	5e		 pop	 esi
  01a2a	5d		 pop	 ebp
  01a2b	5b		 pop	 ebx

; 4949 : }

  01a2c	c3		 ret	 0
_Process_MM_WOM_DONE_Message ENDP
_pPlayAudio$ = 8
_Process_MM_WOM_CLOSE_Message PROC NEAR

; 4978 : {

  01a30	56		 push	 esi

; 4979 : #ifdef AUD_DEBUG	 // tek 13may97
; 4980 :   {
; 4981 : 		  char  szTemp[256]="";
; 4982 : 		  sprintf(szTemp,"ProcWOMCLOSE: outstanding now %d at %08lu\n",
; 4983 : 			  pPlayAudio->iOutstandingBuffers,
; 4984 : 			  timeGetTime()
; 4985 : 			  );
; 4986 : 		  OutputDebugString(szTemp);
; 4987 :   }
; 4988 : #endif //AUD_DEBUG
; 4989 :   /********************************************************************/
; 4990 :   /*  If the audio device is not owned then clear the handle now.     */
; 4991 :   /********************************************************************/
; 4992 : 
; 4993 :   if (( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE ) == 0 )

  01a31	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  01a35	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  01a39	75 07		 jne	 SHORT $L71585

; 4994 :   {
; 4995 :     pPlayAudio->hWaveOut = (int)NULL;

  01a3b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$L71585:

; 4996 :   }
; 4997 : 
; 4998 :   /********************************************************************/
; 4999 :   /*  Set the audio device state and unblock the timer thread.        */
; 5000 :   /********************************************************************/
; 5001 : 
; 5002 :   OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  01a42	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  01a45	50		 push	 eax
  01a46	e8 00 00 00 00	 call	 _OP_LockMutex

; 5003 :   pPlayAudio->dwAudioDeviceState = AUDIO_DEVICE_INACTIVE;
; 5004 :   OP_SetEvent( pPlayAudio->hevTimerThreadActive );

  01a4b	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  01a4e	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
  01a55	51		 push	 ecx
  01a56	e8 00 00 00 00	 call	 _OP_SetEvent

; 5005 :   OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  01a5b	8b 56 70	 mov	 edx, DWORD PTR [esi+112]
  01a5e	52		 push	 edx
  01a5f	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 5006 : 
; 5007 :   /********************************************************************/
; 5008 :   /*  Unblock the PA_WaitForPlayToComplete() function.                */
; 5009 :   /********************************************************************/
; 5010 : 
; 5011 :   OP_SetEvent( pPlayAudio->hevAudioDeviceInactive );

  01a64	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  01a67	50		 push	 eax
  01a68	e8 00 00 00 00	 call	 _OP_SetEvent

; 5012 : 
; 5013 :   /********************************************************************/
; 5014 :   /*  Signal the application that the audio has stopped.              */
; 5015 :   /********************************************************************/
; 5016 : 
; 5017 :   if ( pPlayAudio->bReportPlayStop )

  01a6d	8b 46 64	 mov	 eax, DWORD PTR [esi+100]
  01a70	83 c4 10	 add	 esp, 16			; 00000010H
  01a73	85 c0		 test	 eax, eax
  01a75	74 14		 je	 SHORT $L72110

; 5018 :   {
; 5019 :     ReportStatusToApplication( pPlayAudio,
; 5020 :                                PA_PLAY_STOP,
; 5021 :                                0 );

  01a77	6a 00		 push	 0
  01a79	6a 02		 push	 2
  01a7b	56		 push	 esi
  01a7c	e8 00 00 00 00	 call	 _ReportStatusToApplication
  01a81	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5022 : 
; 5023 :     pPlayAudio->bReportPlayStop = FALSE;

  01a84	c7 46 64 00 00
	00 00		 mov	 DWORD PTR [esi+100], 0
$L72110:

; 5024 :   }
; 5025 : 
; 5026 :   return FALSE;

  01a8b	33 c0		 xor	 eax, eax
  01a8d	5e		 pop	 esi

; 5027 : }

  01a8e	c3		 ret	 0
_Process_MM_WOM_CLOSE_Message ENDP
_pPlayAudio$ = 8
_dwPosition$ = 8
_ClosePlayDevice PROC NEAR

; 5057 : {

  01a90	56		 push	 esi

; 5058 :   DWORD dwPosition;
; 5059 : 
; 5060 :   /********************************************************************/
; 5061 :   /*  If the user owns the audio device then just perform the same    */
; 5062 :   /*  processing that receiving a MM_WOM_CLOSE message would cause.   */
; 5063 :   /*  Otherwise call the waveOutClose() function to release the wave  */
; 5064 :   /*  output device. This will cause the wave device driver to send   */
; 5065 :   /*  an MM_WOM_CLOSE message when the wave output device is          */
; 5066 :   /*  released. At that time the Audio Device State will be set to    */
; 5067 :   /*  AUDIO_DEVICE_INACTIVE.                                          */
; 5068 :   /********************************************************************/
; 5069 : 
; 5070 :   if ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )

  01a91	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  01a95	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  01a99	74 0b		 je	 SHORT $L71593

; 5071 :   {
; 5072 :     Process_MM_WOM_CLOSE_Message( pPlayAudio );

  01a9b	56		 push	 esi
  01a9c	e8 00 00 00 00	 call	 _Process_MM_WOM_CLOSE_Message
  01aa1	83 c4 04	 add	 esp, 4
  01aa4	5e		 pop	 esi

; 5086 :   }
; 5087 : 
; 5088 :   return;
; 5089 : }

  01aa5	c3		 ret	 0
$L71593:

; 5073 :   }
; 5074 :   else
; 5075 :   {
; 5076 :     OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  01aa6	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  01aa9	50		 push	 eax
  01aaa	e8 00 00 00 00	 call	 _OP_LockMutex

; 5077 :     pPlayAudio->dwAudioDeviceState = AUDIO_DEVICE_SHUTTING_DOWN;
; 5078 :     OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  01aaf	8b 4e 70	 mov	 ecx, DWORD PTR [esi+112]
  01ab2	c7 46 34 03 00
	00 00		 mov	 DWORD PTR [esi+52], 3
  01ab9	51		 push	 ecx
  01aba	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 5079 : 
; 5080 :     AudioPosition( pPlayAudio, &dwPosition );

  01abf	8d 54 24 10	 lea	 edx, DWORD PTR _dwPosition$[esp+8]
  01ac3	52		 push	 edx
  01ac4	56		 push	 esi
  01ac5	e8 00 00 00 00	 call	 _AudioPosition

; 5081 : 
; 5082 :     pPlayAudio->dwPositionBase += dwPosition;

  01aca	8b 44 24 18	 mov	 eax, DWORD PTR _dwPosition$[esp+16]
  01ace	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  01ad1	03 c8		 add	 ecx, eax
  01ad3	83 c4 10	 add	 esp, 16			; 00000010H
  01ad6	89 4e 40	 mov	 DWORD PTR [esi+64], ecx

; 5083 : 
; 5084 :     LOCK_MME_CALL( waveOutClose( pPlayAudio->hWaveOut ))

  01ad9	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01adc	51		 push	 ecx
  01add	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutClose@4

; 5085 : 	pPlayAudio->bResetPaused = FALSE;

  01ae3	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0
  01aea	5e		 pop	 esi

; 5086 :   }
; 5087 : 
; 5088 :   return;
; 5089 : }

  01aeb	c3		 ret	 0
_ClosePlayDevice ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutPrepareHeader@12:NEAR
EXTRN	__imp__waveOutWrite@12:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pWaveHdr$ = 12
_uiLength$ = 16
_WriteBufferToWaveDevice PROC NEAR

; 5127 :   unsigned int uiI;
; 5128 :   int iNumberToMoveToQueueTop;
; 5129 :   unsigned int uiWriteLength;
; 5130 :   short * pWordSource;
; 5131 :   LPAUDIO_T pByteDest;
; 5132 :   LPPLAY_RING_T pPlayAudioRing;
; 5133 :   MMRESULT mmStatus;
; 5134 : 
; 5135 : #ifdef AUD_DEBUG  //tek 13may97
; 5136 :   {
; 5137 : 		  char  szTemp[256]="";
; 5138 : 		  pPlayAudioRing = pPlayAudio->pPlayAudioRing;
; 5139 : 		  sprintf(szTemp,"WBTWOD size=%d at %08lx; out=%d; waiting=%d qcount=%d at %08lu\n",
; 5140 : 			  uiLength, 
; 5141 : 			  pWaveHdr,
; 5142 : 			  pPlayAudio->iOutstandingBuffers, 
; 5143 : 			  pPlayAudio->iSamplesWaitingForCompletion,
; 5144 : 			  pPlayAudioRing->iQueueCount,
; 5145 : 			  timeGetTime()
; 5146 : 			  );
; 5147 : 		  OutputDebugString(szTemp);
; 5148 :   }
; 5149 : #endif //AUD_DEBUG
; 5150 : 
; 5151 :   /********************************************************************/
; 5152 :   /*  Limit the length to be written.                                 */
; 5153 :   /********************************************************************/
; 5154 : 
; 5155 :   if ( uiLength > pPlayAudio->uiMaximumWriteLength )

  01af0	8b 54 24 04	 mov	 edx, DWORD PTR _pPlayAudio$[esp-4]
  01af4	53		 push	 ebx
  01af5	55		 push	 ebp
  01af6	8b 6c 24 14	 mov	 ebp, DWORD PTR _uiLength$[esp+4]
  01afa	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  01afd	56		 push	 esi
  01afe	3b e8		 cmp	 ebp, eax
  01b00	57		 push	 edi
  01b01	76 02		 jbe	 SHORT $L71609

; 5156 :   {
; 5157 :     uiLength = pPlayAudio->uiMaximumWriteLength;

  01b03	8b e8		 mov	 ebp, eax
$L71609:

; 5158 :   }
; 5159 : 
; 5160 :   /********************************************************************/
; 5161 :   /*  If necessary, wrap the output pointer and move data.            */
; 5162 :   /*  First ensure that the next buffer of data that is written does  */
; 5163 :   /*  not extend beyond the end of the queue. If it does then all     */
; 5164 :   /*  samples starting at the the current output pointer to the last  */
; 5165 :   /*  location at the end of the queue will be moved to the extra     */
; 5166 :   /*  space above the queue start. Set the output pointer to the      */
; 5167 :   /*  start of this data and set the output position relative to      */
; 5168 :   /*  the buffer start (i.e. the output buffer position will end      */
; 5169 :   /*  up either negative or zero).                                    */
; 5170 :   /********************************************************************/
; 5171 : 
; 5172 :   pPlayAudioRing = pPlayAudio->pPlayAudioRing;

  01b05	8b 9a 98 00 00
	00		 mov	 ebx, DWORD PTR [edx+152]

; 5173 : 
; 5174 :   if ( pPlayAudioRing->iOutputPosition + (int)uiLength
; 5175 :                                     > pPlayAudioRing->iQueueLength )

  01b0b	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  01b0e	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  01b11	8d 34 29	 lea	 esi, DWORD PTR [ecx+ebp]
  01b14	3b f0		 cmp	 esi, eax
  01b16	7e 2b		 jle	 SHORT $L71611

; 5176 :   {
; 5177 :     /******************************************************************/
; 5178 :     /*  Move samples to the top of the queue.                         */
; 5179 :     /******************************************************************/
; 5180 : 
; 5181 :     iNumberToMoveToQueueTop =
; 5182 :       pPlayAudioRing->iQueueLength - pPlayAudioRing->iOutputPosition;
; 5183 : 
; 5184 :     /******************************************************************/
; 5185 :     /*  pByteSource = pPlayAudioRing->pQueueOutput;                   */
; 5186 :     /*  pByteDest =                                                   */
; 5187 :     /*    pPlayAudioRing->pQueueStart - iNumberToMoveToQueueTop;      */
; 5188 :     /*                                                                */
; 5189 :     /*  for ( uiI = 0; uiI < iNumberToMoveToQueueTop; uiI++ )         */
; 5190 :     /*    *pByteDest++ = *pByteSource++;                              */
; 5191 :     /******************************************************************/
; 5192 : 
; 5193 :     memcpy( pPlayAudioRing->pQueueStart - iNumberToMoveToQueueTop,
; 5194 :             pPlayAudioRing->pQueueOutput,
; 5195 :             iNumberToMoveToQueueTop );

  01b18	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  01b1b	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
  01b1e	2b c1		 sub	 eax, ecx
  01b20	8b c8		 mov	 ecx, eax
  01b22	2b f8		 sub	 edi, eax
  01b24	8b d1		 mov	 edx, ecx
  01b26	c1 e9 02	 shr	 ecx, 2
  01b29	f3 a5		 rep movsd
  01b2b	8b ca		 mov	 ecx, edx

; 5196 : 
; 5197 :     pPlayAudioRing->pQueueOutput =
; 5198 :       pPlayAudioRing->pQueueStart - iNumberToMoveToQueueTop;
; 5199 :     pPlayAudioRing->iOutputPosition = - iNumberToMoveToQueueTop;

  01b2d	8b 54 24 14	 mov	 edx, DWORD PTR _pPlayAudio$[esp+12]
  01b31	83 e1 03	 and	 ecx, 3
  01b34	f3 a4		 rep movsb
  01b36	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  01b39	2b c8		 sub	 ecx, eax
  01b3b	f7 d8		 neg	 eax
  01b3d	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx
  01b40	89 43 14	 mov	 DWORD PTR [ebx+20], eax
$L71611:

; 5200 :   }
; 5201 : 
; 5202 :   /********************************************************************/
; 5203 :   /*  If the waveOutOpen() function has opened a device that requires */
; 5204 :   /*  8 bit samples and 16 bit samples were queued, then convert the  */
; 5205 :   /*  samples to 8 bits here.                                         */
; 5206 :   /********************************************************************/
; 5207 : 
; 5208 :   if ( pPlayAudio->bConvertToEightBit )

  01b43	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  01b46	33 ff		 xor	 edi, edi
  01b48	3b c7		 cmp	 eax, edi
  01b4a	74 25		 je	 SHORT $L71612

; 5209 :   {
; 5210 :     pByteDest = pPlayAudioRing->pQueueOutput;

  01b4c	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 5211 :     pWordSource = (short *)pByteDest;
; 5212 : 
; 5213 :     for ( uiI = 0; uiI < uiLength; uiI++ )

  01b4f	3b ef		 cmp	 ebp, edi
  01b51	8b f0		 mov	 esi, eax
  01b53	76 16		 jbe	 SHORT $L71616

; 5209 :   {
; 5210 :     pByteDest = pPlayAudioRing->pQueueOutput;

  01b55	8b fd		 mov	 edi, ebp
$L71614:

; 5214 :       *pByteDest++ = (unsigned char)((*pWordSource++) >> 8 ) ^ 0x80;

  01b57	66 8b 0e	 mov	 cx, WORD PTR [esi]
  01b5a	83 c6 02	 add	 esi, 2
  01b5d	c1 f9 08	 sar	 ecx, 8
  01b60	80 f1 80	 xor	 cl, 128			; 00000080H
  01b63	88 08		 mov	 BYTE PTR [eax], cl
  01b65	40		 inc	 eax
  01b66	4f		 dec	 edi
  01b67	75 ee		 jne	 SHORT $L71614

; 5211 :     pWordSource = (short *)pByteDest;
; 5212 : 
; 5213 :     for ( uiI = 0; uiI < uiLength; uiI++ )

  01b69	33 ff		 xor	 edi, edi
$L71616:

; 5215 : 
; 5216 :     uiWriteLength = uiLength >> 1;

  01b6b	8b c5		 mov	 eax, ebp
  01b6d	d1 e8		 shr	 eax, 1

; 5217 :   }
; 5218 :   else

  01b6f	eb 02		 jmp	 SHORT $L71618
$L71612:

; 5219 :   {
; 5220 :     uiWriteLength = uiLength;

  01b71	8b c5		 mov	 eax, ebp
$L71618:

; 5221 :   }
; 5222 : 
; 5223 :   /********************************************************************/
; 5224 :   /*  Set up the WAVEHDR structure.                                   */
; 5225 :   /*  Save the buffer length in the high 16 bits of the dwUser        */
; 5226 :   /*  element of the wave header.                                     */
; 5227 :   /********************************************************************/
; 5228 : 
; 5229 : #ifdef UNDER_CE
; 5230 :   if (!pPlayAudio->bConvertToEightBit && uiWriteLength & 0x01) {
; 5231 : 	  if (uiWriteLength & 0x01)		MessageBox(NULL, _T("Misalligned data"), _T("DECtalk"), MB_OK);
; 5232 : 	  return uiWriteLength;			// Throw away the packet!!!
; 5233 :   }
; 5234 : #endif
; 5235 :   pWaveHdr->lpData          = (char *)pPlayAudioRing->pQueueOutput;

  01b73	8b 74 24 18	 mov	 esi, DWORD PTR _pWaveHdr$[esp+12]
  01b77	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]

; 5236 :   pWaveHdr->dwBufferLength  = uiWriteLength;
; 5237 :   pWaveHdr->dwBytesRecorded = 0L;
; 5238 :   pWaveHdr->dwUser          = (DWORD)uiLength;
; 5239 :   pWaveHdr->dwFlags         = 0L;
; 5240 :   pWaveHdr->dwLoops         = 0L;
; 5241 :   pWaveHdr->lpNext          = NULL;
; 5242 :   pWaveHdr->reserved        = 0L;
; 5243 : 
; 5244 :   /********************************************************************/
; 5245 :   /*  Prepare the header for the waveOutWrite() function.             */
; 5246 :   /********************************************************************/
; 5247 : 
; 5248 : #ifndef USE_MME_SERVER
; 5249 : 
; 5250 :   mmStatus = waveOutPrepareHeader( pPlayAudio->hWaveOut,
; 5251 :                                    pWaveHdr,
; 5252 :                                    sizeof(WAVEHDR));

  01b7a	6a 20		 push	 32			; 00000020H
  01b7c	56		 push	 esi
  01b7d	89 0e		 mov	 DWORD PTR [esi], ecx
  01b7f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  01b82	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  01b85	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  01b88	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  01b8b	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  01b8e	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  01b91	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  01b94	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  01b97	52		 push	 edx
  01b98	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutPrepareHeader@12

; 5253 : 
; 5254 :   if ( mmStatus != MMSYSERR_NOERROR )

  01b9e	3b c7		 cmp	 eax, edi
  01ba0	74 17		 je	 SHORT $L71623

; 5255 :   {
; 5256 : #ifdef AUD_DEBUG
; 5257 : 	  OutputDebugString("WriteBufferToWaveDevice: waveOutPrepareHeader failed.\n");
; 5258 : #endif
; 5259 : 	  ReportStatusToApplication( pPlayAudio,
; 5260 :                                PA_WRITE_ERROR,
; 5261 :                                mmStatus );

  01ba2	50		 push	 eax
  01ba3	8b 44 24 18	 mov	 eax, DWORD PTR _pPlayAudio$[esp+16]
  01ba7	6a 07		 push	 7
  01ba9	50		 push	 eax

; 5307 :   }
; 5308 :   else
; 5309 :   {
; 5310 :     /******************************************************************/
; 5311 :     /*  Report any errors that occured.                               */
; 5312 :     /******************************************************************/
; 5313 : #ifdef AUD_DEBUG
; 5314 : 	OutputDebugString("WriteBufferToWaveDevice: waveOutWrite failed.\n");
; 5315 : #endif
; 5316 :     ReportStatusToApplication( pPlayAudio,
; 5317 :                                PA_WRITE_ERROR,
; 5318 :                                mmStatus );

  01baa	e8 00 00 00 00	 call	 _ReportStatusToApplication
  01baf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5319 :     return 0;

  01bb2	33 c0		 xor	 eax, eax
  01bb4	5f		 pop	 edi
  01bb5	5e		 pop	 esi
  01bb6	5d		 pop	 ebp
  01bb7	5b		 pop	 ebx

; 5323 : }

  01bb8	c3		 ret	 0
$L71623:

; 5262 :     return 0;
; 5263 :   }
; 5264 : 
; 5265 : #endif
; 5266 : 
; 5267 :   /********************************************************************/
; 5268 :   /*  Write the buffer to the wave output device.                     */
; 5269 :   /********************************************************************/
; 5270 : 
; 5271 :   LOCK_MME_CALL( mmStatus = waveOutWrite( pPlayAudio->hWaveOut,
; 5272 :                                           pWaveHdr,
; 5273 :                                           sizeof(WAVEHDR)))

  01bb9	6a 20		 push	 32			; 00000020H
  01bbb	56		 push	 esi
  01bbc	8b 74 24 1c	 mov	 esi, DWORD PTR _pPlayAudio$[esp+20]
  01bc0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01bc3	51		 push	 ecx
  01bc4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutWrite@12

; 5274 : 
; 5275 :   if ( mmStatus == MMSYSERR_NOERROR )

  01bca	3b c7		 cmp	 eax, edi
  01bcc	75 2c		 jne	 SHORT $L71625

; 5276 :   {
; 5277 : 	  // tek 09may97
; 5278 : 	  pPlayAudio->iOutstandingBuffers++;// keep track..

  01bce	8b be a4 00 00
	00		 mov	 edi, DWORD PTR [esi+164]

; 5279 : #ifdef USE_MME_SERVER
; 5280 : 
; 5281 :     /******************************************************************/
; 5282 :     /*  MME BUG WORKAROUND. Because the MME server currently does not */
; 5283 :     /*  return wave headers in the correct order, it is necessary to  */
; 5284 :     /*  put wave headers on a list whenever a wave header is written  */
; 5285 :     /*  by the waveOutWrite() function. This list is accessed in the  */
; 5286 :     /*  wave output callback routine to determine the current header. */
; 5287 :     /******************************************************************/
; 5288 : 
; 5289 :     pPlayAudio->ppWaveHdrInUseList[pPlayAudio->uiWaveHdrWriteIndex] = pWaveHdr;
; 5290 : 
; 5291 :     pPlayAudio->uiWaveHdrWriteIndex++;
; 5292 : 
; 5293 :     if ( pPlayAudio->uiWaveHdrWriteIndex >= MAXIMUM_BUFFERS_QUEUED )
; 5294 :     {
; 5295 :       pPlayAudio->uiWaveHdrWriteIndex = 0;
; 5296 :     }
; 5297 : 
; 5298 : #endif
; 5299 : 
; 5300 :     /******************************************************************/
; 5301 :     /*  Update the output pointers and the "samples waiting" count.   */
; 5302 :     /******************************************************************/
; 5303 : 
; 5304 :     pPlayAudio->iSamplesWaitingForCompletion += uiLength;

  01bd4	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  01bd7	47		 inc	 edi
  01bd8	03 d5		 add	 edx, ebp
  01bda	89 be a4 00 00
	00		 mov	 DWORD PTR [esi+164], edi
  01be0	89 56 30	 mov	 DWORD PTR [esi+48], edx

; 5305 :     pPlayAudioRing->pQueueOutput += uiLength;

  01be3	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]

; 5306 :     pPlayAudioRing->iOutputPosition += uiLength;

  01be6	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  01be9	03 cd		 add	 ecx, ebp
  01beb	03 c5		 add	 eax, ebp
  01bed	89 43 14	 mov	 DWORD PTR [ebx+20], eax
  01bf0	5f		 pop	 edi

; 5320 :   }
; 5321 : 
; 5322 :   return uiLength;

  01bf1	8b c5		 mov	 eax, ebp
  01bf3	5e		 pop	 esi
  01bf4	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx
  01bf7	5d		 pop	 ebp
  01bf8	5b		 pop	 ebx

; 5323 : }

  01bf9	c3		 ret	 0
$L71625:

; 5307 :   }
; 5308 :   else
; 5309 :   {
; 5310 :     /******************************************************************/
; 5311 :     /*  Report any errors that occured.                               */
; 5312 :     /******************************************************************/
; 5313 : #ifdef AUD_DEBUG
; 5314 : 	OutputDebugString("WriteBufferToWaveDevice: waveOutWrite failed.\n");
; 5315 : #endif
; 5316 :     ReportStatusToApplication( pPlayAudio,
; 5317 :                                PA_WRITE_ERROR,
; 5318 :                                mmStatus );

  01bfa	50		 push	 eax
  01bfb	6a 07		 push	 7
  01bfd	56		 push	 esi
  01bfe	e8 00 00 00 00	 call	 _ReportStatusToApplication
  01c03	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5319 :     return 0;

  01c06	33 c0		 xor	 eax, eax
  01c08	5f		 pop	 edi
  01c09	5e		 pop	 esi
  01c0a	5d		 pop	 ebp
  01c0b	5b		 pop	 ebx

; 5323 : }

  01c0c	c3		 ret	 0
_WriteBufferToWaveDevice ENDP
_pPlayAudio$ = 8
_ProcessOpenWaveOutputDeviceMessage PROC NEAR

; 5351 : {

  01c10	56		 push	 esi

; 5352 :   /********************************************************************/
; 5353 :   /*  If the wave output device is not closed then abort.             */
; 5354 :   /*  This check is necessary because the PA_Queue() function and     */
; 5355 :   /*  the Timer thread might send both the ID_Open_Wave_Output_Device */
; 5356 :   /*  message before either occurence of the message can be processed */
; 5357 :   /*  Also abort if the pause flag is set.                            */
; 5358 :   /********************************************************************/
; 5359 : 
; 5360 :   if (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )
; 5361 :     && ( ! pPlayAudio->bPaused ))

  01c11	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  01c15	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  01c18	85 c0		 test	 eax, eax
  01c1a	75 5c		 jne	 SHORT $L72117
  01c1c	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  01c1f	85 c0		 test	 eax, eax
  01c21	75 55		 jne	 SHORT $L72117

; 5362 :   {
; 5363 :     /******************************************************************/
; 5364 :     /*  IF the wave output device is owned by the application and     */
; 5365 :     /*     the wave output device is already opened,                  */
; 5366 :     /*  THEN                                                          */
; 5367 :     /*    There will be no MM_WOM_OPEN message generated so start     */
; 5368 :     /*    audio playing right now.                                    */
; 5369 :     /*  ELSE                                                          */
; 5370 :     /*    Open the wave audio device.                                 */
; 5371 :     /*    The Process_MM_WOM_OPEN_Message function will start audio   */
; 5372 :     /*    playing later.                                              */
; 5373 :     /******************************************************************/
; 5374 : 
; 5375 :     if (( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )
; 5376 :       && ( pPlayAudio->hWaveOut != (int)NULL ))

  01c23	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  01c27	74 1d		 je	 SHORT $L71633
  01c29	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01c2c	85 c0		 test	 eax, eax
  01c2e	74 16		 je	 SHORT $L71633

; 5377 :     {
; 5378 :       /****************************************************************/
; 5379 :       /*  Block the PA_WaitForPlayToComplete() function.              */
; 5380 :       /****************************************************************/
; 5381 : 
; 5382 :       OP_ResetEvent( pPlayAudio->hevAudioDeviceInactive );

  01c30	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  01c33	50		 push	 eax
  01c34	e8 00 00 00 00	 call	 _OP_ResetEvent

; 5383 : 
; 5384 :       /****************************************************************/
; 5385 :       /*  Set the device state.                                       */
; 5386 :       /****************************************************************/
; 5387 : 
; 5388 : 	  // tek 16mar98 we should never set the device state, because 
; 5389 : 	  // StartAudioPlaying manages that..! (bats622)
; 5390 :       //OP_LockMutex( pPlayAudio->hmxAudioDeviceState );
; 5391 :       //pPlayAudio->dwAudioDeviceState = AUDIO_DEVICE_ACTIVE;
; 5392 :       //OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );
; 5393 : 
; 5394 :       StartAudioPlaying( pPlayAudio );

  01c39	56		 push	 esi
  01c3a	e8 00 00 00 00	 call	 _StartAudioPlaying
  01c3f	83 c4 08	 add	 esp, 8

; 5413 :       }
; 5414 :     }
; 5415 :   }
; 5416 : 
; 5417 :   return FALSE;

  01c42	33 c0		 xor	 eax, eax
  01c44	5e		 pop	 esi

; 5418 : }

  01c45	c3		 ret	 0
$L71633:

; 5395 :     }
; 5396 :     else
; 5397 :     {
; 5398 :       if ( OpenWaveOutputDevice( pPlayAudio ) == MMSYSERR_NOERROR )

  01c46	56		 push	 esi
  01c47	e8 00 00 00 00	 call	 _OpenWaveOutputDevice
  01c4c	83 c4 04	 add	 esp, 4
  01c4f	85 c0		 test	 eax, eax
  01c51	75 25		 jne	 SHORT $L72117

; 5399 :       {
; 5400 :         /**************************************************************/
; 5401 :         /*  Block the PA_WaitForPlayToComplete() function.            */
; 5402 :         /**************************************************************/
; 5403 : 
; 5404 :         OP_ResetEvent( pPlayAudio->hevAudioDeviceInactive );

  01c53	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  01c56	51		 push	 ecx
  01c57	e8 00 00 00 00	 call	 _OP_ResetEvent

; 5405 : 
; 5406 :         /**************************************************************/
; 5407 :         /*  Set the device state.                                     */
; 5408 :         /**************************************************************/
; 5409 : 
; 5410 :         OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  01c5c	8b 56 70	 mov	 edx, DWORD PTR [esi+112]
  01c5f	52		 push	 edx
  01c60	e8 00 00 00 00	 call	 _OP_LockMutex

; 5411 :         pPlayAudio->dwAudioDeviceState = AUDIO_DEVICE_STARTING_UP;
; 5412 :         OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  01c65	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  01c68	c7 46 34 01 00
	00 00		 mov	 DWORD PTR [esi+52], 1
  01c6f	50		 push	 eax
  01c70	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01c75	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72117:

; 5413 :       }
; 5414 :     }
; 5415 :   }
; 5416 : 
; 5417 :   return FALSE;

  01c78	33 c0		 xor	 eax, eax
  01c7a	5e		 pop	 esi

; 5418 : }

  01c7b	c3		 ret	 0
_ProcessOpenWaveOutputDeviceMessage ENDP
_TEXT	ENDS
PUBLIC	_WaveOutCallbackRoutine@20
EXTRN	__imp__waveOutOpen@24:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_dwSampleRate$ = -4
_mmStatus$ = 8
_OpenWaveOutputDevice PROC NEAR

; 5447 : {

  01c80	51		 push	 ecx
  01c81	53		 push	 ebx
  01c82	55		 push	 ebp
  01c83	56		 push	 esi
  01c84	57		 push	 edi

; 5448 :   DWORD dwSampleRate=0;
; 5449 :   DWORD dwNumberOfChannels=0;
; 5450 :   DWORD dwBytesPerSample=0;
; 5451 :   DWORD dwOpenFlags=0;
; 5452 :   LPWAVEFORMATEX pWaveFormat;
; 5453 :   MMRESULT mmStatus;
; 5454 : 
; 5455 :   /********************************************************************/
; 5456 :   /*  The default state is no sample conversion.                      */
; 5457 :   /********************************************************************/
; 5458 : 
; 5459 :   pPlayAudio->bConvertToEightBit = FALSE;

  01c85	8b 7c 24 18	 mov	 edi, DWORD PTR _pPlayAudio$[esp+16]
  01c89	33 d2		 xor	 edx, edx
  01c8b	33 db		 xor	 ebx, ebx
  01c8d	89 54 24 10	 mov	 DWORD PTR _dwSampleRate$[esp+20], edx

; 5460 : 
; 5461 :   /********************************************************************/
; 5462 :   /*  Initialize the local WAVEFORMATEX structure.                    */
; 5463 :   /********************************************************************/
; 5464 : 
; 5465 :   pWaveFormat = pPlayAudio->pWaveFormat;

  01c91	8b b7 a0 00 00
	00		 mov	 esi, DWORD PTR [edi+160]
  01c97	89 57 50	 mov	 DWORD PTR [edi+80], edx

; 5466 : 
; 5467 :   /********************************************************************/
; 5468 :   /*  If the WAVEFORMATEX data structure has a wFormatTag element     */
; 5469 :   /*  equal to WAVE_FORMAT_PCM then the device is opened for either   */
; 5470 :   /*  16 or 8 bit output. Whether 8 or 16 bits will succeed depends   */
; 5471 :   /*  on the audio data size and the audio driver. If the audio       */
; 5472 :   /*  samples are 16 bits and only 8 bit output is supported by the   */
; 5473 :   /*  audio driver then the 16 bit audio samples are converted to 8   */
; 5474 :   /*  bit audio samples in the WriteBufferToWaveDevice() function.    */
; 5475 :   /*  This conversion is indicated by the bConvertToEightBit flag.    */
; 5476 :   /*  The wBitsPerSample element, the nChannels element , and         */
; 5477 :   /*  the nSamplesPerSec element of the WAVEFORMATEX structure are    */
; 5478 :   /*  used to calculate the values of the other elements of the       */
; 5479 :   /*  WAVEFORMATEX structure.                                         */
; 5480 :   /*                                                                  */
; 5481 :   /*  If the wFormatTag element of the WAVEFORMATEX structure         */
; 5482 :   /*  is NOT equal to WAVE_FORMAT_PCM then all of the fields of the   */
; 5483 :   /*  WAVEFORMATEX structure must be filled in and are used in the    */
; 5484 :   /*  call to the waveOutOpen() function.                             */
; 5485 :   /********************************************************************/
; 5486 : 
; 5487 :   if ( pWaveFormat->wFormatTag == WAVE_FORMAT_PCM )

  01c9a	66 83 3e 01	 cmp	 WORD PTR [esi], 1
  01c9e	75 2a		 jne	 SHORT $L71645

; 5488 :   {
; 5489 :     /******************************************************************/
; 5490 :     /*  The wFormatTag element is equal to WAVE_FORMAT_PCM.           */
; 5491 :     /******************************************************************/
; 5492 : 
; 5493 :     dwSampleRate = pWaveFormat->nSamplesPerSec;
; 5494 :     dwNumberOfChannels = pWaveFormat->nChannels;

  01ca0	66 8b 5e 02	 mov	 bx, WORD PTR [esi+2]

; 5495 :     dwBytesPerSample = pWaveFormat->wBitsPerSample >> 3;

  01ca4	33 c0		 xor	 eax, eax
  01ca6	66 8b 46 0e	 mov	 ax, WORD PTR [esi+14]
  01caa	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  01cad	c1 e8 03	 shr	 eax, 3

; 5496 : 
; 5497 :     /******************************************************************/
; 5498 :     /*  Initialize other WAVEFORMATEX structure elements.             */
; 5499 :     /******************************************************************/
; 5500 : 
; 5501 :     pWaveFormat->nAvgBytesPerSec =
; 5502 :       dwSampleRate * dwNumberOfChannels * dwBytesPerSample;

  01cb0	8b e8		 mov	 ebp, eax
  01cb2	89 4c 24 10	 mov	 DWORD PTR _dwSampleRate$[esp+20], ecx
  01cb6	0f af eb	 imul	 ebp, ebx
  01cb9	0f af e9	 imul	 ebp, ecx

; 5503 :     pWaveFormat->nBlockAlign =
; 5504 :       (WORD)( dwNumberOfChannels * dwBytesPerSample );

  01cbc	0f af c3	 imul	 eax, ebx
  01cbf	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  01cc2	66 89 46 0c	 mov	 WORD PTR [esi+12], ax

; 5505 :     pWaveFormat->cbSize = 0;

  01cc6	66 89 56 10	 mov	 WORD PTR [esi+16], dx
$L71645:

; 5506 : 
; 5507 :   }
; 5508 : 
; 5509 :   /********************************************************************/
; 5510 :   /*  Set the wave out device open flags.                             */
; 5511 :   /********************************************************************/
; 5512 : 
; 5513 :   dwOpenFlags = CALLBACK_FUNCTION;
; 5514 :   
; 5515 : #ifdef USE_MME_SERVER
; 5516 : 
; 5517 :   /********************************************************************/
; 5518 :   /*  If the WAVE_OPEN_SHARE bit is set in the device options then    */
; 5519 :   /*  enable device sharing.                                          */
; 5520 :   /********************************************************************/
; 5521 : 
; 5522 :   if ( pPlayAudio->dwDeviceOptions & WAVE_OPEN_SHAREABLE )
; 5523 :   {
; 5524 :     dwOpenFlags |= WAVE_OPEN_SHAREABLE;
; 5525 :   }
; 5526 : 
; 5527 : #endif
; 5528 : 
; 5529 :   /********************************************************************/
; 5530 :   /*  Attempt to open the wave output device.                         */
; 5531 :   /********************************************************************/
; 5532 : #ifdef AUD_DEBUG
; 5533 :   OutputDebugString("OpenWaveOutputDevice: waveOutOpen() {1}\n");
; 5534 : #endif
; 5535 : 
; 5536 : #ifdef OS_SIXTY_FOUR_BIT
; 5537 :  
; 5538 :   LOCK_MME_CALL(
; 5539 :     mmStatus = waveOutOpen( &(pPlayAudio->hWaveOut),
; 5540 :                             pPlayAudio->uiSelectedDeviceID,
; 5541 :                             (LPWAVEFORMAT)pWaveFormat,
; 5542 :                             WaveOutCallbackRoutine,
; 5543 :                             pPlayAudio->uiHandleListIndex,
; 5544 :                             dwOpenFlags ))
; 5545 : #else
; 5546 :  
; 5547 :   LOCK_MME_CALL(
; 5548 :     mmStatus = waveOutOpen( &(pPlayAudio->hWaveOut),
; 5549 :                             pPlayAudio->uiSelectedDeviceID,
; 5550 :                             (LPWAVEFORMATEX)pWaveFormat,
; 5551 :                             (DWORD)WaveOutCallbackRoutine,
; 5552 :                             (DWORD)pPlayAudio,
; 5553 :                             dwOpenFlags ))

  01cca	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  01ccd	68 00 00 03 00	 push	 196608			; 00030000H
  01cd2	57		 push	 edi
  01cd3	68 00 00 00 00	 push	 OFFSET FLAT:_WaveOutCallbackRoutine@20
  01cd8	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  01cdb	56		 push	 esi
  01cdc	51		 push	 ecx
  01cdd	50		 push	 eax
  01cde	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutOpen@24
  01ce4	8b e8		 mov	 ebp, eax

; 5554 : #endif
; 5555 : 
; 5556 : #ifdef USE_MME_SERVER
; 5557 : 
; 5558 :   /********************************************************************/
; 5559 :   /*  THIS IS PROBABLY NOT NECESSARY, BUT IT CANNOT HURT.             */
; 5560 :   /*  The MME servers waveOutOpen() function returns a value of       */
; 5561 :   /*  WAVERR_DEVICESHAREABLE if the device is shareable. Change       */
; 5562 :   /*  this to MMSYSERR_NOERROR.                                       */
; 5563 :   /********************************************************************/
; 5564 : 
; 5565 :   if (( pPlayAudio->dwDeviceOptions & WAVE_OPEN_SHAREABLE )
; 5566 :     && ( mmStatus == WAVERR_DEVICESHAREABLE ))
; 5567 :   {
; 5568 :     mmStatus = MMSYSERR_NOERROR;
; 5569 :   }
; 5570 : 
; 5571 : #endif
; 5572 : 
; 5573 :   /********************************************************************/
; 5574 :   /*  If the requested wave output format is WAVE_FORMAT_PCM and the  */
; 5575 :   /*  number of bits per sample is 16 and the format is not supported */
; 5576 :   /*  then try to open the wave output device for 8 bit samples.      */
; 5577 :   /********************************************************************/
; 5578 : 
; 5579 :   if  (( mmStatus == WAVERR_BADFORMAT )
; 5580 :     && ( pWaveFormat->wFormatTag == WAVE_FORMAT_PCM )
; 5581 :     && ( pWaveFormat->wBitsPerSample == 16 ))

  01ce6	83 fd 20	 cmp	 ebp, 32			; 00000020H
  01ce9	75 5e		 jne	 SHORT $L71650
  01ceb	66 83 3e 01	 cmp	 WORD PTR [esi], 1
  01cef	75 5c		 jne	 SHORT $L72121
  01cf1	66 83 7e 0e 10	 cmp	 WORD PTR [esi+14], 16	; 00000010H
  01cf6	75 55		 jne	 SHORT $L72121

; 5582 :   {
; 5583 :     /******************************************************************/
; 5584 :     /*  Initialize other WAVEFORMATEX structure elements for 8 bit    */
; 5585 :     /*  data.                                                         */
; 5586 :     /******************************************************************/
; 5587 : 
; 5588 :     pWaveFormat->nAvgBytesPerSec = dwSampleRate * dwNumberOfChannels;

  01cf8	8b eb		 mov	 ebp, ebx

; 5589 :     pWaveFormat->nBlockAlign = (WORD)dwNumberOfChannels;
; 5590 :     pWaveFormat->wBitsPerSample = 8;
; 5591 : 
; 5592 :     /******************************************************************/
; 5593 :     /*  Attempt to open the wave output device.                       */
; 5594 :     /******************************************************************/
; 5595 : #ifdef AUD_DEBUG
; 5596 :     OutputDebugString("OpenWaveOutputDevice: waveOutOpen() {2}\n");
; 5597 : #endif
; 5598 : 
; 5599 : #ifdef OS_SIXTY_FOUR_BIT
; 5600 : 
; 5601 :     LOCK_MME_CALL(
; 5602 :       mmStatus = waveOutOpen( &(pPlayAudio->hWaveOut),
; 5603 :                               pPlayAudio->uiSelectedDeviceID,
; 5604 :                               (LPWAVEFORMAT)pWaveFormat,
; 5605 :                               WaveOutCallbackRoutine,
; 5606 :                               pPlayAudio->uiHandleListIndex,
; 5607 :                               dwOpenFlags ))
; 5608 : #else
; 5609 : 
; 5610 :     LOCK_MME_CALL(
; 5611 :       mmStatus = waveOutOpen( &(pPlayAudio->hWaveOut),
; 5612 :                               pPlayAudio->uiSelectedDeviceID,
; 5613 :                               (LPWAVEFORMATEX)pWaveFormat,
; 5614 :                               (DWORD)WaveOutCallbackRoutine,
; 5615 :                               (DWORD)pPlayAudio,
; 5616 :                               dwOpenFlags ))

  01cfa	68 00 00 03 00	 push	 196608			; 00030000H
  01cff	0f af 6c 24 14	 imul	 ebp, DWORD PTR _dwSampleRate$[esp+24]
  01d04	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  01d07	66 89 5e 0c	 mov	 WORD PTR [esi+12], bx
  01d0b	66 c7 46 0e 08
	00		 mov	 WORD PTR [esi+14], 8
  01d11	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
  01d14	57		 push	 edi
  01d15	68 00 00 00 00	 push	 OFFSET FLAT:_WaveOutCallbackRoutine@20
  01d1a	56		 push	 esi
  01d1b	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  01d1e	52		 push	 edx
  01d1f	50		 push	 eax
  01d20	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutOpen@24
  01d26	89 44 24 18	 mov	 DWORD PTR _mmStatus$[esp+16], eax

; 5617 : #endif
; 5618 : 
; 5619 : #ifdef USE_MME_SERVER
; 5620 : 
; 5621 :     /******************************************************************/
; 5622 :     /*  THIS IS PROBABLY NOT NECESSARY, BUT IT CANNOT HURT.           */
; 5623 :     /*  The MME servers waveOutOpen() function returns a value of     */
; 5624 :     /*  WAVERR_DEVICESHAREABLE if the device is shareable. Change     */
; 5625 :     /*  this to MMSYSERR_NOERROR.                                     */
; 5626 :     /******************************************************************/
; 5627 : 
; 5628 :     if (( pPlayAudio->dwDeviceOptions & WAVE_OPEN_SHAREABLE )
; 5629 :       && ( mmStatus == WAVERR_DEVICESHAREABLE ))
; 5630 :     {
; 5631 :       mmStatus = MMSYSERR_NOERROR;
; 5632 :     }
; 5633 : 
; 5634 : #endif
; 5635 : 
; 5636 :     /******************************************************************/
; 5637 :     /*  Reset the WAVEFORMATEX structure elements for 16 bit data.    */
; 5638 :     /******************************************************************/
; 5639 : 
; 5640 :     pWaveFormat->nAvgBytesPerSec =
; 5641 :       dwSampleRate * dwNumberOfChannels << 1;

  01d2a	8d 44 2d 00	 lea	 eax, DWORD PTR [ebp+ebp]

; 5642 :     pWaveFormat->nBlockAlign = (WORD)( dwNumberOfChannels << 1 );
; 5643 :     pWaveFormat->wBitsPerSample = 16;
; 5644 : 
; 5645 :     pPlayAudio->bConvertToEightBit = TRUE;

  01d2e	8b 6c 24 18	 mov	 ebp, DWORD PTR _mmStatus$[esp+16]
  01d32	8d 0c 1b	 lea	 ecx, DWORD PTR [ebx+ebx]
  01d35	89 46 08	 mov	 DWORD PTR [esi+8], eax
  01d38	66 89 4e 0c	 mov	 WORD PTR [esi+12], cx
  01d3c	66 c7 46 0e 10
	00		 mov	 WORD PTR [esi+14], 16	; 00000010H
  01d42	c7 47 50 01 00
	00 00		 mov	 DWORD PTR [edi+80], 1
$L71650:

; 5646 :   }
; 5647 : 
; 5648 :   /********************************************************************/
; 5649 :   /*  Test for an open error.                                         */
; 5650 :   /********************************************************************/
; 5651 : 
; 5652 :   if ( mmStatus )

  01d49	85 ed		 test	 ebp, ebp
  01d4b	74 1a		 je	 SHORT $L72122
$L72121:

; 5653 :   {
; 5654 :     /******************************************************************/
; 5655 :     /*  The error that occured WAS caused by another application      */
; 5656 :     /*  owning the wave output device.                                */
; 5657 :     /******************************************************************/
; 5658 : #ifdef AUD_DEBUG
; 5659 : 	  {
; 5660 : #include <stdio.h>
; 5661 : 		  char szTemp[256]="";
; 5662 : 		  sprintf(szTemp,"OpenWaveOutputDevice: waveOutOpen failed: status=%lu (%08lx)\n",
; 5663 : 			  mmStatus, mmStatus);
; 5664 : 		  OutputDebugString(szTemp);
; 5665 : 	  }
; 5666 : #endif //AUD_DEBUG
; 5667 :     if ( pPlayAudio->bEnableOpenErrorMessage )

  01d4d	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  01d50	85 c0		 test	 eax, eax
  01d52	74 13		 je	 SHORT $L72122

; 5668 :     {
; 5669 :       if ( ! ReportStatusToApplication( pPlayAudio,
; 5670 :                                         PA_DEVICE_OPEN_FAILURE,
; 5671 :                                         mmStatus ))

  01d54	55		 push	 ebp
  01d55	6a 03		 push	 3
  01d57	57		 push	 edi
  01d58	e8 00 00 00 00	 call	 _ReportStatusToApplication
  01d5d	83 c4 0c	 add	 esp, 12			; 0000000cH
  01d60	85 c0		 test	 eax, eax
  01d62	75 03		 jne	 SHORT $L72122

; 5672 :       {
; 5673 :         pPlayAudio->bEnableOpenErrorMessage = FALSE;

  01d64	89 47 60	 mov	 DWORD PTR [edi+96], eax
$L72122:
  01d67	5f		 pop	 edi

; 5674 :       }
; 5675 :     }
; 5676 :   }
; 5677 : 
; 5678 :   return mmStatus;

  01d68	8b c5		 mov	 eax, ebp
  01d6a	5e		 pop	 esi
  01d6b	5d		 pop	 ebp
  01d6c	5b		 pop	 ebx

; 5679 : }

  01d6d	59		 pop	 ecx
  01d6e	c3		 ret	 0
_OpenWaveOutputDevice ENDP
_pWaveFormat$ = 8
_GetWaveFormatSize PROC NEAR

; 5707 :   DWORD dwSize;
; 5708 : 
; 5709 :   if ( pWaveFormat->wFormatTag == WAVE_FORMAT_PCM )

  01d70	8b 44 24 04	 mov	 eax, DWORD PTR _pWaveFormat$[esp-4]
  01d74	66 83 38 01	 cmp	 WORD PTR [eax], 1
  01d78	75 06		 jne	 SHORT $L71663

; 5710 :   {
; 5711 :     dwSize = sizeof(WAVEFORMATEX);

  01d7a	b8 12 00 00 00	 mov	 eax, 18			; 00000012H

; 5716 :   }
; 5717 : 
; 5718 :   return dwSize;
; 5719 : }

  01d7f	c3		 ret	 0
$L71663:

; 5712 :   }
; 5713 :   else
; 5714 :   {
; 5715 :     dwSize = sizeof(WAVEFORMATEX) + pWaveFormat->cbSize;

  01d80	33 c9		 xor	 ecx, ecx
  01d82	66 8b 48 10	 mov	 cx, WORD PTR [eax+16]
  01d86	8b c1		 mov	 eax, ecx
  01d88	83 c0 12	 add	 eax, 18			; 00000012H

; 5716 :   }
; 5717 : 
; 5718 :   return dwSize;
; 5719 : }

  01d8b	c3		 ret	 0
_GetWaveFormatSize ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutReset@4:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_dwVolume$71672 = 8
_ProcessResetMessage PROC NEAR

; 5747 : {

  01d90	53		 push	 ebx
  01d91	56		 push	 esi

; 5748 :   MMRESULT mmStatus;
; 5749 : 
; 5750 :   /********************************************************************/
; 5751 :   /*  This flag causes the timer thread to abandon sending any        */
; 5752 :   /*  synchronization marks until it reaches the start of the timer   */
; 5753 :   /*  thread main loop.                                               */
; 5754 :   /********************************************************************/
; 5755 : 
; 5756 :   pPlayAudio->bTimerThreadReset = TRUE;

  01d92	8b 74 24 0c	 mov	 esi, DWORD PTR _pPlayAudio$[esp+4]
  01d96	57		 push	 edi
  01d97	bf 01 00 00 00	 mov	 edi, 1

; 5757 : 
; 5758 : 
; 5759 :   // tek 22jan99 ResetAudioQueue now happens further down
; 5760 : 
; 5761 :   /********************************************************************/
; 5762 :   /*  Set audio position counts to zero.                              */
; 5763 :   /********************************************************************/
; 5764 : 
; 5765 :   pPlayAudio->dwPositionBase = 0;
; 5766 : 
; 5767 :   OP_LockMutex( pPlayAudio->hmxBytesPlayed );

  01d9c	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  01d9f	89 7e 6c	 mov	 DWORD PTR [esi+108], edi
  01da2	50		 push	 eax
  01da3	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], 0
  01daa	e8 00 00 00 00	 call	 _OP_LockMutex

; 5768 :   pPlayAudio->dwBytesPlayed = 0;
; 5769 :   OP_UnlockMutex( pPlayAudio->hmxBytesPlayed );

  01daf	8b 4e 74	 mov	 ecx, DWORD PTR [esi+116]
  01db2	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0
  01db9	51		 push	 ecx
  01dba	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 5770 : 
; 5771 :   /********************************************************************/
; 5772 :   /*  Zero the "queued byte" counter.                                 */
; 5773 :   /********************************************************************/
; 5774 : 
; 5775 :   OP_LockMutex( pPlayAudio->hmxQueuedByteCount );

  01dbf	8b 96 84 00 00
	00		 mov	 edx, DWORD PTR [esi+132]
  01dc5	52		 push	 edx
  01dc6	e8 00 00 00 00	 call	 _OP_LockMutex

; 5776 :   pPlayAudio->dwQueuedByteCount = 0;
; 5777 :   OP_UnlockMutex( pPlayAudio->hmxQueuedByteCount );

  01dcb	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01dd1	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
  01dd8	50		 push	 eax
  01dd9	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 5778 : 
; 5779 :   /********************************************************************/
; 5780 :   /*  Free all synchronization marks in the synchronization mark      */
; 5781 :   /*  linked list.                                                    */
; 5782 :   /********************************************************************/
; 5783 : 
; 5784 :   ClearSynchronizationMarkList( pPlayAudio );

  01dde	56		 push	 esi
  01ddf	e8 00 00 00 00	 call	 _ClearSynchronizationMarkList

; 5785 : 
; 5786 :   /********************************************************************/
; 5787 :   /*  If the audio device is open then reset it and return all wave   */
; 5788 :   /*  headers. Then the Process_MM_WOM_DONE_Message() function will   */
; 5789 :   /*  clear the "Reset Complete" event when all buffers have          */
; 5790 :   /*  completed. Otherwise clear the "Reset Complete" event here.     */
; 5791 :   /********************************************************************/
; 5792 : 
; 5793 :   if (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )
; 5794 :       && ( pPlayAudio->iSamplesWaitingForCompletion != 0 ))

  01de4	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  01de7	83 c4 14	 add	 esp, 20			; 00000014H
  01dea	83 f8 02	 cmp	 eax, 2
  01ded	0f 85 82 00 00
	00		 jne	 $L71671
  01df3	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  01df6	85 c0		 test	 eax, eax
  01df8	74 7b		 je	 SHORT $L71671

; 5795 :     {
; 5796 : #ifdef TYPING_MODE
; 5797 :       DWORD dwVolume; // tek 19nov97
; 5798 :       MMRESULT mmVolSetStatus; // tek 19nov97
; 5799 : #endif //TYPING_MODE
; 5800 :       
; 5801 :       pPlayAudio->dwAudioPlayState = AUDIO_STATE_RESET;
; 5802 : #ifdef TYPING_MODE
; 5803 :       // tek 19nov97 set the volume to zero before doing the reset, 
; 5804 :       // and put it back later.
; 5805 :       // this is part of bats518, but we need to do it here at a very
; 5806 :       // low level so we don't leave the wave device in a bad state if we
; 5807 :       // get aborted
; 5808 :       mmVolSetStatus = waveOutGetVolume(pPlayAudio->hWaveOut,&dwVolume);

  01dfa	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  01dfd	8d 4c 24 10	 lea	 ecx, DWORD PTR _dwVolume$71672[esp+8]
  01e01	51		 push	 ecx
  01e02	52		 push	 edx
  01e03	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  01e06	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetVolume@8
  01e0c	8b f8		 mov	 edi, eax

; 5809 :       if (mmVolSetStatus ==  MMSYSERR_NOERROR)

  01e0e	85 ff		 test	 edi, edi
  01e10	75 0d		 jne	 SHORT $L71674

; 5810 : 	{
; 5811 : 	  mmVolSetStatus = waveOutSetVolume(pPlayAudio->hWaveOut,0);

  01e12	50		 push	 eax
  01e13	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01e16	50		 push	 eax
  01e17	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutSetVolume@8
  01e1d	8b f8		 mov	 edi, eax
$L71674:

; 5812 : 	}
; 5813 : #endif //TYPING_MODE
; 5814 :   
; 5815 : //	We're gonna do a PAUSE / RESET / RESET
; 5816 : 	  LOCK_MME_CALL( mmStatus = waveOutPause( pPlayAudio->hWaveOut ))

  01e1f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01e22	51		 push	 ecx
  01e23	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutPause@4

; 5817 : 	  pPlayAudio->bResetPaused = TRUE;
; 5818 : 
; 5819 :       LOCK_MME_CALL( mmStatus = waveOutReset( pPlayAudio->hWaveOut ))

  01e29	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  01e2c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__waveOutReset@4
  01e32	52		 push	 edx
  01e33	c7 46 5c 01 00
	00 00		 mov	 DWORD PTR [esi+92], 1
  01e3a	ff d3		 call	 ebx

; 5820 : 
; 5821 :       LOCK_MME_CALL( mmStatus = waveOutReset( pPlayAudio->hWaveOut ))

  01e3c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01e3f	50		 push	 eax
  01e40	ff d3		 call	 ebx

; 5822 : 
; 5823 : #ifdef TYPING_MODE
; 5824 : 	if (mmVolSetStatus ==  MMSYSERR_NOERROR)

  01e42	85 ff		 test	 edi, edi
  01e44	8b d8		 mov	 ebx, eax
  01e46	75 0f		 jne	 SHORT $L72129

; 5825 : 	  {
; 5826 : 	    mmVolSetStatus = waveOutSetVolume(pPlayAudio->hWaveOut,dwVolume);

  01e48	8b 4c 24 10	 mov	 ecx, DWORD PTR _dwVolume$71672[esp+8]
  01e4c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  01e4f	51		 push	 ecx
  01e50	52		 push	 edx
  01e51	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutSetVolume@8
$L72129:

; 5827 : 	  }
; 5828 : #endif //TYPING_MODE
; 5829 :       
; 5830 :     }  // if (( pPlayAudio...
; 5831 :   else

  01e57	bf 01 00 00 00	 mov	 edi, 1
$L71676:

; 5845 :   }
; 5846 :   // tek 22jan99 if audio is truly dead, we can call ResetAudioQueue now.
; 5847 :   if ( pPlayAudio->iSamplesWaitingForCompletion == 0 )

  01e5c	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  01e5f	85 c0		 test	 eax, eax
  01e61	75 09		 jne	 SHORT $L72128

; 5848 :   {
; 5849 : 	  ResetAudioQueue(pPlayAudio);

  01e63	56		 push	 esi
  01e64	e8 00 00 00 00	 call	 _ResetAudioQueue
  01e69	83 c4 04	 add	 esp, 4
$L72128:

; 5850 :   }
; 5851 : 
; 5852 : 
; 5853 :   /********************************************************************/
; 5854 :   /*  Enable the sending of Device open failure error messages.       */
; 5855 :   /********************************************************************/
; 5856 : 
; 5857 :   pPlayAudio->bEnableOpenErrorMessage = TRUE;

  01e6c	89 7e 60	 mov	 DWORD PTR [esi+96], edi
  01e6f	5f		 pop	 edi

; 5858 : 
; 5859 :   return mmStatus;

  01e70	8b c3		 mov	 eax, ebx
  01e72	5e		 pop	 esi
  01e73	5b		 pop	 ebx

; 5860 : }

  01e74	c3		 ret	 0
$L71671:
  01e75	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  01e78	50		 push	 eax
  01e79	e8 00 00 00 00	 call	 _OP_SetEvent

; 5832 :     {
; 5833 :       OP_SetEvent( pPlayAudio->hevResetComplete );

  01e7e	83 c4 04	 add	 esp, 4

; 5834 : #ifdef AUD_DEBUG //tek 22may97
; 5835 :       {
; 5836 : 		  char szTemp[256]="";
; 5837 : 		  sprintf(szTemp,"ProcResetMsg: calling waveOutReset at %ld\n",
; 5838 : 			  timeGetTime()
; 5839 : 			  );
; 5840 : 		  OutputDebugString(szTemp);
; 5841 : 	  }
; 5842 : #endif //AUD_DEBUG
; 5843 : 	  
; 5844 :     mmStatus = MMSYSERR_NOERROR;

  01e81	33 db		 xor	 ebx, ebx
  01e83	eb d7		 jmp	 SHORT $L71676
_ProcessResetMessage ENDP
_pPlayAudio$ = 8
_ClearSynchronizationMarkList PROC NEAR

; 5888 : {

  01e90	53		 push	 ebx

; 5889 :   LPSYNC_MARK_T pSyncMark;
; 5890 :   LPSYNC_MARK_T pNextSyncMark;
; 5891 : 
; 5892 :   /********************************************************************/
; 5893 :   /*  Free all synchronization marks in the synchronization mark      */
; 5894 :   /*  linked list.                                                    */
; 5895 :   /********************************************************************/
; 5896 : 
; 5897 :   OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  01e91	8b 5c 24 08	 mov	 ebx, DWORD PTR _pPlayAudio$[esp]
  01e95	8b 83 8c 00 00
	00		 mov	 eax, DWORD PTR [ebx+140]
  01e9b	50		 push	 eax
  01e9c	e8 00 00 00 00	 call	 _OP_LockMutex

; 5898 : 
; 5899 :   pSyncMark = pPlayAudio->pSyncMarkList;

  01ea1	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [ebx+156]
  01ea7	83 c4 04	 add	 esp, 4

; 5900 :   pPlayAudio->pSyncMarkList = NULL;
; 5901 : 
; 5902 :   while ( pSyncMark != NULL )

  01eaa	85 c0		 test	 eax, eax
  01eac	c7 83 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+156], 0
  01eb6	74 18		 je	 SHORT $L71687
  01eb8	56		 push	 esi
  01eb9	57		 push	 edi
  01eba	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
$L71686:

; 5903 :   {
; 5904 :     pNextSyncMark = pSyncMark->pLink;

  01ec0	8b 30		 mov	 esi, DWORD PTR [eax]

; 5905 : 
; 5906 :     free( pSyncMark );

  01ec2	50		 push	 eax
  01ec3	ff d7		 call	 edi
  01ec5	83 c4 04	 add	 esp, 4

; 5907 : 
; 5908 :     pSyncMark = pNextSyncMark;

  01ec8	8b c6		 mov	 eax, esi
  01eca	85 f6		 test	 esi, esi
  01ecc	75 f2		 jne	 SHORT $L71686
  01ece	5f		 pop	 edi
  01ecf	5e		 pop	 esi
$L71687:

; 5909 :   }
; 5910 : 
; 5911 :   OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  01ed0	8b 8b 8c 00 00
	00		 mov	 ecx, DWORD PTR [ebx+140]
  01ed6	51		 push	 ecx
  01ed7	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01edc	83 c4 04	 add	 esp, 4
  01edf	5b		 pop	 ebx

; 5912 : 
; 5913 :   return;
; 5914 : }

  01ee0	c3		 ret	 0
_ClearSynchronizationMarkList ENDP
_pPlayAudio$ = 8
_ResetAudioQueue PROC NEAR

; 5943 : {

  01ef0	56		 push	 esi
  01ef1	57		 push	 edi

; 5944 :   LPPLAY_RING_T pPlayAudioRing;
; 5945 :   unsigned int uiI; //tek 22may97
; 5946 :   pPlayAudioRing = pPlayAudio->pPlayAudioRing;

  01ef2	8b 7c 24 0c	 mov	 edi, DWORD PTR _pPlayAudio$[esp+4]

; 5947 : 
; 5948 : //tek 22may97
; 5949 : #ifdef AUD_DEBUG
; 5950 :   {
; 5951 : 		  char  szTemp[256]="";
; 5952 : 		  sprintf(szTemp,"ResetAudioQueue: at %08lu\n",
; 5953 : 			  timeGetTime()
; 5954 : 			  );
; 5955 : 		  OutputDebugString(szTemp);
; 5956 :   }
; 5957 : #endif //AUD_DEBUG
; 5958 :   // tek 05nov97 bats 508? (HJ Echo problem)
; 5959 :   // this needs to be done under the QueueCount mutex..
; 5960 : 
; 5961 :   OP_LockMutex( pPlayAudio->hmxQueueCount ); // own the audio queue...

  01ef6	8b 47 7c	 mov	 eax, DWORD PTR [edi+124]
  01ef9	8b b7 98 00 00
	00		 mov	 esi, DWORD PTR [edi+152]
  01eff	50		 push	 eax
  01f00	e8 00 00 00 00	 call	 _OP_LockMutex

; 5962 :   pPlayAudioRing->pQueueInput = pPlayAudioRing->pQueueStart;

  01f05	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 5963 :   pPlayAudioRing->pQueueOutput = pPlayAudioRing->pQueueStart;
; 5964 :   pPlayAudioRing->iInputPosition = 0;

  01f08	33 c9		 xor	 ecx, ecx
  01f0a	83 c4 04	 add	 esp, 4
  01f0d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  01f10	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  01f13	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 5965 :   pPlayAudioRing->iOutputPosition = 0;

  01f16	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 5966 :   pPlayAudioRing->iQueueCount = 0;

  01f19	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
  01f1c	33 c0		 xor	 eax, eax
$L71693:

; 5967 : 
; 5968 :   // we use the lpData field of each wave header to signal free/busy
; 5969 :   // for that header; so, zero them out here..
; 5970 :   for ( uiI = 0; uiI < MAXIMUM_BUFFERS_QUEUED; uiI++ )
; 5971 :       pPlayAudio->ppWaveHdr[uiI]->lpData = NULL;

  01f1e	8b 97 94 00 00
	00		 mov	 edx, DWORD PTR [edi+148]
  01f24	83 c0 04	 add	 eax, 4
  01f27	83 f8 20	 cmp	 eax, 32			; 00000020H
  01f2a	8b 54 10 fc	 mov	 edx, DWORD PTR [eax+edx-4]
  01f2e	89 0a		 mov	 DWORD PTR [edx], ecx
  01f30	7c ec		 jl	 SHORT $L71693

; 5972 : 
; 5973 :   OP_SetEvent( pPlayAudio->hevQueueNotFull );

  01f32	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  01f35	50		 push	 eax
  01f36	e8 00 00 00 00	 call	 _OP_SetEvent

; 5974 :   OP_UnlockMutex( pPlayAudio->hmxQueueCount ); // tek 05nov97 unlock..

  01f3b	8b 4f 7c	 mov	 ecx, DWORD PTR [edi+124]
  01f3e	51		 push	 ecx
  01f3f	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01f44	83 c4 08	 add	 esp, 8
  01f47	5f		 pop	 edi
  01f48	5e		 pop	 esi

; 5975 : #ifdef AUD_DEBUG
; 5976 :   {
; 5977 : 		  char  szTemp[256]="";
; 5978 : 		  sprintf(szTemp,"ResetAudioQueue: exit at %08lu\n",
; 5979 : 			  timeGetTime()
; 5980 : 			  );
; 5981 : 		  OutputDebugString(szTemp);
; 5982 :   }
; 5983 : #endif //AUD_DEBUG
; 5984 :   return;
; 5985 : }

  01f49	c3		 ret	 0
_ResetAudioQueue ENDP
_pPlayAudio$ = 8
_ProcessPauseMessage PROC NEAR

; 6012 : {

  01f50	56		 push	 esi

; 6013 :   MMRESULT mmStatus;
; 6014 : 
; 6015 :   /********************************************************************/
; 6016 :   /*  If the wave output device is active then pause it. If it is not */
; 6017 :   /*  active then set the pause flag.                                 */
; 6018 :   /********************************************************************/
; 6019 : 
; 6020 :   if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )

  01f51	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  01f55	57		 push	 edi
  01f56	83 7e 34 02	 cmp	 DWORD PTR [esi+52], 2
  01f5a	75 3e		 jne	 SHORT $L71701

; 6021 :   {
; 6022 :     LOCK_MME_CALL( mmStatus = waveOutPause( pPlayAudio->hWaveOut ))

  01f5c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01f5f	50		 push	 eax
  01f60	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutPause@4
  01f66	8b f8		 mov	 edi, eax

; 6027 :   }
; 6028 : 
; 6029 :   /********************************************************************/
; 6030 :   /*  If the restart was successful then set the pause flag.          */
; 6031 :   /********************************************************************/
; 6032 : 
; 6033 :   if ( mmStatus == MMSYSERR_NOERROR )

  01f68	85 ff		 test	 edi, edi
  01f6a	75 29		 jne	 SHORT $L72138
$L72137:

; 6034 :   {
; 6035 :     OP_LockMutex( pPlayAudio->hmxPauseFlag );

  01f6c	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  01f72	51		 push	 ecx
  01f73	e8 00 00 00 00	 call	 _OP_LockMutex

; 6036 :     pPlayAudio->bPaused = TRUE;
; 6037 : 	// Clear the reset pause, we're really paused now.
; 6038 : 	pPlayAudio->bResetPaused = FALSE;
; 6039 :     OP_UnlockMutex( pPlayAudio->hmxPauseFlag );

  01f78	8b 96 88 00 00
	00		 mov	 edx, DWORD PTR [esi+136]
  01f7e	c7 46 58 01 00
	00 00		 mov	 DWORD PTR [esi+88], 1
  01f85	52		 push	 edx
  01f86	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0
  01f8d	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01f92	83 c4 08	 add	 esp, 8
$L72138:

; 6040 :   }
; 6041 : 
; 6042 :   return mmStatus;

  01f95	8b c7		 mov	 eax, edi
  01f97	5f		 pop	 edi
  01f98	5e		 pop	 esi

; 6043 : }

  01f99	c3		 ret	 0
$L71701:

; 6023 :   }
; 6024 :   else
; 6025 :   {
; 6026 :     mmStatus = MMSYSERR_NOERROR;

  01f9a	33 ff		 xor	 edi, edi

; 6027 :   }
; 6028 : 
; 6029 :   /********************************************************************/
; 6030 :   /*  If the restart was successful then set the pause flag.          */
; 6031 :   /********************************************************************/
; 6032 : 
; 6033 :   if ( mmStatus == MMSYSERR_NOERROR )

  01f9c	eb ce		 jmp	 SHORT $L72137
_ProcessPauseMessage ENDP
_pPlayAudio$ = 8
_ProcessResumeMessage PROC NEAR

; 6070 : {

  01fa0	56		 push	 esi

; 6071 :   MMRESULT mmStatus;
; 6072 : 
; 6073 :   /********************************************************************/
; 6074 :   /*  If the wave output device was paused then restart it.           */
; 6075 :   /********************************************************************/
; 6076 : 
; 6077 :   if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )

  01fa1	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  01fa5	57		 push	 edi
  01fa6	83 7e 34 02	 cmp	 DWORD PTR [esi+52], 2
  01faa	75 40		 jne	 SHORT $L71708

; 6078 :   {
; 6079 :     LOCK_MME_CALL( mmStatus = waveOutRestart( pPlayAudio->hWaveOut ))

  01fac	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01faf	50		 push	 eax
  01fb0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutRestart@4
  01fb6	8b f8		 mov	 edi, eax

; 6084 :   }
; 6085 : 
; 6086 :   /********************************************************************/
; 6087 :   /*  If the restart was successful then reset the pause flag.        */
; 6088 :   /********************************************************************/
; 6089 : 
; 6090 :   if ( mmStatus == MMSYSERR_NOERROR )

  01fb8	85 ff		 test	 edi, edi
  01fba	75 2b		 jne	 SHORT $L72141
$L72140:

; 6091 :   {
; 6092 :     OP_LockMutex( pPlayAudio->hmxPauseFlag );

  01fbc	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  01fc2	51		 push	 ecx
  01fc3	e8 00 00 00 00	 call	 _OP_LockMutex

; 6093 :     pPlayAudio->bPaused = FALSE;
; 6094 :     OP_SetEvent( pPlayAudio->hevTimerThreadActive );

  01fc8	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  01fcb	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  01fd2	52		 push	 edx
  01fd3	e8 00 00 00 00	 call	 _OP_SetEvent

; 6095 :     OP_UnlockMutex( pPlayAudio->hmxPauseFlag );

  01fd8	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  01fde	50		 push	 eax
  01fdf	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01fe4	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72141:

; 6096 :   }
; 6097 : 
; 6098 :   return mmStatus;

  01fe7	8b c7		 mov	 eax, edi
  01fe9	5f		 pop	 edi
  01fea	5e		 pop	 esi

; 6099 : }

  01feb	c3		 ret	 0
$L71708:

; 6080 :   }
; 6081 :   else
; 6082 :   {
; 6083 :     mmStatus = MMSYSERR_NOERROR;

  01fec	33 ff		 xor	 edi, edi

; 6084 :   }
; 6085 : 
; 6086 :   /********************************************************************/
; 6087 :   /*  If the restart was successful then reset the pause flag.        */
; 6088 :   /********************************************************************/
; 6089 : 
; 6090 :   if ( mmStatus == MMSYSERR_NOERROR )

  01fee	eb cc		 jmp	 SHORT $L72140
_ProcessResumeMessage ENDP
_pPlayAudio$ = 8
_pWaveFormat$ = 12
_dwSampleRate$ = -4
_ProcessSetFormatMessage PROC NEAR

; 6134 : {

  01ff0	51		 push	 ecx
  01ff1	53		 push	 ebx
  01ff2	55		 push	 ebp
  01ff3	56		 push	 esi

; 6135 :   DWORD dwSampleRate=0;
; 6136 :   DWORD dwNumberOfChannels=0;
; 6137 :   DWORD dwBytesPerSample=0;
; 6138 :   DWORD dwQueryFlags=0;
; 6139 :   MMRESULT mmStatus;
; 6140 : 
; 6141 :   /********************************************************************/
; 6142 :   /*  The wBitsPerSample element, the nChannels element, and the      */
; 6143 :   /*  nSamplesPerSec element of the WAVEFORMATEX structure are        */
; 6144 :   /*  used to calculate the values of the other elements of the       */
; 6145 :   /*  WAVEFORMATEX structure.                                         */
; 6146 :   /*                                                                  */
; 6147 :   /*  If the wFormatTag element of the WAVEFORMATEX structure         */
; 6148 :   /*  is NOT equal to WAVE_FORMAT_PCM then all of the fields of       */
; 6149 :   /*  the WAVEFORMATEX structure must be filled in and are used       */
; 6150 :   /*  in the call to the waveOutOpen() function.                      */
; 6151 :   /********************************************************************/
; 6152 : 
; 6153 :   if ( pWaveFormat->wFormatTag == WAVE_FORMAT_PCM )

  01ff4	8b 74 24 18	 mov	 esi, DWORD PTR _pWaveFormat$[esp+12]
  01ff8	57		 push	 edi
  01ff9	33 db		 xor	 ebx, ebx
  01ffb	66 8b 0e	 mov	 cx, WORD PTR [esi]
  01ffe	33 ff		 xor	 edi, edi
  02000	66 83 f9 01	 cmp	 cx, 1
  02004	89 5c 24 10	 mov	 DWORD PTR _dwSampleRate$[esp+20], ebx
  02008	75 2a		 jne	 SHORT $L71721

; 6154 :   {
; 6155 :     /******************************************************************/
; 6156 :     /*  The wFormatTag element is equal to WAVE_FORMAT_PCM.           */
; 6157 :     /******************************************************************/
; 6158 : 
; 6159 :     dwSampleRate = pWaveFormat->nSamplesPerSec;
; 6160 :     dwNumberOfChannels = pWaveFormat->nChannels;

  0200a	66 8b 7e 02	 mov	 di, WORD PTR [esi+2]

; 6161 :     dwBytesPerSample = pWaveFormat->wBitsPerSample >> 3;

  0200e	33 c0		 xor	 eax, eax
  02010	66 8b 46 0e	 mov	 ax, WORD PTR [esi+14]
  02014	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  02017	c1 e8 03	 shr	 eax, 3

; 6162 : 
; 6163 :     /******************************************************************/
; 6164 :     /*  Initialize other WAVEFORMATEX structure elements.             */
; 6165 :     /******************************************************************/
; 6166 : 
; 6167 :     pWaveFormat->nAvgBytesPerSec =
; 6168 :       dwSampleRate * dwNumberOfChannels * dwBytesPerSample;

  0201a	8b e8		 mov	 ebp, eax
  0201c	89 54 24 10	 mov	 DWORD PTR _dwSampleRate$[esp+20], edx
  02020	0f af ef	 imul	 ebp, edi
  02023	0f af ea	 imul	 ebp, edx

; 6169 :     pWaveFormat->nBlockAlign =
; 6170 :       (WORD)( dwNumberOfChannels * dwBytesPerSample );

  02026	0f af c7	 imul	 eax, edi
  02029	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  0202c	66 89 46 0c	 mov	 WORD PTR [esi+12], ax

; 6171 :     pWaveFormat->cbSize = 0;

  02030	66 89 5e 10	 mov	 WORD PTR [esi+16], bx
$L71721:

; 6172 :   }
; 6173 : 
; 6174 :   /********************************************************************/
; 6175 :   /*  If PA_OWN_DEVICE is specified AND the requested Sample Rate and */
; 6176 :   /*  the requested Number Of Channels do NOT match the current       */
; 6177 :   /*  settings then an error is returned.                             */
; 6178 :   /********************************************************************/
; 6179 : 
; 6180 :   if ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )

  02034	8b 6c 24 18	 mov	 ebp, DWORD PTR _pPlayAudio$[esp+16]
  02038	f6 45 3c 01	 test	 BYTE PTR [ebp+60], 1
  0203c	74 61		 je	 SHORT $L71723

; 6181 :   {
; 6182 :     /******************************************************************/
; 6183 :     /*  The audio device is owned. This means that the wave output    */
; 6184 :     /*  device will not be closed unless the PA_DestroyPlayHandle()   */
; 6185 :     /*  function is called. In this case, the requested format must   */
; 6186 :     /*  match the actual data format currently being used.            */
; 6187 :     /*  One exception is that if the wFormatTag is equal to           */
; 6188 :     /*  WAVE_FORMAT_PCM then the several other fields will            */
; 6189 :     /*  automatically match (Except the wBitsPerSample field that     */
; 6190 :     /*  does not necessarily to match in this case).                  */
; 6191 :     /******************************************************************/
; 6192 : 
; 6193 :     if (( pWaveFormat->wFormatTag != pPlayAudio->pWaveFormat->wFormatTag )
; 6194 :       || ( pWaveFormat->nSamplesPerSec
; 6195 :                 != pPlayAudio->pWaveFormat->nSamplesPerSec )
; 6196 :       || ( pWaveFormat->nChannels != pPlayAudio->pWaveFormat->nChannels ))

  0203e	8b ad a0 00 00
	00		 mov	 ebp, DWORD PTR [ebp+160]
  02044	66 3b 4d 00	 cmp	 cx, WORD PTR [ebp]
  02048	75 4a		 jne	 SHORT $L71725
  0204a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0204d	8b 55 04	 mov	 edx, DWORD PTR [ebp+4]
  02050	3b c2		 cmp	 eax, edx
  02052	75 40		 jne	 SHORT $L71725
  02054	66 8b 56 02	 mov	 dx, WORD PTR [esi+2]
  02058	66 3b 55 02	 cmp	 dx, WORD PTR [ebp+2]
  0205c	75 36		 jne	 SHORT $L71725

; 6197 :       return MMSYSERR_ERROR;
; 6198 : 
; 6199 :     if ( pWaveFormat->wFormatTag != WAVE_FORMAT_PCM )

  0205e	66 83 f9 01	 cmp	 cx, 1
  02062	0f 84 b5 00 00
	00		 je	 $L71740

; 6200 :     {
; 6201 :       if (( pWaveFormat->nAvgBytesPerSec
; 6202 :                   != pPlayAudio->pWaveFormat->nAvgBytesPerSec )
; 6203 :         || ( pWaveFormat->nBlockAlign
; 6204 :                   != pPlayAudio->pWaveFormat->nBlockAlign )
; 6205 :         || ( pWaveFormat->wBitsPerSample
; 6206 :                   != pPlayAudio->pWaveFormat->wBitsPerSample )
; 6207 :         || ( pWaveFormat->cbSize != pPlayAudio->pWaveFormat->cbSize ))

  02068	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0206b	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  0206e	3b c1		 cmp	 eax, ecx
  02070	75 22		 jne	 SHORT $L71725
  02072	66 8b 4e 0c	 mov	 cx, WORD PTR [esi+12]
  02076	66 3b 4d 0c	 cmp	 cx, WORD PTR [ebp+12]
  0207a	75 18		 jne	 SHORT $L71725
  0207c	66 8b 56 0e	 mov	 dx, WORD PTR [esi+14]
  02080	66 3b 55 0e	 cmp	 dx, WORD PTR [ebp+14]
  02084	75 0e		 jne	 SHORT $L71725
  02086	66 8b 46 10	 mov	 ax, WORD PTR [esi+16]
  0208a	66 3b 45 10	 cmp	 ax, WORD PTR [ebp+16]
  0208e	0f 84 89 00 00
	00		 je	 $L71740
$L71725:
  02094	5f		 pop	 edi
  02095	5e		 pop	 esi
  02096	5d		 pop	 ebp

; 6208 :       return MMSYSERR_ERROR;

  02097	b8 01 00 00 00	 mov	 eax, 1
  0209c	5b		 pop	 ebx

; 6402 : }

  0209d	59		 pop	 ecx
  0209e	c3		 ret	 0
$L71723:

; 6209 :     }
; 6210 :   }
; 6211 :   else
; 6212 :   {
; 6213 :     /******************************************************************/
; 6214 :     /*  If the audio device is not inactive then return an error.     */
; 6215 :     /******************************************************************/
; 6216 : 
; 6217 :     if ( pPlayAudio->dwAudioDeviceState != AUDIO_DEVICE_INACTIVE )

  0209f	39 5d 34	 cmp	 DWORD PTR [ebp+52], ebx
  020a2	74 0b		 je	 SHORT $L71730
  020a4	5f		 pop	 edi
  020a5	5e		 pop	 esi
  020a6	5d		 pop	 ebp

; 6218 :     {
; 6219 :       return MMSYSERR_ALLOCATED;

  020a7	b8 04 00 00 00	 mov	 eax, 4
  020ac	5b		 pop	 ebx

; 6402 : }

  020ad	59		 pop	 ecx
  020ae	c3		 ret	 0
$L71730:

; 6220 :     }
; 6221 :     else
; 6222 :     {
; 6223 :       /****************************************************************/
; 6224 :       /*  If the WAVEFORMATEX data structure has a wFormatTag         */
; 6225 :       /*  element equal to WAVE_FORMAT_PCM then the device is tested  */
; 6226 :       /*  for either 16 or 8 bit output. Whether 8 or 16 bits will    */
; 6227 :       /*  succeed depends on the audio data size and the audio        */
; 6228 :       /*  driver. If the audio samples are 16 bits and only 8 bit     */
; 6229 :       /*  output is supported by the audio driver then the 16 bit     */
; 6230 :       /*  audio samples are converted to 8 bit audio samples in the   */
; 6231 :       /*  WriteBufferToWaveDevice() function. This conversion is      */
; 6232 :       /*  indicated by the bConvertToEightBit flag.                   */
; 6233 :       /*                                                              */
; 6234 :       /*  If the wFormatTag element of the WAVEFORMATEX structure     */
; 6235 :       /*  is NOT equal to WAVE_FORMAT_PCM then all of the fields of   */
; 6236 :       /*  the WAVEFORMATEX structure must be filled in and are used   */
; 6237 :       /*  in the call to the waveOutOpen() function.                  */
; 6238 :       /****************************************************************/
; 6239 : 
; 6240 :       /****************************************************************/
; 6241 :       /*  Set the wave out device query flags.                        */
; 6242 :       /****************************************************************/
; 6243 : 
; 6244 :       dwQueryFlags = WAVE_FORMAT_QUERY;
; 6245 :   
; 6246 : #ifdef USE_MME_SERVER
; 6247 : 
; 6248 :       /****************************************************************/
; 6249 :       /*  If the WAVE_OPEN_SHARE bit is set in the device options     */
; 6250 :       /*  then enable device sharing.                                 */
; 6251 :       /****************************************************************/
; 6252 : 
; 6253 :       if ( pPlayAudio->dwDeviceOptions & WAVE_OPEN_SHAREABLE )
; 6254 :       {
; 6255 :         dwQueryFlags |= WAVE_OPEN_SHAREABLE;
; 6256 :       }
; 6257 : 
; 6258 : #endif
; 6259 : 
; 6260 : 	
; 6261 :       /****************************************************************/
; 6262 :       /*  Query the wave output device.                               */
; 6263 :       /****************************************************************/
; 6264 : 
; 6265 : #ifdef USE_MME_SERVER
; 6266 : 
; 6267 :       LOCK_MME_CALL(
; 6268 :         mmStatus = waveOutOpen( NULL,
; 6269 :                                 pPlayAudio->uiSelectedDeviceID,
; 6270 :                                 (LPWAVEFORMAT)pWaveFormat,
; 6271 :                                 0,
; 6272 :                                 0,
; 6273 :                                 dwQueryFlags ))
; 6274 : #else
; 6275 :       LOCK_MME_CALL(
; 6276 :         mmStatus = waveOutOpen( NULL,
; 6277 :                                 pPlayAudio->uiSelectedDeviceID,
; 6278 :                                 (LPWAVEFORMATEX)pWaveFormat,
; 6279 :                                 0,
; 6280 :                                 0,
; 6281 :                                 dwQueryFlags ))

  020af	8b 4d 20	 mov	 ecx, DWORD PTR [ebp+32]
  020b2	6a 01		 push	 1
  020b4	53		 push	 ebx
  020b5	53		 push	 ebx
  020b6	56		 push	 esi
  020b7	51		 push	 ecx
  020b8	53		 push	 ebx
  020b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutOpen@24

; 6282 : #endif
; 6283 : 
; 6284 : #ifdef USE_MME_SERVER
; 6285 : 
; 6286 :       /****************************************************************/
; 6287 :       /*  THIS IS PROBABLY NOT NECESSARY, BUT IT CANNOT HURT.         */
; 6288 :       /*  The MME servers waveOutOpen() function returns a value of   */
; 6289 :       /*  WAVERR_DEVICESHAREABLE if the device is shareable. Change   */
; 6290 :       /*  this to MMSYSERR_NOERROR.                                   */
; 6291 :       /****************************************************************/
; 6292 : 
; 6293 :       if (( pPlayAudio->dwDeviceOptions & WAVE_OPEN_SHAREABLE )
; 6294 :         && ( mmStatus == WAVERR_DEVICESHAREABLE ))
; 6295 :       {
; 6296 :         mmStatus = MMSYSERR_NOERROR;
; 6297 :       }
; 6298 : 
; 6299 : #endif
; 6300 : 
; 6301 :       /****************************************************************/
; 6302 :       /*  If the requested wave output format is WAVE_FORMAT_PCM and  */
; 6303 :       /*  the number of bits per sample is 16 and the format is not   */
; 6304 :       /*  supported then try to query the wave output device for 8    */
; 6305 :       /*  bit samples.                                                */
; 6306 :       /****************************************************************/
; 6307 : 
; 6308 : /* TQL 05/21/1997  change this for OSF build */
; 6309 :       if(
; 6310 : #if defined WIN32
; 6311 : 	 ( mmStatus == WAVERR_BADFORMAT )
; 6312 : #endif
; 6313 : #if defined __osf__ || defined __linux__  
; 6314 : 	 ( mmStatus == MMSYSERR_NOTSUPPORTED )
; 6315 : #endif
; 6316 : 	 && ( pWaveFormat->wFormatTag == WAVE_FORMAT_PCM )
; 6317 : 	 && ( pWaveFormat->wBitsPerSample == 16 ))

  020bf	83 f8 20	 cmp	 eax, 32			; 00000020H
  020c2	75 47		 jne	 SHORT $L71734
  020c4	66 83 3e 01	 cmp	 WORD PTR [esi], 1
  020c8	75 55		 jne	 SHORT $L71715
  020ca	66 83 7e 0e 10	 cmp	 WORD PTR [esi+14], 16	; 00000010H
  020cf	75 4e		 jne	 SHORT $L71715

; 6318 : 	{
; 6319 : 	  /**************************************************************/
; 6320 : 	  /*  Initialize other WAVEFORMATEX structure elements for 8    */
; 6321 : 	  /*  bit data.                                                 */
; 6322 : 	  /**************************************************************/
; 6323 : 	  
; 6324 : 	  pWaveFormat->nAvgBytesPerSec = dwSampleRate * dwNumberOfChannels;

  020d1	8b df		 mov	 ebx, edi

; 6325 : 	  pWaveFormat->nBlockAlign = (WORD)dwNumberOfChannels;
; 6326 : 	  pWaveFormat->wBitsPerSample = 8;
; 6327 : 	  
; 6328 : 	  /**************************************************************/
; 6329 : 	  /*  Query the wave output device.                             */
; 6330 : 	  /**************************************************************/
; 6331 : 	  
; 6332 : #ifdef USE_MME_SERVER
; 6333 : 	  
; 6334 : 	  LOCK_MME_CALL(
; 6335 : 			mmStatus = waveOutOpen( NULL,
; 6336 : 						pPlayAudio->uiSelectedDeviceID,
; 6337 : 						(LPWAVEFORMAT)pWaveFormat,
; 6338 : 						0,
; 6339 : 						0,
; 6340 : 						dwQueryFlags ))
; 6341 : #else
; 6342 : 	    LOCK_MME_CALL(
; 6343 : 			  mmStatus = waveOutOpen( NULL,
; 6344 : 						  pPlayAudio->uiSelectedDeviceID,
; 6345 : 						  (LPWAVEFORMATEX)pWaveFormat,
; 6346 : 						  0,
; 6347 : 						  0,
; 6348 : 						  dwQueryFlags ))

  020d3	6a 01		 push	 1
  020d5	0f af 5c 24 14	 imul	 ebx, DWORD PTR _dwSampleRate$[esp+24]
  020da	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  020dd	66 89 7e 0c	 mov	 WORD PTR [esi+12], di
  020e1	66 c7 46 0e 08
	00		 mov	 WORD PTR [esi+14], 8
  020e7	8b 55 20	 mov	 edx, DWORD PTR [ebp+32]
  020ea	6a 00		 push	 0
  020ec	6a 00		 push	 0
  020ee	56		 push	 esi
  020ef	52		 push	 edx
  020f0	6a 00		 push	 0
  020f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutOpen@24

; 6349 : #endif
; 6350 : 	    
; 6351 : #ifdef USE_MME_SERVER
; 6352 : 	    
; 6353 : 	    /**************************************************************/
; 6354 : 	    /*  THIS IS PROBABLY NOT NECESSARY, BUT IT CANNOT HURT.       */
; 6355 : 	    /*  The MME servers waveOutOpen() function returns a value of */
; 6356 : 	    /*  WAVERR_DEVICESHAREABLE if the device is shareable. Change */
; 6357 : 	    /*  this to MMSYSERR_NOERROR.                                 */
; 6358 : 	    /**************************************************************/
; 6359 : 	    
; 6360 : 	    if (( pPlayAudio->dwDeviceOptions & WAVE_OPEN_SHAREABLE )
; 6361 : 		&& ( mmStatus == WAVERR_DEVICESHAREABLE ))
; 6362 : 	      {
; 6363 : 		mmStatus = MMSYSERR_NOERROR;
; 6364 : 	      }
; 6365 : 	  
; 6366 : #endif
; 6367 : 	  
; 6368 : 	  /**************************************************************/
; 6369 : 	  /*  Reset the WAVEFORMATEX structure elements for 16 bit      */
; 6370 : 	  /*  data.                                                     */
; 6371 : 	  /**************************************************************/
; 6372 : 	  
; 6373 : 	  pWaveFormat->nAvgBytesPerSec =
; 6374 : 	    dwSampleRate * dwNumberOfChannels << 1;

  020f8	8d 0c 1b	 lea	 ecx, DWORD PTR [ebx+ebx]

; 6375 : 	  pWaveFormat->nBlockAlign = (WORD)( dwNumberOfChannels << 1 );

  020fb	8d 14 3f	 lea	 edx, DWORD PTR [edi+edi]
  020fe	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  02101	66 89 56 0c	 mov	 WORD PTR [esi+12], dx

; 6376 : 	  pWaveFormat->wBitsPerSample = 16;

  02105	66 c7 46 0e 10
	00		 mov	 WORD PTR [esi+14], 16	; 00000010H
$L71734:

; 6377 : 	}
; 6378 :       
; 6379 :       /****************************************************************/
; 6380 :       /*  Test for a "query failure" error.                           */
; 6381 :       /****************************************************************/
; 6382 :       
; 6383 :       if ( mmStatus )

  0210b	85 c0		 test	 eax, eax

; 6384 : 	{
; 6385 : 	  return mmStatus;

  0210d	75 10		 jne	 SHORT $L71715

; 6386 : 	}
; 6387 :       
; 6388 :       /****************************************************************/
; 6389 :       /*  Set the new device format.                                  */
; 6390 :       /****************************************************************/
; 6391 :       
; 6392 :       mmStatus = SetNewFormat( pPlayAudio, pWaveFormat );

  0210f	56		 push	 esi
  02110	55		 push	 ebp
  02111	e8 00 00 00 00	 call	 _SetNewFormat
  02116	83 c4 08	 add	 esp, 8

; 6393 :       
; 6394 :       if ( mmStatus )

  02119	85 c0		 test	 eax, eax

; 6395 : 	{
; 6396 : 	  return mmStatus;

  0211b	75 02		 jne	 SHORT $L71715
$L71740:

; 6397 : 	}
; 6398 :     }
; 6399 :   }
; 6400 :   
; 6401 :   return MMSYSERR_NOERROR;

  0211d	33 c0		 xor	 eax, eax
$L71715:
  0211f	5f		 pop	 edi
  02120	5e		 pop	 esi
  02121	5d		 pop	 ebp
  02122	5b		 pop	 ebx

; 6402 : }

  02123	59		 pop	 ecx
  02124	c3		 ret	 0
_ProcessSetFormatMessage ENDP
_TEXT	ENDS
PUBLIC	__real@8@3ff8ccccccccccccd000
PUBLIC	__real@8@3ffb851eb851eb852000
;	COMDAT __real@8@3ff8ccccccccccccd000
; File D:\work\product\dapi\src\NT\playaud.c
CONST	SEGMENT
__real@8@3ff8ccccccccccccd000 DQ 03f8999999999999ar ; 0.0125
CONST	ENDS
;	COMDAT __real@8@3ffb851eb851eb852000
CONST	SEGMENT
__real@8@3ffb851eb851eb852000 DQ 03fb0a3d70a3d70a4r ; 0.065
CONST	ENDS
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pWaveFormat$ = 12
_uiWriteLength$ = 12
_pWaveFormatNew$ = 12
_SetNewFormat PROC NEAR

; 6442 : {

  02130	83 ec 08	 sub	 esp, 8
  02133	53		 push	 ebx

; 6443 :   unsigned int uiBlockAlign;
; 6444 :   unsigned int uiWriteLength;
; 6445 :   DWORD dwWaveFormatSize;
; 6446 :   LPWAVEFORMATEX pWaveFormatNew;
; 6447 :   LPWAVEFORMATEX pWaveFormatOld;
; 6448 : 
; 6449 :   /******************************************************************/
; 6450 :   /*  Get the size of the WAVEFORMATEX structure including the      */
; 6451 :   /*  possible data space indicated by the cbSize element.          */
; 6452 :   /******************************************************************/
; 6453 : 
; 6454 :   dwWaveFormatSize = GetWaveFormatSize( pWaveFormat );

  02134	8b 5c 24 14	 mov	 ebx, DWORD PTR _pWaveFormat$[esp+8]
  02138	56		 push	 esi
  02139	53		 push	 ebx
  0213a	e8 00 00 00 00	 call	 _GetWaveFormatSize
  0213f	83 c4 04	 add	 esp, 4

; 6455 : 
; 6456 :   // MGS change this back for osf so that we don't divide by 0 !
; 6457 : /* TQL 05/21/1997  change this for OSF build */
; 6458 :   //#ifdef WIN32
; 6459 :   if (pWaveFormat->wFormatTag == WAVE_FORMAT_PCM)

  02142	66 83 3b 01	 cmp	 WORD PTR [ebx], 1
  02146	8b f0		 mov	 esi, eax
  02148	75 25		 jne	 SHORT $L71751

; 6460 :   {
; 6461 :     /******************************************************************/
; 6462 :     /*  Initialize other WAVEFORMATEX structure elements.             */
; 6463 :     /******************************************************************/
; 6464 : 
; 6465 :     pWaveFormat->nBlockAlign = pWaveFormat->nChannels * (pWaveFormat->wBitsPerSample >> 3);

  0214a	66 8b 43 0e	 mov	 ax, WORD PTR [ebx+14]

; 6466 :     pWaveFormat->nAvgBytesPerSec = pWaveFormat->nSamplesPerSec * pWaveFormat->nBlockAlign;

  0214e	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  02151	66 c1 e8 03	 shr	 ax, 3
  02155	66 0f af 43 02	 imul	 ax, WORD PTR [ebx+2]
  0215a	66 89 43 0c	 mov	 WORD PTR [ebx+12], ax
  0215e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  02163	0f af c8	 imul	 ecx, eax
  02166	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx

; 6467 :     pWaveFormat->cbSize = 0;

  02169	66 c7 43 10 00
	00		 mov	 WORD PTR [ebx+16], 0
$L71751:

; 6468 :   }
; 6469 :   ///#endif
; 6470 : 
; 6471 :   /******************************************************************/
; 6472 :   /*  Allocate space for the new WAVEFORMATEX structure.            */
; 6473 :   /******************************************************************/
; 6474 : 
; 6475 :   LOCK_MME_CALL(
; 6476 :     pWaveFormatNew = ALLOCATE_SERVER_MEM( dwWaveFormatSize ))

  0216f	56		 push	 esi
  02170	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  02176	83 c4 04	 add	 esp, 4
  02179	89 44 24 18	 mov	 DWORD PTR _pWaveFormatNew$[esp+12], eax

; 6477 : 
; 6478 :   if ( pWaveFormatNew == NULL )

  0217d	85 c0		 test	 eax, eax
  0217f	75 0b		 jne	 SHORT $L71753
  02181	5e		 pop	 esi

; 6479 :   {
; 6480 :     return MMSYSERR_NOMEM;

  02182	b8 07 00 00 00	 mov	 eax, 7
  02187	5b		 pop	 ebx

; 6594 : }

  02188	83 c4 08	 add	 esp, 8
  0218b	c3		 ret	 0
$L71753:

; 6481 :   }
; 6482 : 
; 6483 :   /******************************************************************/
; 6484 :   /*  copy the WAVEFORMATEX structure.                              */
; 6485 :   /******************************************************************/
; 6486 : 
; 6487 :   memcpy( pWaveFormatNew,
; 6488 :           pWaveFormat,
; 6489 :           dwWaveFormatSize );

  0218c	8b ce		 mov	 ecx, esi
  0218e	55		 push	 ebp
  0218f	8b d1		 mov	 edx, ecx
  02191	57		 push	 edi
  02192	8b f3		 mov	 esi, ebx
  02194	8b f8		 mov	 edi, eax
  02196	c1 e9 02	 shr	 ecx, 2
  02199	f3 a5		 rep movsd

; 6490 : 
; 6491 :   /******************************************************************/
; 6492 :   /*  Save the old wave format structure so it can be freed.        */
; 6493 :   /******************************************************************/
; 6494 : 
; 6495 :   pWaveFormatOld = pPlayAudio->pWaveFormat;

  0219b	8b 6c 24 1c	 mov	 ebp, DWORD PTR _pPlayAudio$[esp+20]
  0219f	8b ca		 mov	 ecx, edx
  021a1	83 e1 03	 and	 ecx, 3
  021a4	f3 a4		 rep movsb

; 6496 : 
; 6497 :   /******************************************************************/
; 6498 :   /*  It is important that the assignment statement on the          */
; 6499 :   /*  following line executes automically so the timer thread does  */
; 6500 :   /*  not create an error.                                          */
; 6501 :   /******************************************************************/
; 6502 : 
; 6503 :   OP_LockMutex( pPlayAudio->hmxWaveFormat );

  021a6	8b 85 90 00 00
	00		 mov	 eax, DWORD PTR [ebp+144]
  021ac	8b b5 a0 00 00
	00		 mov	 esi, DWORD PTR [ebp+160]
  021b2	50		 push	 eax
  021b3	e8 00 00 00 00	 call	 _OP_LockMutex

; 6504 :   pPlayAudio->pWaveFormat = pWaveFormatNew;
; 6505 :   OP_UnlockMutex( pPlayAudio->hmxWaveFormat );

  021b8	8b 8d 90 00 00
	00		 mov	 ecx, DWORD PTR [ebp+144]
  021be	8b 7c 24 24	 mov	 edi, DWORD PTR _pWaveFormatNew$[esp+24]
  021c2	51		 push	 ecx
  021c3	89 bd a0 00 00
	00		 mov	 DWORD PTR [ebp+160], edi
  021c9	e8 00 00 00 00	 call	 _OP_UnlockMutex
  021ce	83 c4 08	 add	 esp, 8

; 6506 : 
; 6507 :   if ( pWaveFormatOld != NULL )

  021d1	85 f6		 test	 esi, esi
  021d3	74 0a		 je	 SHORT $L71755

; 6508 :   {
; 6509 :     LOCK_MME_CALL( FREE_SERVER_MEM( pWaveFormatOld ))

  021d5	56		 push	 esi
  021d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  021dc	83 c4 04	 add	 esp, 4
$L71755:

; 6510 :   }
; 6511 : 
; 6512 :   /********************************************************************/
; 6513 :   /*  Only write blocks that are a multiple of the block alignment.   */
; 6514 :   /********************************************************************/
; 6515 : 
; 6516 :   uiBlockAlign = pWaveFormatNew->nBlockAlign;

  021df	33 f6		 xor	 esi, esi
  021e1	66 8b 77 0c	 mov	 si, WORD PTR [edi+12]

; 6517 : 
; 6518 :   if ( uiBlockAlign == 0 )

  021e5	85 f6		 test	 esi, esi
  021e7	75 05		 jne	 SHORT $L71756

; 6519 :   {
; 6520 :     uiBlockAlign = 1;

  021e9	be 01 00 00 00	 mov	 esi, 1
$L71756:

; 6521 :   }
; 6522 : 
; 6523 :   /********************************************************************/
; 6524 :   /*  Calculate the maximum write length written by the               */
; 6525 :   /*  WriteBufferToWaveDevice() function.                             */
; 6526 :   /********************************************************************/
; 6527 : 
; 6528 :   uiWriteLength = MAXIMUM_WRITE_LENGTH;
; 6529 :   uiWriteLength = uiWriteLength / uiBlockAlign;

  021ee	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H
  021f3	33 d2		 xor	 edx, edx
  021f5	f7 f6		 div	 esi

; 6530 :   pPlayAudio->uiMaximumWriteLength = uiWriteLength * uiBlockAlign;
; 6531 : 
; 6532 :   /********************************************************************/
; 6533 :   /*  Calculate the maximum startup length written to the             */
; 6534 :   /*  WriteBufferToWaveDevice() function.                             */
; 6535 :   /********************************************************************/
; 6536 : 
; 6537 :   uiWriteLength = (unsigned int)
; 6538 :     ( (STARTUP_BUFFER_SECONDS/MAXIMUM_BUFFERS_QUEUED) * (double)pWaveFormat->nAvgBytesPerSec );

  021f7	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR -8+[esp+28], 0
  021ff	8b f8		 mov	 edi, eax
  02201	0f af fe	 imul	 edi, esi
  02204	89 7d 24	 mov	 DWORD PTR [ebp+36], edi
  02207	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  0220a	89 54 24 10	 mov	 DWORD PTR -8+[esp+24], edx
  0220e	df 6c 24 10	 fild	 QWORD PTR -8+[esp+24]
  02212	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@8@3ff8ccccccccccccd000
  02218	e8 00 00 00 00	 call	 __ftol

; 6539 : 
; 6540 :   if ( uiWriteLength < MINIMUM_STARTUP_WRITE_SIZE )

  0221d	3d 40 06 00 00	 cmp	 eax, 1600		; 00000640H
  02222	73 05		 jae	 SHORT $L71759

; 6541 :   {
; 6542 :     uiWriteLength = MINIMUM_STARTUP_WRITE_SIZE;

  02224	b8 40 06 00 00	 mov	 eax, 1600		; 00000640H
$L71759:

; 6543 :   }
; 6544 : 
; 6545 : #ifdef UNDER_CE
; 6546 :   // tek 23mar99 stretch the startup packet to try to avoid stutter.
; 6547 :   uiWriteLength = uiWriteLength*2;
; 6548 : #endif //UNDER_CE
; 6549 : 
; 6550 :   uiWriteLength = uiWriteLength / uiBlockAlign;

  02229	33 d2		 xor	 edx, edx
  0222b	f7 f6		 div	 esi

; 6551 :   uiWriteLength = uiWriteLength * uiBlockAlign;

  0222d	0f af c6	 imul	 eax, esi

; 6552 : 
; 6553 :   /********************************************************************/
; 6554 :   /*  Limit the maximum startup length written so that if             */
; 6555 :   /*  MAXIMUM_BUFFERS_QUEUED buffers are written, there is still      */
; 6556 :   /*  space for at least MAXIMUM_WRITE_LENGTH bytes left in the       */
; 6557 :   /*  audio queue.                                                    */
; 6558 :   /********************************************************************/
; 6559 : 
; 6560 :   if ( uiWriteLength > pPlayAudio->uiMaximumWriteLength )

  02230	3b c7		 cmp	 eax, edi
  02232	89 44 24 20	 mov	 DWORD PTR _uiWriteLength$[esp+20], eax
  02236	76 06		 jbe	 SHORT $L71760

; 6561 :   {
; 6562 :     uiWriteLength = pPlayAudio->uiMaximumWriteLength;

  02238	89 7c 24 20	 mov	 DWORD PTR _uiWriteLength$[esp+20], edi
  0223c	8b c7		 mov	 eax, edi
$L71760:

; 6563 :   }
; 6564 : 
; 6565 :   pPlayAudio->uiStartupWriteLength = uiWriteLength;

  0223e	89 45 28	 mov	 DWORD PTR [ebp+40], eax

; 6566 : 
; 6567 : #ifdef TYPING_MODE
; 6568 :   // when we're doing fast starts, we have to make sure we write 
; 6569 :   // at least 65msec or so of audio on the first shot to keep 
; 6570 :   // the Win multimedia services from getting confused and stuttering.
; 6571 :   {
; 6572 : 	  UINT uiStutterMinWrite = (0.065) * (double)pWaveFormat->nAvgBytesPerSec;

  02241	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  02244	89 44 24 10	 mov	 DWORD PTR -8+[esp+24], eax
  02248	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR -8+[esp+28], 0
  02250	df 6c 24 10	 fild	 QWORD PTR -8+[esp+24]
  02254	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@8@3ffb851eb851eb852000
  0225a	e8 00 00 00 00	 call	 __ftol

; 6573 : 
; 6574 : 	  if (pPlayAudio->uiStartupWriteLength < uiStutterMinWrite)

  0225f	39 44 24 20	 cmp	 DWORD PTR _uiWriteLength$[esp+20], eax
  02263	73 03		 jae	 SHORT $L71763

; 6575 : 			   pPlayAudio->uiStartupWriteLength = uiStutterMinWrite;

  02265	89 45 28	 mov	 DWORD PTR [ebp+40], eax
$L71763:

; 6576 :   }
; 6577 : #endif //TYPING_MODE
; 6578 : 
; 6579 :   /********************************************************************/
; 6580 :   /*  Set the minimum startup bytes value.                            */
; 6581 :   /********************************************************************/
; 6582 :  
; 6583 : #if (defined TYPING_MODE) || (defined UNDER_CE) //mfg 21jul1999 ifdef UNDER_CE to avoid 1 sec startup delay 
; 6584 :   {
; 6585 : 	  pPlayAudio->uiMinimumStartupBytes =
; 6586 : 		2 * pPlayAudio->uiStartupWriteLength;

  02268	8b 4d 28	 mov	 ecx, DWORD PTR [ebp+40]
  0226b	5f		 pop	 edi
  0226c	d1 e1		 shl	 ecx, 1
  0226e	89 4d 2c	 mov	 DWORD PTR [ebp+44], ecx
  02271	5d		 pop	 ebp
  02272	5e		 pop	 esi

; 6587 :   }
; 6588 : #else
; 6589 :   pPlayAudio->uiMinimumStartupBytes =
; 6590 :     MAXIMUM_BUFFERS_QUEUED * pPlayAudio->uiStartupWriteLength;
; 6591 : #endif //TYPING_MODE
; 6592 : 
; 6593 :   return MMSYSERR_NOERROR;

  02273	33 c0		 xor	 eax, eax
  02275	5b		 pop	 ebx

; 6594 : }

  02276	83 c4 08	 add	 esp, 8
  02279	c3		 ret	 0
_SetNewFormat ENDP
_pPlayAudio$ = 8
_pWaveFormat$ = 12
_ProcessGetFormatMessage PROC NEAR

; 6627 : {

  02280	56		 push	 esi

; 6628 :   DWORD dwWaveFormatSize;
; 6629 : 
; 6630 :   /********************************************************************/
; 6631 :   /*  Get the size of the WAVEFORMATEX structure including the        */
; 6632 :   /*  possible data space indicated by the cbSize element.            */
; 6633 :   /********************************************************************/
; 6634 : 
; 6635 :   dwWaveFormatSize = GetWaveFormatSize( pPlayAudio->pWaveFormat );

  02281	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  02285	57		 push	 edi
  02286	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  0228c	50		 push	 eax
  0228d	e8 00 00 00 00	 call	 _GetWaveFormatSize

; 6636 : 
; 6637 :   /********************************************************************/
; 6638 :   /*  Copy to the new WAVEFORMATEX structure.                         */
; 6639 :   /********************************************************************/
; 6640 : 
; 6641 :   memcpy( pWaveFormat,
; 6642 :           pPlayAudio->pWaveFormat,
; 6643 :           dwWaveFormatSize );

  02292	8b b6 a0 00 00
	00		 mov	 esi, DWORD PTR [esi+160]
  02298	8b 7c 24 14	 mov	 edi, DWORD PTR _pWaveFormat$[esp+8]
  0229c	8b c8		 mov	 ecx, eax
  0229e	83 c4 04	 add	 esp, 4
  022a1	8b d1		 mov	 edx, ecx

; 6644 : 
; 6645 :   return MMSYSERR_NOERROR;

  022a3	33 c0		 xor	 eax, eax
  022a5	c1 e9 02	 shr	 ecx, 2
  022a8	f3 a5		 rep movsd
  022aa	8b ca		 mov	 ecx, edx
  022ac	83 e1 03	 and	 ecx, 3
  022af	f3 a4		 rep movsb
  022b1	5f		 pop	 edi
  022b2	5e		 pop	 esi

; 6646 : }

  022b3	c3		 ret	 0
_ProcessGetFormatMessage ENDP
_pPlayAudio$ = 8
_pdwVolume$ = 12
_ProcessGetVolumeMessage PROC NEAR

; 6678 :   MMRESULT mmStatus;
; 6679 : 
; 6680 :   /********************************************************************/
; 6681 :   /*  Get the wave output device volume.                              */
; 6682 :   /********************************************************************/
; 6683 : 
; 6684 :   LOCK_MME_CALL(
; 6685 :     mmStatus = waveOutGetVolume((HWAVEOUT)pPlayAudio->uiSelectedDeviceID,
; 6686 :                                 pdwVolume ))

  022c0	8b 4c 24 04	 mov	 ecx, DWORD PTR _pPlayAudio$[esp-4]
  022c4	8b 44 24 08	 mov	 eax, DWORD PTR _pdwVolume$[esp-4]
  022c8	50		 push	 eax
  022c9	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  022cc	52		 push	 edx
  022cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetVolume@8

; 6687 :   return mmStatus;
; 6688 : }

  022d3	c3		 ret	 0
_ProcessGetVolumeMessage ENDP
_pPlayAudio$ = 8
_dwVolume$ = 12
_ProcessSetVolumeMessage PROC NEAR

; 6720 :   MMRESULT mmStatus;
; 6721 : 
; 6722 :   /********************************************************************/
; 6723 :   /*  If volume control is supported then set the volume.             */
; 6724 :   /********************************************************************/
; 6725 : 
; 6726 :   if ( pPlayAudio->dwDeviceSupport &
; 6727 :      ( WAVECAPS_LRVOLUME | WAVECAPS_VOLUME ))

  022e0	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  022e4	f6 40 48 0c	 test	 BYTE PTR [eax+72], 12	; 0000000cH
  022e8	74 10		 je	 SHORT $L71783

; 6728 :   {
; 6729 :     LOCK_MME_CALL(
; 6730 :       mmStatus = waveOutSetVolume((HWAVEOUT)pPlayAudio->uiSelectedDeviceID,
; 6731 :                                   dwVolume ))

  022ea	8b 4c 24 08	 mov	 ecx, DWORD PTR _dwVolume$[esp-4]
  022ee	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  022f1	51		 push	 ecx
  022f2	52		 push	 edx
  022f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutSetVolume@8

; 6736 :   }
; 6737 : 
; 6738 :   return mmStatus;
; 6739 : }

  022f9	c3		 ret	 0
$L71783:

; 6732 :   }
; 6733 :   else
; 6734 :   {
; 6735 :     mmStatus = MMSYSERR_NOTSUPPORTED;

  022fa	b8 08 00 00 00	 mov	 eax, 8

; 6736 :   }
; 6737 : 
; 6738 :   return mmStatus;
; 6739 : }

  022ff	c3		 ret	 0
_ProcessSetVolumeMessage ENDP
_pPlayAudio$ = 8
_aTag$ = 12
_ProcessSynchronizationMarkMessage PROC NEAR

; 6775 : {

  02300	57		 push	 edi

; 6776 :   LPSYNC_MARK_T pSyncMark;
; 6777 :   LPSYNC_MARK_T pNextSyncMark;
; 6778 : 
; 6779 :   /********************************************************************/
; 6780 :   /*  Allocate memory for the synchronization mark structure.         */
; 6781 :   /********************************************************************/
; 6782 : 
; 6783 :   pSyncMark = (LPSYNC_MARK_T)malloc( sizeof(SYNC_MARK_T));

  02301	6a 0c		 push	 12			; 0000000cH
  02303	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  02309	8b f8		 mov	 edi, eax
  0230b	83 c4 04	 add	 esp, 4

; 6784 : 
; 6785 :   if ( pSyncMark == NULL )

  0230e	85 ff		 test	 edi, edi
  02310	75 07		 jne	 SHORT $L71796

; 6786 :   {
; 6787 :     return MMSYSERR_NOMEM;

  02312	b8 07 00 00 00	 mov	 eax, 7
  02317	5f		 pop	 edi

; 6841 : }

  02318	c3		 ret	 0
$L71796:
  02319	56		 push	 esi

; 6788 :   }
; 6789 : 
; 6790 :   /********************************************************************/
; 6791 :   /*  Fill in the synchonization mark structure.                      */
; 6792 :   /********************************************************************/
; 6793 : 
; 6794 :   OP_LockMutex( pPlayAudio->hmxQueuedByteCount );

  0231a	8b 74 24 0c	 mov	 esi, DWORD PTR _pPlayAudio$[esp+4]
  0231e	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  02324	50		 push	 eax
  02325	e8 00 00 00 00	 call	 _OP_LockMutex

; 6795 :   pSyncMark->dwPosition = pPlayAudio->dwQueuedByteCount;

  0232a	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  0232d	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 6796 :   OP_UnlockMutex( pPlayAudio->hmxQueuedByteCount );

  02330	8b 96 84 00 00
	00		 mov	 edx, DWORD PTR [esi+132]
  02336	52		 push	 edx
  02337	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 6797 : 
; 6798 :   pSyncMark->aTag = aTag;

  0233c	8b 44 24 18	 mov	 eax, DWORD PTR _aTag$[esp+12]

; 6799 :   pSyncMark->pLink = NULL;

  02340	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  02346	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 6800 : 
; 6801 :   /********************************************************************/
; 6802 :   /*  Lock the synchronization mark linked list.                      */
; 6803 :   /********************************************************************/
; 6804 : 
; 6805 :   OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  02349	8b 8e 8c 00 00
	00		 mov	 ecx, DWORD PTR [esi+140]
  0234f	51		 push	 ecx
  02350	e8 00 00 00 00	 call	 _OP_LockMutex

; 6806 : 
; 6807 :   /********************************************************************/
; 6808 :   /*  Put the synchronization mark at the end of the linked list.     */
; 6809 :   /********************************************************************/
; 6810 : 
; 6811 :   if ( pPlayAudio->pSyncMarkList == NULL )

  02355	8b 8e 9c 00 00
	00		 mov	 ecx, DWORD PTR [esi+156]
  0235b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0235e	85 c9		 test	 ecx, ecx
  02360	75 08		 jne	 SHORT $L71799

; 6812 :   {
; 6813 :     pPlayAudio->pSyncMarkList = pSyncMark;

  02362	89 be 9c 00 00
	00		 mov	 DWORD PTR [esi+156], edi

; 6814 :   }
; 6815 :   else

  02368	eb 10		 jmp	 SHORT $L71800
$L71799:

; 6816 :   {
; 6817 :     pNextSyncMark = pPlayAudio->pSyncMarkList;
; 6818 : 
; 6819 :     while ( pNextSyncMark->pLink != NULL )

  0236a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0236c	85 c0		 test	 eax, eax
  0236e	74 08		 je	 SHORT $L71804
$L71803:

; 6820 :     {
; 6821 :       pNextSyncMark = pNextSyncMark->pLink;

  02370	8b c8		 mov	 ecx, eax
  02372	8b 01		 mov	 eax, DWORD PTR [ecx]
  02374	85 c0		 test	 eax, eax
  02376	75 f8		 jne	 SHORT $L71803
$L71804:

; 6822 :     }
; 6823 : 
; 6824 :     pNextSyncMark->pLink = pSyncMark;

  02378	89 39		 mov	 DWORD PTR [ecx], edi
$L71800:

; 6825 :   }
; 6826 : 
; 6827 :   /********************************************************************/
; 6828 :   /*  Set the timer thread active so it can process synchronization   */
; 6829 :   /*  marks.                                                          */
; 6830 :   /********************************************************************/
; 6831 : 
; 6832 :   OP_SetEvent( pPlayAudio->hevTimerThreadActive );

  0237a	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0237d	52		 push	 edx
  0237e	e8 00 00 00 00	 call	 _OP_SetEvent

; 6833 : 
; 6834 :   /********************************************************************/
; 6835 :   /*  Unlock the synchronization mark linked list.                    */
; 6836 :   /********************************************************************/
; 6837 : 
; 6838 :   OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  02383	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  02389	50		 push	 eax
  0238a	e8 00 00 00 00	 call	 _OP_UnlockMutex
  0238f	83 c4 08	 add	 esp, 8

; 6839 : 
; 6840 :   return MMSYSERR_NOERROR;

  02392	33 c0		 xor	 eax, eax
  02394	5e		 pop	 esi
  02395	5f		 pop	 edi

; 6841 : }

  02396	c3		 ret	 0
_ProcessSynchronizationMarkMessage ENDP
_pPlayAudio$ = 8
_pdwPosition$ = 12
_ProcessGetPositionMessage PROC NEAR

; 6874 : {

  023a0	57		 push	 edi

; 6875 :   MMRESULT mmStatus;
; 6876 : 
; 6877 :   if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )

  023a1	8b 7c 24 08	 mov	 edi, DWORD PTR _pPlayAudio$[esp]
  023a5	83 7f 34 02	 cmp	 DWORD PTR [edi+52], 2
  023a9	75 1b		 jne	 SHORT $L71811
  023ab	56		 push	 esi

; 6878 :   {
; 6879 :     mmStatus = AudioPosition( pPlayAudio, pdwPosition );

  023ac	8b 74 24 10	 mov	 esi, DWORD PTR _pdwPosition$[esp+4]
  023b0	56		 push	 esi
  023b1	57		 push	 edi
  023b2	e8 00 00 00 00	 call	 _AudioPosition

; 6880 : 
; 6881 :     *pdwPosition += pPlayAudio->dwPositionBase;

  023b7	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  023ba	8b 16		 mov	 edx, DWORD PTR [esi]
  023bc	83 c4 08	 add	 esp, 8
  023bf	03 d1		 add	 edx, ecx
  023c1	89 16		 mov	 DWORD PTR [esi], edx
  023c3	5e		 pop	 esi
  023c4	5f		 pop	 edi

; 6888 :   }
; 6889 : 
; 6890 :   return mmStatus;
; 6891 : }

  023c5	c3		 ret	 0
$L71811:

; 6882 :   }
; 6883 :   else
; 6884 :   {
; 6885 :     mmStatus = MMSYSERR_NOERROR;
; 6886 : 
; 6887 :     *pdwPosition = pPlayAudio->dwPositionBase;

  023c6	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pdwPosition$[esp]
  023ca	8b 57 40	 mov	 edx, DWORD PTR [edi+64]
  023cd	33 c0		 xor	 eax, eax
  023cf	5f		 pop	 edi
  023d0	89 11		 mov	 DWORD PTR [ecx], edx

; 6888 :   }
; 6889 : 
; 6890 :   return mmStatus;
; 6891 : }

  023d2	c3		 ret	 0
_ProcessGetPositionMessage ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutGetPosition@12:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pdwPosition$ = 12
_AudioPosition PROC NEAR

; 6929 : {

  023e0	56		 push	 esi

; 6930 :   MMRESULT mmStatus;
; 6931 :   LPMMTIME pMmt;
; 6932 : 
; 6933 :   /********************************************************************/
; 6934 :   /*  Get the wave output device position.                            */
; 6935 :   /*  First allocate memory for the MMTIME structure.                 */
; 6936 :   /********************************************************************/
; 6937 : 
; 6938 :   LOCK_MME_CALL( pMmt = (LPMMTIME)ALLOCATE_SERVER_MEM(sizeof(MMTIME)))

  023e1	6a 0c		 push	 12			; 0000000cH
  023e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  023e9	8b f0		 mov	 esi, eax
  023eb	83 c4 04	 add	 esp, 4

; 6939 : 
; 6940 :   if ( pMmt == NULL )

  023ee	85 f6		 test	 esi, esi
  023f0	75 07		 jne	 SHORT $L71823

; 6941 :   {
; 6942 :     return MMSYSERR_NOMEM;

  023f2	b8 07 00 00 00	 mov	 eax, 7
  023f7	5e		 pop	 esi

; 7015 : }

  023f8	c3		 ret	 0
$L71823:
  023f9	53		 push	 ebx
  023fa	57		 push	 edi

; 6943 :   }
; 6944 : 
; 6945 :   /********************************************************************/
; 6946 :   /*  Get the position of the last sample played by the wave output   */
; 6947 :   /*  device.                                                         */
; 6948 :   /********************************************************************/
; 6949 : 
; 6950 :   pMmt->wType = TIME_BYTES;
; 6951 : 
; 6952 :   LOCK_MME_CALL( mmStatus = waveOutGetPosition( pPlayAudio->hWaveOut,
; 6953 :                                                 pMmt,
; 6954 :                                                 sizeof(MMTIME)))

  023fb	8b 7c 24 10	 mov	 edi, DWORD PTR _pPlayAudio$[esp+8]
  023ff	c7 06 04 00 00
	00		 mov	 DWORD PTR [esi], 4
  02405	6a 0c		 push	 12			; 0000000cH
  02407	56		 push	 esi
  02408	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0240b	50		 push	 eax
  0240c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetPosition@12
  02412	8b d8		 mov	 ebx, eax

; 6955 :   if ( mmStatus )

  02414	85 db		 test	 ebx, ebx
  02416	74 1a		 je	 SHORT $L71825

; 6956 :   {
; 6957 :     *pdwPosition = 0xFFFFFFFF;

  02418	8b 4c 24 14	 mov	 ecx, DWORD PTR _pdwPosition$[esp+8]

; 7002 :       mmStatus = MMSYSERR_ERROR;
; 7003 : 
; 7004 :       break;
; 7005 :     }
; 7006 :   }
; 7007 : 
; 7008 :   /********************************************************************/
; 7009 :   /*  Free memory for the MMTIME structure.                           */
; 7010 :   /********************************************************************/
; 7011 : 
; 7012 :   LOCK_MME_CALL( FREE_SERVER_MEM( pMmt ))

  0241c	56		 push	 esi
  0241d	c7 01 ff ff ff
	ff		 mov	 DWORD PTR [ecx], -1
  02423	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  02429	83 c4 04	 add	 esp, 4

; 7013 : 
; 7014 :   return mmStatus;

  0242c	8b c3		 mov	 eax, ebx
  0242e	5f		 pop	 edi
  0242f	5b		 pop	 ebx
  02430	5e		 pop	 esi

; 7015 : }

  02431	c3		 ret	 0
$L71825:

; 6958 :   }
; 6959 :   else
; 6960 :   {
; 6961 :     switch ( pMmt->wType )
; 6962 :     {

  02432	8b 06		 mov	 eax, DWORD PTR [esi]
  02434	48		 dec	 eax
  02435	74 7d		 je	 SHORT $L71831
  02437	48		 dec	 eax
  02438	74 48		 je	 SHORT $L71833
  0243a	83 e8 02	 sub	 eax, 2
  0243d	74 1f		 je	 SHORT $L71835

; 6995 :       }
; 6996 : 
; 6997 :       break;
; 6998 : 
; 6999 :     default:
; 7000 : 
; 7001 :       *pdwPosition = 0xFFFFFFFF;

  0243f	8b 54 24 14	 mov	 edx, DWORD PTR _pdwPosition$[esp+8]

; 7002 :       mmStatus = MMSYSERR_ERROR;
; 7003 : 
; 7004 :       break;
; 7005 :     }
; 7006 :   }
; 7007 : 
; 7008 :   /********************************************************************/
; 7009 :   /*  Free memory for the MMTIME structure.                           */
; 7010 :   /********************************************************************/
; 7011 : 
; 7012 :   LOCK_MME_CALL( FREE_SERVER_MEM( pMmt ))

  02443	56		 push	 esi
  02444	bb 01 00 00 00	 mov	 ebx, 1
  02449	c7 02 ff ff ff
	ff		 mov	 DWORD PTR [edx], -1
  0244f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  02455	83 c4 04	 add	 esp, 4

; 7013 : 
; 7014 :   return mmStatus;

  02458	8b c3		 mov	 eax, ebx
  0245a	5f		 pop	 edi
  0245b	5b		 pop	 ebx
  0245c	5e		 pop	 esi

; 7015 : }

  0245d	c3		 ret	 0
$L71835:

; 6984 :       }
; 6985 : 
; 6986 :       break;
; 6987 : 
; 6988 :     case TIME_BYTES:
; 6989 : 
; 6990 :       *pdwPosition = pMmt->u.cb;

  0245e	8b 4c 24 14	 mov	 ecx, DWORD PTR _pdwPosition$[esp+8]
  02462	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  02465	89 01		 mov	 DWORD PTR [ecx], eax

; 6991 : 
; 6992 :       if ( pPlayAudio->bConvertToEightBit )

  02467	8b 57 50	 mov	 edx, DWORD PTR [edi+80]
  0246a	85 d2		 test	 edx, edx
  0246c	74 75		 je	 SHORT $L71832

; 6993 :       {
; 6994 :         *pdwPosition = *pdwPosition << 1;

  0246e	03 c0		 add	 eax, eax

; 7002 :       mmStatus = MMSYSERR_ERROR;
; 7003 : 
; 7004 :       break;
; 7005 :     }
; 7006 :   }
; 7007 : 
; 7008 :   /********************************************************************/
; 7009 :   /*  Free memory for the MMTIME structure.                           */
; 7010 :   /********************************************************************/
; 7011 : 
; 7012 :   LOCK_MME_CALL( FREE_SERVER_MEM( pMmt ))

  02470	56		 push	 esi
  02471	89 01		 mov	 DWORD PTR [ecx], eax
  02473	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  02479	83 c4 04	 add	 esp, 4

; 7013 : 
; 7014 :   return mmStatus;

  0247c	8b c3		 mov	 eax, ebx
  0247e	5f		 pop	 edi
  0247f	5b		 pop	 ebx
  02480	5e		 pop	 esi

; 7015 : }

  02481	c3		 ret	 0
$L71833:

; 6972 :       }
; 6973 : 
; 6974 :       break;
; 6975 : 
; 6976 :     case TIME_SAMPLES:
; 6977 : 
; 6978 :       *pdwPosition = pMmt->u.sample
; 6979 :         * pPlayAudio->pWaveFormat->nBlockAlign;

  02482	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
  02488	33 c0		 xor	 eax, eax
  0248a	66 8b 41 0c	 mov	 ax, WORD PTR [ecx+12]
  0248e	8b 4c 24 14	 mov	 ecx, DWORD PTR _pdwPosition$[esp+8]
  02492	0f af 46 04	 imul	 eax, DWORD PTR [esi+4]
  02496	89 01		 mov	 DWORD PTR [ecx], eax

; 6980 : 
; 6981 :       if ( pPlayAudio->bConvertToEightBit )

  02498	8b 57 50	 mov	 edx, DWORD PTR [edi+80]
  0249b	85 d2		 test	 edx, edx
  0249d	74 44		 je	 SHORT $L71832

; 6982 :       {
; 6983 :         *pdwPosition = *pdwPosition << 1;

  0249f	8d 14 00	 lea	 edx, DWORD PTR [eax+eax]

; 7002 :       mmStatus = MMSYSERR_ERROR;
; 7003 : 
; 7004 :       break;
; 7005 :     }
; 7006 :   }
; 7007 : 
; 7008 :   /********************************************************************/
; 7009 :   /*  Free memory for the MMTIME structure.                           */
; 7010 :   /********************************************************************/
; 7011 : 
; 7012 :   LOCK_MME_CALL( FREE_SERVER_MEM( pMmt ))

  024a2	56		 push	 esi
  024a3	89 11		 mov	 DWORD PTR [ecx], edx
  024a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  024ab	83 c4 04	 add	 esp, 4

; 7013 : 
; 7014 :   return mmStatus;

  024ae	8b c3		 mov	 eax, ebx
  024b0	5f		 pop	 edi
  024b1	5b		 pop	 ebx
  024b2	5e		 pop	 esi

; 7015 : }

  024b3	c3		 ret	 0
$L71831:

; 6963 :     case TIME_MS:
; 6964 : 
; 6965 :       *pdwPosition =
; 6966 :         ( pMmt->u.ms * pPlayAudio->pWaveFormat->nSamplesPerSec
; 6967 :             * pPlayAudio->pWaveFormat->nBlockAlign ) / 1000;

  024b4	8b 87 a0 00 00
	00		 mov	 eax, DWORD PTR [edi+160]
  024ba	33 c9		 xor	 ecx, ecx
  024bc	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  024c0	0f af 48 04	 imul	 ecx, DWORD PTR [eax+4]
  024c4	0f af 4e 04	 imul	 ecx, DWORD PTR [esi+4]
  024c8	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  024cd	f7 e1		 mul	 ecx
  024cf	8b 44 24 14	 mov	 eax, DWORD PTR _pdwPosition$[esp+8]
  024d3	c1 ea 06	 shr	 edx, 6
  024d6	89 10		 mov	 DWORD PTR [eax], edx

; 6968 : 
; 6969 :       if ( pPlayAudio->bConvertToEightBit )

  024d8	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  024db	85 c9		 test	 ecx, ecx
  024dd	74 04		 je	 SHORT $L71832

; 6970 :       {
; 6971 :         *pdwPosition = *pdwPosition << 1;

  024df	03 d2		 add	 edx, edx
  024e1	89 10		 mov	 DWORD PTR [eax], edx
$L71832:

; 7002 :       mmStatus = MMSYSERR_ERROR;
; 7003 : 
; 7004 :       break;
; 7005 :     }
; 7006 :   }
; 7007 : 
; 7008 :   /********************************************************************/
; 7009 :   /*  Free memory for the MMTIME structure.                           */
; 7010 :   /********************************************************************/
; 7011 : 
; 7012 :   LOCK_MME_CALL( FREE_SERVER_MEM( pMmt ))

  024e3	56		 push	 esi
  024e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  024ea	83 c4 04	 add	 esp, 4

; 7013 : 
; 7014 :   return mmStatus;

  024ed	8b c3		 mov	 eax, ebx
  024ef	5f		 pop	 edi
  024f0	5b		 pop	 ebx
  024f1	5e		 pop	 esi

; 7015 : }

  024f2	c3		 ret	 0
_AudioPosition ENDP
_pPlayAudio$ = 8
_aItem_0$ = 12
_aItem_1$ = 16
_ReportStatusToApplication PROC NEAR

; 7059 :   unsigned int uiRet;
; 7060 : 
; 7061 : #ifdef AUD_DEBUG
; 7062 :   OutputDebugString("PA: ReportStatusToApplication()\n");
; 7063 : #endif
; 7064 :   /********************************************************************/
; 7065 :   /*  If no callback routine is specified then discard the message.   */
; 7066 :   /********************************************************************/
; 7067 : 
; 7068 :   if ( 
; 7069 : 	  (pPlayAudio->CallbackRoutine != NULL )
; 7070 : #ifdef TYPING_MODE //13may97 tek don't return these in typing mode..!
; 7071 : 	  && ( !(((LPTTS_HANDLE_T)(pPlayAudio->aInstance))->bInTypingMode) )
; 7072 : #endif
; 7073 : 	 )

  02500	8b 4c 24 04	 mov	 ecx, DWORD PTR _pPlayAudio$[esp-4]
  02504	56		 push	 esi
  02505	8b 11		 mov	 edx, DWORD PTR [ecx]
  02507	85 d2		 test	 edx, edx
  02509	74 20		 je	 SHORT $L71848
  0250b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0250e	8b b0 d4 00 00
	00		 mov	 esi, DWORD PTR [eax+212]
  02514	85 f6		 test	 esi, esi
  02516	75 13		 jne	 SHORT $L71848

; 7074 :   {
; 7075 :     uiRet = ( *pPlayAudio->CallbackRoutine )( pPlayAudio,
; 7076 :                                               pPlayAudio->aInstance,
; 7077 :                                               aItem_0,
; 7078 :                                               aItem_1 );

  02518	8b 74 24 10	 mov	 esi, DWORD PTR _aItem_1$[esp]
  0251c	56		 push	 esi
  0251d	8b 74 24 10	 mov	 esi, DWORD PTR _aItem_0$[esp+4]
  02521	56		 push	 esi
  02522	50		 push	 eax
  02523	51		 push	 ecx
  02524	ff d2		 call	 edx
  02526	83 c4 10	 add	 esp, 16			; 00000010H
  02529	5e		 pop	 esi

; 7083 :   }
; 7084 : 
; 7085 :   return uiRet;
; 7086 : }

  0252a	c3		 ret	 0
$L71848:

; 7079 :   }
; 7080 :   else
; 7081 :   {
; 7082 :     uiRet = 0;

  0252b	33 c0		 xor	 eax, eax
  0252d	5e		 pop	 esi

; 7083 :   }
; 7084 : 
; 7085 :   return uiRet;
; 7086 : }

  0252e	c3		 ret	 0
_ReportStatusToApplication ENDP
_pPlayAudio$ = 8
_uiMessage$ = 12
_aParam$ = 16
_mDummy0$ = -4
_mDummy1$ = -8
_mReturn$ = -12
_SendPlayAudioMessage PROC NEAR

; 7124 :   ATYPE_T mDummy0;
; 7125 :   ATYPE_T mDummy1;
; 7126 :   ATYPE_T mReturn;
; 7127 : 
; 7128 :   /********************************************************************/
; 7129 :   /*  Put the message into the "play audio" message queue.            */
; 7130 :   /********************************************************************/
; 7131 : 
; 7132 :   OP_LockMutex( pShm_t->hmxGlobalSendPlayAudio );

  02530	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  02535	83 ec 0c	 sub	 esp, 12			; 0000000cH
  02538	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0253b	51		 push	 ecx
  0253c	e8 00 00 00 00	 call	 _OP_LockMutex

; 7133 : 
; 7134 :   WriteMessageQueue( pShm_t->pGlobalPlayAudioMessageQueue,
; 7135 :                      (ATYPE_T)pPlayAudio,
; 7136 :                      uiMessage,
; 7137 :                      aParam );

  02541	8b 54 24 1c	 mov	 edx, DWORD PTR _aParam$[esp+12]
  02545	8b 44 24 18	 mov	 eax, DWORD PTR _uiMessage$[esp+12]
  02549	8b 4c 24 14	 mov	 ecx, DWORD PTR _pPlayAudio$[esp+12]
  0254d	52		 push	 edx
  0254e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  02554	50		 push	 eax
  02555	51		 push	 ecx
  02556	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  02559	50		 push	 eax
  0255a	e8 00 00 00 00	 call	 _WriteMessageQueue

; 7138 : 
; 7139 :   /********************************************************************/
; 7140 :   /*  Get the result from the report message queue.                   */
; 7141 :   /********************************************************************/
; 7142 : 
; 7143 :   ReadMessageQueue( pShm_t->pGlobalReportMessageQueue,
; 7144 :                     &mDummy0,
; 7145 :                     &mDummy1,
; 7146 :                     &mReturn );

  0255f	8d 4c 24 14	 lea	 ecx, DWORD PTR _mReturn$[esp+32]
  02563	8d 54 24 18	 lea	 edx, DWORD PTR _mDummy1$[esp+32]
  02567	51		 push	 ecx
  02568	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t
  0256e	52		 push	 edx
  0256f	8d 44 24 24	 lea	 eax, DWORD PTR _mDummy0$[esp+40]
  02573	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  02576	50		 push	 eax
  02577	52		 push	 edx
  02578	e8 00 00 00 00	 call	 _ReadMessageQueue

; 7147 :   OP_UnlockMutex( pShm_t->hmxGlobalSendPlayAudio );

  0257d	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  02582	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  02585	51		 push	 ecx
  02586	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 7148 :   return (SENDRET_T)mReturn;

  0258b	8b 44 24 28	 mov	 eax, DWORD PTR _mReturn$[esp+52]

; 7149 : }

  0258f	83 c4 34	 add	 esp, 52			; 00000034H
  02592	c3		 ret	 0
_SendPlayAudioMessage ENDP
_uiQueueLength$ = 8
_CreateMessageQueue PROC NEAR

; 7179 : {

  025a0	53		 push	 ebx
  025a1	55		 push	 ebp

; 7180 :   unsigned int uiBufferLength;
; 7181 :   LPMESSAGE_QUEUE_T pMessageQueue;
; 7182 : 
; 7183 :   /********************************************************************/
; 7184 :   /*  Allocate the message queue structure.                           */
; 7185 :   /********************************************************************/
; 7186 : 
; 7187 :   pMessageQueue = (LPMESSAGE_QUEUE_T)malloc( sizeof( MESSAGE_QUEUE_T ));

  025a2	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__malloc
  025a8	56		 push	 esi
  025a9	57		 push	 edi
  025aa	6a 28		 push	 40			; 00000028H
  025ac	ff d5		 call	 ebp
  025ae	8b f0		 mov	 esi, eax

; 7188 : 
; 7189 :   if ( pMessageQueue == NULL )

  025b0	33 ff		 xor	 edi, edi
  025b2	83 c4 04	 add	 esp, 4
  025b5	3b f7		 cmp	 esi, edi
  025b7	75 07		 jne	 SHORT $L71870
  025b9	5f		 pop	 edi
  025ba	5e		 pop	 esi
  025bb	5d		 pop	 ebp

; 7190 :   {
; 7191 :     return NULL;

  025bc	33 c0		 xor	 eax, eax
  025be	5b		 pop	 ebx

; 7268 : }

  025bf	c3		 ret	 0
$L71870:

; 7192 :   }
; 7193 : 
; 7194 :   /********************************************************************/
; 7195 :   /*  Initialize message queue structure elements.                    */
; 7196 :   /********************************************************************/
; 7197 : 
; 7198 :   pMessageQueue->pStart = NULL;
; 7199 :   pMessageQueue->hevNotFull = NULL;
; 7200 :   pMessageQueue->hevNotEmpty = NULL;
; 7201 :   pMessageQueue->hmxMessageQueue = NULL;
; 7202 : 
; 7203 :   /********************************************************************/
; 7204 :   /*  Allocate the message queue buffer in multiples of 3 ATYPE_T     */
; 7205 :   /*  items.                                                          */
; 7206 :   /********************************************************************/
; 7207 : 
; 7208 :   uiBufferLength = NUMBER_OF_ITEMS_IN_MESSAGE * uiQueueLength;

  025c0	8b 44 24 14	 mov	 eax, DWORD PTR _uiQueueLength$[esp+12]
  025c4	89 3e		 mov	 DWORD PTR [esi], edi
  025c6	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  025c9	89 7e 20	 mov	 DWORD PTR [esi+32], edi
  025cc	8d 1c 40	 lea	 ebx, DWORD PTR [eax+eax*2]
  025cf	89 7e 24	 mov	 DWORD PTR [esi+36], edi

; 7209 : 
; 7210 :   pMessageQueue->pStart =
; 7211 :     (LPATYPE_T)malloc( uiBufferLength * sizeof(ATYPE_T));

  025d2	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  025d9	50		 push	 eax
  025da	ff d5		 call	 ebp
  025dc	83 c4 04	 add	 esp, 4

; 7212 : 
; 7213 :   if ( pMessageQueue->pStart == NULL )

  025df	3b c7		 cmp	 eax, edi
  025e1	89 06		 mov	 DWORD PTR [esi], eax
  025e3	75 10		 jne	 SHORT $L71879

; 7214 :   {
; 7215 :     DestroyMessageQueue( pMessageQueue );

  025e5	56		 push	 esi
  025e6	e8 00 00 00 00	 call	 _DestroyMessageQueue
  025eb	83 c4 04	 add	 esp, 4

; 7216 :     return NULL;

  025ee	33 c0		 xor	 eax, eax
  025f0	5f		 pop	 edi
  025f1	5e		 pop	 esi
  025f2	5d		 pop	 ebp
  025f3	5b		 pop	 ebx

; 7268 : }

  025f4	c3		 ret	 0
$L71879:

; 7217 :   }
; 7218 : 
; 7219 :   /********************************************************************/
; 7220 :   /*  Allocate the message queue mutex object.                        */
; 7221 :   /********************************************************************/
; 7222 : 
; 7223 :   pMessageQueue->hmxMessageQueue = OP_CreateMutex();

  025f5	e8 00 00 00 00	 call	 _OP_CreateMutex

; 7224 : 
; 7225 :   if ( pMessageQueue->hmxMessageQueue == NULL )

  025fa	3b c7		 cmp	 eax, edi
  025fc	89 46 24	 mov	 DWORD PTR [esi+36], eax
  025ff	75 10		 jne	 SHORT $L71882

; 7226 :   {
; 7227 :     DestroyMessageQueue( pMessageQueue );

  02601	56		 push	 esi
  02602	e8 00 00 00 00	 call	 _DestroyMessageQueue
  02607	83 c4 04	 add	 esp, 4

; 7228 :     return NULL;

  0260a	33 c0		 xor	 eax, eax
  0260c	5f		 pop	 edi
  0260d	5e		 pop	 esi
  0260e	5d		 pop	 ebp
  0260f	5b		 pop	 ebx

; 7268 : }

  02610	c3		 ret	 0
$L71882:

; 7229 :   }
; 7230 : 
; 7231 :   /********************************************************************/
; 7232 :   /*  Initialize the message queue structure.                         */
; 7233 :   /********************************************************************/
; 7234 : 
; 7235 :   pMessageQueue->pInput = pMessageQueue->pStart;

  02611	8b 06		 mov	 eax, DWORD PTR [esi]

; 7236 :   pMessageQueue->pOutput = pMessageQueue->pStart;
; 7237 :   pMessageQueue->uiInputPosition = 0;
; 7238 :   pMessageQueue->uiOutputPosition = 0;
; 7239 :   pMessageQueue->uiLength = uiBufferLength;
; 7240 :   pMessageQueue->uiCount = 0;
; 7241 : 
; 7242 :   /********************************************************************/
; 7243 :   /*  Create the "Not Empty" Event. The initial state is not          */
; 7244 :   /*  signalled.                                                      */
; 7245 :   /********************************************************************/
; 7246 : 
; 7247 :   pMessageQueue->hevNotEmpty = OP_CreateEvent( TRUE, FALSE );

  02613	57		 push	 edi
  02614	6a 01		 push	 1
  02616	89 46 04	 mov	 DWORD PTR [esi+4], eax
  02619	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0261c	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0261f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  02622	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  02625	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  02628	e8 00 00 00 00	 call	 _OP_CreateEvent
  0262d	83 c4 08	 add	 esp, 8

; 7248 : 
; 7249 :   if ( pMessageQueue->hevNotEmpty == NULL )

  02630	3b c7		 cmp	 eax, edi
  02632	89 46 20	 mov	 DWORD PTR [esi+32], eax
  02635	75 10		 jne	 SHORT $L71885

; 7250 :   {
; 7251 :     DestroyMessageQueue( pMessageQueue );

  02637	56		 push	 esi
  02638	e8 00 00 00 00	 call	 _DestroyMessageQueue
  0263d	83 c4 04	 add	 esp, 4

; 7252 :     return NULL;

  02640	33 c0		 xor	 eax, eax
  02642	5f		 pop	 edi
  02643	5e		 pop	 esi
  02644	5d		 pop	 ebp
  02645	5b		 pop	 ebx

; 7268 : }

  02646	c3		 ret	 0
$L71885:

; 7253 :   }
; 7254 : 
; 7255 :   /********************************************************************/
; 7256 :   /*  Create the "Not Full" Event. The initial state is signalled.    */
; 7257 :   /********************************************************************/
; 7258 : 
; 7259 :   pMessageQueue->hevNotFull = OP_CreateEvent( TRUE, TRUE );

  02647	6a 01		 push	 1
  02649	6a 01		 push	 1
  0264b	e8 00 00 00 00	 call	 _OP_CreateEvent
  02650	83 c4 08	 add	 esp, 8

; 7260 : 
; 7261 :   if ( pMessageQueue->hevNotFull == NULL )

  02653	3b c7		 cmp	 eax, edi
  02655	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  02658	75 10		 jne	 SHORT $L71888

; 7262 :   {
; 7263 :     DestroyMessageQueue( pMessageQueue );

  0265a	56		 push	 esi
  0265b	e8 00 00 00 00	 call	 _DestroyMessageQueue
  02660	83 c4 04	 add	 esp, 4

; 7264 :     return NULL;

  02663	33 c0		 xor	 eax, eax
  02665	5f		 pop	 edi
  02666	5e		 pop	 esi
  02667	5d		 pop	 ebp
  02668	5b		 pop	 ebx

; 7268 : }

  02669	c3		 ret	 0
$L71888:

; 7265 :   }
; 7266 : 
; 7267 :   return pMessageQueue;

  0266a	8b c6		 mov	 eax, esi
  0266c	5f		 pop	 edi
  0266d	5e		 pop	 esi
  0266e	5d		 pop	 ebp
  0266f	5b		 pop	 ebx

; 7268 : }

  02670	c3		 ret	 0
_CreateMessageQueue ENDP
_pMessageQueue$ = 8
_DestroyMessageQueue PROC NEAR

; 7295 : {

  02680	56		 push	 esi

; 7296 :   if ( pMessageQueue != NULL )

  02681	8b 74 24 08	 mov	 esi, DWORD PTR _pMessageQueue$[esp]
  02685	85 f6		 test	 esi, esi
  02687	74 38		 je	 SHORT $L71894

; 7297 :   {
; 7298 :     /******************************************************************/
; 7299 :     /*  Delete the mutex object.                                      */
; 7300 :     /******************************************************************/
; 7301 : 
; 7302 :     OP_DestroyMutex( pMessageQueue->hmxMessageQueue );

  02689	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0268c	57		 push	 edi
  0268d	50		 push	 eax
  0268e	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 7303 : 
; 7304 :     /******************************************************************/
; 7305 :     /*  Free the message queue events.                                */
; 7306 :     /******************************************************************/
; 7307 : 
; 7308 :     OP_DestroyEvent( pMessageQueue->hevNotEmpty );

  02693	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  02696	51		 push	 ecx
  02697	e8 00 00 00 00	 call	 _OP_DestroyEvent

; 7309 : 
; 7310 :     OP_DestroyEvent( pMessageQueue->hevNotFull );

  0269c	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  0269f	52		 push	 edx
  026a0	e8 00 00 00 00	 call	 _OP_DestroyEvent

; 7311 : 
; 7312 :     /******************************************************************/
; 7313 :     /*  Deallocate the message queue buffer and the message queue     */
; 7314 :     /*  structure.                                                    */
; 7315 :     /******************************************************************/
; 7316 : 
; 7317 :     if ( pMessageQueue->pStart != NULL )

  026a5	8b 06		 mov	 eax, DWORD PTR [esi]
  026a7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
  026ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  026b0	85 c0		 test	 eax, eax
  026b2	74 06		 je	 SHORT $L71896

; 7318 :     {
; 7319 :       free( pMessageQueue->pStart );

  026b4	50		 push	 eax
  026b5	ff d7		 call	 edi
  026b7	83 c4 04	 add	 esp, 4
$L71896:

; 7320 :     }
; 7321 : 
; 7322 :     free( pMessageQueue );

  026ba	56		 push	 esi
  026bb	ff d7		 call	 edi
  026bd	83 c4 04	 add	 esp, 4
  026c0	5f		 pop	 edi
$L71894:
  026c1	5e		 pop	 esi

; 7323 :   }
; 7324 : 
; 7325 :   return;
; 7326 : }

  026c2	c3		 ret	 0
_DestroyMessageQueue ENDP
_pMessageQueue$ = 8
_aItem_0$ = 12
_aItem_1$ = 16
_aItem_2$ = 20
_aArray$ = -12
_WriteMessageQueue PROC NEAR

; 7367 : {

  026d0	83 ec 0c	 sub	 esp, 12			; 0000000cH
  026d3	53		 push	 ebx
  026d4	55		 push	 ebp
  026d5	56		 push	 esi

; 7368 :   unsigned int uiI;
; 7369 :   unsigned int uiRemaining;
; 7370 :   unsigned int uiNumberToWrite;
; 7371 :   ATYPE_T aArray[NUMBER_OF_ITEMS_IN_MESSAGE];
; 7372 :   LPATYPE_T pItems;
; 7373 : 
; 7374 :   /********************************************************************/
; 7375 :   /*  Block if the message queue is busy.                             */
; 7376 :   /********************************************************************/
; 7377 : 
; 7378 :   OP_LockMutex( pMessageQueue->hmxMessageQueue );

  026d6	8b 74 24 1c	 mov	 esi, DWORD PTR _pMessageQueue$[esp+20]
  026da	57		 push	 edi
  026db	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  026de	50		 push	 eax
  026df	e8 00 00 00 00	 call	 _OP_LockMutex

; 7379 : 
; 7380 :   aArray[0] = aItem_0;

  026e4	8b 4c 24 28	 mov	 ecx, DWORD PTR _aItem_0$[esp+28]

; 7381 :   aArray[1] = aItem_1;
; 7382 :   aArray[2] = aItem_2;

  026e8	8b 44 24 30	 mov	 eax, DWORD PTR _aItem_2$[esp+28]
  026ec	8b 54 24 2c	 mov	 edx, DWORD PTR _aItem_1$[esp+28]
  026f0	89 4c 24 14	 mov	 DWORD PTR _aArray$[esp+32], ecx

; 7383 :   pItems = &aArray[0];
; 7384 : 
; 7385 :   /********************************************************************/
; 7386 :   /*  If there's not enough room for the items then block.            */
; 7387 :   /*  WriteMessageQueue must own pMessageQueue->uiCount               */
; 7388 :   /*  during the compare in case multiple threads are trying to write */
; 7389 :   /*  the queue at the same time.                                     */
; 7390 :   /********************************************************************/
; 7391 : 
; 7392 :   uiNumberToWrite = NUMBER_OF_ITEMS_IN_MESSAGE;
; 7393 :   
; 7394 :   while ( pMessageQueue->uiCount + uiNumberToWrite > pMessageQueue->uiLength )

  026f4	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  026f7	89 44 24 1c	 mov	 DWORD PTR _aArray$[esp+40], eax
  026fb	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  026fe	83 c1 03	 add	 ecx, 3
  02701	83 c4 04	 add	 esp, 4
  02704	3b c8		 cmp	 ecx, eax
  02706	89 54 24 14	 mov	 DWORD PTR _aArray$[esp+32], edx
  0270a	8d 7c 24 10	 lea	 edi, DWORD PTR _aArray$[esp+28]
  0270e	76 36		 jbe	 SHORT $L71913
$L71912:

; 7395 :   {
; 7396 :   
; 7397 :     OP_ResetEvent( pMessageQueue->hevNotFull );

  02710	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  02713	52		 push	 edx
  02714	e8 00 00 00 00	 call	 _OP_ResetEvent

; 7398 : 
; 7399 :     OP_UnlockMutex( pMessageQueue->hmxMessageQueue );

  02719	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0271c	50		 push	 eax
  0271d	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 7400 :   
; 7401 :     OP_WaitForEvent( pMessageQueue->hevNotFull, OP_INFINITE );

  02722	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  02725	6a ff		 push	 -1
  02727	51		 push	 ecx
  02728	e8 00 00 00 00	 call	 _OP_WaitForEvent

; 7402 :   
; 7403 :     OP_LockMutex( pMessageQueue->hmxMessageQueue );

  0272d	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  02730	52		 push	 edx
  02731	e8 00 00 00 00	 call	 _OP_LockMutex
  02736	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  02739	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0273c	83 c0 03	 add	 eax, 3
  0273f	83 c4 14	 add	 esp, 20			; 00000014H
  02742	3b c1		 cmp	 eax, ecx
  02744	77 ca		 ja	 SHORT $L71912
$L71913:

; 7404 :   }
; 7405 : 
; 7406 :   /********************************************************************/
; 7407 :   /*  There is enough space in the message queue.                     */
; 7408 :   /*  Test to see if the data will wrap around the circular queue.    */
; 7409 :   /********************************************************************/
; 7410 : 
; 7411 :   if (( pMessageQueue->uiInputPosition + uiNumberToWrite )
; 7412 :          > pMessageQueue->uiLength )

  02746	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  02749	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0274c	8d 51 03	 lea	 edx, DWORD PTR [ecx+3]
  0274f	3b d0		 cmp	 edx, eax
  02751	76 50		 jbe	 SHORT $L71914

; 7413 :   {
; 7414 :     /******************************************************************/
; 7415 :     /*  The data will wrap around the circular queue.                 */
; 7416 :     /******************************************************************/
; 7417 : 
; 7418 :     uiRemaining = pMessageQueue->uiLength - pMessageQueue->uiInputPosition;

  02753	2b c1		 sub	 eax, ecx

; 7419 : 
; 7420 :     for ( uiI = 0; uiI < uiRemaining; uiI++ )

  02755	ba 04 00 00 00	 mov	 edx, 4
  0275a	74 16		 je	 SHORT $L71917

; 7413 :   {
; 7414 :     /******************************************************************/
; 7415 :     /*  The data will wrap around the circular queue.                 */
; 7416 :     /******************************************************************/
; 7417 : 
; 7418 :     uiRemaining = pMessageQueue->uiLength - pMessageQueue->uiInputPosition;

  0275c	8b c8		 mov	 ecx, eax
$L71915:

; 7421 :      *pMessageQueue->pInput++ = *pItems++;

  0275e	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  02761	8b 2f		 mov	 ebp, DWORD PTR [edi]
  02763	03 fa		 add	 edi, edx
  02765	89 2b		 mov	 DWORD PTR [ebx], ebp
  02767	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0276a	03 da		 add	 ebx, edx
  0276c	49		 dec	 ecx
  0276d	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  02770	75 ec		 jne	 SHORT $L71915
$L71917:

; 7422 : 
; 7423 :     pMessageQueue->pInput = pMessageQueue->pStart;

  02772	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 7424 : 
; 7425 :     for ( uiI = uiRemaining; uiI < uiNumberToWrite; uiI++ )

  02774	83 f8 03	 cmp	 eax, 3
  02777	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0277a	73 1b		 jae	 SHORT $L71920
  0277c	b9 03 00 00 00	 mov	 ecx, 3
  02781	2b c8		 sub	 ecx, eax
$L71918:

; 7426 :      *pMessageQueue->pInput++ = *pItems++;

  02783	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  02786	8b 2f		 mov	 ebp, DWORD PTR [edi]
  02788	03 fa		 add	 edi, edx
  0278a	89 2b		 mov	 DWORD PTR [ebx], ebp
  0278c	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0278f	03 da		 add	 ebx, edx
  02791	49		 dec	 ecx
  02792	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  02795	75 ec		 jne	 SHORT $L71918
$L71920:

; 7427 : 
; 7428 :     /******************************************************************/
; 7429 :     /*  Update the input position in a circular fashion.              */
; 7430 :     /******************************************************************/
; 7431 : 
; 7432 :     pMessageQueue->uiInputPosition = uiNumberToWrite - uiRemaining;

  02797	ba 03 00 00 00	 mov	 edx, 3
  0279c	2b d0		 sub	 edx, eax
  0279e	89 56 0c	 mov	 DWORD PTR [esi+12], edx

; 7433 :   }
; 7434 :   else

  027a1	eb 22		 jmp	 SHORT $L71921
$L71914:

; 7435 :   {
; 7436 :     /******************************************************************/
; 7437 :     /*  The data will NOT wrap around the circular queue.             */
; 7438 :     /******************************************************************/
; 7439 : 
; 7440 :     for ( uiI = 0; uiI < uiNumberToWrite; uiI++ )

  027a3	b8 03 00 00 00	 mov	 eax, 3
  027a8	ba 04 00 00 00	 mov	 edx, 4
$L71922:

; 7441 :      *pMessageQueue->pInput++ = *pItems++;

  027ad	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  027b0	8b 1f		 mov	 ebx, DWORD PTR [edi]
  027b2	03 fa		 add	 edi, edx
  027b4	89 19		 mov	 DWORD PTR [ecx], ebx
  027b6	8b 6e 04	 mov	 ebp, DWORD PTR [esi+4]
  027b9	03 ea		 add	 ebp, edx
  027bb	48		 dec	 eax
  027bc	89 6e 04	 mov	 DWORD PTR [esi+4], ebp
  027bf	75 ec		 jne	 SHORT $L71922

; 7442 : 
; 7443 :     /******************************************************************/
; 7444 :     /*  Update the input position.                                    */
; 7445 :     /******************************************************************/
; 7446 : 
; 7447 :     pMessageQueue->uiInputPosition += uiNumberToWrite;

  027c1	83 46 0c 03	 add	 DWORD PTR [esi+12], 3
$L71921:

; 7448 :   }
; 7449 : 
; 7450 :   /********************************************************************/
; 7451 :   /*  Update the count of items in the message queue.                 */
; 7452 :   /********************************************************************/
; 7453 : 
; 7454 :   pMessageQueue->uiCount += uiNumberToWrite;

  027c5	8b 5e 18	 mov	 ebx, DWORD PTR [esi+24]

; 7455 : 
; 7456 :   /********************************************************************/
; 7457 :   /*  Set the "Not Empty" condition.                                  */
; 7458 :   /********************************************************************/
; 7459 : 
; 7460 :   OP_SetEvent( pMessageQueue->hevNotEmpty );

  027c8	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  027cb	83 c3 03	 add	 ebx, 3
  027ce	52		 push	 edx
  027cf	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  027d2	e8 00 00 00 00	 call	 _OP_SetEvent

; 7461 : 
; 7462 :   /********************************************************************/
; 7463 :   /*  Free the message queue.                                         */
; 7464 :   /********************************************************************/
; 7465 : 
; 7466 :   OP_UnlockMutex( pMessageQueue->hmxMessageQueue );

  027d7	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  027da	50		 push	 eax
  027db	e8 00 00 00 00	 call	 _OP_UnlockMutex
  027e0	83 c4 08	 add	 esp, 8
  027e3	5f		 pop	 edi
  027e4	5e		 pop	 esi
  027e5	5d		 pop	 ebp
  027e6	5b		 pop	 ebx

; 7467 : 
; 7468 :   return;
; 7469 : }

  027e7	83 c4 0c	 add	 esp, 12			; 0000000cH
  027ea	c3		 ret	 0
_WriteMessageQueue ENDP
_pMessageQueue$ = 8
_paItem_0$ = 12
_paItem_1$ = 16
_paItem_2$ = 20
_aArray$ = -12
_ReadMessageQueue PROC NEAR

; 7508 : {

  027f0	83 ec 0c	 sub	 esp, 12			; 0000000cH
  027f3	53		 push	 ebx
  027f4	56		 push	 esi

; 7509 :   unsigned int uiI;
; 7510 :   unsigned int uiRemaining;
; 7511 :   unsigned int uiNumberToRead;
; 7512 :   ATYPE_T aArray[NUMBER_OF_ITEMS_IN_MESSAGE];
; 7513 :   LPATYPE_T pItems;
; 7514 : 
; 7515 :   /********************************************************************/
; 7516 :   /*  Block if the message queue is busy.                             */
; 7517 :   /********************************************************************/
; 7518 : 
; 7519 :   OP_LockMutex( pMessageQueue->hmxMessageQueue );

  027f5	8b 74 24 18	 mov	 esi, DWORD PTR _pMessageQueue$[esp+16]
  027f9	57		 push	 edi
  027fa	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  027fd	50		 push	 eax
  027fe	e8 00 00 00 00	 call	 _OP_LockMutex

; 7520 : 
; 7521 :   pItems = &aArray[0];
; 7522 : 
; 7523 :   /********************************************************************/
; 7524 :   /*  If there is no message in the message queue then block.         */
; 7525 :   /*  The ReadMessageQueue() function must own pMessageQueue->uiCount */
; 7526 :   /*  during the compare in case multiple threads are trying to read  */
; 7527 :   /*  the message queue at the same time.                             */
; 7528 :   /********************************************************************/
; 7529 : 
; 7530 :   uiNumberToRead = NUMBER_OF_ITEMS_IN_MESSAGE;
; 7531 : 
; 7532 :   while ( pMessageQueue->uiCount < uiNumberToRead )

  02803	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  02806	bb 03 00 00 00	 mov	 ebx, 3
  0280b	83 c4 04	 add	 esp, 4
  0280e	3b c3		 cmp	 eax, ebx
  02810	8d 7c 24 0c	 lea	 edi, DWORD PTR _aArray$[esp+24]
  02814	73 30		 jae	 SHORT $L71941
$L71940:

; 7533 :   {
; 7534 : 
; 7535 :     OP_ResetEvent( pMessageQueue->hevNotEmpty );

  02816	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  02819	51		 push	 ecx
  0281a	e8 00 00 00 00	 call	 _OP_ResetEvent

; 7536 : 
; 7537 :     OP_UnlockMutex( pMessageQueue->hmxMessageQueue );

  0281f	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  02822	52		 push	 edx
  02823	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 7538 : 
; 7539 :     OP_WaitForEvent( pMessageQueue->hevNotEmpty, OP_INFINITE );

  02828	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0282b	6a ff		 push	 -1
  0282d	50		 push	 eax
  0282e	e8 00 00 00 00	 call	 _OP_WaitForEvent

; 7540 : 
; 7541 :     OP_LockMutex( pMessageQueue->hmxMessageQueue );

  02833	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  02836	51		 push	 ecx
  02837	e8 00 00 00 00	 call	 _OP_LockMutex
  0283c	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0283f	83 c4 14	 add	 esp, 20			; 00000014H
  02842	3b c3		 cmp	 eax, ebx
  02844	72 d0		 jb	 SHORT $L71940
$L71941:

; 7542 :   }
; 7543 : 
; 7544 :   /********************************************************************/
; 7545 :   /*  There is a message in the queue.                                */
; 7546 :   /*  Test to see if the read of the data wraps around the queue.     */
; 7547 :   /********************************************************************/
; 7548 : 
; 7549 :   if (( pMessageQueue->uiOutputPosition + uiNumberToRead )
; 7550 :           > pMessageQueue->uiLength )

  02846	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  02849	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0284c	8d 51 03	 lea	 edx, DWORD PTR [ecx+3]
  0284f	3b d0		 cmp	 edx, eax
  02851	76 46		 jbe	 SHORT $L71942

; 7551 :   {
; 7552 :     /******************************************************************/
; 7553 :     /*  The read of the data will wrap around the circular queue.     */
; 7554 :     /******************************************************************/
; 7555 : 
; 7556 :     uiRemaining = pMessageQueue->uiLength - pMessageQueue->uiOutputPosition;

  02853	2b c1		 sub	 eax, ecx
  02855	55		 push	 ebp
  02856	8b d0		 mov	 edx, eax

; 7557 : 
; 7558 :     for ( uiI = 0; uiI < uiRemaining; uiI++ )

  02858	74 16		 je	 SHORT $L71945

; 7551 :   {
; 7552 :     /******************************************************************/
; 7553 :     /*  The read of the data will wrap around the circular queue.     */
; 7554 :     /******************************************************************/
; 7555 : 
; 7556 :     uiRemaining = pMessageQueue->uiLength - pMessageQueue->uiOutputPosition;

  0285a	8b ca		 mov	 ecx, edx
$L71943:

; 7559 :       *pItems++ = *pMessageQueue->pOutput++;

  0285c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0285f	83 c7 04	 add	 edi, 4
  02862	8b 28		 mov	 ebp, DWORD PTR [eax]
  02864	83 c0 04	 add	 eax, 4
  02867	89 6f fc	 mov	 DWORD PTR [edi-4], ebp
  0286a	49		 dec	 ecx
  0286b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0286e	75 ec		 jne	 SHORT $L71943
$L71945:

; 7560 : 
; 7561 :     pMessageQueue->pOutput = pMessageQueue->pStart;

  02870	8b 06		 mov	 eax, DWORD PTR [esi]

; 7562 : 
; 7563 :     for ( uiI = uiRemaining; uiI < uiNumberToRead; uiI++ )

  02872	3b d3		 cmp	 edx, ebx
  02874	89 46 08	 mov	 DWORD PTR [esi+8], eax
  02877	73 18		 jae	 SHORT $L71948
  02879	8b cb		 mov	 ecx, ebx
  0287b	2b ca		 sub	 ecx, edx
$L71946:

; 7564 :       *pItems++ = *pMessageQueue->pOutput++;

  0287d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  02880	83 c7 04	 add	 edi, 4
  02883	8b 28		 mov	 ebp, DWORD PTR [eax]
  02885	83 c0 04	 add	 eax, 4
  02888	89 6f fc	 mov	 DWORD PTR [edi-4], ebp
  0288b	49		 dec	 ecx
  0288c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0288f	75 ec		 jne	 SHORT $L71946
$L71948:

; 7565 : 
; 7566 :     /******************************************************************/
; 7567 :     /*  Update the output position in a circular fashion.             */
; 7568 :     /******************************************************************/
; 7569 : 
; 7570 :     pMessageQueue->uiOutputPosition = uiNumberToRead - uiRemaining;

  02891	2b da		 sub	 ebx, edx
  02893	5d		 pop	 ebp
  02894	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 7571 :   }
; 7572 :   else

  02897	eb 19		 jmp	 SHORT $L71949
$L71942:

; 7573 :   {
; 7574 :     /******************************************************************/
; 7575 :     /*  The read of the data will NOT wrap around the circular queue. */
; 7576 :     /******************************************************************/
; 7577 : 
; 7578 :     for ( uiI = 0; uiI < uiNumberToRead; uiI++ )

  02899	8b cb		 mov	 ecx, ebx
$L71950:

; 7579 :       *pItems++ = *pMessageQueue->pOutput++;

  0289b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0289e	83 c7 04	 add	 edi, 4
  028a1	8b 18		 mov	 ebx, DWORD PTR [eax]
  028a3	83 c0 04	 add	 eax, 4
  028a6	89 5f fc	 mov	 DWORD PTR [edi-4], ebx
  028a9	49		 dec	 ecx
  028aa	89 46 08	 mov	 DWORD PTR [esi+8], eax
  028ad	75 ec		 jne	 SHORT $L71950

; 7580 : 
; 7581 :     /******************************************************************/
; 7582 :     /*  Update the output position.                                   */
; 7583 :     /******************************************************************/
; 7584 : 
; 7585 :     pMessageQueue->uiOutputPosition += uiNumberToRead;

  028af	89 56 10	 mov	 DWORD PTR [esi+16], edx
$L71949:

; 7586 :   }
; 7587 : 
; 7588 :   /********************************************************************/
; 7589 :   /*  Update the count of items in the message queue.                 */
; 7590 :   /********************************************************************/
; 7591 : 
; 7592 :   pMessageQueue->uiCount -= uiNumberToRead;

  028b2	8b 5e 18	 mov	 ebx, DWORD PTR [esi+24]

; 7593 : 
; 7594 :   /********************************************************************/
; 7595 :   /*  Set the "Not Full" condition.                                   */
; 7596 :   /********************************************************************/
; 7597 : 
; 7598 :   OP_SetEvent( pMessageQueue->hevNotFull );

  028b5	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  028b8	83 c3 fd	 add	 ebx, -3			; fffffffdH
  028bb	51		 push	 ecx
  028bc	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  028bf	e8 00 00 00 00	 call	 _OP_SetEvent

; 7599 : 
; 7600 :   /********************************************************************/
; 7601 :   /*  Copy the data to the output arguments.                          */
; 7602 :   /********************************************************************/
; 7603 : 
; 7604 :   *paItem_0 = aArray[0];

  028c4	8b 54 24 24	 mov	 edx, DWORD PTR _paItem_0$[esp+24]
  028c8	8b 44 24 10	 mov	 eax, DWORD PTR _aArray$[esp+28]

; 7605 :   *paItem_1 = aArray[1];

  028cc	8b 4c 24 28	 mov	 ecx, DWORD PTR _paItem_1$[esp+24]
  028d0	89 02		 mov	 DWORD PTR [edx], eax
  028d2	8b 54 24 14	 mov	 edx, DWORD PTR _aArray$[esp+32]

; 7606 :   *paItem_2 = aArray[2];

  028d6	8b 44 24 2c	 mov	 eax, DWORD PTR _paItem_2$[esp+24]
  028da	89 11		 mov	 DWORD PTR [ecx], edx
  028dc	8b 4c 24 18	 mov	 ecx, DWORD PTR _aArray$[esp+36]
  028e0	89 08		 mov	 DWORD PTR [eax], ecx

; 7607 : 
; 7608 :   /******************************************************************/
; 7609 :   /*  Free the message queue.                                       */
; 7610 :   /******************************************************************/
; 7611 : 
; 7612 :   OP_UnlockMutex( pMessageQueue->hmxMessageQueue );

  028e2	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  028e5	52		 push	 edx
  028e6	e8 00 00 00 00	 call	 _OP_UnlockMutex
  028eb	83 c4 08	 add	 esp, 8
  028ee	5f		 pop	 edi
  028ef	5e		 pop	 esi
  028f0	5b		 pop	 ebx

; 7613 :   return;
; 7614 : }

  028f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  028f4	c3		 ret	 0
_ReadMessageQueue ENDP
_uiMessage$ = 12
_dwInstance$ = 16
_lParam1$ = 20
_WaveOutCallbackRoutine@20 PROC NEAR

; 7658 :   HPLAY_AUDIO_T pPlayAudio;
; 7659 :   switch ( uiMessage )
; 7660 :   {

  02900	8b 44 24 08	 mov	 eax, DWORD PTR _uiMessage$[esp-4]
  02904	2d bb 03 00 00	 sub	 eax, 955		; 000003bbH
  02909	74 1b		 je	 SHORT $L71969
  0290b	48		 dec	 eax
  0290c	74 0f		 je	 SHORT $L71979
  0290e	48		 dec	 eax
  0290f	75 33		 jne	 SHORT $L71966

; 7688 :     break;
; 7689 : 
; 7690 :   case MM_WOM_DONE:
; 7691 : 
; 7692 :     /******************************************************************/
; 7693 :     /*  Get the audio handle.                                         */
; 7694 :     /******************************************************************/
; 7695 : 
; 7696 : #ifdef OS_SIXTY_FOUR_BIT
; 7697 : 
; 7698 :     OP_LockMutex( pShm_t->hmxGlobalHandleList );
; 7699 :     pPlayAudio = pShm_t->ppGlobalHandleList[dwInstance];
; 7700 :     OP_UnlockMutex( pShm_t->hmxGlobalHandleList );
; 7701 : 
; 7702 : #else
; 7703 : 
; 7704 :     pPlayAudio = (HPLAY_AUDIO_T)dwInstance;
; 7705 : 
; 7706 : #endif
; 7707 : 
; 7708 :   /********************************************************************/
; 7709 :   /*  Determine the address of the WAVEHDR structure. For Windows,    */
; 7710 :   /*  the address is the same as the address written by the           */
; 7711 :   /*  waveOutWrite() function call that caused this MM_WOM_DONE       */
; 7712 :   /*  message. For the MME Server the returned WAVEHDR address is     */
; 7713 :   /*  different.                                                      */
; 7714 :   /********************************************************************/
; 7715 : 
; 7716 : #ifdef USE_MME_SERVER
; 7717 : 
; 7718 :     /******************************************************************/
; 7719 :     /*  MME BUG WORKAROUND. Because the MME server currently does not */
; 7720 :     /*  return wave headers in the correct order, it is necessary to  */
; 7721 :     /*  put wave headers on a list whenever a wave header is written  */
; 7722 :     /*  by the waveOutWrite() function. This list is accessed in the  */
; 7723 :     /*  wave output callback routine to determine the current header. */
; 7724 :     /******************************************************************/
; 7725 : 
; 7726 :     lParam1 =
; 7727 :       (LPARAM)pPlayAudio->ppWaveHdrInUseList[pPlayAudio->uiWaveHdrReadIndex];
; 7728 : 
; 7729 :     pPlayAudio->uiWaveHdrReadIndex++;
; 7730 : 
; 7731 :     if ( pPlayAudio->uiWaveHdrReadIndex >= MAXIMUM_BUFFERS_QUEUED )
; 7732 :     {
; 7733 :       pPlayAudio->uiWaveHdrReadIndex = 0;
; 7734 :     }
; 7735 : 
; 7736 : #endif
; 7737 : 
; 7738 :     /******************************************************************/
; 7739 :     /*  Put the MM_WOM_DONE message into the "play audio" message     */
; 7740 :     /*  queue. Send the address of the returned wave header.          */
; 7741 :     /******************************************************************/
; 7742 : 
; 7743 :     WriteMessageQueue( pShm_t->pGlobalPlayAudioMessageQueue,
; 7744 :                        (ATYPE_T)pPlayAudio,
; 7745 :                        (ATYPE_T)uiMessage,
; 7746 :                        (ATYPE_T)lParam1 );

  02911	8b 44 24 10	 mov	 eax, DWORD PTR _lParam1$[esp-4]
  02915	50		 push	 eax
  02916	68 bd 03 00 00	 push	 957			; 000003bdH

; 7747 : 
; 7748 :     break;

  0291b	eb 10		 jmp	 SHORT $L72181
$L71979:

; 7749 : 
; 7750 :   case MM_WOM_CLOSE:
; 7751 : 
; 7752 :     /******************************************************************/
; 7753 :     /*  Get the audio handle.                                         */
; 7754 :     /******************************************************************/
; 7755 : 
; 7756 : #ifdef OS_SIXTY_FOUR_BIT
; 7757 : 
; 7758 :     OP_LockMutex( pShm_t->hmxGlobalHandleList );
; 7759 :     pPlayAudio = pShm_t->ppGlobalHandleList[dwInstance];
; 7760 :     OP_UnlockMutex( pShm_t->hmxGlobalHandleList );
; 7761 : 
; 7762 : #else
; 7763 : 
; 7764 :     pPlayAudio = (HPLAY_AUDIO_T)dwInstance;
; 7765 : 
; 7766 : #endif
; 7767 : 
; 7768 :     /******************************************************************/
; 7769 :     /*  Put the MM_WOM_CLOSE message into the "play audio" message    */
; 7770 :     /*  queue.                                                        */
; 7771 :     /******************************************************************/
; 7772 : 
; 7773 :     WriteMessageQueue( pShm_t->pGlobalPlayAudioMessageQueue,
; 7774 :                        (ATYPE_T)pPlayAudio,
; 7775 :                        (ATYPE_T)uiMessage,
; 7776 :                        (ATYPE_T)0 );

  0291d	6a 00		 push	 0
  0291f	68 bc 03 00 00	 push	 956			; 000003bcH

; 7777 :     break;

  02924	eb 07		 jmp	 SHORT $L72181
$L71969:

; 7661 :   case MM_WOM_OPEN:
; 7662 : 
; 7663 :     /******************************************************************/
; 7664 :     /*  Get the audio handle.                                         */
; 7665 :     /******************************************************************/
; 7666 : 
; 7667 : #ifdef OS_SIXTY_FOUR_BIT
; 7668 : 
; 7669 :     OP_LockMutex( pShm_t->hmxGlobalHandleList );
; 7670 :     pPlayAudio = pShm_t->ppGlobalHandleList[dwInstance];
; 7671 :     OP_UnlockMutex( pShm_t->hmxGlobalHandleList );
; 7672 : 
; 7673 : #else
; 7674 : 
; 7675 :     pPlayAudio = (HPLAY_AUDIO_T)dwInstance;
; 7676 : 
; 7677 : #endif
; 7678 : 
; 7679 :     /******************************************************************/
; 7680 :     /*  Put the MM_WOM_OPEN message into the "play audio" message     */
; 7681 :     /*  queue.                                                        */
; 7682 :     /******************************************************************/
; 7683 : 
; 7684 :     WriteMessageQueue( pShm_t->pGlobalPlayAudioMessageQueue,
; 7685 :                        (ATYPE_T)pPlayAudio,
; 7686 :                        (ATYPE_T)uiMessage,
; 7687 :                        (ATYPE_T)0 );

  02926	6a 00		 push	 0
  02928	68 bb 03 00 00	 push	 955			; 000003bbH
$L72181:
  0292d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  02933	8b 4c 24 14	 mov	 ecx, DWORD PTR _dwInstance$[esp+4]
  02937	51		 push	 ecx
  02938	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0293b	50		 push	 eax
  0293c	e8 00 00 00 00	 call	 _WriteMessageQueue
  02941	83 c4 10	 add	 esp, 16			; 00000010H
$L71966:

; 7778 : 
; 7779 :   default:
; 7780 : 
; 7781 :     break;
; 7782 :   }
; 7783 : 
; 7784 :   return;
; 7785 : }

  02944	c2 14 00	 ret	 20			; 00000014H
_WaveOutCallbackRoutine@20 ENDP
_TEXT	ENDS
PUBLIC	_PA_DoSync
_TEXT	SEGMENT
_pPlayAudio$ = 8
_PA_DoSync PROC NEAR

; 7794 : 	// tek 19jun97 we do nothing if we're not working to a device..
; 7795 : 	if (pPlayAudio == NULL)

  02950	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  02954	85 c0		 test	 eax, eax
  02956	74 2a		 je	 SHORT $L71994

; 7796 : 		return;
; 7797 : 
; 7798 : 	  // if there are audio samples to
; 7799 : 	  // play, and the audio device isn't playing them, then start
; 7800 : 	  // the audio device.
; 7801 : #ifdef AUD_DEBUG
; 7802 :   {
; 7803 : 	  // tek 12nov97 corrected as part of the BATS508 edits
; 7804 : 		  char  szTemp[256]="";
; 7805 : 		  sprintf(szTemp,"DoSync at %08lu\n",
; 7806 : 			  timeGetTime()
; 7807 : 			  );	  
; 7808 : 		  OutputDebugString(szTemp);
; 7809 :   }
; 7810 : #endif //AUD_DEBUG
; 7811 :   {
; 7812 :     // tek 19nov97 restructured this logic..
; 7813 :     // if we have something to do..
; 7814 :     if (pPlayAudio->pPlayAudioRing->iQueueCount)

  02958	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  0295e	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  02961	85 d2		 test	 edx, edx
  02963	74 1d		 je	 SHORT $L71994

; 7815 : 		  {
; 7816 : 			  // if we own the device, just do it.
; 7817 : 			  if ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )

  02965	f6 40 3c 01	 test	 BYTE PTR [eax+60], 1
  02969	74 0a		 je	 SHORT $L71992

; 7818 : 			  {
; 7819 : 			 StartAudioPlaying(pPlayAudio);

  0296b	50		 push	 eax
  0296c	e8 00 00 00 00	 call	 _StartAudioPlaying
  02971	83 c4 04	 add	 esp, 4

; 7828 : 				  }
; 7829 : 			  }
; 7830 : 		  } // if we have something to do..
; 7831 : 	  }
; 7832 : 
; 7833 : }

  02974	c3		 ret	 0
$L71992:

; 7820 : 			  }
; 7821 : 			  else // we don't own the device..
; 7822 : 			  {
; 7823 : 				  // if the device is running, do this. if not, it is up to the
; 7824 : 				  // timer thread to start things.
; 7825 : 				  if (AUDIO_DEVICE_ACTIVE == pPlayAudio->dwAudioDeviceState)

  02975	83 78 34 02	 cmp	 DWORD PTR [eax+52], 2
  02979	75 07		 jne	 SHORT $L71994

; 7826 : 				  {
; 7827 : 					StartAudioPlaying(pPlayAudio);

  0297b	50		 push	 eax
  0297c	e8 00 00 00 00	 call	 _StartAudioPlaying
  02981	59		 pop	 ecx
$L71994:

; 7828 : 				  }
; 7829 : 			  }
; 7830 : 		  } // if we have something to do..
; 7831 : 	  }
; 7832 : 
; 7833 : }

  02982	c3		 ret	 0
_PA_DoSync ENDP
_TEXT	ENDS
PUBLIC	_PA_GetBytesPerSecond
_TEXT	SEGMENT
_pPlayAudio$ = 8
_PA_GetBytesPerSecond PROC NEAR

; 7840 : 	return(pPlayAudio->pWaveFormat->nAvgBytesPerSec);

  02990	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  02994	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  0299a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 7841 : }

  0299d	c3		 ret	 0
_PA_GetBytesPerSecond ENDP
_TEXT	ENDS
END
