	TITLE	D:\work\Product\dapi\src\Ph\ph_syl.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_ascky_check
PUBLIC	_common_affixes
PUBLIC	_syl_vowels
PUBLIC	_syl_cons
_DATA	SEGMENT
_ascky_check DB	00H
	DB	069H
	DB	049H
	DB	065H
	DB	045H
	DB	040H
	DB	061H
	DB	041H
	DB	057H
	DB	05eH
	DB	063H
	DB	06fH
	DB	04fH
	DB	055H
	DB	075H
	DB	052H
	DB	059H
	DB	078H
	DB	07cH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	077H
	DB	079H
	DB	072H
	DB	06cH
	DB	068H
	DB	00H
	DB	00H
	DB	06dH
	DB	06eH
	DB	047H
	DB	04cH
	DB	00H
	DB	04eH
	DB	066H
	DB	076H
	DB	054H
	DB	044H
	DB	073H
	DB	07aH
	DB	053H
	DB	05aH
	DB	070H
	DB	062H
	DB	074H
	DB	064H
	DB	06bH
	DB	067H
	DB	026H
	DB	051H
	DB	071H
	DB	043H
	DB	04aH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+1
_common_affixes DD FLAT:$SG71335
	DD	FLAT:$SG71336
	DD	FLAT:$SG71337
	DD	FLAT:$SG71338
	DD	FLAT:$SG71339
	DD	FLAT:$SG71340
	DD	FLAT:$SG71341
	DD	FLAT:$SG71342
	DD	FLAT:$SG71343
	DD	FLAT:$SG71344
	DD	FLAT:$SG71345
	DD	FLAT:$SG71346
	DD	FLAT:$SG71347
	DD	FLAT:$SG71348
	DD	FLAT:$SG71349
	DD	FLAT:$SG71350
	DD	FLAT:$SG71351
	DD	FLAT:$SG71352
	DD	FLAT:$SG71353
	DD	FLAT:$SG71354
	DD	FLAT:$SG71355
	DD	FLAT:$SG71356
	DD	FLAT:$SG71357
	DD	FLAT:$SG71358
	DD	FLAT:$SG71359
	DD	FLAT:$SG71360
	DD	FLAT:$SG71361
	DD	FLAT:$SG71362
	DD	FLAT:$SG71363
	DD	FLAT:$SG71364
	DD	FLAT:$SG71365
	DD	FLAT:$SG71366
	DD	FLAT:$SG71367
	DD	FLAT:$SG71368
	DD	FLAT:$SG71369
	DD	FLAT:$SG71370
	DD	FLAT:$SG71371
	DD	FLAT:$SG71372
	DD	FLAT:$SG71373
	DD	FLAT:$SG71374
	DD	FLAT:$SG71375
	DD	FLAT:$SG71376
	DD	FLAT:$SG71377
	DD	FLAT:$SG71378
	DD	FLAT:$SG71379
	DD	FLAT:$SG71380
	DD	FLAT:$SG71381
	DD	FLAT:$SG71382
	DD	FLAT:$SG71383
	DD	FLAT:$SG71384
	DD	FLAT:$SG71385
	DD	FLAT:$SG71386
	DD	FLAT:$SG71387
	DD	FLAT:$SG71388
	DD	FLAT:$SG71389
	DD	FLAT:$SG71390
	DD	FLAT:$SG71391
	DD	FLAT:$SG71392
	DD	FLAT:$SG71393
	DD	FLAT:$SG71394
	DD	FLAT:$SG71395
	DD	FLAT:$SG71396
	DD	FLAT:$SG71397
	DD	FLAT:$SG71398
	DD	FLAT:$SG71399
	DD	FLAT:$SG71400
	DD	FLAT:$SG71401
	DD	FLAT:$SG71402
	DD	FLAT:$SG71403
	DD	FLAT:$SG71404
	DD	FLAT:$SG71405
	DD	FLAT:$SG71406
	DD	FLAT:$SG71407
	DD	FLAT:$SG71408
	DD	FLAT:$SG71409
	DD	FLAT:$SG71410
	DD	00H
_syl_vowels DB	'a@AeEiIoOuU^WRc|xLN', 00H
_syl_cons DD	FLAT:$SG71413
	DD	FLAT:$SG71414
	DD	FLAT:$SG71415
	DD	FLAT:$SG71416
	DD	FLAT:$SG71417
	DD	FLAT:$SG71418
	DD	FLAT:$SG71419
	DD	FLAT:$SG71420
	DD	FLAT:$SG71421
	DD	FLAT:$SG71422
	DD	FLAT:$SG71423
	DD	FLAT:$SG71424
	DD	FLAT:$SG71425
	DD	FLAT:$SG71426
	DD	FLAT:$SG71427
	DD	FLAT:$SG71428
	DD	FLAT:$SG71429
	DD	FLAT:$SG71430
	DD	FLAT:$SG71431
	DD	FLAT:$SG71432
	DD	FLAT:$SG71433
	DD	FLAT:$SG71434
	DD	FLAT:$SG71435
	DD	FLAT:$SG71436
	DD	FLAT:$SG71437
	DD	FLAT:$SG71438
	DD	FLAT:$SG71439
	DD	FLAT:$SG71440
	DD	FLAT:$SG71441
	DD	FLAT:$SG71442
	DD	FLAT:$SG71443
	DD	FLAT:$SG71444
	DD	FLAT:$SG71445
	DD	FLAT:$SG71446
	DD	FLAT:$SG71447
	DD	FLAT:$SG71448
	DD	FLAT:$SG71449
	DD	FLAT:$SG71450
	DD	FLAT:$SG71451
	DD	FLAT:$SG71452
	DD	FLAT:$SG71453
	DD	FLAT:$SG71454
	DD	FLAT:$SG71455
	DD	FLAT:$SG71456
	DD	FLAT:$SG71457
	DD	FLAT:$SG71458
	DD	FLAT:$SG71459
	DD	FLAT:$SG71460
	DD	FLAT:$SG71461
	DD	FLAT:$SG71462
	DD	FLAT:$SG71463
	DD	FLAT:$SG71464
	DD	FLAT:$SG71465
	DD	FLAT:$SG71466
	DD	FLAT:$SG71467
	DD	FLAT:$SG71468
	DD	FLAT:$SG71469
	DD	FLAT:$SG71470
	DD	FLAT:$SG71471
	DD	FLAT:$SG71472
	DD	00H
$SG71335 DB	'sElvz', 00H
	ORG $+2
$SG71336 DB	'kwIst', 00H
	ORG $+2
$SG71337 DB	'flEks', 00H
	ORG $+2
$SG71338 DB	'sfir', 00H
	ORG $+3
$SG71339 DB	'stAn', 00H
	ORG $+3
$SG71340 DB	'gr@f', 00H
	ORG $+3
$SG71341 DB	'ples', 00H
	ORG $+3
$SG71342 DB	'plen', 00H
	ORG $+3
$SG71343 DB	'skop', 00H
	ORG $+3
$SG71344 DB	'baks', 00H
	ORG $+3
$SG71345 DB	'ston', 00H
	ORG $+3
$SG71346 DB	'wRT', 00H
$SG71347 DB	'lxnd', 00H
	ORG $+3
$SG71348 DB	'l@nd', 00H
	ORG $+3
$SG71349 DB	'k@st', 00H
	ORG $+3
$SG71350 DB	'fI|S', 00H
	ORG $+3
$SG71351 DB	'h@nd', 00H
	ORG $+3
$SG71352 DB	'yard', 00H
	ORG $+3
$SG71353 DB	'kcpf', 00H
	ORG $+3
$SG71354 DB	'mxnt', 00H
	ORG $+3
$SG71355 DB	'mEnt', 00H
	ORG $+3
$SG71356 DB	'sElf', 00H
	ORG $+3
$SG71357 DB	'st@t', 00H
	ORG $+3
$SG71358 DB	'SI|p', 00H
	ORG $+3
$SG71359 DB	'sAt', 00H
$SG71360 DB	'vIl', 00H
$SG71361 DB	'b@k', 00H
$SG71362 DB	'bot', 00H
$SG71363 DB	'lAf', 00H
$SG71364 DB	'lAk', 00H
$SG71365 DB	'pAp', 00H
$SG71366 DB	'wck', 00H
$SG71367 DB	'wcS', 00H
$SG71368 DB	'wUd', 00H
$SG71369 DB	'wRk', 00H
$SG71370 DB	'kek', 00H
$SG71371 DB	'bcl', 00H
$SG71372 DB	'bEl', 00H
$SG71373 DB	'del', 00H
$SG71374 DB	'hIl', 00H
$SG71375 DB	'hol', 00H
$SG71376 DB	'hUd', 00H
$SG71377 DB	'l|s', 00H
$SG71378 DB	'm@n', 00H
$SG71379 DB	'mxn', 00H
$SG71380 DB	'mor', 00H
$SG71381 DB	'nEk', 00H
$SG71382 DB	'n|s', 00H
$SG71383 DB	'Sap', 00H
$SG71384 DB	'Z|n', 00H
$SG71385 DB	'S|n', 00H
$SG71386 DB	'tel', 00H
$SG71387 DB	'tin', 00H
$SG71388 DB	'tAm', 00H
$SG71389 DB	'wRd', 00H
$SG71390 DB	'wer', 00H
$SG71391 DB	'wIl', 00H
$SG71392 DB	'wAz', 00H
$SG71393 DB	'b@g', 00H
$SG71394 DB	'k@p', 00H
$SG71395 DB	'kar', 00H
$SG71396 DB	'k@t', 00H
$SG71397 DB	'dxm', 00H
$SG71398 DB	'flA', 00H
$SG71399 DB	'mxn', 00H
$SG71400 DB	'm@n', 00H
$SG71401 DB	'mEn', 00H
$SG71402 DB	'n^t', 00H
$SG71403 DB	'pad', 00H
$SG71404 DB	'ek', 00H
	ORG $+1
$SG71405 DB	'bO', 00H
	ORG $+1
$SG71406 DB	'de', 00H
	ORG $+1
$SG71407 DB	'fL', 00H
	ORG $+1
$SG71408 DB	'|J', 00H
	ORG $+1
$SG71409 DB	'sc', 00H
	ORG $+1
$SG71410 DB	'we', 00H
	ORG $+1
$SG71413 DB	'spl', 00H
$SG71414 DB	'spr', 00H
$SG71415 DB	'str', 00H
$SG71416 DB	'skw', 00H
$SG71417 DB	'skl', 00H
$SG71418 DB	'skr', 00H
$SG71419 DB	' Sm', 00H
$SG71420 DB	' SL', 00H
$SG71421 DB	'pl', 00H
	ORG $+1
$SG71422 DB	'pr', 00H
	ORG $+1
$SG71423 DB	'bl', 00H
	ORG $+1
$SG71424 DB	'br', 00H
	ORG $+1
$SG71425 DB	'fl', 00H
	ORG $+1
$SG71426 DB	'fr', 00H
	ORG $+1
$SG71427 DB	'tw', 00H
	ORG $+1
$SG71428 DB	'tr', 00H
	ORG $+1
$SG71429 DB	'dw', 00H
	ORG $+1
$SG71430 DB	'dr', 00H
	ORG $+1
$SG71431 DB	'Tw', 00H
	ORG $+1
$SG71432 DB	'Tr', 00H
	ORG $+1
$SG71433 DB	'kw', 00H
	ORG $+1
$SG71434 DB	'kl', 00H
	ORG $+1
$SG71435 DB	'kr', 00H
	ORG $+1
$SG71436 DB	'gw', 00H
	ORG $+1
$SG71437 DB	'gl', 00H
	ORG $+1
$SG71438 DB	'gr', 00H
	ORG $+1
$SG71439 DB	'sw', 00H
	ORG $+1
$SG71440 DB	'sl', 00H
	ORG $+1
$SG71441 DB	'sp', 00H
	ORG $+1
$SG71442 DB	'st', 00H
	ORG $+1
$SG71443 DB	'sk', 00H
	ORG $+1
$SG71444 DB	'sm', 00H
	ORG $+1
$SG71445 DB	'sn', 00H
	ORG $+1
$SG71446 DB	'Sw', 00H
	ORG $+1
$SG71447 DB	'Sl', 00H
	ORG $+1
$SG71448 DB	'Sr', 00H
	ORG $+1
$SG71449 DB	' Y', 00H
	ORG $+1
$SG71450 DB	'y', 00H
	ORG $+2
$SG71451 DB	'f', 00H
	ORG $+2
$SG71452 DB	't', 00H
	ORG $+2
$SG71453 DB	'd', 00H
	ORG $+2
$SG71454 DB	'T', 00H
	ORG $+2
$SG71455 DB	'k', 00H
	ORG $+2
$SG71456 DB	'g', 00H
	ORG $+2
$SG71457 DB	's', 00H
	ORG $+2
$SG71458 DB	'S', 00H
	ORG $+2
$SG71459 DB	'p', 00H
	ORG $+2
$SG71460 DB	'w', 00H
	ORG $+2
$SG71461 DB	'l', 00H
	ORG $+2
$SG71462 DB	'r', 00H
	ORG $+2
$SG71463 DB	'h', 00H
	ORG $+2
$SG71464 DB	'D', 00H
	ORG $+2
$SG71465 DB	'z', 00H
	ORG $+2
$SG71466 DB	'Z', 00H
	ORG $+2
$SG71467 DB	'C', 00H
	ORG $+2
$SG71468 DB	'J', 00H
	ORG $+2
$SG71469 DB	'n', 00H
	ORG $+2
$SG71470 DB	'm', 00H
	ORG $+2
$SG71471 DB	'v', 00H
	ORG $+2
$SG71472 DB	'b', 00H
_DATA	ENDS
PUBLIC	_saysyllable
_TEXT	SEGMENT
_phTTS$ = 8
_temp_symbols$ = -1860
_temp_user_durs$ = -1240
_temp_user_f0$ = -620
_saysyllable PROC NEAR

; 192  : {

  00000	81 ec 48 07 00
	00		 sub	 esp, 1864		; 00000748H

; 193  : 
; 194  : 	int i, j, k;   /* MVP int m; was unreferenced varaible */
; 195  : 	int last, old_tot;
; 196  : 	short temp_symbols[NPHON_MAX + SAFETY + 2];
; 197  : 	short temp_user_durs[NPHON_MAX + SAFETY + 2];
; 198  : 	short temp_user_f0[NPHON_MAX + SAFETY + 2];
; 199  : 
; 200  : 	//PKSD_T pKsd_t = phTTS->pKernelShareData;
; 201  : 	PDPH_T pDph_t = phTTS->pPHThreadData;

  00006	8b 84 24 4c 07
	00 00		 mov	 eax, DWORD PTR _phTTS$[esp+1860]
  0000d	53		 push	 ebx
  0000e	55		 push	 ebp
  0000f	56		 push	 esi
  00010	8b 68 18	 mov	 ebp, DWORD PTR [eax+24]
  00013	57		 push	 edi

; 202  : 
; 203  : 	/* 
; 204  : 	 *  then, save the clause ...
; 205  : 	 */
; 206  : 
; 207  : 	for (i = 0; i <= pDph_t->nsymbtot; i++)

  00014	0f bf bd 82 17
	00 00		 movsx	 edi, WORD PTR [ebp+6018]
  0001b	85 ff		 test	 edi, edi
  0001d	89 7c 24 10	 mov	 DWORD PTR -1864+[esp+1880], edi
  00021	7c 57		 jl	 SHORT $L71485
  00023	8b b5 88 17 00
	00		 mov	 esi, DWORD PTR [ebp+6024]
  00029	8d 44 3f 02	 lea	 eax, DWORD PTR [edi+edi+2]
  0002d	8b c8		 mov	 ecx, eax
  0002f	8d bc 24 ec 04
	00 00		 lea	 edi, DWORD PTR _temp_user_f0$[esp+1880]
  00036	d1 e9		 shr	 ecx, 1
  00038	d1 e9		 shr	 ecx, 1
  0003a	f3 a5		 rep movsd
  0003c	8b 95 84 17 00
	00		 mov	 edx, DWORD PTR [ebp+6020]
  00042	8d 9d 26 15 00
	00		 lea	 ebx, DWORD PTR [ebp+5414]
  00048	13 c9		 adc	 ecx, ecx
  0004a	66 f3 a5	 rep movsw

; 208  : 	{
; 209  : 		temp_symbols[i] = pDph_t->symbols[i];
; 210  : 		temp_user_durs[i] = pDph_t->user_durs[i];

  0004d	8b c8		 mov	 ecx, eax
  0004f	8b f2		 mov	 esi, edx
  00051	d1 e9		 shr	 ecx, 1
  00053	8d bc 24 80 02
	00 00		 lea	 edi, DWORD PTR _temp_user_durs$[esp+1880]
  0005a	d1 e9		 shr	 ecx, 1
  0005c	f3 a5		 rep movsd
  0005e	13 c9		 adc	 ecx, ecx
  00060	66 f3 a5	 rep movsw
  00063	8b c8		 mov	 ecx, eax
  00065	8b f3		 mov	 esi, ebx
  00067	d1 e9		 shr	 ecx, 1
  00069	8d 7c 24 14	 lea	 edi, DWORD PTR _temp_symbols$[esp+1880]
  0006d	d1 e9		 shr	 ecx, 1
  0006f	f3 a5		 rep movsd
  00071	13 c9		 adc	 ecx, ecx
  00073	66 f3 a5	 rep movsw
  00076	8b 7c 24 10	 mov	 edi, DWORD PTR -1864+[esp+1880]
$L71485:

; 211  : 		temp_user_f0[i] = pDph_t->user_f0[i];
; 212  : 	}
; 213  : 
; 214  : 	old_tot = pDph_t->nsymbtot;
; 215  : 	last = 0;

  0007a	33 f6		 xor	 esi, esi

; 216  : 	while (last <= old_tot)

  0007c	85 ff		 test	 edi, edi
  0007e	0f 8c 1a 01 00
	00		 jl	 $L71490
  00084	eb 04		 jmp	 SHORT $L71489
$L71697:
  00086	8b 7c 24 10	 mov	 edi, DWORD PTR -1864+[esp+1880]
$L71489:

; 219  : 		last += 1;

  0008a	46		 inc	 esi

; 220  : 		for (j = 0; (temp_symbols[j + last] != WBOUND) && (j + last < old_tot) && (j < 256); j++)

  0008b	33 c9		 xor	 ecx, ecx
  0008d	66 83 7c 74 14
	6f		 cmp	 WORD PTR _temp_symbols$[esp+esi*2+1880], 111 ; 0000006fH
  00093	c7 85 d8 27 00
	00 6f 00 00 00	 mov	 DWORD PTR [ebp+10200], 111 ; 0000006fH
  0009d	8d 44 74 14	 lea	 eax, DWORD PTR _temp_symbols$[esp+esi*2+1880]
  000a1	74 27		 je	 SHORT $L71493

; 217  : 	{
; 218  : 		pDph_t->phone_struct[0] = WBOUND;

  000a3	8d 95 dc 27 00
	00		 lea	 edx, DWORD PTR [ebp+10204]
$L71491:

; 220  : 		for (j = 0; (temp_symbols[j + last] != WBOUND) && (j + last < old_tot) && (j < 256); j++)

  000a9	8d 1c 31	 lea	 ebx, DWORD PTR [ecx+esi]
  000ac	3b df		 cmp	 ebx, edi
  000ae	7d 1a		 jge	 SHORT $L71493
  000b0	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  000b6	7d 12		 jge	 SHORT $L71493

; 221  : 			pDph_t->phone_struct[j + 1] = temp_symbols[j + last];

  000b8	0f bf 18	 movsx	 ebx, WORD PTR [eax]
  000bb	83 c0 02	 add	 eax, 2
  000be	89 1a		 mov	 DWORD PTR [edx], ebx
  000c0	41		 inc	 ecx
  000c1	83 c2 04	 add	 edx, 4
  000c4	66 83 38 6f	 cmp	 WORD PTR [eax], 111	; 0000006fH
  000c8	75 df		 jne	 SHORT $L71491
$L71493:

; 222  : 		pDph_t->phone_struct[j + 1] = 0;

  000ca	33 db		 xor	 ebx, ebx

; 223  : 		/* 
; 224  : 		 *  syllabify it, and return the length of syllable_struct ...
; 225  : 		 */
; 226  : 		k = ph_syllab (pDph_t, j);

  000cc	51		 push	 ecx
  000cd	55		 push	 ebp
  000ce	89 9c 8d dc 27
	00 00		 mov	 DWORD PTR [ebp+ecx*4+10204], ebx
  000d5	e8 00 00 00 00	 call	 _ph_syllab
  000da	8b f8		 mov	 edi, eax

; 227  : 		pDph_t->syllable_struct[k] = 0;
; 228  : 		/* 
; 229  : 		 *  now, after the comma, start breaking the word up ....
; 230  : 		 */
; 231  : 		syl_clause_init (pDph_t);

  000dc	55		 push	 ebp
  000dd	89 9c bd d8 23
	00 00		 mov	 DWORD PTR [ebp+edi*4+9176], ebx
  000e4	e8 00 00 00 00	 call	 _syl_clause_init
  000e9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 232  : 		while (--k >= 0)

  000ec	4f		 dec	 edi
  000ed	0f 88 87 00 00
	00		 js	 $L71496
  000f3	8d 9c bd d8 23
	00 00		 lea	 ebx, DWORD PTR [ebp+edi*4+9176]
  000fa	47		 inc	 edi
$L71495:

; 233  : 		{
; 234  : 			/* 
; 235  : 			 *  count up the sounded phones ...
; 236  : 			 */
; 237  : 			if (ascky_check[temp_symbols[last]])

  000fb	66 8b 44 74 14	 mov	 ax, WORD PTR _temp_symbols$[esp+esi*2+1880]
  00100	0f bf c8	 movsx	 ecx, ax
  00103	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR _ascky_check[ecx]
  00109	84 d2		 test	 dl, dl
  0010b	74 07		 je	 SHORT $L71497

; 238  : 				pDph_t->nphone++;

  0010d	66 ff 85 d0 23
	00 00		 inc	 WORD PTR [ebp+9168]
$L71497:

; 239  : 			if (pDph_t->syllable_struct[k] == SBOUND)

  00114	83 3b 6c	 cmp	 DWORD PTR [ebx], 108	; 0000006cH
  00117	75 12		 jne	 SHORT $L71498

; 240  : 				speak_syllable (phTTS);

  00119	8b 94 24 5c 07
	00 00		 mov	 edx, DWORD PTR _phTTS$[esp+1876]
  00120	52		 push	 edx
  00121	e8 00 00 00 00	 call	 _speak_syllable
  00126	83 c4 04	 add	 esp, 4

; 241  : 			else

  00129	eb 49		 jmp	 SHORT $L71499
$L71498:

; 242  : 			{
; 243  : 				pDph_t->symbols[pDph_t->nsymbtot] = temp_symbols[last];

  0012b	0f bf 8d 82 17
	00 00		 movsx	 ecx, WORD PTR [ebp+6018]
  00132	66 89 84 4d 26
	15 00 00	 mov	 WORD PTR [ebp+ecx*2+5414], ax

; 244  : 				pDph_t->user_durs[pDph_t->nsymbtot] = temp_user_durs[last];

  0013a	8b 85 84 17 00
	00		 mov	 eax, DWORD PTR [ebp+6020]
  00140	0f bf 95 82 17
	00 00		 movsx	 edx, WORD PTR [ebp+6018]
  00147	66 8b 8c 74 80
	02 00 00	 mov	 cx, WORD PTR _temp_user_durs$[esp+esi*2+1880]
  0014f	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 245  : 				pDph_t->user_f0[pDph_t->nsymbtot++] = temp_user_f0[last++];

  00153	8b 85 88 17 00
	00		 mov	 eax, DWORD PTR [ebp+6024]
  00159	0f bf 95 82 17
	00 00		 movsx	 edx, WORD PTR [ebp+6018]
  00160	66 8b 8c 74 ec
	04 00 00	 mov	 cx, WORD PTR _temp_user_f0$[esp+esi*2+1880]
  00168	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
  0016c	66 ff 85 82 17
	00 00		 inc	 WORD PTR [ebp+6018]
  00173	46		 inc	 esi
$L71499:
  00174	83 eb 04	 sub	 ebx, 4
  00177	4f		 dec	 edi
  00178	75 81		 jne	 SHORT $L71495
$L71496:

; 246  : 			}
; 247  : 		}
; 248  : 		/* 
; 249  : 		 *  take care of the last accumulated syllable ...
; 250  : 		 */
; 251  : 		if (pDph_t->nsymbtot > 1)

  0017a	66 83 bd 82 17
	00 00 01	 cmp	 WORD PTR [ebp+6018], 1
  00182	7e 10		 jle	 SHORT $L71500

; 252  : 			speak_syllable (phTTS);

  00184	8b 94 24 5c 07
	00 00		 mov	 edx, DWORD PTR _phTTS$[esp+1876]
  0018b	52		 push	 edx
  0018c	e8 00 00 00 00	 call	 _speak_syllable
  00191	83 c4 04	 add	 esp, 4
$L71500:
  00194	3b 74 24 10	 cmp	 esi, DWORD PTR -1864+[esp+1880]
  00198	0f 8e e8 fe ff
	ff		 jle	 $L71697
$L71490:
  0019e	5f		 pop	 edi
  0019f	5e		 pop	 esi
  001a0	5d		 pop	 ebp
  001a1	5b		 pop	 ebx

; 253  : 	}
; 254  : }

  001a2	81 c4 48 07 00
	00		 add	 esp, 1864		; 00000748H
  001a8	c3		 ret	 0
_saysyllable ENDP
_TEXT	ENDS
PUBLIC	_syl_find_vowel
_TEXT	SEGMENT
_ph$ = 8
_off$ = -4
_syl_find_vowel PROC NEAR

; 107  : {

  001b0	51		 push	 ecx

; 123  : 	for (i = 0; ph[i] != WBOUND; i--)

  001b1	8b 44 24 08	 mov	 eax, DWORD PTR _ph$[esp]
  001b5	53		 push	 ebx
  001b6	55		 push	 ebp
  001b7	33 d2		 xor	 edx, edx
  001b9	66 8b 08	 mov	 cx, WORD PTR [eax]
  001bc	56		 push	 esi
  001bd	66 83 f9 6f	 cmp	 cx, 111			; 0000006fH
  001c1	57		 push	 edi
  001c2	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _off$[esp+20], 1
  001ca	74 60		 je	 SHORT $L71511

; 108  : #ifdef SPANISH
; 109  : 	int	vc, hit = 0;
; 110  : #endif
; 111  : #if defined ENGLISH_US || defined ENGLISH_UK// NAL warning removal
; 112  : 	int l;
; 113  : #endif
; 114  : #ifndef FRENCH
; 115  : 	int j;
; 116  : #endif
; 117  : 	int i, off;
; 118  : #ifdef ENGLISH
; 119  : 	int k=0;
; 120  : #endif
; 121  : 
; 122  : 	off = 1;

  001cc	8b e8		 mov	 ebp, eax
$L71509:

; 124  : 	{
; 125  : 		if (ascky_check[ph[i] & PVALUE])

  001ce	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  001d4	8a 99 00 00 00
	00		 mov	 bl, BYTE PTR _ascky_check[ecx]
  001da	84 db		 test	 bl, bl
  001dc	74 37		 je	 SHORT $L71515

; 126  : 		{
; 127  : #ifdef ENGLISH_US
; 128  : 			for (j = 0; syl_vowels[j] != 0; j++)

  001de	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _syl_vowels
  001e4	84 c9		 test	 cl, cl
  001e6	74 2d		 je	 SHORT $L71515

; 129  : 			{
; 130  : 				if (ascky_check[ph[i] & PVALUE] == syl_vowels[j])

  001e8	66 8b 7d 00	 mov	 di, WORD PTR [ebp]
  001ec	8b f7		 mov	 esi, edi
  001ee	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH
  001f4	8a 9e 00 00 00
	00		 mov	 bl, BYTE PTR _ascky_check[esi]
  001fa	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_syl_vowels
$L71513:
  001ff	3a d9		 cmp	 bl, cl
  00201	74 32		 je	 SHORT $L71704

; 137  : 						return (off);
; 138  : 					return (off);
; 139  : 				}
; 140  : 				if (ph[i] == US_YU)

  00203	66 83 ff 10	 cmp	 di, 16			; 00000010H
  00207	0f 84 c4 00 00
	00		 je	 $L71705
  0020d	8a 4e 01	 mov	 cl, BYTE PTR [esi+1]
  00210	46		 inc	 esi
  00211	84 c9		 test	 cl, cl
  00213	75 ea		 jne	 SHORT $L71513
$L71515:

; 144  : 						return (off);
; 145  : 					else
; 146  : 						return (0);
; 147  : 				}
; 148  : 			}
; 149  : #endif
; 150  : #ifdef ENGLISH_UK
; 151  : 			for (j = 0; syl_vowels[j] != 0; j++)
; 152  : 			{
; 153  : 				if (ascky_check[ph[i] & PVALUE] == syl_vowels[j])
; 154  : 				{
; 155  : 					for (k = 1; ascky_check[ph[i - k] & PVALUE] == 0 && ph[i - k] != WBOUND; k++);
; 156  : 					if (ph[i - k] != UKP_YU)
; 157  : 						return (off);
; 158  : 					for (l = k + 1; ascky_check[ph[i - l] & PVALUE] == 0 && ph[i - l] != WBOUND; l++);
; 159  : 					if (ph[i - l] != WBOUND)
; 160  : 						return (off);
; 161  : 					return (off);
; 162  : 				}
; 163  : 				if (ph[i] == UKP_YU)
; 164  : 				{
; 165  : 					for (k += 1; ascky_check[ph[i - k] & PVALUE] == 0 && ph[i - k] != WBOUND; k++);
; 166  : 					if (ph[i - k] != WBOUND)
; 167  : 						return (off);
; 168  : 					else
; 169  : 						return (0);
; 170  : 				}
; 171  : 			}
; 172  : #endif
; 173  : #ifdef SPANISH
; 174  : 			for (j = 0; syl_vowels[j] != 0; j++)
; 175  : 			{
; 176  : 				if (ascky_check[ph[i] & PVALUE] == syl_vowels[j])
; 177  : 				{
; 178  : 					/* 
; 179  : 					 * any vowel before i and u or Y and W become one.
; 180  : 					 * also if this or any vowel preceed by iuYW it also 
; 181  : 					 * becomes one vowel as with ia ana iai 
; 182  : 					 */
; 183  : 					vc = i;
; 184  : 					if (ph[i] == 3 || (ph[i] >= 5 && ph[i] <= 7))
; 185  : 					{
; 186  : 						if (ascky_check[ph[i - 1] & PVALUE] == syl_vowels[j])
; 187  : 							hit = 1;
; 188  : 						vc--;
; 189  : 					}
; 190  : 					vc--;
; 191  : 					while (ph[vc] >= BLOCK_RULES && ph[vc] < SBOUND)
; 192  : 					{
; 193  : 						hit = 1;
; 194  : 						vc--;
; 195  : 					}
; 196  : 					/* if preceeded by 'i' || 'u' ||'y' || 'w' */
; 197  : 					if (ph[vc] == 3 || (ph[vc] >= 5 && ph[vc] <= 7))
; 198  : 					{
; 199  : 						hit = 1;
; 200  : 					}
; 201  : 					if (hit)
; 202  : 						off += i - vc;
; 203  : 					return (off);
; 204  : 				}
; 205  : 			}
; 206  : #endif
; 207  : 		}
; 208  : 		off += 1;

  00215	8b 4c 24 10	 mov	 ecx, DWORD PTR _off$[esp+20]
  00219	83 ed 02	 sub	 ebp, 2
  0021c	41		 inc	 ecx
  0021d	4a		 dec	 edx
  0021e	89 4c 24 10	 mov	 DWORD PTR _off$[esp+20], ecx
  00222	66 8b 4d 00	 mov	 cx, WORD PTR [ebp]
  00226	66 83 f9 6f	 cmp	 cx, 111			; 0000006fH
  0022a	75 a2		 jne	 SHORT $L71509
$L71511:
  0022c	5f		 pop	 edi
  0022d	5e		 pop	 esi
  0022e	5d		 pop	 ebp

; 209  : 	}
; 210  : 	return (0);

  0022f	66 33 c0	 xor	 ax, ax
  00232	5b		 pop	 ebx

; 211  : }

  00233	59		 pop	 ecx
  00234	c3		 ret	 0
$L71704:

; 131  : 				{
; 132  : 					for (k = 1; ascky_check[ph[i - k] & PVALUE] == 0 && ph[i - k] != WBOUND; k++);

  00235	66 8b 4c 50 fe	 mov	 cx, WORD PTR [eax+edx*2-2]
  0023a	bf 01 00 00 00	 mov	 edi, 1
  0023f	8b f1		 mov	 esi, ecx
  00241	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH
  00247	8a 9e 00 00 00
	00		 mov	 bl, BYTE PTR _ascky_check[esi]
  0024d	84 db		 test	 bl, bl
  0024f	75 23		 jne	 SHORT $L71519
  00251	8d 74 50 fe	 lea	 esi, DWORD PTR [eax+edx*2-2]
$L71517:
  00255	66 83 f9 6f	 cmp	 cx, 111			; 0000006fH
  00259	74 19		 je	 SHORT $L71519
  0025b	66 8b 4e fe	 mov	 cx, WORD PTR [esi-2]
  0025f	83 ee 02	 sub	 esi, 2
  00262	8b d9		 mov	 ebx, ecx
  00264	47		 inc	 edi
  00265	81 e3 ff 00 00
	00		 and	 ebx, 255		; 000000ffH
  0026b	80 bb 00 00 00
	00 00		 cmp	 BYTE PTR _ascky_check[ebx], 0
  00272	74 e1		 je	 SHORT $L71517
$L71519:

; 133  : 					if (ph[i - k] != US_YU)

  00274	8b ca		 mov	 ecx, edx
  00276	2b cf		 sub	 ecx, edi
  00278	66 83 3c 48 10	 cmp	 WORD PTR [eax+ecx*2], 16 ; 00000010H
  0027d	74 0b		 je	 SHORT $L71520

; 134  : 						return (off);

  0027f	66 8b 44 24 10	 mov	 ax, WORD PTR _off$[esp+20]
  00284	5f		 pop	 edi
  00285	5e		 pop	 esi
  00286	5d		 pop	 ebp
  00287	5b		 pop	 ebx

; 211  : }

  00288	59		 pop	 ecx
  00289	c3		 ret	 0
$L71520:

; 135  : 					for (l = k + 1; ascky_check[ph[i - l] & PVALUE] == 0 && ph[i - l] != WBOUND; l++);

  0028a	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  0028d	2b d6		 sub	 edx, esi
  0028f	66 8b 0c 50	 mov	 cx, WORD PTR [eax+edx*2]
  00293	8d 14 50	 lea	 edx, DWORD PTR [eax+edx*2]
  00296	8b c1		 mov	 eax, ecx
  00298	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0029d	8a 98 00 00 00
	00		 mov	 bl, BYTE PTR _ascky_check[eax]
  002a3	84 db		 test	 bl, bl
  002a5	75 1f		 jne	 SHORT $L71523
$L71521:
  002a7	66 83 f9 6f	 cmp	 cx, 111			; 0000006fH
  002ab	74 19		 je	 SHORT $L71523
  002ad	66 8b 4a fe	 mov	 cx, WORD PTR [edx-2]
  002b1	83 ea 02	 sub	 edx, 2
  002b4	8b c1		 mov	 eax, ecx
  002b6	46		 inc	 esi
  002b7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002bc	8a 98 00 00 00
	00		 mov	 bl, BYTE PTR _ascky_check[eax]
  002c2	84 db		 test	 bl, bl
  002c4	74 e1		 je	 SHORT $L71521
$L71523:

; 136  : 					if (ph[i - l] != WBOUND)

  002c6	66 8b 44 24 10	 mov	 ax, WORD PTR _off$[esp+20]
  002cb	5f		 pop	 edi
  002cc	5e		 pop	 esi
  002cd	5d		 pop	 ebp
  002ce	5b		 pop	 ebx

; 211  : }

  002cf	59		 pop	 ecx
  002d0	c3		 ret	 0
$L71705:

; 141  : 				{
; 142  : 					for (k += 1; ascky_check[ph[i - k] & PVALUE] == 0 && ph[i - k] != WBOUND; k++);

  002d1	66 8b 4c 50 fe	 mov	 cx, WORD PTR [eax+edx*2-2]
  002d6	bf 01 00 00 00	 mov	 edi, 1
  002db	8b f1		 mov	 esi, ecx
  002dd	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH
  002e3	8a 9e 00 00 00
	00		 mov	 bl, BYTE PTR _ascky_check[esi]
  002e9	84 db		 test	 bl, bl
  002eb	75 23		 jne	 SHORT $L71528
  002ed	8d 74 50 fe	 lea	 esi, DWORD PTR [eax+edx*2-2]
$L71526:
  002f1	66 83 f9 6f	 cmp	 cx, 111			; 0000006fH
  002f5	74 19		 je	 SHORT $L71528
  002f7	66 8b 4e fe	 mov	 cx, WORD PTR [esi-2]
  002fb	83 ee 02	 sub	 esi, 2
  002fe	8b d9		 mov	 ebx, ecx
  00300	47		 inc	 edi
  00301	81 e3 ff 00 00
	00		 and	 ebx, 255		; 000000ffH
  00307	80 bb 00 00 00
	00 00		 cmp	 BYTE PTR _ascky_check[ebx], 0
  0030e	74 e1		 je	 SHORT $L71526
$L71528:

; 143  : 					if (ph[i - k] != WBOUND)

  00310	2b d7		 sub	 edx, edi
  00312	8b 4c 24 10	 mov	 ecx, DWORD PTR _off$[esp+20]
  00316	5f		 pop	 edi
  00317	5e		 pop	 esi
  00318	66 8b 04 50	 mov	 ax, WORD PTR [eax+edx*2]
  0031c	5d		 pop	 ebp
  0031d	66 2d 6f 00	 sub	 ax, 111			; 0000006fH
  00321	5b		 pop	 ebx
  00322	66 f7 d8	 neg	 ax
  00325	1b c0		 sbb	 eax, eax
  00327	23 c1		 and	 eax, ecx

; 211  : }

  00329	59		 pop	 ecx
  0032a	c3		 ret	 0
_syl_find_vowel ENDP
_TEXT	ENDS
PUBLIC	_syl_find_cons
_TEXT	SEGMENT
_ph$ = 8
_syl_find_cons PROC NEAR

; 226  : {

  00330	53		 push	 ebx

; 227  : 	short                   *tp;
; 228  : 	int                     i= 0 , j = 0, len = 0;
; 229  : 
; 230  : #ifdef ENGLISH_US
; 231  : 	tp = ph;
; 232  : 	if (*tp-- == 26+ (PFUSA<<PSFONT))

  00331	8b 5c 24 08	 mov	 ebx, DWORD PTR _ph$[esp]
  00335	55		 push	 ebp
  00336	56		 push	 esi
  00337	66 81 3b 1a 1e	 cmp	 WORD PTR [ebx], 7706	; 00001e1aH
  0033c	57		 push	 edi
  0033d	75 29		 jne	 SHORT $L71541

; 233  : 	{
; 234  : 		for (j = 0; syl_vowels[j] != 0; j++)

  0033f	a0 00 00 00 00	 mov	 al, BYTE PTR _syl_vowels
  00344	84 c0		 test	 al, al
  00346	74 20		 je	 SHORT $L71541

; 235  : 		{
; 236  : 			if (ascky_check[(*tp) & PVALUE] == syl_vowels[j])

  00348	8a 4b fe	 mov	 cl, BYTE PTR [ebx-2]
  0034b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00351	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR _ascky_check[ecx]
  00357	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_syl_vowels
$L71539:
  0035c	3a d0		 cmp	 dl, al
  0035e	74 60		 je	 SHORT $L71718
  00360	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00363	41		 inc	 ecx
  00364	84 c0		 test	 al, al
  00366	75 f4		 jne	 SHORT $L71539
$L71541:

; 237  : 			{
; 238  : 				return (0);
; 239  : 			}
; 240  : 		}
; 241  : 	}
; 242  : #endif
; 243  : #ifdef ENGLISH_UK
; 244  : 	tp = ph;
; 245  : 	if (*tp-- == 26 + (PFUK << PSFONT))
; 246  : 	{
; 247  : 		for (j = 0; syl_vowels[j] != 0; j++)
; 248  : 		{
; 249  : 			if (ascky_check[(*tp) & PVALUE] == syl_vowels[j])
; 250  : 			{
; 251  : 				return (0);
; 252  : 			}
; 253  : 		}
; 254  : 	}
; 255  : #endif
; 256  : #ifdef FRENCH
; 257  : 	tp = ph;
; 258  : 	if (*tp-- == 26 + (PFFR<<PSFONT))
; 259  : 	{
; 260  : 		for (j = 0; syl_vowels[j] != 0; j++)
; 261  : 		{
; 262  : 			if (ascky_check[(*tp) & PVALUE] == syl_vowels[j])
; 263  : 			{
; 264  : 				return (0);
; 265  : 			}
; 266  : 		}
; 267  : 	}
; 268  : #endif
; 269  : 	for (j = 0; syl_cons[j]; j++)

  00368	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _syl_cons
  0036e	85 ff		 test	 edi, edi
  00370	74 4e		 je	 SHORT $L71718
  00372	bd 00 00 00 00	 mov	 ebp, OFFSET FLAT:_syl_cons
$L71543:

; 270  : 	{
; 271  : 		for (i = 0; syl_cons[j][i]; i++);

  00377	8a 07		 mov	 al, BYTE PTR [edi]
  00379	33 c9		 xor	 ecx, ecx
  0037b	84 c0		 test	 al, al
  0037d	74 0c		 je	 SHORT $L71548
  0037f	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
$L71546:
  00382	8a 44 0f 01	 mov	 al, BYTE PTR [edi+ecx+1]
  00386	41		 inc	 ecx
  00387	84 c0		 test	 al, al
  00389	75 f7		 jne	 SHORT $L71546
$L71548:

; 272  : /* printf(" %s ons %d \n",syl_cons[j],len); */
; 273  : 		len = i;

  0038b	8b c1		 mov	 eax, ecx

; 274  : 		tp = ph;

  0038d	8b f3		 mov	 esi, ebx
$L71550:

; 276  : 		{
; 277  : 			if (ascky_check[(*tp) & PVALUE] == 0)

  0038f	8a 16		 mov	 dl, BYTE PTR [esi]
  00391	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00397	8a 92 00 00 00
	00		 mov	 dl, BYTE PTR _ascky_check[edx]
  0039d	84 d2		 test	 dl, dl
  0039f	75 06		 jne	 SHORT $L71552

; 278  : 			{
; 279  : #ifdef ENGLISH_US
; 280  : 				tp++;

  003a1	83 c6 02	 add	 esi, 2

; 281  : #endif      
; 282  : #ifdef ENGLISH_UK
; 283  : 				tp++;
; 284  : #endif      
; 285  : #ifdef SPANISH
; 286  : 				tp--;
; 287  : #endif
; 288  : #ifdef FRENCH
; 289  : 				tp++;
; 290  : #endif 
; 291  : 				len += 1;

  003a4	40		 inc	 eax

; 292  : 
; 293  : 			}
; 294  : 			else

  003a5	eb 09		 jmp	 SHORT $L71553
$L71552:

; 295  : 			{
; 296  : /* 
; 297  :  * printf("asc = %c \n",syl_cons[j][i-1]);
; 298  :  * 
; 299  :  * printf("look at   %d %c \n",ascky_check[*tp],ascky_check[*tp]); 
; 300  :  */
; 301  : 				--i;

  003a7	49		 dec	 ecx

; 302  : 				if (syl_cons[j][i] != ascky_check[(*tp) & PVALUE])

  003a8	38 14 0f	 cmp	 BYTE PTR [edi+ecx], dl
  003ab	75 09		 jne	 SHORT $L71719

; 303  : 				{
; 304  : 					tp--;
; 305  : 					break;
; 306  : 				}
; 307  : 				tp--;

  003ad	83 ee 02	 sub	 esi, 2
$L71553:

; 308  : 			}
; 309  : 			if (i == 0)

  003b0	85 c9		 test	 ecx, ecx
  003b2	74 0f		 je	 SHORT $L71533

; 275  : 		while (true)

  003b4	eb d9		 jmp	 SHORT $L71550
$L71719:

; 237  : 			{
; 238  : 				return (0);
; 239  : 			}
; 240  : 		}
; 241  : 	}
; 242  : #endif
; 243  : #ifdef ENGLISH_UK
; 244  : 	tp = ph;
; 245  : 	if (*tp-- == 26 + (PFUK << PSFONT))
; 246  : 	{
; 247  : 		for (j = 0; syl_vowels[j] != 0; j++)
; 248  : 		{
; 249  : 			if (ascky_check[(*tp) & PVALUE] == syl_vowels[j])
; 250  : 			{
; 251  : 				return (0);
; 252  : 			}
; 253  : 		}
; 254  : 	}
; 255  : #endif
; 256  : #ifdef FRENCH
; 257  : 	tp = ph;
; 258  : 	if (*tp-- == 26 + (PFFR<<PSFONT))
; 259  : 	{
; 260  : 		for (j = 0; syl_vowels[j] != 0; j++)
; 261  : 		{
; 262  : 			if (ascky_check[(*tp) & PVALUE] == syl_vowels[j])
; 263  : 			{
; 264  : 				return (0);
; 265  : 			}
; 266  : 		}
; 267  : 	}
; 268  : #endif
; 269  : 	for (j = 0; syl_cons[j]; j++)

  003b6	8b 7d 04	 mov	 edi, DWORD PTR [ebp+4]
  003b9	83 c5 04	 add	 ebp, 4
  003bc	85 ff		 test	 edi, edi
  003be	75 b7		 jne	 SHORT $L71543
$L71718:

; 310  : 				return (len);
; 311  : 		}
; 312  : 	}
; 313  : 	return (0);

  003c0	66 33 c0	 xor	 ax, ax
$L71533:
  003c3	5f		 pop	 edi
  003c4	5e		 pop	 esi
  003c5	5d		 pop	 ebp
  003c6	5b		 pop	 ebx

; 314  : }

  003c7	c3		 ret	 0
_syl_find_cons ENDP
_TEXT	ENDS
PUBLIC	_logsyllable
EXTRN	_TextToSpeechErrorHandler:NEAR
EXTRN	__imp__fprintf:NEAR
EXTRN	__imp__EnterCriticalSection@4:NEAR
EXTRN	__imp__LeaveCriticalSection@4:NEAR
_DATA	SEGMENT
	ORG $+2
$SG71596 DB	'[:syll ', 00H
$SG71599 DB	'[:syll ', 00H
$SG71604 DB	'%c', 00H
	ORG $+1
$SG71607 DB	'%c', 00H
	ORG $+1
$SG71609 DB	' --> ', 00H
	ORG $+2
$SG71612 DB	' --> ', 00H
	ORG $+2
$SG71617 DB	'%c', 00H
	ORG $+1
$SG71620 DB	'%c', 00H
	ORG $+1
$SG71622 DB	']', 0aH, 00H
	ORG $+1
$SG71625 DB	']', 0aH, 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_i$ = -12
_k$ = -4
_pDph_t$ = -8
_logsyllable PROC NEAR

; 407  : {

  003d0	83 ec 0c	 sub	 esp, 12			; 0000000cH
  003d3	53		 push	 ebx

; 408  : 	int                     i, j, k;
; 409  : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  003d4	8b 5c 24 14	 mov	 ebx, DWORD PTR _phTTS$[esp+12]
  003d8	56		 push	 esi
  003d9	57		 push	 edi

; 410  : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 411  : 
; 412  : #ifndef MSDOS
; 413  : /* 
; 414  :  * LPTTS_HANDLE_T phTTS;
; 415  :  * 
; 416  :  * phTTS = TextToSpeechGetHandle(); 
; 417  :  */
; 418  : #endif
; 419  : 
; 420  : #ifdef WIN32
; 421  : 	EnterCriticalSection (phTTS->pcsLogFile);

  003da	8b 83 c8 00 00
	00		 mov	 eax, DWORD PTR [ebx+200]
  003e0	8b 7b 18	 mov	 edi, DWORD PTR [ebx+24]
  003e3	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  003e6	50		 push	 eax
  003e7	89 7c 24 14	 mov	 DWORD PTR _pDph_t$[esp+28], edi
  003eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 422  : #endif
; 423  : #if defined (__osf__) || defined (__linux__)
; 424  : 	/* GL 04/21/1997  change this as the latest OSF code */
; 425  : 	/*ToggleLogfileMutex (MUTEX_RESERVE);*/
; 426  : 	OP_LockMutex( phTTS->pcsLogFile );
; 427  : #endif
; 428  : 
; 429  : 	for (i = 1; i < pDph_t->nsymbtot; i++)

  003f1	b8 01 00 00 00	 mov	 eax, 1
  003f6	66 39 87 82 17
	00 00		 cmp	 WORD PTR [edi+6018], ax
  003fd	89 44 24 0c	 mov	 DWORD PTR _i$[esp+24], eax
  00401	0f 8e 8d 02 00
	00		 jle	 $L71591
  00407	55		 push	 ebp

; 464  : 			}
; 465  : 		}
; 466  : #endif
; 467  : 
; 468  : #ifdef MSDOS
; 469  : 
; 470  : 		/* 
; 471  : 		 * the table pKsd_t->ascky should be change 
; 472  : 		 * when a [:lang ] commad is engountered 
; 473  : 		 */
; 474  : 		for (j = 0; pDph_t->phone_struct[j]; j++)
; 475  : 		{
; 476  : #ifndef MSDOS
; 477  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 478  : 			fprintf(pKsd_t->dbglog, pKsd_t->ascky[pDph_t->phone_struct[j] & PVALUE]);
; 479  : #endif // #ifndef MSDOS
; 480  : 		printf ("%c", pKsd_t->ascky[pDph_t->phone_struct[j] & PVALUE]);	
; 481  : 		}
; 482  : 
; 483  : #ifndef MSDOS
; 484  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 485  : 			fprintf(pKsd_t->dbglog," --> ");
; 486  : #endif // #ifndef MSDOS
; 487  : 		printf (" --> ");
; 488  : 
; 489  : 		while (--k)
; 490  : 		{
; 491  : #ifndef MSDOS
; 492  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 493  : 			fprintf(pKsd_t->dbglog,"%c", pKsd_t->ascky[pDph_t->syllable_struct[k] & PVALUE]);
; 494  : #endif // #ifndef MSDOS
; 495  : 		printf ("%c", pKsd_t->ascky[pDph_t->syllable_struct[k] & PVALUE]);
; 496  : 		}
; 497  : #ifndef MSDOS
; 498  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 499  : 			fprintf(pKsd_t->dbglog,"%c","]\n");
; 500  : #endif // #ifndef MSDOS
; 501  : 		printf ("]\n");
; 502  : 		SIGNAL_PRINT;
; 503  : #else //#ifdef MSDOS
; 504  : 
; 505  : 		for (j = 0; pDph_t->phone_struct[j]; j++)

  00408	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__fprintf
$L71589:
  0040e	8b 4c 24 10	 mov	 ecx, DWORD PTR _i$[esp+28]
  00412	c7 87 d8 27 00
	00 6f 00 00 00	 mov	 DWORD PTR [edi+10200], 111 ; 0000006fH
  0041c	33 c0		 xor	 eax, eax
  0041e	66 83 bc 4f 26
	15 00 00 6f	 cmp	 WORD PTR [edi+ecx*2+5414], 111 ; 0000006fH
  00427	8d 8c 4f 26 15
	00 00		 lea	 ecx, DWORD PTR [edi+ecx*2+5414]
  0042e	74 3e		 je	 SHORT $L71594

; 430  : 	{
; 431  : 		/* 
; 432  : 		 *  first, isolate phonemic words ...
; 433  : 		 */
; 434  : 		pDph_t->phone_struct[0] = WBOUND;

  00430	8d 97 dc 27 00
	00		 lea	 edx, DWORD PTR [edi+10204]
  00436	eb 04		 jmp	 SHORT $L71592
$L71733:
  00438	8b 7c 24 14	 mov	 edi, DWORD PTR _pDph_t$[esp+28]
$L71592:

; 435  : 		for (j = 0; pDph_t->symbols[i + j] != WBOUND && i + j < pDph_t->nsymbtot && j < 256; j++)

  0043c	8b 5c 24 10	 mov	 ebx, DWORD PTR _i$[esp+28]
  00440	0f bf bf 82 17
	00 00		 movsx	 edi, WORD PTR [edi+6018]
  00447	03 d8		 add	 ebx, eax
  00449	3b df		 cmp	 ebx, edi
  0044b	7d 19		 jge	 SHORT $L71734
  0044d	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00452	7d 12		 jge	 SHORT $L71734

; 436  : 		{
; 437  : 			pDph_t->phone_struct[j + 1] = pDph_t->symbols[i + j];

  00454	0f bf 39	 movsx	 edi, WORD PTR [ecx]
  00457	83 c1 02	 add	 ecx, 2
  0045a	89 3a		 mov	 DWORD PTR [edx], edi
  0045c	40		 inc	 eax
  0045d	83 c2 04	 add	 edx, 4
  00460	66 83 39 6f	 cmp	 WORD PTR [ecx], 111	; 0000006fH
  00464	75 d2		 jne	 SHORT $L71733
$L71734:

; 435  : 		for (j = 0; pDph_t->symbols[i + j] != WBOUND && i + j < pDph_t->nsymbtot && j < 256; j++)

  00466	8b 5c 24 20	 mov	 ebx, DWORD PTR _phTTS$[esp+24]
  0046a	8b 7c 24 14	 mov	 edi, DWORD PTR _pDph_t$[esp+28]
$L71594:

; 438  : 		}
; 439  : 		j++;    
; 440  : 		pDph_t->phone_struct[j]=0;
; 441  : 		pDph_t->phone_struct[j+1]=0;
; 442  : 		i += j - 1;

  0046e	8b 54 24 10	 mov	 edx, DWORD PTR _i$[esp+28]
  00472	40		 inc	 eax
  00473	33 c9		 xor	 ecx, ecx

; 443  : 		k = ph_syllab (pDph_t, j);

  00475	50		 push	 eax
  00476	89 8c 87 d8 27
	00 00		 mov	 DWORD PTR [edi+eax*4+10200], ecx
  0047d	89 8c 87 dc 27
	00 00		 mov	 DWORD PTR [edi+eax*4+10204], ecx
  00484	8d 4c 02 ff	 lea	 ecx, DWORD PTR [edx+eax-1]
  00488	57		 push	 edi
  00489	89 4c 24 18	 mov	 DWORD PTR _i$[esp+36], ecx
  0048d	e8 00 00 00 00	 call	 _ph_syllab
  00492	89 44 24 20	 mov	 DWORD PTR _k$[esp+36], eax

; 444  : #ifdef MSDOS
; 445  : 		WAIT_PRINT;
; 446  : 		printf ("[:syll ");
; 447  : #else
; 448  : #ifdef PRINTFDEBUG
; 449  : 		printf ("[:syll ");
; 450  : #endif
; 451  : 		
; 452  : #ifndef MSDOS
; 453  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/

  00496	8b 86 44 06 00
	00		 mov	 eax, DWORD PTR [esi+1604]
  0049c	83 c4 08	 add	 esp, 8
  0049f	85 c0		 test	 eax, eax
  004a1	74 0b		 je	 SHORT $L71595

; 454  : 			fprintf(pKsd_t->dbglog,"[:syll ");

  004a3	68 00 00 00 00	 push	 OFFSET FLAT:$SG71596
  004a8	50		 push	 eax
  004a9	ff d5		 call	 ebp
  004ab	83 c4 08	 add	 esp, 8
$L71595:

; 455  : #endif
; 456  : 		
; 457  : 		if (pKsd_t->logflag & LOG_SYLLABLES)

  004ae	f6 86 c4 03 00
	00 10		 test	 BYTE PTR [esi+964], 16	; 00000010H
  004b5	74 22		 je	 SHORT $L71598

; 458  : 		{
; 459  : 			if (fprintf (phTTS->pLogFile, "[:syll ") < 0)

  004b7	8b 93 9c 00 00
	00		 mov	 edx, DWORD PTR [ebx+156]
  004bd	68 00 00 00 00	 push	 OFFSET FLAT:$SG71599
  004c2	52		 push	 edx
  004c3	ff d5		 call	 ebp
  004c5	83 c4 08	 add	 esp, 8
  004c8	85 c0		 test	 eax, eax
  004ca	7d 0d		 jge	 SHORT $L71598

; 460  : 			{
; 461  : 				TextToSpeechErrorHandler (phTTS,
; 462  : 										  ERROR_WRITING_FILE,
; 463  : 										  0L);

  004cc	6a 00		 push	 0
  004ce	6a 05		 push	 5
  004d0	53		 push	 ebx
  004d1	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  004d6	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71598:

; 464  : 			}
; 465  : 		}
; 466  : #endif
; 467  : 
; 468  : #ifdef MSDOS
; 469  : 
; 470  : 		/* 
; 471  : 		 * the table pKsd_t->ascky should be change 
; 472  : 		 * when a [:lang ] commad is engountered 
; 473  : 		 */
; 474  : 		for (j = 0; pDph_t->phone_struct[j]; j++)
; 475  : 		{
; 476  : #ifndef MSDOS
; 477  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 478  : 			fprintf(pKsd_t->dbglog, pKsd_t->ascky[pDph_t->phone_struct[j] & PVALUE]);
; 479  : #endif // #ifndef MSDOS
; 480  : 		printf ("%c", pKsd_t->ascky[pDph_t->phone_struct[j] & PVALUE]);	
; 481  : 		}
; 482  : 
; 483  : #ifndef MSDOS
; 484  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 485  : 			fprintf(pKsd_t->dbglog," --> ");
; 486  : #endif // #ifndef MSDOS
; 487  : 		printf (" --> ");
; 488  : 
; 489  : 		while (--k)
; 490  : 		{
; 491  : #ifndef MSDOS
; 492  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 493  : 			fprintf(pKsd_t->dbglog,"%c", pKsd_t->ascky[pDph_t->syllable_struct[k] & PVALUE]);
; 494  : #endif // #ifndef MSDOS
; 495  : 		printf ("%c", pKsd_t->ascky[pDph_t->syllable_struct[k] & PVALUE]);
; 496  : 		}
; 497  : #ifndef MSDOS
; 498  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 499  : 			fprintf(pKsd_t->dbglog,"%c","]\n");
; 500  : #endif // #ifndef MSDOS
; 501  : 		printf ("]\n");
; 502  : 		SIGNAL_PRINT;
; 503  : #else //#ifdef MSDOS
; 504  : 
; 505  : 		for (j = 0; pDph_t->phone_struct[j]; j++)

  004d9	8b 87 d8 27 00
	00		 mov	 eax, DWORD PTR [edi+10200]
  004df	85 c0		 test	 eax, eax
  004e1	74 7f		 je	 SHORT $L71602
  004e3	81 c7 d8 27 00
	00		 add	 edi, 10200		; 000027d8H
$L71600:

; 506  : 		{
; 507  : #ifdef PRINTFDEBUG
; 508  : 			printf ("%c", pKsd_t->ascky[pDph_t->phone_struct[j] & PVALUE]);
; 509  : #endif
; 510  : #ifndef MSDOS
; 511  : 			if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/

  004e9	8b 86 44 06 00
	00		 mov	 eax, DWORD PTR [esi+1604]
  004ef	85 c0		 test	 eax, eax
  004f1	74 23		 je	 SHORT $L71603

; 512  : 				fprintf(pKsd_t->dbglog,"%c", pKsd_t->ascky[pDph_t->phone_struct[j] & PVALUE]);

  004f3	8b 0f		 mov	 ecx, DWORD PTR [edi]
  004f5	8b 96 20 06 00
	00		 mov	 edx, DWORD PTR [esi+1568]
  004fb	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00501	33 db		 xor	 ebx, ebx
  00503	8a 1c 0a	 mov	 bl, BYTE PTR [edx+ecx]
  00506	53		 push	 ebx
  00507	68 00 00 00 00	 push	 OFFSET FLAT:$SG71604
  0050c	50		 push	 eax
  0050d	ff d5		 call	 ebp
  0050f	8b 5c 24 2c	 mov	 ebx, DWORD PTR _phTTS$[esp+36]
  00513	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71603:

; 513  : #endif // #ifndef MSDOS
; 514  : 
; 515  : 			if (pKsd_t->logflag & LOG_SYLLABLES)

  00516	f6 86 c4 03 00
	00 10		 test	 BYTE PTR [esi+964], 16	; 00000010H
  0051d	74 35		 je	 SHORT $L71601

; 516  : 			{
; 517  : 
; 518  : 
; 519  : 				if (fprintf (phTTS->pLogFile,
; 520  : 							 "%c", pKsd_t->ascky[pDph_t->phone_struct[j] & PVALUE]) < 0)

  0051f	8b 07		 mov	 eax, DWORD PTR [edi]
  00521	8b 8e 20 06 00
	00		 mov	 ecx, DWORD PTR [esi+1568]
  00527	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0052c	33 d2		 xor	 edx, edx
  0052e	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00531	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [ebx+156]
  00537	52		 push	 edx
  00538	68 00 00 00 00	 push	 OFFSET FLAT:$SG71607
  0053d	50		 push	 eax
  0053e	ff d5		 call	 ebp
  00540	83 c4 0c	 add	 esp, 12			; 0000000cH
  00543	85 c0		 test	 eax, eax
  00545	7d 0d		 jge	 SHORT $L71601

; 521  : 				{
; 522  : 					TextToSpeechErrorHandler (phTTS,
; 523  : 											  ERROR_WRITING_FILE,
; 524  : 											  0L);

  00547	6a 00		 push	 0
  00549	6a 05		 push	 5
  0054b	53		 push	 ebx
  0054c	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  00551	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71601:
  00554	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00557	83 c7 04	 add	 edi, 4
  0055a	85 c0		 test	 eax, eax
  0055c	75 8b		 jne	 SHORT $L71600

; 464  : 			}
; 465  : 		}
; 466  : #endif
; 467  : 
; 468  : #ifdef MSDOS
; 469  : 
; 470  : 		/* 
; 471  : 		 * the table pKsd_t->ascky should be change 
; 472  : 		 * when a [:lang ] commad is engountered 
; 473  : 		 */
; 474  : 		for (j = 0; pDph_t->phone_struct[j]; j++)
; 475  : 		{
; 476  : #ifndef MSDOS
; 477  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 478  : 			fprintf(pKsd_t->dbglog, pKsd_t->ascky[pDph_t->phone_struct[j] & PVALUE]);
; 479  : #endif // #ifndef MSDOS
; 480  : 		printf ("%c", pKsd_t->ascky[pDph_t->phone_struct[j] & PVALUE]);	
; 481  : 		}
; 482  : 
; 483  : #ifndef MSDOS
; 484  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 485  : 			fprintf(pKsd_t->dbglog," --> ");
; 486  : #endif // #ifndef MSDOS
; 487  : 		printf (" --> ");
; 488  : 
; 489  : 		while (--k)
; 490  : 		{
; 491  : #ifndef MSDOS
; 492  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 493  : 			fprintf(pKsd_t->dbglog,"%c", pKsd_t->ascky[pDph_t->syllable_struct[k] & PVALUE]);
; 494  : #endif // #ifndef MSDOS
; 495  : 		printf ("%c", pKsd_t->ascky[pDph_t->syllable_struct[k] & PVALUE]);
; 496  : 		}
; 497  : #ifndef MSDOS
; 498  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 499  : 			fprintf(pKsd_t->dbglog,"%c","]\n");
; 500  : #endif // #ifndef MSDOS
; 501  : 		printf ("]\n");
; 502  : 		SIGNAL_PRINT;
; 503  : #else //#ifdef MSDOS
; 504  : 
; 505  : 		for (j = 0; pDph_t->phone_struct[j]; j++)

  0055e	8b 7c 24 14	 mov	 edi, DWORD PTR _pDph_t$[esp+28]
$L71602:

; 525  : 				}
; 526  : 			}
; 527  : 		}
; 528  : 
; 529  : #ifdef PRINTFDEBUG
; 530  : 		printf (" --> ");
; 531  : #endif
; 532  : #ifndef MSDOS
; 533  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/

  00562	8b 86 44 06 00
	00		 mov	 eax, DWORD PTR [esi+1604]
  00568	85 c0		 test	 eax, eax
  0056a	74 0b		 je	 SHORT $L71608

; 534  : 				fprintf(pKsd_t->dbglog, " --> ");

  0056c	68 00 00 00 00	 push	 OFFSET FLAT:$SG71609
  00571	50		 push	 eax
  00572	ff d5		 call	 ebp
  00574	83 c4 08	 add	 esp, 8
$L71608:

; 535  : #endif// #ifndef MSDOS
; 536  : 		if (pKsd_t->logflag & LOG_SYLLABLES)

  00577	f6 86 c4 03 00
	00 10		 test	 BYTE PTR [esi+964], 16	; 00000010H
  0057e	74 22		 je	 SHORT $L71729

; 537  : 		{
; 538  : 
; 539  : 			if (fprintf (phTTS->pLogFile, " --> ") < 0)

  00580	8b 8b 9c 00 00
	00		 mov	 ecx, DWORD PTR [ebx+156]
  00586	68 00 00 00 00	 push	 OFFSET FLAT:$SG71612
  0058b	51		 push	 ecx
  0058c	ff d5		 call	 ebp
  0058e	83 c4 08	 add	 esp, 8
  00591	85 c0		 test	 eax, eax
  00593	7d 0d		 jge	 SHORT $L71729

; 540  : 			{
; 541  : 				TextToSpeechErrorHandler (phTTS,
; 542  : 										  ERROR_WRITING_FILE,
; 543  : 										  0L);

  00595	6a 00		 push	 0
  00597	6a 05		 push	 5
  00599	53		 push	 ebx
  0059a	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  0059f	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71729:

; 544  : 			}
; 545  : 		}
; 546  : 
; 547  : 		while (--k)

  005a2	8b 44 24 18	 mov	 eax, DWORD PTR _k$[esp+28]
  005a6	48		 dec	 eax
  005a7	89 44 24 18	 mov	 DWORD PTR _k$[esp+28], eax
  005ab	0f 84 8a 00 00
	00		 je	 $L71615
  005b1	8b d0		 mov	 edx, eax
  005b3	89 44 24 18	 mov	 DWORD PTR -4+[esp+28], eax
  005b7	8d bc 97 d8 23
	00 00		 lea	 edi, DWORD PTR [edi+edx*4+9176]
$L71614:

; 548  : 		{
; 549  : #ifdef PRINTFDEBUG
; 550  : 			printf ("%c", pKsd_t->ascky[pDph_t->syllable_struct[k] & PVALUE]);
; 551  : #endif
; 552  : #ifndef MSDOS
; 553  : 			if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/

  005be	8b 86 44 06 00
	00		 mov	 eax, DWORD PTR [esi+1604]
  005c4	85 c0		 test	 eax, eax
  005c6	74 23		 je	 SHORT $L71616

; 554  : 				fprintf(pKsd_t->dbglog,"%c", pKsd_t->ascky[pDph_t->syllable_struct[k] & PVALUE]);

  005c8	8b 0f		 mov	 ecx, DWORD PTR [edi]
  005ca	8b 96 20 06 00
	00		 mov	 edx, DWORD PTR [esi+1568]
  005d0	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  005d6	33 db		 xor	 ebx, ebx
  005d8	8a 1c 11	 mov	 bl, BYTE PTR [ecx+edx]
  005db	53		 push	 ebx
  005dc	68 00 00 00 00	 push	 OFFSET FLAT:$SG71617
  005e1	50		 push	 eax
  005e2	ff d5		 call	 ebp
  005e4	8b 5c 24 2c	 mov	 ebx, DWORD PTR _phTTS$[esp+36]
  005e8	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71616:

; 555  : #endif// #ifndef MSDOS
; 556  : 			if (pKsd_t->logflag & LOG_SYLLABLES)

  005eb	f6 86 c4 03 00
	00 10		 test	 BYTE PTR [esi+964], 16	; 00000010H
  005f2	74 35		 je	 SHORT $L71619

; 557  : 			{
; 558  : 				if (fprintf (phTTS->pLogFile,
; 559  : 							 "%c", pKsd_t->ascky[pDph_t->syllable_struct[k] & PVALUE]) < 0)

  005f4	8b 07		 mov	 eax, DWORD PTR [edi]
  005f6	8b 8e 20 06 00
	00		 mov	 ecx, DWORD PTR [esi+1568]
  005fc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00601	33 d2		 xor	 edx, edx
  00603	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  00606	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [ebx+156]
  0060c	52		 push	 edx
  0060d	68 00 00 00 00	 push	 OFFSET FLAT:$SG71620
  00612	50		 push	 eax
  00613	ff d5		 call	 ebp
  00615	83 c4 0c	 add	 esp, 12			; 0000000cH
  00618	85 c0		 test	 eax, eax
  0061a	7d 0d		 jge	 SHORT $L71619

; 560  : 				{
; 561  : 					TextToSpeechErrorHandler (phTTS,
; 562  : 											  ERROR_WRITING_FILE,
; 563  : 											  0L);

  0061c	6a 00		 push	 0
  0061e	6a 05		 push	 5
  00620	53		 push	 ebx
  00621	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  00626	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71619:
  00629	8b 44 24 18	 mov	 eax, DWORD PTR -4+[esp+28]
  0062d	83 ef 04	 sub	 edi, 4
  00630	48		 dec	 eax
  00631	89 44 24 18	 mov	 DWORD PTR -4+[esp+28], eax
  00635	75 87		 jne	 SHORT $L71614

; 544  : 			}
; 545  : 		}
; 546  : 
; 547  : 		while (--k)

  00637	8b 7c 24 14	 mov	 edi, DWORD PTR _pDph_t$[esp+28]
$L71615:

; 564  : 				}
; 565  : 			}
; 566  : 		}
; 567  : 
; 568  : #ifdef PRINTFDEBUG
; 569  : 		printf ("]\n");
; 570  : #endif
; 571  : #ifndef MSDOS
; 572  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/

  0063b	8b 86 44 06 00
	00		 mov	 eax, DWORD PTR [esi+1604]
  00641	85 c0		 test	 eax, eax
  00643	74 0b		 je	 SHORT $L71621

; 573  : 			fprintf(pKsd_t->dbglog,"]\n");

  00645	68 00 00 00 00	 push	 OFFSET FLAT:$SG71622
  0064a	50		 push	 eax
  0064b	ff d5		 call	 ebp
  0064d	83 c4 08	 add	 esp, 8
$L71621:

; 574  : #endif// #ifndef MSDOS
; 575  : 		if (pKsd_t->logflag & LOG_SYLLABLES)

  00650	f6 86 c4 03 00
	00 10		 test	 BYTE PTR [esi+964], 16	; 00000010H
  00657	74 22		 je	 SHORT $L71590

; 576  : 		{
; 577  : 			if (fprintf (phTTS->pLogFile, "]\n") < 0)

  00659	8b 8b 9c 00 00
	00		 mov	 ecx, DWORD PTR [ebx+156]
  0065f	68 00 00 00 00	 push	 OFFSET FLAT:$SG71625
  00664	51		 push	 ecx
  00665	ff d5		 call	 ebp
  00667	83 c4 08	 add	 esp, 8
  0066a	85 c0		 test	 eax, eax
  0066c	7d 0d		 jge	 SHORT $L71590

; 578  : 			{
; 579  : 				TextToSpeechErrorHandler (phTTS,
; 580  : 										  ERROR_WRITING_FILE,
; 581  : 										  0L);

  0066e	6a 00		 push	 0
  00670	6a 05		 push	 5
  00672	53		 push	 ebx
  00673	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  00678	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71590:
  0067b	8b 44 24 10	 mov	 eax, DWORD PTR _i$[esp+28]
  0067f	0f bf 97 82 17
	00 00		 movsx	 edx, WORD PTR [edi+6018]
  00686	40		 inc	 eax
  00687	3b c2		 cmp	 eax, edx
  00689	89 44 24 10	 mov	 DWORD PTR _i$[esp+28], eax
  0068d	0f 8c 7b fd ff
	ff		 jl	 $L71589
  00693	5d		 pop	 ebp
$L71591:

; 582  : 			}
; 583  : 		}
; 584  : #endif // #ifdef MSDOS
; 585  : 
; 586  : 	}
; 587  : #ifdef WIN32
; 588  : 	LeaveCriticalSection (phTTS->pcsLogFile);

  00694	8b 83 c8 00 00
	00		 mov	 eax, DWORD PTR [ebx+200]
  0069a	50		 push	 eax
  0069b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  006a1	5f		 pop	 edi
  006a2	5e		 pop	 esi
  006a3	5b		 pop	 ebx

; 589  : #endif
; 590  : #if defined (__osf__) || defined (__linux__)
; 591  : 	/* GL 04/21/1997  change this as the latest OSF code */
; 592  : 	/* ToggleLogfileMutex (MUTEX_RELEASE);*/
; 593  : 	OP_UnlockMutex( phTTS->pcsLogFile );
; 594  : #endif
; 595  : 
; 596  : }

  006a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  006a7	c3		 ret	 0
_logsyllable ENDP
_pDph_t$ = 8
_j$ = 12
_ph_syllab PROC NEAR

; 613  : {

  006b0	53		 push	 ebx

; 614  : 	int k; 
; 615  : 	short len;
; 616  : 
; 617  : 	/* 
; 618  : 	 *  first, strip off any  ...
; 619  : 	 */
; 620  : 
; 621  : 	k = 0;

  006b1	8b 5c 24 08	 mov	 ebx, DWORD PTR _pDph_t$[esp]
  006b5	55		 push	 ebp
  006b6	56		 push	 esi
  006b7	8b 74 24 14	 mov	 esi, DWORD PTR _j$[esp+8]
  006bb	57		 push	 edi
  006bc	33 ff		 xor	 edi, edi
$L71634:

; 622  : 	while (true)
; 623  : 	{
; 624  : #ifdef __linux__
; 625  : 		len = syl_find_affix (pDph_t, (short int *)&(pDph_t->phone_struct[j]));
; 626  : #else
; 627  :                 len = syl_find_affix (pDph_t, (short *)&(pDph_t->phone_struct[j])); // NAL warning removal

  006be	8d ac b3 d8 27
	00 00		 lea	 ebp, DWORD PTR [ebx+esi*4+10200]
  006c5	55		 push	 ebp
  006c6	53		 push	 ebx
  006c7	e8 00 00 00 00	 call	 _syl_find_affix
  006cc	83 c4 08	 add	 esp, 8

; 628  : #endif
; 629  : 		if (len == 0)

  006cf	66 85 c0	 test	 ax, ax
  006d2	74 7f		 je	 SHORT $L71752

; 630  : 			break;
; 631  : 		while (len-- && j)

  006d4	48		 dec	 eax
  006d5	8d 8c bb d8 23
	00 00		 lea	 ecx, DWORD PTR [ebx+edi*4+9176]
  006dc	8b d5		 mov	 edx, ebp
$L71639:
  006de	85 f6		 test	 esi, esi
  006e0	0f 84 a9 01 00
	00		 je	 $L71662

; 632  : 			pDph_t->syllable_struct[k++] = pDph_t->phone_struct[j--];

  006e6	8b 2a		 mov	 ebp, DWORD PTR [edx]
  006e8	47		 inc	 edi
  006e9	89 29		 mov	 DWORD PTR [ecx], ebp
  006eb	83 c1 04	 add	 ecx, 4
  006ee	4e		 dec	 esi
  006ef	83 ea 04	 sub	 edx, 4
  006f2	66 8b e8	 mov	 bp, ax
  006f5	48		 dec	 eax
  006f6	66 85 ed	 test	 bp, bp
  006f9	75 e3		 jne	 SHORT $L71639

; 633  : 		if (j == 0)

  006fb	85 f6		 test	 esi, esi
  006fd	0f 84 8c 01 00
	00		 je	 $L71662
  00703	8d 8c bb d8 23
	00 00		 lea	 ecx, DWORD PTR [ebx+edi*4+9176]
  0070a	8d 94 b3 d8 27
	00 00		 lea	 edx, DWORD PTR [ebx+esi*4+10200]
$L71643:

; 634  : 			break;
; 635  : 		while (j && ascky_check[pDph_t->phone_struct[j] & PVALUE] == 0)

  00711	8b 02		 mov	 eax, DWORD PTR [edx]
  00713	8b e8		 mov	 ebp, eax
  00715	81 e5 ff 00 00
	00		 and	 ebp, 255		; 000000ffH
  0071b	80 bd 00 00 00
	00 00		 cmp	 BYTE PTR _ascky_check[ebp], 0
  00722	75 0e		 jne	 SHORT $L71644

; 636  : 			pDph_t->syllable_struct[k++] = pDph_t->phone_struct[j--];

  00724	89 01		 mov	 DWORD PTR [ecx], eax
  00726	47		 inc	 edi
  00727	83 c1 04	 add	 ecx, 4
  0072a	4e		 dec	 esi
  0072b	83 ea 04	 sub	 edx, 4
  0072e	85 f6		 test	 esi, esi
  00730	75 df		 jne	 SHORT $L71643
$L71644:

; 637  : 		if (pDph_t->syllable_struct[k-1] != SBOUND)		/* fix duplicated syllable boundries */

  00732	8b 8c bb d4 23
	00 00		 mov	 ecx, DWORD PTR [ebx+edi*4+9172]
  00739	b8 6c 00 00 00	 mov	 eax, 108		; 0000006cH
  0073e	3b c8		 cmp	 ecx, eax
  00740	0f 84 78 ff ff
	ff		 je	 $L71634

; 638  : 			pDph_t->syllable_struct[k++] = SBOUND;

  00746	89 84 bb d8 23
	00 00		 mov	 DWORD PTR [ebx+edi*4+9176], eax
  0074d	47		 inc	 edi
  0074e	e9 6b ff ff ff	 jmp	 $L71634
$L71752:

; 639  : 		
; 640  : 	}
; 641  : 	/* 
; 642  : 	 *  Now, syllablify the rest of it ...
; 643  : 	 */
; 644  : 	if (j != 0)

  00753	85 f6		 test	 esi, esi
  00755	0f 84 34 01 00
	00		 je	 $L71662
$L71648:

; 645  : 	{
; 646  : 		while (true)
; 647  : 		{
; 648  : 			/* 
; 649  : 			 *  Find vowel ...
; 650  : 			 */
; 651  : #ifdef __linux__
; 652  : 			len = syl_find_vowel ((short int *)&(pDph_t->phone_struct[j]));
; 653  : #else
; 654  :                         len = syl_find_vowel ((short *) &(pDph_t->phone_struct[j])); // NAL warning removal

  0075b	8d ac b3 d8 27
	00 00		 lea	 ebp, DWORD PTR [ebx+esi*4+10200]
  00762	55		 push	 ebp
  00763	e8 00 00 00 00	 call	 _syl_find_vowel
  00768	83 c4 04	 add	 esp, 4

; 655  : #endif
; 656  : 			if (len)

  0076b	66 85 c0	 test	 ax, ax
  0076e	0f 84 fa 00 00
	00		 je	 $L71751

; 657  : 			{
; 658  : 				while (len-- && j)

  00774	48		 dec	 eax
  00775	8d 8c bb d8 23
	00 00		 lea	 ecx, DWORD PTR [ebx+edi*4+9176]
  0077c	8b d5		 mov	 edx, ebp
$L71653:
  0077e	85 f6		 test	 esi, esi
  00780	0f 84 09 01 00
	00		 je	 $L71662

; 659  : 				{
; 660  : 					pDph_t->syllable_struct[k++] = pDph_t->phone_struct[j--];

  00786	8b 2a		 mov	 ebp, DWORD PTR [edx]
  00788	47		 inc	 edi
  00789	89 29		 mov	 DWORD PTR [ecx], ebp
  0078b	83 c1 04	 add	 ecx, 4
  0078e	4e		 dec	 esi
  0078f	83 ea 04	 sub	 edx, 4
  00792	66 8b e8	 mov	 bp, ax
  00795	48		 dec	 eax
  00796	66 85 ed	 test	 bp, bp
  00799	75 e3		 jne	 SHORT $L71653

; 661  : 				}
; 662  : 				if (j == 0)

  0079b	85 f6		 test	 esi, esi
  0079d	0f 84 ec 00 00
	00		 je	 $L71662
  007a3	8d 8c bb d8 23
	00 00		 lea	 ecx, DWORD PTR [ebx+edi*4+9176]
  007aa	8d 94 b3 d8 27
	00 00		 lea	 edx, DWORD PTR [ebx+esi*4+10200]
$L71657:

; 663  : 					break;
; 664  : 				while (j && ascky_check[pDph_t->phone_struct[j] & PVALUE] == 0)

  007b1	8b 02		 mov	 eax, DWORD PTR [edx]
  007b3	8b e8		 mov	 ebp, eax
  007b5	81 e5 ff 00 00
	00		 and	 ebp, 255		; 000000ffH
  007bb	80 bd 00 00 00
	00 00		 cmp	 BYTE PTR _ascky_check[ebp], 0
  007c2	75 0e		 jne	 SHORT $L71658

; 665  : 					pDph_t->syllable_struct[k++] = pDph_t->phone_struct[j--];

  007c4	89 01		 mov	 DWORD PTR [ecx], eax
  007c6	47		 inc	 edi
  007c7	83 c1 04	 add	 ecx, 4
  007ca	4e		 dec	 esi
  007cb	83 ea 04	 sub	 edx, 4
  007ce	85 f6		 test	 esi, esi
  007d0	75 df		 jne	 SHORT $L71657
$L71658:

; 671  : 				break;
; 672  : 			}
; 673  : 			/* 
; 674  : 			 *  head cons ...
; 675  : 			 */
; 676  : #ifdef __linux__
; 677  : 			len = syl_find_cons ((short int *) &(pDph_t->phone_struct[j]));
; 678  : #else
; 679  :                         len = syl_find_cons ((short *) &(pDph_t->phone_struct[j])); // NAL warning removal

  007d2	8d ac b3 d8 27
	00 00		 lea	 ebp, DWORD PTR [ebx+esi*4+10200]
  007d9	55		 push	 ebp
  007da	e8 00 00 00 00	 call	 _syl_find_cons
  007df	83 c4 04	 add	 esp, 4

; 680  : #endif
; 681  : 			if (len)

  007e2	66 85 c0	 test	 ax, ax
  007e5	74 2d		 je	 SHORT $L71750

; 682  : 			{
; 683  : 				while (len-- && j)

  007e7	48		 dec	 eax
  007e8	8d 8c bb d8 23
	00 00		 lea	 ecx, DWORD PTR [ebx+edi*4+9176]
  007ef	8b d5		 mov	 edx, ebp
$L71666:
  007f1	85 f6		 test	 esi, esi
  007f3	0f 84 96 00 00
	00		 je	 $L71662

; 684  : 					pDph_t->syllable_struct[k++] = pDph_t->phone_struct[j--];

  007f9	8b 2a		 mov	 ebp, DWORD PTR [edx]
  007fb	47		 inc	 edi
  007fc	89 29		 mov	 DWORD PTR [ecx], ebp
  007fe	83 c1 04	 add	 ecx, 4
  00801	4e		 dec	 esi
  00802	83 ea 04	 sub	 edx, 4
  00805	66 8b e8	 mov	 bp, ax
  00808	48		 dec	 eax
  00809	66 85 ed	 test	 bp, bp
  0080c	75 e3		 jne	 SHORT $L71666

; 685  : 				if (j == 0)

  0080e	85 f6		 test	 esi, esi
  00810	74 7d		 je	 SHORT $L71662

; 686  : 					break;
; 687  : 			}
; 688  : 			/* 
; 689  : 			 *  syllable break must be here ... if we are not word initial ...
; 690  : 			 */
; 691  : 			while (j && ascky_check[pDph_t->phone_struct[j] & PVALUE] == 0)

  00812	eb 04		 jmp	 SHORT $L71772
$L71750:
  00814	85 f6		 test	 esi, esi
  00816	74 77		 je	 SHORT $L71662
$L71772:
  00818	8d 8c bb d8 23
	00 00		 lea	 ecx, DWORD PTR [ebx+edi*4+9176]
  0081f	8d 94 b3 d8 27
	00 00		 lea	 edx, DWORD PTR [ebx+esi*4+10200]
$L71670:
  00826	8b 02		 mov	 eax, DWORD PTR [edx]
  00828	8b e8		 mov	 ebp, eax
  0082a	81 e5 ff 00 00
	00		 and	 ebp, 255		; 000000ffH
  00830	80 bd 00 00 00
	00 00		 cmp	 BYTE PTR _ascky_check[ebp], 0
  00837	75 10		 jne	 SHORT $L71671

; 692  : 				pDph_t->syllable_struct[k++] = pDph_t->phone_struct[j--];

  00839	89 01		 mov	 DWORD PTR [ecx], eax
  0083b	47		 inc	 edi
  0083c	83 c1 04	 add	 ecx, 4
  0083f	4e		 dec	 esi
  00840	83 ea 04	 sub	 edx, 4
  00843	85 f6		 test	 esi, esi
  00845	74 48		 je	 SHORT $L71662

; 686  : 					break;
; 687  : 			}
; 688  : 			/* 
; 689  : 			 *  syllable break must be here ... if we are not word initial ...
; 690  : 			 */
; 691  : 			while (j && ascky_check[pDph_t->phone_struct[j] & PVALUE] == 0)

  00847	eb dd		 jmp	 SHORT $L71670
$L71671:

; 693  : 			if (j == 0)

  00849	85 f6		 test	 esi, esi
  0084b	74 42		 je	 SHORT $L71662

; 694  : 			{
; 695  : 				break;
; 696  : 			}
; 697  : 			if (pDph_t->syllable_struct[k-1] != SBOUND)	/* fix duplicated syllable boundries */	

  0084d	8b 8c bb d4 23
	00 00		 mov	 ecx, DWORD PTR [ebx+edi*4+9172]
  00854	b8 6c 00 00 00	 mov	 eax, 108		; 0000006cH
  00859	3b c8		 cmp	 ecx, eax
  0085b	0f 84 fa fe ff
	ff		 je	 $L71648

; 698  : 				pDph_t->syllable_struct[k++] = SBOUND;

  00861	89 84 bb d8 23
	00 00		 mov	 DWORD PTR [ebx+edi*4+9176], eax
  00868	47		 inc	 edi
  00869	e9 ed fe ff ff	 jmp	 $L71648
$L71751:

; 666  : 			}
; 667  : 			else
; 668  : 			{
; 669  : 				while (j)

  0086e	85 f6		 test	 esi, esi
  00870	74 1d		 je	 SHORT $L71662
  00872	8d 84 bb d8 23
	00 00		 lea	 eax, DWORD PTR [ebx+edi*4+9176]
  00879	8d 9c b3 d8 27
	00 00		 lea	 ebx, DWORD PTR [ebx+esi*4+10200]
  00880	03 fe		 add	 edi, esi
$L71661:

; 670  : 					pDph_t->syllable_struct[k++] = pDph_t->phone_struct[j--];

  00882	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00884	83 eb 04	 sub	 ebx, 4
  00887	89 08		 mov	 DWORD PTR [eax], ecx
  00889	83 c0 04	 add	 eax, 4
  0088c	4e		 dec	 esi
  0088d	75 f3		 jne	 SHORT $L71661
$L71662:

; 699  : 		}
; 700  : 	}
; 701  : 	return (k);

  0088f	8b c7		 mov	 eax, edi
  00891	5f		 pop	 edi
  00892	5e		 pop	 esi
  00893	5d		 pop	 ebp
  00894	5b		 pop	 ebx

; 702  : }

  00895	c3		 ret	 0
_ph_syllab ENDP
_ph$ = 12
_syl_find_affix PROC NEAR

; 329  : {

  008a0	53		 push	 ebx
  008a1	55		 push	 ebp
  008a2	56		 push	 esi
  008a3	57		 push	 edi

; 330  : 	short *tp;
; 331  : 	int i, j, len = 0;
; 332  : 
; 333  : 	for (j = 0; common_affixes[j]; j++)

  008a4	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _common_affixes
  008aa	85 ff		 test	 edi, edi
  008ac	74 56		 je	 SHORT $L71567
  008ae	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_common_affixes
$L71565:

; 334  : 	{
; 335  : 		for (i = 0; common_affixes[j][i]; i++);

  008b3	8a 17		 mov	 dl, BYTE PTR [edi]
  008b5	33 c9		 xor	 ecx, ecx
  008b7	84 d2		 test	 dl, dl
  008b9	74 0b		 je	 SHORT $L71570
  008bb	8b 38		 mov	 edi, DWORD PTR [eax]
$L71568:
  008bd	8a 54 0f 01	 mov	 dl, BYTE PTR [edi+ecx+1]
  008c1	41		 inc	 ecx
  008c2	84 d2		 test	 dl, dl
  008c4	75 f7		 jne	 SHORT $L71568
$L71570:

; 336  : 		len = i;
; 337  : 		tp = ph;

  008c6	8b 74 24 18	 mov	 esi, DWORD PTR _ph$[esp+12]
  008ca	8b e9		 mov	 ebp, ecx
$L71572:

; 339  : 		{
; 340  : 			if (ascky_check[(*tp) & PVALUE] == 0)

  008cc	8a 16		 mov	 dl, BYTE PTR [esi]
  008ce	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  008d4	8a 92 00 00 00
	00		 mov	 dl, BYTE PTR _ascky_check[edx]
  008da	84 d2		 test	 dl, dl
  008dc	75 06		 jne	 SHORT $L71574

; 341  : 			{
; 342  : #ifdef ENGLISH_US
; 343  : 				tp++;

  008de	83 c6 02	 add	 esi, 2

; 344  : #endif
; 345  : #ifdef ENGLISH_UK
; 346  : 				tp++;
; 347  : #endif
; 348  : #ifdef SPANISH
; 349  : 				tp--;
; 350  : #endif
; 351  : #ifdef FRENCH
; 352  : 				tp++;
; 353  : #endif
; 354  : 				len += 1;

  008e1	45		 inc	 ebp

; 355  : 			}
; 356  : 			else

  008e2	eb 10		 jmp	 SHORT $L71575
$L71574:

; 357  : 			{
; 358  : 				--i;

  008e4	49		 dec	 ecx

; 359  : 				if ((common_affixes[j][i]) != (ascky_check[(*tp) & PVALUE]))

  008e5	33 db		 xor	 ebx, ebx
  008e7	0f be d2	 movsx	 edx, dl
  008ea	8a 1c 0f	 mov	 bl, BYTE PTR [edi+ecx]
  008ed	3b da		 cmp	 ebx, edx
  008ef	75 09		 jne	 SHORT $L71791

; 360  : 				{
; 361  : 					tp--;
; 362  : 					break;
; 363  : 				}
; 364  : 				tp--;

  008f1	83 ee 02	 sub	 esi, 2
$L71575:

; 365  : 			}
; 366  : 			if (i == 0)

  008f4	85 c9		 test	 ecx, ecx
  008f6	74 14		 je	 SHORT $L71792

; 338  : 		while (true)

  008f8	eb d2		 jmp	 SHORT $L71572
$L71791:

; 330  : 	short *tp;
; 331  : 	int i, j, len = 0;
; 332  : 
; 333  : 	for (j = 0; common_affixes[j]; j++)

  008fa	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  008fd	83 c0 04	 add	 eax, 4
  00900	85 ff		 test	 edi, edi
  00902	75 af		 jne	 SHORT $L71565
$L71567:
  00904	5f		 pop	 edi
  00905	5e		 pop	 esi
  00906	5d		 pop	 ebp

; 368  : 		}
; 369  : 	}
; 370  : 	return (0);

  00907	66 33 c0	 xor	 ax, ax
  0090a	5b		 pop	 ebx

; 371  : }

  0090b	c3		 ret	 0
$L71792:
  0090c	5f		 pop	 edi

; 367  : 				return (len);

  0090d	66 8b c5	 mov	 ax, bp
  00910	5e		 pop	 esi
  00911	5d		 pop	 ebp
  00912	5b		 pop	 ebx

; 371  : }

  00913	c3		 ret	 0
_syl_find_affix ENDP
_pDph_t$ = 8
_syl_clause_init PROC NEAR

; 719  : 	pDph_t->symbols[0] = COMMA;

  00920	8b 44 24 04	 mov	 eax, DWORD PTR _pDph_t$[esp-4]
  00924	56		 push	 esi
  00925	ba 73 00 00 00	 mov	 edx, 115		; 00000073H

; 720  : 	pDph_t->user_durs[0] = 0;

  0092a	33 c9		 xor	 ecx, ecx
  0092c	8b b0 84 17 00
	00		 mov	 esi, DWORD PTR [eax+6020]
  00932	66 89 90 26 15
	00 00		 mov	 WORD PTR [eax+5414], dx
  00939	66 89 0e	 mov	 WORD PTR [esi], cx

; 721  : 	pDph_t->user_f0[0] = 0;

  0093c	8b b0 88 17 00
	00		 mov	 esi, DWORD PTR [eax+6024]
  00942	66 89 0e	 mov	 WORD PTR [esi], cx

; 722  : 	pDph_t->bound = COMMA;

  00945	89 90 cc 23 00
	00		 mov	 DWORD PTR [eax+9164], edx

; 723  : 	pDph_t->lastoffs = 0;

  0094b	89 88 d4 23 00
	00		 mov	 DWORD PTR [eax+9172], ecx

; 724  : 	pDph_t->nphone = 0;
; 725  : 	pDph_t->asperation = 0;

  00951	89 88 c4 23 00
	00		 mov	 DWORD PTR [eax+9156], ecx

; 726  : 	pDph_t->nsymbtot = 1;

  00957	66 c7 80 82 17
	00 00 01 00	 mov	 WORD PTR [eax+6018], 1

; 727  : 	pDph_t->nphone = 0;

  00960	66 89 88 d0 23
	00 00		 mov	 WORD PTR [eax+9168], cx
  00967	5e		 pop	 esi

; 728  : }

  00968	c3		 ret	 0
_syl_clause_init ENDP
_TEXT	ENDS
EXTRN	_write_pipe:NEAR
EXTRN	_phclause:NEAR
_TEXT	SEGMENT
_pipe_item$ = 8
_phTTS$ = 8
_speak_syllable PROC NEAR

; 745  : /* GL 04/21/1997  change this as the latest OSF code */
; 746  : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 747  : 	DT_PIPE_T               pipe_item[1];
; 748  : #endif
; 749  : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;

  00970	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00974	56		 push	 esi
  00975	57		 push	 edi

; 750  : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;
; 751  : 
; 752  : 	pDph_t->symbols[pDph_t->nsymbtot] = COMMA;
; 753  : 	pDph_t->user_durs[pDph_t->nsymbtot] = 0;
; 754  : 	pDph_t->user_f0[pDph_t->nsymbtot++] = 0;
; 755  : 	phclause (phTTS);

  00976	50		 push	 eax
  00977	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  0097a	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  0097d	0f bf 8e 82 17
	00 00		 movsx	 ecx, WORD PTR [esi+6018]
  00984	66 c7 84 4e 26
	15 00 00 73 00	 mov	 WORD PTR [esi+ecx*2+5414], 115 ; 00000073H
  0098e	8b 8e 84 17 00
	00		 mov	 ecx, DWORD PTR [esi+6020]
  00994	0f bf 96 82 17
	00 00		 movsx	 edx, WORD PTR [esi+6018]
  0099b	66 c7 04 51 00
	00		 mov	 WORD PTR [ecx+edx*2], 0
  009a1	8b 8e 88 17 00
	00		 mov	 ecx, DWORD PTR [esi+6024]
  009a7	0f bf 96 82 17
	00 00		 movsx	 edx, WORD PTR [esi+6018]
  009ae	66 c7 04 51 00
	00		 mov	 WORD PTR [ecx+edx*2], 0
  009b4	66 ff 86 82 17
	00 00		 inc	 WORD PTR [esi+6018]
  009bb	e8 00 00 00 00	 call	 _phclause

; 756  : 	syl_clause_init (pDph_t);

  009c0	56		 push	 esi
  009c1	e8 00 00 00 00	 call	 _syl_clause_init

; 757  : 
; 758  : /* GL 04/21/1997  change this as the latest OSF code */
; 759  : /* write forced clause boundary symbol to VTM */
; 760  : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 761  : 	pipe_item[0] = SPC_type_force;

  009c6	66 c7 44 24 14
	0b 00		 mov	 WORD PTR _pipe_item$[esp+12], 11 ; 0000000bH

; 762  : 	write_pipe (pKsd_t->vtm_pipe, pipe_item, 1);

  009cd	8b 87 9c 02 00
	00		 mov	 eax, DWORD PTR [edi+668]
  009d3	8d 54 24 14	 lea	 edx, DWORD PTR _pipe_item$[esp+12]
  009d7	6a 01		 push	 1
  009d9	52		 push	 edx
  009da	50		 push	 eax
  009db	e8 00 00 00 00	 call	 _write_pipe
  009e0	83 c4 14	 add	 esp, 20			; 00000014H
  009e3	5f		 pop	 edi
  009e4	5e		 pop	 esi

; 763  : #endif
; 764  : 
; 765  : }

  009e5	c3		 ret	 0
_speak_syllable ENDP
_TEXT	ENDS
END
