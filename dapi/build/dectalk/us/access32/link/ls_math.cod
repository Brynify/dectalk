	TITLE	D:\work\Product\dapi\src\Lts\ls_math.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_math_table
PUBLIC	_ascky_tab
_DATA	SEGMENT
_math_table DB	02bH
	ORG $+3
	DD	FLAT:$SG71776
	DB	02dH
	ORG $+3
	DD	FLAT:$SG71777
	DB	02aH
	ORG $+3
	DD	FLAT:$SG71778
	DB	02fH
	ORG $+3
	DD	FLAT:$SG71779
	DB	05eH
	ORG $+3
	DD	FLAT:$SG71780
	DB	03cH
	ORG $+3
	DD	FLAT:$SG71781
	DB	03eH
	ORG $+3
	DD	FLAT:$SG71782
	DB	03dH
	ORG $+3
	DD	FLAT:$SG71783
	DB	025H
	ORG $+3
	DD	FLAT:$SG71784
	DB	02eH
	ORG $+3
	DD	FLAT:$SG71785
	DB	00H
	ORG $+3
	DD	00H
_ascky_tab DB	065H
	ORG $+3
	DD	01e03H
	DB	061H
	ORG $+3
	DD	01e06H
	DB	069H
	ORG $+3
	DD	01e01H
	DB	045H
	ORG $+3
	DD	01e04H
	DB	041H
	ORG $+3
	DD	01e07H
	DB	049H
	ORG $+3
	DD	01e02H
	DB	04fH
	ORG $+3
	DD	01e0cH
	DB	06fH
	ORG $+3
	DD	01e0bH
	DB	075H
	ORG $+3
	DD	01e0eH
	DB	05eH
	ORG $+3
	DD	01e09H
	DB	057H
	ORG $+3
	DD	01e08H
	DB	059H
	ORG $+3
	DD	01e10H
	DB	052H
	ORG $+3
	DD	01e0fH
	DB	063H
	ORG $+3
	DD	01e0aH
	DB	040H
	ORG $+3
	DD	01e05H
	DB	055H
	ORG $+3
	DD	01e0dH
	DB	07cH
	ORG $+3
	DD	01e12H
	DB	078H
	ORG $+3
	DD	01e11H
	DB	070H
	ORG $+3
	DD	01e2dH
	DB	074H
	ORG $+3
	DD	01e2fH
	DB	06bH
	ORG $+3
	DD	01e31H
	DB	066H
	ORG $+3
	DD	01e25H
	DB	054H
	ORG $+3
	DD	01e27H
	DB	073H
	ORG $+3
	DD	01e29H
	DB	053H
	ORG $+3
	DD	01e2bH
	DB	043H
	ORG $+3
	DD	01e36H
	DB	077H
	ORG $+3
	DD	01e18H
	DB	079H
	ORG $+3
	DD	01e19H
	DB	068H
	ORG $+3
	DD	01e1cH
	DB	06cH
	ORG $+3
	DD	01e1bH
	DB	04cH
	ORG $+3
	DD	01e22H
	DB	04eH
	ORG $+3
	DD	01e24H
	DB	062H
	ORG $+3
	DD	01e2eH
	DB	064H
	ORG $+3
	DD	01e30H
	DB	067H
	ORG $+3
	DD	01e32H
	DB	076H
	ORG $+3
	DD	01e26H
	DB	044H
	ORG $+3
	DD	01e28H
	DB	07aH
	ORG $+3
	DD	01e2aH
	DB	05aH
	ORG $+3
	DD	01e2cH
	DB	04aH
	ORG $+3
	DD	01e37H
	DB	06dH
	ORG $+3
	DD	01e1fH
	DB	06eH
	ORG $+3
	DD	01e20H
	DB	047H
	ORG $+3
	DD	01e21H
	DB	072H
	ORG $+3
	DD	01e1aH
	DB	071H
	ORG $+3
	DD	01e35H
	DB	051H
	ORG $+3
	DD	01e34H
	DB	026H
	ORG $+3
	DD	01e33H
	DB	046H
	ORG $+3
	DD	01e38H
	DB	042H
	ORG $+3
	DD	01e13H
	DB	04bH
	ORG $+3
	DD	01e14H
	DB	050H
	ORG $+3
	DD	01e15H
	DB	04dH
	ORG $+3
	DD	01e16H
	DB	06aH
	ORG $+3
	DD	01e17H
	DB	02cH
	ORG $+3
	DD	01e73H
	DB	020H
	ORG $+3
	DD	01e6fH
	DB	09H
	ORG $+3
	DD	01e6fH
	DB	027H
	ORG $+3
	DD	01e67H
	DB	060H
	ORG $+3
	DD	01e66H
	DB	022H
	ORG $+3
	DD	01e68H
	DB	023H
	ORG $+3
	DD	01e6eH
	DB	028H
	ORG $+3
	DD	01e70H
	DB	029H
	ORG $+3
	DD	01e71H
	DB	02aH
	ORG $+3
	DD	01e6dH
	DB	07eH
	ORG $+3
	DD	01e64H
	DB	02dH
	ORG $+3
	DD	01e6cH
$SG71776 DB	'pl''^s', 00H
	ORG $+2
$SG71777 DB	'm''An|s', 00H
	ORG $+1
$SG71778 DB	'm''^lt|plAd*bA', 00H
	ORG $+2
$SG71779 DB	'd|v''Ad|d*bA', 00H
$SG71780 DB	'tU*Dx*p''WR*xv', 00H
	ORG $+2
$SG71781 DB	'l''Es*DEn', 00H
	ORG $+3
$SG71782 DB	'gr''etR*DEn', 00H
	ORG $+1
$SG71783 DB	'''ikwLz', 00H
	ORG $+1
$SG71784 DB	'pRs''Ent', 00H
$SG71785 DB	'p''Ont', 00H
_DATA	ENDS
PUBLIC	_ls_math_do_math
PUBLIC	_ls_math_flush_ascky
_TEXT	SEGMENT
_pKsd_t$ = 8
_check_char$ = 12
_ls_math_do_math PROC NEAR

; 79   : {

  00000	56		 push	 esi

; 80   : 	struct math_symbols *ms;
; 81   : 
; 82   : 	/*
; 83   : 	 * this must be a single character and mode math must be enabled ...
; 84   : 	 */
; 85   : 
; 86   : 	if(pKsd_t->modeflag & MODE_MATH)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _pKsd_t$[esp]
  00005	f6 86 c0 03 00
	00 04		 test	 BYTE PTR [esi+960], 4
  0000c	74 20		 je	 SHORT $L71796

; 87   : 	{
; 88   : 		ms = math_table;
; 89   : 		while((*ms).sym)

  0000e	a0 00 00 00 00	 mov	 al, BYTE PTR _math_table
  00013	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_math_table
  00018	84 c0		 test	 al, al
  0001a	74 12		 je	 SHORT $L71796

; 90   : 		{
; 91   : 			if((*ms).sym == check_char)

  0001c	8a 54 24 0c	 mov	 dl, BYTE PTR _check_char$[esp]
$L71795:
  00020	3a c2		 cmp	 al, dl
  00022	74 0e		 je	 SHORT $L71818
  00024	8a 41 08	 mov	 al, BYTE PTR [ecx+8]

; 95   : 			}
; 96   : 			else
; 97   : 				ms += 1;

  00027	83 c1 08	 add	 ecx, 8
  0002a	84 c0		 test	 al, al
  0002c	75 f2		 jne	 SHORT $L71795
$L71796:

; 98   : 		}
; 99   : 	}
; 100  : 	return(false);

  0002e	33 c0		 xor	 eax, eax
  00030	5e		 pop	 esi

; 101  : }

  00031	c3		 ret	 0
$L71818:

; 92   : 			{
; 93   : 				ls_math_flush_ascky(pKsd_t,(*ms).sym_pron);

  00032	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00035	50		 push	 eax
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 _ls_math_flush_ascky
  0003c	83 c4 08	 add	 esp, 8

; 94   : 				return(true);

  0003f	b8 01 00 00 00	 mov	 eax, 1
  00044	5e		 pop	 esi

; 101  : }

  00045	c3		 ret	 0
_ls_math_do_math ENDP
_TEXT	ENDS
EXTRN	_ls_util_write_pipe:NEAR
_TEXT	SEGMENT
_pKsd_t$ = 8
_str$ = 12
_ls_math_flush_ascky PROC NEAR

; 126  : {                              

  00050	56		 push	 esi

; 127  : 	int	i;	
; 128  : 
; 129  : 	while(*str)

  00051	8b 74 24 0c	 mov	 esi, DWORD PTR _str$[esp]
  00055	8a 16		 mov	 dl, BYTE PTR [esi]
  00057	84 d2		 test	 dl, dl
  00059	74 39		 je	 SHORT $L71807
  0005b	57		 push	 edi
  0005c	8b 7c 24 0c	 mov	 edi, DWORD PTR _pKsd_t$[esp+4]
$L71806:

; 130  : 	{
; 131  : 		for(i=0;i<NATAB;i++)  

  00060	33 c9		 xor	 ecx, ecx
  00062	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_ascky_tab
$L71809:

; 132  : 		{
; 133  : 			if(*str == ascky_tab[i].p_graph)

  00067	3a 10		 cmp	 dl, BYTE PTR [eax]
  00069	74 0d		 je	 SHORT $L71822
  0006b	83 c0 08	 add	 eax, 8
  0006e	41		 inc	 ecx
  0006f	3d 08 02 00 00	 cmp	 eax, OFFSET FLAT:_ascky_tab+520
  00074	7c f1		 jl	 SHORT $L71809
  00076	eb 13		 jmp	 SHORT $L71811
$L71822:

; 134  : 			{
; 135  : 				ls_util_write_pipe(pKsd_t, (short *)&ascky_tab[i].pphone,1);

  00078	8d 04 cd 04 00
	00 00		 lea	 eax, DWORD PTR _ascky_tab[ecx*8+4]
  0007f	6a 01		 push	 1
  00081	50		 push	 eax
  00082	57		 push	 edi
  00083	e8 00 00 00 00	 call	 _ls_util_write_pipe
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71811:
  0008b	8a 56 01	 mov	 dl, BYTE PTR [esi+1]

; 136  : 				break;
; 137  : 			} 
; 138  : 		}
; 139  : 		str += 1;

  0008e	46		 inc	 esi
  0008f	84 d2		 test	 dl, dl
  00091	75 cd		 jne	 SHORT $L71806
  00093	5f		 pop	 edi
$L71807:
  00094	5e		 pop	 esi

; 140  : 	}
; 141  : }

  00095	c3		 ret	 0
_ls_math_flush_ascky ENDP
_TEXT	ENDS
END
