	TITLE	D:\work\Product\dapi\src\Lts\lsa_adju.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_ls_adju_cluster
_TEXT	SEGMENT
_f$ = 8
_s$ = 12
_ls_adju_cluster PROC NEAR

; 73   : 	switch (f) 
; 74   : 	{

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _f$[esp-4]
  00004	83 c0 db	 add	 eax, -37		; ffffffdbH
  00007	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  0000a	0f 87 f8 00 00
	00		 ja	 $L72361
  00010	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72777[eax*4]
$L72364:

; 75   : 		case US_P:
; 76   : 			if (s==US_LL || s==US_R)

  00017	8b 44 24 08	 mov	 eax, DWORD PTR _s$[esp-4]

; 77   : 				return (TRYS);

  0001b	eb 63		 jmp	 SHORT $L72776
$L72367:

; 78   : 			break;
; 79   : 	
; 80   : 		case US_B:
; 81   : 			if (s==US_LL || s==US_R)

  0001d	8b 44 24 08	 mov	 eax, DWORD PTR _s$[esp-4]

; 82   : 				return (OK);

  00021	eb 76		 jmp	 SHORT $L72775
$L72370:

; 83   : 			break;
; 84   : 
; 85   : 		case US_F:
; 86   : 			if (s ==US_R)

  00023	8b 44 24 08	 mov	 eax, DWORD PTR _s$[esp-4]
  00027	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  0002a	75 06		 jne	 SHORT $L72371

; 87   : 				return (TRYS);

  0002c	b8 02 00 00 00	 mov	 eax, 2

; 127  : } 

  00031	c3		 ret	 0
$L72371:

; 88   : 			if (s ==US_LL)

  00032	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  00035	0f 85 cd 00 00
	00		 jne	 $L72361

; 89   : 				return (OK);

  0003b	b8 01 00 00 00	 mov	 eax, 1

; 127  : } 

  00040	c3		 ret	 0
$L72373:

; 90   : 			break;
; 91   : 	
; 92   : 		case US_T:
; 93   : 			if (s ==US_R)

  00041	8b 44 24 08	 mov	 eax, DWORD PTR _s$[esp-4]
  00045	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  00048	75 06		 jne	 SHORT $L72374

; 94   : 				return (TRYS);

  0004a	b8 02 00 00 00	 mov	 eax, 2

; 127  : } 

  0004f	c3		 ret	 0
$L72374:

; 95   : 			if (s ==US_W)

  00050	83 f8 18	 cmp	 eax, 24			; 00000018H
  00053	0f 85 af 00 00
	00		 jne	 $L72361

; 96   : 				return (OK);

  00059	b8 01 00 00 00	 mov	 eax, 1

; 127  : } 

  0005e	c3		 ret	 0
$L72376:

; 97   : 			break;
; 98   : 
; 99   : 		case US_D:
; 100  : 		case US_TH:
; 101  : 			if (s==US_W || s==US_R)

  0005f	8b 44 24 08	 mov	 eax, DWORD PTR _s$[esp-4]
  00063	83 f8 18	 cmp	 eax, 24			; 00000018H
  00066	74 3b		 je	 SHORT $L72378
  00068	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  0006b	0f 85 97 00 00
	00		 jne	 $L72361

; 102  : 				return (OK);

  00071	b8 01 00 00 00	 mov	 eax, 1

; 127  : } 

  00076	c3		 ret	 0
$L72379:

; 103  : 			break;
; 104  : 	
; 105  : 		case US_K:
; 106  : 			if (s==US_W || s==US_LL || s==US_R)

  00077	8b 44 24 08	 mov	 eax, DWORD PTR _s$[esp-4]
  0007b	83 f8 18	 cmp	 eax, 24			; 00000018H
  0007e	74 0a		 je	 SHORT $L72366
$L72776:
  00080	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  00083	74 05		 je	 SHORT $L72366
  00085	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  00088	75 7e		 jne	 SHORT $L72361
$L72366:

; 107  : 				return (TRYS);

  0008a	b8 02 00 00 00	 mov	 eax, 2

; 127  : } 

  0008f	c3		 ret	 0
$L72382:

; 108  : 			break;
; 109  : 	
; 110  : 		case US_G:
; 111  : 			if (s==US_W || s==US_LL || s==US_R)

  00090	8b 44 24 08	 mov	 eax, DWORD PTR _s$[esp-4]
  00094	83 f8 18	 cmp	 eax, 24			; 00000018H
  00097	74 0a		 je	 SHORT $L72378
$L72775:
  00099	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  0009c	74 05		 je	 SHORT $L72378
  0009e	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  000a1	75 65		 jne	 SHORT $L72361
$L72378:

; 112  : 				return (OK);

  000a3	b8 01 00 00 00	 mov	 eax, 1

; 127  : } 

  000a8	c3		 ret	 0
$L72385:

; 113  : 			break;
; 114  : 	
; 115  : 		case US_S:
; 116  : 			if (s==US_W || s==US_LL || s==US_P || s==US_T || s==US_K
; 117  : 			||  s==US_M || s==US_N  || s==US_F)

  000a9	8b 44 24 08	 mov	 eax, DWORD PTR _s$[esp-4]
  000ad	83 f8 18	 cmp	 eax, 24			; 00000018H
  000b0	74 23		 je	 SHORT $L72387
  000b2	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  000b5	74 1e		 je	 SHORT $L72387
  000b7	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  000ba	74 19		 je	 SHORT $L72387
  000bc	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  000bf	74 14		 je	 SHORT $L72387
  000c1	83 f8 31	 cmp	 eax, 49			; 00000031H
  000c4	74 0f		 je	 SHORT $L72387
  000c6	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000c9	74 0a		 je	 SHORT $L72387
  000cb	83 f8 20	 cmp	 eax, 32			; 00000020H
  000ce	74 05		 je	 SHORT $L72387
  000d0	83 f8 25	 cmp	 eax, 37			; 00000025H
  000d3	75 33		 jne	 SHORT $L72361
$L72387:

; 118  : 				return (OK);

  000d5	b8 01 00 00 00	 mov	 eax, 1

; 127  : } 

  000da	c3		 ret	 0
$L72388:

; 119  : 			break;
; 120  : 
; 121  : 		case US_SH:
; 122  : 			if (s==US_W || s==US_LL || s==US_R || s==US_P || s==US_T
; 123  : 			||  s==US_M || s==US_N)

  000db	8b 44 24 08	 mov	 eax, DWORD PTR _s$[esp-4]
  000df	83 f8 18	 cmp	 eax, 24			; 00000018H
  000e2	74 1e		 je	 SHORT $L72390
  000e4	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  000e7	74 19		 je	 SHORT $L72390
  000e9	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  000ec	74 14		 je	 SHORT $L72390
  000ee	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  000f1	74 0f		 je	 SHORT $L72390
  000f3	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  000f6	74 0a		 je	 SHORT $L72390
  000f8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000fb	74 05		 je	 SHORT $L72390
  000fd	83 f8 20	 cmp	 eax, 32			; 00000020H
  00100	75 06		 jne	 SHORT $L72361
$L72390:

; 124  : 				return (OK);

  00102	b8 01 00 00 00	 mov	 eax, 1

; 127  : } 

  00107	c3		 ret	 0
$L72361:

; 125  : 	} /* 	switch (f) */
; 126  : 	return (ILLEGAL);

  00108	33 c0		 xor	 eax, eax

; 127  : } 

  0010a	c3		 ret	 0
  0010b	90		 npad	 1
$L72777:
  0010c	00 00 00 00	 DD	 $L72370
  00110	00 00 00 00	 DD	 $L72361
  00114	00 00 00 00	 DD	 $L72376
  00118	00 00 00 00	 DD	 $L72361
  0011c	00 00 00 00	 DD	 $L72385
  00120	00 00 00 00	 DD	 $L72361
  00124	00 00 00 00	 DD	 $L72388
  00128	00 00 00 00	 DD	 $L72361
  0012c	00 00 00 00	 DD	 $L72364
  00130	00 00 00 00	 DD	 $L72367
  00134	00 00 00 00	 DD	 $L72373
  00138	00 00 00 00	 DD	 $L72376
  0013c	00 00 00 00	 DD	 $L72379
  00140	00 00 00 00	 DD	 $L72382
_ls_adju_cluster ENDP
_TEXT	ENDS
PUBLIC	_ls_adju_is_voc
PUBLIC	_ls_adju_is_obs
PUBLIC	_ls_adju_ins_phone
PUBLIC	_ls_adju_allo2
PUBLIC	_ls_adju_del_phone
_TEXT	SEGMENT
_pLts_t$ = 8
_sleft$ = -4
_sthis$ = 8
_ls_adju_allo2 PROC NEAR

; 152  : {

  00150	51		 push	 ecx
  00151	53		 push	 ebx
  00152	55		 push	 ebp

; 153  : 	 PHONE	*pp1;
; 154  : 	 PHONE	*pp2;
; 155  : 	 PHONE	*pp3;
; 156  : 	 PHONE	*pp4;
; 157  : 	 int	ph1;
; 158  : 	 int	sleft;
; 159  : 	 int	sthis;
; 160  : 	 int	fthis;
; 161  : 
; 162  : 	/*
; 163  : 	 * Sweep the phoneme string
; 164  : 	 * left to right, performing the vowel
; 165  : 	 * reductions. This has to be done in a
; 166  : 	 * prepass, to make sure all IX or
; 167  : 	 * AX vowels are correct before the main
; 168  : 	 * body of the allophonic rules are
; 169  : 	 * run. The "bflag" conditionally blocks
; 170  : 	 * this pass on VMS.
; 171  : 	 */
; 172  : #if defined	(VMS) || defined (LDS_BUILD)
; 173  : 	if (bflag == FALSE) 
; 174  : 	{
; 175  : #endif
; 176  : 
; 177  : 	sthis = SNONE;
; 178  : 	fthis = 0;
; 179  : 	pp1 = pLts_t->phead.p_fp;

  00153	8b 6c 24 10	 mov	 ebp, DWORD PTR _pLts_t$[esp+8]
  00157	56		 push	 esi
  00158	57		 push	 edi
  00159	33 f6		 xor	 esi, esi
  0015b	8b 85 c8 08 00
	00		 mov	 eax, DWORD PTR [ebp+2248]
  00161	8d bd c8 08 00
	00		 lea	 edi, DWORD PTR [ebp+2248]
  00167	33 db		 xor	 ebx, ebx

; 180  : 
; 181  : 	while (pp1 != &pLts_t->phead) 

  00169	3b c7		 cmp	 eax, edi
  0016b	ba 7b 00 00 00	 mov	 edx, 123		; 0000007bH
  00170	74 2a		 je	 SHORT $L72404
$L72403:

; 182  : 	{
; 183  : 		if ((pp1->p_flag&PFSYLAB) != 0) 

  00172	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00175	f6 c1 10	 test	 cl, 16			; 00000010H
  00178	74 05		 je	 SHORT $L72405

; 184  : 		{
; 185  : 			sthis = pp1->p_stress;

  0017a	8b 50 10	 mov	 edx, DWORD PTR [eax+16]

; 186  : 			fthis = pp1->p_flag;

  0017d	8b d9		 mov	 ebx, ecx
$L72405:

; 187  : 		}
; 188  : 		if ((fthis&PFBLOCK) == 0
; 189  : 		&& (pp1->p_uphone!=SIL && sthis==SUN)) 

  0017f	f6 c3 80	 test	 bl, -128		; ffffff80H
  00182	75 12		 jne	 SHORT $L72406
  00184	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00187	3b ce		 cmp	 ecx, esi
  00189	74 0b		 je	 SHORT $L72406
  0018b	83 fa 7c	 cmp	 edx, 124		; 0000007cH
  0018e	75 06		 jne	 SHORT $L72406

; 190  : 		{
; 191  : 
; 192  : 			pp1->p_sphone = pp1->p_uphone;

  00190	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 193  : 			pp1->p_uphone = SIL;

  00193	89 70 18	 mov	 DWORD PTR [eax+24], esi
$L72406:

; 194  : 		} 
; 195  : 		pp1 = pp1->p_fp;

  00196	8b 00		 mov	 eax, DWORD PTR [eax]
  00198	3b c7		 cmp	 eax, edi
  0019a	75 d6		 jne	 SHORT $L72403
$L72404:

; 196  : 	}
; 197  : 
; 198  : #if defined	(VMS) || defined (LDS_BUILD)
; 199  : 	}
; 200  : #endif
; 201  : 	/*
; 202  : 	 * Main allophonic sweep.
; 203  : 	 */
; 204  : 
; 205  : 	pp1 = pLts_t->phead.p_fp;
; 206  : 
; 207  : 	pLts_t->phead.p_sphone = SIL;			/* Make this look like	*/

  0019c	89 b5 dc 08 00
	00		 mov	 DWORD PTR [ebp+2268], esi

; 208  : 	pLts_t->phead.p_uphone = SIL;			/* silence, morpheme	*/

  001a2	89 b5 e0 08 00
	00		 mov	 DWORD PTR [ebp+2272], esi

; 209  : 	pLts_t->phead.p_flag = PFMORPH;			/* boundry.		*/
; 210  : 	sthis = SNONE;
; 211  : 	sleft = SNONE;
; 212  : 	pp1 = pLts_t->phead.p_fp;

  001a8	8b 37		 mov	 esi, DWORD PTR [edi]
  001aa	bb 0f 00 00 00	 mov	 ebx, 15			; 0000000fH
  001af	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH

; 213  : 	while (pp1 != &pLts_t->phead) 

  001b4	3b f7		 cmp	 esi, edi
  001b6	89 9d d4 08 00
	00		 mov	 DWORD PTR [ebp+2260], ebx
  001bc	89 44 24 18	 mov	 DWORD PTR _sthis$[esp+16], eax
  001c0	89 44 24 10	 mov	 DWORD PTR _sleft$[esp+20], eax
  001c4	0f 84 65 03 00
	00		 je	 $L72781
  001ca	eb 04		 jmp	 SHORT $L72408
$L72791:
  001cc	8b 44 24 18	 mov	 eax, DWORD PTR _sthis$[esp+16]
$L72408:

; 214  : 	{
; 215  : 		ph1 = pp1->p_sphone;
; 216  : 		if ((pp1->p_flag&PFSYLAB) != 0) 

  001d0	8a 4e 0c	 mov	 cl, BYTE PTR [esi+12]
  001d3	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  001d6	f6 c1 10	 test	 cl, 16			; 00000010H
  001d9	74 0b		 je	 SHORT $L72410

; 217  : 		{
; 218  : 			sleft = sthis;

  001db	89 44 24 10	 mov	 DWORD PTR _sleft$[esp+20], eax

; 219  : 			sthis = pp1->p_stress;

  001df	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  001e2	89 44 24 18	 mov	 DWORD PTR _sthis$[esp+16], eax
$L72410:

; 220  : 		}
; 221  : 		/*
; 222  : 		 * [x][l] => [L] / - +, [-Stress]
; 223  : 		 * [|][l] => [L] / - +, [-Stress]
; 224  : 		 */
; 225  : 		if (sthis==SUN && (ph1==US_AX || ph1==US_IX)) 

  001e6	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  001e9	75 35		 jne	 SHORT $L72787
  001eb	83 ff 11	 cmp	 edi, 17			; 00000011H
  001ee	74 05		 je	 SHORT $L72412
  001f0	83 ff 12	 cmp	 edi, 18			; 00000012H
  001f3	75 64		 jne	 SHORT $L72414
$L72412:

; 226  : 		{
; 227  : 			pp2 = pp1->p_fp;

  001f5	8b 06		 mov	 eax, DWORD PTR [esi]

; 228  : 			if (pp2->p_sphone == US_LL
; 229  : 			&& (pp2->p_flag&PFSYLAB) == 0
; 230  : 			&& (pp2->p_fp->p_flag&PFMORPH) != 0) 

  001f7	83 78 14 1b	 cmp	 DWORD PTR [eax+20], 27	; 0000001bH
  001fb	75 5c		 jne	 SHORT $L72414
  001fd	f6 40 0c 10	 test	 BYTE PTR [eax+12], 16	; 00000010H
  00201	75 56		 jne	 SHORT $L72414
  00203	8b 10		 mov	 edx, DWORD PTR [eax]
  00205	84 5a 0c	 test	 BYTE PTR [edx+12], bl
  00208	74 4f		 je	 SHORT $L72414

; 231  : 			{
; 232  : 				ls_adju_del_phone(pLts_t,pp2);

  0020a	50		 push	 eax
  0020b	55		 push	 ebp
  0020c	e8 00 00 00 00	 call	 _ls_adju_del_phone
  00211	83 c4 08	 add	 esp, 8

; 233  : 				pp1->p_sphone = US_EL;

  00214	c7 46 14 22 00
	00 00		 mov	 DWORD PTR [esi+20], 34	; 00000022H

; 234  : 				pp1 = pp1->p_fp;
; 235  : 				continue;

  0021b	e9 ff 02 00 00	 jmp	 $L72416
$L72787:

; 236  : 			}
; 237  : 		}
; 238  : 
; 239  : 		/*
; 240  : 		 * [l] => [L] / [+Obs] - +, [-Stress]
; 241  : 		 * [r] => [R] / [+Obs] - +, [-Stress]
; 242  : 		 */
; 243  : 
; 244  : 		if (sthis != SUN
; 245  : 		&& (ph1==US_LL || ph1==US_R)
; 246  : 		&& ls_adju_is_obs(pp1->p_bp) != FALSE
; 247  : 		&& (pp1->p_fp->p_flag&PFMORPH) != 0) 

  00220	83 ff 1b	 cmp	 edi, 27			; 0000001bH
  00223	74 05		 je	 SHORT $L72415
  00225	83 ff 1a	 cmp	 edi, 26			; 0000001aH
  00228	75 2f		 jne	 SHORT $L72414
$L72415:
  0022a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0022d	50		 push	 eax
  0022e	e8 00 00 00 00	 call	 _ls_adju_is_obs
  00233	83 c4 04	 add	 esp, 4
  00236	85 c0		 test	 eax, eax
  00238	74 1f		 je	 SHORT $L72414
  0023a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0023c	84 59 0c	 test	 BYTE PTR [ecx+12], bl
  0023f	74 18		 je	 SHORT $L72414

; 248  : 		{
; 249  : 			pp1->p_sphone = US_RR;
; 250  : 			if (ph1 == US_LL)

  00241	83 ff 1b	 cmp	 edi, 27			; 0000001bH
  00244	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00247	0f 85 d2 02 00
	00		 jne	 $L72416

; 251  : 				pp1->p_sphone = US_EL;

  0024d	c7 46 14 22 00
	00 00		 mov	 DWORD PTR [esi+20], 34	; 00000022H

; 252  : 			pp1 = pp1->p_fp;
; 253  : 			continue;

  00254	e9 c6 02 00 00	 jmp	 $L72416
$L72414:

; 254  : 		}
; 255  : 		/*
; 256  : 		 * [x][r] => [R]		(urge)
; 257  : 		 * [x][r][r] => [R]		(berry)
; 258  : 		 * [x][=][r] => [x][=][r]	(around)
; 259  : 		 * [x][r][=][r] => [x][=][r]	(arrange)
; 260  : 		 */
; 261  : 		if (ph1 == US_AX
; 262  : 		&& (pp2=pp1->p_fp)->p_sphone == US_R
; 263  : 		&& (pp2->p_flag&PFSYLAB) == 0)

  00259	83 ff 11	 cmp	 edi, 17			; 00000011H
  0025c	75 44		 jne	 SHORT $L72417
  0025e	8b 06		 mov	 eax, DWORD PTR [esi]
  00260	83 78 14 1a	 cmp	 DWORD PTR [eax+20], 26	; 0000001aH
  00264	0f 85 b5 02 00
	00		 jne	 $L72416
  0026a	f6 40 0c 10	 test	 BYTE PTR [eax+12], 16	; 00000010H
  0026e	0f 85 ab 02 00
	00		 jne	 $L72416

; 264  : 		{
; 265  : 			ls_adju_del_phone(pLts_t,pp2);

  00274	50		 push	 eax
  00275	55		 push	 ebp
  00276	e8 00 00 00 00	 call	 _ls_adju_del_phone

; 266  : 			if ((pp2=pp1->p_fp)->p_sphone == US_R)

  0027b	8b 06		 mov	 eax, DWORD PTR [esi]
  0027d	83 c4 08	 add	 esp, 8
  00280	83 78 14 1a	 cmp	 DWORD PTR [eax+20], 26	; 0000001aH
  00284	75 14		 jne	 SHORT $L72418

; 267  : 			{
; 268  : 				if ((pp2->p_flag&PFSYLAB) == 0)

  00286	f6 40 0c 10	 test	 BYTE PTR [eax+12], 16	; 00000010H
  0028a	0f 85 8f 02 00
	00		 jne	 $L72416

; 269  : 				{
; 270  : 					ls_adju_del_phone(pLts_t,pp2);

  00290	50		 push	 eax
  00291	55		 push	 ebp
  00292	e8 00 00 00 00	 call	 _ls_adju_del_phone
  00297	83 c4 08	 add	 esp, 8
$L72418:

; 271  : 					pp1->p_sphone = US_RR;
; 272  : 				}
; 273  : 
; 274  : 			} 
; 275  : 			else
; 276  : 			{
; 277  : 				pp1->p_sphone = US_RR;

  0029a	89 5e 14	 mov	 DWORD PTR [esi+20], ebx

; 278  : 			}
; 279  : 				pp1 = pp1->p_fp;
; 280  : 				continue;

  0029d	e9 7d 02 00 00	 jmp	 $L72416
$L72417:

; 281  : 		}
; 282  : 
; 283  : 		/*
; 284  : 		 * [n] => [n][y] / - [u][L] +
; 285  : 		 */
; 286  : 		/* 06 Hack.						*/
; 287  : 		if (ph1 == US_N) 

  002a2	83 ff 20	 cmp	 edi, 32			; 00000020H
  002a5	75 5d		 jne	 SHORT $L72426

; 288  : 		{
; 289  : 		 	if ((pp2=pp1->p_fp)->p_sphone == US_UW) 

  002a7	8b 3e		 mov	 edi, DWORD PTR [esi]
  002a9	83 7f 14 0e	 cmp	 DWORD PTR [edi+20], 14	; 0000000eH
  002ad	75 2e		 jne	 SHORT $L72789

; 290  : 		 	{
; 291  : 		  		if ((pp3=pp2->p_fp)->p_sphone == US_EL) 

  002af	8b 07		 mov	 eax, DWORD PTR [edi]
  002b1	83 78 14 22	 cmp	 DWORD PTR [eax+20], 34	; 00000022H
  002b5	75 26		 jne	 SHORT $L72789

; 292  : 		  		{
; 293  : 		   			if ((pp3->p_fp->p_flag&PFMORPH) != 0) 

  002b7	8b 10		 mov	 edx, DWORD PTR [eax]
  002b9	84 5a 0c	 test	 BYTE PTR [edx+12], bl
  002bc	74 1f		 je	 SHORT $L72789

; 294  : 		   			{
; 295  : 						if (ls_adju_ins_phone(pLts_t,pp2, US_Y, SIL, SNONE) == FALSE)

  002be	6a 7b		 push	 123			; 0000007bH
  002c0	6a 00		 push	 0
  002c2	6a 19		 push	 25			; 00000019H
  002c4	57		 push	 edi
  002c5	55		 push	 ebp
  002c6	e8 00 00 00 00	 call	 _ls_adju_ins_phone
  002cb	83 c4 14	 add	 esp, 20			; 00000014H
  002ce	85 c0		 test	 eax, eax
  002d0	0f 84 59 02 00
	00		 je	 $L72781

; 296  : 							return;
; 297  : 						pp1 = pp2;

  002d6	8b f7		 mov	 esi, edi

; 298  : 						continue;

  002d8	e9 44 02 00 00	 jmp	 $L72786
$L72789:

; 299  : 		   			}
; 300  : 		  		}
; 301  : 		 	}
; 302  : 		}
; 303  : 		/*
; 304  : 		 * [n] => [G] / - {[k],[g]}
; 305  : 		 */
; 306  : 		if (ph1 == US_N
; 307  : 		&& ((pp2=pp1->p_fp)->p_sphone==US_K || pp2->p_sphone==US_G)
; 308  : 		&& (pp2->p_flag&PFSYLAB) == 0) 

  002dd	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  002e0	83 f8 31	 cmp	 eax, 49			; 00000031H
  002e3	74 09		 je	 SHORT $L72427
  002e5	83 f8 32	 cmp	 eax, 50			; 00000032H
  002e8	0f 85 31 02 00
	00		 jne	 $L72416
$L72427:
  002ee	f6 47 0c 10	 test	 BYTE PTR [edi+12], 16	; 00000010H
  002f2	0f 85 27 02 00
	00		 jne	 $L72416

; 309  : 		{
; 310  : 			pp1->p_sphone = US_NX;

  002f8	c7 46 14 21 00
	00 00		 mov	 DWORD PTR [esi+20], 33	; 00000021H

; 311  : 			pp1 = pp1->p_fp;
; 312  : 			continue;	

  002ff	e9 1b 02 00 00	 jmp	 $L72416
$L72426:

; 313  : 		}
; 314  : 		/*
; 315  : 		 * More palatalization.
; 316  : 		 * [g] => [J] / - [|][z][x][m] +
; 317  : 		 *	      / - [A][z] +
; 318  : 		 *	      / - [|][s][t] +
; 319  : 		 *	      / - [|][d] +
; 320  : 		 * [k] => [s] / - [|][z][x][m] +
; 321  : 		 *	      / - [A][z] +
; 322  : 		 *	      / - [|][s][t] +
; 323  : 		 *	      / - [|][d] +
; 324  : 		 */
; 325  : 		if (ph1==US_G || ph1==US_K) 

  00304	83 ff 32	 cmp	 edi, 50			; 00000032H
  00307	74 31		 je	 SHORT $L72790
  00309	83 ff 31	 cmp	 edi, 49			; 00000031H
  0030c	0f 85 8d 00 00
	00		 jne	 $L72442

; 330  : 				ph1 = US_S;

  00312	bf 29 00 00 00	 mov	 edi, 41			; 00000029H
$L72431:

; 331  : 			pp2 = pp1->p_fp;

  00317	8b 06		 mov	 eax, DWORD PTR [esi]

; 332  : 			if (pp2->p_sphone == US_AY
; 333  : 			&& (pp2=pp2->p_fp)->p_sphone == US_Z
; 334  : 			&& (pp2->p_fp->p_flag&PFMORPH) != 0) 

  00319	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0031c	83 f9 07	 cmp	 ecx, 7
  0031f	75 20		 jne	 SHORT $L72432
  00321	8b 00		 mov	 eax, DWORD PTR [eax]
  00323	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00326	83 f9 2a	 cmp	 ecx, 42			; 0000002aH
  00329	75 16		 jne	 SHORT $L72432
  0032b	8b 10		 mov	 edx, DWORD PTR [eax]
  0032d	84 5a 0c	 test	 BYTE PTR [edx+12], bl
  00330	74 0f		 je	 SHORT $L72432

; 335  : 			{
; 336  : 				pp1->p_sphone = ph1;

  00332	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 337  : 				pp1 = pp1->p_fp;
; 338  : 				continue;

  00335	e9 e5 01 00 00	 jmp	 $L72416
$L72790:

; 326  : 		{
; 327  : 			if (ph1 == US_G)		/* [g] => [J]		*/
; 328  : 				ph1 = US_JH;

  0033a	bf 37 00 00 00	 mov	 edi, 55			; 00000037H

; 329  : 			else				/* [k] => [s]		*/

  0033f	eb d6		 jmp	 SHORT $L72431
$L72432:

; 339  : 			} /*if (pp2->p_sphone == AY */
; 340  : 			else
; 341  : 			{ 
; 342  : 				if (pp2->p_sphone == US_IX) 

  00341	83 f9 12	 cmp	 ecx, 18			; 00000012H
  00344	75 59		 jne	 SHORT $L72442

; 343  : 				{
; 344  : 					pp2 = pp2->p_fp;

  00346	8b 00		 mov	 eax, DWORD PTR [eax]

; 345  : 					if (pp2->p_sphone == US_D
; 346  : 					&& (pp2->p_fp->p_flag&PFMORPH) != 0) 

  00348	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0034b	83 fa 30	 cmp	 edx, 48			; 00000030H
  0034e	75 0f		 jne	 SHORT $L72435
  00350	8b 08		 mov	 ecx, DWORD PTR [eax]
  00352	84 59 0c	 test	 BYTE PTR [ecx+12], bl
  00355	74 08		 je	 SHORT $L72435

; 347  : 					{
; 348  : 						pp1->p_sphone = ph1;

  00357	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 349  : 						pp1 = pp1->p_fp;
; 350  : 						continue;

  0035a	e9 c0 01 00 00	 jmp	 $L72416
$L72435:

; 351  : 					}
; 352  : 					/* 06 Hack.				*/
; 353  : 					if (pp2->p_sphone == US_Z) {

  0035f	83 fa 2a	 cmp	 edx, 42			; 0000002aH
  00362	75 1f		 jne	 SHORT $L72439

; 354  : 				 		if ((pp3=pp2->p_fp)->p_sphone == US_AX) 

  00364	8b 08		 mov	 ecx, DWORD PTR [eax]
  00366	83 79 14 11	 cmp	 DWORD PTR [ecx+20], 17	; 00000011H
  0036a	75 17		 jne	 SHORT $L72439

; 355  : 				 		{
; 356  : 				  			if ((pp3=pp3->p_fp)->p_sphone == US_M) 

  0036c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0036e	83 79 14 1f	 cmp	 DWORD PTR [ecx+20], 31	; 0000001fH
  00372	75 0f		 jne	 SHORT $L72439

; 357  : 				  			{
; 358  : 				   				if ((pp3->p_fp->p_flag&PFMORPH) != 0) 

  00374	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00376	84 59 0c	 test	 BYTE PTR [ecx+12], bl
  00379	74 08		 je	 SHORT $L72439

; 359  : 				   				{
; 360  : 									pp1->p_sphone = ph1;

  0037b	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 361  : 									pp1 = pp1->p_fp;
; 362  : 									continue;

  0037e	e9 9c 01 00 00	 jmp	 $L72416
$L72439:

; 363  : 				   				}
; 364  : 				  			}
; 365  : 				 		}
; 366  : 					}
; 367  : 					/* 06 Hack.				*/
; 368  : 					if (pp2->p_sphone == US_S) 

  00383	83 fa 29	 cmp	 edx, 41			; 00000029H
  00386	75 17		 jne	 SHORT $L72442

; 369  : 					{
; 370  : 				 		if ((pp3=pp2->p_fp)->p_sphone == US_T) 

  00388	8b 00		 mov	 eax, DWORD PTR [eax]
  0038a	83 78 14 2f	 cmp	 DWORD PTR [eax+20], 47	; 0000002fH
  0038e	75 0f		 jne	 SHORT $L72442

; 371  : 				 		{
; 372  : 				  			if ((pp3->p_fp->p_flag&PFMORPH) != 0) 

  00390	8b 10		 mov	 edx, DWORD PTR [eax]
  00392	84 5a 0c	 test	 BYTE PTR [edx+12], bl
  00395	74 08		 je	 SHORT $L72442

; 373  : 				  			{
; 374  : 								pp1->p_sphone = ph1;

  00397	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 375  : 								pp1 = pp1->p_fp;
; 376  : 								continue;

  0039a	e9 80 01 00 00	 jmp	 $L72416
$L72442:

; 377  : 				  			}
; 378  : 				 		}
; 379  : 					}
; 380  : 				}		/*	if (pp2->p_sphone == IX)  */
; 381  : 			}/* if (pp2->p_sphone == AY */
; 382  : 		}/* 		if (ph1==G || ph1==K) */
; 383  : 		/*
; 384  : 		 * D rules.
; 385  : 		 */
; 386  : 		if (ph1 == US_D) 

  0039f	83 ff 30	 cmp	 edi, 48			; 00000030H
  003a2	75 36		 jne	 SHORT $L72444

; 387  : 		{
; 388  : 			/*
; 389  : 			 * [d] => [J] / - [u][l] +
; 390  : 			 * [d] => [J] / - [u][L] +
; 391  : 			 */
; 392  : 			if ((pp2=pp1->p_fp)->p_sphone == US_UW
; 393  : 			&& ((pp2=pp2->p_fp)->p_sphone == US_LL
; 394  : 			|| pp2->p_sphone == US_EL)
; 395  : 			&& (pp2->p_fp->p_flag&PFMORPH) != 0) 

  003a4	8b 06		 mov	 eax, DWORD PTR [esi]
  003a6	83 78 14 0e	 cmp	 DWORD PTR [eax+20], 14	; 0000000eH
  003aa	0f 85 6f 01 00
	00		 jne	 $L72416
  003b0	8b 08		 mov	 ecx, DWORD PTR [eax]
  003b2	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  003b5	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  003b8	74 09		 je	 SHORT $L72445
  003ba	83 f8 22	 cmp	 eax, 34			; 00000022H
  003bd	0f 85 5c 01 00
	00		 jne	 $L72416
$L72445:
  003c3	8b 01		 mov	 eax, DWORD PTR [ecx]
  003c5	84 58 0c	 test	 BYTE PTR [eax+12], bl
  003c8	0f 84 51 01 00
	00		 je	 $L72416

; 396  : 			{
; 397  : 				pp1->p_sphone = US_JH;

  003ce	c7 46 14 37 00
	00 00		 mov	 DWORD PTR [esi+20], 55	; 00000037H

; 398  : 				pp1 = pp1->p_fp;
; 399  : 				continue;

  003d5	e9 45 01 00 00	 jmp	 $L72416
$L72444:

; 400  : 			}
; 401  : 		}
; 402  : 		/*
; 403  : 		 * S rules.
; 404  : 		 */
; 405  : 		if (ph1 == US_S) 

  003da	83 ff 29	 cmp	 edi, 41			; 00000029H
  003dd	0f 85 8f 00 00
	00		 jne	 $L72455

; 406  : 		{
; 407  : 			/*
; 408  : 			 * [k][s] => [g][z] / [|] - [+Voc,+Stress]
; 409  : 			 */
; 410  : 			if ((pp2=pp1->p_bp)->p_sphone == US_K
; 411  : 			&& pp2->p_bp->p_sphone == US_IX
; 412  : 			&& sleft == SUN
; 413  : 			&& ls_adju_is_voc(pp1->p_fp) != FALSE
; 414  : 			&& sthis != SUN) 

  003e3	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  003e6	83 7f 14 31	 cmp	 DWORD PTR [edi+20], 49	; 00000031H
  003ea	75 39		 jne	 SHORT $L72447
  003ec	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  003ef	83 79 14 12	 cmp	 DWORD PTR [ecx+20], 18	; 00000012H
  003f3	75 30		 jne	 SHORT $L72447
  003f5	83 7c 24 10 7c	 cmp	 DWORD PTR _sleft$[esp+20], 124 ; 0000007cH
  003fa	75 29		 jne	 SHORT $L72447
  003fc	8b 16		 mov	 edx, DWORD PTR [esi]
  003fe	52		 push	 edx
  003ff	e8 00 00 00 00	 call	 _ls_adju_is_voc
  00404	83 c4 04	 add	 esp, 4
  00407	85 c0		 test	 eax, eax
  00409	74 1a		 je	 SHORT $L72447
  0040b	83 7c 24 18 7c	 cmp	 DWORD PTR _sthis$[esp+16], 124 ; 0000007cH
  00410	74 13		 je	 SHORT $L72447

; 415  : 			{
; 416  : 				pp2->p_sphone = US_G;

  00412	c7 47 14 32 00
	00 00		 mov	 DWORD PTR [edi+20], 50	; 00000032H

; 417  : 				pp1->p_sphone = US_Z;

  00419	c7 46 14 2a 00
	00 00		 mov	 DWORD PTR [esi+20], 42	; 0000002aH

; 418  : 				continue;

  00420	e9 fc 00 00 00	 jmp	 $L72786
$L72447:

; 419  : 			}
; 420  : 			/*
; 421  : 			 * [s][s] => [S] / - [u] +
; 422  : 			 */
; 423  : 			/* 06 Hack.					*/
; 424  : 			if ((pp2=pp1->p_bp)->p_sphone == US_S) 

  00425	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00428	83 78 14 29	 cmp	 DWORD PTR [eax+20], 41	; 00000029H
  0042c	75 13		 jne	 SHORT $L72450

; 425  : 			{
; 426  : 			 	if ((pp3=pp1->p_fp)->p_sphone == US_UW) 

  0042e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00430	83 79 14 0e	 cmp	 DWORD PTR [ecx+20], 14	; 0000000eH
  00434	75 0b		 jne	 SHORT $L72450

; 427  : 			 	{
; 428  : 			  		if ((pp3->p_fp->p_flag&PFMORPH) != 0) 

  00436	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00438	84 59 0c	 test	 BYTE PTR [ecx+12], bl

; 429  : 			  		{
; 430  : 						if ((pp2->p_flag&PFSYLAB) != 0)
; 431  : 							return;
; 432  : 						ls_adju_del_phone(pLts_t,pp2);
; 433  : 						pp1->p_sphone = US_SH;
; 434  : 						pp1 = pp1->p_fp;
; 435  : 						continue;

  0043b	0f 85 aa 00 00
	00		 jne	 $L72792
$L72450:

; 436  : 			  		}
; 437  : 			 	}
; 438  : 			}
; 439  : 			/*
; 440  : 			 * [s][i] => [S] / - [x][s] +
; 441  : 			 */
; 442  : 			/* 06 Hack.					*/
; 443  : 			if ((pp2=pp1->p_fp)->p_sphone == US_IY) 

  00441	8b 06		 mov	 eax, DWORD PTR [esi]
  00443	83 78 14 01	 cmp	 DWORD PTR [eax+20], 1
  00447	0f 85 d2 00 00
	00		 jne	 $L72416

; 444  : 			{
; 445  : 			 	if ((pp3=pp2->p_fp)->p_sphone == US_AX) 

  0044d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0044f	83 79 14 11	 cmp	 DWORD PTR [ecx+20], 17	; 00000011H
  00453	0f 85 c6 00 00
	00		 jne	 $L72416

; 446  : 			 	{
; 447  : 			 		if ((pp4=pp3->p_fp)->p_sphone == US_S) 

  00459	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0045b	83 79 14 29	 cmp	 DWORD PTR [ecx+20], 41	; 00000029H
  0045f	0f 85 ba 00 00
	00		 jne	 $L72416

; 448  : 			 		{
; 449  : 					   	if ((pp4->p_fp->p_flag&PFMORPH) != 0) 

  00465	8b 11		 mov	 edx, DWORD PTR [ecx]
  00467	84 5a 0c	 test	 BYTE PTR [edx+12], bl
  0046a	0f 84 af 00 00
	00		 je	 $L72416

; 450  : 					   	{
; 451  : 							if ((pp2->p_flag&PFSYLAB) != 0)
; 452  : 								return;
; 453  : 							ls_adju_del_phone(pLts_t,pp2);
; 454  : 							pp1->p_sphone = US_SH;
; 455  : 							pp1 = pp1->p_fp;
; 456  : 							continue;

  00470	eb 79		 jmp	 SHORT $L72792
$L72455:

; 457  : 			 		  	}
; 458  : 			 		}
; 459  : 			 	}
; 460  : 			}
; 461  : 		}/* 		if (ph1 == S) */
; 462  : 
; 463  : 		/*
; 464  : 		 * T rules.
; 465  : 		 */
; 466  : 		if (ph1 == US_T) 

  00472	83 ff 2f	 cmp	 edi, 47			; 0000002fH
  00475	0f 85 a4 00 00
	00		 jne	 $L72416

; 467  : 		{
; 468  : 			pp2 = pp1->p_fp;

  0047b	8b 06		 mov	 eax, DWORD PTR [esi]

; 469  : 			/*
; 470  : 			 * [t] => [C] / - [u][e][r][i] +
; 471  : 			 * [t] => [C] / - [u][L] +
; 472  : 			 * ; MGS this one is not good
; 473  : 			 * ; [t] => [C] / - [u] +
; 474  : 			 */
; 475  : 			if (pp2->p_sphone == US_UW) 

  0047d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00480	83 f9 0e	 cmp	 ecx, 14			; 0000000eH
  00483	75 50		 jne	 SHORT $L72458

; 476  : 			{
; 477  : 				pp3 = pp2->p_fp;

  00485	8b 00		 mov	 eax, DWORD PTR [eax]

; 478  : 				if ((pp3->p_flag&PFMORPH) != 0) 

  00487	84 58 0c	 test	 BYTE PTR [eax+12], bl
  0048a	74 0c		 je	 SHORT $L72459

; 479  : 				{
; 480  : 					pp1->p_sphone = US_CH;

  0048c	c7 46 14 36 00
	00 00		 mov	 DWORD PTR [esi+20], 54	; 00000036H

; 481  : 					pp1 = pp1->p_fp;
; 482  : 					continue;

  00493	e9 87 00 00 00	 jmp	 $L72416
$L72459:

; 483  : 				} 
; 484  : 				/* 06 Hack.				*/
; 485  : 				if (pp3->p_sphone == US_EL) 

  00498	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0049b	83 f9 22	 cmp	 ecx, 34			; 00000022H
  0049e	75 10		 jne	 SHORT $L72461

; 486  : 				{
; 487  : 				 	if ((pp3->p_fp->p_flag&PFMORPH) != 0) 

  004a0	8b 10		 mov	 edx, DWORD PTR [eax]
  004a2	84 5a 0c	 test	 BYTE PTR [edx+12], bl
  004a5	74 09		 je	 SHORT $L72461

; 488  : 				 	{
; 489  : 						pp1->p_sphone = US_CH;

  004a7	c7 46 14 36 00
	00 00		 mov	 DWORD PTR [esi+20], 54	; 00000036H

; 490  : 						pp1 = pp1->p_fp;
; 491  : 						continue;

  004ae	eb 6f		 jmp	 SHORT $L72416
$L72461:

; 492  : 				 	}
; 493  : 				}
; 494  : 				/* 06 Hack.				*/
; 495  : 				if (pp3->p_sphone == US_EY) 

  004b0	83 f9 03	 cmp	 ecx, 3
  004b3	75 6a		 jne	 SHORT $L72416

; 496  : 				{
; 497  : 				 	if ((pp4=pp3->p_fp)->p_sphone == US_R) 

  004b5	8b 00		 mov	 eax, DWORD PTR [eax]
  004b7	83 78 14 1a	 cmp	 DWORD PTR [eax+20], 26	; 0000001aH
  004bb	75 62		 jne	 SHORT $L72416

; 498  : 				 	{
; 499  : 				  		if ((pp4=pp4->p_fp)->p_sphone == US_IY) 

  004bd	8b 00		 mov	 eax, DWORD PTR [eax]
  004bf	83 78 14 01	 cmp	 DWORD PTR [eax+20], 1
  004c3	75 5a		 jne	 SHORT $L72416

; 500  : 				  		{
; 501  : 				   			if ((pp4->p_fp->p_flag&PFMORPH) != 0) 

  004c5	8b 00		 mov	 eax, DWORD PTR [eax]
  004c7	84 58 0c	 test	 BYTE PTR [eax+12], bl
  004ca	74 53		 je	 SHORT $L72416

; 502  : 				   			{
; 503  : 								pp1->p_sphone = US_CH;

  004cc	c7 46 14 36 00
	00 00		 mov	 DWORD PTR [esi+20], 54	; 00000036H

; 504  : 								pp1 = pp1->p_fp;
; 505  : 								continue;

  004d3	eb 4a		 jmp	 SHORT $L72416
$L72458:

; 506  : 				   			}
; 507  : 				  		}
; 508  : 				 	}
; 509  : 				}
; 510  : 			/*
; 511  : 			 * [t][i] => [S] / - [x] +
; 512  : 			 * [t] => [S] / - [i][e][t][R] +
; 513  : 			 */
; 514  : 			}	/* if (pp2->p_sphone == UW)*/ 
; 515  : 			else 
; 516  : 			{
; 517  : 				if (pp2->p_sphone == US_IY) 

  004d5	83 f9 01	 cmp	 ecx, 1
  004d8	75 45		 jne	 SHORT $L72416

; 518  : 				{
; 519  : 					pp3 = pp2->p_fp;

  004da	8b 08		 mov	 ecx, DWORD PTR [eax]

; 520  : 					if (pp3->p_sphone == US_AX
; 521  : 					&& (pp3->p_fp->p_flag&PFMORPH) != 0) 

  004dc	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  004df	83 fa 11	 cmp	 edx, 17			; 00000011H
  004e2	75 19		 jne	 SHORT $L72468
  004e4	8b 39		 mov	 edi, DWORD PTR [ecx]
  004e6	84 5f 0c	 test	 BYTE PTR [edi+12], bl
  004e9	74 12		 je	 SHORT $L72468
$L72792:

; 522  : 					{
; 523  : 						if ((pp2->p_flag&PFSYLAB) != 0)

  004eb	f6 40 0c 10	 test	 BYTE PTR [eax+12], 16	; 00000010H
  004ef	75 3e		 jne	 SHORT $L72781

; 524  : 							return;
; 525  : 						ls_adju_del_phone(pLts_t,pp2);

  004f1	50		 push	 eax
  004f2	55		 push	 ebp
  004f3	e8 00 00 00 00	 call	 _ls_adju_del_phone
  004f8	83 c4 08	 add	 esp, 8

; 526  : 						pp1->p_sphone = US_SH;
; 527  : 						pp1 = pp1->p_fp;
; 528  : 						continue;

  004fb	eb 1b		 jmp	 SHORT $L72793
$L72468:

; 529  : 					}
; 530  : 					/* 06 Hack.				*/
; 531  : 					if (pp3->p_sphone == US_EY) {

  004fd	83 fa 03	 cmp	 edx, 3
  00500	75 1d		 jne	 SHORT $L72416

; 532  : 				 	if ((pp4=pp3->p_fp)->p_sphone == US_T) {

  00502	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00504	83 79 14 2f	 cmp	 DWORD PTR [ecx+20], 47	; 0000002fH
  00508	75 15		 jne	 SHORT $L72416

; 533  : 				  	if ((pp4=pp4->p_fp)->p_sphone == US_RR) {

  0050a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0050c	39 59 14	 cmp	 DWORD PTR [ecx+20], ebx
  0050f	75 0e		 jne	 SHORT $L72416

; 534  : 				   	if ((pp4->p_fp->p_flag&PFMORPH) != 0) {

  00511	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00513	84 59 0c	 test	 BYTE PTR [ecx+12], bl
  00516	74 07		 je	 SHORT $L72416
$L72793:

; 535  : 						pp1->p_sphone = US_SH;

  00518	c7 46 14 2b 00
	00 00		 mov	 DWORD PTR [esi+20], 43	; 0000002bH
$L72416:

; 536  : 						pp1 = pp1->p_fp;
; 537  : 						continue;
; 538  : 				   	}
; 539  : 				  	}
; 540  : 				 	}
; 541  : 					}
; 542  : 				}/*	if (pp2->p_sphone == IY) */
; 543  : 			}	/* if (pp2->p_sphone == UW)*/ 
; 544  : 		}	/*	if (ph1 == T)*/
; 545  : 		pp1 = pp1->p_fp;

  0051f	8b 36		 mov	 esi, DWORD PTR [esi]
$L72786:

; 213  : 	while (pp1 != &pLts_t->phead) 

  00521	8d 85 c8 08 00
	00		 lea	 eax, DWORD PTR [ebp+2248]
  00527	3b f0		 cmp	 esi, eax
  00529	0f 85 9d fc ff
	ff		 jne	 $L72791
$L72781:
  0052f	5f		 pop	 edi
  00530	5e		 pop	 esi
  00531	5d		 pop	 ebp
  00532	5b		 pop	 ebx

; 546  : 	}/* 	while ((int)pp1 != (int)&pLts_t->phead) */
; 547  : 	
; 548  : }

  00533	59		 pop	 ecx
  00534	c3		 ret	 0
_ls_adju_allo2 ENDP
_TEXT	ENDS
PUBLIC	_ls_adju_sylables
PUBLIC	_ls_adju_is_cons
_TEXT	SEGMENT
_fpp$ = 8
_lpp$ = 12
_lsp$ = -4
_stype$ = 12
_ls_adju_sylables PROC NEAR

; 140  : {

  00540	51		 push	 ecx

; 141  : 	 PHONE	*pp1;
; 142  : 	 PHONE	*pp2;
; 143  : 	 PHONE	*lsp;
; 144  : 	 int	type;
; 145  : 	 int	stype;
; 146  : 
; 147  : 	lsp = NULL;				/* Last sylable pointer	*/
; 148  : 	pp1 = fpp;				/* Start of word.	*/
; 149  : 	while (pp1 != lpp) 

  00541	8b 44 24 0c	 mov	 eax, DWORD PTR _lpp$[esp]
  00545	53		 push	 ebx
  00546	8b 5c 24 0c	 mov	 ebx, DWORD PTR _fpp$[esp+4]
  0054a	55		 push	 ebp
  0054b	56		 push	 esi
  0054c	57		 push	 edi
  0054d	3b d8		 cmp	 ebx, eax
  0054f	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _lsp$[esp+20], 0
  00557	8b fb		 mov	 edi, ebx
  00559	0f 84 c0 01 00
	00		 je	 $L72500
$L72495:

; 150  : 	{
; 151  : 		if ((pp1->p_flag&PFSYLAB) != 0) 

  0055f	f6 47 0c 10	 test	 BYTE PTR [edi+12], 16	; 00000010H
  00563	75 08		 jne	 SHORT $L72798

; 154  : 			break;
; 155  : 		}
; 156  : 		pp1 = pp1->p_fp;

  00565	8b 3f		 mov	 edi, DWORD PTR [edi]
  00567	3b f8		 cmp	 edi, eax
  00569	75 f4		 jne	 SHORT $L72495

; 173  : 		if (pp1 == fpp) 

  0056b	eb 04		 jmp	 SHORT $L72796
$L72798:

; 152  : 		{
; 153  : 			lsp = pp1;

  0056d	89 7c 24 10	 mov	 DWORD PTR _lsp$[esp+20], edi
$L72796:

; 157  : 	}
; 158  : 	while (pp1 != fpp) 

  00571	3b fb		 cmp	 edi, ebx
  00573	0f 84 a6 01 00
	00		 je	 $L72500
$L72499:

; 159  : 	{						/* Until start of word.	*/
; 160  : 		stype = SNONE;		/* Not set.		*/
; 161  : 		do 
; 162  : 		{					/* Backup to vowel	*/
; 163  : 			pp2 = pp1->p_bp;

  00579	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0057c	bd 7b 00 00 00	 mov	 ebp, 123		; 0000007bH

; 164  : 			if (ls_adju_is_cons(pp2) == FALSE)

  00581	56		 push	 esi
  00582	89 6c 24 20	 mov	 DWORD PTR _stype$[esp+20], ebp
  00586	e8 00 00 00 00	 call	 _ls_adju_is_cons
  0058b	83 c4 04	 add	 esp, 4
  0058e	85 c0		 test	 eax, eax
  00590	74 28		 je	 SHORT $L72503
$L72501:

; 165  : 				break;
; 166  : 			pp1 = pp2;
; 167  : 			if (pp1->p_stress != SNONE) 

  00592	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00595	8b fe		 mov	 edi, esi
  00597	3b c5		 cmp	 eax, ebp
  00599	74 07		 je	 SHORT $L72502

; 168  : 			{
; 169  : 				stype = pp1->p_stress;

  0059b	89 44 24 1c	 mov	 DWORD PTR _stype$[esp+16], eax

; 170  : 				pp1->p_stress = SNONE;

  0059f	89 6e 10	 mov	 DWORD PTR [esi+16], ebp
$L72502:

; 171  : 			}
; 172  : 		} while (pp1 != fpp);

  005a2	3b f3		 cmp	 esi, ebx
  005a4	0f 84 4b 01 00
	00		 je	 $L72800
  005aa	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  005ad	56		 push	 esi
  005ae	e8 00 00 00 00	 call	 _ls_adju_is_cons
  005b3	83 c4 04	 add	 esp, 4
  005b6	85 c0		 test	 eax, eax
  005b8	75 d8		 jne	 SHORT $L72501
$L72503:

; 173  : 		if (pp1 == fpp) 

  005ba	3b fb		 cmp	 edi, ebx
  005bc	0f 84 33 01 00
	00		 je	 $L72800

; 183  : 			break;
; 184  : 		} 
; 185  : 		pp1 = pp1->p_bp;			/* Point at vowel	*/

  005c2	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]

; 186  : 		pp1->p_flag |= PFLEFTC;		/* In left cluster.	*/

  005c5	8b 6f 0c	 mov	 ebp, DWORD PTR [edi+12]
  005c8	8d 77 0c	 lea	 esi, DWORD PTR [edi+12]

; 187  : 		if (pp1->p_stress != SNONE) 

  005cb	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  005ce	83 cd 40	 or	 ebp, 64			; 00000040H
  005d1	89 2e		 mov	 DWORD PTR [esi], ebp
  005d3	8b cd		 mov	 ecx, ebp
  005d5	8d 6f 10	 lea	 ebp, DWORD PTR [edi+16]
  005d8	83 f8 7b	 cmp	 eax, 123		; 0000007bH
  005db	74 0b		 je	 SHORT $L72509

; 188  : 		{
; 189  : 			stype = pp1->p_stress;

  005dd	89 44 24 1c	 mov	 DWORD PTR _stype$[esp+16], eax

; 190  : 			pp1->p_stress = SNONE;

  005e1	c7 45 00 7b 00
	00 00		 mov	 DWORD PTR [ebp], 123	; 0000007bH
$L72509:

; 191  : 		}
; 192  : 		if ((pp1->p_flag&PFMORPH) != 0	/* Explicit morpheme	*/
; 193  : 		|| pp1 == fpp					/* or start of word	*/
; 194  : 		|| ls_adju_is_cons(pp2=pp1->p_bp) == FALSE)

  005e8	f6 c1 0f	 test	 cl, 15			; 0000000fH
  005eb	0f 85 e4 00 00
	00		 jne	 $out$72512
  005f1	3b fb		 cmp	 edi, ebx
  005f3	0f 84 dc 00 00
	00		 je	 $out$72512
  005f9	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  005fc	53		 push	 ebx
  005fd	e8 00 00 00 00	 call	 _ls_adju_is_cons
  00602	83 c4 04	 add	 esp, 4
  00605	85 c0		 test	 eax, eax
  00607	0f 84 c4 00 00
	00		 je	 $L72804

; 195  : 		{
; 196  : 			goto out;
; 197  : 		}
; 198  : 		pp1 = pp2;					/* One consonant	*/
; 199  : 
; 200  : 		pp1->p_flag |= PFLEFTC;		/* In left cluster.	*/

  0060d	8b 6b 0c	 mov	 ebp, DWORD PTR [ebx+12]
  00610	8d 73 0c	 lea	 esi, DWORD PTR [ebx+12]

; 201  : 		if (pp1->p_stress != SNONE) 

  00613	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00616	83 cd 40	 or	 ebp, 64			; 00000040H
  00619	89 2e		 mov	 DWORD PTR [esi], ebp
  0061b	8b cd		 mov	 ecx, ebp
  0061d	8d 6b 10	 lea	 ebp, DWORD PTR [ebx+16]
  00620	83 f8 7b	 cmp	 eax, 123		; 0000007bH
  00623	8b fb		 mov	 edi, ebx
  00625	74 0b		 je	 SHORT $L72513

; 202  : 		{
; 203  : 			stype = pp1->p_stress;

  00627	89 44 24 1c	 mov	 DWORD PTR _stype$[esp+16], eax

; 204  : 			pp1->p_stress = SNONE;

  0062b	c7 45 00 7b 00
	00 00		 mov	 DWORD PTR [ebp], 123	; 0000007bH
$L72513:

; 205  : 		}
; 206  : 		if ((pp1->p_flag&PFMORPH) != 0	/* Explicit morpheme	*/
; 207  : 		|| pp1 == fpp					/* or start of word.	*/
; 208  : 		|| ls_adju_is_cons(pp2=pp1->p_bp) == FALSE)

  00632	f6 c1 0f	 test	 cl, 15			; 0000000fH
  00635	0f 85 96 00 00
	00		 jne	 $L72804
  0063b	3b 5c 24 18	 cmp	 ebx, DWORD PTR _fpp$[esp+16]
  0063f	0f 84 8c 00 00
	00		 je	 $L72804
  00645	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  00648	53		 push	 ebx
  00649	e8 00 00 00 00	 call	 _ls_adju_is_cons
  0064e	83 c4 04	 add	 esp, 4
  00651	85 c0		 test	 eax, eax
  00653	74 7c		 je	 SHORT $L72804

; 209  : 		{
; 210  : 			goto out;
; 211  : 		}
; 212  : 		type = ls_adju_cluster(pp2->p_sphone, pp1->p_sphone);

  00655	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00658	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  0065b	50		 push	 eax
  0065c	51		 push	 ecx
  0065d	e8 00 00 00 00	 call	 _ls_adju_cluster
  00662	83 c4 08	 add	 esp, 8

; 213  : 		if (type == ILLEGAL)			/* Not allowed		*/

  00665	85 c0		 test	 eax, eax
  00667	74 68		 je	 SHORT $L72804

; 214  : 		{
; 215  : 			goto out;
; 216  : 		}
; 217  : 		pp1 = pp2;					/* Two consonants	*/
; 218  : 
; 219  : 		pp1->p_flag |= PFLEFTC;		/* In left cluster.	*/

  00669	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0066c	8d 73 0c	 lea	 esi, DWORD PTR [ebx+12]
  0066f	83 c9 40	 or	 ecx, 64			; 00000040H

; 220  : 		if (pp1->p_stress != SNONE) 

  00672	8d 6b 10	 lea	 ebp, DWORD PTR [ebx+16]
  00675	89 0e		 mov	 DWORD PTR [esi], ecx
  00677	8b d1		 mov	 edx, ecx
  00679	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  0067c	8b fb		 mov	 edi, ebx
  0067e	83 f9 7b	 cmp	 ecx, 123		; 0000007bH
  00681	74 0b		 je	 SHORT $L72517

; 221  : 		{
; 222  : 			stype = pp1->p_stress;

  00683	89 4c 24 1c	 mov	 DWORD PTR _stype$[esp+16], ecx

; 223  : 			pp1->p_stress = SNONE;

  00687	c7 45 00 7b 00
	00 00		 mov	 DWORD PTR [ebp], 123	; 0000007bH
$L72517:

; 224  : 		}
; 225  : 		if (type == TRYS				/* If "s" or "S" good	*/
; 226  : 		&& (pp1->p_flag&PFMORPH) == 0	/* check for it.	*/
; 227  : 		&& pp1 != fpp
; 228  : #ifdef ENGLISH_US
; 229  : 		&& ((pp2=pp1->p_bp)->p_sphone==US_S || pp2->p_sphone==US_SH)) 

  0068e	83 f8 02	 cmp	 eax, 2
  00691	75 3e		 jne	 SHORT $L72804
  00693	f6 c2 0f	 test	 dl, 15			; 0000000fH
  00696	75 39		 jne	 SHORT $L72804
  00698	3b 5c 24 18	 cmp	 ebx, DWORD PTR _fpp$[esp+16]
  0069c	74 33		 je	 SHORT $L72804
  0069e	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  006a1	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  006a4	83 f8 29	 cmp	 eax, 41			; 00000029H
  006a7	74 05		 je	 SHORT $L72519
  006a9	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  006ac	75 23		 jne	 SHORT $L72804
$L72519:

; 230  : #endif
; 231  : #ifdef ENGLISH_UK
; 232  : 		&& ((pp2=pp1->p_bp)->p_sphone==UK_S || pp2->p_sphone==UK_SH)) 
; 233  : #endif
; 234  : #ifdef GERMAN
; 235  : 		&& ((pp2=pp1->p_bp)->p_sphone==GR_S || pp2->p_sphone==GR_SH)) 
; 236  : #endif
; 237  : 
; 238  : 		{
; 239  : 			pp1 = pp2;					/* Include it.		*/
; 240  : 			pp1->p_flag |= PFLEFTC;

  006ae	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]

; 241  : 			if (pp1->p_stress != SNONE) 

  006b1	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  006b4	8d 73 0c	 lea	 esi, DWORD PTR [ebx+12]
  006b7	8d 6b 10	 lea	 ebp, DWORD PTR [ebx+16]
  006ba	83 ca 40	 or	 edx, 64			; 00000040H
  006bd	83 f8 7b	 cmp	 eax, 123		; 0000007bH
  006c0	8b fb		 mov	 edi, ebx
  006c2	89 16		 mov	 DWORD PTR [esi], edx
  006c4	74 0b		 je	 SHORT $L72804

; 242  : 			{
; 243  : 				stype = pp1->p_stress;

  006c6	89 44 24 1c	 mov	 DWORD PTR _stype$[esp+16], eax

; 244  : 				pp1->p_stress = SNONE;

  006ca	c7 45 00 7b 00
	00 00		 mov	 DWORD PTR [ebp], 123	; 0000007bH
$L72804:
  006d1	8b 5c 24 18	 mov	 ebx, DWORD PTR _fpp$[esp+16]
$out$72512:

; 245  : 			}
; 246  : 		}
; 247  : 	out:
; 248  : 
; 249  : 		pp1->p_flag |= PFSYLAB;		/* Mark sylable		*/

  006d5	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 250  : 		pp1->p_stress = stype;		/* (may set stress)	*/

  006d7	8b 54 24 1c	 mov	 edx, DWORD PTR _stype$[esp+16]
  006db	83 c9 10	 or	 ecx, 16			; 00000010H
  006de	3b fb		 cmp	 edi, ebx
  006e0	89 0e		 mov	 DWORD PTR [esi], ecx
  006e2	89 55 00	 mov	 DWORD PTR [ebp], edx

; 251  : 		lsp = pp1;					/* Remember last one	*/

  006e5	89 7c 24 10	 mov	 DWORD PTR _lsp$[esp+20], edi
  006e9	0f 85 8a fe ff
	ff		 jne	 $L72499
  006ef	5f		 pop	 edi
  006f0	5e		 pop	 esi
  006f1	5d		 pop	 ebp
  006f2	5b		 pop	 ebx

; 252  : 	}
; 253  : 	return;
; 254  : }

  006f3	59		 pop	 ecx
  006f4	c3		 ret	 0
$L72800:

; 174  : 		{					/* "gdansk", "gxx"	*/
; 175  : 			if (lsp != NULL) 

  006f5	8b 44 24 10	 mov	 eax, DWORD PTR _lsp$[esp+20]
  006f9	85 c0		 test	 eax, eax
  006fb	74 13		 je	 SHORT $L72508

; 176  : 			{
; 177  : 				lsp->p_flag &= ~PFSYLAB;

  006fd	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00700	83 e1 ef	 and	 ecx, -17		; ffffffefH
  00703	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 178  : 				stype = lsp->p_stress;

  00706	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00709	89 4c 24 1c	 mov	 DWORD PTR _stype$[esp+16], ecx

; 179  : 				lsp->p_stress = SNONE;

  0070d	89 68 10	 mov	 DWORD PTR [eax+16], ebp
$L72508:

; 180  : 			}
; 181  : 			pp1->p_flag |= PFSYLAB;

  00710	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]

; 182  : 			pp1->p_stress = stype;

  00713	8b 54 24 1c	 mov	 edx, DWORD PTR _stype$[esp+16]
  00717	0c 10		 or	 al, 16			; 00000010H
  00719	89 57 10	 mov	 DWORD PTR [edi+16], edx
  0071c	89 47 0c	 mov	 DWORD PTR [edi+12], eax
$L72500:
  0071f	5f		 pop	 edi
  00720	5e		 pop	 esi
  00721	5d		 pop	 ebp
  00722	5b		 pop	 ebx

; 252  : 	}
; 253  : 	return;
; 254  : }

  00723	59		 pop	 ecx
  00724	c3		 ret	 0
_ls_adju_sylables ENDP
_TEXT	ENDS
EXTRN	_pfeat:BYTE
_TEXT	SEGMENT
_pp$ = 8
_ls_adju_is_cons PROC NEAR

; 274  : 	if ((pfeat[pp->p_sphone]&PCONS) != 0)

  00730	8b 44 24 04	 mov	 eax, DWORD PTR _pp$[esp-4]
  00734	33 d2		 xor	 edx, edx
  00736	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00739	8a 14 4d 00 00
	00 00		 mov	 dl, BYTE PTR _pfeat[ecx*2]
  00740	8b c2		 mov	 eax, edx
  00742	83 e0 01	 and	 eax, 1

; 275  : 		return (TRUE);
; 276  : 	return (FALSE);
; 277  : }                

  00745	c3		 ret	 0
_ls_adju_is_cons ENDP
_pp$ = 8
_ls_adju_is_voc PROC NEAR

; 297  : 	if ((pfeat[pp->p_sphone]&PVOC) != 0)

  00750	8b 44 24 04	 mov	 eax, DWORD PTR _pp$[esp-4]
  00754	33 d2		 xor	 edx, edx
  00756	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00759	8a 14 4d 00 00
	00 00		 mov	 dl, BYTE PTR _pfeat[ecx*2]
  00760	8b c2		 mov	 eax, edx
  00762	d1 e8		 shr	 eax, 1
  00764	83 e0 01	 and	 eax, 1

; 298  : 		return (TRUE);
; 299  : 	return (FALSE);
; 300  : }                

  00767	c3		 ret	 0
_ls_adju_is_voc ENDP
_TEXT	ENDS
PUBLIC	_ls_adju_stress
PUBLIC	_ls_adju_unstressed
PUBLIC	_ls_adju_suffixscan
PUBLIC	_ls_adju_prefixscan
PUBLIC	_ls_adju_bestdefault
PUBLIC	_ls_adju_final_fixes
EXTRN	_lsa_util_stress_sp:NEAR
EXTRN	_lsa_util_stress_sl:NEAR
EXTRN	_lsa_util_stress_ja:NEAR
EXTRN	_lsa_util_stress_it:NEAR
EXTRN	_lsa_util_stress_gr:NEAR
EXTRN	_lsa_util_stress_fr:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_fpp$ = 12
_lpp$ = 16
_pstype$ = 20
_sel_lang$ = 24
_ls_adju_stress PROC NEAR

; 329  : {

  00770	53		 push	 ebx

; 330  : 	 int	csyl;
; 331  : 	 int	type;
; 332  : 	 int	isreduced;
; 333  : 	 PLTS_T pLts_t;               
; 334  : 	 PKSD_T pKsd_t;
; 335  : 	 pLts_t=phTTS->pLTSThreadData;
; 336  : 	 pKsd_t=phTTS->pKernelShareData;
; 337  : 
; 338  : 	if (ls_adju_suffixscan(pLts_t,fpp, lpp) == FALSE)

  00771	8b 5c 24 0c	 mov	 ebx, DWORD PTR _fpp$[esp]
  00775	55		 push	 ebp
  00776	8b 6c 24 0c	 mov	 ebp, DWORD PTR _phTTS$[esp+4]
  0077a	56		 push	 esi
  0077b	57		 push	 edi
  0077c	8b 7c 24 1c	 mov	 edi, DWORD PTR _lpp$[esp+12]
  00780	8b 75 10	 mov	 esi, DWORD PTR [ebp+16]
  00783	57		 push	 edi
  00784	53		 push	 ebx
  00785	56		 push	 esi
  00786	e8 00 00 00 00	 call	 _ls_adju_suffixscan
  0078b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0078e	85 c0		 test	 eax, eax
  00790	0f 84 04 04 00
	00		 je	 $L72539

; 339  : 		return;
; 340  : 	if (ls_adju_prefixscan(phTTS,fpp, lpp,sel_lang) == FALSE)

  00796	8b 44 24 24	 mov	 eax, DWORD PTR _sel_lang$[esp+12]
  0079a	50		 push	 eax
  0079b	57		 push	 edi
  0079c	53		 push	 ebx
  0079d	55		 push	 ebp
  0079e	e8 00 00 00 00	 call	 _ls_adju_prefixscan
  007a3	83 c4 10	 add	 esp, 16			; 00000010H
  007a6	85 c0		 test	 eax, eax
  007a8	0f 84 ec 03 00
	00		 je	 $L72539

; 341  : 		return;
; 342  : #ifdef ACNA
; 343  : 	/*
; 344  : 	 * PRG	23-NOV-1988
; 345  : 	 * BEGINNING OF MODIFICATION - this code segment looks at the
; 346  : 	 * language tag associated with the word being analyzed and
; 347  : 	 * dispatches the word out to different analysis routines for
; 348  : 	 * languages other than English.  English words are processed
; 349  : 	 * as words always have been.
; 350  : 	 */
; 351  : 
; 352  : 		if (sel_lang != NAME_ENGLISH && sel_lang != NAME_IRISH)

  007ae	8b 54 24 24	 mov	 edx, DWORD PTR _sel_lang$[esp+12]
  007b2	85 d2		 test	 edx, edx
  007b4	0f 84 c3 00 00
	00		 je	 $L72552
  007ba	83 fa 03	 cmp	 edx, 3
  007bd	0f 84 ba 00 00
	00		 je	 $L72552

; 353  : 		{
; 354  : 	   	   /*
; 355  : 		    * Stress placed on the word by English rules (which are the
; 356  : 	    	* default rules) must be removed.
; 357  : 	    	*/
; 358  : 
; 359  : 
; 360  : 	   		for (csyl=0; csyl<pLts_t->nsyl; csyl++)

  007c3	33 c0		 xor	 eax, eax
  007c5	66 39 86 30 04
	00 00		 cmp	 WORD PTR [esi+1072], ax
  007cc	7e 1e		 jle	 SHORT $L72550
  007ce	8d 8e 08 04 00
	00		 lea	 ecx, DWORD PTR [esi+1032]
$L72548:

; 361  : 	      		pLts_t->sylp[csyl]->p_stress = SUN;

  007d4	8b 29		 mov	 ebp, DWORD PTR [ecx]
  007d6	40		 inc	 eax
  007d7	83 c1 04	 add	 ecx, 4
  007da	c7 45 10 7c 00
	00 00		 mov	 DWORD PTR [ebp+16], 124	; 0000007cH
  007e1	0f bf ae 30 04
	00 00		 movsx	 ebp, WORD PTR [esi+1072]
  007e8	3b c5		 cmp	 eax, ebp
  007ea	7c e8		 jl	 SHORT $L72548
$L72550:

; 362  : 
; 363  : 	   		/*
; 364  : 	    	 * Execute language specific analysis.
; 365  : 	    	 */
; 366  : 
; 367  : 	   		switch (sel_lang)
; 368  : 	   		{

  007ec	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  007ef	83 f8 06	 cmp	 eax, 6
  007f2	0f 87 85 00 00
	00		 ja	 $L72552
  007f8	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72830[eax*4]
$L72555:

; 369  : 				case NAME_FRENCH :
; 370  : 		 			lsa_util_stress_fr (pLts_t,fpp, lpp, pstype);

  007ff	8b 4c 24 20	 mov	 ecx, DWORD PTR _pstype$[esp+12]
  00803	51		 push	 ecx
  00804	57		 push	 edi
  00805	53		 push	 ebx
  00806	56		 push	 esi
  00807	e8 00 00 00 00	 call	 _lsa_util_stress_fr
  0080c	83 c4 10	 add	 esp, 16			; 00000010H
  0080f	5f		 pop	 edi
  00810	5e		 pop	 esi
  00811	5d		 pop	 ebp
  00812	5b		 pop	 ebx

; 535  : }

  00813	c3		 ret	 0
$L72556:

; 371  : 		 			return;
; 372  : 
; 373  : 	      		case NAME_GERMANIC :
; 374  : 			 		lsa_util_stress_gr (pLts_t,fpp, lpp, pstype);

  00814	8b 54 24 20	 mov	 edx, DWORD PTR _pstype$[esp+12]
  00818	52		 push	 edx
  00819	57		 push	 edi
  0081a	53		 push	 ebx
  0081b	56		 push	 esi
  0081c	e8 00 00 00 00	 call	 _lsa_util_stress_gr
  00821	83 c4 10	 add	 esp, 16			; 00000010H
  00824	5f		 pop	 edi
  00825	5e		 pop	 esi
  00826	5d		 pop	 ebp
  00827	5b		 pop	 ebx

; 535  : }

  00828	c3		 ret	 0
$L72557:

; 375  : 		 			return;
; 376  : 
; 377  : 	      		case NAME_ITALIAN :
; 378  : 		 			lsa_util_stress_it (pLts_t,fpp, lpp, pstype);

  00829	8b 44 24 20	 mov	 eax, DWORD PTR _pstype$[esp+12]
  0082d	50		 push	 eax
  0082e	57		 push	 edi
  0082f	53		 push	 ebx
  00830	56		 push	 esi
  00831	e8 00 00 00 00	 call	 _lsa_util_stress_it
  00836	83 c4 10	 add	 esp, 16			; 00000010H
  00839	5f		 pop	 edi
  0083a	5e		 pop	 esi
  0083b	5d		 pop	 ebp
  0083c	5b		 pop	 ebx

; 535  : }

  0083d	c3		 ret	 0
$L72558:

; 379  : 		 			return;
; 380  : 
; 381  : 		      	case NAME_JAPANESE :
; 382  : 				 	lsa_util_stress_ja (pLts_t,fpp, lpp, pstype);

  0083e	8b 4c 24 20	 mov	 ecx, DWORD PTR _pstype$[esp+12]
  00842	51		 push	 ecx
  00843	57		 push	 edi
  00844	53		 push	 ebx
  00845	56		 push	 esi
  00846	e8 00 00 00 00	 call	 _lsa_util_stress_ja
  0084b	83 c4 10	 add	 esp, 16			; 00000010H
  0084e	5f		 pop	 edi
  0084f	5e		 pop	 esi
  00850	5d		 pop	 ebp
  00851	5b		 pop	 ebx

; 535  : }

  00852	c3		 ret	 0
$L72559:

; 383  : 		 			return;
; 384  : 
; 385  : 	      		case NAME_SPANISH :
; 386  : 					lsa_util_stress_sp (pLts_t,fpp, lpp, pstype);

  00853	8b 54 24 20	 mov	 edx, DWORD PTR _pstype$[esp+12]
  00857	52		 push	 edx
  00858	57		 push	 edi
  00859	53		 push	 ebx
  0085a	56		 push	 esi
  0085b	e8 00 00 00 00	 call	 _lsa_util_stress_sp
  00860	83 c4 10	 add	 esp, 16			; 00000010H
  00863	5f		 pop	 edi
  00864	5e		 pop	 esi
  00865	5d		 pop	 ebp
  00866	5b		 pop	 ebx

; 535  : }

  00867	c3		 ret	 0
$L72560:

; 387  : 			 		return;
; 388  : 
; 389  : 	      		case NAME_SLAVIC :
; 390  : 					lsa_util_stress_sl (pLts_t,fpp, lpp, pstype);

  00868	8b 44 24 20	 mov	 eax, DWORD PTR _pstype$[esp+12]
  0086c	50		 push	 eax
  0086d	57		 push	 edi
  0086e	53		 push	 ebx
  0086f	56		 push	 esi
  00870	e8 00 00 00 00	 call	 _lsa_util_stress_sl
  00875	83 c4 10	 add	 esp, 16			; 00000010H
  00878	5f		 pop	 edi
  00879	5e		 pop	 esi
  0087a	5d		 pop	 ebp
  0087b	5b		 pop	 ebx

; 535  : }

  0087c	c3		 ret	 0
$L72552:

; 391  : 			 		return;
; 392  : 	   		};
; 393  : 		}
; 394  : 
; 395  : 	/*
; 396  : 	 * END OF MODIFICATION.
; 397  : 	 */
; 398  : 
; 399  : #endif /* #ifdef ACNA */
; 400  : 
; 401  : 	/* Suffix is providing primary stress placement information.	*/
; 402  : 	/* Place it. Shift left if impossible. Let prefix flags and bad	*/
; 403  : 	/* vowels push it back toward the suffix.			*/
; 404  : 
; 405  : 	if (pLts_t->psyl >= 0) 

  0087d	66 8b 96 34 04
	00 00		 mov	 dx, WORD PTR [esi+1076]
  00884	66 85 d2	 test	 dx, dx
  00887	0f 8c 7b 01 00
	00		 jl	 $L72561

; 406  : 	{
; 407  : 		type = pLts_t->sylp[pLts_t->psyl]->p_stress;

  0088d	0f bf ca	 movsx	 ecx, dx

; 408  : 		if (type==S1LEFT || type==S2LEFT) 

  00890	bd 80 00 00 00	 mov	 ebp, 128		; 00000080H
  00895	8b 8c 8e 08 04
	00 00		 mov	 ecx, DWORD PTR [esi+ecx*4+1032]
  0089c	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0089f	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  008a2	74 04		 je	 SHORT $L72563
  008a4	3b c5		 cmp	 eax, ebp
  008a6	75 38		 jne	 SHORT $L72811
$L72563:

; 409  : 		{
; 410  : 			if (pLts_t->psyl != 0) 

  008a8	66 85 d2	 test	 dx, dx
  008ab	74 33		 je	 SHORT $L72811

; 411  : 			{
; 412  : 				pLts_t->sylp[pLts_t->psyl]->p_stress = SUN;

  008ad	ba 7c 00 00 00	 mov	 edx, 124		; 0000007cH
  008b2	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 413  : 				--pLts_t->psyl;

  008b5	66 ff 8e 34 04
	00 00		 dec	 WORD PTR [esi+1076]
  008bc	66 8b 8e 34 04
	00 00		 mov	 cx, WORD PTR [esi+1076]

; 414  : 				if (type==S2LEFT && pLts_t->psyl!=0) 

  008c3	3b c5		 cmp	 eax, ebp
  008c5	75 19		 jne	 SHORT $L72811
  008c7	66 85 c9	 test	 cx, cx
  008ca	74 14		 je	 SHORT $L72811

; 415  : 				{
; 416  : 					pLts_t->sylp[pLts_t->psyl]->p_stress = SUN;

  008cc	0f bf c1	 movsx	 eax, cx
  008cf	8b 8c 86 08 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax*4+1032]
  008d6	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 417  : 					--pLts_t->psyl;

  008d9	66 ff 8e 34 04
	00 00		 dec	 WORD PTR [esi+1076]
$L72811:

; 418  : 				}
; 419  : 			}
; 420  : 		}
; 421  : 		while (pLts_t->psyl!=0 && ls_adju_unstressed(pLts_t,pLts_t->psyl)!=FALSE) 

  008e0	66 83 be 34 04
	00 00 00	 cmp	 WORD PTR [esi+1076], 0
  008e8	74 26		 je	 SHORT $L72812
$L72567:
  008ea	0f bf 96 34 04
	00 00		 movsx	 edx, WORD PTR [esi+1076]
  008f1	52		 push	 edx
  008f2	56		 push	 esi
  008f3	e8 00 00 00 00	 call	 _ls_adju_unstressed
  008f8	83 c4 08	 add	 esp, 8
  008fb	85 c0		 test	 eax, eax
  008fd	74 11		 je	 SHORT $L72812

; 422  : 		{
; 423  : 			--pLts_t->psyl;

  008ff	66 ff 8e 34 04
	00 00		 dec	 WORD PTR [esi+1076]
  00906	66 83 be 34 04
	00 00 00	 cmp	 WORD PTR [esi+1076], 0
  0090e	75 da		 jne	 SHORT $L72567
$L72812:

; 424  : 		}
; 425  : 		while (pLts_t->psyl<pLts_t->nsyl-1 && (pLts_t->sylp[pLts_t->psyl]->p_flag&PFRFUSE)!=0) 

  00910	0f bf 86 30 04
	00 00		 movsx	 eax, WORD PTR [esi+1072]
  00917	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  0091a	0f bf 86 34 04
	00 00		 movsx	 eax, WORD PTR [esi+1076]
  00921	3b c1		 cmp	 eax, ecx
  00923	7d 27		 jge	 SHORT $L72813
  00925	b2 20		 mov	 dl, 32			; 00000020H
$L72570:
  00927	66 8b 86 34 04
	00 00		 mov	 ax, WORD PTR [esi+1076]
  0092e	0f bf f8	 movsx	 edi, ax
  00931	8b bc be 08 04
	00 00		 mov	 edi, DWORD PTR [esi+edi*4+1032]
  00938	84 57 0c	 test	 BYTE PTR [edi+12], dl
  0093b	74 0f		 je	 SHORT $L72813

; 426  : 		{
; 427  : 			++pLts_t->psyl;

  0093d	40		 inc	 eax
  0093e	66 89 86 34 04
	00 00		 mov	 WORD PTR [esi+1076], ax
  00945	0f bf c0	 movsx	 eax, ax
  00948	3b c1		 cmp	 eax, ecx
  0094a	7c db		 jl	 SHORT $L72570
$L72813:

; 428  : 		}
; 429  : 		while (pLts_t->psyl<pLts_t->nsyl-1 && ls_adju_unstressed(pLts_t,pLts_t->psyl)!=FALSE) 

  0094c	0f bf 96 34 04
	00 00		 movsx	 edx, WORD PTR [esi+1076]
  00953	3b d1		 cmp	 edx, ecx
  00955	7d 32		 jge	 SHORT $L72574
$L72573:
  00957	0f bf 86 34 04
	00 00		 movsx	 eax, WORD PTR [esi+1076]
  0095e	50		 push	 eax
  0095f	56		 push	 esi
  00960	e8 00 00 00 00	 call	 _ls_adju_unstressed
  00965	83 c4 08	 add	 esp, 8
  00968	85 c0		 test	 eax, eax
  0096a	74 1d		 je	 SHORT $L72574

; 430  : 		{
; 431  : 			++pLts_t->psyl;

  0096c	66 ff 86 34 04
	00 00		 inc	 WORD PTR [esi+1076]
  00973	66 8b 86 34 04
	00 00		 mov	 ax, WORD PTR [esi+1076]
  0097a	0f bf 8e 30 04
	00 00		 movsx	 ecx, WORD PTR [esi+1072]
  00981	0f bf d0	 movsx	 edx, ax
  00984	49		 dec	 ecx
  00985	3b d1		 cmp	 edx, ecx
  00987	7c ce		 jl	 SHORT $L72573
$L72574:

; 432  : 		}
; 433  : 		pLts_t->sylp[pLts_t->psyl]->p_stress = pstype;

  00989	0f bf 86 34 04
	00 00		 movsx	 eax, WORD PTR [esi+1076]
  00990	8b 54 24 20	 mov	 edx, DWORD PTR _pstype$[esp+12]

; 434  : 		csyl = pLts_t->psyl+1;
; 435  : 		isreduced = TRUE;

  00994	bf 01 00 00 00	 mov	 edi, 1
  00999	8b 8c 86 08 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax*4+1032]
  009a0	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  009a3	0f bf 8e 34 04
	00 00		 movsx	 ecx, WORD PTR [esi+1076]

; 436  : 		while (csyl < pLts_t->nsyl) 

  009aa	0f bf 86 30 04
	00 00		 movsx	 eax, WORD PTR [esi+1072]
  009b1	41		 inc	 ecx
  009b2	3b c8		 cmp	 ecx, eax
  009b4	0f 8d d7 01 00
	00		 jge	 $L72577
  009ba	8d 94 8e 08 04
	00 00		 lea	 edx, DWORD PTR [esi+ecx*4+1032]
  009c1	bb 7b 00 00 00	 mov	 ebx, 123		; 0000007bH
$L72576:

; 437  : 		{
; 438  : 			if (isreduced == FALSE) 

  009c6	85 ff		 test	 edi, edi
  009c8	75 11		 jne	 SHORT $L72578

; 439  : 			{
; 440  : 				if (pLts_t->sylp[csyl]->p_stress == SNONE)

  009ca	8b 02		 mov	 eax, DWORD PTR [edx]
  009cc	39 58 10	 cmp	 DWORD PTR [eax+16], ebx
  009cf	75 03		 jne	 SHORT $L72579

; 441  : 					pLts_t->sylp[csyl]->p_flag |= PFBLOCK;

  009d1	09 68 0c	 or	 DWORD PTR [eax+12], ebp
$L72579:

; 442  : 				isreduced = TRUE;

  009d4	bf 01 00 00 00	 mov	 edi, 1

; 443  : 			} 
; 444  : 			else

  009d9	eb 02		 jmp	 SHORT $L72580
$L72578:

; 445  : 			{
; 446  : 				isreduced = FALSE;

  009db	33 ff		 xor	 edi, edi
$L72580:

; 447  : 			}
; 448  : 			if (pLts_t->sylp[csyl]->p_stress == SNONE)

  009dd	8b 02		 mov	 eax, DWORD PTR [edx]
  009df	39 58 10	 cmp	 DWORD PTR [eax+16], ebx
  009e2	75 07		 jne	 SHORT $L72581

; 449  : 			{
; 450  : 				pLts_t->sylp[csyl]->p_stress = SUN;

  009e4	c7 40 10 7c 00
	00 00		 mov	 DWORD PTR [eax+16], 124	; 0000007cH
$L72581:

; 436  : 		while (csyl < pLts_t->nsyl) 

  009eb	0f bf 86 30 04
	00 00		 movsx	 eax, WORD PTR [esi+1072]

; 451  : 			}
; 452  : 			++csyl;

  009f2	41		 inc	 ecx
  009f3	83 c2 04	 add	 edx, 4
  009f6	3b c8		 cmp	 ecx, eax
  009f8	7c cc		 jl	 SHORT $L72576

; 533  : 	}
; 534  : 	ls_adju_final_fixes(pLts_t);

  009fa	56		 push	 esi
  009fb	e8 00 00 00 00	 call	 _ls_adju_final_fixes
  00a00	83 c4 04	 add	 esp, 4
  00a03	5f		 pop	 edi
  00a04	5e		 pop	 esi
  00a05	5d		 pop	 ebp
  00a06	5b		 pop	 ebx

; 535  : }

  00a07	c3		 ret	 0
$L72561:

; 453  : 		}
; 454  : 		ls_adju_final_fixes(pLts_t);
; 455  : 		return;
; 456  : 	}
; 457  : 	/* No suffix, but prefix is refusing the stress.		*/
; 458  : 	if ((pLts_t->sylp[0]->p_flag&PFRFUSE) != 0) 

  00a08	8b 8e 08 04 00
	00		 mov	 ecx, DWORD PTR [esi+1032]
  00a0e	b2 20		 mov	 dl, 32			; 00000020H
  00a10	84 51 0c	 test	 BYTE PTR [ecx+12], dl
  00a13	0f 84 fd 00 00
	00		 je	 $L72582

; 459  : 	{
; 460  : 		pLts_t->psyl = 0;
; 461  : #if defined (VMS) || defined (LDS_BUILD)
; 462  : 		if (rflag != FALSE)
; 463  : 			printf("Begin at sylable 1\n");
; 464  : #endif
; 465  : 		while (pLts_t->psyl<pLts_t->nsyl-1 && (pLts_t->sylp[pLts_t->psyl]->p_flag&PFRFUSE)!=0) 

  00a19	0f bf 86 30 04
	00 00		 movsx	 eax, WORD PTR [esi+1072]
  00a20	66 c7 86 34 04
	00 00 00 00	 mov	 WORD PTR [esi+1076], 0
  00a29	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00a2c	85 c9		 test	 ecx, ecx
  00a2e	7e 25		 jle	 SHORT $L72816
$L72584:
  00a30	66 8b 86 34 04
	00 00		 mov	 ax, WORD PTR [esi+1076]
  00a37	0f bf f8	 movsx	 edi, ax
  00a3a	8b bc be 08 04
	00 00		 mov	 edi, DWORD PTR [esi+edi*4+1032]
  00a41	84 57 0c	 test	 BYTE PTR [edi+12], dl
  00a44	74 0f		 je	 SHORT $L72816

; 466  : 		{
; 467  : 			++pLts_t->psyl;

  00a46	40		 inc	 eax
  00a47	66 89 86 34 04
	00 00		 mov	 WORD PTR [esi+1076], ax
  00a4e	0f bf c0	 movsx	 eax, ax
  00a51	3b c1		 cmp	 eax, ecx
  00a53	7c db		 jl	 SHORT $L72584
$L72816:

; 468  : #if defined (VMS) || defined (LDS_BUILD)
; 469  : 			if (rflag != FALSE)
; 470  : 				printf("Prefix, shift right\n");
; 471  : #endif
; 472  : 		}
; 473  : 		while (pLts_t->psyl<pLts_t->nsyl-1 && ls_adju_unstressed(pLts_t,pLts_t->psyl)!=FALSE) 

  00a55	0f bf 96 34 04
	00 00		 movsx	 edx, WORD PTR [esi+1076]
  00a5c	3b d1		 cmp	 edx, ecx
  00a5e	7d 32		 jge	 SHORT $L72588
$L72587:
  00a60	0f bf 86 34 04
	00 00		 movsx	 eax, WORD PTR [esi+1076]
  00a67	50		 push	 eax
  00a68	56		 push	 esi
  00a69	e8 00 00 00 00	 call	 _ls_adju_unstressed
  00a6e	83 c4 08	 add	 esp, 8
  00a71	85 c0		 test	 eax, eax
  00a73	74 1d		 je	 SHORT $L72588

; 474  : 		{
; 475  : 			++pLts_t->psyl;

  00a75	66 ff 86 34 04
	00 00		 inc	 WORD PTR [esi+1076]
  00a7c	66 8b 86 34 04
	00 00		 mov	 ax, WORD PTR [esi+1076]
  00a83	0f bf 8e 30 04
	00 00		 movsx	 ecx, WORD PTR [esi+1072]
  00a8a	0f bf d0	 movsx	 edx, ax
  00a8d	49		 dec	 ecx
  00a8e	3b d1		 cmp	 edx, ecx
  00a90	7c ce		 jl	 SHORT $L72587
$L72588:

; 476  : #if defined (VMS) || defined (LDS_BUILD)
; 477  : 			if (rflag != FALSE)
; 478  : 				printf("Impossible, shift right\n");
; 479  : #endif
; 480  : 		}
; 481  : #if defined (VMS) || defined (LDS_BUILD)
; 482  : 		if (rflag != FALSE)
; 483  : 			printf("Primary on sylable %d\n", pLts_t->psyl+1);
; 484  : #endif
; 485  : 		pLts_t->sylp[pLts_t->psyl]->p_stress = pstype;

  00a92	0f bf 86 34 04
	00 00		 movsx	 eax, WORD PTR [esi+1076]
  00a99	8b 54 24 20	 mov	 edx, DWORD PTR _pstype$[esp+12]

; 486  : 		csyl = pLts_t->psyl+1;
; 487  : 		isreduced = TRUE;

  00a9d	bf 01 00 00 00	 mov	 edi, 1
  00aa2	8b 8c 86 08 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax*4+1032]
  00aa9	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00aac	0f bf 8e 34 04
	00 00		 movsx	 ecx, WORD PTR [esi+1076]

; 488  : 		while (csyl < pLts_t->nsyl) 

  00ab3	0f bf 86 30 04
	00 00		 movsx	 eax, WORD PTR [esi+1072]
  00aba	41		 inc	 ecx
  00abb	3b c8		 cmp	 ecx, eax
  00abd	0f 8d ce 00 00
	00		 jge	 $L72577
  00ac3	8d 94 8e 08 04
	00 00		 lea	 edx, DWORD PTR [esi+ecx*4+1032]
  00aca	bd 80 00 00 00	 mov	 ebp, 128		; 00000080H
  00acf	bb 7b 00 00 00	 mov	 ebx, 123		; 0000007bH
$L72590:

; 489  : 		{
; 490  : 			if (isreduced == FALSE) 

  00ad4	85 ff		 test	 edi, edi
  00ad6	75 11		 jne	 SHORT $L72592

; 491  : 			{
; 492  : 				if (pLts_t->sylp[csyl]->p_stress == SNONE)

  00ad8	8b 02		 mov	 eax, DWORD PTR [edx]
  00ada	39 58 10	 cmp	 DWORD PTR [eax+16], ebx
  00add	75 03		 jne	 SHORT $L72593

; 493  : 					pLts_t->sylp[csyl]->p_flag |= PFBLOCK;

  00adf	09 68 0c	 or	 DWORD PTR [eax+12], ebp
$L72593:

; 494  : 				isreduced = TRUE;

  00ae2	bf 01 00 00 00	 mov	 edi, 1

; 495  : 			} 
; 496  : 			else

  00ae7	eb 02		 jmp	 SHORT $L72594
$L72592:

; 497  : 			{
; 498  : 				isreduced = FALSE;

  00ae9	33 ff		 xor	 edi, edi
$L72594:

; 499  : 			}
; 500  : 			if (pLts_t->sylp[csyl]->p_stress == SNONE)

  00aeb	8b 02		 mov	 eax, DWORD PTR [edx]
  00aed	39 58 10	 cmp	 DWORD PTR [eax+16], ebx
  00af0	75 07		 jne	 SHORT $L72595

; 501  : 				pLts_t->sylp[csyl]->p_stress = SUN;

  00af2	c7 40 10 7c 00
	00 00		 mov	 DWORD PTR [eax+16], 124	; 0000007cH
$L72595:

; 488  : 		while (csyl < pLts_t->nsyl) 

  00af9	0f bf 86 30 04
	00 00		 movsx	 eax, WORD PTR [esi+1072]

; 502  : 			++csyl;

  00b00	41		 inc	 ecx
  00b01	83 c2 04	 add	 edx, 4
  00b04	3b c8		 cmp	 ecx, eax
  00b06	7c cc		 jl	 SHORT $L72590

; 533  : 	}
; 534  : 	ls_adju_final_fixes(pLts_t);

  00b08	56		 push	 esi
  00b09	e8 00 00 00 00	 call	 _ls_adju_final_fixes
  00b0e	83 c4 04	 add	 esp, 4
  00b11	5f		 pop	 edi
  00b12	5e		 pop	 esi
  00b13	5d		 pop	 ebp
  00b14	5b		 pop	 ebx

; 535  : }

  00b15	c3		 ret	 0
$L72582:

; 503  : 		}
; 504  : 		ls_adju_final_fixes(pLts_t);
; 505  : 		return;
; 506  : 	}
; 507  : 	/* Revert to default rules. No or all refusing suffix.		*/
; 508  : 	ls_adju_bestdefault(pLts_t);

  00b16	56		 push	 esi
  00b17	e8 00 00 00 00	 call	 _ls_adju_bestdefault

; 509  : #if defined (VMS) || defined (LDS_BUILD)
; 510  : 	if (rflag != FALSE)
; 511  : 		printf("Best default on sylable %d\n", pLts_t->psyl+1);
; 512  : #endif
; 513  : 	pLts_t->sylp[pLts_t->psyl]->p_stress = pstype;

  00b1c	0f bf 8e 34 04
	00 00		 movsx	 ecx, WORD PTR [esi+1076]
  00b23	8b 44 24 24	 mov	 eax, DWORD PTR _pstype$[esp+16]
  00b27	83 c4 04	 add	 esp, 4
  00b2a	8b 94 8e 08 04
	00 00		 mov	 edx, DWORD PTR [esi+ecx*4+1032]

; 514  : 	csyl = pLts_t->psyl+1;
; 515  : 	isreduced = TRUE;

  00b31	bf 01 00 00 00	 mov	 edi, 1
  00b36	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00b39	0f bf 8e 34 04
	00 00		 movsx	 ecx, WORD PTR [esi+1076]

; 516  : 	while (csyl < pLts_t->nsyl) 

  00b40	0f bf 96 30 04
	00 00		 movsx	 edx, WORD PTR [esi+1072]
  00b47	41		 inc	 ecx
  00b48	3b ca		 cmp	 ecx, edx
  00b4a	7d 45		 jge	 SHORT $L72577
  00b4c	8d 94 8e 08 04
	00 00		 lea	 edx, DWORD PTR [esi+ecx*4+1032]
  00b53	bd 80 00 00 00	 mov	 ebp, 128		; 00000080H
  00b58	bb 7b 00 00 00	 mov	 ebx, 123		; 0000007bH
$L72597:

; 517  : 	{
; 518  : 		if (isreduced == FALSE) 

  00b5d	85 ff		 test	 edi, edi
  00b5f	75 11		 jne	 SHORT $L72599

; 519  : 		{
; 520  : 			if (pLts_t->sylp[csyl]->p_stress == SNONE)

  00b61	8b 02		 mov	 eax, DWORD PTR [edx]
  00b63	39 58 10	 cmp	 DWORD PTR [eax+16], ebx
  00b66	75 03		 jne	 SHORT $L72600

; 521  : 				pLts_t->sylp[csyl]->p_flag |= PFBLOCK;

  00b68	09 68 0c	 or	 DWORD PTR [eax+12], ebp
$L72600:

; 522  : 			isreduced = TRUE;

  00b6b	bf 01 00 00 00	 mov	 edi, 1

; 523  : 		} 
; 524  : 		else

  00b70	eb 02		 jmp	 SHORT $L72601
$L72599:

; 525  : 		{
; 526  : 			isreduced = FALSE;

  00b72	33 ff		 xor	 edi, edi
$L72601:

; 527  : 		}
; 528  : 		if (pLts_t->sylp[csyl]->p_stress == SNONE)

  00b74	8b 02		 mov	 eax, DWORD PTR [edx]
  00b76	39 58 10	 cmp	 DWORD PTR [eax+16], ebx
  00b79	75 07		 jne	 SHORT $L72602

; 529  : 		{
; 530  : 			pLts_t->sylp[csyl]->p_stress = SUN;

  00b7b	c7 40 10 7c 00
	00 00		 mov	 DWORD PTR [eax+16], 124	; 0000007cH
$L72602:

; 516  : 	while (csyl < pLts_t->nsyl) 

  00b82	0f bf 86 30 04
	00 00		 movsx	 eax, WORD PTR [esi+1072]

; 531  : 		}
; 532  : 		++csyl;

  00b89	41		 inc	 ecx
  00b8a	83 c2 04	 add	 edx, 4
  00b8d	3b c8		 cmp	 ecx, eax
  00b8f	7c cc		 jl	 SHORT $L72597
$L72577:

; 533  : 	}
; 534  : 	ls_adju_final_fixes(pLts_t);

  00b91	56		 push	 esi
  00b92	e8 00 00 00 00	 call	 _ls_adju_final_fixes
  00b97	83 c4 04	 add	 esp, 4
$L72539:
  00b9a	5f		 pop	 edi
  00b9b	5e		 pop	 esi
  00b9c	5d		 pop	 ebp
  00b9d	5b		 pop	 ebx

; 535  : }

  00b9e	c3		 ret	 0
  00b9f	90		 npad	 1
$L72830:
  00ba0	00 00 00 00	 DD	 $L72555
  00ba4	00 00 00 00	 DD	 $L72556
  00ba8	00 00 00 00	 DD	 $L72552
  00bac	00 00 00 00	 DD	 $L72557
  00bb0	00 00 00 00	 DD	 $L72558
  00bb4	00 00 00 00	 DD	 $L72560
  00bb8	00 00 00 00	 DD	 $L72559
_ls_adju_stress ENDP
_pLts_t$ = 8
_n$ = 12
_ls_adju_unstressed PROC NEAR

; 559  : 	 PHONE	*pp;
; 560  : 	 int	sphone;
; 561  : 
; 562  : 	pp = pLts_t->sylp[n];

  00bc0	8b 44 24 08	 mov	 eax, DWORD PTR _n$[esp-4]
  00bc4	8b 4c 24 04	 mov	 ecx, DWORD PTR _pLts_t$[esp-4]
  00bc8	56		 push	 esi
  00bc9	8b b4 81 08 04
	00 00		 mov	 esi, DWORD PTR [ecx+eax*4+1032]

; 563  : 	while (ls_adju_is_cons(pp) != FALSE)

  00bd0	56		 push	 esi
  00bd1	e8 00 00 00 00	 call	 _ls_adju_is_cons
  00bd6	83 c4 04	 add	 esp, 4
  00bd9	85 c0		 test	 eax, eax
  00bdb	74 0f		 je	 SHORT $L72612
$L72611:

; 564  : 		pp = pp->p_fp;

  00bdd	8b 36		 mov	 esi, DWORD PTR [esi]
  00bdf	56		 push	 esi
  00be0	e8 00 00 00 00	 call	 _ls_adju_is_cons
  00be5	83 c4 04	 add	 esp, 4
  00be8	85 c0		 test	 eax, eax
  00bea	75 f1		 jne	 SHORT $L72611
$L72612:

; 565  : 	sphone = pp->p_sphone;
; 566  : #ifdef ENGLISH_US
; 567  : 	if (sphone ==US_EL)

  00bec	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00bef	33 c0		 xor	 eax, eax
  00bf1	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00bf4	5e		 pop	 esi
  00bf5	0f 94 c0	 sete	 al

; 568  : #endif
; 569  : #ifdef ENGLISH_UK
; 570  : 	if (sphone ==UK_EL)
; 571  : #endif
; 572  : #ifdef GERMAN
; 573  :         if (sphone ==GR_L)
; 574  : #endif	
; 575  : 		return (TRUE);
; 576  : 	return (FALSE);
; 577  : }

  00bf8	c3		 ret	 0
_ls_adju_unstressed ENDP
_pLts_t$ = 8
_fpp$ = 12
_lpp$ = 16
_ls_adju_suffixscan PROC NEAR

; 605  : 	 PHONE	*pp;
; 606  : 
; 607  : 	pLts_t->nsyl =  0;

  00c00	8b 44 24 04	 mov	 eax, DWORD PTR _pLts_t$[esp-4]

; 608  : 	pLts_t->rsyl = -1;

  00c04	83 c9 ff	 or	 ecx, -1
  00c07	56		 push	 esi

; 609  : 	pLts_t->psyl = -1;
; 610  : 	pp = fpp;
; 611  : 	while (pp != lpp) 

  00c08	8b 74 24 10	 mov	 esi, DWORD PTR _lpp$[esp]
  00c0c	66 89 88 32 04
	00 00		 mov	 WORD PTR [eax+1074], cx
  00c13	66 89 88 34 04
	00 00		 mov	 WORD PTR [eax+1076], cx
  00c1a	8b 4c 24 0c	 mov	 ecx, DWORD PTR _fpp$[esp]
  00c1e	66 c7 80 30 04
	00 00 00 00	 mov	 WORD PTR [eax+1072], 0
  00c27	3b ce		 cmp	 ecx, esi
  00c29	74 58		 je	 SHORT $L72624
$L72623:

; 612  : 	{
; 613  : 		if ((pp->p_flag&PFSYLAB) != 0) 

  00c2b	f6 41 0c 10	 test	 BYTE PTR [ecx+12], 16	; 00000010H
  00c2f	74 4c		 je	 SHORT $L72625

; 614  : 		{
; 615  : 			if (pLts_t->nsyl >= NSYL)

  00c31	66 8b 90 30 04
	00 00		 mov	 dx, WORD PTR [eax+1072]
  00c38	66 83 fa 0a	 cmp	 dx, 10			; 0000000aH
  00c3c	7d 64		 jge	 SHORT $L72836

; 617  : 			if (pp->p_stress != SNONE) 

  00c3e	83 79 10 7b	 cmp	 DWORD PTR [ecx+16], 123	; 0000007bH
  00c42	74 28		 je	 SHORT $L72629

; 618  : 			{
; 619  : 				if (pLts_t->rsyl < 0)

  00c44	66 83 b8 32 04
	00 00 00	 cmp	 WORD PTR [eax+1074], 0
  00c4c	7d 07		 jge	 SHORT $L72628

; 620  : 					pLts_t->rsyl = pLts_t->nsyl;

  00c4e	66 89 90 32 04
	00 00		 mov	 WORD PTR [eax+1074], dx
$L72628:

; 621  : 				if (pLts_t->psyl<0 && pp->p_stress>=SPRI)

  00c55	66 83 b8 34 04
	00 00 00	 cmp	 WORD PTR [eax+1076], 0
  00c5d	7d 0d		 jge	 SHORT $L72629
  00c5f	83 79 10 7e	 cmp	 DWORD PTR [ecx+16], 126	; 0000007eH
  00c63	7c 07		 jl	 SHORT $L72629

; 622  : 					pLts_t->psyl = pLts_t->nsyl;

  00c65	66 89 90 34 04
	00 00		 mov	 WORD PTR [eax+1076], dx
$L72629:

; 623  : 			}
; 624  : 			pLts_t->sylp[pLts_t->nsyl++] = pp;

  00c6c	0f bf d2	 movsx	 edx, dx
  00c6f	89 8c 90 08 04
	00 00		 mov	 DWORD PTR [eax+edx*4+1032], ecx
  00c76	66 ff 80 30 04
	00 00		 inc	 WORD PTR [eax+1072]
$L72625:

; 625  : 		}
; 626  : 		pp = pp->p_fp;

  00c7d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00c7f	3b ce		 cmp	 ecx, esi
  00c81	75 a8		 jne	 SHORT $L72623
$L72624:

; 627  : 	}
; 628  : 	if (pLts_t->rsyl < 0)

  00c83	66 83 b8 32 04
	00 00 00	 cmp	 WORD PTR [eax+1074], 0
  00c8b	7d 0e		 jge	 SHORT $L72630

; 629  : 		pLts_t->rsyl = pLts_t->nsyl;

  00c8d	66 8b 88 30 04
	00 00		 mov	 cx, WORD PTR [eax+1072]
  00c94	66 89 88 32 04
	00 00		 mov	 WORD PTR [eax+1074], cx
$L72630:

; 630  : 	return (TRUE);

  00c9b	b8 01 00 00 00	 mov	 eax, 1
  00ca0	5e		 pop	 esi

; 631  : }

  00ca1	c3		 ret	 0
$L72836:

; 616  : 				return (FALSE);

  00ca2	33 c0		 xor	 eax, eax
  00ca4	5e		 pop	 esi

; 631  : }

  00ca5	c3		 ret	 0
_ls_adju_suffixscan ENDP
_TEXT	ENDS
EXTRN	_preftab:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_fpp$ = 12
_lpp$ = 16
_lang_tag$ = 20
_pp1$ = 12
_csyl$ = 8
_pLts_t$ = -8
_ls_adju_prefixscan PROC NEAR

; 656  : {

  00cb0	83 ec 08	 sub	 esp, 8

; 657  : 
; 658  : 	 PHONE	*pp1;
; 659  : 	 PHONE	*pp2;
; 660  : 	 int	i;
; 661  : 	 int	len;
; 662  : 	 int	csyl;
; 663  : 	char	*ptp;
; 664  : 	PLTS_T	pLts_t;
; 665  : 	PKSD_T  pKsd_t;
; 666  : 	pKsd_t = phTTS->pKernelShareData;
; 667  : 	pLts_t=phTTS->pLTSThreadData;

  00cb3	8b 44 24 0c	 mov	 eax, DWORD PTR _phTTS$[esp+4]

; 668  : 
; 669  : 	pp1  = fpp;					/* Start of the word.	*/

  00cb7	8b 4c 24 10	 mov	 ecx, DWORD PTR _fpp$[esp+4]
  00cbb	53		 push	 ebx
  00cbc	55		 push	 ebp
  00cbd	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00cc0	56		 push	 esi
  00cc1	57		 push	 edi
  00cc2	89 44 24 10	 mov	 DWORD PTR _pLts_t$[esp+24], eax

; 670  : 	csyl = 0;					/* Sylable count.		*/
; 671  : loop:
; 672  : 	if (csyl >= pLts_t->nsyl-1)	/* No sylables.			*/

  00cc6	0f bf 90 30 04
	00 00		 movsx	 edx, WORD PTR [eax+1072]
  00ccd	4a		 dec	 edx
  00cce	89 4c 24 20	 mov	 DWORD PTR _pp1$[esp+20], ecx
  00cd2	85 d2		 test	 edx, edx
  00cd4	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _csyl$[esp+20], 0
  00cdc	0f 8e 8e 01 00
	00		 jle	 $L72843
  00ce2	8b 5c 24 24	 mov	 ebx, DWORD PTR _lpp$[esp+20]
  00ce6	05 08 04 00 00	 add	 eax, 1032		; 00000408H
  00ceb	89 44 24 14	 mov	 DWORD PTR -4+[esp+24], eax
$loop$72648:

; 673  : 		return (TRUE);
; 674  : 	ptp = &preftab[0];

  00cef	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_preftab
$L72651:

; 675  : #ifdef ACNA      
; 676  : 	while ((len = ptp[1]&PLENGTH) != 0) 

  00cf4	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00cf7	83 e0 0f	 and	 eax, 15			; 0000000fH
  00cfa	8b e8		 mov	 ebp, eax
  00cfc	0f 84 05 01 00
	00		 je	 $L72652

; 677  : #else
; 678  : 	while ((len = ptp[0]&PLENGTH) != 0) 
; 679  : #endif
; 680  : 	{
; 681  : #ifdef ACNA
; 682  : 		/*
; 683  : 		 * PRG	23-NOV-1988
; 684  : 		 * BEGINNING OF MODIFICATION - skip the prefix if it is
; 685  : 		 * marked IRISH and the scan is not being done for an
; 686  : 		 * IRISH word (i.e. the IRISH flag is not set).
; 687  : 		 *
; 688  : 		 * PRG	15-DEC-1988
; 689  : 		 * Modified the following to handle arbitrary names, not
; 690  : 		 * just IRISH ones.
; 691  : 		 */
; 692  : 
; 693  : 		if (ptp[0] != -1)

  00d02	8a 07		 mov	 al, BYTE PTR [edi]
  00d04	3c ff		 cmp	 al, -1
  00d06	74 0f		 je	 SHORT $L72654

; 694  : 		{
; 695  : 			if (ptp[0] != lang_tag)

  00d08	0f be c8	 movsx	 ecx, al
  00d0b	3b 4c 24 28	 cmp	 ecx, DWORD PTR _lang_tag$[esp+20]
  00d0f	74 06		 je	 SHORT $L72654

; 696  : 		   	{
; 697  : 		   		ptp += len+2;

  00d11	8d 7c 2f 02	 lea	 edi, DWORD PTR [edi+ebp+2]

; 698  : 		  		continue;

  00d15	eb dd		 jmp	 SHORT $L72651
$L72654:

; 699  : 		   	}
; 700  : 		}
; 701  : 		ptp++;
; 702  : 
; 703  : 		/*
; 704  : 		 * END OF MODIFICATION.
; 705  : 		 */
; 706  : 
; 707  : #endif /* #ifdef ACNA */
; 708  : 		pp2 = pp1;

  00d17	8b 74 24 20	 mov	 esi, DWORD PTR _pp1$[esp+20]

; 709  : 		for (i=0; i<len; ++i) 

  00d1b	33 c0		 xor	 eax, eax
  00d1d	85 ed		 test	 ebp, ebp
  00d1f	7e 15		 jle	 SHORT $L72842
$L72655:

; 710  : 		{		/* Compare loop.	*/
; 711  : 			if (pp2==lpp || pp2->p_sphone!=ptp[i+1])

  00d21	3b f3		 cmp	 esi, ebx
  00d23	74 11		 je	 SHORT $L72842
  00d25	0f be 54 38 02	 movsx	 edx, BYTE PTR [eax+edi+2]
  00d2a	39 56 14	 cmp	 DWORD PTR [esi+20], edx
  00d2d	75 07		 jne	 SHORT $L72842

; 712  : 				break;
; 713  : 			pp2 = pp2->p_fp;

  00d2f	8b 36		 mov	 esi, DWORD PTR [esi]
  00d31	40		 inc	 eax
  00d32	3b c5		 cmp	 eax, ebp
  00d34	7c eb		 jl	 SHORT $L72655
$L72842:

; 714  : 		}
; 715  : 		if (i != len) 

  00d36	3b c5		 cmp	 eax, ebp
  00d38	74 06		 je	 SHORT $L72660

; 716  : 		{			/* Failed.		*/
; 717  : 			ptp += len+1;

  00d3a	8d 7c 2f 02	 lea	 edi, DWORD PTR [edi+ebp+2]

; 718  : 			continue;

  00d3e	eb b4		 jmp	 SHORT $L72651
$L72660:

; 719  : 		}
; 720  : #ifdef ENGLISH
; 721  : 		/* The "pp2" is pointing beyond the match. You cannot	*/
; 722  : 		/* bite off a prefix and create an illegal cluster at	*/
; 723  : 		/* the start of the sylable. An example of a word that	*/
; 724  : 		/* is blocked by this rule is "rectilinear".			*/
; 725  : 		if (pp2!=lpp && (pp2->p_flag&PFLEFTC)==0) 

  00d40	3b f3		 cmp	 esi, ebx
  00d42	74 0c		 je	 SHORT $L72661
  00d44	f6 46 0c 40	 test	 BYTE PTR [esi+12], 64	; 00000040H
  00d48	75 06		 jne	 SHORT $L72661

; 726  : 		{
; 727  : 			ptp += len+1;

  00d4a	8d 7c 2f 02	 lea	 edi, DWORD PTR [edi+ebp+2]

; 728  : 			continue;

  00d4e	eb a4		 jmp	 SHORT $L72651
$L72661:

; 729  : 		}
; 730  : 		if ((ptp[0]&PRCON)!=0 && (pp2==lpp || ls_adju_is_cons(pp2)==FALSE)) 

  00d50	f6 47 01 20	 test	 BYTE PTR [edi+1], 32	; 00000020H
  00d54	74 17		 je	 SHORT $L72662
  00d56	3b f3		 cmp	 esi, ebx
  00d58	74 0d		 je	 SHORT $L72663
  00d5a	56		 push	 esi
  00d5b	e8 00 00 00 00	 call	 _ls_adju_is_cons
  00d60	83 c4 04	 add	 esp, 4
  00d63	85 c0		 test	 eax, eax
  00d65	75 06		 jne	 SHORT $L72662
$L72663:

; 731  : 		{
; 732  : 			ptp += len+1;

  00d67	8d 7c 2f 02	 lea	 edi, DWORD PTR [edi+ebp+2]

; 733  : 			continue;

  00d6b	eb 87		 jmp	 SHORT $L72651
$L72662:

; 734  : 		}
; 735  : 		if ((ptp[0]&PRVOC)!=0 && (pp2==lpp ||  ls_adju_is_voc(pp2)==FALSE)) 

  00d6d	f6 47 01 40	 test	 BYTE PTR [edi+1], 64	; 00000040H
  00d71	74 1a		 je	 SHORT $L72664
  00d73	3b f3		 cmp	 esi, ebx
  00d75	74 0d		 je	 SHORT $L72665
  00d77	56		 push	 esi
  00d78	e8 00 00 00 00	 call	 _ls_adju_is_voc
  00d7d	83 c4 04	 add	 esp, 4
  00d80	85 c0		 test	 eax, eax
  00d82	75 09		 jne	 SHORT $L72664
$L72665:

; 736  : 		{
; 737  : 			ptp += len+1;

  00d84	8d 7c 2f 02	 lea	 edi, DWORD PTR [edi+ebp+2]

; 738  : 			continue;

  00d88	e9 67 ff ff ff	 jmp	 $L72651
$L72664:

; 739  : 		}
; 740  : #endif
; 741  : 		pLts_t->sylp[csyl]->p_flag |= PFRFUSE;	/* Mark refuse.		*/

  00d8d	8b 54 24 14	 mov	 edx, DWORD PTR -4+[esp+24]
  00d91	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00d96	8b 02		 mov	 eax, DWORD PTR [edx]

; 742  : 		++csyl;

  00d98	83 c2 04	 add	 edx, 4
  00d9b	89 54 24 14	 mov	 DWORD PTR -4+[esp+24], edx
  00d9f	8b 68 0c	 mov	 ebp, DWORD PTR [eax+12]
  00da2	0b e9		 or	 ebp, ecx
  00da4	89 68 0c	 mov	 DWORD PTR [eax+12], ebp
  00da7	8b 6c 24 1c	 mov	 ebp, DWORD PTR _csyl$[esp+20]

; 743  : 		if ((ptp[0]&P2SYL) != 0		/* If 2 syl. prefix and	*/
; 744  : 		&& csyl < pLts_t->nsyl-1) 

  00dab	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00dae	45		 inc	 ebp
  00daf	a8 80		 test	 al, 128			; 00000080H
  00db1	89 6c 24 1c	 mov	 DWORD PTR _csyl$[esp+20], ebp
  00db5	74 21		 je	 SHORT $L72666
  00db7	8b 44 24 10	 mov	 eax, DWORD PTR _pLts_t$[esp+24]
  00dbb	0f bf 80 30 04
	00 00		 movsx	 eax, WORD PTR [eax+1072]
  00dc2	48		 dec	 eax
  00dc3	3b e8		 cmp	 ebp, eax
  00dc5	7d 11		 jge	 SHORT $L72666

; 745  : 		{							/* some root remains.	*/
; 746  : 			pLts_t->sylp[csyl]->p_flag |= PFRFUSE;

  00dc7	8b 02		 mov	 eax, DWORD PTR [edx]
  00dc9	09 48 0c	 or	 DWORD PTR [eax+12], ecx

; 747  : 			++csyl;

  00dcc	45		 inc	 ebp
  00dcd	83 c2 04	 add	 edx, 4
  00dd0	89 6c 24 1c	 mov	 DWORD PTR _csyl$[esp+20], ebp
  00dd4	89 54 24 14	 mov	 DWORD PTR -4+[esp+24], edx
$L72666:

; 748  : 		}
; 749  : 		if ((ptp[0]&PCONT) == 0)	/* Stop the scan.	*/

  00dd8	f6 47 01 10	 test	 BYTE PTR [edi+1], 16	; 00000010H
  00ddc	0f 84 8e 00 00
	00		 je	 $L72843
  00de2	8b 4c 24 10	 mov	 ecx, DWORD PTR _pLts_t$[esp+24]

; 750  : 			return (TRUE);
; 751  : 		pp1 = pp2;					/* Advance.			*/

  00de6	89 74 24 20	 mov	 DWORD PTR _pp1$[esp+20], esi
  00dea	0f bf 91 30 04
	00 00		 movsx	 edx, WORD PTR [ecx+1072]
  00df1	4a		 dec	 edx
  00df2	3b ea		 cmp	 ebp, edx
  00df4	0f 8c f5 fe ff
	ff		 jl	 $loop$72648
  00dfa	5f		 pop	 edi
  00dfb	5e		 pop	 esi
  00dfc	5d		 pop	 ebp

; 766  : 	}        
; 767  : #endif	
; 768  : 	return (TRUE);

  00dfd	b8 01 00 00 00	 mov	 eax, 1
  00e02	5b		 pop	 ebx

; 769  : }

  00e03	83 c4 08	 add	 esp, 8
  00e06	c3		 ret	 0
$L72652:

; 752  : 		goto loop;		
; 753  : 	}
; 754  : 	if (csyl >= pLts_t->nsyl-1)		/* No sylables.		*/

  00e07	8b 44 24 10	 mov	 eax, DWORD PTR _pLts_t$[esp+24]
  00e0b	0f bf 88 30 04
	00 00		 movsx	 ecx, WORD PTR [eax+1072]
  00e12	8b 44 24 1c	 mov	 eax, DWORD PTR _csyl$[esp+20]
  00e16	49		 dec	 ecx
  00e17	3b c1		 cmp	 eax, ecx

; 755  : 		return (TRUE);

  00e19	7d 55		 jge	 SHORT $L72843

; 756  : #ifdef ENGLISH		
; 757  : 	if (pp1 != lpp					/* V-C1-C2 case.	*/
; 758  : 	&& ls_adju_is_voc(pp1) != FALSE
; 759  : 	&& (pp1=pp1->p_fp) != lpp
; 760  : 	&& ls_adju_is_cons(pp1) != FALSE
; 761  : 	&& (pp2=pp1->p_fp) != lpp
; 762  : 	&& (pp2->p_flag&PFSYLAB) != 0
; 763  : 	&& pp1->p_sphone == pp2->p_sphone)

  00e1b	8b 44 24 20	 mov	 eax, DWORD PTR _pp1$[esp+20]
  00e1f	3b c3		 cmp	 eax, ebx
  00e21	74 4d		 je	 SHORT $L72843
  00e23	50		 push	 eax
  00e24	e8 00 00 00 00	 call	 _ls_adju_is_voc
  00e29	83 c4 04	 add	 esp, 4
  00e2c	85 c0		 test	 eax, eax
  00e2e	74 40		 je	 SHORT $L72843
  00e30	8b 54 24 20	 mov	 edx, DWORD PTR _pp1$[esp+20]
  00e34	8b 32		 mov	 esi, DWORD PTR [edx]
  00e36	3b f3		 cmp	 esi, ebx
  00e38	74 36		 je	 SHORT $L72843
  00e3a	56		 push	 esi
  00e3b	e8 00 00 00 00	 call	 _ls_adju_is_cons
  00e40	83 c4 04	 add	 esp, 4
  00e43	85 c0		 test	 eax, eax
  00e45	74 29		 je	 SHORT $L72843
  00e47	8b 06		 mov	 eax, DWORD PTR [esi]
  00e49	3b c3		 cmp	 eax, ebx
  00e4b	74 23		 je	 SHORT $L72843
  00e4d	f6 40 0c 10	 test	 BYTE PTR [eax+12], 16	; 00000010H
  00e51	74 1d		 je	 SHORT $L72843
  00e53	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00e56	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00e59	3b ca		 cmp	 ecx, edx
  00e5b	75 13		 jne	 SHORT $L72843

; 764  : 	{	
; 765  : 		pLts_t->sylp[csyl]->p_flag |= PFRFUSE;

  00e5d	8b 54 24 10	 mov	 edx, DWORD PTR _pLts_t$[esp+24]
  00e61	8b 44 24 1c	 mov	 eax, DWORD PTR _csyl$[esp+20]
  00e65	8b 84 82 08 04
	00 00		 mov	 eax, DWORD PTR [edx+eax*4+1032]
  00e6c	83 48 0c 20	 or	 DWORD PTR [eax+12], 32	; 00000020H
$L72843:
  00e70	5f		 pop	 edi
  00e71	5e		 pop	 esi
  00e72	5d		 pop	 ebp

; 766  : 	}        
; 767  : #endif	
; 768  : 	return (TRUE);

  00e73	b8 01 00 00 00	 mov	 eax, 1
  00e78	5b		 pop	 ebx

; 769  : }

  00e79	83 c4 08	 add	 esp, 8
  00e7c	c3		 ret	 0
_ls_adju_prefixscan ENDP
_TEXT	ENDS
PUBLIC	_ls_adju_best2syl
_TEXT	SEGMENT
_pLts_t$ = 8
_ls_adju_bestdefault PROC NEAR

; 794  : {                       

  00e80	56		 push	 esi

; 795  : #ifdef ENGLISH
; 796  : 	switch (pLts_t->rsyl) 
; 797  : 	{

  00e81	8b 74 24 08	 mov	 esi, DWORD PTR _pLts_t$[esp]
  00e85	66 8b 8e 32 04
	00 00		 mov	 cx, WORD PTR [esi+1074]
  00e8c	0f bf c1	 movsx	 eax, cx
  00e8f	83 f8 03	 cmp	 eax, 3
  00e92	77 47		 ja	 SHORT $L72681
  00e94	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72853[eax*4]
$L72677:

; 798  : 		case 0:					/* Crap.		*/
; 799  : 		case 1:					/* 1 sylables.		*/
; 800  : 			pLts_t->psyl = 0;

  00e9b	66 c7 86 34 04
	00 00 00 00	 mov	 WORD PTR [esi+1076], 0
  00ea4	5e		 pop	 esi

; 839  : 			break;
; 840  : 	}       
; 841  : #endif
; 842  : #ifdef GERMAN
; 843  :         pLts_t->psyl = 0;
; 844  : #endif	
; 845  : 	/* return (0); */	/* return value not used */
; 846  : }

  00ea5	c3		 ret	 0
$L72678:

; 801  : 			break;
; 802  : 
; 803  : 		case 2:					/* 2 sylables.		*/
; 804  : 			ls_adju_best2syl(pLts_t);

  00ea6	56		 push	 esi
  00ea7	e8 00 00 00 00	 call	 _ls_adju_best2syl
  00eac	83 c4 04	 add	 esp, 4
  00eaf	5e		 pop	 esi

; 839  : 			break;
; 840  : 	}       
; 841  : #endif
; 842  : #ifdef GERMAN
; 843  :         pLts_t->psyl = 0;
; 844  : #endif	
; 845  : 	/* return (0); */	/* return value not used */
; 846  : }

  00eb0	c3		 ret	 0
$L72679:

; 805  : 			break;
; 806  : 
; 807  : 		case 3:					/* 3 sylables.		*/
; 808  : 			pLts_t->psyl = 0;
; 809  : 			if (ls_adju_is_cons(pLts_t->sylp[2]->p_bp) != FALSE)

  00eb1	8b 86 10 04 00
	00		 mov	 eax, DWORD PTR [esi+1040]
  00eb7	66 c7 86 34 04
	00 00 00 00	 mov	 WORD PTR [esi+1076], 0
  00ec0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00ec3	51		 push	 ecx
  00ec4	e8 00 00 00 00	 call	 _ls_adju_is_cons
  00ec9	83 c4 04	 add	 esp, 4
  00ecc	85 c0		 test	 eax, eax
  00ece	74 3b		 je	 SHORT $L72683

; 810  : 				pLts_t->psyl = 1;

  00ed0	66 c7 86 34 04
	00 00 01 00	 mov	 WORD PTR [esi+1076], 1
  00ed9	5e		 pop	 esi

; 839  : 			break;
; 840  : 	}       
; 841  : #endif
; 842  : #ifdef GERMAN
; 843  :         pLts_t->psyl = 0;
; 844  : #endif	
; 845  : 	/* return (0); */	/* return value not used */
; 846  : }

  00eda	c3		 ret	 0
$L72681:

; 811  : 			break;
; 812  : 
; 813  : 		default:				/* 4 or more sylables.	*/
; 814  : 			/* NCS    01/30/1997
; 815  : 			 * This is a little patch to fix the problem of the misplacement of the stress
; 816  : 			 * marker.  Words ending in "ia" would have the stress on the end in stead of
; 817  : 			 * the proper location.
; 818  : 			 *
; 819  : 			 * You can see in the following if statement that the phoneme are checked for
; 820  : 			 * "ia".  And if this is true, the stress is placed BEFORE this spot.
; 821  : 			 * That is why this check is placed in the "4 or more sylables" section.
; 822  : 			 *
; 823  : 			 * But, the first check statement in the if check
; 824  : 			 * you should see that the pointers used p_bp which checks
; 825  : 			 * for the second to last phoneme.  This is the only way to properly find out if
; 826  : 			 * the word ends in "ia" (IYAX).
; 827  : 			 */
; 828  : #ifdef ENGLISH_US
; 829  : 			if ((pLts_t->sylp[pLts_t->rsyl-1])->p_bp->p_sphone == US_IY &&
; 830  : 				pLts_t->sylp[pLts_t->rsyl-1]->p_sphone == US_AX)

  00edb	8b 84 86 04 04
	00 00		 mov	 eax, DWORD PTR [esi+eax*4+1028]
  00ee2	57		 push	 edi
  00ee3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00ee6	8b 7a 14	 mov	 edi, DWORD PTR [edx+20]
  00ee9	83 ff 01	 cmp	 edi, 1
  00eec	5f		 pop	 edi
  00eed	75 12		 jne	 SHORT $L72682
  00eef	83 78 14 11	 cmp	 DWORD PTR [eax+20], 17	; 00000011H
  00ef3	75 0c		 jne	 SHORT $L72682

; 831  : #endif
; 832  : #ifdef ENGLISH_UK
; 833  : 			if ((pLts_t->sylp[pLts_t->rsyl-1])->p_bp->p_sphone == UK_IY &&
; 834  : 				pLts_t->sylp[pLts_t->rsyl-1]->p_sphone == UK_AX)
; 835  : #endif
; 836  : 				pLts_t->psyl = pLts_t->rsyl-3;

  00ef5	83 c1 fd	 add	 ecx, -3			; fffffffdH

; 837  : 			else
; 838  : 				pLts_t->psyl = pLts_t->rsyl-2;

  00ef8	66 89 8e 34 04
	00 00		 mov	 WORD PTR [esi+1076], cx
  00eff	5e		 pop	 esi

; 839  : 			break;
; 840  : 	}       
; 841  : #endif
; 842  : #ifdef GERMAN
; 843  :         pLts_t->psyl = 0;
; 844  : #endif	
; 845  : 	/* return (0); */	/* return value not used */
; 846  : }

  00f00	c3		 ret	 0
$L72682:

; 837  : 			else
; 838  : 				pLts_t->psyl = pLts_t->rsyl-2;

  00f01	83 c1 fe	 add	 ecx, -2			; fffffffeH
  00f04	66 89 8e 34 04
	00 00		 mov	 WORD PTR [esi+1076], cx
$L72683:
  00f0b	5e		 pop	 esi

; 839  : 			break;
; 840  : 	}       
; 841  : #endif
; 842  : #ifdef GERMAN
; 843  :         pLts_t->psyl = 0;
; 844  : #endif	
; 845  : 	/* return (0); */	/* return value not used */
; 846  : }

  00f0c	c3		 ret	 0
  00f0d	8d 49 00	 npad	 3
$L72853:
  00f10	00 00 00 00	 DD	 $L72677
  00f14	00 00 00 00	 DD	 $L72677
  00f18	00 00 00 00	 DD	 $L72678
  00f1c	00 00 00 00	 DD	 $L72679
_ls_adju_bestdefault ENDP
_pLts_t$ = 8
_ls_adju_best2syl PROC NEAR

; 867  : {

  00f20	53		 push	 ebx

; 868  : 	 PHONE	*pp;
; 869  : 	 int	ph;
; 870  : 
; 871  : 	pp = pLts_t->sylp[0];

  00f21	8b 5c 24 08	 mov	 ebx, DWORD PTR _pLts_t$[esp]
  00f25	56		 push	 esi
  00f26	57		 push	 edi
  00f27	8b b3 08 04 00
	00		 mov	 esi, DWORD PTR [ebx+1032]

; 872  : 	ph = pp->p_sphone;

  00f2d	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]

; 873  : 	/* Never stress [@] if initial sylable, like "abridge".		*/
; 874  : #ifdef ENGLISH_US
; 875  : 	if (ph==US_AE && (pp->p_fp->p_flag&PFSYLAB)!=0) 

  00f30	83 ff 05	 cmp	 edi, 5
  00f33	75 15		 jne	 SHORT $L72689
  00f35	8b 06		 mov	 eax, DWORD PTR [esi]
  00f37	f6 40 0c 10	 test	 BYTE PTR [eax+12], 16	; 00000010H
  00f3b	74 0d		 je	 SHORT $L72689
  00f3d	5f		 pop	 edi

; 876  : #endif
; 877  : #ifdef ENGLISH_UK
; 878  : 	if (ph==UK_AE && (pp->p_fp->p_flag&PFSYLAB)!=0) 
; 879  : #endif
; 880  : #ifdef GERMAN
; 881  : 	if (ph==GR_AE && (pp->p_fp->p_flag&PFSYLAB)!=0) 
; 882  : #endif
; 883  : 	{
; 884  : 		pLts_t->psyl = 1;

  00f3e	66 c7 83 34 04
	00 00 01 00	 mov	 WORD PTR [ebx+1076], 1
  00f47	5e		 pop	 esi
  00f48	5b		 pop	 ebx

; 908  : }

  00f49	c3		 ret	 0
$L72689:

; 885  : 		return;
; 886  : 	}
; 887  : 	/* Never stress [@], [E], [I], [^] in initial VCC sylable.	*/
; 888  : 	if (ls_adju_is_voc(pp) != FALSE
; 889  : 	&& ls_adju_is_cons(pp->p_fp) != FALSE
; 890  : 	&& ls_adju_is_cons(pp->p_fp->p_fp) != FALSE) 

  00f4a	56		 push	 esi
  00f4b	e8 00 00 00 00	 call	 _ls_adju_is_voc
  00f50	83 c4 04	 add	 esp, 4
  00f53	85 c0		 test	 eax, eax
  00f55	74 41		 je	 SHORT $L72691
  00f57	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00f59	51		 push	 ecx
  00f5a	e8 00 00 00 00	 call	 _ls_adju_is_cons
  00f5f	83 c4 04	 add	 esp, 4
  00f62	85 c0		 test	 eax, eax
  00f64	74 32		 je	 SHORT $L72691
  00f66	8b 16		 mov	 edx, DWORD PTR [esi]
  00f68	8b 02		 mov	 eax, DWORD PTR [edx]
  00f6a	50		 push	 eax
  00f6b	e8 00 00 00 00	 call	 _ls_adju_is_cons
  00f70	83 c4 04	 add	 esp, 4
  00f73	85 c0		 test	 eax, eax
  00f75	74 21		 je	 SHORT $L72691

; 891  : 	{
; 892  : #ifdef ENGLISH_US
; 893  : 		if (ph==US_AE || ph==US_EH || ph==US_IH || ph==US_AH) 

  00f77	83 ff 05	 cmp	 edi, 5
  00f7a	74 0f		 je	 SHORT $L72692
  00f7c	83 ff 04	 cmp	 edi, 4
  00f7f	74 0a		 je	 SHORT $L72692
  00f81	83 ff 02	 cmp	 edi, 2
  00f84	74 05		 je	 SHORT $L72692
  00f86	83 ff 09	 cmp	 edi, 9
  00f89	75 0d		 jne	 SHORT $L72691
$L72692:
  00f8b	5f		 pop	 edi

; 894  : #endif
; 895  : #ifdef ENGLISH_UK
; 896  : 		if (ph==UK_AE || ph==UK_EH || ph==UK_IH || ph==UK_AH) 
; 897  : #endif
; 898  : #ifdef GERMAN
; 899  : 		if (ph==GR_AE || ph==GR_EH || ph==GR_IH || ph==GR_AH) 
; 900  : #endif
; 901  : 		{
; 902  : 			pLts_t->psyl = 1;

  00f8c	66 c7 83 34 04
	00 00 01 00	 mov	 WORD PTR [ebx+1076], 1
  00f95	5e		 pop	 esi
  00f96	5b		 pop	 ebx

; 908  : }

  00f97	c3		 ret	 0
$L72691:
  00f98	5f		 pop	 edi

; 903  : 			return;
; 904  : 		}		
; 905  : 	}
; 906  : 	/* Best default is stress first sylable.			*/
; 907  : 	pLts_t->psyl = 0;

  00f99	66 c7 83 34 04
	00 00 00 00	 mov	 WORD PTR [ebx+1076], 0
  00fa2	5e		 pop	 esi
  00fa3	5b		 pop	 ebx

; 908  : }

  00fa4	c3		 ret	 0
_ls_adju_best2syl ENDP
_pLts_t$ = 8
_ls_adju_final_fixes PROC NEAR

; 933  : 
; 934  : #if defined ENGLISH_US || defined ENGLISH_UK // NAL warning removal
; 935  : 	PHONE	*pp;
; 936  : #endif
; 937  : 	int	last;
; 938  : 
; 939  : 	last = SPRI;
; 940  : 	while (pLts_t->psyl!=0 && pLts_t->sylp[pLts_t->psyl-1]->p_stress!=SNONE) 

  00fb0	8b 44 24 04	 mov	 eax, DWORD PTR _pLts_t$[esp-4]
  00fb4	56		 push	 esi
  00fb5	57		 push	 edi
  00fb6	66 83 b8 34 04
	00 00 00	 cmp	 WORD PTR [eax+1076], 0
  00fbe	ba 7e 00 00 00	 mov	 edx, 126		; 0000007eH
  00fc3	bf 7b 00 00 00	 mov	 edi, 123		; 0000007bH
  00fc8	74 30		 je	 SHORT $L72857
$L72699:
  00fca	66 8b 88 34 04
	00 00		 mov	 cx, WORD PTR [eax+1076]
  00fd1	0f bf f1	 movsx	 esi, cx
  00fd4	8b b4 b0 04 04
	00 00		 mov	 esi, DWORD PTR [eax+esi*4+1028]
  00fdb	39 7e 10	 cmp	 DWORD PTR [esi+16], edi
  00fde	74 1a		 je	 SHORT $L72857

; 941  : 	{
; 942  : 		--pLts_t->psyl;

  00fe0	49		 dec	 ecx

; 943  : 		last = pLts_t->sylp[pLts_t->psyl]->p_stress;

  00fe1	0f bf d1	 movsx	 edx, cx
  00fe4	66 89 88 34 04
	00 00		 mov	 WORD PTR [eax+1076], cx
  00feb	8b 94 90 08 04
	00 00		 mov	 edx, DWORD PTR [eax+edx*4+1032]
  00ff2	66 85 c9	 test	 cx, cx
  00ff5	8b 52 10	 mov	 edx, DWORD PTR [edx+16]
  00ff8	75 d0		 jne	 SHORT $L72699
$L72857:

; 944  : 	}
; 945  : 	while (pLts_t->psyl != 0) 

  00ffa	66 8b 88 34 04
	00 00		 mov	 cx, WORD PTR [eax+1076]
  01001	66 85 c9	 test	 cx, cx
  01004	74 54		 je	 SHORT $L72703
  01006	be 7c 00 00 00	 mov	 esi, 124		; 0000007cH
$L72702:

; 946  : 	{
; 947  : 		--pLts_t->psyl;

  0100b	49		 dec	 ecx

; 948  : 		if (last == SUN) 

  0100c	3b d6		 cmp	 edx, esi
  0100e	66 89 88 34 04
	00 00		 mov	 WORD PTR [eax+1076], cx
  01015	75 1f		 jne	 SHORT $L72704

; 949  : 		{		/* Block reduction.	*/
; 950  : 			if (pLts_t->sylp[pLts_t->psyl]->p_stress == SNONE)

  01017	0f bf c9	 movsx	 ecx, cx
  0101a	8b 8c 88 08 04
	00 00		 mov	 ecx, DWORD PTR [eax+ecx*4+1032]
  01021	39 79 10	 cmp	 DWORD PTR [ecx+16], edi
  01024	75 09		 jne	 SHORT $L72705

; 951  : 				pLts_t->sylp[pLts_t->psyl]->p_flag |= PFBLOCK;

  01026	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  01029	80 ca 80	 or	 dl, -128		; ffffff80H
  0102c	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L72705:

; 952  : 			last = SSEC;

  0102f	ba 7d 00 00 00	 mov	 edx, 125		; 0000007dH

; 953  : 		} 
; 954  : 		else

  01034	eb 02		 jmp	 SHORT $L72706
$L72704:

; 955  : 		{
; 956  : 			last = SUN;

  01036	8b d6		 mov	 edx, esi
$L72706:

; 957  : 		}
; 958  : 		if (pLts_t->sylp[pLts_t->psyl]->p_stress == SNONE)

  01038	0f bf 88 34 04
	00 00		 movsx	 ecx, WORD PTR [eax+1076]
  0103f	8b 8c 88 08 04
	00 00		 mov	 ecx, DWORD PTR [eax+ecx*4+1032]
  01046	39 79 10	 cmp	 DWORD PTR [ecx+16], edi
  01049	75 03		 jne	 SHORT $L72707

; 959  : 			pLts_t->sylp[pLts_t->psyl]->p_stress = SUN;

  0104b	89 71 10	 mov	 DWORD PTR [ecx+16], esi
$L72707:

; 944  : 	}
; 945  : 	while (pLts_t->psyl != 0) 

  0104e	66 8b 88 34 04
	00 00		 mov	 cx, WORD PTR [eax+1076]
  01055	66 85 c9	 test	 cx, cx
  01058	75 b1		 jne	 SHORT $L72702
$L72703:

; 960  : 	}
; 961  : #ifdef ENGLISH_US
; 962  : 	pp = pLts_t->phead.p_fp;			/* [xn] => [^n].	*/

  0105a	8b 88 c8 08 00
	00		 mov	 ecx, DWORD PTR [eax+2248]
  01060	8d 90 c8 08 00
	00		 lea	 edx, DWORD PTR [eax+2248]

; 963  : 	if (pp->p_sphone ==US_AX
; 964  : 	&& (pp=pp->p_fp) != &pLts_t->phead
; 965  : 	&&  pp->p_sphone ==US_N
; 966  : 	&& (pp=pp->p_fp) != &pLts_t->phead
; 967  : 	&& (pp->p_flag&PFSYLAB) != 0) 

  01066	bf 11 00 00 00	 mov	 edi, 17			; 00000011H
  0106b	39 79 14	 cmp	 DWORD PTR [ecx+20], edi
  0106e	75 2d		 jne	 SHORT $L72708
  01070	8b 31		 mov	 esi, DWORD PTR [ecx]
  01072	3b f2		 cmp	 esi, edx
  01074	74 27		 je	 SHORT $L72708
  01076	83 7e 14 20	 cmp	 DWORD PTR [esi+20], 32	; 00000020H
  0107a	75 21		 jne	 SHORT $L72708
  0107c	8b 36		 mov	 esi, DWORD PTR [esi]
  0107e	3b f2		 cmp	 esi, edx
  01080	74 1b		 je	 SHORT $L72708
  01082	f6 46 0c 10	 test	 BYTE PTR [esi+12], 16	; 00000010H
  01086	74 15		 je	 SHORT $L72708

; 968  : 	{
; 969  : 		pp = pLts_t->phead.p_fp;
; 970  : 		pp->p_sphone = US_AH;

  01088	c7 41 14 09 00
	00 00		 mov	 DWORD PTR [ecx+20], 9

; 971  : 		pp->p_uphone = SIL;

  0108f	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 972  : 		pp->p_stress = SPRI;

  01096	c7 41 10 7e 00
	00 00		 mov	 DWORD PTR [ecx+16], 126	; 0000007eH
$L72708:

; 973  : 	}
; 974  : 	if (pLts_t->nsyl == 3) 

  0109d	66 83 b8 30 04
	00 00 03	 cmp	 WORD PTR [eax+1072], 3
  010a5	75 2d		 jne	 SHORT $L72711

; 975  : 	{	/* "camera" rule.	*/
; 976  : 		pp = pLts_t->phead.p_bp;

  010a7	8b 88 cc 08 00
	00		 mov	 ecx, DWORD PTR [eax+2252]

; 977  : 
; 978  : #ifdef DGC
; 979  : 		if (pp->p_sphone ==US_Z)		/* "cameras".		*/

  010ad	83 79 14 2a	 cmp	 DWORD PTR [ecx+20], 42	; 0000002aH
  010b1	75 03		 jne	 SHORT $L72710

; 980  : 			pp = pp->p_bp;

  010b3	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
$L72710:

; 981  : 		if (pp!=&pLts_t->phead && pp->p_sphone==US_AA && pp->p_uphone==US_AX)

  010b6	3b ca		 cmp	 ecx, edx
  010b8	74 1a		 je	 SHORT $L72711
  010ba	83 79 14 06	 cmp	 DWORD PTR [ecx+20], 6
  010be	75 14		 jne	 SHORT $L72711
  010c0	39 79 18	 cmp	 DWORD PTR [ecx+24], edi
  010c3	75 0f		 jne	 SHORT $L72711

; 982  : 			pLts_t->sylp[2]->p_flag &= ~PFBLOCK;

  010c5	8b 80 10 04 00
	00		 mov	 eax, DWORD PTR [eax+1040]
  010cb	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  010ce	80 e1 7f	 and	 cl, 127			; 0000007fH
  010d1	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$L72711:
  010d4	5f		 pop	 edi
  010d5	5e		 pop	 esi

; 983  : #else
; 984  : 		if (pp->p_sphone==US_AA && pp->p_uphone==US_AX)
; 985  : 			pLts_t->sylp[2]->p_flag &= ~PFBLOCK;
; 986  : #endif
; 987  : 	}       
; 988  : #endif //ENGLISH_US
; 989  : #ifdef ENGLISH_UK
; 990  : 	pp = pLts_t->phead.p_fp;			/* [xn] => [^n].	*/
; 991  : 	if (pp->p_sphone ==UK_AX
; 992  : 	&& (pp=pp->p_fp) != &pLts_t->phead
; 993  : 	&&  pp->p_sphone ==UK_N
; 994  : 	&& (pp=pp->p_fp) != &pLts_t->phead
; 995  : 	&& (pp->p_flag&PFSYLAB) != 0) 
; 996  : 	{
; 997  : 		pp = pLts_t->phead.p_fp;
; 998  : 		pp->p_sphone = UK_AH;
; 999  : 		pp->p_uphone = SIL;
; 1000 : 		pp->p_stress = SPRI;
; 1001 : 	}
; 1002 : 	if (pLts_t->nsyl == 3) 
; 1003 : 	{	/* "camera" rule.	*/
; 1004 : 		pp = pLts_t->phead.p_bp;
; 1005 : 
; 1006 : #ifdef DGC
; 1007 : 		if (pp->p_sphone ==UK_Z)		/* "cameras".		*/
; 1008 : 			pp = pp->p_bp;
; 1009 : 		if (pp!=&pLts_t->phead && pp->p_sphone==UK_AA && pp->p_uphone==UK_AX)
; 1010 : 			pLts_t->sylp[2]->p_flag &= ~PFBLOCK;
; 1011 : #else
; 1012 : 		if (pp->p_sphone==UK_AA && pp->p_uphone==UK_AX)
; 1013 : 			pLts_t->sylp[2]->p_flag &= ~PFBLOCK;
; 1014 : #endif
; 1015 : 	}       
; 1016 : #endif   //ENGLISH_UK
; 1017 : }

  010d6	c3		 ret	 0
_ls_adju_final_fixes ENDP
_TEXT	ENDS
PUBLIC	_ls_adju_allo1
_TEXT	SEGMENT
_pLts_t$ = 8
_fpp$ = 12
_lpp$ = 16
_ls_adju_allo1 PROC NEAR

; 1041 : {

  010e0	53		 push	 ebx

; 1042 : 	PHONE	*pp1;
; 1043 : 	PHONE	*pp2;
; 1044 : 	int	i;
; 1045 : 
; 1046 : 	pp1 = fpp;				/* Left end.		*/

  010e1	8b 5c 24 0c	 mov	 ebx, DWORD PTR _fpp$[esp]
  010e5	55		 push	 ebp

; 1047 : 	while (pp1 != lpp) 

  010e6	8b 6c 24 14	 mov	 ebp, DWORD PTR _lpp$[esp+4]
  010ea	56		 push	 esi
  010eb	3b dd		 cmp	 ebx, ebp
  010ed	57		 push	 edi
  010ee	8b f3		 mov	 esi, ebx
  010f0	0f 84 b2 00 00
	00		 je	 $L72861
  010f6	8b 7c 24 14	 mov	 edi, DWORD PTR _pLts_t$[esp+12]
$L72723:

; 1048 : 	{			/* Until right end.	*/
; 1049 : 		/*
; 1050 : 		 * [z] > [|][z] / [+Cons,+Sib] + - #
; 1051 : 		 * [z] > [s]    / [+Cons,-Voice] + - #
; 1052 : 		 */
; 1053 : 		if (pp1->p_sphone == US_Z		/* Phoneme is "z"	*/
; 1054 : 		&& (pp1->p_flag&PFMORPH) != 0	/* at left end of morph	*/
; 1055 : 		&& pp1->p_fp == lpp		/* and right is "#"	*/
; 1056 : 		&& pp1 != fpp) 

  010fa	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  010fd	83 f9 2a	 cmp	 ecx, 42			; 0000002aH
  01100	75 4e		 jne	 SHORT $L72728
  01102	f6 46 0c 0f	 test	 BYTE PTR [esi+12], 15	; 0000000fH
  01106	74 48		 je	 SHORT $L72728
  01108	39 2e		 cmp	 DWORD PTR [esi], ebp
  0110a	75 44		 jne	 SHORT $L72728
  0110c	3b f3		 cmp	 esi, ebx
  0110e	74 40		 je	 SHORT $L72728

; 1057 : 		{		/* and stuff on left.	*/
; 1058 : 			pp2 = pp1->p_bp;
; 1059 : 			i = pfeat[pp2->p_sphone];

  01110	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  01113	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  01116	33 c0		 xor	 eax, eax
  01118	66 8b 04 55 00
	00 00 00	 mov	 ax, WORD PTR _pfeat[edx*2]

; 1060 : 			if ((i&(PCONS|PSIB)) == (PCONS|PSIB)) 

  01120	8b d0		 mov	 edx, eax
  01122	83 e2 11	 and	 edx, 17			; 00000011H
  01125	80 fa 11	 cmp	 dl, 17			; 00000011H
  01128	75 16		 jne	 SHORT $L72726

; 1061 : 			{
; 1062 : 				if (ls_adju_ins_phone(pLts_t,pp1, US_IX, SIL, SUN) == FALSE)

  0112a	6a 7c		 push	 124			; 0000007cH
  0112c	6a 00		 push	 0
  0112e	6a 12		 push	 18			; 00000012H
  01130	56		 push	 esi
  01131	57		 push	 edi
  01132	e8 00 00 00 00	 call	 _ls_adju_ins_phone
  01137	83 c4 14	 add	 esp, 20			; 00000014H
  0113a	85 c0		 test	 eax, eax
  0113c	74 6a		 je	 SHORT $L72861

; 1063 : 					return;
; 1064 : 				pp1 = pp1->p_fp;
; 1065 : 				continue;

  0113e	eb 5e		 jmp	 SHORT $L72733
$L72726:

; 1066 : 			}
; 1067 : 			if ((i&(PCONS|PVOICE)) == PCONS) 

  01140	83 e0 09	 and	 eax, 9
  01143	3c 01		 cmp	 al, 1
  01145	75 09		 jne	 SHORT $L72728

; 1068 : 			{
; 1069 : 				pp1->p_sphone = US_S;

  01147	c7 46 14 29 00
	00 00		 mov	 DWORD PTR [esi+20], 41	; 00000029H

; 1070 : 				pp1 = pp1->p_fp;
; 1071 : 				continue;

  0114e	eb 4e		 jmp	 SHORT $L72733
$L72728:

; 1072 : 			}
; 1073 : 		}
; 1074 : 		/*
; 1075 : 		 * [d] > [|][d] / {[t],[d]} + - #
; 1076 : 		 * [d] > [t]    / [+Cons,-Voice] + - #
; 1077 : 		 */
; 1078 : 		if (pp1->p_sphone == US_D			/* Phoneme is "d"	*/
; 1079 : 		&& (pp1->p_flag&PFMORPH) != 0	/* at left end of morph	*/
; 1080 : 		&& pp1->p_fp == lpp				/* and right is "#"	*/
; 1081 : 		&& pp1 != fpp) 

  01150	83 f9 30	 cmp	 ecx, 48			; 00000030H
  01153	75 49		 jne	 SHORT $L72733
  01155	f6 46 0c 0f	 test	 BYTE PTR [esi+12], 15	; 0000000fH
  01159	74 43		 je	 SHORT $L72733
  0115b	39 2e		 cmp	 DWORD PTR [esi], ebp
  0115d	75 3f		 jne	 SHORT $L72733
  0115f	3b f3		 cmp	 esi, ebx
  01161	74 3b		 je	 SHORT $L72733

; 1082 : 		{		
; 1083 : 			/* and stuff on left.	*/
; 1084 : 			pp2 = pp1->p_bp;
; 1085 : 			i = pp2->p_sphone;

  01163	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  01166	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 1086 : 			if (i==US_T || i==US_D) 

  01169	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0116c	74 1c		 je	 SHORT $L72731
  0116e	3b c1		 cmp	 eax, ecx
  01170	74 18		 je	 SHORT $L72731

; 1089 : 					return;
; 1090 : 				pp1 = pp1->p_fp;
; 1091 : 				continue;
; 1092 : 			}
; 1093 : 			if ((pfeat[i]&(PCONS|PVOICE)) == PCONS) 

  01172	8a 0c 45 00 00
	00 00		 mov	 cl, BYTE PTR _pfeat[eax*2]
  01179	80 e1 09	 and	 cl, 9
  0117c	80 f9 01	 cmp	 cl, 1
  0117f	75 1d		 jne	 SHORT $L72733

; 1094 : 			{
; 1095 : 				pp1->p_sphone = US_T;

  01181	c7 46 14 2f 00
	00 00		 mov	 DWORD PTR [esi+20], 47	; 0000002fH

; 1096 : 				pp1 = pp1->p_fp;
; 1097 : 				continue;

  01188	eb 14		 jmp	 SHORT $L72733
$L72731:

; 1087 : 			{
; 1088 : 				if (ls_adju_ins_phone(pLts_t,pp1, US_IX, SIL, SUN) == FALSE)

  0118a	6a 7c		 push	 124			; 0000007cH
  0118c	6a 00		 push	 0
  0118e	6a 12		 push	 18			; 00000012H
  01190	56		 push	 esi
  01191	57		 push	 edi
  01192	e8 00 00 00 00	 call	 _ls_adju_ins_phone
  01197	83 c4 14	 add	 esp, 20			; 00000014H
  0119a	85 c0		 test	 eax, eax
  0119c	74 0a		 je	 SHORT $L72861
$L72733:

; 1098 : 			}
; 1099 : 		}
; 1100 : 		pp1 = pp1->p_fp;

  0119e	8b 36		 mov	 esi, DWORD PTR [esi]
  011a0	3b f5		 cmp	 esi, ebp
  011a2	0f 85 52 ff ff
	ff		 jne	 $L72723
$L72861:
  011a8	5f		 pop	 edi
  011a9	5e		 pop	 esi
  011aa	5d		 pop	 ebp
  011ab	5b		 pop	 ebx

; 1101 : 	}
; 1102 : }

  011ac	c3		 ret	 0
_ls_adju_allo1 ENDP
_TEXT	ENDS
PUBLIC	_ls_adju_delgemphone
_TEXT	SEGMENT
_pLts_t$ = 8
_pp$ = 12
_ph$ = 16
_ls_adju_delgemphone PROC NEAR

; 1193 : 	PHONE *bp;
; 1194 : 
; 1195 : 	bp = pp->p_bp;					/* Point at first.	*/

  011b0	8b 44 24 08	 mov	 eax, DWORD PTR _pp$[esp-4]

; 1196 : 	pp->p_sphone = ph;				/* Zap phoneme.		*/

  011b4	8b 54 24 0c	 mov	 edx, DWORD PTR _ph$[esp-4]
  011b8	56		 push	 esi
  011b9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1197 : 	pp->p_flag |= bp->p_flag;		/* Move flags forward.	*/

  011bc	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  011bf	89 50 14	 mov	 DWORD PTR [eax+20], edx
  011c2	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  011c5	0b f2		 or	 esi, edx
  011c7	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 1198 : 	if (bp->p_stress > pp->p_stress)/* Keep strongest.	*/

  011ca	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  011cd	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  011d0	3b d6		 cmp	 edx, esi
  011d2	5e		 pop	 esi
  011d3	7e 03		 jle	 SHORT $L72742

; 1199 : 		pp->p_stress = bp->p_stress;

  011d5	89 50 10	 mov	 DWORD PTR [eax+16], edx
$L72742:

; 1200 : 	ls_adju_del_phone(pLts_t,bp);	/* Delete first one.	*/ 

  011d8	8b 44 24 04	 mov	 eax, DWORD PTR _pLts_t$[esp-4]
  011dc	51		 push	 ecx
  011dd	50		 push	 eax
  011de	e8 00 00 00 00	 call	 _ls_adju_del_phone
  011e3	83 c4 08	 add	 esp, 8

; 1201 : }

  011e6	c3		 ret	 0
_ls_adju_delgemphone ENDP
_pp$ = 8
_ls_adju_is_obs PROC NEAR

; 1222 : 	if ((pfeat[pp->p_sphone]&POBS) != 0)

  011f0	8b 44 24 04	 mov	 eax, DWORD PTR _pp$[esp-4]
  011f4	33 d2		 xor	 edx, edx
  011f6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  011f9	8a 14 4d 00 00
	00 00		 mov	 dl, BYTE PTR _pfeat[ecx*2]
  01200	8b c2		 mov	 eax, edx
  01202	c1 e8 05	 shr	 eax, 5
  01205	83 e0 01	 and	 eax, 1

; 1223 : 	return (TRUE);
; 1224 : 	return (FALSE);
; 1225 : }

  01208	c3		 ret	 0
_ls_adju_is_obs ENDP
_TEXT	ENDS
EXTRN	_ls_rule_phone_alloc:NEAR
_TEXT	SEGMENT
_pLts_t$ = 8
_fpp$ = 12
_sph$ = 16
_uph$ = 20
_stress$ = 24
_ls_adju_ins_phone PROC NEAR

; 1255 : 	PHONE	*ipp;
; 1256 : 	PHONE	*bpp;
; 1257 : 
; 1258 : 	if ((ipp=ls_rule_phone_alloc(pLts_t)) == (PHONE *)NULL)		/* Get new node		*/

  01210	8b 44 24 04	 mov	 eax, DWORD PTR _pLts_t$[esp-4]
  01214	50		 push	 eax
  01215	e8 00 00 00 00	 call	 _ls_rule_phone_alloc
  0121a	83 c4 04	 add	 esp, 4
  0121d	85 c0		 test	 eax, eax
  0121f	75 01		 jne	 SHORT $L72762

; 1273 : }

  01221	c3		 ret	 0
$L72762:

; 1259 : 		return (FALSE);
; 1260 : 	bpp = fpp->p_bp;			/* Get previous		*/

  01222	8b 4c 24 08	 mov	 ecx, DWORD PTR _fpp$[esp-4]
  01226	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 1261 : 	bpp->p_fp = ipp;			/* Link in			*/

  01229	89 02		 mov	 DWORD PTR [edx], eax

; 1262 : 	ipp->p_fp = fpp;

  0122b	89 08		 mov	 DWORD PTR [eax], ecx

; 1263 : 	fpp->p_bp = ipp;

  0122d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1264 : 	ipp->p_bp = bpp;

  01230	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1265 : 	ipp->p_ip = NULL;			/* No index chain	*/
; 1266 : 	ipp->p_sphone = sph;		/* Phonemes			*/

  01233	8b 54 24 0c	 mov	 edx, DWORD PTR _sph$[esp-4]
  01237	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0123e	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 1267 : 	ipp->p_uphone = uph;

  01241	8b 54 24 10	 mov	 edx, DWORD PTR _uph$[esp-4]
  01245	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 1268 : 	ipp->p_flag = fpp->p_flag;	/* Move flags forward	*/

  01248	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0124b	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 1269 : 	fpp->p_flag = 0;
; 1270 : 	ipp->p_stress = stress;		/* Set stress			*/

  0124e	8b 54 24 14	 mov	 edx, DWORD PTR _stress$[esp-4]
  01252	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  01259	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 1271 : 	fpp->p_stress = SNONE;

  0125c	c7 41 10 7b 00
	00 00		 mov	 DWORD PTR [ecx+16], 123	; 0000007bH

; 1272 : 	return (TRUE);

  01263	b8 01 00 00 00	 mov	 eax, 1

; 1273 : }

  01268	c3		 ret	 0
_ls_adju_ins_phone ENDP
_TEXT	ENDS
EXTRN	_ls_rule_phone_free:NEAR
_TEXT	SEGMENT
_pLts_t$ = 8
_dpp$ = 12
_ls_adju_del_phone PROC NEAR

; 1298 : 	PHONE	*bpp;
; 1299 : 	PHONE	*fpp;
; 1300 : 
; 1301 : 	bpp = dpp->p_bp;				/* Get previous, next	*/

  01270	8b 44 24 08	 mov	 eax, DWORD PTR _dpp$[esp-4]

; 1302 : 	fpp = dpp->p_fp;
; 1303 : 	bpp->p_fp = fpp;				/* Break links			*/
; 1304 : 	fpp->p_bp = bpp;
; 1305 : 
; 1306 : 	ls_rule_phone_free(pLts_t,dpp);	/* Free the node		*/

  01274	50		 push	 eax
  01275	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01278	8b 10		 mov	 edx, DWORD PTR [eax]
  0127a	8b 44 24 08	 mov	 eax, DWORD PTR _pLts_t$[esp]
  0127e	89 11		 mov	 DWORD PTR [ecx], edx
  01280	50		 push	 eax
  01281	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  01284	e8 00 00 00 00	 call	 _ls_rule_phone_free
  01289	83 c4 08	 add	 esp, 8

; 1307 : }       

  0128c	c3		 ret	 0
_ls_adju_del_phone ENDP
_TEXT	ENDS
END
