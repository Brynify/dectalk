	TITLE	D:\work\Product\dapi\src\Cmd\cm_util.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_tlikmap
PUBLIC	_tlitone0
PUBLIC	_tlitone1
PUBLIC	_tliproto
_DATA	SEGMENT
_tlikmap DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	02aH
	DB	023H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
_tlitone0 DW	0538H
	DW	04b9H
	DW	0538H
	DW	05c5H
	DW	04b9H
	DW	0538H
	DW	05c5H
	DW	04b9H
	DW	0538H
	DW	05c5H
	DW	04b9H
	DW	05c5H
	DW	0661H
	DW	0661H
	DW	0661H
	DW	0661H
_tlitone1 DW	03adH
	DW	02b9H
	DW	02b9H
	DW	02b9H
	DW	0302H
	DW	0302H
	DW	0302H
	DW	0354H
	DW	0354H
	DW	0354H
	DW	03adH
	DW	03adH
	DW	0302H
	DW	0354H
	DW	03adH
	ORG $+2
_tliproto DW	00H
	DW	00H
	DW	01996H
	DW	0101bH
	DW	05H
	DW	0640H
	DW	01996H
	DW	0101bH
	DW	05H
	DW	0258H
_DATA	ENDS
PUBLIC	_cm_util_initialize
_TEXT	SEGMENT
_phTTS$ = 8
_cm_util_initialize PROC NEAR

; 109  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]

; 110  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  0000a	8b 70 08	 mov	 esi, DWORD PTR [eax+8]

; 111  : /*	INPUT_SEQ command_seq; */
; 112  : 	int i;
; 113  : 
; 114  : 	pCmd_t->error_mode = ERROR_speak;
; 115  : 	pCmd_t->punct_mode = PUNCT_some;
; 116  : 	pCmd_t->skip_mode = SKIP_none;

  0000d	33 db		 xor	 ebx, ebx

; 117  : 	pCmd_t->last_punct = 0; 
; 118  : 	pCmd_t->last_char=0;
; 119  : 	pCmd_t->timeout=0;
; 120  : 	memset(pCmd_t->esc_seq,0,sizeof(INPUT_SEQ));

  0000f	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  00014	8b ba 24 05 00
	00		 mov	 edi, DWORD PTR [edx+1316]
  0001a	33 c0		 xor	 eax, eax
  0001c	c7 82 08 05 00
	00 03 00 00 00	 mov	 DWORD PTR [edx+1288], 3
  00026	c7 82 0c 05 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+1292], 1
  00030	89 9a 10 05 00
	00		 mov	 DWORD PTR [edx+1296], ebx
  00036	89 9a 14 05 00
	00		 mov	 DWORD PTR [edx+1300], ebx
  0003c	89 9a f8 02 00
	00		 mov	 DWORD PTR [edx+760], ebx
  00042	66 89 9a 94 57
	00 00		 mov	 WORD PTR [edx+22420], bx
  00049	f3 ab		 rep stosd
  0004b	66 ab		 stosw

; 121  : 	pCmd_t->esc_seq->type = 0;

  0004d	8b 82 24 05 00
	00		 mov	 eax, DWORD PTR [edx+1316]
  00053	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00058	66 89 18	 mov	 WORD PTR [eax], bx

; 122  : #ifdef MSDOS
; 123  : 	pCmd_t->tone_wait = 0;
; 124  : #endif
; 125  : 	pKsd_t->phoneme_mode = PHONEME_OFF | PHONEME_SPEAK;

  0005b	c7 86 d0 03 00
	00 05 00 00 00	 mov	 DWORD PTR [esi+976], 5

; 126  : 	pKsd_t->pitch_delta = 35;

  00065	c7 86 18 04 00
	00 23 00 00 00	 mov	 DWORD PTR [esi+1048], 35 ; 00000023H

; 127  : 	pCmd_t->insertflag=0;

  0006f	66 89 9a 20 05
	00 00		 mov	 WORD PTR [edx+1312], bx

; 128  : 	
; 129  : 	pKsd_t->debug_switch = 0;

  00076	66 89 9e 40 06
	00 00		 mov	 WORD PTR [esi+1600], bx

; 130  : 	pKsd_t->gender_switch = 0;

  0007d	66 89 9e 42 06
	00 00		 mov	 WORD PTR [esi+1602], bx

; 131  : 
; 132  : 	/* mfg 05/18/1998 initialize dbglog file pointer */
; 133  : 	pKsd_t->dbglog = 0;

  00084	89 9e 44 06 00
	00		 mov	 DWORD PTR [esi+1604], ebx
  0008a	8d 42 28	 lea	 eax, DWORD PTR [edx+40]
$L71260:

; 134  :     /* GL 02/28/1997  set MODE_LATIN based on the compiler switch */
; 135  :     /* only for MSDOS build. DECtalk software switch is in ttsapi.c */
; 136  : #ifdef MSDOS
; 137  : #ifdef SPANISH_LA
; 138  :     pKsd_t->modeflag = MODE_CITATION | MODE_LATIN;
; 139  : #else
; 140  :     pKsd_t->modeflag = MODE_CITATION;
; 141  : #endif
; 142  : #endif
; 143  : 	/* Initialize setv[] */
; 144  : 	for (i=0; i<10;i++)
; 145  : 	{
; 146  : 		pCmd_t->setv[i].cmd[0] = '\0'; 

  0008d	88 18		 mov	 BYTE PTR [eax], bl
  0008f	83 c0 3c	 add	 eax, 60			; 0000003cH
  00092	49		 dec	 ecx
  00093	75 f8		 jne	 SHORT $L71260

; 147  : 	}
; 148  : 	 
; 149  : 	/* Initialize pCmd_t->param[] */
; 150  : 	for (i=0; i < NPARAM; i++)
; 151  : 	{
; 152  : 		pCmd_t->params[i] = 0;

  00095	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0009a	33 c0		 xor	 eax, eax
  0009c	8b fa		 mov	 edi, edx

; 153  : 	}
; 154  : 	
; 155  : 	pCmd_t->done = 0;
; 156  :     pCmd_t->roll_text = 0;
; 157  :     pCmd_t->email_header = 0;
; 158  :     pCmd_t->index_counter = 0;
; 159  :     pCmd_t->input_counter = 0;
; 160  : 
; 161  : 	memset(pCmd_t->clausebuf,0,PAR_MAX_INPUT_ARRAY);

  0009e	8d b2 3c 05 00
	00		 lea	 esi, DWORD PTR [edx+1340]
  000a4	f3 ab		 rep stosd
  000a6	b9 e1 00 00 00	 mov	 ecx, 225		; 000000e1H
  000ab	8b fe		 mov	 edi, esi
  000ad	66 89 9a 72 57
	00 00		 mov	 WORD PTR [edx+22386], bx
  000b4	66 89 9a 38 05
	00 00		 mov	 WORD PTR [edx+1336], bx
  000bb	66 89 9a 3a 05
	00 00		 mov	 WORD PTR [edx+1338], bx
  000c2	66 89 9a 36 05
	00 00		 mov	 WORD PTR [edx+1334], bx
  000c9	66 89 9a 34 05
	00 00		 mov	 WORD PTR [edx+1332], bx
  000d0	f3 ab		 rep stosd

; 162  : 	memset(pCmd_t->wordbuf,0,50);

  000d2	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  000d7	8d ba c0 08 00
	00		 lea	 edi, DWORD PTR [edx+2240]
  000dd	f3 ab		 rep stosd
  000df	66 ab		 stosw

; 163  : 	memset(pCmd_t->new_input,0,PAR_MAX_INPUT_ARRAY);

  000e1	b9 e1 00 00 00	 mov	 ecx, 225		; 000000e1H
  000e6	33 c0		 xor	 eax, eax
  000e8	8d ba c8 0f 00
	00		 lea	 edi, DWORD PTR [edx+4040]
  000ee	f3 ab		 rep stosd

; 164  : 	memset(pCmd_t->output_buf,0,PAR_MAX_OUTPUT_ARRAY);

  000f0	b9 e1 00 00 00	 mov	 ecx, 225		; 000000e1H
  000f5	8d ba 44 0c 00
	00		 lea	 edi, DWORD PTR [edx+3140]
  000fb	f3 ab		 rep stosd

; 165  : 	memset(pCmd_t->dict_hit_buf,0,PAR_MAX_INPUT_ARRAY);

  000fd	b9 e1 00 00 00	 mov	 ecx, 225		; 000000e1H
  00102	8d ba 4c 13 00
	00		 lea	 edi, DWORD PTR [edx+4940]
  00108	f3 ab		 rep stosd

; 166  : 
; 167  : #ifdef NEW_INDEXING
; 168  : 	memset(pCmd_t->input_indexes,0,PAR_MAX_INPUT_ARRAY*sizeof(index_data_t));

  0010a	b9 46 05 00 00	 mov	 ecx, 1350		; 00000546H
  0010f	8d ba d0 16 00
	00		 lea	 edi, DWORD PTR [edx+5840]
  00115	f3 ab		 rep stosd

; 169  : 	memset(pCmd_t->new_input_indexes,0,PAR_MAX_INPUT_ARRAY*sizeof(index_data_t));

  00117	b9 46 05 00 00	 mov	 ecx, 1350		; 00000546H
  0011c	8d ba e8 2b 00
	00		 lea	 edi, DWORD PTR [edx+11240]
  00122	f3 ab		 rep stosd

; 170  : 	memset(pCmd_t->output_indexes,0,PAR_MAX_OUTPUT_ARRAY*sizeof(index_data_t));

  00124	b9 46 05 00 00	 mov	 ecx, 1350		; 00000546H
  00129	8d ba 00 41 00
	00		 lea	 edi, DWORD PTR [edx+16640]
  0012f	f3 ab		 rep stosd

; 171  : #endif
; 172  : 	pCmd_t->prevword=&(pCmd_t->clausebuf[1]);

  00131	8d 8a 3d 05 00
	00		 lea	 ecx, DWORD PTR [edx+1341]

; 173  :     pCmd_t->prev_word_index=0;
; 174  : 	pCmd_t->clausebuf[0]=' ';

  00137	c6 06 20	 mov	 BYTE PTR [esi], 32	; 00000020H

; 175  : 	memset(&(pCmd_t->ret_value),0,sizeof(return_value_t));

  0013a	8d b2 74 57 00
	00		 lea	 esi, DWORD PTR [edx+22388]
  00140	89 8a 6c 57 00
	00		 mov	 DWORD PTR [edx+22380], ecx
  00146	b9 08 00 00 00	 mov	 ecx, 8
  0014b	8b fe		 mov	 edi, esi
  0014d	66 89 9a 70 57
	00 00		 mov	 WORD PTR [edx+22384], bx
  00154	f3 ab		 rep stosd

; 176  : 	pCmd_t->ret_value.input_pos = 0;

  00156	89 1e		 mov	 DWORD PTR [esi], ebx
  00158	5f		 pop	 edi

; 177  : /* 024	MGS		11/19/1998		BATS #812 fixed say-letter mode extra spaces */
; 178  : 	pCmd_t->letter_mode_flag=0;

  00159	66 89 9a 98 57
	00 00		 mov	 WORD PTR [edx+22424], bx
  00160	5e		 pop	 esi
  00161	5b		 pop	 ebx

; 179  : }

  00162	c3		 ret	 0
_cm_util_initialize ENDP
_TEXT	ENDS
PUBLIC	_cm_util_flush_init
_TEXT	SEGMENT
_phTTS$ = 8
_cm_util_flush_init PROC NEAR

; 195  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00170	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00174	53		 push	 ebx
  00175	56		 push	 esi
  00176	57		 push	 edi
  00177	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]

; 196  : 	//PKSD_T pKsd_t = phTTS->pKernelShareData;
; 197  : /*	INPUT_SEQ command_seq; */
; 198  : 
; 199  : 	pCmd_t->last_char=0;

  0017a	33 f6		 xor	 esi, esi

; 200  : 
; 201  : #if 0
; 202  : 	/* Initialize setv[] */
; 203  : 	for (i=0; i<10;i++)
; 204  : 	{
; 205  : 		pCmd_t->setv[i].cmd[0] = '\0'; 
; 206  : 	}
; 207  : 	 
; 208  : 	/* Initialize pCmd_t->param[] */
; 209  : 	for (i=0; i < NPARAM; i++)
; 210  : 	{
; 211  : 		pCmd_t->params[i] = 0;
; 212  : 	}
; 213  : #endif
; 214  : 
; 215  : 	pCmd_t->done = 0;
; 216  :     pCmd_t->roll_text = 0;
; 217  :     pCmd_t->email_header = 0;
; 218  :     pCmd_t->index_counter = 0;
; 219  :     pCmd_t->input_counter = 0;
; 220  : 
; 221  : 	memset(pCmd_t->clausebuf,0,PAR_MAX_INPUT_ARRAY);

  0017c	b9 e1 00 00 00	 mov	 ecx, 225		; 000000e1H
  00181	33 c0		 xor	 eax, eax
  00183	8d 9a 3c 05 00
	00		 lea	 ebx, DWORD PTR [edx+1340]
  00189	89 b2 f8 02 00
	00		 mov	 DWORD PTR [edx+760], esi
  0018f	8b fb		 mov	 edi, ebx
  00191	66 89 b2 72 57
	00 00		 mov	 WORD PTR [edx+22386], si
  00198	66 89 b2 38 05
	00 00		 mov	 WORD PTR [edx+1336], si
  0019f	66 89 b2 3a 05
	00 00		 mov	 WORD PTR [edx+1338], si
  001a6	66 89 b2 36 05
	00 00		 mov	 WORD PTR [edx+1334], si
  001ad	66 89 b2 34 05
	00 00		 mov	 WORD PTR [edx+1332], si
  001b4	f3 ab		 rep stosd

; 222  : 	memset(pCmd_t->wordbuf,0,50);

  001b6	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  001bb	8d ba c0 08 00
	00		 lea	 edi, DWORD PTR [edx+2240]
  001c1	f3 ab		 rep stosd
  001c3	66 ab		 stosw

; 223  : 	memset(pCmd_t->new_input,0,PAR_MAX_INPUT_ARRAY);

  001c5	b9 e1 00 00 00	 mov	 ecx, 225		; 000000e1H
  001ca	33 c0		 xor	 eax, eax
  001cc	8d ba c8 0f 00
	00		 lea	 edi, DWORD PTR [edx+4040]
  001d2	f3 ab		 rep stosd

; 224  : 	memset(pCmd_t->output_buf,0,PAR_MAX_OUTPUT_ARRAY);

  001d4	b9 e1 00 00 00	 mov	 ecx, 225		; 000000e1H
  001d9	8d ba 44 0c 00
	00		 lea	 edi, DWORD PTR [edx+3140]
  001df	f3 ab		 rep stosd

; 225  : 	memset(pCmd_t->dict_hit_buf,0,PAR_MAX_INPUT_ARRAY);

  001e1	b9 e1 00 00 00	 mov	 ecx, 225		; 000000e1H
  001e6	8d ba 4c 13 00
	00		 lea	 edi, DWORD PTR [edx+4940]
  001ec	f3 ab		 rep stosd

; 226  : 
; 227  : #ifdef NEW_INDEXING
; 228  : 	memset(pCmd_t->input_indexes,0,PAR_MAX_INPUT_ARRAY*sizeof(index_data_t));

  001ee	b9 46 05 00 00	 mov	 ecx, 1350		; 00000546H
  001f3	8d ba d0 16 00
	00		 lea	 edi, DWORD PTR [edx+5840]
  001f9	f3 ab		 rep stosd

; 229  : 	memset(pCmd_t->new_input_indexes,0,PAR_MAX_INPUT_ARRAY*sizeof(index_data_t));

  001fb	b9 46 05 00 00	 mov	 ecx, 1350		; 00000546H
  00200	8d ba e8 2b 00
	00		 lea	 edi, DWORD PTR [edx+11240]
  00206	f3 ab		 rep stosd

; 230  : 	memset(pCmd_t->output_indexes,0,PAR_MAX_OUTPUT_ARRAY*sizeof(index_data_t));

  00208	b9 46 05 00 00	 mov	 ecx, 1350		; 00000546H
  0020d	8d ba 00 41 00
	00		 lea	 edi, DWORD PTR [edx+16640]
  00213	f3 ab		 rep stosd

; 231  : #endif
; 232  : 	pCmd_t->prevword=&(pCmd_t->clausebuf[1]);

  00215	8d 8a 3d 05 00
	00		 lea	 ecx, DWORD PTR [edx+1341]

; 233  :     pCmd_t->prev_word_index=0;

  0021b	66 89 b2 70 57
	00 00		 mov	 WORD PTR [edx+22384], si
  00222	89 8a 6c 57 00
	00		 mov	 DWORD PTR [edx+22380], ecx

; 234  : 	pCmd_t->clausebuf[0]=' ';
; 235  : 	memset(&(pCmd_t->ret_value),0,sizeof(return_value_t));

  00228	81 c2 74 57 00
	00		 add	 edx, 22388		; 00005774H
  0022e	b9 08 00 00 00	 mov	 ecx, 8
  00233	8b fa		 mov	 edi, edx
  00235	c6 03 20	 mov	 BYTE PTR [ebx], 32	; 00000020H
  00238	f3 ab		 rep stosd

; 236  : 	pCmd_t->ret_value.input_pos = 0;

  0023a	89 32		 mov	 DWORD PTR [edx], esi
  0023c	5f		 pop	 edi
  0023d	5e		 pop	 esi
  0023e	5b		 pop	 ebx

; 237  : 
; 238  : }

  0023f	c3		 ret	 0
_cm_util_flush_init ENDP
_TEXT	ENDS
PUBLIC	_cm_util_init_type
EXTRN	_usa_init:NEAR
_TEXT	SEGMENT
_pKsd_t$ = 8
_cm_util_init_type PROC NEAR

; 255  :    /*
; 256  : 	* This will be changed when we have an architecture
; 257  : 	* to implement multi-language support
; 258  : 	*                          KM 4/29/94
; 259  : 	*/
; 260  : 
; 261  : #ifdef CMDDEBUG
; 262  : f_fprintf("cmdtype: In init type\n");
; 263  : #endif
; 264  : 
; 265  : 
; 266  : #ifndef MSDOS
; 267  : 	 /* 6/15/99 GL, BATS#896 don't do this initialization for MSDOS */
; 268  : 	 pKsd_t->loaded_languages = 0;

  00240	8b 44 24 04	 mov	 eax, DWORD PTR _pKsd_t$[esp-4]

; 269  : 
; 270  : 	 usa_init(pKsd_t);

  00244	50		 push	 eax
  00245	c7 80 1c 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1564], 0
  0024f	e8 00 00 00 00	 call	 _usa_init
  00254	59		 pop	 ecx

; 271  : #endif
; 272  : 
; 273  : }

  00255	c3		 ret	 0
_cm_util_init_type ENDP
_TEXT	ENDS
PUBLIC	_cm_util_dtpc_tones
PUBLIC	_cm_util_write_pipe
EXTRN	_WaitForLtsFlush:NEAR
EXTRN	_cm_cmd_sync:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_iFrequency$ = 16
_iDuration$ = 20
_pipe$ = -12
_cm_util_dtpc_tones PROC NEAR

; 332  : {

  00260	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00263	56		 push	 esi

; 333  :   DT_PIPE_T pipe[6];
; 334  :   PKSD_T pKsd_t = phTTS->pKernelShareData;

  00264	8b 74 24 14	 mov	 esi, DWORD PTR _phTTS$[esp+12]
  00268	57		 push	 edi

; 335  :  
; 336  :   /* LPTTS_HANDLE_T phTTS; */
; 337  :   
; 338  :   /********************************************************************/
; 339  :   /*  Get the text to speech handle.                                  */
; 340  :   /********************************************************************/
; 341  :   
; 342  :   /* phTTS = TextToSpeechGetHandle(); */
; 343  :   
; 344  :   /********************************************************************/
; 345  :   /*  Wait for all characters previously queued to LTS to be          */
; 346  :   /*  processed.                                                      */
; 347  :   /********************************************************************/
; 348  : 
; 349  :   if ( cm_cmd_sync(phTTS) == CMD_flushing )

  00269	56		 push	 esi
  0026a	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0026d	e8 00 00 00 00	 call	 _cm_cmd_sync
  00272	83 c4 04	 add	 esp, 4
  00275	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00278	75 06		 jne	 SHORT $L71292
  0027a	5f		 pop	 edi
  0027b	5e		 pop	 esi

; 396  : }

  0027c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0027f	c3		 ret	 0
$L71292:

; 350  :   {
; 351  : 	return( CMD_flushing );                        
; 352  :   }
; 353  : 
; 354  :   WaitForLtsFlush( phTTS, 0xFFFFFFFF );

  00280	6a ff		 push	 -1
  00282	56		 push	 esi
  00283	e8 00 00 00 00	 call	 _WaitForLtsFlush

; 355  : 
; 356  :   /********************************************************************/
; 357  :   /*  The packet format here is different than the DTC07. The ramp    */
; 358  :   /*  duration has been eliminated. The tone generation software      */
; 359  :   /*  automatically provides 3 msec. cosine squared tapering for      */
; 360  :   /*  the tone pulse rise and fall time.                              */
; 361  :   /*                                                                  */
; 362  :   /*  Packet Index     Packet Data                 Value              */
; 363  :   /*                                                                  */
; 364  :   /*      0            Command Word              SPC_type_tone        */
; 365  :   /*      1            Tone Duration (msec.)     0 to ?               */
; 366  :   /*      2            Tone 0 Frequency          0 to Fs/2            */
; 367  :   /*      3            Tone 0 Amplitude          0 to 32767           */
; 368  :   /*      4            Tone 1 Frequency          0 to Fs/2            */
; 369  :   /*      5            Tone 1 Amplitude          0 to 32767           */
; 370  :   /*                                                                  */
; 371  :   /********************************************************************/
; 372  : 
; 373  :   /********************************************************************/
; 374  :   /*  params[1] is a character pointer to the duration in msec.       */
; 375  :   /*  params[0] is a character pointer to the frequency in Hertz.     */
; 376  :   /********************************************************************/
; 377  : 
; 378  :   pipe[0] = SPC_type_tone;
; 379  :   pipe[1] = (short)iDuration;

  00288	66 8b 44 24 2c	 mov	 ax, WORD PTR _iDuration$[esp+24]

; 380  :   pipe[2] = (short)iFrequency;

  0028d	66 8b 4c 24 28	 mov	 cx, WORD PTR _iFrequency$[esp+24]
  00292	66 c7 44 24 10
	02 00		 mov	 WORD PTR _pipe$[esp+28], 2
  00299	66 89 44 24 12	 mov	 WORD PTR _pipe$[esp+30], ax
  0029e	66 89 4c 24 14	 mov	 WORD PTR _pipe$[esp+32], cx

; 381  : 
; 382  :   /********************************************************************/
; 383  :   /*  Disable the second tone.                                        */
; 384  :   /********************************************************************/
; 385  : 
; 386  :   pipe[3] = TONE_AMPLITUDE;

  002a3	66 c7 44 24 16
	ff 7f		 mov	 WORD PTR _pipe$[esp+34], 32767 ; 00007fffH

; 387  :   pipe[4] = 1000;

  002aa	66 c7 44 24 18
	e8 03		 mov	 WORD PTR _pipe$[esp+36], 1000 ; 000003e8H

; 388  :   pipe[5] = 0;

  002b1	66 c7 44 24 1a
	00 00		 mov	 WORD PTR _pipe$[esp+38], 0

; 389  : 
; 390  : /* GL 04/21/1997  change this for OSF build */
; 391  : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 392  :   cm_util_write_pipe( pKsd_t, pKsd_t->vtm_pipe, pipe, 6 );

  002b8	8b 87 9c 02 00
	00		 mov	 eax, DWORD PTR [edi+668]
  002be	8d 54 24 10	 lea	 edx, DWORD PTR _pipe$[esp+28]
  002c2	6a 06		 push	 6
  002c4	52		 push	 edx
  002c5	50		 push	 eax
  002c6	57		 push	 edi
  002c7	e8 00 00 00 00	 call	 _cm_util_write_pipe
  002cc	83 c4 18	 add	 esp, 24			; 00000018H

; 393  : #endif
; 394  : 
; 395  :   return( CMD_success );

  002cf	33 c0		 xor	 eax, eax
  002d1	5f		 pop	 edi
  002d2	5e		 pop	 esi

; 396  : }

  002d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d6	c3		 ret	 0
_cm_util_dtpc_tones ENDP
_TEXT	ENDS
PUBLIC	_cm_util_dtpc_tones_reset
_TEXT	SEGMENT
_cm_util_dtpc_tones_reset PROC NEAR

; 603  : #ifdef MSDOS
; 604  : 	unsigned int pipe_value; 
; 605  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 606  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;
; 607  : 	
; 608  : 	if(cm_cmd_sync(phTTS) == CMD_flushing)
; 609  : 	{
; 610  : 		return(CMD_flushing);                   
; 611  : 	}
; 612  : 	sleep(pCmd_t->tone_wait);
; 613  : 	RESET_DSP;
; 614  : 	RUN_DSP;
; 615  : 	pipe_value = LAST_VOICE;
; 616  : 	cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,&pipe_value,1);
; 617  : 	pCmd_t->tone_wait = 0; 
; 618  : #endif
; 619  : 	return(CMD_success);

  002e0	33 c0		 xor	 eax, eax

; 620  : }

  002e2	c3		 ret	 0
_cm_util_dtpc_tones_reset ENDP
_TEXT	ENDS
PUBLIC	_cm_util_type_out
_TEXT	SEGMENT
_pKsd_t$ = 8
_c$ = 12
_phone$ = -4
_cm_util_type_out PROC NEAR

; 636  : {

  002f0	51		 push	 ecx
  002f1	56		 push	 esi

; 637  : 	unsigned char _far *tp;
; 638  : 	DT_PIPE_T phone;
; 639  : 
; 640  : 	phone = LAST_VOICE;
; 641  : 	cm_util_write_pipe(pKsd_t,pKsd_t->ph_pipe,&phone,1);

  002f2	8b 74 24 0c	 mov	 esi, DWORD PTR _pKsd_t$[esp+4]
  002f6	57		 push	 edi
  002f7	8d 44 24 08	 lea	 eax, DWORD PTR _phone$[esp+12]
  002fb	8b 8e 94 02 00
	00		 mov	 ecx, DWORD PTR [esi+660]
  00301	6a 01		 push	 1
  00303	50		 push	 eax
  00304	51		 push	 ecx
  00305	56		 push	 esi
  00306	c7 44 24 18 03
	1f 00 00	 mov	 DWORD PTR _phone$[esp+28], 7939 ; 00001f03H
  0030e	e8 00 00 00 00	 call	 _cm_util_write_pipe

; 642  : 	for(tp = (unsigned char _far *)pKsd_t->typing_table[c];*tp;tp++)

  00313	8b 96 38 06 00
	00		 mov	 edx, DWORD PTR [esi+1592]
  00319	8b 44 24 24	 mov	 eax, DWORD PTR _c$[esp+24]
  0031d	83 c4 10	 add	 esp, 16			; 00000010H
  00320	8b 3c 82	 mov	 edi, DWORD PTR [edx+eax*4]
  00323	8a 07		 mov	 al, BYTE PTR [edi]
  00325	84 c0		 test	 al, al
  00327	74 32		 je	 SHORT $L71308
$L71306:

; 643  : 	{
; 644  : 		phone = pKsd_t->reverse_ascky[(*tp) & 0xff];

  00329	8b 8e 28 06 00
	00		 mov	 ecx, DWORD PTR [esi+1576]
  0032f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH

; 645  : 		cm_util_write_pipe(pKsd_t,pKsd_t->ph_pipe,&phone,1);

  00334	6a 01		 push	 1
  00336	66 8b 14 81	 mov	 dx, WORD PTR [ecx+eax*4]
  0033a	8b 8e 94 02 00
	00		 mov	 ecx, DWORD PTR [esi+660]
  00340	8d 44 24 0c	 lea	 eax, DWORD PTR _phone$[esp+16]
  00344	89 54 24 0c	 mov	 DWORD PTR _phone$[esp+16], edx
  00348	50		 push	 eax
  00349	51		 push	 ecx
  0034a	56		 push	 esi
  0034b	e8 00 00 00 00	 call	 _cm_util_write_pipe
  00350	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00353	83 c4 10	 add	 esp, 16			; 00000010H
  00356	47		 inc	 edi
  00357	84 c0		 test	 al, al
  00359	75 ce		 jne	 SHORT $L71306
$L71308:

; 646  : 	}
; 647  : 	switch (pKsd_t->lang_curr)
; 648  : 	{

  0035b	8b 86 b8 02 00
	00		 mov	 eax, DWORD PTR [esi+696]
  00361	83 f8 06	 cmp	 eax, 6
  00364	77 41		 ja	 SHORT $L71310
  00366	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L71370[eax*4]
$L71313:

; 649  : 	case LANG_english:
; 650  : 		phone = (PFUSA<<PSFONT) | COMMA;

  0036d	c7 44 24 08 73
	1e 00 00	 mov	 DWORD PTR _phone$[esp+12], 7795 ; 00001e73H

; 651  : 		break;

  00375	eb 30		 jmp	 SHORT $L71310
$L71314:

; 652  : 	case LANG_british:
; 653  : 		phone = (PFUK<<PSFONT) | COMMA;

  00377	c7 44 24 08 73
	1d 00 00	 mov	 DWORD PTR _phone$[esp+12], 7539 ; 00001d73H

; 654  : 		break;

  0037f	eb 26		 jmp	 SHORT $L71310
$L71315:

; 655  : 	case LANG_german:
; 656  : 		phone = (PFGR<<PSFONT) | COMMA;

  00381	c7 44 24 08 73
	1c 00 00	 mov	 DWORD PTR _phone$[esp+12], 7283 ; 00001c73H

; 657  : 		break;

  00389	eb 1c		 jmp	 SHORT $L71310
$L71316:

; 658  : 	case LANG_spanish:
; 659  : 		phone = (PFSP<<PSFONT) | COMMA;

  0038b	c7 44 24 08 73
	1b 00 00	 mov	 DWORD PTR _phone$[esp+12], 7027 ; 00001b73H

; 660  : 		break;

  00393	eb 12		 jmp	 SHORT $L71310
$L71317:

; 661  : 	case LANG_latin_american:
; 662  : 		phone = (PFLA<<PSFONT) | COMMA;

  00395	c7 44 24 08 73
	1a 00 00	 mov	 DWORD PTR _phone$[esp+12], 6771 ; 00001a73H

; 663  : 		break;

  0039d	eb 08		 jmp	 SHORT $L71310
$L71318:

; 664  : 	case LANG_french:
; 665  : 		phone = (PFFR<<PSFONT) | COMMA;

  0039f	c7 44 24 08 73
	19 00 00	 mov	 DWORD PTR _phone$[esp+12], 6515 ; 00001973H
$L71310:

; 666  : 		break;
; 667  : 	}
; 668  : 	
; 669  : 	cm_util_write_pipe(pKsd_t,pKsd_t->ph_pipe,&phone,1);

  003a7	8b 86 94 02 00
	00		 mov	 eax, DWORD PTR [esi+660]
  003ad	8d 54 24 08	 lea	 edx, DWORD PTR _phone$[esp+12]
  003b1	6a 01		 push	 1
  003b3	52		 push	 edx
  003b4	50		 push	 eax
  003b5	56		 push	 esi
  003b6	e8 00 00 00 00	 call	 _cm_util_write_pipe
  003bb	83 c4 10	 add	 esp, 16			; 00000010H
  003be	5f		 pop	 edi
  003bf	5e		 pop	 esi

; 670  : }

  003c0	59		 pop	 ecx
  003c1	c3		 ret	 0
  003c2	8b ff		 npad	 2
$L71370:
  003c4	00 00 00 00	 DD	 $L71313
  003c8	00 00 00 00	 DD	 $L71318
  003cc	00 00 00 00	 DD	 $L71315
  003d0	00 00 00 00	 DD	 $L71316
  003d4	00 00 00 00	 DD	 $L71310
  003d8	00 00 00 00	 DD	 $L71314
  003dc	00 00 00 00	 DD	 $L71317
_cm_util_type_out ENDP
_TEXT	ENDS
PUBLIC	_cm_util_string_match
EXTRN	_par_lower:BYTE
_TEXT	SEGMENT
_sa$ = 8
_s$ = 12
_matches$ = -8
_match_index$ = -4
_cm_util_string_match PROC NEAR

; 688  : {

  003e0	83 ec 08	 sub	 esp, 8
  003e3	53		 push	 ebx

; 689  : 	unsigned char *t, *ta;
; 690  : 	int index, matches, match_index=0;
; 691  : 
; 692  : #ifdef DEBUGPARS // NAL warning removal
; 693  : 	int i;
; 694  : #endif
; 695  : 
; 696  : 	matches = 0;
; 697  : 
; 698  : if (s == NULL) //mfg check for a NULL argument BATS#628

  003e4	8b 5c 24 14	 mov	 ebx, DWORD PTR _s$[esp+8]
  003e8	55		 push	 ebp
  003e9	33 ed		 xor	 ebp, ebp
  003eb	56		 push	 esi
  003ec	3b dd		 cmp	 ebx, ebp
  003ee	57		 push	 edi
  003ef	89 6c 24 14	 mov	 DWORD PTR _match_index$[esp+24], ebp
  003f3	89 6c 24 10	 mov	 DWORD PTR _matches$[esp+24], ebp

; 699  : 	{
; 700  : 	return(NO_STRING_MATCH);

  003f7	74 50		 je	 SHORT $L71342

; 701  : 	}
; 702  : 
; 703  : #ifdef DEBUGPARS
; 704  : 		printf("CM_UTIL: string_match:\n");
; 705  : #endif                         
; 706  : #ifdef DEBUGPARS
; 707  : 	putc('s');
; 708  : 	putc('=');
; 709  : 	for (i=0;s[i];i++)
; 710  : 	{
; 711  : 		putc(s[i]);
; 712  : 	} 
; 713  : 	putc('\r');
; 714  : 	putc('\n');
; 715  : #endif
; 716  : 	for(index=0; sa[index]; index+=1)

  003f9	8b 54 24 1c	 mov	 edx, DWORD PTR _sa$[esp+20]
  003fd	8b 0a		 mov	 ecx, DWORD PTR [edx]
  003ff	3b cd		 cmp	 ecx, ebp
  00401	74 46		 je	 SHORT $L71342
  00403	8b fa		 mov	 edi, edx
$L71331:

; 717  : 	{
; 718  : #ifdef DEBUGPARS
; 719  : 		putc('s');
; 720  : 		putc('a');
; 721  : 		putc('=');
; 722  : 		for (i=0;sa[index][i];i++)
; 723  : 		{
; 724  : 			putc(sa[index][i]);
; 725  : 		} 
; 726  : 		putc('\r');
; 727  : 		putc('\n');
; 728  : #endif		
; 729  : 		t = s;

  00405	8b d3		 mov	 edx, ebx

; 730  : 		ta = sa[index];

  00407	8b f1		 mov	 esi, ecx
$L71335:

; 731  : 		while(TRUE)
; 732  : 		{
; 733  : 			if (*ta == par_lower[*t])

  00409	8a 0e		 mov	 cl, BYTE PTR [esi]
  0040b	33 c0		 xor	 eax, eax
  0040d	8a 02		 mov	 al, BYTE PTR [edx]
  0040f	3a 88 00 00 00
	00		 cmp	 cl, BYTE PTR _par_lower[eax]
  00415	75 08		 jne	 SHORT $L71337

; 734  : 			{
; 735  : 				if(*ta == 0)                                                       

  00417	84 c9		 test	 cl, cl
  00419	74 3b		 je	 SHORT $L71374

; 738  : 				}
; 739  : 				ta += 1;                                              

  0041b	46		 inc	 esi

; 740  : 				t += 1;

  0041c	42		 inc	 edx
  0041d	eb ea		 jmp	 SHORT $L71335
$L71337:

; 741  : 			}
; 742  : 			else 
; 743  : 			{
; 744  : 				if(*t == 0)

  0041f	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00422	75 0d		 jne	 SHORT $L71332

; 745  : 				{
; 746  : 					matches += 1;

  00424	8b 44 24 10	 mov	 eax, DWORD PTR _matches$[esp+24]

; 747  : 					match_index = index;

  00428	89 6c 24 14	 mov	 DWORD PTR _match_index$[esp+24], ebp
  0042c	40		 inc	 eax
  0042d	89 44 24 10	 mov	 DWORD PTR _matches$[esp+24], eax
$L71332:
  00431	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00434	83 c7 04	 add	 edi, 4
  00437	45		 inc	 ebp
  00438	85 c9		 test	 ecx, ecx
  0043a	75 c9		 jne	 SHORT $L71331

; 748  : 					break;
; 749  : 				}
; 750  : 				else
; 751  : 				{
; 752  : 					break;
; 753  : 				}
; 754  : 			}
; 755  : 		}
; 756  : 	}
; 757  : 	if(matches == 1)

  0043c	8b 44 24 10	 mov	 eax, DWORD PTR _matches$[esp+24]
  00440	83 f8 01	 cmp	 eax, 1

; 758  : 	{
; 759  : 		return(match_index);

  00443	8b 44 24 14	 mov	 eax, DWORD PTR _match_index$[esp+24]
  00447	74 05		 je	 SHORT $L71323
$L71342:

; 760  : 	}
; 761  : 	return(NO_STRING_MATCH);

  00449	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$L71323:
  0044e	5f		 pop	 edi
  0044f	5e		 pop	 esi
  00450	5d		 pop	 ebp
  00451	5b		 pop	 ebx

; 762  : }

  00452	83 c4 08	 add	 esp, 8
  00455	c3		 ret	 0
$L71374:
  00456	5f		 pop	 edi

; 736  : 				{
; 737  : 					return(index);

  00457	8b c5		 mov	 eax, ebp
  00459	5e		 pop	 esi
  0045a	5d		 pop	 ebp
  0045b	5b		 pop	 ebx

; 762  : }

  0045c	83 c4 08	 add	 esp, 8
  0045f	c3		 ret	 0
_cm_util_string_match ENDP
_TEXT	ENDS
EXTRN	_write_pipe:NEAR
_TEXT	SEGMENT
_pKsd_t$ = 8
_kinp$ = 12
_phone$ = 16
_count$ = 20
_cm_util_write_pipe PROC NEAR

; 784  : 
; 785  : 
; 786  : 		/* debug switch */
; 787  : 		if (DT_DBG(CMD_DBG,0x800))

  00460	8b 44 24 04	 mov	 eax, DWORD PTR _pKsd_t$[esp-4]
  00464	56		 push	 esi
  00465	8b 74 24 10	 mov	 esi, DWORD PTR _phone$[esp]
  00469	57		 push	 edi
  0046a	66 8b 80 40 06
	00 00		 mov	 ax, WORD PTR [eax+1600]
  00471	f6 c4 80	 test	 ah, -128		; ffffff80H
  00474	74 20		 je	 SHORT $L71353
  00476	f6 c4 08	 test	 ah, 8
  00479	74 1b		 je	 SHORT $L71353

; 788  : 		{
; 789  : 			/*mfg 04/27/98 when pipe is drained let the following pass through*/ 
; 790  : 			if ((*phone != SYNC) && (*phone != BREATH_BREAK) 
; 791  : 				&& (*phone != KILL_TASK) && (*phone != FLUSH_SYNC))

  0047b	66 8b 06	 mov	 ax, WORD PTR [esi]
  0047e	66 3d 0a 1f	 cmp	 ax, 7946		; 00001f0aH
  00482	74 12		 je	 SHORT $L71353
  00484	66 3d 0b 1f	 cmp	 ax, 7947		; 00001f0bH
  00488	74 0c		 je	 SHORT $L71353
  0048a	66 3d 0c 1f	 cmp	 ax, 7948		; 00001f0cH
  0048e	74 06		 je	 SHORT $L71353
  00490	66 3d 0d 1f	 cmp	 ax, 7949		; 00001f0dH
  00494	75 34		 jne	 SHORT $L71354
$L71353:

; 792  : 
; 793  : 			return;
; 794  : 		}
; 795  : 
; 796  :         write_pipe(kinp,phone,count);

  00496	0f bf 4c 24 18	 movsx	 ecx, WORD PTR _count$[esp+4]
  0049b	8b 7c 24 10	 mov	 edi, DWORD PTR _kinp$[esp+4]
  0049f	51		 push	 ecx
  004a0	56		 push	 esi
  004a1	57		 push	 edi
  004a2	e8 00 00 00 00	 call	 _write_pipe

; 797  : 
; 798  : 		/* GL 01/08/98  BATS#547  force a extra space after SYNC, VT/HT to fix the
; 799  : 		   dropping punctuation problem. */
; 800  : 		if (*phone == SYNC || *phone == BREATH_BREAK)

  004a7	66 8b 06	 mov	 ax, WORD PTR [esi]
  004aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ad	66 3d 0a 1f	 cmp	 ax, 7946		; 00001f0aH
  004b1	74 06		 je	 SHORT $L71355
  004b3	66 3d 0b 1f	 cmp	 ax, 7947		; 00001f0bH
  004b7	75 11		 jne	 SHORT $L71354
$L71355:

; 801  : 		{
; 802  : 			*phone = (PFASCII<<PSFONT) + ' ';
; 803  : 			write_pipe(kinp,phone,1);

  004b9	6a 01		 push	 1
  004bb	56		 push	 esi
  004bc	57		 push	 edi
  004bd	66 c7 06 20 00	 mov	 WORD PTR [esi], 32	; 00000020H
  004c2	e8 00 00 00 00	 call	 _write_pipe
  004c7	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71354:
  004ca	5f		 pop	 edi
  004cb	5e		 pop	 esi

; 804  : 		}
; 805  :         
; 806  : 		return;
; 807  : } 

  004cc	c3		 ret	 0
_cm_util_write_pipe ENDP
_TEXT	ENDS
END
