	TITLE	D:\work\product\dapi\src\Lts\ls_suff.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_form_class_strings
_DATA	SEGMENT
_form_class_strings DD FLAT:$SG71765
	DD	FLAT:$SG71766
	DD	FLAT:$SG71767
	DD	FLAT:$SG71768
	DD	FLAT:$SG71769
	DD	FLAT:$SG71770
	DD	FLAT:$SG71771
	DD	FLAT:$SG71772
	DD	FLAT:$SG71773
	DD	FLAT:$SG71774
	DD	FLAT:$SG71775
	DD	FLAT:$SG71776
	DD	FLAT:$SG71777
	DD	FLAT:$SG71778
	DD	FLAT:$SG71779
	DD	FLAT:$SG71780
	DD	FLAT:$SG71781
	DD	FLAT:$SG71782
	DD	FLAT:$SG71783
	DD	FLAT:$SG71784
	DD	FLAT:$SG71785
	DD	FLAT:$SG71786
	DD	FLAT:$SG71787
	DD	FLAT:$SG71788
	DD	FLAT:$SG71789
	DD	FLAT:$SG71790
	DD	FLAT:$SG71791
	DD	FLAT:$SG71792
	DD	FLAT:$SG71793
	DD	FLAT:$SG71794
	DD	FLAT:$SG71795
	DD	FLAT:$SG71796
$SG71765 DB	'adj', 00H
$SG71766 DB	'adv', 00H
$SG71767 DB	'art', 00H
$SG71768 DB	'aux', 00H
$SG71769 DB	'be', 00H
	ORG $+1
$SG71770 DB	'bev', 00H
$SG71771 DB	'conj', 00H
	ORG $+3
$SG71772 DB	'ed', 00H
	ORG $+1
$SG71773 DB	'have', 00H
	ORG $+3
$SG71774 DB	'ing', 00H
$SG71775 DB	'noun', 00H
	ORG $+3
$SG71776 DB	'pos', 00H
$SG71777 DB	'prep', 00H
	ORG $+3
$SG71778 DB	'pron', 00H
	ORG $+3
$SG71779 DB	'subj', 00H
	ORG $+3
$SG71780 DB	'that', 00H
	ORG $+3
$SG71781 DB	'to', 00H
	ORG $+1
$SG71782 DB	'verb', 00H
	ORG $+3
$SG71783 DB	'who', 00H
$SG71784 DB	'neg', 00H
$SG71785 DB	'intr', 00H
	ORG $+3
$SG71786 DB	'ref', 00H
$SG71787 DB	'part', 00H
	ORG $+3
$SG71788 DB	'func', 00H
	ORG $+3
$SG71789 DB	'conj', 00H
	ORG $+3
$SG71790 DB	'char', 00H
	ORG $+3
$SG71791 DB	'refr', 00H
	ORG $+3
$SG71792 DB	'unused', 00H
	ORG $+1
$SG71793 DB	'unused', 00H
	ORG $+1
$SG71794 DB	'mark', 00H
	ORG $+3
$SG71795 DB	'cont', 00H
	ORG $+3
$SG71796 DB	'homo', 00H
_DATA	ENDS
PUBLIC	_ls_suff_suffix_find
PUBLIC	_ls_suff_append_pron
EXTRN	_suffix_table:BYTE
EXTRN	_suffix_index:BYTE
EXTRN	_ls_lower:BYTE
EXTRN	_ls_dict_find_word:NEAR
EXTRN	_ls_dict_ufind_word:NEAR
EXTRN	__imp__fprintf:NEAR
EXTRN	__imp__printf:NEAR
_DATA	SEGMENT
	ORG $+3
$SG71743 DB	0aH, 'HITS(%s)', 00H
	ORG $+2
$SG71744 DB	0aH, 'HITS(%s)', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_str_end$ = 12
_which_dic$ = 16
_stat$ = -136
_si$ = -140
_save_str$ = -128
_pKsd_t$ = -132
_ls_suff_suffix_find PROC NEAR

; 106  : {

  00000	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH

; 107  : 	unsigned char   _far *bp;                       /* base text string seach */
; 108  : 	unsigned char   _far *sp;                       /* suffix string seach */
; 109  : 	unsigned char   _far *np;                       /* replacement string save */
; 110  : 	unsigned char   _far *sbp;                      /* saved base pointer to recurse */
; 111  : 	/* GL 04/21/1997  add this for OSF build */
; 112  : 	U32     i,stat=0;
; 113  : 	U32		si;
; 114  : 
; 115  : 	struct  suff_rule       *stp;
; 116  : 	unsigned char   save_str[128];
; 117  : #ifdef GERMAN
; 118  : 	short hit_tail=0;
; 119  : 	short hit_suff=0;
; 120  : #endif
; 121  : 
; 122  : 	PLTS_T  pLts_t;
; 123  : 	PKSD_T  pKsd_t;
; 124  : 	pKsd_t = phTTS->pKernelShareData;

  00006	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _phTTS$[esp+136]
  0000d	53		 push	 ebx
  0000e	55		 push	 ebp
  0000f	33 c0		 xor	 eax, eax
  00011	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 125  : 	pLts_t = phTTS->pLTSThreadData;

  00014	8b 59 10	 mov	 ebx, DWORD PTR [ecx+16]
  00017	89 54 24 10	 mov	 DWORD PTR _pKsd_t$[esp+148], edx

; 126  : 	
; 127  : #ifdef LSSUFFDEBUG
; 128  : 		printf("ls_suff_suffix_find; comp_str = %s str_end = %s\n",pLts_t->comp_str,str_end);
; 129  : #endif
; 130  : 
; 131  :     /* GL 07/25/1997 For BATS#416  pick up the right index for international character */
; 132  : 	/* this change will match to suffix compiler character grouping */
; 133  : 	/* if(IS_LOWER_ALPHA(ls_lower[*str_end]) == false)*/
; 134  : 	if (ls_lower[*str_end] < 'a' || ls_lower[*str_end] > 'z')

  0001b	8b 94 24 9c 00
	00 00		 mov	 edx, DWORD PTR _str_end$[esp+144]
  00022	33 c9		 xor	 ecx, ecx
  00024	56		 push	 esi
  00025	8a 0a		 mov	 cl, BYTE PTR [edx]
  00027	57		 push	 edi
  00028	89 44 24 14	 mov	 DWORD PTR _stat$[esp+156], eax
  0002c	8a 89 00 00 00
	00		 mov	 cl, BYTE PTR _ls_lower[ecx]
  00032	80 f9 61	 cmp	 cl, 97			; 00000061H
  00035	72 18		 jb	 SHORT $L71709
  00037	80 f9 7a	 cmp	 cl, 122			; 0000007aH
  0003a	77 13		 ja	 SHORT $L71709

; 136  : 	else
; 137  : 		si = suffix_index[ls_lower[*str_end] - 'a'];

  0003c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00042	8b 0c 8d 7c fe
	ff ff		 mov	 ecx, DWORD PTR _suffix_index[ecx*4-388]
  00049	89 4c 24 10	 mov	 DWORD PTR _si$[esp+156], ecx
  0004d	eb 0a		 jmp	 SHORT $L71848
$L71709:

; 135  : 		si = suffix_index[26];

  0004f	8b 15 68 00 00
	00		 mov	 edx, DWORD PTR _suffix_index+104
  00055	89 54 24 10	 mov	 DWORD PTR _si$[esp+156], edx
$L71848:

; 138  : #ifdef LSSUFFDEBUG
; 139  : 		printf("suffix_find si = %04X\n",si); 
; 140  : #endif
; 141  : 
; 142  : 	while(si != 0xffff)

  00059	81 7c 24 10 ff
	ff 00 00	 cmp	 DWORD PTR _si$[esp+156], 65535 ; 0000ffffH
  00061	0f 84 d4 01 00
	00		 je	 $L71713
$L71712:

; 143  : 	{
; 144  : 		stp = (struct suff_rule *)&suffix_table[si];
; 145  : 		bp = str_end;
; 146  : 		sp = &stp->rule[0];

  00067	8b 54 24 10	 mov	 edx, DWORD PTR _si$[esp+156]
  0006b	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR _str_end$[esp+152]
  00072	8d b2 08 00 00
	00		 lea	 esi, DWORD PTR _suffix_table[edx+8]

; 147  : 		while(*sp != SF_STRIP && *sp != SF_FC)

  00078	8a 92 08 00 00
	00		 mov	 dl, BYTE PTR _suffix_table[edx+8]
  0007e	80 fa fe	 cmp	 dl, 254			; 000000feH
  00081	74 2d		 je	 SHORT $L71855
  00083	eb 04		 jmp	 SHORT $L71716
$L71865:
  00085	8b 44 24 14	 mov	 eax, DWORD PTR _stat$[esp+156]
$L71716:
  00089	80 fa fd	 cmp	 dl, 253			; 000000fdH
  0008c	74 22		 je	 SHORT $L71855

; 148  : 		{
; 149  : 			if(ls_lower[*bp] != *sp || bp == pLts_t->str_vowel)

  0008e	33 c0		 xor	 eax, eax
  00090	8a 01		 mov	 al, BYTE PTR [ecx]
  00092	38 90 00 00 00
	00		 cmp	 BYTE PTR _ls_lower[eax], dl
  00098	75 12		 jne	 SHORT $L71866
  0009a	3b 8b b8 04 00
	00		 cmp	 ecx, DWORD PTR [ebx+1208]
  000a0	74 0a		 je	 SHORT $L71866
  000a2	8a 56 01	 mov	 dl, BYTE PTR [esi+1]

; 150  : 				break;
; 151  : 			bp--;

  000a5	49		 dec	 ecx

; 152  : 			sp++;

  000a6	46		 inc	 esi
  000a7	80 fa fe	 cmp	 dl, 254			; 000000feH
  000aa	75 d9		 jne	 SHORT $L71865
$L71866:

; 147  : 		while(*sp != SF_STRIP && *sp != SF_FC)

  000ac	8b 44 24 14	 mov	 eax, DWORD PTR _stat$[esp+156]
$L71855:

; 153  : 		}
; 154  : 
; 155  : 		/*
; 156  : 		 *  for form class hits, just set the fc field ...
; 157  : 		 */
; 158  : 		
; 159  : 		if(which_dic && (*sp == SF_FC))

  000b0	66 83 bc 24 a8
	00 00 00 00	 cmp	 WORD PTR _which_dic$[esp+152], 0
  000b9	74 09		 je	 SHORT $L71720
  000bb	80 3e fd	 cmp	 BYTE PTR [esi], 253	; 000000fdH
  000be	0f 84 84 01 00
	00		 je	 $L71857
$L71720:

; 162  : 			return(MISS);
; 163  : 		}
; 164  : 		/*
; 165  : 		 *  if the suffix can be stripped, look for a striping rule starting
; 166  : 		 *  with / and see if it can be applied ...
; 167  : 		 */
; 168  : 		if(*sp++ == SF_STRIP)

  000c4	8a 16		 mov	 dl, BYTE PTR [esi]
  000c6	46		 inc	 esi
  000c7	80 fa fe	 cmp	 dl, 254			; 000000feH
  000ca	0f 85 51 01 00
	00		 jne	 $L71727

; 169  : 		{
; 170  : 			for(i=0;(save_str[i] = pLts_t->comp_str[i]);i++);

  000d0	8a 93 38 04 00
	00		 mov	 dl, BYTE PTR [ebx+1080]
  000d6	8d bb 38 04 00
	00		 lea	 edi, DWORD PTR [ebx+1080]
  000dc	84 d2		 test	 dl, dl
  000de	88 54 24 1c	 mov	 BYTE PTR _save_str$[esp+156], dl
  000e2	74 10		 je	 SHORT $L71724
  000e4	8d 6c 24 1c	 lea	 ebp, DWORD PTR _save_str$[esp+156]
$L71722:
  000e8	8a 57 01	 mov	 dl, BYTE PTR [edi+1]
  000eb	47		 inc	 edi
  000ec	45		 inc	 ebp
  000ed	84 d2		 test	 dl, dl
  000ef	88 55 00	 mov	 BYTE PTR [ebp], dl
  000f2	75 f4		 jne	 SHORT $L71722
$L71724:

; 171  : 			sbp = bp;
; 172  : 
; 173  : 			while(*sp != SF_END)

  000f4	8a 16		 mov	 dl, BYTE PTR [esi]
  000f6	8b e9		 mov	 ebp, ecx
  000f8	80 fa ff	 cmp	 dl, 255			; 000000ffH
  000fb	0f 84 20 01 00
	00		 je	 $L71727
$L71726:

; 174  : 			{
; 175  : 				if(*sp++ == SF_REPLACE)

  00101	46		 inc	 esi
  00102	80 fa fc	 cmp	 dl, 252			; 000000fcH
  00105	0f 85 0b 01 00
	00		 jne	 $L71728

; 176  : 				{
; 177  : 					while(*sp == ls_lower[*bp])

  0010b	33 d2		 xor	 edx, edx
  0010d	8a 11		 mov	 dl, BYTE PTR [ecx]
  0010f	8b fa		 mov	 edi, edx
  00111	8a 16		 mov	 dl, BYTE PTR [esi]
  00113	3a 97 00 00 00
	00		 cmp	 dl, BYTE PTR _ls_lower[edi]
  00119	75 12		 jne	 SHORT $L71731
$L71730:

; 178  : 					{
; 179  : 						sp++;

  0011b	46		 inc	 esi

; 180  : 						bp--;

  0011c	49		 dec	 ecx
  0011d	33 d2		 xor	 edx, edx
  0011f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00121	8b fa		 mov	 edi, edx
  00123	8a 16		 mov	 dl, BYTE PTR [esi]
  00125	3a 97 00 00 00
	00		 cmp	 dl, BYTE PTR _ls_lower[edi]
  0012b	74 ee		 je	 SHORT $L71730
$L71731:

; 181  : 					}
; 182  : 					if(*sp++ == SF_REPLACE_WITH)

  0012d	8a 16		 mov	 dl, BYTE PTR [esi]
  0012f	46		 inc	 esi
  00130	80 fa fb	 cmp	 dl, 251			; 000000fbH
  00133	0f 85 db 00 00
	00		 jne	 $L71748

; 183  : 					{
; 184  : 						np = bp+1;

  00139	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]

; 185  : #ifdef GERMAN
; 186  : 						if ((*np == 'e' && *(np+1) == 0) ||
; 187  : 						    (*np == 'e' && *(np+1) == 'r' && *(np+2) == 0)  ||
; 188  : 						    (*np == 'e' && *(np+1) == 'n' && *(np+2) == 0)  ||
; 189  : 						    (*np == 'e' && *(np+1) == 's' && *(np+2) == 0))
; 190  : 							hit_suff = 1;
; 191  : #endif
; 192  : 						while(*sp != SF_REPLACE_END)

  0013c	8a 0e		 mov	 cl, BYTE PTR [esi]
  0013e	80 f9 fa	 cmp	 cl, 250			; 000000faH
  00141	74 0c		 je	 SHORT $L71735
$L71734:

; 193  : 						{
; 194  : 							*np++ = *sp++;

  00143	88 0a		 mov	 BYTE PTR [edx], cl
  00145	8a 4e 01	 mov	 cl, BYTE PTR [esi+1]
  00148	42		 inc	 edx
  00149	46		 inc	 esi
  0014a	80 f9 fa	 cmp	 cl, 250			; 000000faH
  0014d	75 f4		 jne	 SHORT $L71734
$L71735:

; 195  : 						}
; 196  : 						*np++ = 0;
; 197  : 						sp++;

  0014f	46		 inc	 esi
  00150	c6 02 00	 mov	 BYTE PTR [edx], 0

; 198  : 						if(*sp == SF_RECURSE)

  00153	80 3e f9	 cmp	 BYTE PTR [esi], 249	; 000000f9H
  00156	75 1c		 jne	 SHORT $L71736

; 199  : 						{
; 200  : 							sp++;
; 201  : #ifdef LSSUFFDEBUG
; 202  : 								printf("suffix_find recursion bp = %s np = %s save_str = %s\n",bp,np,save_str);
; 203  : #endif
; 204  : 							stat = ls_suff_suffix_find(phTTS,np-1,which_dic);

  00158	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR _which_dic$[esp+152]
  0015f	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _phTTS$[esp+152]
  00166	50		 push	 eax
  00167	52		 push	 edx
  00168	51		 push	 ecx
  00169	46		 inc	 esi
  0016a	e8 00 00 00 00	 call	 _ls_suff_suffix_find
  0016f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 205  : #ifdef LSSUFFDEBUG
; 206  : 								printf("out of recursion\n");
; 207  : #endif
; 208  : 						}
; 209  : 						else

  00172	eb 63		 jmp	 SHORT $L71871
$L71736:

; 210  : 						{
; 211  : #ifdef GERMAN
; 212  : 							/* GL 04/28/98, BATS#659  set up the offset for dictionary send_phone() call */
; 213  : 							hit_tail=0;
; 214  : 							for(i=0;pLts_t->comp_str[i];i++)
; 215  : 							{
; 216  : 								if (pLts_t->comp_str[i] == 'i' &&
; 217  : 								    pLts_t->comp_str[i+1] == 'g' &&
; 218  : 								    pLts_t->comp_str[i+2] == 0)
; 219  : 									hit_tail = 1;
; 220  : 								if (pLts_t->comp_str[i] == 'i' &&
; 221  : 								    pLts_t->comp_str[i+1] == 'v' &&
; 222  : 								    pLts_t->comp_str[i+2] == 0)
; 223  : 									hit_tail = 3;
; 224  : 							}
; 225  : #endif
; 226  : 							pLts_t->fc_struct[pLts_t->fc_index] = stp->fc;

  00174	8b 4c 24 10	 mov	 ecx, DWORD PTR _si$[esp+156]
  00178	8b 93 bc 08 00
	00		 mov	 edx, DWORD PTR [ebx+2236]
  0017e	8b 89 04 00 00
	00		 mov	 ecx, DWORD PTR _suffix_table[ecx+4]
  00184	89 8c 93 bc 04
	00 00		 mov	 DWORD PTR [ebx+edx*4+1212], ecx

; 227  : 							/* GL 11/05/1997 BATS#510 */
; 228  : 							if(pKsd_t->udic_entries[pKsd_t->lang_curr] != 0)

  0018b	8b 4c 24 18	 mov	 ecx, DWORD PTR _pKsd_t$[esp+156]
  0018f	8b 91 f8 00 00
	00		 mov	 edx, DWORD PTR [ecx+248]
  00195	8b 7c 91 54	 mov	 edi, DWORD PTR [ecx+edx*4+84]
  00199	85 ff		 test	 edi, edi
  0019b	74 16		 je	 SHORT $L71738

; 229  : 							{
; 230  : 								/* GL 06/19/1997  add one more argument */
; 231  : #ifdef GERMAN
; 232  : 								stat=ls_dict_ufind_word(phTTS,0,(hit_tail & hit_suff));
; 233  : #else
; 234  : 								stat=ls_dict_ufind_word(phTTS,0);

  0019d	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _phTTS$[esp+152]
  001a4	6a 00		 push	 0
  001a6	50		 push	 eax
  001a7	e8 00 00 00 00	 call	 _ls_dict_ufind_word
  001ac	83 c4 08	 add	 esp, 8
  001af	89 44 24 14	 mov	 DWORD PTR _stat$[esp+156], eax
$L71738:

; 235  : #endif
; 236  : 							}
; 237  : 
; 238  : 							if(DICT_ENTRY !=0 && stat != HIT)

  001b3	8b 4c 24 18	 mov	 ecx, DWORD PTR _pKsd_t$[esp+156]
  001b7	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  001ba	85 d2		 test	 edx, edx
  001bc	74 1d		 je	 SHORT $L71739
  001be	83 f8 01	 cmp	 eax, 1
  001c1	0f 84 a5 00 00
	00		 je	 $L71856

; 239  : 							{
; 240  : #ifdef GERMAN
; 241  : 								stat = ls_dict_find_word(phTTS,(hit_tail & hit_suff));
; 242  : #else
; 243  : 								stat = ls_dict_find_word(phTTS);

  001c7	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR _phTTS$[esp+152]
  001ce	52		 push	 edx
  001cf	e8 00 00 00 00	 call	 _ls_dict_find_word
  001d4	83 c4 04	 add	 esp, 4
$L71871:
  001d7	89 44 24 14	 mov	 DWORD PTR _stat$[esp+156], eax
$L71739:

; 244  : #endif
; 245  : 							}
; 246  : 						}
; 247  : 						if(stat == HIT)

  001db	83 f8 01	 cmp	 eax, 1
  001de	0f 84 88 00 00
	00		 je	 $L71856

; 272  : 						}
; 273  : 						else 
; 274  : 						{
; 275  : 							pLts_t->fc_struct[pLts_t->fc_index] = 0;

  001e4	8b 8b bc 08 00
	00		 mov	 ecx, DWORD PTR [ebx+2236]

; 276  : 						}
; 277  : 						for(i=0;pLts_t->comp_str[i] = save_str[i];i++);

  001ea	8d bb 38 04 00
	00		 lea	 edi, DWORD PTR [ebx+1080]
  001f0	c7 84 8b bc 04
	00 00 00 00 00
	00		 mov	 DWORD PTR [ebx+ecx*4+1212], 0
  001fb	8a 4c 24 1c	 mov	 cl, BYTE PTR _save_str$[esp+156]
  001ff	84 c9		 test	 cl, cl
  00201	88 0f		 mov	 BYTE PTR [edi], cl
  00203	74 0f		 je	 SHORT $L71748

; 272  : 						}
; 273  : 						else 
; 274  : 						{
; 275  : 							pLts_t->fc_struct[pLts_t->fc_index] = 0;

  00205	8d 54 24 1c	 lea	 edx, DWORD PTR _save_str$[esp+156]
$L71746:

; 276  : 						}
; 277  : 						for(i=0;pLts_t->comp_str[i] = save_str[i];i++);

  00209	8a 4a 01	 mov	 cl, BYTE PTR [edx+1]
  0020c	42		 inc	 edx
  0020d	47		 inc	 edi
  0020e	84 c9		 test	 cl, cl
  00210	88 0f		 mov	 BYTE PTR [edi], cl
  00212	75 f5		 jne	 SHORT $L71746
$L71748:

; 278  : 					} /* if(*sp++ == SF_REPLACE_WITH) */
; 279  : 					bp = sbp;

  00214	8b cd		 mov	 ecx, ebp
$L71728:

; 171  : 			sbp = bp;
; 172  : 
; 173  : 			while(*sp != SF_END)

  00216	8a 16		 mov	 dl, BYTE PTR [esi]
  00218	80 fa ff	 cmp	 dl, 255			; 000000ffH
  0021b	0f 85 e0 fe ff
	ff		 jne	 $L71726
$L71727:

; 280  : 				} /* if(*sp++ == SF_REPLACE) */
; 281  : 			} /* while(*sp != SF_END) */
; 282  : 		} /* if(*sp++ == SF_STRIP) */
; 283  : 		si = stp->next;

  00221	8b 54 24 10	 mov	 edx, DWORD PTR _si$[esp+156]
  00225	8b 8a 00 00 00
	00		 mov	 ecx, DWORD PTR _suffix_table[edx]
  0022b	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  00231	89 4c 24 10	 mov	 DWORD PTR _si$[esp+156], ecx
  00235	0f 85 2c fe ff
	ff		 jne	 $L71712
$L71713:
  0023b	5f		 pop	 edi
  0023c	5e		 pop	 esi
  0023d	5d		 pop	 ebp

; 284  : #ifdef LSSUFFDEBUG
; 285  : 			printf("suffix_find new si = %04X\n",si); 
; 286  : #endif
; 287  : 	}/*     while(si != 0xffff)*/
; 288  : 	return(MISS);

  0023e	33 c0		 xor	 eax, eax
  00240	5b		 pop	 ebx

; 289  : }

  00241	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  00247	c3		 ret	 0
$L71857:

; 160  : 		{
; 161  : 			pLts_t->fc_struct[pLts_t->fc_index] = stp->fc;

  00248	8b 4c 24 10	 mov	 ecx, DWORD PTR _si$[esp+156]
  0024c	8b 83 bc 08 00
	00		 mov	 eax, DWORD PTR [ebx+2236]
  00252	5f		 pop	 edi
  00253	5e		 pop	 esi
  00254	8b 91 04 00 00
	00		 mov	 edx, DWORD PTR _suffix_table[ecx+4]
  0025a	5d		 pop	 ebp
  0025b	89 94 83 bc 04
	00 00		 mov	 DWORD PTR [ebx+eax*4+1212], edx

; 284  : #ifdef LSSUFFDEBUG
; 285  : 			printf("suffix_find new si = %04X\n",si); 
; 286  : #endif
; 287  : 	}/*     while(si != 0xffff)*/
; 288  : 	return(MISS);

  00262	33 c0		 xor	 eax, eax
  00264	5b		 pop	 ebx

; 289  : }

  00265	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  0026b	c3		 ret	 0
$L71856:

; 248  : 						{
; 249  : 							/* debug switch */
; 250  : 							if (DT_DBG(LTS_DBG,0x004))

  0026c	8b 44 24 18	 mov	 eax, DWORD PTR _pKsd_t$[esp+156]
  00270	66 8b 80 78 04
	00 00		 mov	 ax, WORD PTR [eax+1144]
  00277	f6 c4 40	 test	 ah, 64			; 00000040H
  0027a	74 3d		 je	 SHORT $L71741
  0027c	a8 04		 test	 al, 4
  0027e	74 39		 je	 SHORT $L71741

; 251  : 							{
; 252  : #ifndef MSDOS
; 253  :                            	if(pKsd_t->dbglog)

  00280	8b 4c 24 18	 mov	 ecx, DWORD PTR _pKsd_t$[esp+156]
  00284	8b 81 7c 04 00
	00		 mov	 eax, DWORD PTR [ecx+1148]
  0028a	85 c0		 test	 eax, eax
  0028c	74 16		 je	 SHORT $L71742

; 254  : 							fprintf(pKsd_t->dbglog,"\nHITS(%s)",pLts_t->comp_str); /*mfg 04/24/98 added debug log support*/

  0028e	8d 93 38 04 00
	00		 lea	 edx, DWORD PTR [ebx+1080]
  00294	52		 push	 edx
  00295	68 00 00 00 00	 push	 OFFSET FLAT:$SG71743
  0029a	50		 push	 eax
  0029b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  002a1	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71742:

; 255  : #endif
; 256  : 							printf("\nHITS(%s)",pLts_t->comp_str);

  002a4	81 c3 38 04 00
	00		 add	 ebx, 1080		; 00000438H
  002aa	53		 push	 ebx
  002ab	68 00 00 00 00	 push	 OFFSET FLAT:$SG71744
  002b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  002b6	83 c4 08	 add	 esp, 8
$L71741:

; 257  : 							}
; 258  : #ifdef GERMAN
; 259  : 							/* GL 04/28/98, send "g" for -en, -er, -es, -e */
; 260  : 							if ((hit_tail & hit_suff) != 0 && hit_tail == 1)
; 261  : 							{
; 262  : 								ls_util_send_phone(phTTS,G);
; 263  : 							}
; 264  : 							/* GL 04/28/98, send "v" for -en, -er, -es, -e */
; 265  : 							if ((hit_tail & hit_suff) != 0 && hit_tail == 3)
; 266  : 							{
; 267  : 								ls_util_send_phone(phTTS,V);
; 268  : 							}
; 269  : #endif
; 270  : 							ls_suff_append_pron(phTTS,sp);

  002b9	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _phTTS$[esp+152]
  002c0	56		 push	 esi
  002c1	50		 push	 eax
  002c2	e8 00 00 00 00	 call	 _ls_suff_append_pron
  002c7	83 c4 08	 add	 esp, 8

; 271  : 							return(HIT);

  002ca	b8 01 00 00 00	 mov	 eax, 1
  002cf	5f		 pop	 edi
  002d0	5e		 pop	 esi
  002d1	5d		 pop	 ebp
  002d2	5b		 pop	 ebx

; 289  : }

  002d3	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  002d9	c3		 ret	 0
_ls_suff_suffix_find ENDP
_TEXT	ENDS
EXTRN	_pfeat:BYTE
EXTRN	_ls_util_send_phone:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pb$ = 12
_ls_suff_append_pron PROC NEAR

; 306  : {

  002e0	56		 push	 esi

; 307  : 	PLTS_T  pLts_t;
; 308  : 
; 309  : 	pLts_t = phTTS->pLTSThreadData;
; 310  : 
; 311  : 	while(*pb != SF_END)

  002e1	8b 74 24 0c	 mov	 esi, DWORD PTR _pb$[esp]
  002e5	57		 push	 edi
  002e6	8b 7c 24 0c	 mov	 edi, DWORD PTR _phTTS$[esp+4]
  002ea	8a 06		 mov	 al, BYTE PTR [esi]
  002ec	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  002ef	3c ff		 cmp	 al, 255			; 000000ffH
  002f1	74 4d		 je	 SHORT $L71763
$L71756:

; 312  : 	{
; 313  : 		if(*pb++ == SF_PHONES)

  002f3	46		 inc	 esi
  002f4	3c f8		 cmp	 al, 248			; 000000f8H
  002f6	75 23		 jne	 SHORT $L71760

; 314  : 	    {
; 315  : 			/* GL 07/16/1997 for BATS#402 fix the documents problem */
; 316  : 			/* break two *pb++ to two different statements */
; 317  : 			int temp;
; 318  : 			temp = *pb++ & pfeat[pLts_t->lphone];

  002f8	0f bf 81 36 04
	00 00		 movsx	 eax, WORD PTR [ecx+1078]
  002ff	33 d2		 xor	 edx, edx
  00301	66 8b 14 45 00
	00 00 00	 mov	 dx, WORD PTR _pfeat[eax*2]
  00309	8b c2		 mov	 eax, edx
  0030b	33 d2		 xor	 edx, edx
  0030d	8a 16		 mov	 dl, BYTE PTR [esi]
  0030f	23 c2		 and	 eax, edx
  00311	46		 inc	 esi

; 319  : 			if(temp == *pb++)

  00312	33 d2		 xor	 edx, edx
  00314	8a 16		 mov	 dl, BYTE PTR [esi]
  00316	46		 inc	 esi
  00317	3b c2		 cmp	 eax, edx
  00319	74 09		 je	 SHORT $L71874
$L71760:

; 307  : 	PLTS_T  pLts_t;
; 308  : 
; 309  : 	pLts_t = phTTS->pLTSThreadData;
; 310  : 
; 311  : 	while(*pb != SF_END)

  0031b	8a 06		 mov	 al, BYTE PTR [esi]
  0031d	3c ff		 cmp	 al, 255			; 000000ffH
  0031f	75 d2		 jne	 SHORT $L71756
  00321	5f		 pop	 edi
  00322	5e		 pop	 esi

; 323  : 				break;
; 324  : 			}
; 325  : 		}
; 326  : 	}
; 327  : }

  00323	c3		 ret	 0
$L71874:

; 320  : 			{
; 321  : 				while(*pb != SF_PHONES_END)

  00324	8a 06		 mov	 al, BYTE PTR [esi]
  00326	3c f7		 cmp	 al, 247			; 000000f7H
  00328	74 16		 je	 SHORT $L71763
$L71762:

; 322  : 					ls_util_send_phone(phTTS,*pb++);

  0032a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0032f	46		 inc	 esi
  00330	50		 push	 eax
  00331	57		 push	 edi
  00332	e8 00 00 00 00	 call	 _ls_util_send_phone
  00337	8a 06		 mov	 al, BYTE PTR [esi]
  00339	83 c4 08	 add	 esp, 8
  0033c	3c f7		 cmp	 al, 247			; 000000f7H
  0033e	75 ea		 jne	 SHORT $L71762
$L71763:
  00340	5f		 pop	 edi
  00341	5e		 pop	 esi

; 323  : 				break;
; 324  : 			}
; 325  : 		}
; 326  : 	}
; 327  : }

  00342	c3		 ret	 0
_ls_suff_append_pron ENDP
_TEXT	ENDS
PUBLIC	_ls_suff_print_fc
EXTRN	__imp__EnterCriticalSection@4:NEAR
EXTRN	__imp__LeaveCriticalSection@4:NEAR
EXTRN	_TextToSpeechErrorHandler:NEAR
_DATA	SEGMENT
	ORG $+2
$SG71810 DB	0aH, '[:form ', 00H
	ORG $+3
$SG71813 DB	0aH, '[:form ', 00H
	ORG $+3
$SG71823 DB	' %s fc ', 00H
$SG71826 DB	'%s fc ', 00H
	ORG $+1
$SG71829 DB	0aH, '  %d : unknown. ', 0aH, 00H
	ORG $+1
$SG71832 DB	0aH, '  %d : unknown. ', 0aH, 00H
	ORG $+1
$SG71835 DB	'/ ', 00H
	ORG $+1
$SG71837 DB	']', 0aH, 00H
	ORG $+1
$SG71840 DB	']', 0aH, 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_j$ = 8
_pLts_t$ = -4
_pKsd_t$ = -8
_ls_suff_print_fc PROC NEAR

; 446  : {

  00350	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00353	53		 push	 ebx

; 447  :   int i,j;
; 448  :   S32 fc_mask;
; 449  :   PLTS_T  pLts_t;
; 450  :   PKSD_T  pKsd_t;
; 451  :   pKsd_t = phTTS->pKernelShareData;

  00354	8b 5c 24 14	 mov	 ebx, DWORD PTR _phTTS$[esp+12]
  00358	56		 push	 esi
  00359	57		 push	 edi

; 452  :   pLts_t = phTTS->pLTSThreadData;

  0035a	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  0035d	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  00360	89 74 24 10	 mov	 DWORD PTR _pKsd_t$[esp+24], esi
  00364	89 7c 24 14	 mov	 DWORD PTR _pLts_t$[esp+24], edi

; 453  : 
; 454  :   /* GL 09/29/98  don't display while there is no data */
; 455  :   if (pLts_t->fc_index == 0) return;

  00368	8b 87 bc 08 00
	00		 mov	 eax, DWORD PTR [edi+2236]
  0036e	85 c0		 test	 eax, eax
  00370	0f 84 ce 01 00
	00		 je	 $L71802

; 456  : 
; 457  : #ifdef WIN32
; 458  :   EnterCriticalSection( phTTS->pcsLogFile );

  00376	8b 83 c4 00 00
	00		 mov	 eax, DWORD PTR [ebx+196]
  0037c	55		 push	 ebp
  0037d	50		 push	 eax
  0037e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 459  : #endif
; 460  : #if defined (__osf__) || defined (__linux__)
; 461  :   /* GL 04/21/1997  change this as the latest OSF code */
; 462  :   /* ToggleLogfileMutex( MUTEX_RESERVE ); */
; 463  :   OP_LockMutex( phTTS->pcsLogFile );
; 464  : #endif
; 465  : 	
; 466  :   
; 467  : #ifndef MSDOS
; 468  :   if (pKsd_t->dbglog)	/*mfg 04/28/98 added debug support*/

  00384	8b 86 7c 04 00
	00		 mov	 eax, DWORD PTR [esi+1148]
  0038a	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__fprintf
  00390	85 c0		 test	 eax, eax
  00392	74 0b		 je	 SHORT $L71809

; 469  : 		fprintf(pKsd_t->dbglog,"\n[:form ");

  00394	68 00 00 00 00	 push	 OFFSET FLAT:$SG71810
  00399	50		 push	 eax
  0039a	ff d5		 call	 ebp
  0039c	83 c4 08	 add	 esp, 8
$L71809:

; 470  : #endif
; 471  : 
; 472  : #ifdef PRINTFDEBUG
; 473  :   printf("\n[:form ");
; 474  : #endif
; 475  :   if (pKsd_t->logflag & LOG_FORM_TYPES)

  0039f	f6 86 04 02 00
	00 08		 test	 BYTE PTR [esi+516], 8
  003a6	74 22		 je	 SHORT $L71812

; 476  :   {
; 477  : 	if ( fprintf( phTTS->pLogFile, "\n[:form ") < 0 )

  003a8	8b 8b 98 00 00
	00		 mov	 ecx, DWORD PTR [ebx+152]
  003ae	68 00 00 00 00	 push	 OFFSET FLAT:$SG71813
  003b3	51		 push	 ecx
  003b4	ff d5		 call	 ebp
  003b6	83 c4 08	 add	 esp, 8
  003b9	85 c0		 test	 eax, eax
  003bb	7d 0d		 jge	 SHORT $L71812

; 478  : 	{
; 479  : #ifndef LDS_BUILD
; 480  : 		TextToSpeechErrorHandler( phTTS,
; 481  : 			      ERROR_WRITING_FILE,
; 482  : 			      0L );

  003bd	6a 00		 push	 0
  003bf	6a 05		 push	 5
  003c1	53		 push	 ebx
  003c2	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  003c7	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71812:

; 483  : #endif
; 484  : 	}
; 485  :   }
; 486  :   for( j = 1; j <= pLts_t->fc_index; j++ )

  003ca	8b 87 bc 08 00
	00		 mov	 eax, DWORD PTR [edi+2236]
  003d0	b9 01 00 00 00	 mov	 ecx, 1
  003d5	3b c1		 cmp	 eax, ecx
  003d7	89 4c 24 20	 mov	 DWORD PTR _j$[esp+24], ecx
  003db	0f 8c 15 01 00
	00		 jl	 $L71816
  003e1	8d 97 c0 04 00
	00		 lea	 edx, DWORD PTR [edi+1216]
  003e7	89 54 24 10	 mov	 DWORD PTR -12+[esp+28], edx
$L71814:

; 487  :   {
; 488  :     if( pLts_t->fc_struct[j] )

  003eb	8b 44 24 10	 mov	 eax, DWORD PTR -12+[esp+28]
  003ef	83 38 00	 cmp	 DWORD PTR [eax], 0
  003f2	74 77		 je	 SHORT $L71817

; 489  :     {
; 490  :       fc_mask = 1;

  003f4	bf 01 00 00 00	 mov	 edi, 1
  003f9	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_form_class_strings
$L71818:

; 491  : 
; 492  :       for( i = 0; i < 32; i++ )
; 493  :       {
; 494  : 		if( pLts_t->fc_struct[j] & fc_mask )

  003fe	8b 4c 24 10	 mov	 ecx, DWORD PTR -12+[esp+28]
  00402	85 39		 test	 DWORD PTR [ecx], edi
  00404	74 4e		 je	 SHORT $L71825

; 495  : 		{
; 496  : #ifdef PRINTFDEBUG
; 497  : 			printf("%s fc ",form_class_strings[i] );
; 498  : #endif
; 499  : #ifndef MSDOS
; 500  : 			if (pKsd_t->dbglog)	/*mfg 04/28/98 added debug support*/

  00406	8b 54 24 14	 mov	 edx, DWORD PTR _pKsd_t$[esp+28]
  0040a	8b 82 7c 04 00
	00		 mov	 eax, DWORD PTR [edx+1148]
  00410	85 c0		 test	 eax, eax
  00412	74 0e		 je	 SHORT $L71822

; 501  : 				fprintf(pKsd_t->dbglog," %s fc ",form_class_strings[i] );

  00414	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00416	51		 push	 ecx
  00417	68 00 00 00 00	 push	 OFFSET FLAT:$SG71823
  0041c	50		 push	 eax
  0041d	ff d5		 call	 ebp
  0041f	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71822:

; 502  : #endif
; 503  : 
; 504  : 			if (pKsd_t->logflag & LOG_FORM_TYPES)

  00422	8b 54 24 14	 mov	 edx, DWORD PTR _pKsd_t$[esp+28]
  00426	f6 82 04 02 00
	00 08		 test	 BYTE PTR [edx+516], 8
  0042d	74 25		 je	 SHORT $L71825

; 505  : 			{
; 506  : 				if ( fprintf( phTTS->pLogFile, "%s fc ",form_class_strings[i] ) < 0 )

  0042f	8b 06		 mov	 eax, DWORD PTR [esi]
  00431	8b 8b 98 00 00
	00		 mov	 ecx, DWORD PTR [ebx+152]
  00437	50		 push	 eax
  00438	68 00 00 00 00	 push	 OFFSET FLAT:$SG71826
  0043d	51		 push	 ecx
  0043e	ff d5		 call	 ebp
  00440	83 c4 0c	 add	 esp, 12			; 0000000cH
  00443	85 c0		 test	 eax, eax
  00445	7d 0d		 jge	 SHORT $L71825

; 507  : 				{
; 508  : #ifndef LDS_BUILD
; 509  : 					TextToSpeechErrorHandler( phTTS,
; 510  : 				      ERROR_WRITING_FILE,
; 511  : 				      0L );

  00447	6a 00		 push	 0
  00449	6a 05		 push	 5
  0044b	53		 push	 ebx
  0044c	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  00451	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71825:
  00454	83 c6 04	 add	 esi, 4

; 512  : #endif
; 513  : 				}
; 514  : 			}
; 515  : 		}
; 516  : 		fc_mask = fc_mask << 1;

  00457	d1 e7		 shl	 edi, 1
  00459	81 fe 80 00 00
	00		 cmp	 esi, OFFSET FLAT:_form_class_strings+128
  0045f	7c 9d		 jl	 SHORT $L71818

; 517  :       }
; 518  :     }
; 519  :     else

  00461	8b 74 24 14	 mov	 esi, DWORD PTR _pKsd_t$[esp+28]
  00465	8b 7c 24 18	 mov	 edi, DWORD PTR _pLts_t$[esp+28]
  00469	eb 46		 jmp	 SHORT $L71831
$L71817:

; 520  :     {
; 521  : #ifdef PRINTFDEBUG
; 522  :       printf("\n  %d : unknown. \n",j);
; 523  : #endif
; 524  : #ifndef MSDOS
; 525  : 	  if (pKsd_t->dbglog)	/*mfg 04/28/98 added debug support*/

  0046b	8b 86 7c 04 00
	00		 mov	 eax, DWORD PTR [esi+1148]
  00471	85 c0		 test	 eax, eax
  00473	74 0c		 je	 SHORT $L71828

; 526  : 		fprintf(pKsd_t->dbglog,"\n  %d : unknown. \n",j);

  00475	51		 push	 ecx
  00476	68 00 00 00 00	 push	 OFFSET FLAT:$SG71829
  0047b	50		 push	 eax
  0047c	ff d5		 call	 ebp
  0047e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71828:

; 527  : #endif
; 528  : 	  if (pKsd_t->logflag & LOG_FORM_TYPES)

  00481	f6 86 04 02 00
	00 08		 test	 BYTE PTR [esi+516], 8
  00488	74 27		 je	 SHORT $L71831

; 529  : 	  {
; 530  : 		if ( fprintf( phTTS->pLogFile, "\n  %d : unknown. \n",j) < 0 )

  0048a	8b 54 24 20	 mov	 edx, DWORD PTR _j$[esp+24]
  0048e	8b 83 98 00 00
	00		 mov	 eax, DWORD PTR [ebx+152]
  00494	52		 push	 edx
  00495	68 00 00 00 00	 push	 OFFSET FLAT:$SG71832
  0049a	50		 push	 eax
  0049b	ff d5		 call	 ebp
  0049d	83 c4 0c	 add	 esp, 12			; 0000000cH
  004a0	85 c0		 test	 eax, eax
  004a2	7d 0d		 jge	 SHORT $L71831

; 531  : 		{
; 532  : #ifndef LDS_BUILD
; 533  : 			TextToSpeechErrorHandler( phTTS,
; 534  : 				  ERROR_WRITING_FILE,
; 535  : 				  0L );

  004a4	6a 00		 push	 0
  004a6	6a 05		 push	 5
  004a8	53		 push	 ebx
  004a9	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  004ae	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71831:

; 536  : #endif
; 537  : 		}
; 538  : 	  }
; 539  :     }
; 540  : 	if (j < pLts_t->fc_index)

  004b1	8b 4c 24 20	 mov	 ecx, DWORD PTR _j$[esp+24]
  004b5	8b 87 bc 08 00
	00		 mov	 eax, DWORD PTR [edi+2236]
  004bb	3b c8		 cmp	 ecx, eax
  004bd	7d 15		 jge	 SHORT $L71815

; 541  : 	{
; 542  : #ifdef PRINTFDEBUG
; 543  : 		printf("/ ");
; 544  : #endif
; 545  : #ifndef MSDOS
; 546  : 		if (pKsd_t->dbglog)	/*mfg 04/28/98 added debug support*/

  004bf	8b 86 7c 04 00
	00		 mov	 eax, DWORD PTR [esi+1148]
  004c5	85 c0		 test	 eax, eax
  004c7	74 0b		 je	 SHORT $L71815

; 547  : 			fprintf(pKsd_t->dbglog,"/ ");

  004c9	68 00 00 00 00	 push	 OFFSET FLAT:$SG71835
  004ce	50		 push	 eax
  004cf	ff d5		 call	 ebp
  004d1	83 c4 08	 add	 esp, 8
$L71815:
  004d4	8b 4c 24 20	 mov	 ecx, DWORD PTR _j$[esp+24]
  004d8	8b 54 24 10	 mov	 edx, DWORD PTR -12+[esp+28]
  004dc	8b 87 bc 08 00
	00		 mov	 eax, DWORD PTR [edi+2236]
  004e2	41		 inc	 ecx
  004e3	83 c2 04	 add	 edx, 4
  004e6	3b c8		 cmp	 ecx, eax
  004e8	89 4c 24 20	 mov	 DWORD PTR _j$[esp+24], ecx
  004ec	89 54 24 10	 mov	 DWORD PTR -12+[esp+28], edx
  004f0	0f 8e f5 fe ff
	ff		 jle	 $L71814
$L71816:

; 548  : #endif
; 549  : 	}
; 550  : 
; 551  :   }
; 552  : 
; 553  : #ifdef PRINTFDEBUG
; 554  :   printf("]\n");
; 555  : #endif
; 556  : #ifndef MSDOS
; 557  : 	if (pKsd_t->dbglog)	/*mfg 04/28/98 added debug support*/

  004f6	8b 86 7c 04 00
	00		 mov	 eax, DWORD PTR [esi+1148]
  004fc	85 c0		 test	 eax, eax
  004fe	74 0b		 je	 SHORT $L71836

; 558  : 		fprintf(pKsd_t->dbglog,"]\n");

  00500	68 00 00 00 00	 push	 OFFSET FLAT:$SG71837
  00505	50		 push	 eax
  00506	ff d5		 call	 ebp
  00508	83 c4 08	 add	 esp, 8
$L71836:

; 559  : #endif
; 560  : 
; 561  :   if (pKsd_t->logflag & LOG_FORM_TYPES)

  0050b	f6 86 04 02 00
	00 08		 test	 BYTE PTR [esi+516], 8
  00512	74 22		 je	 SHORT $L71839

; 562  :   {
; 563  : 	if ( fprintf( phTTS->pLogFile, "]\n") < 0 )

  00514	8b 93 98 00 00
	00		 mov	 edx, DWORD PTR [ebx+152]
  0051a	68 00 00 00 00	 push	 OFFSET FLAT:$SG71840
  0051f	52		 push	 edx
  00520	ff d5		 call	 ebp
  00522	83 c4 08	 add	 esp, 8
  00525	85 c0		 test	 eax, eax
  00527	7d 0d		 jge	 SHORT $L71839

; 564  : 	{
; 565  : #ifndef LDS_BUILD
; 566  : 		TextToSpeechErrorHandler( phTTS,
; 567  : 			      ERROR_WRITING_FILE,
; 568  : 			      0L );

  00529	6a 00		 push	 0
  0052b	6a 05		 push	 5
  0052d	53		 push	 ebx
  0052e	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  00533	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71839:

; 569  : #endif
; 570  : 	}
; 571  :   }
; 572  : 
; 573  : #ifdef WIN32
; 574  :   LeaveCriticalSection( phTTS->pcsLogFile );

  00536	8b 83 c4 00 00
	00		 mov	 eax, DWORD PTR [ebx+196]
  0053c	50		 push	 eax
  0053d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00543	5d		 pop	 ebp
$L71802:
  00544	5f		 pop	 edi
  00545	5e		 pop	 esi
  00546	5b		 pop	 ebx

; 575  : #endif
; 576  : #if defined (__osf__) || defined (__linux__)
; 577  :   /* GL 04/21/1997  change this as the latest OSF code */
; 578  :   /*ToggleLogfileMutex( MUTEX_RELEASE );*/
; 579  :   OP_UnlockMutex( phTTS->pcsLogFile );
; 580  : #endif
; 581  : 
; 582  : }

  00547	83 c4 0c	 add	 esp, 12			; 0000000cH
  0054a	c3		 ret	 0
_ls_suff_print_fc ENDP
_TEXT	ENDS
END
