	TITLE	D:\work\product\dapi\src\Lts\ls_math.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_math_table
PUBLIC	_ascky_tab
_DATA	SEGMENT
_math_table DB	02bH
	ORG $+3
	DD	FLAT:$SG71694
	DB	02dH
	ORG $+3
	DD	FLAT:$SG71695
	DB	02aH
	ORG $+3
	DD	FLAT:$SG71696
	DB	02fH
	ORG $+3
	DD	FLAT:$SG71697
	DB	05eH
	ORG $+3
	DD	FLAT:$SG71698
	DB	03cH
	ORG $+3
	DD	FLAT:$SG71699
	DB	03eH
	ORG $+3
	DD	FLAT:$SG71700
	DB	03dH
	ORG $+3
	DD	FLAT:$SG71701
	DB	025H
	ORG $+3
	DD	FLAT:$SG71702
	DB	02eH
	ORG $+3
	DD	FLAT:$SG71703
	DB	00H
	ORG $+3
	DD	00H
_ascky_tab DB	065H
	ORG $+3
	DD	01e03H
	DB	061H
	ORG $+3
	DD	01e06H
	DB	069H
	ORG $+3
	DD	01e01H
	DB	045H
	ORG $+3
	DD	01e04H
	DB	041H
	ORG $+3
	DD	01e07H
	DB	049H
	ORG $+3
	DD	01e02H
	DB	04fH
	ORG $+3
	DD	01e0cH
	DB	06fH
	ORG $+3
	DD	01e0bH
	DB	075H
	ORG $+3
	DD	01e0eH
	DB	05eH
	ORG $+3
	DD	01e09H
	DB	057H
	ORG $+3
	DD	01e08H
	DB	059H
	ORG $+3
	DD	01e10H
	DB	052H
	ORG $+3
	DD	01e0fH
	DB	063H
	ORG $+3
	DD	01e0aH
	DB	040H
	ORG $+3
	DD	01e05H
	DB	055H
	ORG $+3
	DD	01e0dH
	DB	07cH
	ORG $+3
	DD	01e12H
	DB	078H
	ORG $+3
	DD	01e11H
	DB	070H
	ORG $+3
	DD	01e2dH
	DB	074H
	ORG $+3
	DD	01e2fH
	DB	06bH
	ORG $+3
	DD	01e31H
	DB	066H
	ORG $+3
	DD	01e25H
	DB	054H
	ORG $+3
	DD	01e27H
	DB	073H
	ORG $+3
	DD	01e29H
	DB	053H
	ORG $+3
	DD	01e2bH
	DB	043H
	ORG $+3
	DD	01e36H
	DB	077H
	ORG $+3
	DD	01e18H
	DB	079H
	ORG $+3
	DD	01e19H
	DB	068H
	ORG $+3
	DD	01e1cH
	DB	06cH
	ORG $+3
	DD	01e1bH
	DB	04cH
	ORG $+3
	DD	01e22H
	DB	04eH
	ORG $+3
	DD	01e24H
	DB	062H
	ORG $+3
	DD	01e2eH
	DB	064H
	ORG $+3
	DD	01e30H
	DB	067H
	ORG $+3
	DD	01e32H
	DB	076H
	ORG $+3
	DD	01e26H
	DB	044H
	ORG $+3
	DD	01e28H
	DB	07aH
	ORG $+3
	DD	01e2aH
	DB	05aH
	ORG $+3
	DD	01e2cH
	DB	04aH
	ORG $+3
	DD	01e37H
	DB	06dH
	ORG $+3
	DD	01e1fH
	DB	06eH
	ORG $+3
	DD	01e20H
	DB	047H
	ORG $+3
	DD	01e21H
	DB	072H
	ORG $+3
	DD	01e1aH
	DB	071H
	ORG $+3
	DD	01e35H
	DB	051H
	ORG $+3
	DD	01e34H
	DB	026H
	ORG $+3
	DD	01e33H
	DB	046H
	ORG $+3
	DD	01e38H
	DB	042H
	ORG $+3
	DD	01e13H
	DB	04bH
	ORG $+3
	DD	01e14H
	DB	050H
	ORG $+3
	DD	01e15H
	DB	04dH
	ORG $+3
	DD	01e16H
	DB	06aH
	ORG $+3
	DD	01e17H
	DB	02cH
	ORG $+3
	DD	01e73H
	DB	020H
	ORG $+3
	DD	01e6fH
	DB	09H
	ORG $+3
	DD	01e6fH
	DB	027H
	ORG $+3
	DD	01e67H
	DB	060H
	ORG $+3
	DD	01e66H
	DB	022H
	ORG $+3
	DD	01e68H
	DB	023H
	ORG $+3
	DD	01e6eH
	DB	028H
	ORG $+3
	DD	01e70H
	DB	029H
	ORG $+3
	DD	01e71H
	DB	02aH
	ORG $+3
	DD	01e6dH
	DB	07eH
	ORG $+3
	DD	01e64H
	DB	02dH
	ORG $+3
	DD	01e6cH
$SG71694 DB	'pl''^s', 00H
	ORG $+2
$SG71695 DB	'm''An|s', 00H
	ORG $+1
$SG71696 DB	'm''^lt|plAd*bA', 00H
	ORG $+2
$SG71697 DB	'd|v''Ad|d*bA', 00H
$SG71698 DB	'tU*Dx*p''WR*xv', 00H
	ORG $+2
$SG71699 DB	'l''Es*DEn', 00H
	ORG $+3
$SG71700 DB	'gr''etR*DEn', 00H
	ORG $+1
$SG71701 DB	'''ikwLz', 00H
	ORG $+1
$SG71702 DB	'pRs''Ent', 00H
$SG71703 DB	'p''Ont', 00H
_DATA	ENDS
PUBLIC	_ls_math_do_math
PUBLIC	_ls_math_flush_ascky
_TEXT	SEGMENT
_pKsd_t$ = 8
_check_char$ = 12
_ls_math_do_math PROC NEAR

; 76   : {

  00000	56		 push	 esi

; 77   : 	struct math_symbols *ms;
; 78   : 
; 79   : 	/*
; 80   : 	 * this must be a single character and mode math must be enabled ...
; 81   : 	 */
; 82   : 
; 83   : 	if(pKsd_t->modeflag & MODE_MATH)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _pKsd_t$[esp]
  00005	f6 86 00 02 00
	00 04		 test	 BYTE PTR [esi+512], 4
  0000c	74 20		 je	 SHORT $L71714

; 84   : 	{
; 85   : 		ms = math_table;
; 86   : 		while((*ms).sym)

  0000e	a0 00 00 00 00	 mov	 al, BYTE PTR _math_table
  00013	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_math_table
  00018	84 c0		 test	 al, al
  0001a	74 12		 je	 SHORT $L71714

; 87   : 		{
; 88   : 			if((*ms).sym == check_char)

  0001c	8a 54 24 0c	 mov	 dl, BYTE PTR _check_char$[esp]
$L71713:
  00020	3a c2		 cmp	 al, dl
  00022	74 0e		 je	 SHORT $L71736
  00024	8a 41 08	 mov	 al, BYTE PTR [ecx+8]

; 92   : 			}
; 93   : 			else
; 94   : 				ms += 1;

  00027	83 c1 08	 add	 ecx, 8
  0002a	84 c0		 test	 al, al
  0002c	75 f2		 jne	 SHORT $L71713
$L71714:

; 95   : 		}
; 96   : 	}
; 97   : 	return(false);

  0002e	33 c0		 xor	 eax, eax
  00030	5e		 pop	 esi

; 98   : }

  00031	c3		 ret	 0
$L71736:

; 89   : 			{
; 90   : 				ls_math_flush_ascky(pKsd_t,(*ms).sym_pron);

  00032	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00035	50		 push	 eax
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 _ls_math_flush_ascky
  0003c	83 c4 08	 add	 esp, 8

; 91   : 				return(true);

  0003f	b8 01 00 00 00	 mov	 eax, 1
  00044	5e		 pop	 esi

; 98   : }

  00045	c3		 ret	 0
_ls_math_do_math ENDP
_TEXT	ENDS
EXTRN	_ls_util_write_pipe:NEAR
_TEXT	SEGMENT
_pKsd_t$ = 8
_str$ = 12
_ls_math_flush_ascky PROC NEAR

; 123  : {                              

  00050	56		 push	 esi

; 124  : 	int	i;	
; 125  : 
; 126  : 	while(*str)

  00051	8b 74 24 0c	 mov	 esi, DWORD PTR _str$[esp]
  00055	8a 06		 mov	 al, BYTE PTR [esi]
  00057	84 c0		 test	 al, al
  00059	74 46		 je	 SHORT $L71725
  0005b	53		 push	 ebx
  0005c	57		 push	 edi
  0005d	8b 7c 24 10	 mov	 edi, DWORD PTR _pKsd_t$[esp+8]
$L71724:

; 127  : 	{
; 128  : 		for(i=0;i<NATAB;i++)  
; 129  : 		{
; 130  : 			if(*str == ascky_tab[i].p_graph)

  00061	8b d0		 mov	 edx, eax
  00063	33 c9		 xor	 ecx, ecx
  00065	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0006b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_ascky_tab
$L71727:
  00070	0f be 18	 movsx	 ebx, BYTE PTR [eax]
  00073	3b d3		 cmp	 edx, ebx
  00075	74 0d		 je	 SHORT $L71740
  00077	83 c0 08	 add	 eax, 8
  0007a	41		 inc	 ecx
  0007b	3d 08 02 00 00	 cmp	 eax, OFFSET FLAT:_ascky_tab+520
  00080	7c ee		 jl	 SHORT $L71727
  00082	eb 13		 jmp	 SHORT $L71729
$L71740:

; 131  : 			{
; 132  : 				ls_util_write_pipe(pKsd_t, (short *)&ascky_tab[i].pphone,1);

  00084	8d 04 cd 04 00
	00 00		 lea	 eax, DWORD PTR _ascky_tab[ecx*8+4]
  0008b	6a 01		 push	 1
  0008d	50		 push	 eax
  0008e	57		 push	 edi
  0008f	e8 00 00 00 00	 call	 _ls_util_write_pipe
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71729:
  00097	8a 46 01	 mov	 al, BYTE PTR [esi+1]

; 133  : 				break;
; 134  : 			} 
; 135  : 		}
; 136  : 		str += 1;

  0009a	46		 inc	 esi
  0009b	84 c0		 test	 al, al
  0009d	75 c2		 jne	 SHORT $L71724
  0009f	5f		 pop	 edi
  000a0	5b		 pop	 ebx
$L71725:
  000a1	5e		 pop	 esi

; 137  : 	}
; 138  : }

  000a2	c3		 ret	 0
_ls_math_flush_ascky ENDP
_TEXT	ENDS
END
