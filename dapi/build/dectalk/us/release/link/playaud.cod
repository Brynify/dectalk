	TITLE	D:\work\product\dapi\src\NT\playaud.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_Shm_t
PUBLIC	_pShm_t
PUBLIC	_tlPlayAudio
_BSS	SEGMENT
_tlPlayAudio DB	0cH DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_Shm_t	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_pShm_t	DD	FLAT:_Shm_t
_DATA	ENDS
PUBLIC	_PA_CreatePlayHandle
PUBLIC	_PA_CreatePlayHandleEx
EXTRN	_ThreadLock:NEAR
EXTRN	_ThreadUnlock:NEAR
_TEXT	SEGMENT
_ppPlayAudio$ = 8
_uiWaveOutDeviceID$ = 12
_pWaveFormat$ = 16
_dwDeviceOptions$ = 20
_CallbackRoutine$ = 24
_aInstance$ = 28
_PA_CreatePlayHandle PROC NEAR

; 612  : {

  00000	56		 push	 esi

; 613  :   
; 614  :   MMRESULT mmResult=MMSYSERR_ERROR; // the default error
; 615  :   BOOL bGotLock=FALSE;	// whether we got the lock
; 616  :   
; 617  :   // try to gain control of the resources
; 618  :   bGotLock = ThreadLock(&tlPlayAudio,5);

  00001	6a 05		 push	 5
  00003	68 00 00 00 00	 push	 OFFSET FLAT:_tlPlayAudio
  00008	be 01 00 00 00	 mov	 esi, 1
  0000d	e8 00 00 00 00	 call	 _ThreadLock
  00012	83 c4 08	 add	 esp, 8

; 619  :   if (bGotLock)

  00015	85 c0		 test	 eax, eax
  00017	74 32		 je	 SHORT $L71325

; 620  :     {	// do the actual call..
; 621  :       mmResult = PA_CreatePlayHandleEx(ppPlayAudio,
; 622  : 				       uiWaveOutDeviceID,
; 623  : 				       pWaveFormat,
; 624  : 				       dwDeviceOptions,
; 625  : 				       CallbackRoutine,
; 626  : 				       aInstance);

  00019	8b 44 24 1c	 mov	 eax, DWORD PTR _aInstance$[esp]
  0001d	8b 4c 24 18	 mov	 ecx, DWORD PTR _CallbackRoutine$[esp]
  00021	8b 54 24 14	 mov	 edx, DWORD PTR _dwDeviceOptions$[esp]
  00025	50		 push	 eax
  00026	8b 44 24 14	 mov	 eax, DWORD PTR _pWaveFormat$[esp+4]
  0002a	51		 push	 ecx
  0002b	8b 4c 24 14	 mov	 ecx, DWORD PTR _uiWaveOutDeviceID$[esp+8]
  0002f	52		 push	 edx
  00030	8b 54 24 14	 mov	 edx, DWORD PTR _ppPlayAudio$[esp+12]
  00034	50		 push	 eax
  00035	51		 push	 ecx
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 _PA_CreatePlayHandleEx

; 627  :       // unlock the resources
; 628  :       ThreadUnlock(&tlPlayAudio);

  0003c	68 00 00 00 00	 push	 OFFSET FLAT:_tlPlayAudio
  00041	8b f0		 mov	 esi, eax
  00043	e8 00 00 00 00	 call	 _ThreadUnlock
  00048	83 c4 1c	 add	 esp, 28			; 0000001cH
$L71325:

; 629  :     }
; 630  :   // return our result
; 631  :   return (mmResult);

  0004b	8b c6		 mov	 eax, esi
  0004d	5e		 pop	 esi

; 632  : }

  0004e	c3		 ret	 0
_PA_CreatePlayHandle ENDP
_TEXT	ENDS
PUBLIC	_PA_DestroyPlayHandle
PUBLIC	_PA_SetFormat
PUBLIC	_PlayAudioThreadMain
PUBLIC	_TimerThreadMain
EXTRN	__imp__malloc:NEAR
EXTRN	__imp__waveOutGetNumDevs@0:NEAR
EXTRN	_OP_CreateThread:NEAR
EXTRN	_OP_SetThreadPriority:NEAR
EXTRN	_OP_CreateMutex:NEAR
EXTRN	_OP_CreateEvent:NEAR
EXTRN	_mallocLock:NEAR
_TEXT	SEGMENT
_ppPlayAudio$ = 8
_uiWaveOutDeviceID$ = 12
_pWaveFormat$ = 16
_dwDeviceOptions$ = 20
_CallbackRoutine$ = 24
_aInstance$ = 28
_uiNumberOfWaveOutDevices$ = -24
_WaveFormat$ = -20
_PA_CreatePlayHandleEx PROC NEAR

; 644  : {

  00050	83 ec 18	 sub	 esp, 24			; 00000018H

; 645  :   unsigned int uiI;
; 646  :   unsigned int uiNumberOfWaveOutDevices;
; 647  :   MMRESULT mmStatus;
; 648  :   WAVEFORMATEX WaveFormat;
; 649  :   LPPLAY_RING_T pPlayAudioRing;
; 650  :   HPLAY_AUDIO_T pPlayAudio = NULL;
; 651  : 
; 652  : #ifdef OS_SIXTY_FOUR_BIT
; 653  :   unsigned int bHandleSaved;
; 654  :   HPLAY_AUDIO_T * ppGlobalHandleListTemp;
; 655  : #endif
; 656  :   
; 657  : #ifdef AUD_DEBUG
; 658  :   OutputDebugString("PA_CreatePlayHandle()\n");
; 659  : #endif
; 660  :   
; 661  :   /********************************************************************/
; 662  :   /*  Set the return handle to NULL in case this function fails.      */
; 663  :   /********************************************************************/
; 664  : 
; 665  :   *ppPlayAudio = NULL;

  00053	8b 44 24 1c	 mov	 eax, DWORD PTR _ppPlayAudio$[esp+20]
  00057	53		 push	 ebx
  00058	55		 push	 ebp
  00059	56		 push	 esi
  0005a	57		 push	 edi
  0005b	33 ff		 xor	 edi, edi
  0005d	89 38		 mov	 DWORD PTR [eax], edi

; 666  : 
; 667  :   /********************************************************************/
; 668  :   /*  Increment the play audio instance count.                        */
; 669  :   /********************************************************************/
; 670  : 
; 671  :   pShm_t->uiGlobalPlayAudioInstance++;

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  00064	ff 00		 inc	 DWORD PTR [eax]

; 672  : 
; 673  : #ifdef MME_THREAD_SAFE
; 674  : 
; 675  :   /********************************************************************/
; 676  :   /*  If this is the first instance then create a global mutex to     */
; 677  :   /*  protect MME server calls.                                       */
; 678  :   /********************************************************************/
; 679  : 
; 680  :   if ( pShm_t->uiGlobalPlayAudioInstance == 1 )
; 681  :   {
; 682  :     /******************************************************************/
; 683  :     /*  Create the "Multimedia" mutex.                                */
; 684  :     /******************************************************************/
; 685  : 
; 686  :     pShm_t->hmxGlobalMmeServer = OP_CreateMutex();
; 687  : 
; 688  :     if ( pShm_t->hmxGlobalMmeServer == NULL )
; 689  :     {
; 690  :       PA_DestroyPlayHandle( pPlayAudio );
; 691  :       return MMSYSERR_ERROR;
; 692  :     }
; 693  :   }
; 694  : 
; 695  : #endif
; 696  : 
; 697  : 
; 698  : #ifdef OS_SIXTY_FOUR_BIT
; 699  : 
; 700  :   /********************************************************************/
; 701  :   /*  If this is the first instance then create a global mutex to     */
; 702  :   /*  protect the global Handle List.                                 */
; 703  :   /********************************************************************/
; 704  : 
; 705  :   if ( pShm_t->uiGlobalPlayAudioInstance == 1 )
; 706  :   {
; 707  :     /******************************************************************/
; 708  :     /*  Create the global handle mutex.                               */
; 709  :     /******************************************************************/
; 710  : 
; 711  :     pShm_t->hmxGlobalHandleList = OP_CreateMutex();
; 712  : 
; 713  :     if ( pShm_t->hmxGlobalHandleList == NULL )
; 714  :     {
; 715  :       PA_DestroyPlayHandle( pPlayAudio );
; 716  :       return MMSYSERR_ERROR;
; 717  :     }
; 718  :   }
; 719  : 
; 720  : #endif
; 721  : 
; 722  :   /********************************************************************/
; 723  :   /*  Make sure the system has an audio card.                         */
; 724  :   /********************************************************************/
; 725  : 
; 726  :   LOCK_MME_CALL( uiNumberOfWaveOutDevices = waveOutGetNumDevs() )

  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetNumDevs@0

; 727  : 
; 728  :   if ( uiNumberOfWaveOutDevices == 0 )

  0006c	3b c7		 cmp	 eax, edi
  0006e	89 44 24 10	 mov	 DWORD PTR _uiNumberOfWaveOutDevices$[esp+40], eax
  00072	75 16		 jne	 SHORT $L70238

; 729  :   {
; 730  : #ifdef AUD_DEBUG
; 731  : 	OutputDebugString("PA_: No wave output device found.\n");
; 732  : #endif
; 733  :     PA_DestroyPlayHandle( pPlayAudio );

  00074	57		 push	 edi
  00075	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  0007a	83 c4 04	 add	 esp, 4

; 734  :     return MMSYSERR_NODRIVER;

  0007d	b8 06 00 00 00	 mov	 eax, 6
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5d		 pop	 ebp
  00085	5b		 pop	 ebx

; 1416 : }

  00086	83 c4 18	 add	 esp, 24			; 00000018H
  00089	c3		 ret	 0
$L70238:

; 735  :   }
; 736  :   else
; 737  :   {
; 738  : #ifdef AUD_DEBUG
; 739  : 	  OutputDebugString("PA_: Wave device found.\n");
; 740  : #endif
; 741  :   }
; 742  : 
; 743  :   /********************************************************************/
; 744  :   /*  Make sure the device ID is valid. This is tested as an integer  */
; 745  :   /*  so that a device ID of WAVE_MAPPER ( which is equal to -1 )     */
; 746  :   /*  passes as a valid device ID.                                    */
; 747  :   /********************************************************************/
; 748  :   if ((int)uiWaveOutDeviceID >= (int)uiNumberOfWaveOutDevices )

  0008a	39 44 24 30	 cmp	 DWORD PTR _uiWaveOutDeviceID$[esp+36], eax
  0008e	7c 16		 jl	 SHORT $L70242

; 749  :   {
; 750  : #ifdef AUD_DEBUG
; 751  : 	OutputDebugString("PA_: Bad Device ID\n");
; 752  : #endif
; 753  :     PA_DestroyPlayHandle( pPlayAudio );

  00090	57		 push	 edi
  00091	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00096	83 c4 04	 add	 esp, 4

; 754  :     return MMSYSERR_BADDEVICEID;

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5d		 pop	 ebp
  000a1	5b		 pop	 ebx

; 1416 : }

  000a2	83 c4 18	 add	 esp, 24			; 00000018H
  000a5	c3		 ret	 0
$L70242:

; 755  :   }
; 756  :    else
; 757  :   {
; 758  : #ifdef AUD_DEBUG
; 759  : 	OutputDebugString("PA_: Device ID OK\n");
; 760  : #endif
; 761  :    }
; 762  :   /********************************************************************/
; 763  :   /*  Allocate memory for the play audio handle structure.            */
; 764  :   /********************************************************************/
; 765  : 
; 766  :   pPlayAudio = (HPLAY_AUDIO_T)malloc(sizeof(PLAY_AUDIO_T));

  000a6	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__malloc
  000ac	68 b8 00 00 00	 push	 184			; 000000b8H
  000b1	ff d3		 call	 ebx
  000b3	8b f0		 mov	 esi, eax
  000b5	83 c4 04	 add	 esp, 4

; 767  : 
; 768  :   if ( pPlayAudio == NULL )

  000b8	3b f7		 cmp	 esi, edi
  000ba	75 16		 jne	 SHORT $L70247

; 769  :   {
; 770  :     PA_DestroyPlayHandle( pPlayAudio );

  000bc	56		 push	 esi
  000bd	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  000c2	83 c4 04	 add	 esp, 4

; 771  :     return MMSYSERR_NOMEM;

  000c5	b8 07 00 00 00	 mov	 eax, 7
  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5d		 pop	 ebp
  000cd	5b		 pop	 ebx

; 1416 : }

  000ce	83 c4 18	 add	 esp, 24			; 00000018H
  000d1	c3		 ret	 0
$L70247:

; 772  :   }
; 773  : 
; 774  :   pPlayAudio->bHandleValid = FALSE;
; 775  : 
; 776  :   /********************************************************************/
; 777  :   /*  Initialize several handle elements to NULL.                     */
; 778  :   /********************************************************************/
; 779  : 
; 780  :   pPlayAudio->CallbackRoutine = NULL;
; 781  :   pPlayAudio->hWaveOut = (int)NULL;
; 782  :   pPlayAudio->hTimerThread = NULL;
; 783  :   pPlayAudio->hevAudioDeviceInactive = NULL;
; 784  :   pPlayAudio->hevTimerThreadActive = NULL;
; 785  :   pPlayAudio->hevQueueNotFull = NULL;
; 786  :   pPlayAudio->hevResetComplete = NULL;
; 787  :   pPlayAudio->hmxAudioDeviceState = NULL;
; 788  :   pPlayAudio->hmxBytesPlayed = NULL;
; 789  :   pPlayAudio->hmxSelectedDeviceID = NULL;
; 790  :   pPlayAudio->hmxQueueCount = NULL;
; 791  :   pPlayAudio->hmxQueueAudioBusy = NULL;
; 792  :   pPlayAudio->hmxPauseFlag = NULL;
; 793  :   pPlayAudio->ppWaveHdr = NULL;
; 794  :   pPlayAudio->pPlayAudioRing = NULL;
; 795  :   pPlayAudio->pSyncMarkList = NULL;
; 796  :   pPlayAudio->pWaveFormat = NULL;
; 797  :   //tek 09may97
; 798  :   pPlayAudio->iOutstandingBuffers=0;
; 799  :   pPlayAudio->iFirstFreeBuffer=0; //tek
; 800  : 
; 801  : #ifdef OS_SIXTY_FOUR_BIT
; 802  : 
; 803  :   /********************************************************************/
; 804  :   /*  Store the handle in the first free location in the global       */
; 805  :   /*  instance array so the wave output callback function can access  */
; 806  :   /*  the handle. This is necessary because for Digital UNIX,         */
; 807  :   /*  pointers are 64 bit and the dwInstance parameter (that is       */
; 808  :   /*  passed to the waveOutOpen() function and later returned in      */
; 809  :   /*  a callback) cannot hold a pointer to the play audio handle.     */
; 810  :   /********************************************************************/
; 811  : 
; 812  :   /********************************************************************/
; 813  :   /*  Set the audio instance to an illegal value. This is tested in   */
; 814  :   /*  the PA_DestroyPlayHandle() function.                            */
; 815  :   /********************************************************************/
; 816  : 
; 817  :   pPlayAudio->uiHandleListIndex = (unsigned int)(-1);
; 818  : 
; 819  :   /********************************************************************/
; 820  :   /*  Protect the Handle List.                                        */
; 821  :   /********************************************************************/
; 822  : 
; 823  :   OP_LockMutex( pShm_t->hmxGlobalHandleList );
; 824  : 
; 825  :   /********************************************************************/
; 826  :   /*  If this is the first "play audio" instance, then allocate the   */
; 827  :   /*  global handle array.                                            */
; 828  :   /********************************************************************/
; 829  : 
; 830  :   if ( pShm_t->ppGlobalHandleList == NULL )
; 831  :   {
; 832  :     pShm_t->ppGlobalHandleList = (HPLAY_AUDIO_T *)malloc( sizeof(HPLAY_AUDIO_T ));
; 833  : 
; 834  :     if ( pShm_t->ppGlobalHandleList == NULL )
; 835  :     {
; 836  :       PA_DestroyPlayHandle( pPlayAudio );
; 837  :       return MMSYSERR_NOMEM;
; 838  :     }
; 839  : 
; 840  :     pShm_t->ppGlobalHandleList[0] = NULL;
; 841  :     pShm_t->uiGlobalHandleListLength = 1;
; 842  :   }
; 843  : 
; 844  :   /********************************************************************/
; 845  :   /*  Attempt to save the handle in the handle list. There might be   */
; 846  :   /*  space in the handle array because a previous "play audio"       */
; 847  :   /*  instance was destroyed by the PA_DestroyPlayHandle() function.  */
; 848  :   /********************************************************************/
; 849  : 
; 850  :   bHandleSaved = FALSE;
; 851  : 
; 852  :   for ( uiI = 0; uiI < pShm_t->uiGlobalHandleListLength; uiI++ )
; 853  :   {
; 854  :     if ( pShm_t->ppGlobalHandleList[uiI] == NULL )
; 855  :     {
; 856  :       pShm_t->ppGlobalHandleList[uiI] = pPlayAudio;
; 857  :       pPlayAudio->uiHandleListIndex = uiI;
; 858  :       bHandleSaved = TRUE;
; 859  :       break;
; 860  :     }
; 861  :   }
; 862  : 
; 863  :   /******************************************************************/
; 864  :   /*  If there was no space in the handle list to save the handle   */
; 865  :   /*  then extend the handle list. Then save the handle.            */
; 866  :   /******************************************************************/
; 867  : 
; 868  :   if ( ! bHandleSaved )
; 869  :   {
; 870  :     ppGlobalHandleListTemp = ( HPLAY_AUDIO_T * )
; 871  :       realloc( pShm_t->ppGlobalHandleList,
; 872  :                ( pShm_t->uiGlobalHandleListLength + 1 ) * sizeof(HPLAY_AUDIO_T ));
; 873  : 
; 874  :     if ( ppGlobalHandleListTemp == NULL )
; 875  :     {
; 876  :       PA_DestroyPlayHandle( pPlayAudio );
; 877  :       return MMSYSERR_NOMEM;
; 878  :     }
; 879  : 
; 880  :     pShm_t->ppGlobalHandleList = ppGlobalHandleListTemp;
; 881  :     pShm_t->ppGlobalHandleList[pShm_t->uiGlobalHandleListLength] = pPlayAudio;
; 882  :     pPlayAudio->uiHandleListIndex = pShm_t->uiGlobalHandleListLength;
; 883  :     pShm_t->uiGlobalHandleListLength++;
; 884  :   }
; 885  : 
; 886  :   /********************************************************************/
; 887  :   /*  Release the Handle List.                                        */
; 888  :   /********************************************************************/
; 889  : 
; 890  :   OP_UnlockMutex( pShm_t->hmxGlobalHandleList );
; 891  : 
; 892  : #endif
; 893  : 
; 894  :   /********************************************************************/
; 895  :   /*  Save the input parameters in the play audio handle.             */
; 896  :   /********************************************************************/
; 897  : 
; 898  :   pPlayAudio->CallbackRoutine = CallbackRoutine;

  000d2	8b 4c 24 3c	 mov	 ecx, DWORD PTR _CallbackRoutine$[esp+36]

; 899  :   pPlayAudio->aInstance = aInstance;

  000d6	8b 54 24 40	 mov	 edx, DWORD PTR _aInstance$[esp+36]

; 900  :   pPlayAudio->dwDeviceOptions = dwDeviceOptions;

  000da	8b 44 24 38	 mov	 eax, DWORD PTR _dwDeviceOptions$[esp+36]
  000de	89 7e 64	 mov	 DWORD PTR [esi+100], edi

; 901  : 
; 902  :   /********************************************************************/
; 903  :   /*  Initialize some Audio parameter handles and flags.              */
; 904  :   /********************************************************************/
; 905  : 
; 906  :   pPlayAudio->bTimerExit = FALSE;
; 907  :   pPlayAudio->bPaused = FALSE;
; 908  :   pPlayAudio->bEnableOpenErrorMessage = TRUE;

  000e1	bd 01 00 00 00	 mov	 ebp, 1
  000e6	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  000e9	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 909  :   pPlayAudio->bReportPlayStop = FALSE;
; 910  : 
; 911  :   /********************************************************************/
; 912  :   /*  Initialize the wave out device state flags.                     */
; 913  :   /********************************************************************/
; 914  : 
; 915  :   pPlayAudio->dwAudioDeviceState = AUDIO_DEVICE_INACTIVE;
; 916  :   pPlayAudio->dwAudioPlayState = AUDIO_STATE_PLAY;
; 917  : 
; 918  :   /********************************************************************/
; 919  :   /*  Set both audio position counts to zero.                         */
; 920  :   /********************************************************************/
; 921  : 
; 922  :   pPlayAudio->dwPositionBase = 0;
; 923  :   pPlayAudio->dwBytesPlayed = 0;
; 924  :   pPlayAudio->dwQueuedByteCount = 0;
; 925  : 
; 926  :   /********************************************************************/
; 927  :   /*  Create an "Audio Device Inactive" event. The initial state is   */
; 928  :   /*  signalled.                                                      */
; 929  :   /********************************************************************/
; 930  : 
; 931  :   pPlayAudio->hevAudioDeviceInactive = OP_CreateEvent( TRUE, TRUE );

  000ec	55		 push	 ebp
  000ed	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000f0	55		 push	 ebp
  000f1	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  000f4	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  000f7	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  000fa	89 7e 6c	 mov	 DWORD PTR [esi+108], edi
  000fd	89 7e 70	 mov	 DWORD PTR [esi+112], edi
  00100	89 7e 74	 mov	 DWORD PTR [esi+116], edi
  00103	89 7e 78	 mov	 DWORD PTR [esi+120], edi
  00106	89 7e 7c	 mov	 DWORD PTR [esi+124], edi
  00109	89 be 84 00 00
	00		 mov	 DWORD PTR [esi+132], edi
  0010f	89 be 90 00 00
	00		 mov	 DWORD PTR [esi+144], edi
  00115	89 be 94 00 00
	00		 mov	 DWORD PTR [esi+148], edi
  0011b	89 be 98 00 00
	00		 mov	 DWORD PTR [esi+152], edi
  00121	89 be 9c 00 00
	00		 mov	 DWORD PTR [esi+156], edi
  00127	89 be a0 00 00
	00		 mov	 DWORD PTR [esi+160], edi
  0012d	89 be a4 00 00
	00		 mov	 DWORD PTR [esi+164], edi
  00133	89 0e		 mov	 DWORD PTR [esi], ecx
  00135	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00138	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  0013b	89 7e 54	 mov	 DWORD PTR [esi+84], edi
  0013e	89 7e 58	 mov	 DWORD PTR [esi+88], edi
  00141	89 6e 5c	 mov	 DWORD PTR [esi+92], ebp
  00144	89 7e 60	 mov	 DWORD PTR [esi+96], edi
  00147	89 7e 34	 mov	 DWORD PTR [esi+52], edi
  0014a	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  0014d	89 7e 40	 mov	 DWORD PTR [esi+64], edi
  00150	89 7e 44	 mov	 DWORD PTR [esi+68], edi
  00153	89 7e 4c	 mov	 DWORD PTR [esi+76], edi
  00156	e8 00 00 00 00	 call	 _OP_CreateEvent
  0015b	83 c4 08	 add	 esp, 8

; 932  : 
; 933  :   if ( pPlayAudio->hevAudioDeviceInactive == NULL )

  0015e	3b c7		 cmp	 eax, edi
  00160	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00163	75 13		 jne	 SHORT $L70267

; 934  :   {
; 935  :     PA_DestroyPlayHandle( pPlayAudio );

  00165	56		 push	 esi
  00166	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  0016b	83 c4 04	 add	 esp, 4

; 936  :     return MMSYSERR_ERROR;

  0016e	8b c5		 mov	 eax, ebp
  00170	5f		 pop	 edi
  00171	5e		 pop	 esi
  00172	5d		 pop	 ebp
  00173	5b		 pop	 ebx

; 1416 : }

  00174	83 c4 18	 add	 esp, 24			; 00000018H
  00177	c3		 ret	 0
$L70267:

; 937  :   }
; 938  : 
; 939  :   /********************************************************************/
; 940  :   /*  Create an "Timer Thread Active" event. The initial state is     */
; 941  :   /*  signalled.                                                      */
; 942  :   /********************************************************************/
; 943  : 
; 944  :   pPlayAudio->hevTimerThreadActive = OP_CreateEvent( TRUE, TRUE );

  00178	55		 push	 ebp
  00179	55		 push	 ebp
  0017a	e8 00 00 00 00	 call	 _OP_CreateEvent
  0017f	83 c4 08	 add	 esp, 8

; 945  : 
; 946  :   if ( pPlayAudio->hevTimerThreadActive == NULL )

  00182	3b c7		 cmp	 eax, edi
  00184	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00187	75 13		 jne	 SHORT $L70269

; 947  :   {
; 948  :     PA_DestroyPlayHandle( pPlayAudio );

  00189	56		 push	 esi
  0018a	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  0018f	83 c4 04	 add	 esp, 4

; 949  :     return MMSYSERR_ERROR;

  00192	8b c5		 mov	 eax, ebp
  00194	5f		 pop	 edi
  00195	5e		 pop	 esi
  00196	5d		 pop	 ebp
  00197	5b		 pop	 ebx

; 1416 : }

  00198	83 c4 18	 add	 esp, 24			; 00000018H
  0019b	c3		 ret	 0
$L70269:

; 950  :   }
; 951  : 
; 952  :   /********************************************************************/
; 953  :   /*  Create a "Queue Not Full" event. The initial state is           */
; 954  :   /*  signalled.                                                      */
; 955  :   /********************************************************************/
; 956  : 
; 957  :   pPlayAudio->hevQueueNotFull = OP_CreateEvent( TRUE, TRUE );

  0019c	55		 push	 ebp
  0019d	55		 push	 ebp
  0019e	e8 00 00 00 00	 call	 _OP_CreateEvent
  001a3	83 c4 08	 add	 esp, 8

; 958  : 
; 959  :   if ( pPlayAudio->hevQueueNotFull == NULL )

  001a6	3b c7		 cmp	 eax, edi
  001a8	89 46 18	 mov	 DWORD PTR [esi+24], eax
  001ab	75 13		 jne	 SHORT $L70271

; 960  :   {
; 961  :     PA_DestroyPlayHandle( pPlayAudio );

  001ad	56		 push	 esi
  001ae	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  001b3	83 c4 04	 add	 esp, 4

; 962  :     return MMSYSERR_ERROR;

  001b6	8b c5		 mov	 eax, ebp
  001b8	5f		 pop	 edi
  001b9	5e		 pop	 esi
  001ba	5d		 pop	 ebp
  001bb	5b		 pop	 ebx

; 1416 : }

  001bc	83 c4 18	 add	 esp, 24			; 00000018H
  001bf	c3		 ret	 0
$L70271:

; 963  :   }
; 964  : 
; 965  :   /********************************************************************/
; 966  :   /*  Create a "Reset Complete" event. The initial state is not       */
; 967  :   /*  signalled.                                                      */
; 968  :   /********************************************************************/
; 969  : 
; 970  :   pPlayAudio->hevResetComplete = OP_CreateEvent( TRUE, TRUE );

  001c0	55		 push	 ebp
  001c1	55		 push	 ebp
  001c2	e8 00 00 00 00	 call	 _OP_CreateEvent
  001c7	83 c4 08	 add	 esp, 8

; 971  : 
; 972  :   if ( pPlayAudio->hevResetComplete == NULL )

  001ca	3b c7		 cmp	 eax, edi
  001cc	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  001cf	75 13		 jne	 SHORT $L70273

; 973  :   {
; 974  :     PA_DestroyPlayHandle( pPlayAudio );

  001d1	56		 push	 esi
  001d2	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  001d7	83 c4 04	 add	 esp, 4

; 975  :     return MMSYSERR_ERROR;

  001da	8b c5		 mov	 eax, ebp
  001dc	5f		 pop	 edi
  001dd	5e		 pop	 esi
  001de	5d		 pop	 ebp
  001df	5b		 pop	 ebx

; 1416 : }

  001e0	83 c4 18	 add	 esp, 24			; 00000018H
  001e3	c3		 ret	 0
$L70273:

; 976  :   }
; 977  : 
; 978  :   /********************************************************************/
; 979  :   /*  Create the "Audio Device State" mutex.                          */
; 980  :   /********************************************************************/
; 981  : 
; 982  :   pPlayAudio->hmxAudioDeviceState = OP_CreateMutex();

  001e4	e8 00 00 00 00	 call	 _OP_CreateMutex

; 983  : 
; 984  :   if ( pPlayAudio->hmxAudioDeviceState == NULL )

  001e9	3b c7		 cmp	 eax, edi
  001eb	89 46 6c	 mov	 DWORD PTR [esi+108], eax
  001ee	75 13		 jne	 SHORT $L70275

; 985  :   {
; 986  :     PA_DestroyPlayHandle( pPlayAudio );

  001f0	56		 push	 esi
  001f1	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  001f6	83 c4 04	 add	 esp, 4

; 987  :     return MMSYSERR_ERROR;

  001f9	8b c5		 mov	 eax, ebp
  001fb	5f		 pop	 edi
  001fc	5e		 pop	 esi
  001fd	5d		 pop	 ebp
  001fe	5b		 pop	 ebx

; 1416 : }

  001ff	83 c4 18	 add	 esp, 24			; 00000018H
  00202	c3		 ret	 0
$L70275:

; 988  :   }
; 989  : 
; 990  :   /********************************************************************/
; 991  :   /*  Create the "Bytes Played" mutex.                                */
; 992  :   /********************************************************************/
; 993  : 
; 994  :   pPlayAudio->hmxBytesPlayed = OP_CreateMutex();

  00203	e8 00 00 00 00	 call	 _OP_CreateMutex

; 995  : 
; 996  :   if ( pPlayAudio->hmxBytesPlayed == NULL )

  00208	3b c7		 cmp	 eax, edi
  0020a	89 46 70	 mov	 DWORD PTR [esi+112], eax
  0020d	75 13		 jne	 SHORT $L70277

; 997  :   {
; 998  :     PA_DestroyPlayHandle( pPlayAudio );

  0020f	56		 push	 esi
  00210	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00215	83 c4 04	 add	 esp, 4

; 999  :     return MMSYSERR_ERROR;

  00218	8b c5		 mov	 eax, ebp
  0021a	5f		 pop	 edi
  0021b	5e		 pop	 esi
  0021c	5d		 pop	 ebp
  0021d	5b		 pop	 ebx

; 1416 : }

  0021e	83 c4 18	 add	 esp, 24			; 00000018H
  00221	c3		 ret	 0
$L70277:

; 1000 :   }
; 1001 : 
; 1002 :   /********************************************************************/
; 1003 :   /*  Create the "Selected Device ID" mutex.                          */
; 1004 :   /********************************************************************/
; 1005 : 
; 1006 :   pPlayAudio->hmxSelectedDeviceID = OP_CreateMutex();

  00222	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1007 : 
; 1008 :   if ( pPlayAudio->hmxSelectedDeviceID == NULL )

  00227	3b c7		 cmp	 eax, edi
  00229	89 46 74	 mov	 DWORD PTR [esi+116], eax
  0022c	75 13		 jne	 SHORT $L70279

; 1009 :   {
; 1010 :     PA_DestroyPlayHandle( pPlayAudio );

  0022e	56		 push	 esi
  0022f	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00234	83 c4 04	 add	 esp, 4

; 1011 :     return MMSYSERR_ERROR;

  00237	8b c5		 mov	 eax, ebp
  00239	5f		 pop	 edi
  0023a	5e		 pop	 esi
  0023b	5d		 pop	 ebp
  0023c	5b		 pop	 ebx

; 1416 : }

  0023d	83 c4 18	 add	 esp, 24			; 00000018H
  00240	c3		 ret	 0
$L70279:

; 1012 :   }
; 1013 : 
; 1014 :   /********************************************************************/
; 1015 :   /*  Create the "Queue Count" mutex.                                 */
; 1016 :   /********************************************************************/
; 1017 : 
; 1018 :   pPlayAudio->hmxQueueCount = OP_CreateMutex();

  00241	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1019 : 
; 1020 :   if ( pPlayAudio->hmxQueueCount == NULL )

  00246	3b c7		 cmp	 eax, edi
  00248	89 46 78	 mov	 DWORD PTR [esi+120], eax
  0024b	75 13		 jne	 SHORT $L70281

; 1021 :   {
; 1022 :     PA_DestroyPlayHandle( pPlayAudio );

  0024d	56		 push	 esi
  0024e	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00253	83 c4 04	 add	 esp, 4

; 1023 :     return MMSYSERR_ERROR;

  00256	8b c5		 mov	 eax, ebp
  00258	5f		 pop	 edi
  00259	5e		 pop	 esi
  0025a	5d		 pop	 ebp
  0025b	5b		 pop	 ebx

; 1416 : }

  0025c	83 c4 18	 add	 esp, 24			; 00000018H
  0025f	c3		 ret	 0
$L70281:

; 1024 :   }
; 1025 : 
; 1026 :   /********************************************************************/
; 1027 :   /*  Create the "Queue Audio Busy" mutex.                            */
; 1028 :   /********************************************************************/
; 1029 : 
; 1030 :   pPlayAudio->hmxQueueAudioBusy = OP_CreateMutex();

  00260	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1031 : 
; 1032 :   if ( pPlayAudio->hmxQueueAudioBusy == NULL )

  00265	3b c7		 cmp	 eax, edi
  00267	89 46 7c	 mov	 DWORD PTR [esi+124], eax
  0026a	75 13		 jne	 SHORT $L70283

; 1033 :   {
; 1034 :     PA_DestroyPlayHandle( pPlayAudio );

  0026c	56		 push	 esi
  0026d	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00272	83 c4 04	 add	 esp, 4

; 1035 :     return MMSYSERR_ERROR;

  00275	8b c5		 mov	 eax, ebp
  00277	5f		 pop	 edi
  00278	5e		 pop	 esi
  00279	5d		 pop	 ebp
  0027a	5b		 pop	 ebx

; 1416 : }

  0027b	83 c4 18	 add	 esp, 24			; 00000018H
  0027e	c3		 ret	 0
$L70283:

; 1036 :   }
; 1037 : 
; 1038 :   /********************************************************************/
; 1039 :   /*  Create the "Queued Byte Count" mutex.                           */
; 1040 :   /********************************************************************/
; 1041 : 
; 1042 :   pPlayAudio->hmxQueuedByteCount = OP_CreateMutex();

  0027f	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1043 : 
; 1044 :   if ( pPlayAudio->hmxQueuedByteCount == NULL )

  00284	3b c7		 cmp	 eax, edi
  00286	89 86 80 00 00
	00		 mov	 DWORD PTR [esi+128], eax
  0028c	75 13		 jne	 SHORT $L70285

; 1045 :   {
; 1046 :     PA_DestroyPlayHandle( pPlayAudio );

  0028e	56		 push	 esi
  0028f	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00294	83 c4 04	 add	 esp, 4

; 1047 :     return MMSYSERR_ERROR;

  00297	8b c5		 mov	 eax, ebp
  00299	5f		 pop	 edi
  0029a	5e		 pop	 esi
  0029b	5d		 pop	 ebp
  0029c	5b		 pop	 ebx

; 1416 : }

  0029d	83 c4 18	 add	 esp, 24			; 00000018H
  002a0	c3		 ret	 0
$L70285:

; 1048 :   }
; 1049 : 
; 1050 :   /********************************************************************/
; 1051 :   /*  Create the "Pause Flag" mutex.                                  */
; 1052 :   /********************************************************************/
; 1053 : 
; 1054 :   pPlayAudio->hmxPauseFlag = OP_CreateMutex();

  002a1	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1055 : 
; 1056 :   if ( pPlayAudio->hmxPauseFlag == NULL )

  002a6	3b c7		 cmp	 eax, edi
  002a8	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  002ae	75 13		 jne	 SHORT $L70287

; 1057 :   {
; 1058 :     PA_DestroyPlayHandle( pPlayAudio );

  002b0	56		 push	 esi
  002b1	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  002b6	83 c4 04	 add	 esp, 4

; 1059 :     return MMSYSERR_ERROR;

  002b9	8b c5		 mov	 eax, ebp
  002bb	5f		 pop	 edi
  002bc	5e		 pop	 esi
  002bd	5d		 pop	 ebp
  002be	5b		 pop	 ebx

; 1416 : }

  002bf	83 c4 18	 add	 esp, 24			; 00000018H
  002c2	c3		 ret	 0
$L70287:

; 1060 :   }
; 1061 : 
; 1062 :   /********************************************************************/
; 1063 :   /*  Create the "Synchronization Mark List" mutex.                   */
; 1064 :   /********************************************************************/
; 1065 : 
; 1066 :   pPlayAudio->hmxSynchronizationMarkList = OP_CreateMutex();

  002c3	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1067 : 
; 1068 :   if ( pPlayAudio->hmxSynchronizationMarkList == NULL )

  002c8	3b c7		 cmp	 eax, edi
  002ca	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  002d0	75 13		 jne	 SHORT $L70289

; 1069 :   {
; 1070 :     PA_DestroyPlayHandle( pPlayAudio );

  002d2	56		 push	 esi
  002d3	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  002d8	83 c4 04	 add	 esp, 4

; 1071 :     return MMSYSERR_ERROR;

  002db	8b c5		 mov	 eax, ebp
  002dd	5f		 pop	 edi
  002de	5e		 pop	 esi
  002df	5d		 pop	 ebp
  002e0	5b		 pop	 ebx

; 1416 : }

  002e1	83 c4 18	 add	 esp, 24			; 00000018H
  002e4	c3		 ret	 0
$L70289:

; 1072 :   }
; 1073 : 
; 1074 :   /********************************************************************/
; 1075 :   /*  Create the "Wave Format" mutex.                                 */
; 1076 :   /********************************************************************/
; 1077 : 
; 1078 :   pPlayAudio->hmxWaveFormat = OP_CreateMutex();

  002e5	e8 00 00 00 00	 call	 _OP_CreateMutex

; 1079 : 
; 1080 :   if ( pPlayAudio->hmxWaveFormat == NULL )

  002ea	3b c7		 cmp	 eax, edi
  002ec	89 86 8c 00 00
	00		 mov	 DWORD PTR [esi+140], eax
  002f2	75 13		 jne	 SHORT $L70291

; 1081 :   {
; 1082 :     PA_DestroyPlayHandle( pPlayAudio );

  002f4	56		 push	 esi
  002f5	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  002fa	83 c4 04	 add	 esp, 4

; 1083 :     return MMSYSERR_ERROR;

  002fd	8b c5		 mov	 eax, ebp
  002ff	5f		 pop	 edi
  00300	5e		 pop	 esi
  00301	5d		 pop	 ebp
  00302	5b		 pop	 ebx

; 1416 : }

  00303	83 c4 18	 add	 esp, 24			; 00000018H
  00306	c3		 ret	 0
$L70291:

; 1084 :   }
; 1085 : 
; 1086 :   /********************************************************************/
; 1087 :   /*  Set the wave format data in the "play audio" handle.            */
; 1088 :   /********************************************************************/
; 1089 : #ifdef AUD_DEBUG
; 1090 :   OutputDebugString("PA_: setting format in handle..\n");
; 1091 : #endif
; 1092 :   if ( pWaveFormat != NULL )

  00307	8b 44 24 34	 mov	 eax, DWORD PTR _pWaveFormat$[esp+36]
  0030b	3b c7		 cmp	 eax, edi
  0030d	74 03		 je	 SHORT $L70293

; 1093 :   {
; 1094 : #ifdef AUD_DEBUG
; 1095 : 	  OutputDebugString("PA_: SetNewFormat {1}\n");
; 1096 : #endif
; 1097 : 	  mmStatus = SetNewFormat( pPlayAudio, pWaveFormat );

  0030f	50		 push	 eax

; 1098 :   }
; 1099 :   else

  00310	eb 32		 jmp	 SHORT $L71332
$L70293:

; 1100 :   {
; 1101 :     /******************************************************************/
; 1102 :     /*  The default format is 11 Khz. 16 bit PCM.                     */
; 1103 :     /******************************************************************/
; 1104 : 
; 1105 :     WaveFormat.wFormatTag = WAVE_FORMAT_PCM;
; 1106 :     WaveFormat.nSamplesPerSec = 11025;
; 1107 :     WaveFormat.nChannels = 1;
; 1108 :     WaveFormat.nAvgBytesPerSec = 22050;
; 1109 :     WaveFormat.nBlockAlign = 2;
; 1110 :     WaveFormat.wBitsPerSample = 16;
; 1111 :     WaveFormat.cbSize = 0;
; 1112 : 
; 1113 : #ifdef AUD_DEBUG
; 1114 : 	OutputDebugString("PA_: SetNewFormat {2}\n");
; 1115 : #endif
; 1116 :     mmStatus = SetNewFormat( pPlayAudio, &WaveFormat );

  00312	8d 4c 24 14	 lea	 ecx, DWORD PTR _WaveFormat$[esp+40]
  00316	66 89 6c 24 14	 mov	 WORD PTR _WaveFormat$[esp+40], bp
  0031b	c7 44 24 18 11
	2b 00 00	 mov	 DWORD PTR _WaveFormat$[esp+44], 11025 ; 00002b11H
  00323	66 89 6c 24 16	 mov	 WORD PTR _WaveFormat$[esp+42], bp
  00328	c7 44 24 1c 22
	56 00 00	 mov	 DWORD PTR _WaveFormat$[esp+48], 22050 ; 00005622H
  00330	66 c7 44 24 20
	02 00		 mov	 WORD PTR _WaveFormat$[esp+52], 2
  00337	66 c7 44 24 22
	10 00		 mov	 WORD PTR _WaveFormat$[esp+54], 16 ; 00000010H
  0033e	66 89 7c 24 24	 mov	 WORD PTR _WaveFormat$[esp+56], di
  00343	51		 push	 ecx
$L71332:
  00344	56		 push	 esi
  00345	e8 00 00 00 00	 call	 _SetNewFormat
  0034a	8b e8		 mov	 ebp, eax
  0034c	83 c4 08	 add	 esp, 8

; 1117 :   }
; 1118 : 
; 1119 :   if ( mmStatus )

  0034f	3b ef		 cmp	 ebp, edi
  00351	74 13		 je	 SHORT $L70295

; 1120 :   {
; 1121 : #ifdef AUD_DEBUG
; 1122 : 	OutputDebugString("PA_: SetNewFormat failed\n");
; 1123 : #endif
; 1124 :     PA_DestroyPlayHandle( pPlayAudio );

  00353	56		 push	 esi
  00354	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00359	83 c4 04	 add	 esp, 4

; 1125 :     return mmStatus;

  0035c	8b c5		 mov	 eax, ebp
  0035e	5f		 pop	 edi
  0035f	5e		 pop	 esi
  00360	5d		 pop	 ebp
  00361	5b		 pop	 ebx

; 1416 : }

  00362	83 c4 18	 add	 esp, 24			; 00000018H
  00365	c3		 ret	 0
$L70295:

; 1126 :   }
; 1127 : 
; 1128 :   /********************************************************************/
; 1129 :   /*  Allocate Memory for Wave Header pointer array.                  */
; 1130 :   /********************************************************************/
; 1131 : 
; 1132 :   pPlayAudio->ppWaveHdr =
; 1133 :     (LPWAVEHDR *)malloc( MAXIMUM_BUFFERS_QUEUED * sizeof(LPWAVEHDR));

  00366	6a 20		 push	 32			; 00000020H
  00368	ff d3		 call	 ebx
  0036a	83 c4 04	 add	 esp, 4

; 1134 : 
; 1135 :   if ( pPlayAudio->ppWaveHdr == NULL )

  0036d	3b c7		 cmp	 eax, edi
  0036f	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax
  00375	75 16		 jne	 SHORT $L70299

; 1136 :   {
; 1137 :     PA_DestroyPlayHandle( pPlayAudio );

  00377	56		 push	 esi
  00378	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  0037d	83 c4 04	 add	 esp, 4

; 1138 :     return MMSYSERR_NOMEM;

  00380	b8 07 00 00 00	 mov	 eax, 7
  00385	5f		 pop	 edi
  00386	5e		 pop	 esi
  00387	5d		 pop	 ebp
  00388	5b		 pop	 ebx

; 1416 : }

  00389	83 c4 18	 add	 esp, 24			; 00000018H
  0038c	c3		 ret	 0
$L70299:

; 1139 :   }
; 1140 :   else
; 1141 :   {
; 1142 :     for ( uiI = 0; uiI < MAXIMUM_BUFFERS_QUEUED; uiI++ )

  0038d	33 c0		 xor	 eax, eax
$L70301:

; 1143 :       pPlayAudio->ppWaveHdr[uiI] = NULL;

  0038f	8b 96 90 00 00
	00		 mov	 edx, DWORD PTR [esi+144]
  00395	83 c0 04	 add	 eax, 4
  00398	83 f8 20	 cmp	 eax, 32			; 00000020H
  0039b	89 7c 10 fc	 mov	 DWORD PTR [eax+edx-4], edi
  0039f	7c ee		 jl	 SHORT $L70301

; 1144 : 
; 1145 :     /******************************************************************/
; 1146 :     /*  Allocate Memory for the Wave Headers.                         */
; 1147 :     /******************************************************************/
; 1148 : 
; 1149 :     for ( uiI = 0; uiI < MAXIMUM_BUFFERS_QUEUED; uiI++ )

  003a1	33 ed		 xor	 ebp, ebp
$L70305:

; 1150 :     {
; 1151 :       LOCK_MME_CALL(
; 1152 :         pPlayAudio->ppWaveHdr[uiI] =
; 1153 :           (LPWAVEHDR)ALLOCATE_LOCKED_MEMORY( sizeof(WAVEHDR)))

  003a3	6a 20		 push	 32			; 00000020H
  003a5	e8 00 00 00 00	 call	 _mallocLock
  003aa	8b 8e 90 00 00
	00		 mov	 ecx, DWORD PTR [esi+144]
  003b0	83 c4 04	 add	 esp, 4
  003b3	89 04 29	 mov	 DWORD PTR [ecx+ebp], eax

; 1154 : 
; 1155 :       if ( pPlayAudio->ppWaveHdr[uiI] == NULL )

  003b6	8b 96 90 00 00
	00		 mov	 edx, DWORD PTR [esi+144]
  003bc	39 3c 2a	 cmp	 DWORD PTR [edx+ebp], edi
  003bf	74 48		 je	 SHORT $L71329
  003c1	83 c5 04	 add	 ebp, 4
  003c4	83 fd 20	 cmp	 ebp, 32			; 00000020H
  003c7	7c da		 jl	 SHORT $L70305

; 1156 :       {
; 1157 :         PA_DestroyPlayHandle( pPlayAudio );
; 1158 :         return MMSYSERR_NOMEM;
; 1159 :       }
; 1160 :     }
; 1161 :   }
; 1162 : 
; 1163 :   /********************************************************************/
; 1164 :   /*  Allocate Memory for the Audio Queue Structure.                  */
; 1165 :   /********************************************************************/
; 1166 : 
; 1167 :   pPlayAudioRing = (LPPLAY_RING_T)malloc(sizeof(PLAY_RING_T));

  003c9	6a 20		 push	 32			; 00000020H
  003cb	ff d3		 call	 ebx
  003cd	8b e8		 mov	 ebp, eax
  003cf	83 c4 04	 add	 esp, 4

; 1168 : 
; 1169 :   if ( pPlayAudioRing == NULL )

  003d2	3b ef		 cmp	 ebp, edi
  003d4	75 16		 jne	 SHORT $L70315

; 1170 :   {
; 1171 :     PA_DestroyPlayHandle( pPlayAudio );

  003d6	56		 push	 esi
  003d7	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  003dc	83 c4 04	 add	 esp, 4

; 1172 :     return MMSYSERR_NOMEM;

  003df	b8 07 00 00 00	 mov	 eax, 7
  003e4	5f		 pop	 edi
  003e5	5e		 pop	 esi
  003e6	5d		 pop	 ebp
  003e7	5b		 pop	 ebx

; 1416 : }

  003e8	83 c4 18	 add	 esp, 24			; 00000018H
  003eb	c3		 ret	 0
$L70315:

; 1173 :   }
; 1174 : 
; 1175 :   pPlayAudio->pPlayAudioRing = pPlayAudioRing;

  003ec	89 ae 94 00 00
	00		 mov	 DWORD PTR [esi+148], ebp

; 1176 : 
; 1177 :   /********************************************************************/
; 1178 :   /*  Initialize several of the audio queue elements to NULL.         */
; 1179 :   /********************************************************************/
; 1180 : 
; 1181 :   pPlayAudioRing->pQueueTop = NULL;
; 1182 : 
; 1183 :   /********************************************************************/
; 1184 :   /*  Allocate Memory for the audio buffer.                           */
; 1185 :   /********************************************************************/
; 1186 : 
; 1187 :   LOCK_MME_CALL(
; 1188 :     pPlayAudioRing->pQueueTop = (LPAUDIO_T)
; 1189 :       ALLOCATE_SERVER_BUFFER(( AUDIO_BUFFER_SIZE + MAXIMUM_WRITE_LENGTH ) *
; 1190 :         sizeof(AUDIO_T)))

  003f2	68 00 80 02 00	 push	 163840			; 00028000H
  003f7	89 7d 00	 mov	 DWORD PTR [ebp], edi
  003fa	e8 00 00 00 00	 call	 _mallocLock
  003ff	83 c4 04	 add	 esp, 4

; 1191 : 
; 1192 :   if ( pPlayAudioRing->pQueueTop == NULL )

  00402	3b c7		 cmp	 eax, edi
  00404	89 45 00	 mov	 DWORD PTR [ebp], eax
  00407	75 16		 jne	 SHORT $L70320
$L71329:

; 1193 :   {
; 1194 :     PA_DestroyPlayHandle( pPlayAudio );

  00409	56		 push	 esi
  0040a	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  0040f	83 c4 04	 add	 esp, 4

; 1195 :     return MMSYSERR_NOMEM;

  00412	b8 07 00 00 00	 mov	 eax, 7
  00417	5f		 pop	 edi
  00418	5e		 pop	 esi
  00419	5d		 pop	 ebp
  0041a	5b		 pop	 ebx

; 1416 : }

  0041b	83 c4 18	 add	 esp, 24			; 00000018H
  0041e	c3		 ret	 0
$L70320:

; 1196 :   }
; 1197 : 
; 1198 :   /********************************************************************/
; 1199 :   /*  Initialize the audio queue buffer start and length.             */
; 1200 :   /********************************************************************/
; 1201 : 
; 1202 :   pPlayAudioRing->pQueueStart =
; 1203 :     pPlayAudioRing->pQueueTop + MAXIMUM_WRITE_LENGTH;

  0041f	05 00 40 00 00	 add	 eax, 16384		; 00004000H

; 1204 :   pPlayAudioRing->iQueueLength = AUDIO_BUFFER_SIZE;
; 1205 : 
; 1206 :   /********************************************************************/
; 1207 :   /*  Initialize the audio queue and the completion count.            */
; 1208 :   /********************************************************************/
; 1209 : 
; 1210 :   ResetAudioQueue( pPlayAudio );

  00424	56		 push	 esi
  00425	89 45 04	 mov	 DWORD PTR [ebp+4], eax
  00428	c7 45 1c 00 40
	02 00		 mov	 DWORD PTR [ebp+28], 147456 ; 00024000H
  0042f	e8 00 00 00 00	 call	 _ResetAudioQueue

; 1211 : 
; 1212 :   pPlayAudio->iSamplesWaitingForCompletion = 0;

  00434	89 7e 30	 mov	 DWORD PTR [esi+48], edi

; 1213 : 
; 1214 :   /********************************************************************/
; 1215 :   /*  If this is the first instance then create a message queue and   */
; 1216 :   /*  a "play audio" thread.                                          */
; 1217 :   /********************************************************************/
; 1218 : 
; 1219 :   if ( pShm_t->uiGlobalPlayAudioInstance == 1 )

  00437	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  0043c	83 c4 04	 add	 esp, 4
  0043f	83 38 01	 cmp	 DWORD PTR [eax], 1
  00442	0f 85 df 00 00
	00		 jne	 $L70321

; 1220 :   {
; 1221 :     /******************************************************************/
; 1222 :     /*  Create the "play audio" message queue.                        */
; 1223 :     /******************************************************************/
; 1224 : 
; 1225 :     pShm_t->pGlobalPlayAudioMessageQueue = CreateMessageQueue( MESSAGE_QUEUE_LENGTH );

  00448	68 00 01 00 00	 push	 256			; 00000100H
  0044d	e8 00 00 00 00	 call	 _CreateMessageQueue
  00452	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t
  00458	83 c4 04	 add	 esp, 4
  0045b	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1226 : 
; 1227 :     if ( pShm_t->pGlobalPlayAudioMessageQueue == NULL )

  0045e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  00464	39 7a 14	 cmp	 DWORD PTR [edx+20], edi
  00467	75 16		 jne	 SHORT $L70323

; 1228 :     {
; 1229 :       PA_DestroyPlayHandle( pPlayAudio );

  00469	56		 push	 esi
  0046a	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  0046f	83 c4 04	 add	 esp, 4

; 1230 :       return MMSYSERR_ERROR;

  00472	b8 01 00 00 00	 mov	 eax, 1
  00477	5f		 pop	 edi
  00478	5e		 pop	 esi
  00479	5d		 pop	 ebp
  0047a	5b		 pop	 ebx

; 1416 : }

  0047b	83 c4 18	 add	 esp, 24			; 00000018H
  0047e	c3		 ret	 0
$L70323:

; 1231 :     }
; 1232 : 
; 1233 :     /******************************************************************/
; 1234 :     /*  Create the "report" message queue.                            */
; 1235 :     /******************************************************************/
; 1236 : 
; 1237 :     pShm_t->pGlobalReportMessageQueue = CreateMessageQueue( 1 );

  0047f	6a 01		 push	 1
  00481	e8 00 00 00 00	 call	 _CreateMessageQueue
  00486	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t
  0048c	83 c4 04	 add	 esp, 4
  0048f	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 1238 : 
; 1239 :     if ( pShm_t->pGlobalReportMessageQueue == NULL )

  00492	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  00498	39 7a 10	 cmp	 DWORD PTR [edx+16], edi
  0049b	75 16		 jne	 SHORT $L70325

; 1240 :     {
; 1241 :       PA_DestroyPlayHandle( pPlayAudio );

  0049d	56		 push	 esi
  0049e	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  004a3	83 c4 04	 add	 esp, 4

; 1242 :       return MMSYSERR_ERROR;

  004a6	b8 01 00 00 00	 mov	 eax, 1
  004ab	5f		 pop	 edi
  004ac	5e		 pop	 esi
  004ad	5d		 pop	 ebp
  004ae	5b		 pop	 ebx

; 1416 : }

  004af	83 c4 18	 add	 esp, 24			; 00000018H
  004b2	c3		 ret	 0
$L70325:

; 1243 :     }
; 1244 : 
; 1245 :     /******************************************************************/
; 1246 :     /*  Create the global "Send Play Audio" mutex.                    */
; 1247 :     /******************************************************************/
; 1248 : 
; 1249 :     pShm_t->hmxGlobalSendPlayAudio = OP_CreateMutex();

  004b3	e8 00 00 00 00	 call	 _OP_CreateMutex
  004b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t

; 1250 : 
; 1251 :     if ( pShm_t->hmxGlobalSendPlayAudio == NULL )
; 1252 :     {
; 1253 :       PA_DestroyPlayHandle( pPlayAudio );

  004be	56		 push	 esi
  004bf	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  004c2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  004c8	39 7a 0c	 cmp	 DWORD PTR [edx+12], edi
  004cb	75 15		 jne	 SHORT $L70327
  004cd	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  004d2	83 c4 04	 add	 esp, 4

; 1254 :       return MMSYSERR_ERROR;

  004d5	b8 01 00 00 00	 mov	 eax, 1
  004da	5f		 pop	 edi
  004db	5e		 pop	 esi
  004dc	5d		 pop	 ebp
  004dd	5b		 pop	 ebx

; 1416 : }

  004de	83 c4 18	 add	 esp, 24			; 00000018H
  004e1	c3		 ret	 0
$L70327:

; 1255 :     }
; 1256 : 
; 1257 :     /******************************************************************/
; 1258 :     /*  Create the play audio thread.                                 */
; 1259 :     /******************************************************************/
; 1260 : 
; 1261 :     pShm_t->hGlobalPlayAudioThread =
; 1262 :               OP_CreateThread( 0,
; 1263 :                                (THREAD_PROCEDURE_T)PlayAudioThreadMain,
; 1264 :                                pPlayAudio );

  004e2	68 00 00 00 00	 push	 OFFSET FLAT:_PlayAudioThreadMain
  004e7	57		 push	 edi
  004e8	e8 00 00 00 00	 call	 _OP_CreateThread
  004ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t
  004f3	83 c4 0c	 add	 esp, 12			; 0000000cH
  004f6	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1265 : 
; 1266 :     if ( pShm_t->hGlobalPlayAudioThread == NULL )

  004f9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  004ff	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00502	3b c7		 cmp	 eax, edi
  00504	75 16		 jne	 SHORT $L70330

; 1267 :     {
; 1268 :       PA_DestroyPlayHandle( pPlayAudio );

  00506	56		 push	 esi
  00507	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  0050c	83 c4 04	 add	 esp, 4

; 1269 :       return MMSYSERR_ERROR;

  0050f	b8 01 00 00 00	 mov	 eax, 1
  00514	5f		 pop	 edi
  00515	5e		 pop	 esi
  00516	5d		 pop	 ebp
  00517	5b		 pop	 ebx

; 1416 : }

  00518	83 c4 18	 add	 esp, 24			; 00000018H
  0051b	c3		 ret	 0
$L70330:

; 1270 :     }
; 1271 : 
; 1272 :     OP_SetThreadPriority( pShm_t->hGlobalPlayAudioThread, OP_PRIORITY_HIGHEST );

  0051c	6a 02		 push	 2
  0051e	50		 push	 eax
  0051f	e8 00 00 00 00	 call	 _OP_SetThreadPriority
  00524	83 c4 08	 add	 esp, 8
$L70321:

; 1273 : 
; 1274 : #ifdef USE_MME_SERVER
; 1275 : 
; 1276 :     /******************************************************************/
; 1277 :     /*  Create the MME callback thread.                               */
; 1278 :     /******************************************************************/
; 1279 : 
; 1280 :     pShm_t->bGlobalMmeCallbackExit = FALSE;
; 1281 : 
; 1282 :     pShm_t->hGlobalMmeCallbackThread =
; 1283 :             OP_CreateThread( 0,
; 1284 :                              (THREAD_PROCEDURE_T)MmeCallbackThreadMain,
; 1285 :                              pPlayAudio );
; 1286 : 
; 1287 : /* TQL 05/21/1997  change this for OSF build */
; 1288 : #ifdef WIN32
; 1289 :     if ( pShm_t->hGlobalPlayAudioThread == NULL )
; 1290 : #endif
; 1291 : #ifdef __osf__
; 1292 :     if ( pShm_t->hGlobalMmeCallbackThread == NULL )
; 1293 : #endif
; 1294 :     {
; 1295 :       PA_DestroyPlayHandle( pPlayAudio );
; 1296 :       return MMSYSERR_ERROR;
; 1297 :     }
; 1298 : 
; 1299 : #endif
; 1300 : 
; 1301 :   }
; 1302 :   // tek 30sep96 move this thread creation up here (BATS 136)
; 1303 :   /********************************************************************/
; 1304 :   /*  Create the Timer Thread.                                        */
; 1305 :   /********************************************************************/
; 1306 : 
; 1307 :   pPlayAudio->hTimerThread =
; 1308 :                   OP_CreateThread( 0,
; 1309 :                                    (THREAD_PROCEDURE_T)TimerThreadMain,
; 1310 :                                    pPlayAudio );

  00527	56		 push	 esi
  00528	68 00 00 00 00	 push	 OFFSET FLAT:_TimerThreadMain
  0052d	57		 push	 edi
  0052e	e8 00 00 00 00	 call	 _OP_CreateThread
  00533	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1311 : 
; 1312 :   if ( pPlayAudio->hTimerThread == NULL )

  00536	3b c7		 cmp	 eax, edi
  00538	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0053b	75 16		 jne	 SHORT $L70333

; 1313 :   {
; 1314 :     PA_DestroyPlayHandle( pPlayAudio );

  0053d	56		 push	 esi
  0053e	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00543	83 c4 04	 add	 esp, 4

; 1315 :     return MMSYSERR_ERROR;

  00546	b8 01 00 00 00	 mov	 eax, 1
  0054b	5f		 pop	 edi
  0054c	5e		 pop	 esi
  0054d	5d		 pop	 ebp
  0054e	5b		 pop	 ebx

; 1416 : }

  0054f	83 c4 18	 add	 esp, 24			; 00000018H
  00552	c3		 ret	 0
$L70333:

; 1316 :   }
; 1317 : 
; 1318 :   /********************************************************************/
; 1319 :   /*  Selected a device ID into the "play audio" handle.              */
; 1320 :   /********************************************************************/
; 1321 : 
; 1322 :   if ( uiWaveOutDeviceID == (unsigned int)WAVE_MAPPER )

  00553	8b 44 24 30	 mov	 eax, DWORD PTR _uiWaveOutDeviceID$[esp+36]
  00557	83 f8 ff	 cmp	 eax, -1
  0055a	75 2e		 jne	 SHORT $L70336

; 1323 :   {
; 1324 : #ifdef AUD_DEBUG
; 1325 : 	OutputDebugString("PA_: device is WAVE_MAPPER\n");
; 1326 : #endif
; 1327 :     mmStatus = DetermineDeviceID( pPlayAudio,
; 1328 :                                   uiNumberOfWaveOutDevices,
; 1329 :                                   pPlayAudio->pWaveFormat );

  0055c	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  00562	8b 4c 24 10	 mov	 ecx, DWORD PTR _uiNumberOfWaveOutDevices$[esp+40]
  00566	50		 push	 eax
  00567	51		 push	 ecx
  00568	56		 push	 esi
  00569	e8 00 00 00 00	 call	 _DetermineDeviceID
  0056e	8b e8		 mov	 ebp, eax
  00570	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1330 :     if ( mmStatus )

  00573	3b ef		 cmp	 ebp, edi
  00575	74 45		 je	 SHORT $L70339

; 1331 :     {
; 1332 : #ifdef AUD_DEBUG
; 1333 : 	  OutputDebugString("PA_: DetermineDeviceID failed\n");
; 1334 : #endif
; 1335 :       PA_DestroyPlayHandle( pPlayAudio );

  00577	56		 push	 esi
  00578	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  0057d	83 c4 04	 add	 esp, 4

; 1336 :       return mmStatus;

  00580	8b c5		 mov	 eax, ebp
  00582	5f		 pop	 edi
  00583	5e		 pop	 esi
  00584	5d		 pop	 ebp
  00585	5b		 pop	 ebx

; 1416 : }

  00586	83 c4 18	 add	 esp, 24			; 00000018H
  00589	c3		 ret	 0
$L70336:

; 1337 :     }
; 1338 :   }
; 1339 :   else
; 1340 :   {
; 1341 : #ifdef AUD_DEBUG
; 1342 :     {
; 1343 :       char  szTemp[256]="";
; 1344 :       sprintf(szTemp,"PA_: device is not WAVE_MAPPER, it is: %i\n"
; 1345 : 	      ,uiWaveOutDeviceID);
; 1346 :       OutputDebugString(szTemp);
; 1347 :     }
; 1348 : #endif
; 1349 :     pPlayAudio->uiSelectedDeviceID = uiWaveOutDeviceID;
; 1350 : 
; 1351 :     mmStatus = PA_SetFormat( pPlayAudio, pPlayAudio->pWaveFormat );

  0058a	8b 96 9c 00 00
	00		 mov	 edx, DWORD PTR [esi+156]
  00590	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00593	52		 push	 edx
  00594	56		 push	 esi
  00595	e8 00 00 00 00	 call	 _PA_SetFormat
  0059a	83 c4 08	 add	 esp, 8

; 1352 : 
; 1353 :     if (( mmStatus != MMSYSERR_NOERROR )
; 1354 :       && ( mmStatus != MMSYSERR_ALLOCATED ))

  0059d	3b c7		 cmp	 eax, edi
  0059f	74 1b		 je	 SHORT $L70339
  005a1	83 f8 04	 cmp	 eax, 4
  005a4	74 16		 je	 SHORT $L70339

; 1355 :     {
; 1356 : #ifdef AUD_DEBUG
; 1357 : 	  OutputDebugString("PA_: PA_SetFormat failed\n");
; 1358 : #endif
; 1359 :       PA_DestroyPlayHandle( pPlayAudio );

  005a6	56		 push	 esi
  005a7	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  005ac	83 c4 04	 add	 esp, 4

; 1360 :       return MMSYSERR_NOTSUPPORTED;

  005af	b8 08 00 00 00	 mov	 eax, 8
  005b4	5f		 pop	 edi
  005b5	5e		 pop	 esi
  005b6	5d		 pop	 ebp
  005b7	5b		 pop	 ebx

; 1416 : }

  005b8	83 c4 18	 add	 esp, 24			; 00000018H
  005bb	c3		 ret	 0
$L70339:

; 1361 :     }
; 1362 :   }
; 1363 : 
; 1364 :   /********************************************************************/
; 1365 :   /*  Set the dwDeviceSupport member of the play audio handle         */
; 1366 :   /*  pointed to by "pPlayAudio" to the dwSupport field of the        */
; 1367 :   /*  WAVEOUTCAPS structure. The device ID is specified by the        */
; 1368 :   /*  uiSelectedDeviceID field of the play audio handle.              */
; 1369 :   /********************************************************************/
; 1370 : 
; 1371 :   if ( pPlayAudio->uiSelectedDeviceID != (unsigned int)WAVE_MAPPER )

  005bc	83 7e 20 ff	 cmp	 DWORD PTR [esi+32], -1
  005c0	74 22		 je	 SHORT $L70343

; 1372 :   {
; 1373 :     mmStatus = GetWaveOutDeviceCaps( pPlayAudio );

  005c2	56		 push	 esi
  005c3	e8 00 00 00 00	 call	 _GetWaveOutDeviceCaps
  005c8	8b e8		 mov	 ebp, eax
  005ca	83 c4 04	 add	 esp, 4

; 1374 : 
; 1375 :     if ( mmStatus )

  005cd	3b ef		 cmp	 ebp, edi
  005cf	74 13		 je	 SHORT $L70343

; 1376 :     {
; 1377 : #ifdef AUD_DEBUG
; 1378 : 	  OutputDebugString("PA_: GetWaveOutDeviceCaps failed\n");
; 1379 : #endif
; 1380 :       PA_DestroyPlayHandle( pPlayAudio );

  005d1	56		 push	 esi
  005d2	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  005d7	83 c4 04	 add	 esp, 4

; 1381 :       return mmStatus;

  005da	8b c5		 mov	 eax, ebp
  005dc	5f		 pop	 edi
  005dd	5e		 pop	 esi
  005de	5d		 pop	 ebp
  005df	5b		 pop	 ebx

; 1416 : }

  005e0	83 c4 18	 add	 esp, 24			; 00000018H
  005e3	c3		 ret	 0
$L70343:

; 1382 :     }
; 1383 :   }
; 1384 : 
; 1385 :   /********************************************************************/
; 1386 :   /*  If the application will own the audio device then try to open   */
; 1387 :   /*  it now.                                                         */
; 1388 :   /********************************************************************/
; 1389 : 
; 1390 :   if ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )

  005e4	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  005e8	74 26		 je	 SHORT $L70345

; 1391 :   {
; 1392 :     if ( SendPlayAudioMessage( pPlayAudio,
; 1393 :                                ID_Open_Wave_Output_Device,
; 1394 :                                0L ) == MMSYSERR_NOTSUPPORTED )

  005ea	57		 push	 edi
  005eb	57		 push	 edi
  005ec	56		 push	 esi
  005ed	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  005f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  005f5	83 f8 08	 cmp	 eax, 8
  005f8	75 16		 jne	 SHORT $L70345

; 1395 :     {
; 1396 : #ifdef AUD_DEBUG
; 1397 : 	  OutputDebugString("PA_: SendPlayAudioMessage failed\n");
; 1398 : #endif
; 1399 : 	  PA_DestroyPlayHandle( pPlayAudio );

  005fa	56		 push	 esi
  005fb	e8 00 00 00 00	 call	 _PA_DestroyPlayHandle
  00600	83 c4 04	 add	 esp, 4

; 1400 :       return MMSYSERR_NOTSUPPORTED;

  00603	b8 08 00 00 00	 mov	 eax, 8
  00608	5f		 pop	 edi
  00609	5e		 pop	 esi
  0060a	5d		 pop	 ebp
  0060b	5b		 pop	 ebx

; 1416 : }

  0060c	83 c4 18	 add	 esp, 24			; 00000018H
  0060f	c3		 ret	 0
$L70345:

; 1401 :     }
; 1402 :   }
; 1403 : 
; 1404 :   /********************************************************************/
; 1405 :   /*  Pass the play audio handle back to the application.             */
; 1406 :   /********************************************************************/
; 1407 : 
; 1408 :   pPlayAudio->bHandleValid = TRUE;
; 1409 : 
; 1410 :   *ppPlayAudio = pPlayAudio;

  00610	8b 44 24 2c	 mov	 eax, DWORD PTR _ppPlayAudio$[esp+36]
  00614	c7 46 64 01 00
	00 00		 mov	 DWORD PTR [esi+100], 1
  0061b	5f		 pop	 edi
  0061c	89 30		 mov	 DWORD PTR [eax], esi
  0061e	5e		 pop	 esi
  0061f	5d		 pop	 ebp

; 1411 : 
; 1412 : #ifdef AUD_DEBUG
; 1413 :   OutputDebugString("PA_: Successful exit.\n");
; 1414 : #endif
; 1415 :   return MMSYSERR_NOERROR;

  00620	33 c0		 xor	 eax, eax
  00622	5b		 pop	 ebx

; 1416 : }

  00623	83 c4 18	 add	 esp, 24			; 00000018H
  00626	c3		 ret	 0
_PA_CreatePlayHandleEx ENDP
_TEXT	ENDS
PUBLIC	_PA_DestroyPlayHandleEx
_TEXT	SEGMENT
_pPlayAudio$ = 8
_PA_DestroyPlayHandle PROC NEAR

; 1452 : {

  00630	56		 push	 esi

; 1453 : 
; 1454 : 	MMRESULT mmResult=MMSYSERR_ERROR; // the default error
; 1455 : 	BOOL bGotLock=FALSE;	// whether we got the lock
; 1456 : 
; 1457 : 	// try to gain control of the resources
; 1458 : 	bGotLock = ThreadLock(&tlPlayAudio,5);

  00631	6a 05		 push	 5
  00633	68 00 00 00 00	 push	 OFFSET FLAT:_tlPlayAudio
  00638	be 01 00 00 00	 mov	 esi, 1
  0063d	e8 00 00 00 00	 call	 _ThreadLock
  00642	83 c4 08	 add	 esp, 8

; 1459 : 	if (bGotLock)

  00645	85 c0		 test	 eax, eax
  00647	74 19		 je	 SHORT $L71334

; 1460 : 	{	// do the actual call..
; 1461 : 		mmResult = PA_DestroyPlayHandleEx( pPlayAudio );

  00649	8b 44 24 08	 mov	 eax, DWORD PTR _pPlayAudio$[esp]
  0064d	50		 push	 eax
  0064e	e8 00 00 00 00	 call	 _PA_DestroyPlayHandleEx

; 1462 : 		// unlock the resources
; 1463 : 		ThreadUnlock(&tlPlayAudio);

  00653	68 00 00 00 00	 push	 OFFSET FLAT:_tlPlayAudio
  00658	8b f0		 mov	 esi, eax
  0065a	e8 00 00 00 00	 call	 _ThreadUnlock
  0065f	83 c4 08	 add	 esp, 8
$L71334:

; 1464 : 	}
; 1465 : 	// return our result
; 1466 : 	return (mmResult);

  00662	8b c6		 mov	 eax, esi
  00664	5e		 pop	 esi

; 1467 : }

  00665	c3		 ret	 0
_PA_DestroyPlayHandle ENDP
_TEXT	ENDS
PUBLIC	_PA_Reset
EXTRN	__imp__free:NEAR
EXTRN	__imp__waveOutClose@4:NEAR
EXTRN	_OP_WaitForThreadTermination:NEAR
EXTRN	_OP_DestroyMutex:NEAR
EXTRN	_OP_LockMutex:NEAR
EXTRN	_OP_UnlockMutex:NEAR
EXTRN	_OP_DestroyEvent:NEAR
EXTRN	_OP_SetEvent:NEAR
EXTRN	_OP_ResetEvent:NEAR
EXTRN	_OP_WaitForEvent:NEAR
EXTRN	_freeLock:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_ThreadStatus$ = -4
_PA_DestroyPlayHandleEx PROC NEAR

; 1471 : {

  00670	51		 push	 ecx

; 1472 :   unsigned int uiI;
; 1473 :   MMRESULT mmStatus;
; 1474 :   THREAD_STATUS_T ThreadStatus;
; 1475 :   LPPLAY_RING_T pPlayAudioRing;
; 1476 :   
; 1477 :   /********************************************************************/
; 1478 :   /*  Decrement the play audio instance count.                        */
; 1479 :   /********************************************************************/
; 1480 :   
; 1481 :   pShm_t->uiGlobalPlayAudioInstance--;

  00671	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  00676	55		 push	 ebp
  00677	56		 push	 esi

; 1482 :   
; 1483 :   /********************************************************************/
; 1484 :   /*  Destroy the play audio handle.                                  */
; 1485 :   /********************************************************************/
; 1486 :   
; 1487 :   if ( pPlayAudio != NULL )

  00678	8b 74 24 10	 mov	 esi, DWORD PTR _pPlayAudio$[esp+8]
  0067c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0067e	33 ed		 xor	 ebp, ebp
  00680	49		 dec	 ecx
  00681	3b f5		 cmp	 esi, ebp
  00683	89 08		 mov	 DWORD PTR [eax], ecx
  00685	0f 84 09 02 00
	00		 je	 $L70363

; 1488 :     {
; 1489 :       /******************************************************************/
; 1490 :       /*  If the audio system is playing then a reset is necessary      */
; 1491 :       /*  before shutting down.                                         */
; 1492 :       /******************************************************************/
; 1493 :       
; 1494 :       if ( pPlayAudio->bHandleValid )

  0068b	8b 46 64	 mov	 eax, DWORD PTR [esi+100]
  0068e	53		 push	 ebx
  0068f	3b c5		 cmp	 eax, ebp
  00691	bb 01 00 00 00	 mov	 ebx, 1
  00696	74 37		 je	 SHORT $L70365

; 1495 : 	{
; 1496 : 	  PA_Reset( pPlayAudio );

  00698	56		 push	 esi
  00699	e8 00 00 00 00	 call	 _PA_Reset

; 1497 : 	  
; 1498 : 	  /****************************************************************/
; 1499 : 	  /*  The audio system has already been reset so we can close the */
; 1500 : 	  /*  wave output device here.                                    */
; 1501 : 	  /****************************************************************/
; 1502 : 	  
; 1503 : 	  pPlayAudio->bReportPlayStop = FALSE;
; 1504 : 	  
; 1505 : 	  OP_ResetEvent( pPlayAudio->hevAudioDeviceInactive );

  0069e	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  006a1	89 6e 60	 mov	 DWORD PTR [esi+96], ebp
  006a4	50		 push	 eax
  006a5	e8 00 00 00 00	 call	 _OP_ResetEvent

; 1506 : 	  
; 1507 : 	  if ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )

  006aa	8a 46 3c	 mov	 al, BYTE PTR [esi+60]
  006ad	83 c4 08	 add	 esp, 8
  006b0	84 c3		 test	 al, bl
  006b2	74 1b		 je	 SHORT $L70365

; 1508 : 	    {
; 1509 : 	      LOCK_MME_CALL( waveOutClose( pPlayAudio->hWaveOut ))

  006b4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  006b7	51		 push	 ecx
  006b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutClose@4

; 1510 : 		
; 1511 : 		OP_WaitForEvent( pPlayAudio->hevAudioDeviceInactive,
; 1512 : 				 MAXIMUM_CLOSE_WAIT_IN_MSEC );

  006be	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  006c1	68 88 13 00 00	 push	 5000			; 00001388H
  006c6	52		 push	 edx
  006c7	e8 00 00 00 00	 call	 _OP_WaitForEvent
  006cc	83 c4 08	 add	 esp, 8
$L70365:

; 1513 : 	    }
; 1514 : 	}
; 1515 :       
; 1516 :       /******************************************************************/
; 1517 :       /*  Cause the timer thread to exit.                               */
; 1518 :       /*  The only place in the code where the hevTimerThreadActive     */
; 1519 :       /*  event is reset is locked by the synchronization mark mutex so */
; 1520 :       /*  we use that also to lock the thread exit flag. Since this is  */
; 1521 :       /*  only used for shutdown, it seemed unnecessary to create       */
; 1522 :       /*  an additional mutex.                                          */
; 1523 :       /******************************************************************/
; 1524 :       
; 1525 :       if ( pPlayAudio->hTimerThread != NULL )

  006cf	39 6e 0c	 cmp	 DWORD PTR [esi+12], ebp
  006d2	74 3f		 je	 SHORT $L70367

; 1526 : 	{
; 1527 : 	  OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  006d4	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  006da	50		 push	 eax
  006db	e8 00 00 00 00	 call	 _OP_LockMutex

; 1528 : 	  pPlayAudio->bTimerExit = TRUE;
; 1529 : 	  OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  006e0	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  006e6	89 5e 54	 mov	 DWORD PTR [esi+84], ebx
  006e9	51		 push	 ecx
  006ea	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 1530 : 	  
; 1531 : 	  if ( pPlayAudio->hevTimerThreadActive != NULL )

  006ef	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  006f2	83 c4 08	 add	 esp, 8
  006f5	3b c5		 cmp	 eax, ebp
  006f7	74 09		 je	 SHORT $L70369

; 1532 : 	    {
; 1533 : 	      OP_SetEvent( pPlayAudio->hevTimerThreadActive );

  006f9	50		 push	 eax
  006fa	e8 00 00 00 00	 call	 _OP_SetEvent
  006ff	83 c4 04	 add	 esp, 4
$L70369:

; 1534 : 	    }
; 1535 : 	  /* TQL 05/21/1997  change this for OSF build */  
; 1536 : 	  OP_WaitForThreadTermination( pPlayAudio->hTimerThread,
; 1537 : #ifdef WIN32
; 1538 : 				       &ThreadStatus
; 1539 : #endif
; 1540 : #if defined __osf__ || defined __linux__
; 1541 : 	                               &ThreadStatus, OP_INFINITE
; 1542 : #endif
; 1543 : 				       );

  00702	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00705	8d 54 24 0c	 lea	 edx, DWORD PTR _ThreadStatus$[esp+16]
  00709	52		 push	 edx
  0070a	50		 push	 eax
  0070b	e8 00 00 00 00	 call	 _OP_WaitForThreadTermination
  00710	83 c4 08	 add	 esp, 8
$L70367:

; 1544 :         }
; 1545 :       
; 1546 : #ifdef OS_SIXTY_FOUR_BIT
; 1547 :       
; 1548 :       /******************************************************************/
; 1549 :       /*  Set the instance location in the global audio handle array    */
; 1550 :       /*  to NULL.                                                      */
; 1551 :       /******************************************************************/
; 1552 :       
; 1553 :       uiI = pPlayAudio->uiHandleListIndex;
; 1554 :       
; 1555 :       if ( uiI != (unsigned int)(-1))
; 1556 : 	{
; 1557 : 	  pShm_t->ppGlobalHandleList[uiI] = pPlayAudio;
; 1558 : 	}
; 1559 :       
; 1560 : #endif
; 1561 :       
; 1562 :       /******************************************************************/
; 1563 :       /*  If there are no more "play audio" instances then destroy the  */
; 1564 :       /*  "play audio" thread and the message queue.                    */
; 1565 :       /******************************************************************/
; 1566 :       
; 1567 :       if ( pShm_t->uiGlobalPlayAudioInstance == 0 )

  00713	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  00718	39 28		 cmp	 DWORD PTR [eax], ebp
  0071a	75 7c		 jne	 SHORT $L70378

; 1568 : 	{
; 1569 : 	  
; 1570 : #ifdef USE_MME_SERVER
; 1571 : 	  
; 1572 : 	  /****************************************************************/
; 1573 : 	  /*  Destroy the MME callback thread.                            */
; 1574 : 	  /****************************************************************/
; 1575 : 	  
; 1576 : 	  if ( pShm_t->hGlobalMmeCallbackThread != NULL )
; 1577 : 	    {
; 1578 : 	      pShm_t->bGlobalMmeCallbackExit = TRUE;
; 1579 : 	      
; 1580 : 	      OP_WaitForThreadTermination( pShm_t->hGlobalMmeCallbackThread,
; 1581 : 					   /* TQL 05/21/1997  change this for OSF build */
; 1582 : #ifdef WIN32
; 1583 : 					   &ThreadStatus
; 1584 : #endif
; 1585 : #ifdef __osf__
; 1586 : 					   &ThreadStatus, OP_INFINITE
; 1587 : #endif
; 1588 : 					   );
; 1589 : 	      pShm_t->hGlobalMmeCallbackThread = NULL;
; 1590 : 	    }
; 1591 : 	  
; 1592 : #endif
; 1593 : 	  
; 1594 : 	  /****************************************************************/
; 1595 : 	  /*  Destroy the play audio thread.                              */
; 1596 : 	  /****************************************************************/
; 1597 : 	  
; 1598 : 	  if ( pShm_t->hGlobalPlayAudioThread != NULL ) {

  0071c	39 68 08	 cmp	 DWORD PTR [eax+8], ebp
  0071f	74 2e		 je	 SHORT $L70372

; 1599 : 	    SendPlayAudioMessage( pPlayAudio, ID_Destroy_Message, 0 );

  00721	55		 push	 ebp
  00722	6a 0a		 push	 10			; 0000000aH
  00724	56		 push	 esi
  00725	e8 00 00 00 00	 call	 _SendPlayAudioMessage

; 1600 : 	    
; 1601 : 	    OP_WaitForThreadTermination( pShm_t->hGlobalPlayAudioThread,
; 1602 : #ifdef WIN32
; 1603 : 					 &ThreadStatus
; 1604 : #endif
; 1605 : #if defined __osf__ || defined __linux__
; 1606 : 					 &ThreadStatus, OP_INFINITE
; 1607 : #endif
; 1608 : 					 );

  0072a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  00730	8d 4c 24 18	 lea	 ecx, DWORD PTR _ThreadStatus$[esp+28]
  00734	51		 push	 ecx
  00735	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00738	50		 push	 eax
  00739	e8 00 00 00 00	 call	 _OP_WaitForThreadTermination

; 1609 : 	    pShm_t->hGlobalPlayAudioThread = NULL;

  0073e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t
  00744	83 c4 14	 add	 esp, 20			; 00000014H
  00747	89 69 08	 mov	 DWORD PTR [ecx+8], ebp
  0074a	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
$L70372:

; 1610 : 	  }
; 1611 : 	  
; 1612 : 	  /****************************************************************/
; 1613 : 	  /*  Destroy the "Play Audio" message queue.                     */
; 1614 : 	  /****************************************************************/
; 1615 : 	  
; 1616 : 	  if ( pShm_t->pGlobalPlayAudioMessageQueue != NULL )

  0074f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00752	3b cd		 cmp	 ecx, ebp
  00754	74 17		 je	 SHORT $L70375

; 1617 : 	    {
; 1618 : 	      DestroyMessageQueue( pShm_t->pGlobalPlayAudioMessageQueue );

  00756	51		 push	 ecx
  00757	e8 00 00 00 00	 call	 _DestroyMessageQueue

; 1619 : 	      pShm_t->pGlobalPlayAudioMessageQueue = NULL;

  0075c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  00762	83 c4 04	 add	 esp, 4
  00765	89 6a 14	 mov	 DWORD PTR [edx+20], ebp
  00768	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
$L70375:

; 1620 : 	    }
; 1621 : 	  
; 1622 : 	  /****************************************************************/
; 1623 : 	  /*  Destroy the "Send Play Audio" mutex.                        */
; 1624 : 	  /****************************************************************/
; 1625 : 	  
; 1626 : 	  OP_DestroyMutex( pShm_t->hmxGlobalSendPlayAudio );

  0076d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00770	50		 push	 eax
  00771	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1627 : 	  
; 1628 : 	  /****************************************************************/
; 1629 : 	  /*  Destroy the "Report" message queue.                         */
; 1630 : 	  /****************************************************************/
; 1631 : 	  
; 1632 : 	  if ( pShm_t->pGlobalReportMessageQueue != NULL )

  00776	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t
  0077c	83 c4 04	 add	 esp, 4
  0077f	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00782	3b c5		 cmp	 eax, ebp
  00784	74 12		 je	 SHORT $L70378

; 1633 : 	    {
; 1634 : 	      DestroyMessageQueue( pShm_t->pGlobalReportMessageQueue );

  00786	50		 push	 eax
  00787	e8 00 00 00 00	 call	 _DestroyMessageQueue

; 1635 : 	      pShm_t->pGlobalReportMessageQueue = NULL;

  0078c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  00792	83 c4 04	 add	 esp, 4
  00795	89 6a 10	 mov	 DWORD PTR [edx+16], ebp
$L70378:

; 1636 : 	    }
; 1637 : 	  
; 1638 : #ifdef OS_SIXTY_FOUR_BIT
; 1639 : 	  
; 1640 : 	  /****************************************************************/
; 1641 : 	  /*  Free the global "play audio" handle list.                   */
; 1642 : 	  /****************************************************************/
; 1643 : 	  
; 1644 : 	  if ( pShm_t->ppGlobalHandleList != NULL )
; 1645 : 	    {
; 1646 : 	      free( pShm_t->ppGlobalHandleList );
; 1647 : 	      pShm_t->ppGlobalHandleList = NULL;
; 1648 : 	    }
; 1649 : 	  
; 1650 : 	  pShm_t->uiGlobalHandleListLength = 0;
; 1651 : 	  
; 1652 : 	  /****************************************************************/
; 1653 : 	  /*  Destroy the "Handle List" mutex.                            */
; 1654 : 	  /****************************************************************/
; 1655 : 	  
; 1656 : 	  OP_DestroyMutex( pShm_t->hmxGlobalHandleList );
; 1657 : 	  
; 1658 : #endif
; 1659 : 	  
; 1660 : 	}
; 1661 :       
; 1662 :       /******************************************************************/
; 1663 :       /*  Free the Audio Queue memory.                                  */
; 1664 :       /******************************************************************/
; 1665 :       
; 1666 :       pPlayAudioRing = pPlayAudio->pPlayAudioRing;
; 1667 :       
; 1668 :       if ( pPlayAudioRing != NULL )

  00798	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__free
  0079e	57		 push	 edi
  0079f	8b be 94 00 00
	00		 mov	 edi, DWORD PTR [esi+148]
  007a5	3b fd		 cmp	 edi, ebp
  007a7	74 15		 je	 SHORT $L70381

; 1669 : 	{
; 1670 : 	  /****************************************************************/
; 1671 : 	  /*  Free Memory for the Audio Queue sample buffer.              */
; 1672 : 	  /****************************************************************/
; 1673 : 	  
; 1674 : 	  if ( pPlayAudioRing->pQueueTop != NULL )

  007a9	8b 07		 mov	 eax, DWORD PTR [edi]
  007ab	3b c5		 cmp	 eax, ebp
  007ad	74 09		 je	 SHORT $L70383

; 1675 : 	    {
; 1676 : 	      LOCK_MME_CALL( FREE_SERVER_BUFFER( pPlayAudioRing->pQueueTop ))

  007af	50		 push	 eax
  007b0	e8 00 00 00 00	 call	 _freeLock
  007b5	83 c4 04	 add	 esp, 4
$L70383:

; 1677 : 		}
; 1678 : 	  
; 1679 : 	  /****************************************************************/
; 1680 : 	  /*  Free Memory for the Audio Queue Structure.                  */
; 1681 : 	  /****************************************************************/
; 1682 : 	  
; 1683 : 	  free( pPlayAudioRing );

  007b8	57		 push	 edi
  007b9	ff d3		 call	 ebx
  007bb	83 c4 04	 add	 esp, 4
$L70381:

; 1684 : 	}
; 1685 :       
; 1686 :       /******************************************************************/
; 1687 :       /*  Free Memory for Wave Headers.                                 */
; 1688 :       /******************************************************************/
; 1689 :       
; 1690 :       if ( pPlayAudio->ppWaveHdr != NULL )

  007be	39 ae 90 00 00
	00		 cmp	 DWORD PTR [esi+144], ebp
  007c4	74 2c		 je	 SHORT $L70385

; 1691 : 	{
; 1692 : 	  for ( uiI = 0; uiI < MAXIMUM_BUFFERS_QUEUED; uiI++ )

  007c6	33 ff		 xor	 edi, edi
$L70386:

; 1693 : 	    {
; 1694 : 	      if ( pPlayAudio->ppWaveHdr[uiI] != NULL )

  007c8	8b 86 90 00 00
	00		 mov	 eax, DWORD PTR [esi+144]
  007ce	8b 04 07	 mov	 eax, DWORD PTR [edi+eax]
  007d1	3b c5		 cmp	 eax, ebp
  007d3	74 09		 je	 SHORT $L70387

; 1695 : 		{
; 1696 : 		  LOCK_MME_CALL( FREE_LOCKED_MEMORY( pPlayAudio->ppWaveHdr[uiI] ))

  007d5	50		 push	 eax
  007d6	e8 00 00 00 00	 call	 _freeLock
  007db	83 c4 04	 add	 esp, 4
$L70387:
  007de	83 c7 04	 add	 edi, 4
  007e1	83 ff 20	 cmp	 edi, 32			; 00000020H
  007e4	7c e2		 jl	 SHORT $L70386

; 1697 : 		    }
; 1698 : 	    }
; 1699 : 	  
; 1700 : 	  /****************************************************************/
; 1701 : 	  /*  Free the Wave Header pointer array memory.                  */
; 1702 : 	  /****************************************************************/
; 1703 : 	  
; 1704 : 	  free( pPlayAudio->ppWaveHdr );

  007e6	8b 8e 90 00 00
	00		 mov	 ecx, DWORD PTR [esi+144]
  007ec	51		 push	 ecx
  007ed	ff d3		 call	 ebx
  007ef	83 c4 04	 add	 esp, 4
$L70385:

; 1705 : 	}
; 1706 :       
; 1707 :       /******************************************************************/
; 1708 :       /*  Destroy the "WaveFormat" mutex.                               */
; 1709 :       /******************************************************************/
; 1710 :       
; 1711 :       OP_DestroyMutex( pPlayAudio->hmxWaveFormat );

  007f2	8b 96 8c 00 00
	00		 mov	 edx, DWORD PTR [esi+140]
  007f8	52		 push	 edx
  007f9	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1712 :       
; 1713 :       /******************************************************************/
; 1714 :       /*  Destroy the "Synchronization Mark List" mutex.                */
; 1715 :       /******************************************************************/
; 1716 :       
; 1717 :       OP_DestroyMutex( pPlayAudio->hmxSynchronizationMarkList );

  007fe	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  00804	50		 push	 eax
  00805	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1718 :       
; 1719 :       /******************************************************************/
; 1720 :       /*  Destroy the ""Pause Flag" mutex.                              */
; 1721 :       /******************************************************************/
; 1722 :       
; 1723 :       OP_DestroyMutex( pPlayAudio->hmxPauseFlag );

  0080a	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  00810	51		 push	 ecx
  00811	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1724 :       
; 1725 :       /******************************************************************/
; 1726 :       /*  Destroy the "Queued Byte Count" mutex.                        */
; 1727 :       /******************************************************************/
; 1728 :       
; 1729 :       OP_DestroyMutex( pPlayAudio->hmxQueuedByteCount );

  00816	8b 96 80 00 00
	00		 mov	 edx, DWORD PTR [esi+128]
  0081c	52		 push	 edx
  0081d	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1730 :       
; 1731 :       /******************************************************************/
; 1732 :       /*  Destroy the "Queue Audio Busy" mutex.                         */
; 1733 :       /******************************************************************/
; 1734 :       
; 1735 :       OP_DestroyMutex( pPlayAudio->hmxQueueAudioBusy );

  00822	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  00825	50		 push	 eax
  00826	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1736 :       
; 1737 :       /******************************************************************/
; 1738 :       /*  Destroy the "Queue Count" mutex.                              */
; 1739 :       /******************************************************************/
; 1740 : 
; 1741 :     OP_DestroyMutex( pPlayAudio->hmxQueueCount );

  0082b	8b 4e 78	 mov	 ecx, DWORD PTR [esi+120]
  0082e	51		 push	 ecx
  0082f	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1742 : 
; 1743 :     /******************************************************************/
; 1744 :     /*  Destroy the "Selected Device ID" mutex.                       */
; 1745 :     /******************************************************************/
; 1746 : 
; 1747 :     OP_DestroyMutex( pPlayAudio->hmxSelectedDeviceID );

  00834	8b 56 74	 mov	 edx, DWORD PTR [esi+116]
  00837	52		 push	 edx
  00838	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1748 : 
; 1749 :     /******************************************************************/
; 1750 :     /*  Destroy the "Bytes Played" mutex.                             */
; 1751 :     /******************************************************************/
; 1752 : 
; 1753 :     OP_DestroyMutex( pPlayAudio->hmxBytesPlayed );

  0083d	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  00840	50		 push	 eax
  00841	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1754 : 
; 1755 :     /******************************************************************/
; 1756 :     /*  Destroy the "Audio Device State" mutex.                       */
; 1757 :     /******************************************************************/
; 1758 : 
; 1759 :     OP_DestroyMutex( pPlayAudio->hmxAudioDeviceState );

  00846	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  00849	51		 push	 ecx
  0084a	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 1760 : 
; 1761 :     /******************************************************************/
; 1762 :     /*  Destroy the "Reset Complete" event.                           */
; 1763 :     /******************************************************************/
; 1764 : 
; 1765 :     OP_DestroyEvent( pPlayAudio->hevResetComplete );

  0084f	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00852	52		 push	 edx
  00853	e8 00 00 00 00	 call	 _OP_DestroyEvent

; 1766 : 
; 1767 :     /******************************************************************/
; 1768 :     /*  Destroy the "Queue Not Full" event.                           */
; 1769 :     /******************************************************************/
; 1770 : 
; 1771 :     OP_DestroyEvent( pPlayAudio->hevQueueNotFull );

  00858	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0085b	50		 push	 eax
  0085c	e8 00 00 00 00	 call	 _OP_DestroyEvent

; 1772 : 
; 1773 :     /******************************************************************/
; 1774 :     /*  Destroy the "Timer Thread Active" event.                      */
; 1775 :     /******************************************************************/
; 1776 : 
; 1777 :     OP_DestroyEvent( pPlayAudio->hevTimerThreadActive );

  00861	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00864	51		 push	 ecx
  00865	e8 00 00 00 00	 call	 _OP_DestroyEvent

; 1778 : 
; 1779 :     /******************************************************************/
; 1780 :     /*  Destroy the "Audio Device Inactive" event.                    */
; 1781 :     /******************************************************************/
; 1782 : 
; 1783 :     OP_DestroyEvent( pPlayAudio->hevAudioDeviceInactive );

  0086a	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0086d	52		 push	 edx
  0086e	e8 00 00 00 00	 call	 _OP_DestroyEvent

; 1784 : 
; 1785 :     /******************************************************************/
; 1786 :     /*  Free the play audio handle WAVEFORMATEX structure.            */
; 1787 :     /******************************************************************/
; 1788 : 
; 1789 :     if ( pPlayAudio->pWaveFormat != NULL )

  00873	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  00879	83 c4 34	 add	 esp, 52			; 00000034H
  0087c	3b c5		 cmp	 eax, ebp
  0087e	5f		 pop	 edi
  0087f	74 06		 je	 SHORT $L70392

; 1790 :     {
; 1791 :       LOCK_MME_CALL( FREE_SERVER_MEM( pPlayAudio->pWaveFormat ))

  00881	50		 push	 eax
  00882	ff d3		 call	 ebx
  00884	83 c4 04	 add	 esp, 4
$L70392:

; 1792 :     }
; 1793 : 
; 1794 :     /******************************************************************/
; 1795 :     /*  Free the play audio handle.                                   */
; 1796 :     /******************************************************************/
; 1797 : 
; 1798 :     free( pPlayAudio );

  00887	56		 push	 esi
  00888	ff d3		 call	 ebx
  0088a	83 c4 04	 add	 esp, 4

; 1799 :     
; 1800 :     mmStatus = MMSYSERR_NOERROR;

  0088d	33 c0		 xor	 eax, eax
  0088f	5b		 pop	 ebx
  00890	5e		 pop	 esi
  00891	5d		 pop	 ebp

; 1805 :     }
; 1806 : 
; 1807 : #ifdef MME_THREAD_SAFE
; 1808 :   
; 1809 :   /********************************************************************/
; 1810 :   /*  If this is the last instance then destroy the global mutex that */
; 1811 :   /*  is used to protect MME server calls.                            */
; 1812 :   /********************************************************************/
; 1813 :   
; 1814 :   if ( pShm_t->uiGlobalPlayAudioInstance == 0 )
; 1815 :     {
; 1816 :       OP_DestroyMutex( pShm_t->hmxGlobalMmeServer );
; 1817 :     }
; 1818 :   
; 1819 : #endif
; 1820 : 
; 1821 :   return mmStatus;
; 1822 : }

  00892	59		 pop	 ecx
  00893	c3		 ret	 0
$L70363:
  00894	5e		 pop	 esi

; 1801 :     }
; 1802 :   else
; 1803 :     {
; 1804 :       mmStatus = MMSYSERR_INVALHANDLE;

  00895	b8 05 00 00 00	 mov	 eax, 5
  0089a	5d		 pop	 ebp

; 1805 :     }
; 1806 : 
; 1807 : #ifdef MME_THREAD_SAFE
; 1808 :   
; 1809 :   /********************************************************************/
; 1810 :   /*  If this is the last instance then destroy the global mutex that */
; 1811 :   /*  is used to protect MME server calls.                            */
; 1812 :   /********************************************************************/
; 1813 :   
; 1814 :   if ( pShm_t->uiGlobalPlayAudioInstance == 0 )
; 1815 :     {
; 1816 :       OP_DestroyMutex( pShm_t->hmxGlobalMmeServer );
; 1817 :     }
; 1818 :   
; 1819 : #endif
; 1820 : 
; 1821 :   return mmStatus;
; 1822 : }

  0089b	59		 pop	 ecx
  0089c	c3		 ret	 0
_PA_DestroyPlayHandleEx ENDP
_TEXT	ENDS
PUBLIC	_PA_Queue
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pBuffer$ = 12
_dwLength$ = 16
_PA_Queue PROC NEAR

; 1900 : {

  008a0	55		 push	 ebp

; 1901 :   DWORD dwWrap;
; 1902 :   DWORD dwRemaining;
; 1903 :   LPPLAY_RING_T pPlayAudioRing;
; 1904 : 
; 1905 : #ifdef __linux__
; 1906 :   struct timespec tv;
; 1907 : #endif
; 1908 : 
; 1909 : #ifdef AUD_DEBUG  // 13may97 tek 
; 1910 :   {
; 1911 : 		  char  szTemp[256]="";
; 1912 : 		  sprintf(szTemp,"PA_Queue: size=%lu at %lu\n",
; 1913 : 			  dwLength, timeGetTime());
; 1914 : 		  //OutputDebugString(szTemp); // tek 21nov97 make less verbose
; 1915 :   }
; 1916 : #endif //AUD_DEBUG
; 1917 : 
; 1918 :   /********************************************************************/
; 1919 :   /*  Return an error if NULL handle.                                 */
; 1920 :   /********************************************************************/
; 1921 : 
; 1922 :   if ( pPlayAudio == NULL )

  008a1	8b 6c 24 08	 mov	 ebp, DWORD PTR _pPlayAudio$[esp]
  008a5	85 ed		 test	 ebp, ebp
  008a7	56		 push	 esi
  008a8	75 08		 jne	 SHORT $L70405
  008aa	5e		 pop	 esi

; 1923 :     return MMSYSERR_INVALHANDLE;

  008ab	b8 05 00 00 00	 mov	 eax, 5
  008b0	5d		 pop	 ebp

; 2075 : }

  008b1	c3		 ret	 0
$L70405:

; 1924 : 
; 1925 :   /********************************************************************/
; 1926 :   /*  If too many samples then exit with error status.                */
; 1927 :   /********************************************************************/
; 1928 : 
; 1929 :   if ( dwLength > AUDIO_BUFFER_SIZE )

  008b2	8b 74 24 14	 mov	 esi, DWORD PTR _dwLength$[esp+4]
  008b6	81 fe 00 40 02
	00		 cmp	 esi, 147456		; 00024000H
  008bc	76 08		 jbe	 SHORT $L70406
  008be	5e		 pop	 esi

; 1930 :     return MMSYSERR_INVALPARAM;

  008bf	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  008c4	5d		 pop	 ebp

; 2075 : }

  008c5	c3		 ret	 0
$L70406:

; 1931 : 
; 1932 :   pPlayAudioRing = pPlayAudio->pPlayAudioRing;
; 1933 : 
; 1934 :   /********************************************************************/
; 1935 :   /*  Block if another thread is queueing audio or performing a       */
; 1936 :   /*  reset.                                                          */
; 1937 :   /********************************************************************/
; 1938 :   OP_LockMutex( pPlayAudio->hmxQueueAudioBusy );

  008c6	8b 45 7c	 mov	 eax, DWORD PTR [ebp+124]
  008c9	53		 push	 ebx
  008ca	8b 9d 94 00 00
	00		 mov	 ebx, DWORD PTR [ebp+148]
  008d0	50		 push	 eax
  008d1	e8 00 00 00 00	 call	 _OP_LockMutex

; 1939 : 
; 1940 :   /********************************************************************/
; 1941 :   /*  Wait for space in the queue before adding the new audio buffer. */
; 1942 :   /*  Block if another thread is manipulating the queue count.        */
; 1943 :   /********************************************************************/
; 1944 : 
; 1945 :   OP_LockMutex( pPlayAudio->hmxQueueCount );

  008d6	8b 4d 78	 mov	 ecx, DWORD PTR [ebp+120]
  008d9	51		 push	 ecx
  008da	e8 00 00 00 00	 call	 _OP_LockMutex

; 1946 : 
; 1947 :   while ( pPlayAudioRing->iQueueCount + (int)dwLength
; 1948 :             > pPlayAudioRing->iQueueLength )

  008df	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  008e2	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  008e5	03 d6		 add	 edx, esi
  008e7	83 c4 08	 add	 esp, 8
  008ea	3b d0		 cmp	 edx, eax
  008ec	7e 47		 jle	 SHORT $L70410
$L70409:

; 1949 :   {
; 1950 :     OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  008ee	8b 45 78	 mov	 eax, DWORD PTR [ebp+120]
  008f1	50		 push	 eax
  008f2	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 1951 :     OP_UnlockMutex( pPlayAudio->hmxQueueAudioBusy );

  008f7	8b 4d 7c	 mov	 ecx, DWORD PTR [ebp+124]
  008fa	51		 push	 ecx
  008fb	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 1952 : 
; 1953 :     OP_ResetEvent( pPlayAudio->hevQueueNotFull );

  00900	8b 55 18	 mov	 edx, DWORD PTR [ebp+24]
  00903	52		 push	 edx
  00904	e8 00 00 00 00	 call	 _OP_ResetEvent

; 1954 : 
; 1955 :     OP_WaitForEvent( pPlayAudio->hevQueueNotFull, OP_INFINITE );

  00909	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  0090c	6a ff		 push	 -1
  0090e	50		 push	 eax
  0090f	e8 00 00 00 00	 call	 _OP_WaitForEvent

; 1956 : #ifdef __linux__ 
; 1957 : //necessary for proper multithreading, this may be fixed in newer kernels
; 1958 :     tv.tv_sec=0;
; 1959 :     tv.tv_nsec=1;
; 1960 :     nanosleep(&tv,NULL);
; 1961 :     //usleep(1);
; 1962 : #endif
; 1963 :     OP_LockMutex( pPlayAudio->hmxQueueAudioBusy );

  00914	8b 4d 7c	 mov	 ecx, DWORD PTR [ebp+124]
  00917	51		 push	 ecx
  00918	e8 00 00 00 00	 call	 _OP_LockMutex

; 1964 :     OP_LockMutex( pPlayAudio->hmxQueueCount );

  0091d	8b 55 78	 mov	 edx, DWORD PTR [ebp+120]
  00920	52		 push	 edx
  00921	e8 00 00 00 00	 call	 _OP_LockMutex
  00926	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00929	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  0092c	03 c6		 add	 eax, esi
  0092e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00931	3b c1		 cmp	 eax, ecx
  00933	7f b9		 jg	 SHORT $L70409
$L70410:

; 1965 :   }
; 1966 : 
; 1967 :   OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  00935	8b 4d 78	 mov	 ecx, DWORD PTR [ebp+120]
  00938	57		 push	 edi
  00939	51		 push	 ecx
  0093a	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 1968 : 
; 1969 :   /********************************************************************/
; 1970 :   /*  There is enough space in the audio queue. Test to see if the    */
; 1971 :   /*  data will wrap around the circular queue.                       */
; 1972 :   /********************************************************************/
; 1973 : 
; 1974 :   if ( pPlayAudioRing->iInputPosition + (int)dwLength
; 1975 :          > pPlayAudioRing->iQueueLength )

  0093f	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  00942	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00945	83 c4 04	 add	 esp, 4
  00948	8d 14 31	 lea	 edx, DWORD PTR [ecx+esi]
  0094b	3b d0		 cmp	 edx, eax
  0094d	7e 48		 jle	 SHORT $L70412

; 1976 :   {
; 1977 :     /******************************************************************/
; 1978 :     /*  The data will wrap around the circular queue.                 */
; 1979 :     /******************************************************************/
; 1980 : 
; 1981 :     dwRemaining =
; 1982 :       pPlayAudioRing->iQueueLength - pPlayAudioRing->iInputPosition;
; 1983 : 
; 1984 :     /******************************************************************/
; 1985 :     /*  for ( uiI = 0; uiI < dwRemaining; uiI++ )                     */
; 1986 :     /*    *pPlayAudioRing->pQueueInput++ = *pBuffer++;                */
; 1987 :     /******************************************************************/
; 1988 : 
; 1989 :     memcpy( pPlayAudioRing->pQueueInput, pBuffer, dwRemaining );

  0094f	8b 74 24 18	 mov	 esi, DWORD PTR _pBuffer$[esp+12]
  00953	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  00956	2b c1		 sub	 eax, ecx
  00958	8b d0		 mov	 edx, eax
  0095a	8b ca		 mov	 ecx, edx
  0095c	c1 e9 02	 shr	 ecx, 2
  0095f	f3 a5		 rep movsd
  00961	8b c8		 mov	 ecx, eax

; 1990 : 
; 1991 :     pBuffer += dwRemaining;
; 1992 : 
; 1993 :     /******************************************************************/
; 1994 :     /*  Reset to the start of the audio queue.                        */
; 1995 :     /******************************************************************/
; 1996 : 
; 1997 :     pPlayAudioRing->pQueueInput = pPlayAudioRing->pQueueStart;
; 1998 : 
; 1999 :     /******************************************************************/
; 2000 :     /*  for ( uiI = dwRemaining; uiI < dwLength; uiI++ )              */
; 2001 :     /*    *pPlayAudioRing->pQueueInput++ = *pBuffer++;                */
; 2002 :     /******************************************************************/
; 2003 : 
; 2004 :     dwWrap = dwLength - dwRemaining;

  00963	8b 44 24 1c	 mov	 eax, DWORD PTR _dwLength$[esp+12]
  00967	83 e1 03	 and	 ecx, 3
  0096a	2b c2		 sub	 eax, edx
  0096c	f3 a4		 rep movsb
  0096e	8b 74 24 18	 mov	 esi, DWORD PTR _pBuffer$[esp+12]
  00972	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]

; 2005 : 
; 2006 :     memcpy( pPlayAudioRing->pQueueInput, pBuffer, dwWrap );

  00975	8b c8		 mov	 ecx, eax
  00977	03 f2		 add	 esi, edx
  00979	8b d1		 mov	 edx, ecx
  0097b	89 7b 08	 mov	 DWORD PTR [ebx+8], edi
  0097e	c1 e9 02	 shr	 ecx, 2
  00981	f3 a5		 rep movsd
  00983	8b ca		 mov	 ecx, edx
  00985	83 e1 03	 and	 ecx, 3
  00988	f3 a4		 rep movsb

; 2007 : 
; 2008 :     pPlayAudioRing->pQueueInput += dwWrap;

  0098a	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 2009 :     pPlayAudioRing->iInputPosition = (int)dwWrap;

  0098d	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  00990	03 c8		 add	 ecx, eax
  00992	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx

; 2010 :   }
; 2011 :   else

  00995	eb 2b		 jmp	 SHORT $L70414
$L70412:

; 2012 :   {
; 2013 :     /******************************************************************/
; 2014 :     /*  The data will NOT wrap around the circular queue.             */
; 2015 :     /******************************************************************/
; 2016 :     /******************************************************************/
; 2017 :     /*  for ( uiI = 0; uiI < dwLength; uiI++ )                        */
; 2018 :     /*    *pPlayAudioRing->pQueueInput++ = *pBuffer++;                */
; 2019 :     /******************************************************************/
; 2020 : 
; 2021 :     memcpy( pPlayAudioRing->pQueueInput, pBuffer, dwLength );

  00997	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  0099a	8b ce		 mov	 ecx, esi
  0099c	8b 74 24 18	 mov	 esi, DWORD PTR _pBuffer$[esp+12]
  009a0	8b c1		 mov	 eax, ecx
  009a2	c1 e9 02	 shr	 ecx, 2
  009a5	f3 a5		 rep movsd
  009a7	8b c8		 mov	 ecx, eax

; 2022 : 
; 2023 :     pPlayAudioRing->pQueueInput += dwLength;

  009a9	8b 44 24 1c	 mov	 eax, DWORD PTR _dwLength$[esp+12]
  009ad	83 e1 03	 and	 ecx, 3
  009b0	f3 a4		 rep movsb
  009b2	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]

; 2024 :     pPlayAudioRing->iInputPosition += (int)dwLength;

  009b5	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  009b8	03 d0		 add	 edx, eax
  009ba	03 c8		 add	 ecx, eax
  009bc	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  009bf	89 4b 10	 mov	 DWORD PTR [ebx+16], ecx
$L70414:

; 2025 :   }
; 2026 : 
; 2027 :   /********************************************************************/
; 2028 :   /*  Atomically update the audio queue count.                        */
; 2029 :   /********************************************************************/
; 2030 : 
; 2031 :   OP_LockMutex( pPlayAudio->hmxQueueCount );

  009c2	8b 4d 78	 mov	 ecx, DWORD PTR [ebp+120]
  009c5	51		 push	 ecx
  009c6	e8 00 00 00 00	 call	 _OP_LockMutex

; 2032 :   pPlayAudioRing->iQueueCount += (int)dwLength;

  009cb	8b 74 24 20	 mov	 esi, DWORD PTR _dwLength$[esp+16]
  009cf	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  009d2	03 d6		 add	 edx, esi
  009d4	89 53 18	 mov	 DWORD PTR [ebx+24], edx

; 2033 :   OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  009d7	8b 55 78	 mov	 edx, DWORD PTR [ebp+120]
  009da	52		 push	 edx
  009db	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 2034 : 
; 2035 :   /********************************************************************/
; 2036 :   /*  Atomically update the queued byte count.                        */
; 2037 :   /*  If audio is not playing then activate the timer thread.         */
; 2038 :   /********************************************************************/
; 2039 : 
; 2040 :   OP_LockMutex( pPlayAudio->hmxQueuedByteCount );

  009e0	8b 85 80 00 00
	00		 mov	 eax, DWORD PTR [ebp+128]
  009e6	50		 push	 eax
  009e7	e8 00 00 00 00	 call	 _OP_LockMutex

; 2041 : 
; 2042 :   pPlayAudio->dwQueuedByteCount += dwLength;

  009ec	8b 4d 4c	 mov	 ecx, DWORD PTR [ebp+76]

; 2043 : 
; 2044 :   if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )

  009ef	8b 45 34	 mov	 eax, DWORD PTR [ebp+52]
  009f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  009f5	03 ce		 add	 ecx, esi
  009f7	85 c0		 test	 eax, eax
  009f9	89 4d 4c	 mov	 DWORD PTR [ebp+76], ecx
  009fc	5f		 pop	 edi
  009fd	75 0c		 jne	 SHORT $L70417

; 2045 :   {
; 2046 :     OP_SetEvent( pPlayAudio->hevTimerThreadActive );

  009ff	8b 4d 14	 mov	 ecx, DWORD PTR [ebp+20]
  00a02	51		 push	 ecx
  00a03	e8 00 00 00 00	 call	 _OP_SetEvent
  00a08	83 c4 04	 add	 esp, 4
$L70417:

; 2047 :   }
; 2048 : 
; 2049 :   OP_UnlockMutex( pPlayAudio->hmxQueuedByteCount );

  00a0b	8b 95 80 00 00
	00		 mov	 edx, DWORD PTR [ebp+128]
  00a11	52		 push	 edx
  00a12	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 2050 : 
; 2051 :   /********************************************************************/
; 2052 :   /*  If the audio is not playing and there are enough audio samples  */
; 2053 :   /*  and the system is not paused then start playing audio. Note     */
; 2054 :   /*  that the following tests do NOT have to be performed in a       */
; 2055 :   /*  thread-safe manner.                                             */
; 2056 :   /********************************************************************/
; 2057 : 
; 2058 :   if (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )
; 2059 :     && ( pPlayAudioRing->iQueueCount
; 2060 : 	>= (int)pPlayAudio->uiMinimumStartupBytes )
; 2061 :    && ( ! pPlayAudio->bPaused ))

  00a17	8b 45 34	 mov	 eax, DWORD PTR [ebp+52]
  00a1a	83 c4 04	 add	 esp, 4
  00a1d	85 c0		 test	 eax, eax
  00a1f	75 1e		 jne	 SHORT $L70419
  00a21	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00a24	8b 4d 2c	 mov	 ecx, DWORD PTR [ebp+44]
  00a27	3b c1		 cmp	 eax, ecx
  00a29	7c 14		 jl	 SHORT $L70419
  00a2b	8b 45 58	 mov	 eax, DWORD PTR [ebp+88]
  00a2e	85 c0		 test	 eax, eax
  00a30	75 0d		 jne	 SHORT $L70419

; 2062 :   {
; 2063 :     SendPlayAudioMessage( pPlayAudio,
; 2064 :                           ID_Open_Wave_Output_Device,
; 2065 :                           0L );

  00a32	6a 00		 push	 0
  00a34	6a 00		 push	 0
  00a36	55		 push	 ebp
  00a37	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00a3c	83 c4 0c	 add	 esp, 12			; 0000000cH
$L70419:

; 2066 :   }
; 2067 : 
; 2068 :   /********************************************************************/
; 2069 :   /*  Release the PA_Queue() function for use in another thread.      */
; 2070 :   /********************************************************************/
; 2071 : 
; 2072 :   OP_UnlockMutex( pPlayAudio->hmxQueueAudioBusy );

  00a3f	8b 4d 7c	 mov	 ecx, DWORD PTR [ebp+124]
  00a42	51		 push	 ecx
  00a43	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00a48	83 c4 04	 add	 esp, 4

; 2073 : 
; 2074 :   return MMSYSERR_NOERROR;

  00a4b	33 c0		 xor	 eax, eax
  00a4d	5b		 pop	 ebx
  00a4e	5e		 pop	 esi
  00a4f	5d		 pop	 ebp

; 2075 : }

  00a50	c3		 ret	 0
_PA_Queue ENDP
_pPlayAudio$ = 8
_PA_Reset PROC NEAR

; 2105 : {

  00a60	56		 push	 esi

; 2106 :   MMRESULT mmStatus;
; 2107 : #ifdef AUD_DEBUG //tek 22may97
; 2108 :   {
; 2109 :     char szTemp[256]="";
; 2110 :     sprintf(szTemp,"PA_Reset: at %ld\n",timeGetTime());
; 2111 :     OutputDebugString(szTemp);
; 2112 :   }
; 2113 : #endif //AUD_DEBUG
; 2114 :   
; 2115 :   /********************************************************************/
; 2116 :   /*  Return an error if NULL handle.                                 */
; 2117 :   /********************************************************************/
; 2118 :   
; 2119 :   if ( pPlayAudio == NULL )

  00a61	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  00a65	85 f6		 test	 esi, esi
  00a67	75 07		 jne	 SHORT $L70425

; 2120 :     return MMSYSERR_INVALPARAM;

  00a69	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00a6e	5e		 pop	 esi

; 2185 : }

  00a6f	c3		 ret	 0
$L70425:

; 2121 : 
; 2122 :   /********************************************************************/
; 2123 :   /*  Block if another thread is queueing audio.                      */
; 2124 :   /********************************************************************/
; 2125 : 
; 2126 :   OP_LockMutex( pPlayAudio->hmxQueueAudioBusy );

  00a70	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  00a73	57		 push	 edi
  00a74	50		 push	 eax
  00a75	e8 00 00 00 00	 call	 _OP_LockMutex

; 2127 : 
; 2128 :   /********************************************************************/
; 2129 :   /*  Reset the "Reset Complete" event.                               */
; 2130 :   /********************************************************************/
; 2131 : 
; 2132 :   OP_ResetEvent( pPlayAudio->hevResetComplete );

  00a7a	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00a7d	51		 push	 ecx
  00a7e	e8 00 00 00 00	 call	 _OP_ResetEvent

; 2133 : 
; 2134 :   /********************************************************************/
; 2135 :   /*  Cancel all audio output and initialize the audio queue.         */
; 2136 :   /********************************************************************/
; 2137 : 
; 2138 :   mmStatus = (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2139 : 	  ID_Reset_Audio,
; 2140 : 	  0L );

  00a83	6a 00		 push	 0
  00a85	6a 01		 push	 1
  00a87	56		 push	 esi
  00a88	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00a8d	8b f8		 mov	 edi, eax

; 2141 :   // tek 22jan99 if the audio device is still busy (we really don't
; 2142 :   // care if there is another writer of the status word, because we're
; 2143 :   // not gonna write it..) then we need to send the reset again so that 
; 2144 :   // the reset code can do cleanup after the WOM_DONE messages are processed.
; 2145 :   if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )

  00a8f	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00a92	83 c4 14	 add	 esp, 20			; 00000014H
  00a95	83 f8 02	 cmp	 eax, 2
  00a98	75 0d		 jne	 SHORT $L70427

; 2146 :   {  
; 2147 : #ifdef AUD_DEBUG
; 2148 : 	  {
; 2149 : 		  char szTemp[256];
; 2150 : 		  sprintf(szTemp,"PA_Reset resending ID_Reset_Audio at %ld\n",
; 2151 : 			  timeGetTime());
; 2152 : 		  OutputDebugString(szTemp);
; 2153 : 	  }
; 2154 : #endif //AUD_DEBUG
; 2155 : 	  SendPlayAudioMessage( pPlayAudio,
; 2156 : 		  ID_Reset_Audio,
; 2157 : 		  0L );

  00a9a	6a 00		 push	 0
  00a9c	6a 01		 push	 1
  00a9e	56		 push	 esi
  00a9f	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00aa4	83 c4 0c	 add	 esp, 12			; 0000000cH
$L70427:

; 2158 :   }
; 2159 : 
; 2160 :   /********************************************************************/
; 2161 :   /*  If audio is playing then wait for the reset to complete.        */
; 2162 :   /********************************************************************/
; 2163 : 
; 2164 :   OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  00aa7	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  00aaa	52		 push	 edx
  00aab	e8 00 00 00 00	 call	 _OP_LockMutex

; 2165 : 
; 2166 :   if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )

  00ab0	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00ab3	83 c4 04	 add	 esp, 4
  00ab6	83 f8 02	 cmp	 eax, 2
  00ab9	75 2b		 jne	 SHORT $L70428

; 2167 :   {
; 2168 :     OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  00abb	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00abe	50		 push	 eax
  00abf	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 2169 : 
; 2170 :     OP_WaitForEvent( pPlayAudio->hevResetComplete,
; 2171 :                      MAXIMUM_RESET_WAIT_IN_MSEC );

  00ac4	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00ac7	68 88 13 00 00	 push	 5000			; 00001388H
  00acc	51		 push	 ecx
  00acd	e8 00 00 00 00	 call	 _OP_WaitForEvent

; 2176 :   }
; 2177 : 
; 2178 :   /********************************************************************/
; 2179 :   /*  Release the audio queue.                                        */
; 2180 :   /********************************************************************/
; 2181 : 
; 2182 :   OP_UnlockMutex( pPlayAudio->hmxQueueAudioBusy );

  00ad2	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  00ad5	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ad8	50		 push	 eax
  00ad9	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00ade	83 c4 04	 add	 esp, 4

; 2183 : 
; 2184 :   return mmStatus;

  00ae1	8b c7		 mov	 eax, edi
  00ae3	5f		 pop	 edi
  00ae4	5e		 pop	 esi

; 2185 : }

  00ae5	c3		 ret	 0
$L70428:

; 2172 :   }
; 2173 :   else
; 2174 :   {
; 2175 :     OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  00ae6	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  00ae9	52		 push	 edx
  00aea	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 2176 :   }
; 2177 : 
; 2178 :   /********************************************************************/
; 2179 :   /*  Release the audio queue.                                        */
; 2180 :   /********************************************************************/
; 2181 : 
; 2182 :   OP_UnlockMutex( pPlayAudio->hmxQueueAudioBusy );

  00aef	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  00af2	83 c4 04	 add	 esp, 4
  00af5	50		 push	 eax
  00af6	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00afb	83 c4 04	 add	 esp, 4

; 2183 : 
; 2184 :   return mmStatus;

  00afe	8b c7		 mov	 eax, edi
  00b00	5f		 pop	 edi
  00b01	5e		 pop	 esi

; 2185 : }

  00b02	c3		 ret	 0
_PA_Reset ENDP
_TEXT	ENDS
PUBLIC	_PA_Pause
_TEXT	SEGMENT
_pPlayAudio$ = 8
_PA_Pause PROC NEAR

; 2213 :   /********************************************************************/
; 2214 :   /*  Return an error if NULL handle.                                 */
; 2215 :   /********************************************************************/
; 2216 : 
; 2217 :   if ( pPlayAudio == NULL )

  00b10	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  00b14	85 c0		 test	 eax, eax
  00b16	75 06		 jne	 SHORT $L70434

; 2218 :     return MMSYSERR_INVALHANDLE;

  00b18	b8 05 00 00 00	 mov	 eax, 5

; 2227 : }

  00b1d	c3		 ret	 0
$L70434:

; 2219 : 
; 2220 :   /********************************************************************/
; 2221 :   /*  Pause the wave output device.                                   */
; 2222 :   /********************************************************************/
; 2223 : 
; 2224 :   return (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2225 :                                          ID_Pause_Audio,
; 2226 :                                          0L );

  00b1e	6a 00		 push	 0
  00b20	6a 02		 push	 2
  00b22	50		 push	 eax
  00b23	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00b28	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2227 : }

  00b2b	c3		 ret	 0
_PA_Pause ENDP
_TEXT	ENDS
PUBLIC	_PA_Resume
_TEXT	SEGMENT
_pPlayAudio$ = 8
_PA_Resume PROC NEAR

; 2254 : {

  00b30	56		 push	 esi

; 2255 :   MMRESULT mmStatus;
; 2256 : 
; 2257 :   /********************************************************************/
; 2258 :   /*  Return an error if NULL handle.                                 */
; 2259 :   /********************************************************************/
; 2260 : 
; 2261 :   if ( pPlayAudio == NULL )

  00b31	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  00b35	85 f6		 test	 esi, esi
  00b37	75 07		 jne	 SHORT $L70441

; 2262 :     return MMSYSERR_INVALPARAM;

  00b39	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00b3e	5e		 pop	 esi

; 2288 : }

  00b3f	c3		 ret	 0
$L70441:
  00b40	57		 push	 edi

; 2263 : 
; 2264 :   /********************************************************************/
; 2265 :   /*  Resume paused audio output.                                     */
; 2266 :   /********************************************************************/
; 2267 : 
; 2268 :   mmStatus =  (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2269 :                                               ID_Resume_Audio,
; 2270 :                                               0L );

  00b41	6a 00		 push	 0
  00b43	6a 03		 push	 3
  00b45	56		 push	 esi
  00b46	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00b4b	8b f8		 mov	 edi, eax

; 2271 : 
; 2272 :   /********************************************************************/
; 2273 :   /*  If the audio is not playing and there are enough audio samples  */
; 2274 :   /*  then start playing audio. Note that the following test do NOT   */
; 2275 :   /*  have to be performed in a thread safe manner.                   */
; 2276 :   /********************************************************************/
; 2277 : 
; 2278 :   if (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )
; 2279 :    && ( pPlayAudio->pPlayAudioRing->iQueueCount
; 2280 :           >= (int)pPlayAudio->uiMinimumStartupBytes ))

  00b4d	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00b50	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b53	85 c0		 test	 eax, eax
  00b55	75 1d		 jne	 SHORT $L70444
  00b57	8b 86 94 00 00
	00		 mov	 eax, DWORD PTR [esi+148]
  00b5d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00b60	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00b63	3b c8		 cmp	 ecx, eax
  00b65	7c 0d		 jl	 SHORT $L70444

; 2281 :   {
; 2282 :     SendPlayAudioMessage( pPlayAudio,
; 2283 :                           ID_Open_Wave_Output_Device,
; 2284 :                           0L );

  00b67	6a 00		 push	 0
  00b69	6a 00		 push	 0
  00b6b	56		 push	 esi
  00b6c	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00b71	83 c4 0c	 add	 esp, 12			; 0000000cH
$L70444:

; 2285 :   }
; 2286 : 
; 2287 :   return mmStatus;

  00b74	8b c7		 mov	 eax, edi
  00b76	5f		 pop	 edi
  00b77	5e		 pop	 esi

; 2288 : }

  00b78	c3		 ret	 0
_PA_Resume ENDP
_TEXT	ENDS
PUBLIC	_PA_GetFormat
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pWaveFormat$ = 12
_PA_GetFormat PROC NEAR

; 2322 :   /********************************************************************/
; 2323 :   /*  Return an error if NULL handle.                                 */
; 2324 :   /********************************************************************/
; 2325 : 
; 2326 :   if ( pPlayAudio == NULL )

  00b80	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  00b84	85 c0		 test	 eax, eax
  00b86	75 06		 jne	 SHORT $L70451

; 2327 :     return MMSYSERR_INVALHANDLE;

  00b88	b8 05 00 00 00	 mov	 eax, 5

; 2336 : }

  00b8d	c3		 ret	 0
$L70451:

; 2328 : 
; 2329 :   /********************************************************************/
; 2330 :   /*  Get the audio format.                                           */
; 2331 :   /********************************************************************/
; 2332 : 
; 2333 :   return (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2334 :                                          ID_Get_Audio_Format,
; 2335 :                                          (ATYPE_T)pWaveFormat );

  00b8e	8b 4c 24 08	 mov	 ecx, DWORD PTR _pWaveFormat$[esp-4]
  00b92	51		 push	 ecx
  00b93	6a 05		 push	 5
  00b95	50		 push	 eax
  00b96	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00b9b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2336 : }

  00b9e	c3		 ret	 0
_PA_GetFormat ENDP
_pPlayAudio$ = 8
_pWaveFormat$ = 12
_PA_SetFormat PROC NEAR

; 2372 : {

  00ba0	53		 push	 ebx
  00ba1	55		 push	 ebp

; 2373 :   MMRESULT mmStatus;
; 2374 :   DWORD dwWaveFormatSize;
; 2375 :   LPWAVEFORMATEX pWaveFormatTemp;
; 2376 : #ifdef AUD_DEBUG
; 2377 :   OutputDebugString("PA_SetFormat()\n");
; 2378 : #endif
; 2379 :   /********************************************************************/
; 2380 :   /*  Return an error if NULL handle.                                 */
; 2381 :   /********************************************************************/
; 2382 : 
; 2383 :   if ( pPlayAudio == NULL )

  00ba2	8b 6c 24 0c	 mov	 ebp, DWORD PTR _pPlayAudio$[esp+4]
  00ba6	56		 push	 esi
  00ba7	85 ed		 test	 ebp, ebp
  00ba9	57		 push	 edi
  00baa	75 0a		 jne	 SHORT $L70463
  00bac	5f		 pop	 edi
  00bad	5e		 pop	 esi
  00bae	5d		 pop	 ebp

; 2384 :     return MMSYSERR_INVALHANDLE;

  00baf	b8 05 00 00 00	 mov	 eax, 5
  00bb4	5b		 pop	 ebx

; 2442 : }

  00bb5	c3		 ret	 0
$L70463:

; 2385 : 
; 2386 :   /********************************************************************/
; 2387 :   /*  Allocate shared memory for the MME server.                      */
; 2388 :   /*  First Get the size of the WAVEFORMATEX structure.               */
; 2389 :   /********************************************************************/
; 2390 : 
; 2391 :   dwWaveFormatSize = GetWaveFormatSize( pWaveFormat );

  00bb6	8b 74 24 18	 mov	 esi, DWORD PTR _pWaveFormat$[esp+12]
  00bba	56		 push	 esi
  00bbb	e8 00 00 00 00	 call	 _GetWaveFormatSize
  00bc0	8b f8		 mov	 edi, eax

; 2392 : 
; 2393 :   /********************************************************************/
; 2394 :   /*  Allocate memory for the play audio handle WAVEFORMATEX          */
; 2395 :   /*  structure.                                                      */
; 2396 :   /********************************************************************/
; 2397 : 
; 2398 :   LOCK_MME_CALL(
; 2399 :     pWaveFormatTemp =
; 2400 :       (LPWAVEFORMATEX)ALLOCATE_SERVER_MEM( dwWaveFormatSize ))

  00bc2	57		 push	 edi
  00bc3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00bc9	8b d8		 mov	 ebx, eax
  00bcb	83 c4 08	 add	 esp, 8

; 2401 : 
; 2402 :   if ( pWaveFormatTemp == NULL )

  00bce	85 db		 test	 ebx, ebx
  00bd0	75 0a		 jne	 SHORT $L70466
  00bd2	5f		 pop	 edi
  00bd3	5e		 pop	 esi
  00bd4	5d		 pop	 ebp

; 2403 :   {
; 2404 :     return MMSYSERR_NOMEM;

  00bd5	b8 07 00 00 00	 mov	 eax, 7
  00bda	5b		 pop	 ebx

; 2442 : }

  00bdb	c3		 ret	 0
$L70466:

; 2405 :   }
; 2406 : 
; 2407 :   /********************************************************************/
; 2408 :   /*  Copy the WAVEFORMATEX structure passed to this function to      */
; 2409 :   /*  audio handles WAVEFORMATEX structure.                           */
; 2410 :   /********************************************************************/
; 2411 : 
; 2412 :   memcpy( pWaveFormatTemp,
; 2413 :           pWaveFormat,
; 2414 :           dwWaveFormatSize );

  00bdc	8b cf		 mov	 ecx, edi
  00bde	8b fb		 mov	 edi, ebx
  00be0	8b c1		 mov	 eax, ecx

; 2415 : 
; 2416 :   /********************************************************************/
; 2417 :   /*  Set the audio format.                                           */
; 2418 :   /********************************************************************/
; 2419 : #ifdef AUD_DEBUG
; 2420 :   OutputDebugString("Calling  SendPlayAudioMessage()\n");
; 2421 : #endif
; 2422 :   mmStatus = SendPlayAudioMessage( pPlayAudio,
; 2423 :                                    ID_Set_Audio_Format,
; 2424 :                                    (ATYPE_T)pWaveFormatTemp );

  00be2	53		 push	 ebx
  00be3	c1 e9 02	 shr	 ecx, 2
  00be6	f3 a5		 rep movsd
  00be8	8b c8		 mov	 ecx, eax
  00bea	6a 04		 push	 4
  00bec	83 e1 03	 and	 ecx, 3
  00bef	55		 push	 ebp
  00bf0	f3 a4		 rep movsb
  00bf2	e8 00 00 00 00	 call	 _SendPlayAudioMessage

; 2425 : 
; 2426 :   /******************************************************************/
; 2427 :   /*  Free the temporary WAVEFORMATEX structure.                    */
; 2428 :   /******************************************************************/
; 2429 : 
; 2430 :   LOCK_MME_CALL( FREE_SERVER_MEM( pWaveFormatTemp ))

  00bf7	53		 push	 ebx
  00bf8	8b f0		 mov	 esi, eax
  00bfa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00c00	83 c4 10	 add	 esp, 16			; 00000010H

; 2431 : #ifdef AUD_DEBUG
; 2432 :   {
; 2433 : #include <stdio.h>
; 2434 : 		  char  szTemp[256]="";
; 2435 : 		  sprintf(szTemp,"PA_SetFormat: SendPlayAudioMessage status=%lu (%08lx)\n",
; 2436 : 			  mmStatus, mmStatus);
; 2437 : 		  OutputDebugString(szTemp);
; 2438 :   }
; 2439 : #endif //AUD_DEBUG
; 2440 : 
; 2441 :   return mmStatus;

  00c03	8b c6		 mov	 eax, esi
  00c05	5f		 pop	 edi
  00c06	5e		 pop	 esi
  00c07	5d		 pop	 ebp
  00c08	5b		 pop	 ebx

; 2442 : }

  00c09	c3		 ret	 0
_PA_SetFormat ENDP
_TEXT	ENDS
PUBLIC	_PA_GetVolume
EXTRN	__imp__waveOutGetVolume@8:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pdwVolume$ = 12
_PA_GetVolume PROC NEAR

; 2474 :   LPDWORD pdwVol;
; 2475 :   MMRESULT mmStatus;
; 2476 : 
; 2477 :   // tek 12nov97 bats517 change this to just do it, rather than
; 2478 :   // passing messages around..
; 2479 :   /********************************************************************/
; 2480 :   /*  Return an error if NULL handle.                                 */
; 2481 :   /********************************************************************/
; 2482 : 
; 2483 :   if ( pPlayAudio == NULL )

  00c10	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  00c14	85 c0		 test	 eax, eax
  00c16	75 06		 jne	 SHORT $L70476

; 2484 :     return MMSYSERR_INVALHANDLE;

  00c18	b8 05 00 00 00	 mov	 eax, 5

; 2489 : #else // not win32 or linux; do it the slow way.
; 2490 :   /********************************************************************/
; 2491 :   /*  Allocate memory to return the volume setting.                   */
; 2492 :   /********************************************************************/
; 2493 : 
; 2494 :   LOCK_MME_CALL( pdwVol = (LPDWORD)ALLOCATE_SERVER_MEM(sizeof(DWORD)))
; 2495 : 
; 2496 :   if ( pdwVol == NULL )
; 2497 :   {
; 2498 :     return MMSYSERR_NOMEM;
; 2499 :   }
; 2500 : 
; 2501 :   /********************************************************************/
; 2502 :   /*  Get the wave output device volume.                              */
; 2503 :   /********************************************************************/
; 2504 : 
; 2505 :   mmStatus = (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2506 :                                              ID_Get_Audio_Volume,
; 2507 :                                              (ATYPE_T)pdwVol );
; 2508 :   *pdwVolume = *pdwVol;
; 2509 : 
; 2510 :   /********************************************************************/
; 2511 :   /*  Free the memory used to return the volume setting.              */
; 2512 :   /********************************************************************/
; 2513 : 
; 2514 :   LOCK_MME_CALL( FREE_SERVER_MEM( pdwVol ))
; 2515 : #endif //_WIN32
; 2516 : 
; 2517 :   return mmStatus;
; 2518 : }

  00c1d	c3		 ret	 0
$L70476:

; 2485 : 
; 2486 : #if defined _WIN32 || defined __linux__
; 2487 : 
; 2488 :   mmStatus = waveOutGetVolume((HWAVEOUT)pPlayAudio->uiSelectedDeviceID,pdwVolume);

  00c1e	8b 4c 24 08	 mov	 ecx, DWORD PTR _pdwVolume$[esp-4]
  00c22	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  00c25	51		 push	 ecx
  00c26	52		 push	 edx
  00c27	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetVolume@8

; 2489 : #else // not win32 or linux; do it the slow way.
; 2490 :   /********************************************************************/
; 2491 :   /*  Allocate memory to return the volume setting.                   */
; 2492 :   /********************************************************************/
; 2493 : 
; 2494 :   LOCK_MME_CALL( pdwVol = (LPDWORD)ALLOCATE_SERVER_MEM(sizeof(DWORD)))
; 2495 : 
; 2496 :   if ( pdwVol == NULL )
; 2497 :   {
; 2498 :     return MMSYSERR_NOMEM;
; 2499 :   }
; 2500 : 
; 2501 :   /********************************************************************/
; 2502 :   /*  Get the wave output device volume.                              */
; 2503 :   /********************************************************************/
; 2504 : 
; 2505 :   mmStatus = (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2506 :                                              ID_Get_Audio_Volume,
; 2507 :                                              (ATYPE_T)pdwVol );
; 2508 :   *pdwVolume = *pdwVol;
; 2509 : 
; 2510 :   /********************************************************************/
; 2511 :   /*  Free the memory used to return the volume setting.              */
; 2512 :   /********************************************************************/
; 2513 : 
; 2514 :   LOCK_MME_CALL( FREE_SERVER_MEM( pdwVol ))
; 2515 : #endif //_WIN32
; 2516 : 
; 2517 :   return mmStatus;
; 2518 : }

  00c2d	c3		 ret	 0
_PA_GetVolume ENDP
_TEXT	ENDS
PUBLIC	_PA_SetVolume
EXTRN	__imp__waveOutSetVolume@8:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_dwVolume$ = 12
_PA_SetVolume PROC NEAR

; 2548 : 
; 2549 :    // tek 12nov97	bats517 change to just do it rather than pass messages
; 2550 : 
; 2551 :   /********************************************************************/
; 2552 :   /*  Return an error if NULL handle.                                 */
; 2553 :   /********************************************************************/
; 2554 : 
; 2555 :   if ( pPlayAudio == NULL )

  00c30	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  00c34	85 c0		 test	 eax, eax
  00c36	75 06		 jne	 SHORT $L70484

; 2556 :     return MMSYSERR_INVALHANDLE;

  00c38	b8 05 00 00 00	 mov	 eax, 5

; 2563 : #else // not win32
; 2564 :   return (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2565 :                                          ID_Set_Audio_Volume,
; 2566 :                                          (ATYPE_T)dwVolume );
; 2567 : #endif //_WIN32
; 2568 : }

  00c3d	c3		 ret	 0
$L70484:

; 2557 : 
; 2558 :   /********************************************************************/
; 2559 :   /*  Set the wave output device volume.                              */
; 2560 :   /********************************************************************/
; 2561 : #ifdef _WIN32
; 2562 :   return waveOutSetVolume((HWAVEOUT)pPlayAudio->uiSelectedDeviceID,dwVolume);

  00c3e	8b 4c 24 08	 mov	 ecx, DWORD PTR _dwVolume$[esp-4]
  00c42	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  00c45	51		 push	 ecx
  00c46	52		 push	 edx
  00c47	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutSetVolume@8

; 2563 : #else // not win32
; 2564 :   return (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2565 :                                          ID_Set_Audio_Volume,
; 2566 :                                          (ATYPE_T)dwVolume );
; 2567 : #endif //_WIN32
; 2568 : }

  00c4d	c3		 ret	 0
_PA_SetVolume ENDP
_TEXT	ENDS
PUBLIC	_PA_SynchronizationMark
_TEXT	SEGMENT
_pPlayAudio$ = 8
_aTag$ = 12
_PA_SynchronizationMark PROC NEAR

; 2604 :   /********************************************************************/
; 2605 :   /*  Return an error if NULL handle.                                 */
; 2606 :   /********************************************************************/
; 2607 : 
; 2608 :   if ( pPlayAudio == NULL )

  00c50	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  00c54	85 c0		 test	 eax, eax
  00c56	75 06		 jne	 SHORT $L70492

; 2609 :     return MMSYSERR_INVALHANDLE;

  00c58	b8 05 00 00 00	 mov	 eax, 5

; 2618 : }

  00c5d	c3		 ret	 0
$L70492:

; 2610 : 
; 2611 :   /********************************************************************/
; 2612 :   /*  Set the wave output Synchronization Mark.                       */
; 2613 :   /********************************************************************/
; 2614 : 
; 2615 :   return (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2616 :                                          ID_Synchronization_Mark,
; 2617 :                                          aTag );

  00c5e	8b 4c 24 08	 mov	 ecx, DWORD PTR _aTag$[esp-4]
  00c62	51		 push	 ecx
  00c63	6a 08		 push	 8
  00c65	50		 push	 eax
  00c66	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  00c6b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2618 : }

  00c6e	c3		 ret	 0
_PA_SynchronizationMark ENDP
_TEXT	ENDS
PUBLIC	_PA_GetPosition
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pdwPosition$ = 12
_bFast$ = 16
_PA_GetPosition PROC NEAR

; 2673 : {

  00c70	53		 push	 ebx
  00c71	56		 push	 esi
  00c72	57		 push	 edi

; 2674 :   LPDWORD pdwPos;
; 2675 :   MMRESULT mmStatus;
; 2676 : 
; 2677 :   /********************************************************************/
; 2678 :   /*  Return an error if NULL handle.                                 */
; 2679 :   /********************************************************************/
; 2680 : 
; 2681 :   if ( pPlayAudio == NULL )

  00c73	8b 7c 24 10	 mov	 edi, DWORD PTR _pPlayAudio$[esp+8]
  00c77	85 ff		 test	 edi, edi
  00c79	75 09		 jne	 SHORT $L70504
  00c7b	5f		 pop	 edi
  00c7c	5e		 pop	 esi

; 2682 :     return MMSYSERR_INVALHANDLE;

  00c7d	b8 05 00 00 00	 mov	 eax, 5
  00c82	5b		 pop	 ebx

; 2731 : }

  00c83	c3		 ret	 0
$L70504:

; 2683 : 
; 2684 :   /********************************************************************/
; 2685 :   /*  Either get a quick coarse position or a slower but more         */
; 2686 :   /*  accurate position.                                              */
; 2687 :   /********************************************************************/
; 2688 : 
; 2689 :   if ( bFast )

  00c84	8b 44 24 18	 mov	 eax, DWORD PTR _bFast$[esp+8]
  00c88	85 c0		 test	 eax, eax
  00c8a	74 26		 je	 SHORT $L70505

; 2690 :   {
; 2691 :     /******************************************************************/
; 2692 :     /*  Get the coarse wave output position.                          */
; 2693 :     /******************************************************************/
; 2694 : 
; 2695 :     mmStatus = MMSYSERR_NOERROR;
; 2696 : 
; 2697 :     OP_LockMutex( pPlayAudio->hmxBytesPlayed );

  00c8c	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  00c8f	33 db		 xor	 ebx, ebx
  00c91	50		 push	 eax
  00c92	e8 00 00 00 00	 call	 _OP_LockMutex

; 2698 :     *pdwPosition = pPlayAudio->dwBytesPlayed;

  00c97	8b 54 24 18	 mov	 edx, DWORD PTR _pdwPosition$[esp+12]
  00c9b	8b 4f 44	 mov	 ecx, DWORD PTR [edi+68]
  00c9e	89 0a		 mov	 DWORD PTR [edx], ecx

; 2699 :     OP_UnlockMutex( pPlayAudio->hmxBytesPlayed );

  00ca0	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  00ca3	50		 push	 eax
  00ca4	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00ca9	83 c4 08	 add	 esp, 8

; 2728 :   }
; 2729 : 
; 2730 :   return mmStatus;

  00cac	8b c3		 mov	 eax, ebx
  00cae	5f		 pop	 edi
  00caf	5e		 pop	 esi
  00cb0	5b		 pop	 ebx

; 2731 : }

  00cb1	c3		 ret	 0
$L70505:

; 2700 :   }
; 2701 :   else
; 2702 :   {
; 2703 :     /******************************************************************/
; 2704 :     /*  Allocate memory to return the audio position.                 */
; 2705 :     /******************************************************************/
; 2706 : 
; 2707 :     pdwPos = (LPDWORD)malloc(sizeof(DWORD));

  00cb2	6a 04		 push	 4
  00cb4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00cba	8b f0		 mov	 esi, eax
  00cbc	83 c4 04	 add	 esp, 4

; 2708 : 
; 2709 :     if ( pdwPos == NULL )

  00cbf	85 f6		 test	 esi, esi
  00cc1	75 09		 jne	 SHORT $L70510
  00cc3	5f		 pop	 edi
  00cc4	5e		 pop	 esi

; 2710 :     {
; 2711 :       return MMSYSERR_NOMEM;

  00cc5	b8 07 00 00 00	 mov	 eax, 7
  00cca	5b		 pop	 ebx

; 2731 : }

  00ccb	c3		 ret	 0
$L70510:

; 2712 :     }
; 2713 : 
; 2714 :     /******************************************************************/
; 2715 :     /*  Get the fine wave output position.                            */
; 2716 :     /******************************************************************/
; 2717 : 
; 2718 :     mmStatus = (MMRESULT)SendPlayAudioMessage( pPlayAudio,
; 2719 :                                                ID_Get_Audio_Position,
; 2720 :                                                (ATYPE_T)pdwPos );

  00ccc	56		 push	 esi
  00ccd	6a 09		 push	 9
  00ccf	57		 push	 edi
  00cd0	e8 00 00 00 00	 call	 _SendPlayAudioMessage

; 2721 :     *pdwPosition = *pdwPos;

  00cd5	8b 54 24 20	 mov	 edx, DWORD PTR _pdwPosition$[esp+20]
  00cd9	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 2722 : 
; 2723 :     /******************************************************************/
; 2724 :     /*  Free the memory used to return the audio position.            */
; 2725 :     /******************************************************************/
; 2726 : 
; 2727 :     free( pdwPos );

  00cdb	56		 push	 esi
  00cdc	8b d8		 mov	 ebx, eax
  00cde	89 0a		 mov	 DWORD PTR [edx], ecx
  00ce0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00ce6	83 c4 10	 add	 esp, 16			; 00000010H

; 2728 :   }
; 2729 : 
; 2730 :   return mmStatus;

  00ce9	8b c3		 mov	 eax, ebx
  00ceb	5f		 pop	 edi
  00cec	5e		 pop	 esi
  00ced	5b		 pop	 ebx

; 2731 : }

  00cee	c3		 ret	 0
_PA_GetPosition ENDP
_TEXT	ENDS
PUBLIC	_PA_Status
_TEXT	SEGMENT
_pPlayAudio$ = 8
_dwIdentifierArray$ = 12
_dwStatusArray$ = 16
_dwNumberOfStatusValues$ = 20
_uiQueueCount$ = -8
_bGotQueueCount$ = 8
_mmStatus$ = -4
_PA_Status PROC NEAR

; 2813 : {

  00cf0	83 ec 08	 sub	 esp, 8
  00cf3	55		 push	 ebp
  00cf4	56		 push	 esi

; 2814 :   unsigned int uiI;
; 2815 :   unsigned int uiQueueCount=0;
; 2816 :   unsigned int bGotQueueCount;
; 2817 :   DWORD dwAudioDeviceState;
; 2818 :   LPPLAY_RING_T pPlayAudioRing=NULL;
; 2819 :   MMRESULT mmStatus;
; 2820 : 
; 2821 :   /********************************************************************/
; 2822 :   /*  Return an error if NULL handle.                                 */
; 2823 :   /********************************************************************/
; 2824 : 
; 2825 :   if ( pPlayAudio == NULL )

  00cf5	8b 74 24 14	 mov	 esi, DWORD PTR _pPlayAudio$[esp+12]
  00cf9	33 d2		 xor	 edx, edx
  00cfb	33 ed		 xor	 ebp, ebp
  00cfd	3b f2		 cmp	 esi, edx
  00cff	89 54 24 08	 mov	 DWORD PTR _uiQueueCount$[esp+16], edx
  00d03	75 0b		 jne	 SHORT $L70530
  00d05	5e		 pop	 esi

; 2826 :     return MMSYSERR_INVALHANDLE;

  00d06	b8 05 00 00 00	 mov	 eax, 5
  00d0b	5d		 pop	 ebp

; 2920 : }

  00d0c	83 c4 08	 add	 esp, 8
  00d0f	c3		 ret	 0
$L70530:

; 2827 : 
; 2828 :   /********************************************************************/
; 2829 :   /*  Range check the number of status values requested.              */
; 2830 :   /********************************************************************/
; 2831 : 
; 2832 :   if (( dwNumberOfStatusValues == 0 )
; 2833 :     || ( dwNumberOfStatusValues > MAXIMUM_STATUS_VALUES ))

  00d10	8b 44 24 20	 mov	 eax, DWORD PTR _dwNumberOfStatusValues$[esp+12]
  00d14	3b c2		 cmp	 eax, edx
  00d16	0f 84 3a 01 00
	00		 je	 $L70532
  00d1c	83 f8 04	 cmp	 eax, 4
  00d1f	0f 87 31 01 00
	00		 ja	 $L70532

; 2841 : 
; 2842 :   /********************************************************************/
; 2843 :   /*  Loop and fill in array puiStatus[].                             */
; 2844 :   /********************************************************************/
; 2845 : 
; 2846 :   bGotQueueCount = FALSE;
; 2847 : 
; 2848 :   for ( uiI = 0; uiI < dwNumberOfStatusValues; uiI++ )

  00d25	3b c2		 cmp	 eax, edx
  00d27	89 54 24 0c	 mov	 DWORD PTR _mmStatus$[esp+16], edx
  00d2b	89 54 24 14	 mov	 DWORD PTR _bGotQueueCount$[esp+12], edx
  00d2f	0f 86 17 01 00
	00		 jbe	 $L70535

; 2861 :       else
; 2862 :         dwStatusArray[uiI] = TRUE;

  00d35	8b 4c 24 18	 mov	 ecx, DWORD PTR _dwIdentifierArray$[esp+12]
  00d39	53		 push	 ebx
  00d3a	57		 push	 edi
  00d3b	8b 7c 24 24	 mov	 edi, DWORD PTR _dwStatusArray$[esp+20]
  00d3f	2b cf		 sub	 ecx, edi
  00d41	89 44 24 28	 mov	 DWORD PTR 20+[esp+20], eax
  00d45	89 4c 24 24	 mov	 DWORD PTR 16+[esp+20], ecx
  00d49	eb 08		 jmp	 SHORT $L70533
$L71353:

; 2835 : 
; 2836 :   /********************************************************************/
; 2837 :   /*  Set the default error return value to indicate success.         */
; 2838 :   /********************************************************************/
; 2839 : 
; 2840 :   mmStatus = MMSYSERR_NOERROR;

  00d4b	8b 4c 24 24	 mov	 ecx, DWORD PTR 16+[esp+20]
  00d4f	8b 54 24 1c	 mov	 edx, DWORD PTR _bGotQueueCount$[esp+20]
$L70533:

; 2849 :   {
; 2850 :     switch( dwIdentifierArray[uiI] )
; 2851 :     {

  00d53	8b 04 39	 mov	 eax, DWORD PTR [ecx+edi]
  00d56	83 f8 03	 cmp	 eax, 3
  00d59	0f 87 cb 00 00
	00		 ja	 $L70555
  00d5f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L71354[eax*4]
$L70540:

; 2852 :     case PA_DEVICE_PLAYING:
; 2853 : 
; 2854 :       OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  00d66	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00d69	50		 push	 eax
  00d6a	e8 00 00 00 00	 call	 _OP_LockMutex

; 2855 :       dwAudioDeviceState = pPlayAudio->dwAudioDeviceState;
; 2856 :       OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  00d6f	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  00d72	8b 5e 34	 mov	 ebx, DWORD PTR [esi+52]
  00d75	51		 push	 ecx
  00d76	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00d7b	83 c4 08	 add	 esp, 8

; 2857 : 
; 2858 :       if (( dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )
; 2859 :         || ( dwAudioDeviceState == AUDIO_DEVICE_SHUTTING_DOWN ))

  00d7e	85 db		 test	 ebx, ebx
  00d80	74 10		 je	 SHORT $L70542
  00d82	83 fb 03	 cmp	 ebx, 3
  00d85	74 0b		 je	 SHORT $L70542

; 2861 :       else
; 2862 :         dwStatusArray[uiI] = TRUE;

  00d87	c7 07 01 00 00
	00		 mov	 DWORD PTR [edi], 1
  00d8d	e9 a6 00 00 00	 jmp	 $L70534
$L70542:

; 2860 :         dwStatusArray[uiI] = FALSE;

  00d92	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 2863 : 
; 2864 :       break;

  00d98	e9 9b 00 00 00	 jmp	 $L70534
$L70544:

; 2865 : 
; 2866 :     case PA_FREE_SPACE:
; 2867 : 
; 2868 :       if ( ! bGotQueueCount )

  00d9d	85 d2		 test	 edx, edx
  00d9f	75 2a		 jne	 SHORT $L70545

; 2869 :       {
; 2870 :         bGotQueueCount = TRUE;
; 2871 : 
; 2872 :         pPlayAudioRing = pPlayAudio->pPlayAudioRing;
; 2873 : 
; 2874 :         OP_LockMutex( pPlayAudio->hmxQueueCount );

  00da1	8b 56 78	 mov	 edx, DWORD PTR [esi+120]
  00da4	8b ae 94 00 00
	00		 mov	 ebp, DWORD PTR [esi+148]
  00daa	52		 push	 edx
  00dab	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR _bGotQueueCount$[esp+24], 1
  00db3	e8 00 00 00 00	 call	 _OP_LockMutex

; 2875 :         uiQueueCount = (unsigned int)pPlayAudioRing->iQueueCount;
; 2876 : 		// tek 07nov97 BATS 514this was a very bad typo! change to UNlock!
; 2877 :         OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  00db8	8b 4e 78	 mov	 ecx, DWORD PTR [esi+120]
  00dbb	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  00dbe	51		 push	 ecx
  00dbf	89 44 24 18	 mov	 DWORD PTR _uiQueueCount$[esp+32], eax
  00dc3	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00dc8	83 c4 08	 add	 esp, 8
$L70545:

; 2878 :       }
; 2879 : 
; 2880 :       dwStatusArray[uiI] = (DWORD)
; 2881 :         ((unsigned int )pPlayAudioRing->iQueueLength - uiQueueCount );

  00dcb	8b 55 1c	 mov	 edx, DWORD PTR [ebp+28]
  00dce	8b 44 24 10	 mov	 eax, DWORD PTR _uiQueueCount$[esp+24]
  00dd2	2b d0		 sub	 edx, eax
  00dd4	89 17		 mov	 DWORD PTR [edi], edx

; 2882 : 
; 2883 :       break;

  00dd6	eb 60		 jmp	 SHORT $L70534
$L70549:

; 2884 : 
; 2885 :     case PA_QUEUE_COUNT:
; 2886 : 
; 2887 :       if ( ! bGotQueueCount )

  00dd8	85 d2		 test	 edx, edx
  00dda	75 2a		 jne	 SHORT $L70550

; 2888 :       {
; 2889 :         bGotQueueCount = TRUE;
; 2890 : 
; 2891 :         pPlayAudioRing = pPlayAudio->pPlayAudioRing;
; 2892 : 
; 2893 :         OP_LockMutex( pPlayAudio->hmxQueueCount );

  00ddc	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  00ddf	8b ae 94 00 00
	00		 mov	 ebp, DWORD PTR [esi+148]
  00de5	50		 push	 eax
  00de6	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR _bGotQueueCount$[esp+24], 1
  00dee	e8 00 00 00 00	 call	 _OP_LockMutex

; 2894 :         uiQueueCount = (unsigned int)pPlayAudioRing->iQueueCount;
; 2895 :         OP_LockMutex( pPlayAudio->hmxQueueCount );

  00df3	8b 56 78	 mov	 edx, DWORD PTR [esi+120]
  00df6	8b 4d 18	 mov	 ecx, DWORD PTR [ebp+24]
  00df9	52		 push	 edx
  00dfa	89 4c 24 18	 mov	 DWORD PTR _uiQueueCount$[esp+32], ecx
  00dfe	e8 00 00 00 00	 call	 _OP_LockMutex
  00e03	83 c4 08	 add	 esp, 8
$L70550:

; 2896 :       }
; 2897 : 
; 2898 :       dwStatusArray[uiI] = (DWORD)uiQueueCount;

  00e06	8b 44 24 10	 mov	 eax, DWORD PTR _uiQueueCount$[esp+24]
  00e0a	89 07		 mov	 DWORD PTR [edi], eax

; 2899 : 
; 2900 :       break;

  00e0c	eb 2a		 jmp	 SHORT $L70534
$L70553:

; 2901 : 
; 2902 :     case PA_DEVICE_ID:
; 2903 : 
; 2904 :       OP_LockMutex( pPlayAudio->hmxSelectedDeviceID );

  00e0e	8b 4e 74	 mov	 ecx, DWORD PTR [esi+116]
  00e11	51		 push	 ecx
  00e12	e8 00 00 00 00	 call	 _OP_LockMutex

; 2905 :       dwStatusArray[uiI] = (DWORD)pPlayAudio->uiSelectedDeviceID;

  00e17	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00e1a	89 17		 mov	 DWORD PTR [edi], edx

; 2906 :       OP_UnlockMutex( pPlayAudio->hmxSelectedDeviceID );

  00e1c	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00e1f	50		 push	 eax
  00e20	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00e25	83 c4 08	 add	 esp, 8

; 2907 : 
; 2908 :       break;

  00e28	eb 0e		 jmp	 SHORT $L70534
$L70555:

; 2909 : 
; 2910 :     default:
; 2911 : 
; 2912 :       dwStatusArray[uiI] = 0xFFFFFFFF;

  00e2a	c7 07 ff ff ff
	ff		 mov	 DWORD PTR [edi], -1

; 2913 :       mmStatus = MMSYSERR_INVALPARAM;

  00e30	c7 44 24 14 0b
	00 00 00	 mov	 DWORD PTR _mmStatus$[esp+24], 11 ; 0000000bH
$L70534:
  00e38	8b 44 24 28	 mov	 eax, DWORD PTR 20+[esp+20]
  00e3c	83 c7 04	 add	 edi, 4
  00e3f	48		 dec	 eax
  00e40	89 44 24 28	 mov	 DWORD PTR 20+[esp+20], eax
  00e44	0f 85 01 ff ff
	ff		 jne	 $L71353
  00e4a	5f		 pop	 edi
  00e4b	5b		 pop	 ebx
$L70535:

; 2914 : 
; 2915 :       break;
; 2916 :     }
; 2917 :   }
; 2918 : 
; 2919 :   return mmStatus;

  00e4c	8b 44 24 0c	 mov	 eax, DWORD PTR _mmStatus$[esp+16]
  00e50	5e		 pop	 esi
  00e51	5d		 pop	 ebp

; 2920 : }

  00e52	83 c4 08	 add	 esp, 8
  00e55	c3		 ret	 0
$L70532:
  00e56	5e		 pop	 esi

; 2834 :     return MMSYSERR_INVALPARAM;

  00e57	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00e5c	5d		 pop	 ebp

; 2920 : }

  00e5d	83 c4 08	 add	 esp, 8
  00e60	c3		 ret	 0
  00e61	8d 49 00	 npad	 3
$L71354:
  00e64	00 00 00 00	 DD	 $L70540
  00e68	00 00 00 00	 DD	 $L70544
  00e6c	00 00 00 00	 DD	 $L70549
  00e70	00 00 00 00	 DD	 $L70553
_PA_Status ENDP
_TEXT	ENDS
PUBLIC	_PA_WaitForPlayToComplete
EXTRN	_OP_Sleep:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_PA_WaitForPlayToComplete PROC NEAR

; 2949 : {

  00e80	56		 push	 esi

; 2950 :   int iQueueCount;
; 2951 :   PLAYAUD_BOOL_T bAudioPlaying;
; 2952 :   LPPLAY_RING_T pPlayAudioRing;
; 2953 : 
; 2954 :   /********************************************************************/
; 2955 :   /*  Return an error if NULL handle.                                 */
; 2956 :   /********************************************************************/
; 2957 : 
; 2958 :   if ( pPlayAudio == NULL )

  00e81	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  00e85	85 f6		 test	 esi, esi
  00e87	75 07		 jne	 SHORT $L70563

; 2959 :     return MMSYSERR_INVALHANDLE;

  00e89	b8 05 00 00 00	 mov	 eax, 5
  00e8e	5e		 pop	 esi

; 2996 : }

  00e8f	c3		 ret	 0
$L70563:
  00e90	53		 push	 ebx

; 2960 : 
; 2961 :   /********************************************************************/
; 2962 :   /*  Loop and wait for all queued audio samples to complete.         */
; 2963 :   /********************************************************************/
; 2964 : 
; 2965 :   pPlayAudioRing = pPlayAudio->pPlayAudioRing;

  00e91	8b 9e 94 00 00
	00		 mov	 ebx, DWORD PTR [esi+148]
  00e97	57		 push	 edi
$L70565:

; 2966 :   bAudioPlaying = TRUE;
; 2967 : 
; 2968 :   while( bAudioPlaying )
; 2969 :   {
; 2970 :     /******************************************************************/
; 2971 :     /*  Wait on the Audio Device Inactive Event.                      */
; 2972 :     /******************************************************************/
; 2973 : 
; 2974 :     OP_WaitForEvent( pPlayAudio->hevAudioDeviceInactive, OP_INFINITE );

  00e98	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00e9b	6a ff		 push	 -1
  00e9d	50		 push	 eax
  00e9e	e8 00 00 00 00	 call	 _OP_WaitForEvent

; 2975 : 
; 2976 :     /******************************************************************/
; 2977 :     /*  Check the Audio Queue Count. If there is any audio to be      */
; 2978 :     /*  played then go to sleep and contine to wait.                  */
; 2979 :     /******************************************************************/
; 2980 : 
; 2981 :     OP_LockMutex( pPlayAudio->hmxQueueCount );

  00ea3	8b 4e 78	 mov	 ecx, DWORD PTR [esi+120]
  00ea6	51		 push	 ecx
  00ea7	e8 00 00 00 00	 call	 _OP_LockMutex

; 2982 :     iQueueCount = pPlayAudioRing->iQueueCount;
; 2983 :     OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  00eac	8b 56 78	 mov	 edx, DWORD PTR [esi+120]
  00eaf	8b 7b 18	 mov	 edi, DWORD PTR [ebx+24]
  00eb2	52		 push	 edx
  00eb3	e8 00 00 00 00	 call	 _OP_UnlockMutex
  00eb8	83 c4 10	 add	 esp, 16			; 00000010H

; 2984 : 
; 2985 :     if ( iQueueCount == 0 )

  00ebb	85 ff		 test	 edi, edi
  00ebd	74 0c		 je	 SHORT $L71357

; 2986 :     {
; 2987 :       bAudioPlaying = FALSE;
; 2988 :     }
; 2989 :     else
; 2990 :     {
; 2991 :       OP_Sleep( PLAY_WAIT_SLEEP_TIME_IN_MSEC );

  00ebf	6a 32		 push	 50			; 00000032H
  00ec1	e8 00 00 00 00	 call	 _OP_Sleep
  00ec6	83 c4 04	 add	 esp, 4
  00ec9	eb cd		 jmp	 SHORT $L70565
$L71357:
  00ecb	5f		 pop	 edi
  00ecc	5b		 pop	 ebx

; 2992 :     }
; 2993 :   }
; 2994 : 
; 2995 :   return MMSYSERR_NOERROR;

  00ecd	33 c0		 xor	 eax, eax
  00ecf	5e		 pop	 esi

; 2996 : }

  00ed0	c3		 ret	 0
_PA_WaitForPlayToComplete ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutGetDevCapsA@12:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_uiNumberOfWaveOutDevices$ = 12
_pWaveFormat$ = 16
_bGotDeviceID$ = -8
_bAllocated$ = -4
_DetermineDeviceID PROC NEAR

; 3037 : {

  00ee0	83 ec 08	 sub	 esp, 8
  00ee3	53		 push	 ebx
  00ee4	55		 push	 ebp

; 3038 :   unsigned int bGotDeviceID;
; 3039 :   unsigned int bAllocated;
; 3040 :   unsigned int bIsStandardFormat;
; 3041 :   unsigned int uiDeviceID;
; 3042 :   DWORD dwDesiredFormat=0;
; 3043 :   LPWAVEOUTCAPS pWaveOutCaps;
; 3044 :   MMRESULT mmStatus;
; 3045 : #ifdef AUD_DEBUG
; 3046 :   OutputDebugString("DetermineDeviceID()\n");
; 3047 : #endif
; 3048 :   /********************************************************************/
; 3049 :   /*  Query each device until a non-allocated device that supports    */
; 3050 :   /*  the requested format is found.                                  */
; 3051 :   /********************************************************************/
; 3052 : 
; 3053 :   bGotDeviceID = FALSE;
; 3054 :   bAllocated = FALSE;
; 3055 : 
; 3056 :   for ( uiDeviceID = 0;
; 3057 :         uiDeviceID < uiNumberOfWaveOutDevices;
; 3058 :         uiDeviceID++ )

  00ee5	8b 6c 24 18	 mov	 ebp, DWORD PTR _uiNumberOfWaveOutDevices$[esp+12]
  00ee9	56		 push	 esi
  00eea	57		 push	 edi
  00eeb	33 ff		 xor	 edi, edi
  00eed	3b ef		 cmp	 ebp, edi
  00eef	89 7c 24 10	 mov	 DWORD PTR _bGotDeviceID$[esp+24], edi
  00ef3	89 7c 24 14	 mov	 DWORD PTR _bAllocated$[esp+24], edi
  00ef7	76 6a		 jbe	 SHORT $L71370

; 3059 :   {
; 3060 :     pPlayAudio->uiSelectedDeviceID = uiDeviceID;

  00ef9	8b 74 24 24	 mov	 esi, DWORD PTR _pWaveFormat$[esp+20]
$L70583:
  00efd	8b 5c 24 1c	 mov	 ebx, DWORD PTR _pPlayAudio$[esp+20]

; 3061 : 
; 3062 :     mmStatus = PA_SetFormat( pPlayAudio, pWaveFormat );

  00f01	56		 push	 esi
  00f02	53		 push	 ebx
  00f03	89 7b 20	 mov	 DWORD PTR [ebx+32], edi
  00f06	e8 00 00 00 00	 call	 _PA_SetFormat
  00f0b	83 c4 08	 add	 esp, 8

; 3063 : 
; 3064 :     if ( mmStatus == MMSYSERR_NOERROR )

  00f0e	85 c0		 test	 eax, eax
  00f10	74 14		 je	 SHORT $L71362

; 3067 :       break;
; 3068 :     }
; 3069 :     else if ( mmStatus == MMSYSERR_ALLOCATED )

  00f12	83 f8 04	 cmp	 eax, 4
  00f15	75 08		 jne	 SHORT $L70584

; 3070 :     {
; 3071 :       bAllocated = TRUE;

  00f17	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _bAllocated$[esp+24], 1
$L70584:

; 3038 :   unsigned int bGotDeviceID;
; 3039 :   unsigned int bAllocated;
; 3040 :   unsigned int bIsStandardFormat;
; 3041 :   unsigned int uiDeviceID;
; 3042 :   DWORD dwDesiredFormat=0;
; 3043 :   LPWAVEOUTCAPS pWaveOutCaps;
; 3044 :   MMRESULT mmStatus;
; 3045 : #ifdef AUD_DEBUG
; 3046 :   OutputDebugString("DetermineDeviceID()\n");
; 3047 : #endif
; 3048 :   /********************************************************************/
; 3049 :   /*  Query each device until a non-allocated device that supports    */
; 3050 :   /*  the requested format is found.                                  */
; 3051 :   /********************************************************************/
; 3052 : 
; 3053 :   bGotDeviceID = FALSE;
; 3054 :   bAllocated = FALSE;
; 3055 : 
; 3056 :   for ( uiDeviceID = 0;
; 3057 :         uiDeviceID < uiNumberOfWaveOutDevices;
; 3058 :         uiDeviceID++ )

  00f1f	47		 inc	 edi
  00f20	3b fd		 cmp	 edi, ebp
  00f22	72 d9		 jb	 SHORT $L70583

; 3377 :         {
; 3378 :           break;
; 3379 :         }
; 3380 : 
; 3381 :         if ( pWaveOutCaps->dwFormats == dwDesiredFormat )

  00f24	eb 08		 jmp	 SHORT $L70585
$L71362:

; 3065 :     {
; 3066 :       bGotDeviceID = TRUE;

  00f26	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _bGotDeviceID$[esp+24], 1
$L70585:

; 3072 :     }
; 3073 :   }
; 3074 : 
; 3075 :   /********************************************************************/
; 3076 :   /*  There were no devices available that support the requested      */
; 3077 :   /*  format. Query each device until a device that supports the      */
; 3078 :   /*  requested format is found, even if the device is allocated.     */
; 3079 :   /********************************************************************/
; 3080 : 
; 3081 :   if ( bAllocated )

  00f2e	8b 44 24 14	 mov	 eax, DWORD PTR _bAllocated$[esp+24]
  00f32	85 c0		 test	 eax, eax
  00f34	74 1d		 je	 SHORT $L70592

; 3082 :   {
; 3083 :     for ( uiDeviceID = 0;
; 3084 :           uiDeviceID < uiNumberOfWaveOutDevices;
; 3085 :           uiDeviceID++ )

  00f36	33 ff		 xor	 edi, edi
$L70590:

; 3086 :     {
; 3087 :       pPlayAudio->uiSelectedDeviceID = uiDeviceID;
; 3088 : 
; 3089 :       mmStatus = PA_SetFormat( pPlayAudio, pWaveFormat );

  00f38	56		 push	 esi
  00f39	53		 push	 ebx
  00f3a	89 7b 20	 mov	 DWORD PTR [ebx+32], edi
  00f3d	e8 00 00 00 00	 call	 _PA_SetFormat
  00f42	83 c4 08	 add	 esp, 8

; 3090 : 
; 3091 :       if (( mmStatus == MMSYSERR_NOERROR )
; 3092 :         || ( mmStatus == MMSYSERR_ALLOCATED ))

  00f45	85 c0		 test	 eax, eax
  00f47	74 27		 je	 SHORT $L71363
  00f49	83 f8 04	 cmp	 eax, 4
  00f4c	74 22		 je	 SHORT $L71363
  00f4e	47		 inc	 edi
  00f4f	3b fd		 cmp	 edi, ebp
  00f51	72 e5		 jb	 SHORT $L70590
$L70592:

; 3095 :         break;
; 3096 :       }
; 3097 :     }
; 3098 :   }
; 3099 : 
; 3100 :   // tek 24sep96 if we didn't find an unallocated device that 
; 3101 :   // supports this format, and we didn't find an allocated device, 
; 3102 :   // bail out.
; 3103 :   if ((!bGotDeviceID) && (!bAllocated))

  00f53	8b 44 24 10	 mov	 eax, DWORD PTR _bGotDeviceID$[esp+24]
  00f57	85 c0		 test	 eax, eax
  00f59	75 1d		 jne	 SHORT $L70595
  00f5b	8b 44 24 14	 mov	 eax, DWORD PTR _bAllocated$[esp+24]
  00f5f	85 c0		 test	 eax, eax
  00f61	75 15		 jne	 SHORT $L70595
$L71370:
  00f63	5f		 pop	 edi
  00f64	5e		 pop	 esi
  00f65	5d		 pop	 ebp

; 3104 :   {
; 3105 : #ifdef AUD_DEBUG
; 3106 : 	  OutputDebugString("no devices support format.\n");
; 3107 : #endif
; 3108 : 	  return WAVERR_BADFORMAT;

  00f66	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00f6b	5b		 pop	 ebx

; 3419 : }

  00f6c	83 c4 08	 add	 esp, 8
  00f6f	c3		 ret	 0
$L71363:

; 3093 :       {
; 3094 :         bGotDeviceID = TRUE;

  00f70	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _bGotDeviceID$[esp+24], 1
$L70595:

; 3109 :   }
; 3110 : 
; 3111 : 
; 3112 :   /********************************************************************/
; 3113 :   /*  If a wave output device supporting the request format was not   */
; 3114 :   /*  found, it might be because all devices supporting the requested */
; 3115 :   /*  format are busy and busy devices do not return a bad format     */
; 3116 :   /*  status even if the format is unsupported. This not the case for */
; 3117 :   /*  the MME server, but in any event, this extra check cannot hurt. */
; 3118 :   /*  In this case, device support only for mulaw and certain PCM     */
; 3119 :   /*  formats can be checked.                                         */
; 3120 :   /********************************************************************/
; 3121 : 
; 3122 :   mmStatus = MMSYSERR_NOERROR;
; 3123 : 
; 3124 :   if (( ! bGotDeviceID ) && ( bAllocated ))

  00f78	8b 44 24 10	 mov	 eax, DWORD PTR _bGotDeviceID$[esp+24]
  00f7c	33 ff		 xor	 edi, edi
  00f7e	85 c0		 test	 eax, eax
  00f80	75 74		 jne	 SHORT $L70689
  00f82	8b 44 24 14	 mov	 eax, DWORD PTR _bAllocated$[esp+24]
  00f86	85 c0		 test	 eax, eax
  00f88	74 6c		 je	 SHORT $L70689

; 3125 :   {
; 3126 :     /********************************************************************/
; 3127 :     /*  If the wave format tag is equal to either WAVE_FORMAT_PCM or to */
; 3128 :     /*  WAVE_FORMAT_08M08 then test the device capabilities.            */
; 3129 :     /********************************************************************/
; 3130 : 
; 3131 :     bIsStandardFormat = TRUE;
; 3132 : 
; 3133 :     switch ( pWaveFormat->wFormatTag )
; 3134 :     {

  00f8a	33 c0		 xor	 eax, eax
  00f8c	66 8b 06	 mov	 ax, WORD PTR [esi]
  00f8f	48		 dec	 eax
  00f90	74 22		 je	 SHORT $L70601
  00f92	83 e8 06	 sub	 eax, 6
  00f95	75 53		 jne	 SHORT $L70677

; 3321 :       }
; 3322 : 
; 3323 :       break;
; 3324 : 
; 3325 :     case WAVE_FORMAT_08M08:
; 3326 : 
; 3327 :         if (( pWaveFormat->nSamplesPerSec == 8000 )
; 3328 :           && ( pWaveFormat->nChannels == 1 )
; 3329 :           && ( pWaveFormat->wBitsPerSample == 8 ))

  00f97	81 7e 04 40 1f
	00 00		 cmp	 DWORD PTR [esi+4], 8000	; 00001f40H
  00f9e	75 4a		 jne	 SHORT $L70677
  00fa0	66 83 7e 02 01	 cmp	 WORD PTR [esi+2], 1
  00fa5	75 43		 jne	 SHORT $L70677
  00fa7	66 83 7e 0e 08	 cmp	 WORD PTR [esi+14], 8

; 3330 :         {
; 3331 :           dwDesiredFormat = WAVE_FORMAT_08M08;
; 3332 :         }
; 3333 :         else

  00fac	0f 84 82 00 00
	00		 je	 $L71371

; 3334 :         {
; 3335 :           bIsStandardFormat = FALSE;;
; 3336 :         }
; 3337 : 
; 3338 :         break;

  00fb2	eb 36		 jmp	 SHORT $L70677
$L70601:

; 3135 :     /********************************************************************/
; 3136 :     /*  Determine the identifier returned in the dwFormat element       */
; 3137 :     /*  of the WAVEOUTCAPS structure that corresponds to the            */
; 3138 :     /*  requested audio format.                                         */
; 3139 :     /********************************************************************/
; 3140 : 
; 3141 :     case WAVE_FORMAT_PCM:
; 3142 : 
; 3143 :       switch ( pWaveFormat->nSamplesPerSec )
; 3144 :       {

  00fb4	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00fb7	3d 11 2b 00 00	 cmp	 eax, 11025		; 00002b11H
  00fbc	74 5c		 je	 SHORT $L70606
  00fbe	3d 22 56 00 00	 cmp	 eax, 22050		; 00005622H
  00fc3	74 3b		 je	 SHORT $L70628
  00fc5	3d 44 ac 00 00	 cmp	 eax, 44100		; 0000ac44H

; 3269 :           case 8:
; 3270 : 
; 3271 :             dwDesiredFormat = WAVE_FORMAT_4M08;
; 3272 :             break;
; 3273 : 
; 3274 :           case 16:
; 3275 : 
; 3276 :             dwDesiredFormat = WAVE_FORMAT_4M16;
; 3277 :             break;
; 3278 : 
; 3279 :           default:
; 3280 : 
; 3281 :             bIsStandardFormat = FALSE;;
; 3282 :             break;
; 3283 :           }
; 3284 : 
; 3285 :         case 2:
; 3286 : 
; 3287 :           switch ( pWaveFormat->wBitsPerSample )
; 3288 :           {
; 3289 :           case 8:
; 3290 : 
; 3291 :             dwDesiredFormat = WAVE_FORMAT_4S08;
; 3292 :             break;
; 3293 : 
; 3294 :           case 16:
; 3295 : 
; 3296 :             dwDesiredFormat = WAVE_FORMAT_4S16;
; 3297 :             break;
; 3298 : 
; 3299 :           default:
; 3300 : 
; 3301 :             bIsStandardFormat = FALSE;;
; 3302 :             break;
; 3303 :           }
; 3304 : 
; 3305 :         default:
; 3306 : 
; 3307 :           bIsStandardFormat = FALSE;;
; 3308 :           break;
; 3309 :         }
; 3310 : 
; 3311 :         break;
; 3312 : 
; 3313 :       /****************************************************************/
; 3314 :       /*  The sample rate is not a standard value.                    */
; 3315 :       /****************************************************************/
; 3316 : 
; 3317 :       default:
; 3318 : 
; 3319 :         bIsStandardFormat = FALSE;;
; 3320 :         break;

  00fca	75 1e		 jne	 SHORT $L70677
  00fcc	33 c0		 xor	 eax, eax
  00fce	66 8b 46 02	 mov	 ax, WORD PTR [esi+2]
  00fd2	48		 dec	 eax
  00fd3	74 05		 je	 SHORT $L70655

; 3256 : 
; 3257 :       /****************************************************************/
; 3258 :       /*  The sample rate equals 44100 Hz.                            */
; 3259 :       /****************************************************************/
; 3260 : 
; 3261 :       case 44100:
; 3262 : 
; 3263 :         switch ( pWaveFormat->nChannels )
; 3264 :         {

  00fd5	48		 dec	 eax
  00fd6	74 0c		 je	 SHORT $L70657
  00fd8	eb 10		 jmp	 SHORT $L70677
$L70655:

; 3265 :         case 1:
; 3266 : 
; 3267 :           switch ( pWaveFormat->wBitsPerSample )
; 3268 :           {

  00fda	33 c0		 xor	 eax, eax
  00fdc	66 8b 46 0e	 mov	 ax, WORD PTR [esi+14]
  00fe0	89 44 24 20	 mov	 DWORD PTR 12+[esp+20], eax
$L70657:
  00fe4	33 c0		 xor	 eax, eax
  00fe6	66 8b 46 0e	 mov	 ax, WORD PTR [esi+14]
$L70677:

; 3400 :       {
; 3401 :         mmStatus = MMSYSERR_NOTSUPPORTED;
; 3402 :       }
; 3403 :     }
; 3404 :     else
; 3405 :     {
; 3406 :       /******************************************************************/
; 3407 :       /*  A non standard format is requested and some devices are busy  */
; 3408 :       /*  so they cannot be queried. Exit with failure and inform the   */
; 3409 :       /*  application that some devices are allocated.                  */
; 3410 :       /******************************************************************/
; 3411 : 
; 3412 :       pPlayAudio->uiSelectedDeviceID = WAVE_MAPPER;

  00fea	c7 43 20 ff ff
	ff ff		 mov	 DWORD PTR [ebx+32], -1

; 3413 : 
; 3414 :       mmStatus = MMSYSERR_NOTSUPPORTED;

  00ff1	bf 08 00 00 00	 mov	 edi, 8
$L70689:

; 3415 :     }
; 3416 :   }
; 3417 : 
; 3418 :   return mmStatus;

  00ff6	8b c7		 mov	 eax, edi
  00ff8	5f		 pop	 edi
  00ff9	5e		 pop	 esi
  00ffa	5d		 pop	 ebp
  00ffb	5b		 pop	 ebx

; 3419 : }

  00ffc	83 c4 08	 add	 esp, 8
  00fff	c3		 ret	 0
$L70628:

; 3157 :           case 8:
; 3158 : 
; 3159 :             dwDesiredFormat = WAVE_FORMAT_1M08;
; 3160 :             break;
; 3161 : 
; 3162 :           case 16:
; 3163 : 
; 3164 :             dwDesiredFormat = WAVE_FORMAT_1M16;
; 3165 :             break;
; 3166 : 
; 3167 :           default:
; 3168 : 
; 3169 :             bIsStandardFormat = FALSE;;
; 3170 :             break;
; 3171 :           }
; 3172 : 
; 3173 :         case 2:
; 3174 : 
; 3175 :           switch ( pWaveFormat->wBitsPerSample )
; 3176 :           {
; 3177 :           case 8:
; 3178 : 
; 3179 :             dwDesiredFormat = WAVE_FORMAT_1S08;
; 3180 :             break;
; 3181 : 
; 3182 :           case 16:
; 3183 : 
; 3184 :             dwDesiredFormat = WAVE_FORMAT_1S16;
; 3185 :             break;
; 3186 : 
; 3187 :           default:
; 3188 : 
; 3189 :             bIsStandardFormat = FALSE;;
; 3190 :             break;
; 3191 :           }
; 3192 : 
; 3193 :         default:
; 3194 : 
; 3195 :           bIsStandardFormat = FALSE;;
; 3196 :           break;
; 3197 :         }
; 3198 : 
; 3199 :         break;
; 3200 : 
; 3201 :       /****************************************************************/
; 3202 :       /*  The sample rate equals 22050 Hz.                            */
; 3203 :       /****************************************************************/
; 3204 : 
; 3205 :       case 22050:
; 3206 : 
; 3207 :         switch ( pWaveFormat->nChannels )
; 3208 :         {

  01000	33 c0		 xor	 eax, eax
  01002	66 8b 46 02	 mov	 ax, WORD PTR [esi+2]
  01006	48		 dec	 eax
  01007	74 05		 je	 SHORT $L70633
  01009	48		 dec	 eax
  0100a	74 d8		 je	 SHORT $L70657
  0100c	eb dc		 jmp	 SHORT $L70677
$L70633:

; 3209 :         case 1:
; 3210 : 
; 3211 :           switch ( pWaveFormat->wBitsPerSample )
; 3212 :           {

  0100e	33 c9		 xor	 ecx, ecx
  01010	66 8b 4e 0e	 mov	 cx, WORD PTR [esi+14]
  01014	89 4c 24 20	 mov	 DWORD PTR 12+[esp+20], ecx

; 3213 :           case 8:
; 3214 : 
; 3215 :             dwDesiredFormat = WAVE_FORMAT_2M08;
; 3216 :             break;
; 3217 : 
; 3218 :           case 16:
; 3219 : 
; 3220 :             dwDesiredFormat = WAVE_FORMAT_2M16;
; 3221 :             break;
; 3222 : 
; 3223 :           default:
; 3224 : 
; 3225 :             bIsStandardFormat = FALSE;;
; 3226 :             break;
; 3227 :           }
; 3228 : 
; 3229 :         case 2:
; 3230 : 
; 3231 :           switch ( pWaveFormat->wBitsPerSample )
; 3232 :           {
; 3233 :           case 8:
; 3234 : 
; 3235 :             dwDesiredFormat = WAVE_FORMAT_2S08;
; 3236 :             break;
; 3237 : 
; 3238 :           case 16:
; 3239 : 
; 3240 :             dwDesiredFormat = WAVE_FORMAT_2S16;
; 3241 :             break;
; 3242 : 
; 3243 :           default:
; 3244 : 
; 3245 :             bIsStandardFormat = FALSE;;
; 3246 :             break;
; 3247 :           }
; 3248 : 
; 3249 :         default:
; 3250 : 
; 3251 :           bIsStandardFormat = FALSE;;
; 3252 :           break;
; 3253 :         }
; 3254 : 
; 3255 :         break;

  01018	eb ca		 jmp	 SHORT $L70657
$L70606:

; 3145 :       /******************************************************************/
; 3146 :       /*  The sample rate equals 11025 Hz.                              */
; 3147 :       /******************************************************************/
; 3148 : 
; 3149 :       case 11025:
; 3150 : 
; 3151 :         switch ( pWaveFormat->nChannels )
; 3152 :         {

  0101a	33 c0		 xor	 eax, eax
  0101c	66 8b 46 02	 mov	 ax, WORD PTR [esi+2]
  01020	48		 dec	 eax
  01021	74 05		 je	 SHORT $L70611
  01023	48		 dec	 eax
  01024	74 be		 je	 SHORT $L70657
  01026	eb c2		 jmp	 SHORT $L70677
$L70611:

; 3153 :         case 1:
; 3154 : 
; 3155 :           switch ( pWaveFormat->wBitsPerSample )
; 3156 :           {

  01028	33 d2		 xor	 edx, edx
  0102a	66 8b 56 0e	 mov	 dx, WORD PTR [esi+14]
  0102e	89 54 24 20	 mov	 DWORD PTR 12+[esp+20], edx

; 3339 : 
; 3340 :     default:
; 3341 : 
; 3342 :       bIsStandardFormat = FALSE;;
; 3343 :       break;
; 3344 :     }
; 3345 : 
; 3346 :     if ( bIsStandardFormat )

  01032	eb b0		 jmp	 SHORT $L70657
$L71371:

; 3347 :     {
; 3348 :       /******************************************************************/
; 3349 :       /*  Get the wave output device capabilities.                      */
; 3350 :       /*  First allocate memory for the WAVEOUTCAPS structure.          */
; 3351 :       /******************************************************************/
; 3352 : 
; 3353 :       LOCK_MME_CALL(
; 3354 :         pWaveOutCaps = (LPWAVEOUTCAPS)ALLOCATE_SERVER_MEM(sizeof(WAVEOUTCAPS)))

  01034	6a 34		 push	 52			; 00000034H
  01036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0103c	8b d8		 mov	 ebx, eax

; 3355 : 
; 3356 :       if ( pWaveOutCaps == NULL )

  0103e	33 f6		 xor	 esi, esi
  01040	83 c4 04	 add	 esp, 4
  01043	3b de		 cmp	 ebx, esi
  01045	75 0d		 jne	 SHORT $L70681
  01047	5f		 pop	 edi
  01048	5e		 pop	 esi
  01049	5d		 pop	 ebp

; 3357 :       {
; 3358 :         return MMSYSERR_NOMEM;

  0104a	b8 07 00 00 00	 mov	 eax, 7
  0104f	5b		 pop	 ebx

; 3419 : }

  01050	83 c4 08	 add	 esp, 8
  01053	c3		 ret	 0
$L70681:

; 3359 :       }
; 3360 : 
; 3361 :       /******************************************************************/
; 3362 :       /*  Test for the supported format.                                */
; 3363 :       /******************************************************************/
; 3364 : 
; 3365 :       bGotDeviceID = FALSE;
; 3366 : 
; 3367 :       for ( uiDeviceID = 0;
; 3368 :             uiDeviceID <= uiNumberOfWaveOutDevices - 1;
; 3369 :             uiDeviceID++ )

  01054	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__waveOutGetDevCapsA@12
  0105a	89 74 24 10	 mov	 DWORD PTR _bGotDeviceID$[esp+24], esi
$L70682:

; 3370 :       {
; 3371 :         LOCK_MME_CALL(
; 3372 :           mmStatus = waveOutGetDevCaps( uiDeviceID,
; 3373 :                                         pWaveOutCaps,
; 3374 :                                         sizeof(WAVEOUTCAPS)))

  0105e	6a 34		 push	 52			; 00000034H
  01060	53		 push	 ebx
  01061	56		 push	 esi
  01062	ff d5		 call	 ebp
  01064	8b f8		 mov	 edi, eax

; 3375 : 	 
; 3376 :         if ( mmStatus )

  01066	85 ff		 test	 edi, edi
  01068	75 21		 jne	 SHORT $L70684

; 3377 :         {
; 3378 :           break;
; 3379 :         }
; 3380 : 
; 3381 :         if ( pWaveOutCaps->dwFormats == dwDesiredFormat )

  0106a	83 7b 28 07	 cmp	 DWORD PTR [ebx+40], 7
  0106e	74 0c		 je	 SHORT $L71365
  01070	8b 44 24 20	 mov	 eax, DWORD PTR _uiNumberOfWaveOutDevices$[esp+20]
  01074	46		 inc	 esi
  01075	48		 dec	 eax
  01076	3b f0		 cmp	 esi, eax
  01078	76 e4		 jbe	 SHORT $L70682
  0107a	eb 0f		 jmp	 SHORT $L70684
$L71365:

; 3382 :         {
; 3383 :           bGotDeviceID = TRUE;
; 3384 :           pPlayAudio->uiSelectedDeviceID = uiDeviceID;

  0107c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _pPlayAudio$[esp+20]
  01080	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _bGotDeviceID$[esp+24], 1
  01088	89 71 20	 mov	 DWORD PTR [ecx+32], esi
$L70684:

; 3385 :           break;
; 3386 :         }
; 3387 :       }
; 3388 : 
; 3389 :       /******************************************************************/
; 3390 :       /*  Free memory for the WAVEOUTCAPS structure.                    */
; 3391 :       /******************************************************************/
; 3392 : 
; 3393 :       LOCK_MME_CALL( FREE_SERVER_MEM( pWaveOutCaps ))

  0108b	53		 push	 ebx
  0108c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free

; 3394 : 	  
; 3395 :       /******************************************************************/
; 3396 :       /*  If no device supported the format then return an error.       */
; 3397 :       /******************************************************************/
; 3398 : 	  
; 3399 :       if ( ! bGotDeviceID )

  01092	8b 44 24 14	 mov	 eax, DWORD PTR _bGotDeviceID$[esp+28]
  01096	83 c4 04	 add	 esp, 4
  01099	85 c0		 test	 eax, eax
  0109b	0f 85 55 ff ff
	ff		 jne	 $L70689

; 3413 : 
; 3414 :       mmStatus = MMSYSERR_NOTSUPPORTED;

  010a1	bf 08 00 00 00	 mov	 edi, 8

; 3415 :     }
; 3416 :   }
; 3417 : 
; 3418 :   return mmStatus;

  010a6	8b c7		 mov	 eax, edi
  010a8	5f		 pop	 edi
  010a9	5e		 pop	 esi
  010aa	5d		 pop	 ebp
  010ab	5b		 pop	 ebx

; 3419 : }

  010ac	83 c4 08	 add	 esp, 8
  010af	c3		 ret	 0
_DetermineDeviceID ENDP
_TEXT	ENDS
PUBLIC	__real@8@4008fa00000000000000
EXTRN	_OP_ExitThread:NEAR
EXTRN	__ftol:NEAR
EXTRN	__fltused:NEAR
;	COMDAT __real@8@4008fa00000000000000
; File D:\work\product\dapi\src\NT\playaud.c
CONST	SEGMENT
__real@8@4008fa00000000000000 DQ 0408f400000000000r ; 1000
CONST	ENDS
_TEXT	SEGMENT
_pPlayAudio$ = 8
_uiStartupTimeoutTime$ = -24
_bDidBlock$ = -20
_dwSyncMarkPosition$ = -28
_dwCurrentPosition$ = 8
_pPlayAudioRing$ = -32
_TimerThreadMain PROC NEAR

; 3515 : {

  010b0	83 ec 20	 sub	 esp, 32			; 00000020H
  010b3	55		 push	 ebp
  010b4	56		 push	 esi

; 3516 :   unsigned int uiAvgBytesPerSec;
; 3517 :   unsigned int uiFlowCheckTime;
; 3518 :   unsigned int uiLastQueueCount;
; 3519 :   unsigned int uiCurrentQueueCount;
; 3520 :   unsigned int uiStartupTimeoutTime;
; 3521 :   unsigned int uiElapsedTime;
; 3522 :   unsigned int uiWaitTime;
; 3523 :   BOOL	bDidBlock=FALSE;	//tek 28jan98 BATS 532 reduce CPU consumption
; 3524 :   DWORD dwSyncMarkPosition=0;
; 3525 :   DWORD dwCurrentPosition;
; 3526 :   MMRESULT mmStatus;
; 3527 :   ATYPE_T aSyncMarkTag;
; 3528 :   LPSYNC_MARK_T pSyncMark;
; 3529 :   LPSYNC_MARK_T pNextSyncMark;
; 3530 :   LPPLAY_RING_T pPlayAudioRing;
; 3531 : 
; 3532 :   /********************************************************************/
; 3533 :   /*  Initialize the timer count to 0. This is used to count the      */
; 3534 :   /*  number of consecutive times that audio is in the queue and the  */
; 3535 :   /*  audio device is not active.                                     */
; 3536 :   /********************************************************************/
; 3537 : 
; 3538 :   uiElapsedTime = 0;
; 3539 : 
; 3540 :   pPlayAudioRing = pPlayAudio->pPlayAudioRing;

  010b5	8b 74 24 2c	 mov	 esi, DWORD PTR _pPlayAudio$[esp+36]
  010b9	33 ed		 xor	 ebp, ebp
  010bb	89 6c 24 0c	 mov	 DWORD PTR _dwSyncMarkPosition$[esp+40], ebp
  010bf	8b 86 94 00 00
	00		 mov	 eax, DWORD PTR [esi+148]
  010c5	89 44 24 08	 mov	 DWORD PTR _pPlayAudioRing$[esp+40], eax

; 3541 : 
; 3542 :   /********************************************************************/
; 3543 :   /*  Loop forever until thread shutdown time.                        */
; 3544 :   /********************************************************************/
; 3545 : 
; 3546 :   while( ! pPlayAudio->bTimerExit )

  010c9	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  010cc	85 c0		 test	 eax, eax
  010ce	0f 85 d5 03 00
	00		 jne	 $L71385
  010d4	53		 push	 ebx
  010d5	57		 push	 edi
$L70710:

; 3547 :   {
; 3548 :     pPlayAudio->bTimerThreadReset = FALSE;
; 3549 : 	bDidBlock = FALSE; //tek 28jan98 keep track when we block ourselves
; 3550 : 
; 3551 :     /******************************************************************/
; 3552 :     /******************************************************************/
; 3553 :     /*  If audio is playing then test to see if there are any         */
; 3554 :     /*  synchronization marks that need to be reported.               */
; 3555 :     /*  If there are then get the current "play audio" position.      */
; 3556 :     /******************************************************************/
; 3557 :     /******************************************************************/
; 3558 : 
; 3559 :     if (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )
; 3560 :         && ( pPlayAudio->pSyncMarkList != NULL ))

  010d6	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  010d9	bb 02 00 00 00	 mov	 ebx, 2
  010de	33 ff		 xor	 edi, edi
  010e0	3b c3		 cmp	 eax, ebx
  010e2	89 7e 68	 mov	 DWORD PTR [esi+104], edi
  010e5	89 7c 24 1c	 mov	 DWORD PTR _bDidBlock$[esp+48], edi
  010e9	75 29		 jne	 SHORT $L70713
  010eb	39 be 98 00 00
	00		 cmp	 DWORD PTR [esi+152], edi
  010f1	74 21		 je	 SHORT $L70713

; 3561 :     {
; 3562 :       /****************************************************************/
; 3563 :       /*  Get the current audio position.                             */
; 3564 :       /****************************************************************/
; 3565 : 
; 3566 :       mmStatus = PA_GetPosition( pPlayAudio,
; 3567 :                                  &dwCurrentPosition,
; 3568 :                                  FALSE );

  010f3	8d 4c 24 34	 lea	 ecx, DWORD PTR _dwCurrentPosition$[esp+44]
  010f7	57		 push	 edi
  010f8	51		 push	 ecx
  010f9	56		 push	 esi
  010fa	e8 00 00 00 00	 call	 _PA_GetPosition
  010ff	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3569 :       if ( mmStatus )

  01102	3b c7		 cmp	 eax, edi
  01104	74 48		 je	 SHORT $L71378

; 3570 :       {
; 3571 : #ifdef AUD_DEBUG
; 3572 : 		OutputDebugString("TimerThreadMain: PA_GetPosition failed {1}\n");
; 3573 : #endif
; 3574 :         ReportStatusToApplication( pPlayAudio,
; 3575 :                                    PA_SYNC_ERROR,
; 3576 :                                    mmStatus );

  01106	50		 push	 eax
  01107	6a 05		 push	 5
  01109	56		 push	 esi
  0110a	e8 00 00 00 00	 call	 _ReportStatusToApplication
  0110f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3577 :       }
; 3578 :     }
; 3579 :     else

  01112	eb 3a		 jmp	 SHORT $L71378
$L70713:

; 3580 :     {
; 3581 :       /****************************************************************/
; 3582 :       /*  In case the audio device becomes active between this if     */
; 3583 :       /*  statement and the following code (this will only happen     */
; 3584 :       /*  very infrequently) make sure that the current position      */
; 3585 :       /*  variable is less than any non-zero synchronization mark     */
; 3586 :       /*  position.                                                   */
; 3587 :       /****************************************************************/
; 3588 : 
; 3589 :       OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  01114	8b 96 88 00 00
	00		 mov	 edx, DWORD PTR [esi+136]
  0111a	52		 push	 edx
  0111b	e8 00 00 00 00	 call	 _OP_LockMutex

; 3590 : 
; 3591 :       if ( pPlayAudio->pSyncMarkList != NULL )

  01120	8b 86 98 00 00
	00		 mov	 eax, DWORD PTR [esi+152]
  01126	83 c4 04	 add	 esp, 4
  01129	3b c7		 cmp	 eax, edi
  0112b	74 12		 je	 SHORT $L70719

; 3592 :       {
; 3593 :         if ( pPlayAudio->pSyncMarkList->dwPosition == 0 )

  0112d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  01130	3b c7		 cmp	 eax, edi
  01132	75 06		 jne	 SHORT $L70718

; 3594 :         {
; 3595 :           dwCurrentPosition = 0;

  01134	89 7c 24 34	 mov	 DWORD PTR _dwCurrentPosition$[esp+44], edi

; 3596 :         }
; 3597 :         else

  01138	eb 05		 jmp	 SHORT $L70719
$L70718:

; 3598 :         {
; 3599 :           dwCurrentPosition = pPlayAudio->pSyncMarkList->dwPosition - 1;

  0113a	48		 dec	 eax
  0113b	89 44 24 34	 mov	 DWORD PTR _dwCurrentPosition$[esp+44], eax
$L70719:

; 3600 :         }
; 3601 :       }
; 3602 : 
; 3603 :       OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  0113f	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  01145	50		 push	 eax
  01146	e8 00 00 00 00	 call	 _OP_UnlockMutex
  0114b	83 c4 04	 add	 esp, 4
$L71378:

; 3604 :     }
; 3605 : 
; 3606 :     /******************************************************************/
; 3607 :     /******************************************************************/
; 3608 :     /*  If audio is playing then loop while there are synchronization */
; 3609 :     /*  marks that need to be reported. Don't bother if the audio is  */
; 3610 :     /*  paused.                                                       */
; 3611 :     /******************************************************************/
; 3612 :     /******************************************************************/
; 3613 : 
; 3614 :     while (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )
; 3615 :         && ( pPlayAudio->pSyncMarkList != NULL )
; 3616 :         && ( ! pPlayAudio->bPaused )
; 3617 :         && ( ! pPlayAudio->bTimerThreadReset ))

  0114e	39 5e 34	 cmp	 DWORD PTR [esi+52], ebx
  01151	0f 85 3d 01 00
	00		 jne	 $L70723
$L70722:
  01157	8b 86 98 00 00
	00		 mov	 eax, DWORD PTR [esi+152]
  0115d	85 c0		 test	 eax, eax
  0115f	0f 84 2f 01 00
	00		 je	 $L70723
  01165	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  01168	85 c0		 test	 eax, eax
  0116a	0f 85 24 01 00
	00		 jne	 $L70723
  01170	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  01173	85 c0		 test	 eax, eax
  01175	0f 85 19 01 00
	00		 jne	 $L70723

; 3618 :     {
; 3619 :       /****************************************************************/
; 3620 :       /*  See if the marked position has been encountered yet.        */
; 3621 :       /*  Synchonization mark information is protected by mutex's in  */
; 3622 :       /*  case the synchronization linked list is emptied when the    */
; 3623 :       /*  PA_Reset() function is called.                              */
; 3624 :       /****************************************************************/
; 3625 : 
; 3626 :       OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  0117b	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  01181	51		 push	 ecx
  01182	e8 00 00 00 00	 call	 _OP_LockMutex

; 3627 : 
; 3628 :       pSyncMark = pPlayAudio->pSyncMarkList;

  01187	8b 86 98 00 00
	00		 mov	 eax, DWORD PTR [esi+152]
  0118d	83 c4 04	 add	 esp, 4

; 3629 : 
; 3630 :       if ( pSyncMark != NULL )

  01190	85 c0		 test	 eax, eax
  01192	74 09		 je	 SHORT $L70725

; 3631 :       {
; 3632 :         dwSyncMarkPosition = pSyncMark->dwPosition;

  01194	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  01197	89 54 24 14	 mov	 DWORD PTR _dwSyncMarkPosition$[esp+48], edx
  0119b	8b ea		 mov	 ebp, edx
$L70725:

; 3633 :       }
; 3634 : 
; 3635 :       OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  0119d	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  011a3	50		 push	 eax
  011a4	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 3636 : 
; 3637 :       /****************************************************************/
; 3638 :       /*  Tsst to see if the position counter has wrapped back to     */
; 3639 :       /*  zero. This will only happen after audio has been playing a  */
; 3640 :       /*  very long time. The marked position count and the current   */
; 3641 :       /*  position count can only differ by the time it takes to play */
; 3642 :       /*  all of the audio in the ring buffer. This is at most a few  */
; 3643 :       /*  seconds, even at the lowest supported sample rate. So if    */
; 3644 :       /*  the wait time is more than a few seconds then the position  */
; 3645 :       /*  count has wrapped and the synchronization mark should be    */
; 3646 :       /*  reported immediately.                                       */
; 3647 :       /****************************************************************/
; 3648 : 
; 3649 :       uiWaitTime = dwSyncMarkPosition - dwCurrentPosition;

  011a9	8b 44 24 38	 mov	 eax, DWORD PTR _dwCurrentPosition$[esp+48]
  011ad	8b fd		 mov	 edi, ebp
  011af	83 c4 04	 add	 esp, 4
  011b2	2b f8		 sub	 edi, eax

; 3650 : 
; 3651 :       while (( dwCurrentPosition < dwSyncMarkPosition )
; 3652 :         && ( uiWaitTime < POSITION_COUNT_WRAP_TIME )
; 3653 :         && ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )
; 3654 :         && ( pPlayAudio->pSyncMarkList != NULL )
; 3655 :         && ( ! pPlayAudio->bPaused )
; 3656 :         && ( ! pPlayAudio->bTimerThreadReset ))

  011b4	3b c5		 cmp	 eax, ebp
  011b6	73 5b		 jae	 SHORT $L70729
$L70728:
  011b8	81 ff 40 42 0f
	00		 cmp	 edi, 1000000		; 000f4240H
  011be	73 53		 jae	 SHORT $L70729
  011c0	39 5e 34	 cmp	 DWORD PTR [esi+52], ebx
  011c3	75 4e		 jne	 SHORT $L70729
  011c5	8b 86 98 00 00
	00		 mov	 eax, DWORD PTR [esi+152]
  011cb	85 c0		 test	 eax, eax
  011cd	74 44		 je	 SHORT $L70729
  011cf	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  011d2	85 c0		 test	 eax, eax
  011d4	75 3d		 jne	 SHORT $L70729
  011d6	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  011d9	85 c0		 test	 eax, eax
  011db	75 36		 jne	 SHORT $L70729

; 3657 :       {
; 3658 :         if ( uiWaitTime > MAXIMUM_POSITION_SLEEP_TIME )

  011dd	83 ff 64	 cmp	 edi, 100		; 00000064H
  011e0	76 05		 jbe	 SHORT $L70730

; 3659 :         {
; 3660 :           uiWaitTime = MAXIMUM_POSITION_SLEEP_TIME;

  011e2	bf 64 00 00 00	 mov	 edi, 100		; 00000064H
$L70730:

; 3661 :         }
; 3662 : 
; 3663 :         OP_Sleep( uiWaitTime );

  011e7	57		 push	 edi
  011e8	e8 00 00 00 00	 call	 _OP_Sleep

; 3664 : 
; 3665 :         /**************************************************************/
; 3666 :         /*  Get the current audio position.                           */
; 3667 :         /**************************************************************/
; 3668 : 
; 3669 :         mmStatus = PA_GetPosition( pPlayAudio,
; 3670 :                                    &dwCurrentPosition,
; 3671 :                                    FALSE );

  011ed	8d 4c 24 38	 lea	 ecx, DWORD PTR _dwCurrentPosition$[esp+48]
  011f1	6a 00		 push	 0
  011f3	51		 push	 ecx
  011f4	56		 push	 esi
  011f5	e8 00 00 00 00	 call	 _PA_GetPosition
  011fa	83 c4 10	 add	 esp, 16			; 00000010H

; 3672 : 
; 3673 :         if ( mmStatus )

  011fd	85 c0		 test	 eax, eax
  011ff	74 0c		 je	 SHORT $L70731

; 3674 :         {
; 3675 : #ifdef AUD_DEBUG
; 3676 : 		  OutputDebugString("TimerThreadMain: PA_GetPosition failed {2}\n");
; 3677 : #endif
; 3678 :           ReportStatusToApplication( pPlayAudio,
; 3679 :                                      PA_SYNC_ERROR,
; 3680 :                                      mmStatus );

  01201	50		 push	 eax
  01202	6a 05		 push	 5
  01204	56		 push	 esi
  01205	e8 00 00 00 00	 call	 _ReportStatusToApplication
  0120a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L70731:
  0120d	39 6c 24 34	 cmp	 DWORD PTR _dwCurrentPosition$[esp+44], ebp
  01211	72 a5		 jb	 SHORT $L70728
$L70729:

; 3681 :         }
; 3682 :       }
; 3683 : 
; 3684 :       /****************************************************************/
; 3685 :       /*  Report the mark to the application.                         */
; 3686 :       /****************************************************************/
; 3687 : 
; 3688 :       OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  01213	8b 96 88 00 00
	00		 mov	 edx, DWORD PTR [esi+136]
  01219	52		 push	 edx
  0121a	e8 00 00 00 00	 call	 _OP_LockMutex

; 3689 : 
; 3690 :       pSyncMark = pPlayAudio->pSyncMarkList;

  0121f	8b 86 98 00 00
	00		 mov	 eax, DWORD PTR [esi+152]
  01225	83 c4 04	 add	 esp, 4

; 3691 : 
; 3692 :       if (( pSyncMark != NULL )
; 3693 :         && (( dwCurrentPosition >= pSyncMark->dwPosition )
; 3694 :         || ( uiWaitTime >= POSITION_COUNT_WRAP_TIME ))
; 3695 :         && ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )
; 3696 :         && ( ! pPlayAudio->bTimerThreadReset ))

  01228	85 c0		 test	 eax, eax
  0122a	74 50		 je	 SHORT $L70733
  0122c	8b 4c 24 34	 mov	 ecx, DWORD PTR _dwCurrentPosition$[esp+44]
  01230	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  01233	3b ca		 cmp	 ecx, edx
  01235	73 08		 jae	 SHORT $L70734
  01237	81 ff 40 42 0f
	00		 cmp	 edi, 1000000		; 000f4240H
  0123d	72 3d		 jb	 SHORT $L70733
$L70734:
  0123f	39 5e 34	 cmp	 DWORD PTR [esi+52], ebx
  01242	75 38		 jne	 SHORT $L70733
  01244	8b 4e 68	 mov	 ecx, DWORD PTR [esi+104]
  01247	85 c9		 test	 ecx, ecx
  01249	75 31		 jne	 SHORT $L70733

; 3697 :       {
; 3698 :         /**************************************************************/
; 3699 :         /*  Remove the pointer to the next synchronization mark       */
; 3700 :         /*  structure from the top of the synchronization mark        */
; 3701 :         /*  linked list.                                              */
; 3702 :         /**************************************************************/
; 3703 : 
; 3704 :         aSyncMarkTag = pSyncMark->aTag;

  0124b	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 3705 :         pNextSyncMark = pSyncMark->pLink;

  0124e	8b 18		 mov	 ebx, DWORD PTR [eax]

; 3706 : 
; 3707 :         free( pSyncMark );

  01250	50		 push	 eax
  01251	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free

; 3708 : 
; 3709 :         pPlayAudio->pSyncMarkList = pNextSyncMark;
; 3710 : 
; 3711 :         OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  01257	8b 96 88 00 00
	00		 mov	 edx, DWORD PTR [esi+136]
  0125d	89 9e 98 00 00
	00		 mov	 DWORD PTR [esi+152], ebx
  01263	52		 push	 edx
  01264	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 3712 : 
; 3713 :         /**************************************************************/
; 3714 :         /*  Report the synchronization mark.                          */
; 3715 :         /**************************************************************/
; 3716 : 
; 3717 :         ReportStatusToApplication( pPlayAudio,
; 3718 :                                    PA_SYNC_MARK,
; 3719 :                                    aSyncMarkTag );

  01269	57		 push	 edi
  0126a	6a 04		 push	 4
  0126c	56		 push	 esi
  0126d	e8 00 00 00 00	 call	 _ReportStatusToApplication
  01272	83 c4 14	 add	 esp, 20			; 00000014H

; 3720 :       }
; 3721 :       else

  01275	bb 02 00 00 00	 mov	 ebx, 2
  0127a	eb 0f		 jmp	 SHORT $L70735
$L70733:

; 3722 :       {
; 3723 :         OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  0127c	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  01282	50		 push	 eax
  01283	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01288	83 c4 04	 add	 esp, 4
$L70735:
  0128b	39 5e 34	 cmp	 DWORD PTR [esi+52], ebx
  0128e	0f 84 c3 fe ff
	ff		 je	 $L70722
$L70723:

; 3724 :       }
; 3725 :     }
; 3726 : 
; 3727 :     /******************************************************************/
; 3728 :     /******************************************************************/
; 3729 :     /*  If audio is NOT playing and the system is NOT paused and      */
; 3730 :     /*  there are samples in the queue then test to see if it will    */
; 3731 :     /*  be necessary to start playing audio.                          */
; 3732 :     /******************************************************************/
; 3733 :     /******************************************************************/
; 3734 : 
; 3735 :     /******************************************************************/
; 3736 :     /*  Calculate how long to sleep.                                  */
; 3737 :     /******************************************************************/
; 3738 : 
; 3739 : 		// 22may97 tek remove KSBs NEED_FOR_SPEED.
; 3740 :     OP_LockMutex( pPlayAudio->hmxWaveFormat );

  01294	8b 8e 8c 00 00
	00		 mov	 ecx, DWORD PTR [esi+140]
  0129a	51		 push	 ecx
  0129b	e8 00 00 00 00	 call	 _OP_LockMutex

; 3741 :     uiAvgBytesPerSec = pPlayAudio->pWaveFormat->nAvgBytesPerSec;

  012a0	8b 96 9c 00 00
	00		 mov	 edx, DWORD PTR [esi+156]

; 3742 :     OP_UnlockMutex( pPlayAudio->hmxWaveFormat );

  012a6	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  012ac	50		 push	 eax
  012ad	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
  012b0	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 3743 : 
; 3744 :     uiStartupTimeoutTime = (unsigned int)( 1000.0 *
; 3745 :       (double)(pPlayAudio->uiMinimumStartupBytes) /
; 3746 :         (double)uiAvgBytesPerSec );

  012b5	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  012b8	33 c0		 xor	 eax, eax
  012ba	89 4c 24 28	 mov	 DWORD PTR -16+[esp+56], ecx
  012be	89 44 24 2c	 mov	 DWORD PTR -16+[esp+60], eax
  012c2	df 6c 24 28	 fild	 QWORD PTR -16+[esp+56]
  012c6	89 7c 24 30	 mov	 DWORD PTR -8+[esp+56], edi
  012ca	89 44 24 34	 mov	 DWORD PTR -8+[esp+60], eax
  012ce	83 c4 08	 add	 esp, 8
  012d1	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@8@4008fa00000000000000
  012d7	df 6c 24 28	 fild	 QWORD PTR -8+[esp+48]
  012db	de f9		 fdivp	 ST(1), ST(0)
  012dd	e8 00 00 00 00	 call	 __ftol

; 3747 : 
; 3748 :     /******************************************************************/
; 3749 :     /*  Limit the total startup check wait time to 1 second.          */
; 3750 :     /******************************************************************/
; 3751 : 
; 3752 :     if ( uiStartupTimeoutTime > 1000 )

  012e2	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  012e7	89 44 24 18	 mov	 DWORD PTR _uiStartupTimeoutTime$[esp+48], eax
  012eb	76 08		 jbe	 SHORT $L71380

; 3753 :     {
; 3754 :       uiStartupTimeoutTime = 1000;

  012ed	c7 44 24 18 e8
	03 00 00	 mov	 DWORD PTR _uiStartupTimeoutTime$[esp+48], 1000 ; 000003e8H
$L71380:

; 3755 :     }
; 3756 : 
; 3757 :     while (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )
; 3758 :       && ( ! pPlayAudio->bPaused )
; 3759 :       && ( pPlayAudio->pPlayAudioRing->iQueueCount > 0 ))

  012f5	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  012f8	85 c0		 test	 eax, eax
  012fa	0f 85 a1 00 00
	00		 jne	 $L71383
  01300	eb 09		 jmp	 SHORT $L70741
$L71391:
  01302	8b 6c 24 14	 mov	 ebp, DWORD PTR _dwSyncMarkPosition$[esp+48]
  01306	bb 02 00 00 00	 mov	 ebx, 2
$L70741:
  0130b	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  0130e	85 c0		 test	 eax, eax
  01310	0f 85 8b 00 00
	00		 jne	 $L71383
  01316	8b 96 94 00 00
	00		 mov	 edx, DWORD PTR [esi+148]
  0131c	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0131f	85 c0		 test	 eax, eax
  01321	7e 7e		 jle	 SHORT $L71383

; 3760 :     {
; 3761 : 		// 22may97 tek remove KSBs NEED_FOR_SPEED.
; 3762 :       /****************************************************************/
; 3763 :       /*  Wait for "uiStartupTimeoutTime" milliseconds.               */
; 3764 :       /****************************************************************/
; 3765 : 
; 3766 :       uiElapsedTime = 0;
; 3767 :       uiFlowCheckTime = 0;
; 3768 :       uiLastQueueCount = pPlayAudioRing->iQueueCount;

  01323	8b 44 24 10	 mov	 eax, DWORD PTR _pPlayAudioRing$[esp+48]
  01327	33 ed		 xor	 ebp, ebp
  01329	33 ff		 xor	 edi, edi
  0132b	8b 58 18	 mov	 ebx, DWORD PTR [eax+24]

; 3769 : 
; 3770 :       while (( uiElapsedTime < uiStartupTimeoutTime )
; 3771 :         && ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE ))

  0132e	8b 44 24 18	 mov	 eax, DWORD PTR _uiStartupTimeoutTime$[esp+48]
  01332	85 c0		 test	 eax, eax
  01334	76 31		 jbe	 SHORT $L71382
$L70744:
  01336	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  01339	85 c0		 test	 eax, eax
  0133b	75 5b		 jne	 SHORT $L71394

; 3772 :       {
; 3773 :         OP_Sleep( TIMER_SLEEP_TIME_IN_MSEC );

  0133d	6a 0a		 push	 10			; 0000000aH
  0133f	e8 00 00 00 00	 call	 _OP_Sleep

; 3774 : 
; 3775 :         uiElapsedTime += TIMER_SLEEP_TIME_IN_MSEC;
; 3776 :         uiFlowCheckTime += TIMER_SLEEP_TIME_IN_MSEC;

  01344	83 c7 0a	 add	 edi, 10			; 0000000aH
  01347	83 c4 04	 add	 esp, 4
  0134a	83 c5 0a	 add	 ebp, 10			; 0000000aH

; 3777 : 
; 3778 :         /**************************************************************/
; 3779 :         /*  If the queue input flow rate to the PA_Queue() function   */
; 3780 :         /*  has been slower than real-time over the entire            */
; 3781 :         /*  QUEUE_FLOW_CHECK_TIME_IN_MSEC interval then start the     */
; 3782 :         /*  open now.                                                 */
; 3783 :         /**************************************************************/
; 3784 : 
; 3785 :         if ( uiFlowCheckTime > QUEUE_FLOW_CHECK_TIME_IN_MSEC )

  0134d	83 ff 64	 cmp	 edi, 100		; 00000064H
  01350	76 0f		 jbe	 SHORT $L70746

; 3786 :         {
; 3787 :           uiCurrentQueueCount = (unsigned int)pPlayAudioRing->iQueueCount;

  01352	8b 4c 24 10	 mov	 ecx, DWORD PTR _pPlayAudioRing$[esp+48]
  01356	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]

; 3788 : 
; 3789 :           if ( uiCurrentQueueCount == uiLastQueueCount )

  01359	3b c3		 cmp	 eax, ebx
  0135b	74 0a		 je	 SHORT $L71382

; 3790 :           {
; 3791 :             break;
; 3792 :           }
; 3793 : 
; 3794 :           uiLastQueueCount = uiCurrentQueueCount;

  0135d	8b d8		 mov	 ebx, eax

; 3795 :           uiFlowCheckTime = 0;

  0135f	33 ff		 xor	 edi, edi
$L70746:
  01361	3b 6c 24 18	 cmp	 ebp, DWORD PTR _uiStartupTimeoutTime$[esp+48]
  01365	72 cf		 jb	 SHORT $L70744
$L71382:

; 3796 :         }
; 3797 :       }
; 3798 : 
; 3799 :       /****************************************************************/
; 3800 :       /*  If the audio device starts playing then exit this loop.     */
; 3801 :       /****************************************************************/
; 3802 : 
; 3803 :       if ( pPlayAudio->dwAudioDeviceState != AUDIO_DEVICE_INACTIVE )

  01367	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0136a	85 c0		 test	 eax, eax
  0136c	75 2a		 jne	 SHORT $L71394

; 3804 :       {
; 3805 :         break;
; 3806 :       }
; 3807 : 
; 3808 :       /****************************************************************/
; 3809 :       /*  If audio is still NOT playing and there are samples in the  */
; 3810 :       /*  audio queue then start playing audio. It does not matter    */
; 3811 :       /*  that all of the tests this section of code are not          */
; 3812 :       /*  protected by mutex's. This is because an unnecessary        */
; 3813 :       /*  ID_Open_Wave_Output_Device messages will be discarded in    */
; 3814 :       /*  the "play audio" thread.                                    */
; 3815 :       /****************************************************************/
; 3816 : 
; 3817 :       if (( pPlayAudio->dwAudioDeviceState != AUDIO_DEVICE_ACTIVE )
; 3818 :         && ( pPlayAudioRing->iQueueCount > 0 ))

  0136e	8b 54 24 10	 mov	 edx, DWORD PTR _pPlayAudioRing$[esp+48]
  01372	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  01375	85 c0		 test	 eax, eax
  01377	7e 0d		 jle	 SHORT $L70750

; 3819 :       {
; 3820 :         SendPlayAudioMessage( pPlayAudio,
; 3821 :                               ID_Open_Wave_Output_Device,
; 3822 :                               0L );

  01379	6a 00		 push	 0
  0137b	6a 00		 push	 0
  0137d	56		 push	 esi
  0137e	e8 00 00 00 00	 call	 _SendPlayAudioMessage
  01383	83 c4 0c	 add	 esp, 12			; 0000000cH
$L70750:

; 3823 :       }
; 3824 : 
; 3825 :       /****************************************************************/
; 3826 :       /*  Test for thread shutdown. Shutdown is caused by the         */
; 3827 :       /*  PA_DestroyPlayHandle() function.                            */
; 3828 :       /****************************************************************/
; 3829 : 
; 3830 :       if ( pPlayAudio->bTimerExit )

  01386	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  01389	85 c0		 test	 eax, eax
  0138b	75 0b		 jne	 SHORT $L71394
  0138d	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  01390	85 c0		 test	 eax, eax
  01392	0f 84 6a ff ff
	ff		 je	 $L71391
$L71394:

; 3755 :     }
; 3756 : 
; 3757 :     while (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )
; 3758 :       && ( ! pPlayAudio->bPaused )
; 3759 :       && ( pPlayAudio->pPlayAudioRing->iQueueCount > 0 ))

  01398	8b 6c 24 14	 mov	 ebp, DWORD PTR _dwSyncMarkPosition$[esp+48]
  0139c	bb 02 00 00 00	 mov	 ebx, 2
$L71383:

; 3831 :       {
; 3832 :         break;
; 3833 :       }
; 3834 :     }
; 3835 : 
; 3836 :     /******************************************************************/
; 3837 :     /*  This thread is blocked if there are no synchronization marks  */
; 3838 :     /*  waiting to be processed or the audio is paused and either     */
; 3839 :     /*  the audio device is active or the queue count is zero         */
; 3840 :     /******************************************************************/
; 3841 : 
; 3842 : 	//tek 07nov97 bats508
; 3843 : 	// as originally written, this code wants to take all the mutexes
; 3844 : 	// involved; it really need not do that, because if we make a
; 3845 : 	// mistake here we can always check before exit and fix it.
; 3846 :     OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  013a1	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  013a7	50		 push	 eax
  013a8	e8 00 00 00 00	 call	 _OP_LockMutex

; 3847 :     OP_LockMutex( pPlayAudio->hmxPauseFlag );

  013ad	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  013b3	51		 push	 ecx
  013b4	e8 00 00 00 00	 call	 _OP_LockMutex

; 3848 : 
; 3849 :     if ((( pPlayAudio->pSyncMarkList == NULL )
; 3850 :       || ( pPlayAudio->bPaused ))
; 3851 :       && ( ! pPlayAudio->bTimerExit ))

  013b9	8b 86 98 00 00
	00		 mov	 eax, DWORD PTR [esi+152]
  013bf	83 c4 08	 add	 esp, 8
  013c2	85 c0		 test	 eax, eax
  013c4	74 0b		 je	 SHORT $L70754
  013c6	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  013c9	85 c0		 test	 eax, eax
  013cb	0f 84 ea 00 00
	00		 je	 $L70753
$L70754:
  013d1	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  013d4	85 c0		 test	 eax, eax
  013d6	0f 85 df 00 00
	00		 jne	 $L70753

; 3852 :     {
; 3853 : 	  // let these go here.
; 3854 :       OP_UnlockMutex( pPlayAudio->hmxPauseFlag );

  013dc	8b 96 84 00 00
	00		 mov	 edx, DWORD PTR [esi+132]
  013e2	52		 push	 edx
  013e3	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 3855 :       OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  013e8	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  013ee	50		 push	 eax
  013ef	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 3856 :       OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  013f4	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  013f7	51		 push	 ecx
  013f8	e8 00 00 00 00	 call	 _OP_LockMutex

; 3857 : 	  // tek 07nov97 bats508
; 3858 : 	  // don't need to hold the queue count mutex this early; move
; 3859 : 	  // it into the if branch
; 3860 :       //OP_LockMutex( pPlayAudio->hmxQueueCount );
; 3861 : 
; 3862 :       if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )

  013fd	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  01400	83 c4 0c	 add	 esp, 12			; 0000000cH
  01403	3b c3		 cmp	 eax, ebx
  01405	75 16		 jne	 SHORT $L70755

; 3863 :       {
; 3864 :         OP_ResetEvent( pPlayAudio->hevTimerThreadActive );

  01407	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0140a	52		 push	 edx
  0140b	e8 00 00 00 00	 call	 _OP_ResetEvent
  01410	83 c4 04	 add	 esp, 4

; 3865 : 		bDidBlock = TRUE; // tek 29jan98

  01413	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _bDidBlock$[esp+48], 1

; 3866 :       }
; 3867 :       else

  0141b	eb 37		 jmp	 SHORT $L70756
$L70755:

; 3868 :       {
; 3869 :       OP_LockMutex( pPlayAudio->hmxQueueCount );

  0141d	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  01420	50		 push	 eax
  01421	e8 00 00 00 00	 call	 _OP_LockMutex

; 3870 :         if ( pPlayAudioRing->iQueueCount == 0 )

  01426	8b 4c 24 14	 mov	 ecx, DWORD PTR _pPlayAudioRing$[esp+52]
  0142a	83 c4 04	 add	 esp, 4
  0142d	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  01430	85 c0		 test	 eax, eax
  01432	75 14		 jne	 SHORT $L70757

; 3871 :         {
; 3872 :           OP_ResetEvent( pPlayAudio->hevTimerThreadActive );

  01434	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  01437	52		 push	 edx
  01438	e8 00 00 00 00	 call	 _OP_ResetEvent
  0143d	83 c4 04	 add	 esp, 4

; 3873 : 		  bDidBlock = TRUE; // tek 29jan98

  01440	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _bDidBlock$[esp+48], 1
$L70757:

; 3874 :         }
; 3875 : 	  // tek 07nov97 move this in closer
; 3876 :       OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  01448	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  0144b	50		 push	 eax
  0144c	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01451	83 c4 04	 add	 esp, 4
$L70756:

; 3877 :       }
; 3878 : 
; 3879 : 
; 3880 :       OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  01454	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  01457	51		 push	 ecx
  01458	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 3887 : 	}
; 3888 : 
; 3889 : 	// tek 07nov97 moved inside the if..
; 3890 :     //OP_UnlockMutex( pPlayAudio->hmxPauseFlag );
; 3891 :     //OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );
; 3892 : 
; 3893 : 
; 3894 : 	// tek 07nov97 
; 3895 : 	// now, after all that, it is (I suppose) possible that 
; 3896 : 	// something happened that might cause us to not block;
; 3897 : 	// we'll just check those cases here after the fact, and 
; 3898 : 	// unblock ourselves.
; 3899 : 	// tek 28jan98 be careful here, or we'll suck down all the CPU.
; 3900 : 	if (bDidBlock)

  0145d	8b 44 24 20	 mov	 eax, DWORD PTR _bDidBlock$[esp+52]
  01461	83 c4 04	 add	 esp, 4
  01464	85 c0		 test	 eax, eax
  01466	74 26		 je	 SHORT $L70761

; 3901 : 	{
; 3902 : 		if (   (pPlayAudio->pSyncMarkList != NULL )
; 3903 : 				 ||(   (pPlayAudioRing->iQueueCount != 0 )
; 3904 : 					&& (pPlayAudio->dwAudioDeviceState != AUDIO_DEVICE_ACTIVE)
; 3905 : 				   )
; 3906 : 		   )

  01468	8b 86 98 00 00
	00		 mov	 eax, DWORD PTR [esi+152]
  0146e	85 c0		 test	 eax, eax
  01470	75 10		 jne	 SHORT $L70762
  01472	8b 4c 24 10	 mov	 ecx, DWORD PTR _pPlayAudioRing$[esp+48]
  01476	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  01479	85 c0		 test	 eax, eax
  0147b	74 11		 je	 SHORT $L70761
  0147d	39 5e 34	 cmp	 DWORD PTR [esi+52], ebx
  01480	74 0c		 je	 SHORT $L70761
$L70762:

; 3907 : 		{
; 3908 : 			OP_SetEvent( pPlayAudio->hevTimerThreadActive );

  01482	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  01485	52		 push	 edx
  01486	e8 00 00 00 00	 call	 _OP_SetEvent
  0148b	83 c4 04	 add	 esp, 4
$L70761:

; 3909 : 		}
; 3910 : 	}
; 3911 : 
; 3912 :     /******************************************************************/
; 3913 :     /*  Wait for the thread to unblock.                               */
; 3914 :     /******************************************************************/
; 3915 : 
; 3916 :     OP_WaitForEvent( pPlayAudio->hevTimerThreadActive, OP_INFINITE );

  0148e	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  01491	6a ff		 push	 -1
  01493	50		 push	 eax
  01494	e8 00 00 00 00	 call	 _OP_WaitForEvent

; 3917 : 
; 3918 :     /******************************************************************/
; 3919 :     /*  Test for thread shutdown. Shutdown is caused by the           */
; 3920 :     /*  PA_DestroyPlayHandle() function.                              */
; 3921 :     /******************************************************************/
; 3922 : 
; 3923 :     if ( pPlayAudio->bTimerExit )

  01499	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0149c	83 c4 08	 add	 esp, 8
  0149f	85 c0		 test	 eax, eax
  014a1	0f 84 2f fc ff
	ff		 je	 $L70710
  014a7	5f		 pop	 edi
  014a8	5b		 pop	 ebx
$L71385:

; 3924 :     {
; 3925 :       break;
; 3926 :     }
; 3927 :   }
; 3928 : 
; 3929 :   /********************************************************************/
; 3930 :   /*  Exit the thread.                                                */
; 3931 :   /********************************************************************/
; 3932 : 
; 3933 :   OP_ExitThread( 0 );

  014a9	6a 00		 push	 0
  014ab	e8 00 00 00 00	 call	 _OP_ExitThread
  014b0	83 c4 04	 add	 esp, 4

; 3934 : 
; 3935 :   OP_THREAD_RETURN;

  014b3	33 c0		 xor	 eax, eax
  014b5	5e		 pop	 esi
  014b6	5d		 pop	 ebp

; 3936 : }

  014b7	83 c4 20	 add	 esp, 32			; 00000020H
  014ba	c3		 ret	 0
$L70753:

; 3881 :     }
; 3882 : 	else
; 3883 : 	{
; 3884 : 		// tek 07nov97 gotta let these go..
; 3885 :     OP_UnlockMutex( pPlayAudio->hmxPauseFlag );

  014bb	8b 96 84 00 00
	00		 mov	 edx, DWORD PTR [esi+132]
  014c1	52		 push	 edx
  014c2	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 3886 :     OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  014c7	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  014cd	50		 push	 eax
  014ce	e8 00 00 00 00	 call	 _OP_UnlockMutex
  014d3	83 c4 08	 add	 esp, 8

; 3887 : 	}
; 3888 : 
; 3889 : 	// tek 07nov97 moved inside the if..
; 3890 :     //OP_UnlockMutex( pPlayAudio->hmxPauseFlag );
; 3891 :     //OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );
; 3892 : 
; 3893 : 
; 3894 : 	// tek 07nov97 
; 3895 : 	// now, after all that, it is (I suppose) possible that 
; 3896 : 	// something happened that might cause us to not block;
; 3897 : 	// we'll just check those cases here after the fact, and 
; 3898 : 	// unblock ourselves.
; 3899 : 	// tek 28jan98 be careful here, or we'll suck down all the CPU.
; 3900 : 	if (bDidBlock)

  014d6	eb b6		 jmp	 SHORT $L70761
_TimerThreadMain ENDP
_uiMessage$ = -12
_pPlayAudio$ = -4
_aParam$ = -8
_PlayAudioThreadMain PROC NEAR

; 3955 :   unsigned int uiResult;
; 3956 :   unsigned int uiMessage;
; 3957 :   HPLAY_AUDIO_T pPlayAudio;
; 3958 :   ATYPE_T aParam;
; 3959 : 
; 3960 :   /********************************************************************/
; 3961 :   /*  Audio message loop.                                             */
; 3962 :   /********************************************************************/
; 3963 : 
; 3964 :   pShm_t->bGlobalPlayAudioThreadExit = FALSE;

  014e0	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  014e5	83 ec 0c	 sub	 esp, 12			; 0000000cH
  014e8	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 3965 : 
; 3966 :   while( ! pShm_t->bGlobalPlayAudioThreadExit )

  014ef	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  014f4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  014f7	85 c9		 test	 ecx, ecx
  014f9	75 6d		 jne	 SHORT $L70773
$L70772:

; 3967 :   {
; 3968 :     ReadMessageQueue( pShm_t->pGlobalPlayAudioMessageQueue,
; 3969 :                       (LPATYPE_T)&pPlayAudio,
; 3970 :                       (LPATYPE_T)&uiMessage,
; 3971 :                       &aParam );

  014fb	8d 4c 24 04	 lea	 ecx, DWORD PTR _aParam$[esp+12]
  014ff	8d 54 24 00	 lea	 edx, DWORD PTR _uiMessage$[esp+12]
  01503	51		 push	 ecx
  01504	52		 push	 edx
  01505	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  01508	8d 4c 24 10	 lea	 ecx, DWORD PTR _pPlayAudio$[esp+20]
  0150c	51		 push	 ecx
  0150d	52		 push	 edx
  0150e	e8 00 00 00 00	 call	 _ReadMessageQueue

; 3972 :     uiResult = PlayAudioProcedure( pPlayAudio, uiMessage, aParam );

  01513	8b 44 24 14	 mov	 eax, DWORD PTR _aParam$[esp+28]
  01517	8b 4c 24 10	 mov	 ecx, DWORD PTR _uiMessage$[esp+28]
  0151b	8b 54 24 18	 mov	 edx, DWORD PTR _pPlayAudio$[esp+28]
  0151f	50		 push	 eax
  01520	51		 push	 ecx
  01521	52		 push	 edx
  01522	e8 00 00 00 00	 call	 _PlayAudioProcedure

; 3973 :     /******************************************************************/
; 3974 :     /*  If this is not a driver message then put result into the      */
; 3975 :     /*  report message queue.                                         */
; 3976 :     /******************************************************************/
; 3977 : 
; 3978 :     if  (( uiMessage != MM_WOM_OPEN )
; 3979 :       && ( uiMessage != MM_WOM_DONE )
; 3980 :       && ( uiMessage != MM_WOM_CLOSE ))

  01527	8b 4c 24 1c	 mov	 ecx, DWORD PTR _uiMessage$[esp+40]
  0152b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0152e	81 f9 bb 03 00
	00		 cmp	 ecx, 955		; 000003bbH
  01534	74 26		 je	 SHORT $L70776
  01536	81 f9 bd 03 00
	00		 cmp	 ecx, 957		; 000003bdH
  0153c	74 1e		 je	 SHORT $L70776
  0153e	81 f9 bc 03 00
	00		 cmp	 ecx, 956		; 000003bcH
  01544	74 16		 je	 SHORT $L70776

; 3981 :     {
; 3982 :       WriteMessageQueue( pShm_t->pGlobalReportMessageQueue,
; 3983 :                          (ATYPE_T)0,
; 3984 :                          (ATYPE_T)0,
; 3985 :                          (ATYPE_T)uiResult );

  01546	50		 push	 eax
  01547	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  0154c	6a 00		 push	 0
  0154e	6a 00		 push	 0
  01550	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  01553	51		 push	 ecx
  01554	e8 00 00 00 00	 call	 _WriteMessageQueue
  01559	83 c4 10	 add	 esp, 16			; 00000010H
$L70776:
  0155c	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  01561	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01564	85 c9		 test	 ecx, ecx
  01566	74 93		 je	 SHORT $L70772
$L70773:

; 3986 :     }
; 3987 :   }
; 3988 :   
; 3989 :   /********************************************************************/
; 3990 :   /*  Exit the thread.                                                */
; 3991 :   /********************************************************************/
; 3992 :  
; 3993 :   OP_ExitThread( 0 );

  01568	6a 00		 push	 0
  0156a	e8 00 00 00 00	 call	 _OP_ExitThread

; 3994 :   OP_THREAD_RETURN;

  0156f	33 c0		 xor	 eax, eax

; 3995 : }

  01571	83 c4 10	 add	 esp, 16			; 00000010H
  01574	c3		 ret	 0
_PlayAudioThreadMain ENDP
_pPlayAudio$ = 8
_uiMessage$ = 12
_aParam$ = 16
_PlayAudioProcedure PROC NEAR

; 4013 :   switch( uiMessage )
; 4014 :   {

  01580	8b 44 24 08	 mov	 eax, DWORD PTR _uiMessage$[esp-4]
  01584	3d bb 03 00 00	 cmp	 eax, 955		; 000003bbH
  01589	0f 87 e3 00 00
	00		 ja	 $L71402
  0158f	0f 84 ca 00 00
	00		 je	 $L70791
  01595	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  01598	0f 87 de 00 00
	00		 ja	 $L70810
  0159e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L71404[eax*4]
$L70794:

; 4043 : 
; 4044 :   /********************************************************************/
; 4045 :   /*  This message is sent by the the PA_Queue() function or by the   */
; 4046 :   /*  timer thread, "TimerThreadMain()", to open the wave output      */
; 4047 :   /*  device.                                                         */
; 4048 :   /********************************************************************/
; 4049 : 
; 4050 :   case ID_Open_Wave_Output_Device:
; 4051 :     return ProcessOpenWaveOutputDeviceMessage( pPlayAudio );

  015a5	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  015a9	50		 push	 eax
  015aa	e8 00 00 00 00	 call	 _ProcessOpenWaveOutputDeviceMessage
  015af	83 c4 04	 add	 esp, 4

; 4141 : }

  015b2	c3		 ret	 0
$L70795:

; 4052 : 
; 4053 :   /********************************************************************/
; 4054 :   /*  An application uses this message to cancel audio output.        */
; 4055 :   /********************************************************************/
; 4056 : 
; 4057 :   case ID_Reset_Audio:
; 4058 :     return ProcessResetMessage( pPlayAudio );

  015b3	8b 4c 24 04	 mov	 ecx, DWORD PTR _pPlayAudio$[esp-4]
  015b7	51		 push	 ecx
  015b8	e8 00 00 00 00	 call	 _ProcessResetMessage
  015bd	83 c4 04	 add	 esp, 4

; 4141 : }

  015c0	c3		 ret	 0
$L70796:

; 4059 : 
; 4060 :   /********************************************************************/
; 4061 :   /*  An application uses this message to pause audio output.         */
; 4062 :   /********************************************************************/
; 4063 : 
; 4064 :   case ID_Pause_Audio:
; 4065 :     return ProcessPauseMessage( pPlayAudio );

  015c1	8b 54 24 04	 mov	 edx, DWORD PTR _pPlayAudio$[esp-4]
  015c5	52		 push	 edx
  015c6	e8 00 00 00 00	 call	 _ProcessPauseMessage
  015cb	83 c4 04	 add	 esp, 4

; 4141 : }

  015ce	c3		 ret	 0
$L70797:

; 4066 : 
; 4067 :   /********************************************************************/
; 4068 :   /*  An application uses this message to resume audio output.        */
; 4069 :   /********************************************************************/
; 4070 : 
; 4071 :   case ID_Resume_Audio:
; 4072 :     return ProcessResumeMessage( pPlayAudio );

  015cf	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  015d3	50		 push	 eax
  015d4	e8 00 00 00 00	 call	 _ProcessResumeMessage
  015d9	83 c4 04	 add	 esp, 4

; 4141 : }

  015dc	c3		 ret	 0
$L70798:

; 4073 : 
; 4074 :   /********************************************************************/
; 4075 :   /*  An application uses this message to set audio parameters.       */
; 4076 :   /********************************************************************/
; 4077 : 
; 4078 :   case ID_Set_Audio_Format:
; 4079 :     return ProcessSetFormatMessage( pPlayAudio,
; 4080 :                                     (LPWAVEFORMATEX)aParam );

  015dd	8b 4c 24 0c	 mov	 ecx, DWORD PTR _aParam$[esp-4]
  015e1	8b 54 24 04	 mov	 edx, DWORD PTR _pPlayAudio$[esp-4]
  015e5	51		 push	 ecx
  015e6	52		 push	 edx
  015e7	e8 00 00 00 00	 call	 _ProcessSetFormatMessage
  015ec	83 c4 08	 add	 esp, 8

; 4141 : }

  015ef	c3		 ret	 0
$L70800:

; 4081 : 
; 4082 :   /********************************************************************/
; 4083 :   /*  An application uses this message to get audio parameters.       */
; 4084 :   /********************************************************************/
; 4085 : 
; 4086 :   case ID_Get_Audio_Format:
; 4087 :     return ProcessGetFormatMessage( pPlayAudio,
; 4088 :                                     (LPWAVEFORMATEX)aParam );

  015f0	8b 44 24 0c	 mov	 eax, DWORD PTR _aParam$[esp-4]
  015f4	8b 4c 24 04	 mov	 ecx, DWORD PTR _pPlayAudio$[esp-4]
  015f8	50		 push	 eax
  015f9	51		 push	 ecx
  015fa	e8 00 00 00 00	 call	 _ProcessGetFormatMessage
  015ff	83 c4 08	 add	 esp, 8

; 4141 : }

  01602	c3		 ret	 0
$L70802:

; 4089 : 
; 4090 :   /********************************************************************/
; 4091 :   /*  An application uses this message to get the wave output device  */
; 4092 :   /*  volume.                                                         */
; 4093 :   /********************************************************************/
; 4094 : 
; 4095 :   case ID_Get_Audio_Volume:
; 4096 :     return ProcessGetVolumeMessage( pPlayAudio, (LPDWORD)aParam );

  01603	8b 54 24 0c	 mov	 edx, DWORD PTR _aParam$[esp-4]
  01607	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  0160b	52		 push	 edx
  0160c	50		 push	 eax
  0160d	e8 00 00 00 00	 call	 _ProcessGetVolumeMessage
  01612	83 c4 08	 add	 esp, 8

; 4141 : }

  01615	c3		 ret	 0
$L70804:

; 4097 : 
; 4098 :   /********************************************************************/
; 4099 :   /*  An application uses this message to set the wave output device  */
; 4100 :   /*  volume.                                                         */
; 4101 :   /********************************************************************/
; 4102 : 
; 4103 :   case ID_Set_Audio_Volume:
; 4104 :     return ProcessSetVolumeMessage( pPlayAudio, (DWORD)aParam );

  01616	8b 4c 24 0c	 mov	 ecx, DWORD PTR _aParam$[esp-4]
  0161a	8b 54 24 04	 mov	 edx, DWORD PTR _pPlayAudio$[esp-4]
  0161e	51		 push	 ecx
  0161f	52		 push	 edx
  01620	e8 00 00 00 00	 call	 _ProcessSetVolumeMessage
  01625	83 c4 08	 add	 esp, 8

; 4141 : }

  01628	c3		 ret	 0
$L70806:

; 4105 : 
; 4106 :   /********************************************************************/
; 4107 :   /*  An application uses this message to mark the current audio      */
; 4108 :   /*  position.                                                       */
; 4109 :   /********************************************************************/
; 4110 : 
; 4111 :   case ID_Synchronization_Mark:
; 4112 :     return ProcessSynchronizationMarkMessage( pPlayAudio, aParam );

  01629	8b 44 24 0c	 mov	 eax, DWORD PTR _aParam$[esp-4]
  0162d	8b 4c 24 04	 mov	 ecx, DWORD PTR _pPlayAudio$[esp-4]
  01631	50		 push	 eax
  01632	51		 push	 ecx
  01633	e8 00 00 00 00	 call	 _ProcessSynchronizationMarkMessage
  01638	83 c4 08	 add	 esp, 8

; 4141 : }

  0163b	c3		 ret	 0
$L70807:

; 4113 : 
; 4114 :   /********************************************************************/
; 4115 :   /*  An application uses this message to get the position of the     */
; 4116 :   /*  last sample played by the wave output device.                   */
; 4117 :   /********************************************************************/
; 4118 : 
; 4119 :   case ID_Get_Audio_Position:
; 4120 :     return ProcessGetPositionMessage( pPlayAudio, (LPDWORD)aParam );

  0163c	8b 54 24 0c	 mov	 edx, DWORD PTR _aParam$[esp-4]
  01640	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  01644	52		 push	 edx
  01645	50		 push	 eax
  01646	e8 00 00 00 00	 call	 _ProcessGetPositionMessage
  0164b	83 c4 08	 add	 esp, 8

; 4141 : }

  0164e	c3		 ret	 0
$L70809:

; 4121 : 
; 4122 :   /********************************************************************/
; 4123 :   /*  The ID_Destroy_Message is used to shut down the audio thread.   */
; 4124 :   /********************************************************************/
; 4125 : 
; 4126 :   case ID_Destroy_Message:
; 4127 :     pShm_t->bGlobalPlayAudioThreadExit = TRUE;

  0164f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t

; 4128 : 
; 4129 :     break;
; 4130 : 
; 4131 :   /********************************************************************/
; 4132 :   /*  Default message processing. This should never execute.          */
; 4133 :   /********************************************************************/
; 4134 : 
; 4135 :   default:
; 4136 : 
; 4137 :     break;
; 4138 :   }
; 4139 : 
; 4140 :   return 0;

  01655	33 c0		 xor	 eax, eax
  01657	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1

; 4141 : }

  0165e	c3		 ret	 0
$L70791:

; 4015 :   
; 4016 :   /********************************************************************/
; 4017 :   /*  The MM_WOM_OPEN message is received after the waveOutOpen()     */
; 4018 :   /*  function opens the waveform output device.                      */
; 4019 :   /********************************************************************/
; 4020 : 
; 4021 :   case MM_WOM_OPEN:
; 4022 :     return Process_MM_WOM_OPEN_Message( pPlayAudio, aParam );

  0165f	8b 54 24 0c	 mov	 edx, DWORD PTR _aParam$[esp-4]
  01663	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  01667	52		 push	 edx
  01668	50		 push	 eax
  01669	e8 00 00 00 00	 call	 _Process_MM_WOM_OPEN_Message
  0166e	83 c4 08	 add	 esp, 8

; 4141 : }

  01671	c3		 ret	 0
$L71402:

; 4013 :   switch( uiMessage )
; 4014 :   {

  01672	2d bc 03 00 00	 sub	 eax, 956		; 000003bcH
  01677	74 19		 je	 SHORT $L70793
  01679	48		 dec	 eax
  0167a	74 03		 je	 SHORT $L70792
$L70810:

; 4128 : 
; 4129 :     break;
; 4130 : 
; 4131 :   /********************************************************************/
; 4132 :   /*  Default message processing. This should never execute.          */
; 4133 :   /********************************************************************/
; 4134 : 
; 4135 :   default:
; 4136 : 
; 4137 :     break;
; 4138 :   }
; 4139 : 
; 4140 :   return 0;

  0167c	33 c0		 xor	 eax, eax

; 4141 : }

  0167e	c3		 ret	 0
$L70792:

; 4023 : 
; 4024 :   /********************************************************************/
; 4025 :   /*  The MM_WOM_DONE message is received when a buffer queued by the */
; 4026 :   /*  waveOutWrite() function has been played.                        */
; 4027 :   /********************************************************************/
; 4028 : 
; 4029 :   case MM_WOM_DONE:
; 4030 :     return Process_MM_WOM_DONE_Message( pPlayAudio, aParam );

  0167f	8b 4c 24 0c	 mov	 ecx, DWORD PTR _aParam$[esp-4]
  01683	8b 54 24 04	 mov	 edx, DWORD PTR _pPlayAudio$[esp-4]
  01687	51		 push	 ecx
  01688	52		 push	 edx
  01689	e8 00 00 00 00	 call	 _Process_MM_WOM_DONE_Message
  0168e	83 c4 08	 add	 esp, 8

; 4141 : }

  01691	c3		 ret	 0
$L70793:

; 4031 : 
; 4032 :   /********************************************************************/
; 4033 :   /*  The MM_WOM_CLOSE message is received when the waveOutClose()    */
; 4034 :   /*  function completes closing the waveform output device.          */
; 4035 :   /*  pPlayAudio->dwAudioDeviceState is set to                        */
; 4036 :   /*  AUDIO_DEVICE_INACTIVE in the                                    */
; 4037 :   /*  Process_Process_MM_WOM_DONE_Message() function after the call   */
; 4038 :   /*  to the waveOutClose() function.                                 */
; 4039 :   /********************************************************************/
; 4040 : 
; 4041 :   case MM_WOM_CLOSE:
; 4042 :     return Process_MM_WOM_CLOSE_Message( pPlayAudio );

  01692	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  01696	50		 push	 eax
  01697	e8 00 00 00 00	 call	 _Process_MM_WOM_CLOSE_Message
  0169c	83 c4 04	 add	 esp, 4

; 4141 : }

  0169f	c3		 ret	 0
$L71404:
  016a0	00 00 00 00	 DD	 $L70794
  016a4	00 00 00 00	 DD	 $L70795
  016a8	00 00 00 00	 DD	 $L70796
  016ac	00 00 00 00	 DD	 $L70797
  016b0	00 00 00 00	 DD	 $L70798
  016b4	00 00 00 00	 DD	 $L70800
  016b8	00 00 00 00	 DD	 $L70804
  016bc	00 00 00 00	 DD	 $L70802
  016c0	00 00 00 00	 DD	 $L70806
  016c4	00 00 00 00	 DD	 $L70807
  016c8	00 00 00 00	 DD	 $L70809
_PlayAudioProcedure ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutGetID@8:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_uiSelectedDeviceID$ = 8
_Process_MM_WOM_OPEN_Message PROC NEAR

; 4173 : {

  016d0	56		 push	 esi

; 4174 :   unsigned int uiSelectedDeviceID;
; 4175 :   MMRESULT mmStatus;
; 4176 : #ifdef AUD_DEBUG //tek 13may97
; 4177 :   {
; 4178 : 		  char  szTemp[256]="";
; 4179 : 		  sprintf(szTemp,"ProcWOMOPEN: outstanding now %d at %08lu\n",
; 4180 : 			  pPlayAudio->iOutstandingBuffers,timeGetTime());
; 4181 : 		  OutputDebugString(szTemp);
; 4182 : 		  if ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )
; 4183 : 		  {
; 4184 : 			  sprintf(szTemp,"ProcWOMOPEN: PA_OWN_DEVICE is SET\n");
; 4185 : 		  }
; 4186 : 		  else
; 4187 : 		  {
; 4188 : 			  sprintf(szTemp,"ProcWOMOPEN: PA_OWN_DEVICE is NOT set\n");
; 4189 : 		  }
; 4190 : 		  OutputDebugString(szTemp);
; 4191 :   }
; 4192 : #endif //AUD_DEBUG
; 4193 : 
; 4194 :   /********************************************************************/
; 4195 :   /*  It is NOT possible that the selected device ID is equal to      */
; 4196 :   /*  WAVE_MAPPER because the DetermineDeviceID() function will have  */
; 4197 :   /*  already set the selected device ID. This legacy code provides   */
; 4198 :   /*  another check of the device ID in case a strange error occurs.  */
; 4199 :   /********************************************************************/
; 4200 : 
; 4201 :   if ( pPlayAudio->uiSelectedDeviceID == (unsigned int)WAVE_MAPPER )

  016d1	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  016d5	83 7e 20 ff	 cmp	 DWORD PTR [esi+32], -1
  016d9	75 50		 jne	 SHORT $L70824

; 4202 :   {
; 4203 :     LOCK_MME_CALL( waveOutGetID( pPlayAudio->hWaveOut,
; 4204 :                                  &uiSelectedDeviceID ))

  016db	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  016de	8d 44 24 08	 lea	 eax, DWORD PTR _uiSelectedDeviceID$[esp]
  016e2	50		 push	 eax
  016e3	51		 push	 ecx
  016e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetID@8

; 4205 : 
; 4206 :     /******************************************************************/
; 4207 :     /*  Attempt to fix BUG in MARCH 1993 Beta version of Windows/NT.  */
; 4208 :     /*  If WAVE_MAPPER was the device ID when the waveOutOpen()       */
; 4209 :     /*  function was called and a valid hWaveOut is passed to the     */
; 4210 :     /*  waveOutGetID() function then it returns WAVE_MAPPER instead   */
; 4211 :     /*  of the device ID of the wave out device !                     */
; 4212 :     /*  If WAVE_MAPPER is used, then hope that the device ID is zero. */
; 4213 :     /******************************************************************/
; 4214 : 
; 4215 :     if ( uiSelectedDeviceID == (unsigned int)WAVE_MAPPER )

  016ea	83 7c 24 08 ff	 cmp	 DWORD PTR _uiSelectedDeviceID$[esp], -1
  016ef	75 08		 jne	 SHORT $L70823

; 4216 :     {
; 4217 :       uiSelectedDeviceID = 0;

  016f1	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR _uiSelectedDeviceID$[esp], 0
$L70823:

; 4218 :     }
; 4219 : 
; 4220 :     /******************************************************************/
; 4221 :     /*  Save the selected device ID in the handle.                    */
; 4222 :     /******************************************************************/
; 4223 : 
; 4224 :     OP_LockMutex( pPlayAudio->hmxSelectedDeviceID );

  016f9	8b 56 74	 mov	 edx, DWORD PTR [esi+116]
  016fc	52		 push	 edx
  016fd	e8 00 00 00 00	 call	 _OP_LockMutex

; 4225 :     pPlayAudio->uiSelectedDeviceID = uiSelectedDeviceID;
; 4226 :     OP_UnlockMutex( pPlayAudio->hmxSelectedDeviceID );

  01702	8b 4e 74	 mov	 ecx, DWORD PTR [esi+116]
  01705	8b 44 24 0c	 mov	 eax, DWORD PTR _uiSelectedDeviceID$[esp+4]
  01709	51		 push	 ecx
  0170a	89 46 20	 mov	 DWORD PTR [esi+32], eax
  0170d	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 4227 : 
; 4228 :     /******************************************************************/
; 4229 :     /*  Set the dwDeviceSupport member of the play audio handle       */
; 4230 :     /*  pointed to by "pPlayAudio" to the dwSupport field of the      */
; 4231 :     /*  WAVEOUTCAPS structure. The device ID is specified by the      */
; 4232 :     /*  uiSelectedDeviceID field of the play audio handle.            */
; 4233 :     /******************************************************************/
; 4234 : 
; 4235 :     mmStatus = GetWaveOutDeviceCaps( pPlayAudio );

  01712	56		 push	 esi
  01713	e8 00 00 00 00	 call	 _GetWaveOutDeviceCaps
  01718	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4236 : 
; 4237 :     if ( mmStatus )

  0171b	85 c0		 test	 eax, eax
  0171d	74 0c		 je	 SHORT $L70824

; 4238 :     {
; 4239 : #ifdef AUD_DEBUG
; 4240 : 		OutputDebugString("Process_MM_WOM_OPEN_Message: GetWaveOutDeviceCaps failed.\n");
; 4241 : #endif
; 4242 : 		ReportStatusToApplication( pPlayAudio,
; 4243 :                                  PA_GET_CAPS_ERROR,
; 4244 :                                  mmStatus );

  0171f	50		 push	 eax
  01720	6a 06		 push	 6
  01722	56		 push	 esi
  01723	e8 00 00 00 00	 call	 _ReportStatusToApplication
  01728	83 c4 0c	 add	 esp, 12			; 0000000cH
$L70824:

; 4245 :     }
; 4246 :   }
; 4247 : 
; 4248 :   /********************************************************************/
; 4249 :   /*  Start Audio Playing.                                            */
; 4250 :   /********************************************************************/
; 4251 : 
; 4252 :   StartAudioPlaying( pPlayAudio );

  0172b	56		 push	 esi
  0172c	e8 00 00 00 00	 call	 _StartAudioPlaying
  01731	83 c4 04	 add	 esp, 4

; 4253 : 
; 4254 :   return FALSE;

  01734	33 c0		 xor	 eax, eax
  01736	5e		 pop	 esi

; 4255 : }

  01737	c3		 ret	 0
_Process_MM_WOM_OPEN_Message ENDP
_pPlayAudio$ = 8
_GetWaveOutDeviceCaps PROC NEAR

; 4287 : {

  01740	56		 push	 esi

; 4288 :   LPWAVEOUTCAPS pWaveOutCaps;
; 4289 :   MMRESULT mmStatus;
; 4290 : 
; 4291 :   /********************************************************************/
; 4292 :   /*  Get the wave output device capabilities.                        */
; 4293 :   /*  First allocate memory for the WAVEOUTCAPS structure.            */
; 4294 :   /********************************************************************/
; 4295 : 
; 4296 :   LOCK_MME_CALL(
; 4297 :     pWaveOutCaps = (LPWAVEOUTCAPS)ALLOCATE_SERVER_MEM(sizeof(WAVEOUTCAPS)))

  01741	6a 34		 push	 52			; 00000034H
  01743	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  01749	8b f0		 mov	 esi, eax
  0174b	83 c4 04	 add	 esp, 4

; 4298 : 
; 4299 :   if ( pWaveOutCaps == NULL )

  0174e	85 f6		 test	 esi, esi
  01750	75 07		 jne	 SHORT $L70833

; 4300 :   {
; 4301 :     return MMSYSERR_NOMEM;

  01752	b8 07 00 00 00	 mov	 eax, 7
  01757	5e		 pop	 esi

; 4322 : }

  01758	c3		 ret	 0
$L70833:
  01759	53		 push	 ebx
  0175a	57		 push	 edi

; 4302 :   }
; 4303 : 
; 4304 :   LOCK_MME_CALL(
; 4305 :     mmStatus = waveOutGetDevCaps( pPlayAudio->uiSelectedDeviceID,
; 4306 :                                   pWaveOutCaps,
; 4307 :                                   sizeof(WAVEOUTCAPS)))

  0175b	8b 7c 24 10	 mov	 edi, DWORD PTR _pPlayAudio$[esp+8]
  0175f	6a 34		 push	 52			; 00000034H
  01761	56		 push	 esi
  01762	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  01765	50		 push	 eax
  01766	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetDevCapsA@12

; 4308 : 
; 4309 :   /********************************************************************/
; 4310 :   /*  Store the device capabilities in the handle.                    */
; 4311 :   /********************************************************************/
; 4312 : 
; 4313 :   pPlayAudio->dwDeviceSupport = pWaveOutCaps->dwSupport;

  0176c	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]

; 4314 : 
; 4315 :   /********************************************************************/
; 4316 :   /*  Free memory for the WAVEOUTCAPS structure.                      */
; 4317 :   /********************************************************************/
; 4318 : 
; 4319 :   LOCK_MME_CALL( FREE_SERVER_MEM( pWaveOutCaps ))

  0176f	56		 push	 esi
  01770	8b d8		 mov	 ebx, eax
  01772	89 4f 48	 mov	 DWORD PTR [edi+72], ecx
  01775	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0177b	83 c4 04	 add	 esp, 4

; 4320 : 
; 4321 :   return mmStatus;

  0177e	8b c3		 mov	 eax, ebx
  01780	5f		 pop	 edi
  01781	5b		 pop	 ebx
  01782	5e		 pop	 esi

; 4322 : }

  01783	c3		 ret	 0
_GetWaveOutDeviceCaps ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutPause@4:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_StartAudioPlaying PROC NEAR

; 4352 : {

  01790	53		 push	 ebx
  01791	55		 push	 ebp
  01792	56		 push	 esi

; 4353 :   unsigned int uiI;
; 4354 :   unsigned int uiQueueCount=0;
; 4355 :   unsigned int uiWriteLength=0;
; 4356 :   LPPLAY_RING_T pPlayAudioRing;
; 4357 : #ifdef __linux__
; 4358 :   struct timespec tv;
; 4359 : #endif
; 4360 : 
; 4361 :   /********************************************************************/
; 4362 :   /*  Get the Queue Count. If it changes between here and the end of  */
; 4363 :   /*  this function, that's OK.                                       */
; 4364 :   /********************************************************************/
; 4365 : 
; 4366 :   pPlayAudioRing = pPlayAudio->pPlayAudioRing;

  01793	8b 74 24 10	 mov	 esi, DWORD PTR _pPlayAudio$[esp+8]
  01797	57		 push	 edi

; 4367 : 
; 4368 :   OP_LockMutex( pPlayAudio->hmxQueueCount );

  01798	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  0179b	8b be 94 00 00
	00		 mov	 edi, DWORD PTR [esi+148]
  017a1	50		 push	 eax
  017a2	e8 00 00 00 00	 call	 _OP_LockMutex

; 4369 : 
; 4370 : #ifdef AUD_DEBUG //tek 13may97
; 4371 :   {
; 4372 :     char  szTemp[256]="";
; 4373 :     sprintf(szTemp,"SAP: state=%ld QCount=%d new=%d outstanding=%d at %lu\n",
; 4374 : 	    pPlayAudio->dwAudioDeviceState,
; 4375 : 	    pPlayAudioRing->iQueueCount,
; 4376 : 	    uiQueueCount, 
; 4377 : 	    pPlayAudio->iOutstandingBuffers,
; 4378 : 	    timeGetTime()
; 4379 : 	    );
; 4380 :     OutputDebugString(szTemp);
; 4381 :     if (uiQueueCount < (pPlayAudio->uiStartupWriteLength-1))
; 4382 :       {
; 4383 : 	OutputDebugString("SAP: runt start packet?\n");
; 4384 :       }
; 4385 :     
; 4386 :   }
; 4387 : #endif //AUD_DEBUG
; 4388 :   
; 4389 :   uiQueueCount = (unsigned int)pPlayAudioRing->iQueueCount;
; 4390 :   // tek 06nov97 hold this mutex for the duration
; 4391 :   //OP_UnlockMutex( pPlayAudio->hmxQueueCount );
; 4392 : 
; 4393 :   /********************************************************************/
; 4394 :   /*  If the PA_Reset() function clears the audio queue just after    */
; 4395 :   /*  the waveOutOpen() function completes, then it is possible to    */
; 4396 :   /*  get here with no audio in the queue. In this case, close the    */
; 4397 :   /*  wave output device.                                             */
; 4398 :   /********************************************************************/
; 4399 : 
; 4400 :   if ( uiQueueCount == 0 )

  017a7	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  017aa	83 c4 04	 add	 esp, 4
  017ad	85 c0		 test	 eax, eax
  017af	75 1a		 jne	 SHORT $L70843

; 4401 :   {
; 4402 :     ClosePlayDevice( pPlayAudio );

  017b1	56		 push	 esi
  017b2	e8 00 00 00 00	 call	 _ClosePlayDevice

; 4572 : 	  }
; 4573 : 	  else
; 4574 : 	  {
; 4575 : #ifdef AUD_DEBUG
; 4576 : 		  {
; 4577 : 		    char  szTemp[256]="";
; 4578 : 		    sprintf(szTemp,"SAP: header %d (%08lx) is busy at %lu\n",
; 4579 : 			    uiI,
; 4580 : 			    pPlayAudio->ppWaveHdr[uiI],
; 4581 : 			    timeGetTime()
; 4582 : 			    );
; 4583 : 		    OutputDebugString(szTemp);
; 4584 : 		  }
; 4585 : #endif //AUD_DEBUG  
; 4586 : 	  }
; 4587 :     }
; 4588 :   }
; 4589 : #ifdef AUD_DEBUG
; 4590 :   {
; 4591 : 		  char  szTemp[256]="";
; 4592 : 		  sprintf(szTemp,"SAP: exit at %lu\n",
; 4593 : 			  timeGetTime()
; 4594 : 			  );
; 4595 : 		  OutputDebugString(szTemp);
; 4596 :   }
; 4597 : #endif //AUD_DEBUG  
; 4598 :   // finally release the mutex here.
; 4599 :   OP_UnlockMutex(pPlayAudio->hmxQueueCount);

  017b7	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  017ba	83 c4 04	 add	 esp, 4
  017bd	50		 push	 eax
  017be	e8 00 00 00 00	 call	 _OP_UnlockMutex
  017c3	83 c4 04	 add	 esp, 4
  017c6	5f		 pop	 edi
  017c7	5e		 pop	 esi
  017c8	5d		 pop	 ebp
  017c9	5b		 pop	 ebx

; 4600 : 	
; 4601 : #ifdef __linux__ 
; 4602 : //necessary for proper multithreading, this may be fixed in newer kernels
; 4603 :     tv.tv_sec=0;
; 4604 :     tv.tv_nsec=1;
; 4605 :     nanosleep(&tv,NULL);
; 4606 :     //usleep(1);
; 4607 : #endif
; 4608 : 
; 4609 :   return;
; 4610 : }

  017ca	c3		 ret	 0
$L70843:

; 4403 :   }
; 4404 :   else
; 4405 :   {
; 4406 : 	  // tek 13may97
; 4407 : 	  // we can now be re-entered after audio is actually playing; 
; 4408 : 	  // if we're using hte MME_SERVER we'll just bail out here, but
; 4409 : 	  // if not then we need to correctly atempt to send more samples.
; 4410 : 	  // we can tell if we're already running by the AudioDeviceState.
; 4411 : 
; 4412 :     if (pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE)

  017cb	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  017ce	bd 02 00 00 00	 mov	 ebp, 2
  017d3	3b c5		 cmp	 eax, ebp
  017d5	74 53		 je	 SHORT $L70847

; 4413 : 	{
; 4414 : #ifdef USE_MME_SERVER
; 4415 : 	OP_UnlockMutex(pPlayAudio->hmxQueueCount);
; 4416 : 		return;
; 4417 : #endif //USE_MME_SERVER
; 4418 : 	}
; 4419 : 	else // audio device is not active; do all the things we
; 4420 : 		 // do on startup..
; 4421 : 	{
; 4422 : 
; 4423 :     /******************************************************************/
; 4424 :     /*  Signal the application that we are starting to play audio.    */
; 4425 :     /*  Set a flag to indicate that a PA_PLAY_STOP message may be     */
; 4426 :     /*  sent. This flag is necessary in case the                      */
; 4427 :     /*  Process_MM_WOM_CLOSE() function is called after the audio     */
; 4428 :     /*  device is opened, but no audio is played (that is, the        */
; 4429 :     /*  ClosePlayDevice() function is called above. This can occur    */
; 4430 :     /*  if the timer thread and the PA_Queue() function both send     */
; 4431 :     /*  ID_Open_Wave_Output_Device messages in rapid succession.)     */
; 4432 :     /******************************************************************/
; 4433 : 
; 4434 :     ReportStatusToApplication( pPlayAudio,
; 4435 :                                PA_PLAY_START,
; 4436 :                                0 );

  017d7	bb 01 00 00 00	 mov	 ebx, 1
  017dc	6a 00		 push	 0
  017de	53		 push	 ebx
  017df	56		 push	 esi
  017e0	e8 00 00 00 00	 call	 _ReportStatusToApplication

; 4437 : 
; 4438 :     pPlayAudio->bReportPlayStop = TRUE;
; 4439 : 
; 4440 :     /******************************************************************/
; 4441 :     /*  Set the Audio Device State to AUDIO_DEVICE_ACTIVE.            */
; 4442 :     /******************************************************************/
; 4443 : 
; 4444 : 	// tek 07nov97 unfortunately, with the longer hold of the 
; 4445 : 	// QueueCount mutex, this can deadlock with TimerThreadMain.
; 4446 : 	// But, the audio device is not active, so we release the
; 4447 : 	// mutex while we're doing this, and then take it back.
; 4448 :     OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  017e5	8b 4e 78	 mov	 ecx, DWORD PTR [esi+120]
  017e8	89 5e 60	 mov	 DWORD PTR [esi+96], ebx
  017eb	51		 push	 ecx
  017ec	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 4449 :     OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  017f1	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  017f4	52		 push	 edx
  017f5	e8 00 00 00 00	 call	 _OP_LockMutex

; 4450 :     pPlayAudio->dwAudioDeviceState = AUDIO_DEVICE_ACTIVE;
; 4451 :     OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  017fa	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  017fd	89 6e 34	 mov	 DWORD PTR [esi+52], ebp
  01800	50		 push	 eax
  01801	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 4452 :     OP_LockMutex( pPlayAudio->hmxQueueCount );

  01806	8b 4e 78	 mov	 ecx, DWORD PTR [esi+120]
  01809	51		 push	 ecx
  0180a	e8 00 00 00 00	 call	 _OP_LockMutex

; 4453 : 
; 4454 :     /******************************************************************/
; 4455 :     /*  If the Audio Device State is NOT PA_OWN_DEVICE and the pause  */
; 4456 :     /*  flag is set then pause the wave output device. This is        */
; 4457 :     /*  necessary in case the pause message was received in between   */
; 4458 :     /*  the open wave out device message and the MM_WOM_OPEN message. */
; 4459 :     /******************************************************************/
; 4460 : 
; 4461 :     if ( ! ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )
; 4462 :       && ( pPlayAudio->bPaused ))

  0180f	8a 46 3c	 mov	 al, BYTE PTR [esi+60]
  01812	83 c4 1c	 add	 esp, 28			; 0000001cH
  01815	84 c3		 test	 al, bl
  01817	75 11		 jne	 SHORT $L70847
  01819	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  0181c	85 c0		 test	 eax, eax
  0181e	74 0a		 je	 SHORT $L70847

; 4463 :     {
; 4464 :       LOCK_MME_CALL( waveOutPause( pPlayAudio->hWaveOut ))

  01820	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  01823	52		 push	 edx
  01824	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutPause@4
$L70847:

; 4465 :     }
; 4466 : 
; 4467 : #ifdef USE_MME_SERVER
; 4468 : 
; 4469 :     /******************************************************************/
; 4470 :     /*  MME BUG WORKAROUND. Because the MME server currently does not */
; 4471 :     /*  return wave headers in the correct order, it is necessary to  */
; 4472 :     /*  put wave headers on a list whenever a wave header is written  */
; 4473 :     /*  by the waveOutWrite() function. This list is accessed in the  */
; 4474 :     /*  wave output callback routine to determine the current header. */
; 4475 :     /******************************************************************/
; 4476 : 
; 4477 :     pPlayAudio->uiWaveHdrWriteIndex = 0;
; 4478 :     pPlayAudio->uiWaveHdrReadIndex = 0;
; 4479 : 
; 4480 : #endif
; 4481 : 	}
; 4482 : 
; 4483 : 	// if there are samples outstanding, we have to recalculate the 
; 4484 : 	// correct number of samples that are still waiting to go
; 4485 : 	// hold this mutex up above.
; 4486 : 	//OP_LockMutex( pPlayAudio->hmxQueueCount );
; 4487 : 	// tek 06nov97 bats508 it is possible that ResetAudioQueue
; 4488 : 	// came along and clobbered the queue. If so, we need to
; 4489 : 	// gracefully bow out here..
; 4490 : 	  if ( pPlayAudioRing->iQueueCount == 0 )

  0182a	8b 7f 18	 mov	 edi, DWORD PTR [edi+24]
  0182d	85 ff		 test	 edi, edi
  0182f	75 17		 jne	 SHORT $L70848

; 4491 : 	  {
; 4492 : 		ClosePlayDevice( pPlayAudio );

  01831	56		 push	 esi
  01832	e8 00 00 00 00	 call	 _ClosePlayDevice

; 4493 : 		OP_UnlockMutex(pPlayAudio->hmxQueueCount);

  01837	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  0183a	50		 push	 eax
  0183b	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01840	83 c4 08	 add	 esp, 8
  01843	5f		 pop	 edi
  01844	5e		 pop	 esi
  01845	5d		 pop	 ebp
  01846	5b		 pop	 ebx

; 4600 : 	
; 4601 : #ifdef __linux__ 
; 4602 : //necessary for proper multithreading, this may be fixed in newer kernels
; 4603 :     tv.tv_sec=0;
; 4604 :     tv.tv_nsec=1;
; 4605 :     nanosleep(&tv,NULL);
; 4606 :     //usleep(1);
; 4607 : #endif
; 4608 : 
; 4609 :   return;
; 4610 : }

  01847	c3		 ret	 0
$L70848:

; 4494 : #ifdef AUD_DEBUG
; 4495 : 		{
; 4496 : 		  char  szTemp[256]="";
; 4497 : 		  sprintf(szTemp,"SAP: iQueueCount=0 abort at %lu\n",
; 4498 : 			  timeGetTime()
; 4499 : 			  );
; 4500 : 		  OutputDebugString(szTemp);
; 4501 : 		}
; 4502 : #endif //AUD_DEBUG 
; 4503 : 		return;
; 4504 : 	  }
; 4505 : 	uiQueueCount = pPlayAudioRing->iQueueCount
; 4506 : 					- pPlayAudio->iSamplesWaitingForCompletion;

  01848	8b 46 30	 mov	 eax, DWORD PTR [esi+48]

; 4507 : 	// hold the mutex so PROCWOMDONE won't collide..
; 4508 : 
; 4509 : #ifdef AUD_DEBUG
; 4510 :   {
; 4511 :     char  szTemp[256]="";
; 4512 :     sprintf(szTemp,"SAP: %d samples to write at %lu\n",
; 4513 : 	    uiQueueCount,
; 4514 : 	    timeGetTime()
; 4515 : 	    );
; 4516 :     OutputDebugString(szTemp);
; 4517 :   }
; 4518 : #endif //AUD_DEBUG 
; 4519 : 
; 4520 :     /******************************************************************/
; 4521 :     /*  If the number of samples in the queue is less than the        */
; 4522 :     /*  minimum samples to start playing audio then this is a flush   */
; 4523 :     /*  that was started by the timer thread (TimerThreadMain).       */
; 4524 :     /******************************************************************/
; 4525 : 	// tek 13may97
; 4526 : 	// this is no longer true. We can start up with less data if we're
; 4527 : 	// being forced to speak.
; 4528 : 
; 4529 :     /******************************************************************/
; 4530 :     /*  Loop and write buffers to the wave output device.             */
; 4531 :     /******************************************************************/
; 4532 : 
; 4533 :     uiWriteLength = pPlayAudio->uiStartupWriteLength;

  0184b	8b 5e 28	 mov	 ebx, DWORD PTR [esi+40]
  0184e	2b f8		 sub	 edi, eax
  01850	33 ed		 xor	 ebp, ebp
$L70849:

; 4534 : 
; 4535 : 	// tek 13may97
; 4536 : 	//// if we have less than the normal startup number of bytes, then
; 4537 : 	//// try to split the buffer into at least two buffers.
; 4538 : 	//
; 4539 : 	//if (  (uiQueueCount < uiWriteLength)
; 4540 : 	//	&&(uiQueueCount > 100) // but don't break up really tiny packets..
; 4541 : 	//   )
; 4542 : 	//{
; 4543 : 	//	uiWriteLength = (uiQueueCount>>4)<<3; // div by two, 8-byte chunksize
; 4544 : 	//}
; 4545 : 
; 4546 :     for ( uiI = 0;
; 4547 :           ( uiI < MAXIMUM_BUFFERS_QUEUED ) && ( uiQueueCount > 0 );
; 4548 :           uiI++ )

  01852	85 ff		 test	 edi, edi
  01854	76 35		 jbe	 SHORT $L70851

; 4549 :     {
; 4550 :       if ( uiWriteLength > uiQueueCount)

  01856	3b df		 cmp	 ebx, edi
  01858	76 02		 jbe	 SHORT $L70852

; 4551 :       {
; 4552 :         uiWriteLength = uiQueueCount;

  0185a	8b df		 mov	 ebx, edi
$L70852:

; 4553 :       }
; 4554 : 	  // tek 21nov97 make sure we don't leave a tiny buffer laying around to 
; 4555 : 	  // be sent..
; 4556 : 	  if (uiQueueCount < uiWriteLength+1000)

  0185c	8d 8b e8 03 00
	00		 lea	 ecx, DWORD PTR [ebx+1000]
  01862	3b f9		 cmp	 edi, ecx
  01864	73 02		 jae	 SHORT $L70853

; 4557 :       {
; 4558 : #ifndef UNDER_CE
; 4559 : 		uiWriteLength = uiQueueCount;

  01866	8b df		 mov	 ebx, edi
$L70853:

; 4560 : #else
; 4561 :         if (!pPlayAudio->bConvertToEightBit)	uiWriteLength = (uiQueueCount & 0xFFFFFFFE);		// Let's not send in a half-block
; 4562 : #endif
; 4563 :       }
; 4564 : 	  // check to make sure that this is a free waveheader, and
; 4565 : 	  // write it if it is. (tek 13may97)
; 4566 : 	  if (pPlayAudio->ppWaveHdr[uiI]->lpData == NULL)

  01868	8b 96 90 00 00
	00		 mov	 edx, DWORD PTR [esi+144]
  0186e	8b 04 2a	 mov	 eax, DWORD PTR [edx+ebp]
  01871	83 38 00	 cmp	 DWORD PTR [eax], 0
  01874	75 0d		 jne	 SHORT $L70850

; 4567 : 	  {
; 4568 : 
; 4569 :       uiQueueCount -= WriteBufferToWaveDevice( pPlayAudio,
; 4570 :                                                pPlayAudio->ppWaveHdr[uiI],
; 4571 :                                                uiWriteLength );

  01876	53		 push	 ebx
  01877	50		 push	 eax
  01878	56		 push	 esi
  01879	e8 00 00 00 00	 call	 _WriteBufferToWaveDevice
  0187e	83 c4 0c	 add	 esp, 12			; 0000000cH
  01881	2b f8		 sub	 edi, eax
$L70850:
  01883	83 c5 04	 add	 ebp, 4
  01886	83 fd 20	 cmp	 ebp, 32			; 00000020H
  01889	7c c7		 jl	 SHORT $L70849
$L70851:

; 4572 : 	  }
; 4573 : 	  else
; 4574 : 	  {
; 4575 : #ifdef AUD_DEBUG
; 4576 : 		  {
; 4577 : 		    char  szTemp[256]="";
; 4578 : 		    sprintf(szTemp,"SAP: header %d (%08lx) is busy at %lu\n",
; 4579 : 			    uiI,
; 4580 : 			    pPlayAudio->ppWaveHdr[uiI],
; 4581 : 			    timeGetTime()
; 4582 : 			    );
; 4583 : 		    OutputDebugString(szTemp);
; 4584 : 		  }
; 4585 : #endif //AUD_DEBUG  
; 4586 : 	  }
; 4587 :     }
; 4588 :   }
; 4589 : #ifdef AUD_DEBUG
; 4590 :   {
; 4591 : 		  char  szTemp[256]="";
; 4592 : 		  sprintf(szTemp,"SAP: exit at %lu\n",
; 4593 : 			  timeGetTime()
; 4594 : 			  );
; 4595 : 		  OutputDebugString(szTemp);
; 4596 :   }
; 4597 : #endif //AUD_DEBUG  
; 4598 :   // finally release the mutex here.
; 4599 :   OP_UnlockMutex(pPlayAudio->hmxQueueCount);

  0188b	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  0188e	50		 push	 eax
  0188f	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01894	83 c4 04	 add	 esp, 4
  01897	5f		 pop	 edi
  01898	5e		 pop	 esi
  01899	5d		 pop	 ebp
  0189a	5b		 pop	 ebx

; 4600 : 	
; 4601 : #ifdef __linux__ 
; 4602 : //necessary for proper multithreading, this may be fixed in newer kernels
; 4603 :     tv.tv_sec=0;
; 4604 :     tv.tv_nsec=1;
; 4605 :     nanosleep(&tv,NULL);
; 4606 :     //usleep(1);
; 4607 : #endif
; 4608 : 
; 4609 :   return;
; 4610 : }

  0189b	c3		 ret	 0
_StartAudioPlaying ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutUnprepareHeader@12:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_aParam$ = 12
_Process_MM_WOM_DONE_Message PROC NEAR

; 4647 : {

  018a0	53		 push	 ebx
  018a1	55		 push	 ebp

; 4648 :   int dwRemaining;
; 4649 :   unsigned int uiOldWriteLength;
; 4650 :   LPWAVEHDR pWaveHdr;
; 4651 :   LPPLAY_RING_T pPlayAudioRing;
; 4652 : 
; 4653 : #ifdef __linux__
; 4654 :   struct timespec tv;
; 4655 : #endif
; 4656 : 
; 4657 :   //tek 24jul97
; 4658 :   UINT	uiI=0;
; 4659 : 
; 4660 :   /********************************************************************/
; 4661 :   /*  Get the pointer to the wave header from the aParam of the       */
; 4662 :   /*  MM_WOM_DONE message and the pointer to the audio queue from the */
; 4663 :   /*  audio handle.                                                   */
; 4664 :   /********************************************************************/
; 4665 : 
; 4666 :   pWaveHdr = (LPWAVEHDR)aParam;
; 4667 : 
; 4668 :   /********************************************************************/
; 4669 :   /*  Get the number of samples previously written by the             */
; 4670 :   /*  waveOutWrite() function.                                        */
; 4671 :   /********************************************************************/
; 4672 : 
; 4673 :   uiOldWriteLength = (unsigned int)pWaveHdr->dwUser;

  018a2	8b 6c 24 10	 mov	 ebp, DWORD PTR _aParam$[esp+4]
  018a6	56		 push	 esi

; 4674 : 
; 4675 : #ifdef __arm__
; 4676 :   if( pPlayAudio->bPipesNotEmpty )
; 4677 :     {
; 4678 :       //setpriority(PRIO_PROCESS, 0, 20);
; 4679 :       // OP_SetThreadPriority works better, why? 
; 4680 :       OP_SetThreadPriority( pShm_t->hGlobalPlayAudioThread, OP_PRIORITY_NORMAL );
; 4681 :       if ( (uiOldWriteLength<<5) > 50000 )
; 4682 :       	usleep(50000); // tek 13oct98 defer buffer processing
; 4683 :       else
; 4684 :       	usleep(uiOldWriteLength<<5);
; 4685 :       //ETT 10/13/98 this has to be just right other wise it will stutter worse
; 4686 :       //setpriority(PRIO_PROCESS, 0, -20);
; 4687 :       OP_SetThreadPriority( pShm_t->hGlobalPlayAudioThread, OP_PRIORITY_HIGHEST );
; 4688 :     }
; 4689 : #endif
; 4690 : 
; 4691 :   /********************************************************************/
; 4692 :   /*  Unprepare the old header.                                       */
; 4693 :   /********************************************************************/
; 4694 : 
; 4695 : #ifndef USE_MME_SERVER
; 4696 :   _ASSERTE(pWaveHdr->lpData != NULL); // tek 22jan99 make sure this isn't a bogus
; 4697 : 									  // and/or idle header
; 4698 : 
; 4699 :   waveOutUnprepareHeader( pPlayAudio->hWaveOut,
; 4700 :                           pWaveHdr,
; 4701 :                           sizeof(WAVEHDR));

  018a7	8b 74 24 10	 mov	 esi, DWORD PTR _pPlayAudio$[esp+8]
  018ab	57		 push	 edi
  018ac	8b 5d 0c	 mov	 ebx, DWORD PTR [ebp+12]
  018af	6a 20		 push	 32			; 00000020H
  018b1	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  018b4	55		 push	 ebp
  018b5	50		 push	 eax
  018b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutUnprepareHeader@12

; 4702 : #endif
; 4703 :   // tek 06nov97 we have to take this mutex earlier to avoid collisions
; 4704 :   OP_LockMutex( pPlayAudio->hmxQueueCount );

  018bc	8b 4e 78	 mov	 ecx, DWORD PTR [esi+120]
  018bf	51		 push	 ecx
  018c0	e8 00 00 00 00	 call	 _OP_LockMutex

; 4705 :   // tek 09may97
; 4706 :   pPlayAudio->iOutstandingBuffers--;  // keep track of these for debugging

  018c5	8b 96 a0 00 00
	00		 mov	 edx, DWORD PTR [esi+160]

; 4707 : 
; 4708 :   /********************************************************************/
; 4709 :   /*  Subtract number of samples just output from the samples waiting */
; 4710 :   /*  for completion count.                                           */
; 4711 :   /********************************************************************/
; 4712 : 
; 4713 :   pPlayAudio->iSamplesWaitingForCompletion -= uiOldWriteLength;

  018cb	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]

; 4714 : #ifdef AUD_DEBUG	//13may97 tek
; 4715 :   {
; 4716 : 		  char  szTemp[256]="";
; 4717 : 		  sprintf(szTemp,"ProcWOMDONE: %08lx; outst buffs now=%d; samp waiting=%dat %08lu\n",
; 4718 : 			  pWaveHdr,
; 4719 : 			  pPlayAudio->iOutstandingBuffers,
; 4720 : 			  pPlayAudio->iSamplesWaitingForCompletion,
; 4721 : 			  timeGetTime()
; 4722 : 			  );
; 4723 : 		  OutputDebugString(szTemp);
; 4724 :   }
; 4725 : #endif //AUD_DEBUG
; 4726 : 
; 4727 :   /********************************************************************/
; 4728 :   /*  Do if the audio state isn't equal to AUDIO_STATE_PLAY then it   */
; 4729 :   /*  is equal to AUDIO_STATE_RESET.                                  */
; 4730 :   /********************************************************************/
; 4731 : 
; 4732 :   if ( pPlayAudio->dwAudioPlayState == AUDIO_STATE_PLAY )

  018ce	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  018d1	83 c4 04	 add	 esp, 4
  018d4	4a		 dec	 edx
  018d5	2b cb		 sub	 ecx, ebx
  018d7	85 c0		 test	 eax, eax
  018d9	89 96 a0 00 00
	00		 mov	 DWORD PTR [esi+160], edx
  018df	89 4e 30	 mov	 DWORD PTR [esi+48], ecx
  018e2	0f 85 d2 00 00
	00		 jne	 $L70871

; 4733 :   {
; 4734 :     /******************************************************************/
; 4735 :     /*  Subtract the number of samples from the queue count.          */
; 4736 :     /******************************************************************/
; 4737 : 
; 4738 :     pPlayAudioRing = pPlayAudio->pPlayAudioRing;

  018e8	8b be 94 00 00
	00		 mov	 edi, DWORD PTR [esi+148]

; 4739 : 
; 4740 : 	// tek 06nov97 (during bats508) hold this earlier (above).
; 4741 :     //OP_LockMutex( pPlayAudio->hmxQueueCount );
; 4742 :     pPlayAudioRing->iQueueCount -= (int)uiOldWriteLength;

  018ee	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  018f1	2b cb		 sub	 ecx, ebx
  018f3	89 4f 18	 mov	 DWORD PTR [edi+24], ecx

; 4743 : #ifdef AUD_DEBUG // tek 13may97
; 4744 :   {
; 4745 :     char  szTemp[256]="";
; 4746 :     sprintf(szTemp,"ProcWOMDONE: iQueueCount=%ld\n",
; 4747 : 	    pPlayAudioRing->iQueueCount);
; 4748 :     OutputDebugString(szTemp);
; 4749 :     
; 4750 :     if (pPlayAudioRing->iQueueCount < 0)
; 4751 :       {
; 4752 : 	sprintf(szTemp,"ProcWOMDONE: iQueueCount is negative? %d at %08lu\n",
; 4753 : 		pPlayAudioRing->iQueueCount,
; 4754 : 		timeGetTime()
; 4755 : 		);
; 4756 : 	OutputDebugString(szTemp);
; 4757 :       }
; 4758 :   }
; 4759 : #endif //AUD_DEBUG
; 4760 : 
; 4761 :     // tek 06nov97 this is now part of the larger mutex range
; 4762 :     //OP_UnlockMutex( pPlayAudio->hmxQueueCount );
; 4763 : 
; 4764 :     /******************************************************************/
; 4765 :     /*  Also update the "Bytes Played" count.                         */
; 4766 :     /******************************************************************/
; 4767 : 
; 4768 :     OP_LockMutex( pPlayAudio->hmxBytesPlayed );

  018f6	8b 56 70	 mov	 edx, DWORD PTR [esi+112]
  018f9	52		 push	 edx
  018fa	e8 00 00 00 00	 call	 _OP_LockMutex

; 4769 :     pPlayAudio->dwBytesPlayed += (DWORD)uiOldWriteLength;

  018ff	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  01902	03 c3		 add	 eax, ebx
  01904	89 46 44	 mov	 DWORD PTR [esi+68], eax

; 4770 :     OP_UnlockMutex( pPlayAudio->hmxBytesPlayed );

  01907	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  0190a	50		 push	 eax
  0190b	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 4771 : 
; 4772 :     /******************************************************************/
; 4773 :     /*  If there are no samples waiting for completion then there     */
; 4774 :     /*  are no more buffers queued by the waveOutWrite() function.    */
; 4775 :     /*  In this case release the wave output device by calling the    */
; 4776 :     /*  waveOutClose() function. If there are more samples in the     */
; 4777 :     /*  audio queue then a restart will eventually occur.             */
; 4778 :     /******************************************************************/
; 4779 : 
; 4780 : 	// tek 13may97
; 4781 : 	// this was a check on ( pPlayAudio->iSamplesWaitingForCompletion <= 0 )
; 4782 : 	// but I don't think that is quite correct; we could have no 
; 4783 : 	// samples waiting for completion (in the queue, but sent to the 
; 4784 : 	// device) but still have samples that haven't been sent yet. 
; 4785 : 	// if there are any samples left in the queue after the above update,
; 4786 : 	// then either we still have buffers at the device OR we have
; 4787 : 	// samples that have not yet been sent to the device.
; 4788 : 
; 4789 :     if ( pPlayAudioRing->iQueueCount <= 0 ) //tek 13may97

  01910	8b 7f 18	 mov	 edi, DWORD PTR [edi+24]
  01913	83 c4 08	 add	 esp, 8
  01916	85 ff		 test	 edi, edi
  01918	7f 15		 jg	 SHORT $L70874

; 4790 :     {
; 4791 : 
; 4792 : #ifdef AUD_DEBUG  //tek 13may97
; 4793 :   {
; 4794 : 		  char  szTemp[256]="";
; 4795 : 		  sprintf(szTemp,"ProcWOMDONE: Closing. iQueueCount=%ld\n",
; 4796 : 					pPlayAudioRing->iQueueCount);
; 4797 : 		  OutputDebugString(szTemp);
; 4798 :   }
; 4799 : #endif //AUD_DEBUG
; 4800 : 		// because we're done with this waveheader, clear the lpData field
; 4801 : 		// so that we can reuse it later.. 
; 4802 : 		pWaveHdr->lpData = NULL;
; 4803 :       ClosePlayDevice( pPlayAudio );

  0191a	56		 push	 esi
  0191b	c7 45 00 00 00
	00 00		 mov	 DWORD PTR [ebp], 0
  01922	e8 00 00 00 00	 call	 _ClosePlayDevice
  01927	83 c4 04	 add	 esp, 4

; 4804 :     }
; 4805 :     else

  0192a	e9 b2 00 00 00	 jmp	 $L70896
$L70874:

; 4806 :     {
; 4807 :       /****************************************************************/
; 4808 :       /*  Determine the number of unwritten samples remaining in the  */
; 4809 :       /*  audio queue. Protect the Queue Count.                       */
; 4810 :       /****************************************************************/
; 4811 : 	  // tek 16may97
; 4812 : 	  // we need to hold the mutex while we do the buffer write, else 
; 4813 : 	  // StartAudioPlaying may collide with this and write the same
; 4814 : 	  // thing twice.
; 4815 : 	  // tek 06nov97 this is now part of the larger mutex range
; 4816 :       //OP_LockMutex( pPlayAudio->hmxQueueCount );
; 4817 :       dwRemaining = pPlayAudioRing->iQueueCount -
; 4818 :                      pPlayAudio->iSamplesWaitingForCompletion;

  0192f	2b 7e 30	 sub	 edi, DWORD PTR [esi+48]

; 4819 : #ifdef AUD_DEBUG  //tek 13may97
; 4820 :   {
; 4821 : 		  char  szTemp[256]="";
; 4822 : 		  sprintf(szTemp,"ProcWOMDONE: dwRemaining=%ld\n",
; 4823 : 					dwRemaining);
; 4824 : 		  OutputDebugString(szTemp);
; 4825 :   }
; 4826 : #endif //AUD_DEBUG
; 4827 : 
; 4828 :       /****************************************************************/
; 4829 :       /*  If there are any samples remaining in the audio queue then  */
; 4830 :       /*  write up as many samples as the WriteBufferToWaveDevice()   */
; 4831 :       /*  function allows.                                            */
; 4832 :       /****************************************************************/
; 4833 : 
; 4834 :       if ( dwRemaining > 0 )

  01932	85 ff		 test	 edi, edi
  01934	7e 7b		 jle	 SHORT $L70877

; 4835 :       {
; 4836 :         /**************************************************************/
; 4837 :         /*  Write the next buffer to the output device.               */
; 4838 :         /**************************************************************/	
; 4839 : 		// tek 24jul97 in the presence of SYNCs, we can end up with 
; 4840 : 		// only a single buffer outstanding. To correct this, we'll try 
; 4841 : 		// to write several buffers if we don't have all of them outstanding
; 4842 : 		UINT uiWriteSize = dwRemaining;
; 4843 : 
; 4844 : 		if (pPlayAudio->iOutstandingBuffers < MAXIMUM_BUFFERS_QUEUED-2)

  01936	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  0193c	8b df		 mov	 ebx, edi
  0193e	83 f8 06	 cmp	 eax, 6
  01941	7d 19		 jge	 SHORT $L70879

; 4845 : 		{
; 4846 : #ifndef UNDER_CE // tek 23mar99 write fewer, larger buffers for CE
; 4847 : 			if (pPlayAudio->iOutstandingBuffers < MAXIMUM_BUFFERS_QUEUED-3)

  01943	83 f8 05	 cmp	 eax, 5
  01946	7d 05		 jge	 SHORT $L70880

; 4848 : 			{
; 4849 : 				uiWriteSize = dwRemaining>>2; // try to write 4

  01948	c1 fb 02	 sar	 ebx, 2

; 4850 : 			}
; 4851 : 			else

  0194b	eb 02		 jmp	 SHORT $L70881
$L70880:

; 4852 : #endif //UNDER_CE
; 4853 : 			{
; 4854 : 				uiWriteSize = dwRemaining>>1; // try to write 2

  0194d	d1 fb		 sar	 ebx, 1
$L70881:

; 4855 : 			}
; 4856 : 			// but don't write too little
; 4857 : 			// (make sure that we don't leave a tiny amount behind..)
; 4858 : 			if (uiWriteSize < MINIMUM_STARTUP_WRITE_SIZE)

  0194f	81 fb 40 06 00
	00		 cmp	 ebx, 1600		; 00000640H
  01955	73 02		 jae	 SHORT $L70882

; 4859 : 				uiWriteSize = dwRemaining;

  01957	8b df		 mov	 ebx, edi
$L70882:

; 4860 : 			// 015	MGS		12/15/1998	Fixed odd byte problem to audio device and BATS #844
; 4861 : 			uiWriteSize &= ~0x01;

  01959	83 e3 fe	 and	 ebx, -2			; fffffffeH
$L70879:

; 4862 : 
; 4863 : 		}
; 4864 : #ifdef UNDER_CE
; 4865 : 		if (!pPlayAudio->bConvertToEightBit)	uiWriteSize &= 0xFFFFFFFE;		// Let's not send in a half-block
; 4866 : #endif
; 4867 : 
; 4868 :         dwRemaining -= WriteBufferToWaveDevice( pPlayAudio,
; 4869 :                                  pWaveHdr,
; 4870 :                                  (unsigned int)uiWriteSize );

  0195c	53		 push	 ebx
  0195d	55		 push	 ebp
  0195e	56		 push	 esi
  0195f	e8 00 00 00 00	 call	 _WriteBufferToWaveDevice
  01964	83 c4 0c	 add	 esp, 12			; 0000000cH
  01967	2b f8		 sub	 edi, eax
  01969	33 ed		 xor	 ebp, ebp
$L70884:

; 4871 : 
; 4872 : 
; 4873 : 		// now, go find a free header to write what's left. This 
; 4874 : 		// loop is copied from StartAudioPlaying.
; 4875 : 		for ( uiI = 0;
; 4876 : 			  ( uiI < MAXIMUM_BUFFERS_QUEUED ) && ( dwRemaining > 0 ) && (pPlayAudio->iOutstandingBuffers < MAXIMUM_BUFFERS_QUEUED) ;
; 4877 : 			  uiI++ )

  0196b	85 ff		 test	 edi, edi
  0196d	7e 72		 jle	 SHORT $L70896
  0196f	83 be a0 00 00
	00 08		 cmp	 DWORD PTR [esi+160], 8
  01976	7d 69		 jge	 SHORT $L70896

; 4878 : 		{
; 4879 : 		  if ( uiWriteSize > dwRemaining)

  01978	3b df		 cmp	 ebx, edi
  0197a	76 02		 jbe	 SHORT $L70887

; 4880 : 		  {
; 4881 : 			uiWriteSize = dwRemaining;

  0197c	8b df		 mov	 ebx, edi
$L70887:

; 4882 : 		  }
; 4883 : 		  // check to make sure that this is a free waveheader, and
; 4884 : 		  // write it if it is. (tek 13may97)
; 4885 : 		  if (pPlayAudio->ppWaveHdr[uiI]->lpData == NULL)

  0197e	8b 8e 90 00 00
	00		 mov	 ecx, DWORD PTR [esi+144]
  01984	8b 04 29	 mov	 eax, DWORD PTR [ecx+ebp]
  01987	83 38 00	 cmp	 DWORD PTR [eax], 0
  0198a	75 1b		 jne	 SHORT $L70885

; 4886 : 		  {
; 4887 : #ifdef AUD_DEBUG
; 4888 : 		    {
; 4889 : 		      char  szTemp[256]="";
; 4890 : 		      sprintf(szTemp,"ProcWOMDONE: dwRemaining=%ld, uiWriteLength=%d, using header %d (%08lx) at %lu\n",
; 4891 : 			      dwRemaining,
; 4892 : 			      uiWriteSize,
; 4893 : 			      uiI,
; 4894 : 			      pPlayAudio->ppWaveHdr[uiI],
; 4895 : 			      timeGetTime()
; 4896 : 			      );
; 4897 : 		      OutputDebugString(szTemp);
; 4898 : 		    }
; 4899 : #endif //AUD_DEBUG  
; 4900 : 		    
; 4901 : #ifdef UNDER_CE
; 4902 : 		    if (!pPlayAudio->bConvertToEightBit)	uiWriteSize &= 0xFFFFFFFE;		// Let's not send in a half-block
; 4903 : #endif
; 4904 : 		    
; 4905 : 		    dwRemaining -= WriteBufferToWaveDevice( pPlayAudio,
; 4906 : 												   pPlayAudio->ppWaveHdr[uiI],
; 4907 : 												   uiWriteSize );

  0198c	53		 push	 ebx
  0198d	50		 push	 eax
  0198e	56		 push	 esi
  0198f	e8 00 00 00 00	 call	 _WriteBufferToWaveDevice
  01994	2b f8		 sub	 edi, eax
  01996	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4908 : 		  // don't leave a runt around..
; 4909 : 		  if (dwRemaining - uiWriteSize < MINIMUM_STARTUP_WRITE_SIZE)

  01999	8b d7		 mov	 edx, edi
  0199b	2b d3		 sub	 edx, ebx
  0199d	81 fa 40 06 00
	00		 cmp	 edx, 1600		; 00000640H
  019a3	73 02		 jae	 SHORT $L70885

; 4910 : 				uiWriteSize = dwRemaining;

  019a5	8b df		 mov	 ebx, edi
$L70885:

; 4871 : 
; 4872 : 
; 4873 : 		// now, go find a free header to write what's left. This 
; 4874 : 		// loop is copied from StartAudioPlaying.
; 4875 : 		for ( uiI = 0;
; 4876 : 			  ( uiI < MAXIMUM_BUFFERS_QUEUED ) && ( dwRemaining > 0 ) && (pPlayAudio->iOutstandingBuffers < MAXIMUM_BUFFERS_QUEUED) ;
; 4877 : 			  uiI++ )

  019a7	83 c5 04	 add	 ebp, 4
  019aa	83 fd 20	 cmp	 ebp, 32			; 00000020H
  019ad	7c bc		 jl	 SHORT $L70884

; 4911 : 
; 4912 : 		  }
; 4913 : 		  else
; 4914 : 		  {
; 4915 : #ifdef AUD_DEBUG
; 4916 : 			  {
; 4917 : 					  char  szTemp[256]="";
; 4918 : 					  sprintf(szTemp,"ProcWOMDONE: header %d (%08lx) is busy at %lu\n",
; 4919 : 						  uiI,
; 4920 : 						  pPlayAudio->ppWaveHdr[uiI],
; 4921 : 						  timeGetTime()
; 4922 : 						  );
; 4923 : 					  OutputDebugString(szTemp);
; 4924 : 			  }
; 4925 : #endif //AUD_DEBUG  
; 4926 : 		  }
; 4927 : 		}
; 4928 : 		
; 4929 :       }
; 4930 : 	  else //tek 13may97 if we're done with the header, null the 

  019af	eb 30		 jmp	 SHORT $L70896
$L70877:

; 4931 : 		   // lpData field so we know it is free.
; 4932 : 	  {
; 4933 : 		  pWaveHdr->lpData = NULL;

  019b1	c7 45 00 00 00
	00 00		 mov	 DWORD PTR [ebp], 0

; 4934 : 	  }
; 4935 : 	  // tek 06nov97 move this out of this branch
; 4936 :       //OP_UnlockMutex( pPlayAudio->hmxQueueCount );
; 4937 : 
; 4938 :     }
; 4939 :   }
; 4940 :   else

  019b8	eb 27		 jmp	 SHORT $L70896
$L70871:

; 4941 :   {
; 4942 : 	  // tek 13may97 in any event, we're done with this header..
; 4943 : 	  pWaveHdr->lpData = NULL;

  019ba	c7 45 00 00 00
	00 00		 mov	 DWORD PTR [ebp], 0

; 4944 :     /******************************************************************/
; 4945 :     /*  The audio state is equal to AUDIO_STATE_RESET. In reset mode  */
; 4946 :     /*  the queue count has already been set to zero. If there are no */
; 4947 :     /*  samples playing then signal that the reset is complete.       */
; 4948 :     /******************************************************************/
; 4949 : 
; 4950 :     if ( pPlayAudio->iSamplesWaitingForCompletion <= 0 )

  019c1	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  019c4	85 c0		 test	 eax, eax
  019c6	7f 19		 jg	 SHORT $L70896

; 4951 :     {
; 4952 :       pPlayAudio->dwAudioPlayState = AUDIO_STATE_PLAY;
; 4953 : 
; 4954 :       ClosePlayDevice( pPlayAudio );

  019c8	56		 push	 esi
  019c9	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  019d0	e8 00 00 00 00	 call	 _ClosePlayDevice

; 4955 : 
; 4956 :       OP_SetEvent( pPlayAudio->hevResetComplete );

  019d5	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  019d8	50		 push	 eax
  019d9	e8 00 00 00 00	 call	 _OP_SetEvent
  019de	83 c4 08	 add	 esp, 8
$L70896:

; 4957 :     }
; 4958 :   }
; 4959 : 
; 4960 :   /********************************************************************/
; 4961 :   /*  Signal that the Queue is not full.                              */
; 4962 :   /********************************************************************/
; 4963 : 
; 4964 :   OP_SetEvent( pPlayAudio->hevQueueNotFull );

  019e1	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  019e4	51		 push	 ecx
  019e5	e8 00 00 00 00	 call	 _OP_SetEvent

; 4965 :   //tek 06nov97 finally release the mutex here.
; 4966 :   OP_UnlockMutex( pPlayAudio->hmxQueueCount );

  019ea	8b 56 78	 mov	 edx, DWORD PTR [esi+120]
  019ed	52		 push	 edx
  019ee	e8 00 00 00 00	 call	 _OP_UnlockMutex
  019f3	83 c4 08	 add	 esp, 8

; 4967 : #ifdef __linux__ 
; 4968 : //necessary for proper multithreading, this may be fixed in newer kernels
; 4969 :   tv.tv_sec=0;
; 4970 :   tv.tv_nsec=1;
; 4971 :   nanosleep(&tv,NULL);
; 4972 :   //usleep(1);
; 4973 : #endif
; 4974 :   return FALSE;

  019f6	33 c0		 xor	 eax, eax
  019f8	5f		 pop	 edi
  019f9	5e		 pop	 esi
  019fa	5d		 pop	 ebp
  019fb	5b		 pop	 ebx

; 4975 : }

  019fc	c3		 ret	 0
_Process_MM_WOM_DONE_Message ENDP
_pPlayAudio$ = 8
_Process_MM_WOM_CLOSE_Message PROC NEAR

; 5004 : {

  01a00	56		 push	 esi

; 5005 : #ifdef AUD_DEBUG	 // tek 13may97
; 5006 :   {
; 5007 : 		  char  szTemp[256]="";
; 5008 : 		  sprintf(szTemp,"ProcWOMCLOSE: outstanding now %d at %08lu\n",
; 5009 : 			  pPlayAudio->iOutstandingBuffers,
; 5010 : 			  timeGetTime()
; 5011 : 			  );
; 5012 : 		  OutputDebugString(szTemp);
; 5013 :   }
; 5014 : #endif //AUD_DEBUG
; 5015 :   /********************************************************************/
; 5016 :   /*  If the audio device is not owned then clear the handle now.     */
; 5017 :   /********************************************************************/
; 5018 : 
; 5019 :   if (( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE ) == 0 )

  01a01	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  01a05	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  01a09	75 07		 jne	 SHORT $L70900

; 5020 :   {
; 5021 :     pPlayAudio->hWaveOut = (int)NULL;

  01a0b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$L70900:

; 5022 :   }
; 5023 : 
; 5024 :   /********************************************************************/
; 5025 :   /*  Set the audio device state and unblock the timer thread.        */
; 5026 :   /********************************************************************/
; 5027 : 
; 5028 :   OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  01a12	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  01a15	50		 push	 eax
  01a16	e8 00 00 00 00	 call	 _OP_LockMutex

; 5029 :   pPlayAudio->dwAudioDeviceState = AUDIO_DEVICE_INACTIVE;
; 5030 :   OP_SetEvent( pPlayAudio->hevTimerThreadActive );

  01a1b	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  01a1e	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
  01a25	51		 push	 ecx
  01a26	e8 00 00 00 00	 call	 _OP_SetEvent

; 5031 :   OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  01a2b	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  01a2e	52		 push	 edx
  01a2f	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 5032 : 
; 5033 :   /********************************************************************/
; 5034 :   /*  Unblock the PA_WaitForPlayToComplete() function.                */
; 5035 :   /********************************************************************/
; 5036 : 
; 5037 :   OP_SetEvent( pPlayAudio->hevAudioDeviceInactive );

  01a34	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  01a37	50		 push	 eax
  01a38	e8 00 00 00 00	 call	 _OP_SetEvent

; 5038 : 
; 5039 :   /********************************************************************/
; 5040 :   /*  Signal the application that the audio has stopped.              */
; 5041 :   /********************************************************************/
; 5042 : 
; 5043 :   if ( pPlayAudio->bReportPlayStop )

  01a3d	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  01a40	83 c4 10	 add	 esp, 16			; 00000010H
  01a43	85 c0		 test	 eax, eax
  01a45	74 14		 je	 SHORT $L71417

; 5044 :   {
; 5045 :     ReportStatusToApplication( pPlayAudio,
; 5046 :                                PA_PLAY_STOP,
; 5047 :                                0 );

  01a47	6a 00		 push	 0
  01a49	6a 02		 push	 2
  01a4b	56		 push	 esi
  01a4c	e8 00 00 00 00	 call	 _ReportStatusToApplication
  01a51	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5048 : 
; 5049 :     pPlayAudio->bReportPlayStop = FALSE;

  01a54	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0
$L71417:

; 5050 :   }
; 5051 : 
; 5052 :   return FALSE;

  01a5b	33 c0		 xor	 eax, eax
  01a5d	5e		 pop	 esi

; 5053 : }

  01a5e	c3		 ret	 0
_Process_MM_WOM_CLOSE_Message ENDP
_pPlayAudio$ = 8
_dwPosition$ = 8
_ClosePlayDevice PROC NEAR

; 5083 : {

  01a60	56		 push	 esi

; 5084 :   DWORD dwPosition;
; 5085 : 
; 5086 :   /********************************************************************/
; 5087 :   /*  If the user owns the audio device then just perform the same    */
; 5088 :   /*  processing that receiving a MM_WOM_CLOSE message would cause.   */
; 5089 :   /*  Otherwise call the waveOutClose() function to release the wave  */
; 5090 :   /*  output device. This will cause the wave device driver to send   */
; 5091 :   /*  an MM_WOM_CLOSE message when the wave output device is          */
; 5092 :   /*  released. At that time the Audio Device State will be set to    */
; 5093 :   /*  AUDIO_DEVICE_INACTIVE.                                          */
; 5094 :   /********************************************************************/
; 5095 : 
; 5096 :   if ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )

  01a61	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  01a65	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  01a69	74 0b		 je	 SHORT $L70908

; 5097 :   {
; 5098 :     Process_MM_WOM_CLOSE_Message( pPlayAudio );

  01a6b	56		 push	 esi
  01a6c	e8 00 00 00 00	 call	 _Process_MM_WOM_CLOSE_Message
  01a71	83 c4 04	 add	 esp, 4
  01a74	5e		 pop	 esi

; 5111 :   }
; 5112 : 
; 5113 :   return;
; 5114 : }

  01a75	c3		 ret	 0
$L70908:

; 5099 :   }
; 5100 :   else
; 5101 :   {
; 5102 :     OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  01a76	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  01a79	50		 push	 eax
  01a7a	e8 00 00 00 00	 call	 _OP_LockMutex

; 5103 :     pPlayAudio->dwAudioDeviceState = AUDIO_DEVICE_SHUTTING_DOWN;
; 5104 :     OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  01a7f	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  01a82	c7 46 34 03 00
	00 00		 mov	 DWORD PTR [esi+52], 3
  01a89	51		 push	 ecx
  01a8a	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 5105 : 
; 5106 :     AudioPosition( pPlayAudio, &dwPosition );

  01a8f	8d 54 24 10	 lea	 edx, DWORD PTR _dwPosition$[esp+8]
  01a93	52		 push	 edx
  01a94	56		 push	 esi
  01a95	e8 00 00 00 00	 call	 _AudioPosition

; 5107 : 
; 5108 :     pPlayAudio->dwPositionBase += dwPosition;

  01a9a	8b 44 24 18	 mov	 eax, DWORD PTR _dwPosition$[esp+16]
  01a9e	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  01aa1	03 c8		 add	 ecx, eax
  01aa3	83 c4 10	 add	 esp, 16			; 00000010H
  01aa6	89 4e 40	 mov	 DWORD PTR [esi+64], ecx

; 5109 : 
; 5110 :     LOCK_MME_CALL( waveOutClose( pPlayAudio->hWaveOut ))

  01aa9	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01aac	51		 push	 ecx
  01aad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutClose@4
  01ab3	5e		 pop	 esi

; 5111 :   }
; 5112 : 
; 5113 :   return;
; 5114 : }

  01ab4	c3		 ret	 0
_ClosePlayDevice ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutPrepareHeader@12:NEAR
EXTRN	__imp__waveOutWrite@12:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pWaveHdr$ = 12
_uiLength$ = 16
_WriteBufferToWaveDevice PROC NEAR

; 5152 :   unsigned int uiI;
; 5153 :   int iNumberToMoveToQueueTop;
; 5154 :   unsigned int uiWriteLength;
; 5155 :   short * pWordSource;
; 5156 :   LPAUDIO_T pByteDest;
; 5157 :   LPPLAY_RING_T pPlayAudioRing;
; 5158 :   MMRESULT mmStatus;
; 5159 : 
; 5160 : #ifdef AUD_DEBUG  //tek 13may97
; 5161 :   {
; 5162 : 		  char  szTemp[256]="";
; 5163 : 		  pPlayAudioRing = pPlayAudio->pPlayAudioRing;
; 5164 : 		  sprintf(szTemp,"WBTWOD size=%d at %08lx; out=%d; waiting=%d qcount=%d at %08lu\n",
; 5165 : 			  uiLength, 
; 5166 : 			  pWaveHdr,
; 5167 : 			  pPlayAudio->iOutstandingBuffers, 
; 5168 : 			  pPlayAudio->iSamplesWaitingForCompletion,
; 5169 : 			  pPlayAudioRing->iQueueCount,
; 5170 : 			  timeGetTime()
; 5171 : 			  );
; 5172 : 		  OutputDebugString(szTemp);
; 5173 :   }
; 5174 : #endif //AUD_DEBUG
; 5175 : 
; 5176 :   /********************************************************************/
; 5177 :   /*  Limit the length to be written.                                 */
; 5178 :   /********************************************************************/
; 5179 : 
; 5180 :   if ( uiLength > pPlayAudio->uiMaximumWriteLength )

  01ac0	8b 54 24 04	 mov	 edx, DWORD PTR _pPlayAudio$[esp-4]
  01ac4	53		 push	 ebx
  01ac5	55		 push	 ebp
  01ac6	8b 6c 24 14	 mov	 ebp, DWORD PTR _uiLength$[esp+4]
  01aca	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  01acd	56		 push	 esi
  01ace	3b e8		 cmp	 ebp, eax
  01ad0	57		 push	 edi
  01ad1	76 02		 jbe	 SHORT $L70924

; 5181 :   {
; 5182 :     uiLength = pPlayAudio->uiMaximumWriteLength;

  01ad3	8b e8		 mov	 ebp, eax
$L70924:

; 5183 :   }
; 5184 : 
; 5185 :   /********************************************************************/
; 5186 :   /*  If necessary, wrap the output pointer and move data.            */
; 5187 :   /*  First ensure that the next buffer of data that is written does  */
; 5188 :   /*  not extend beyond the end of the queue. If it does then all     */
; 5189 :   /*  samples starting at the the current output pointer to the last  */
; 5190 :   /*  location at the end of the queue will be moved to the extra     */
; 5191 :   /*  space above the queue start. Set the output pointer to the      */
; 5192 :   /*  start of this data and set the output position relative to      */
; 5193 :   /*  the buffer start (i.e. the output buffer position will end      */
; 5194 :   /*  up either negative or zero).                                    */
; 5195 :   /********************************************************************/
; 5196 : 
; 5197 :   pPlayAudioRing = pPlayAudio->pPlayAudioRing;

  01ad5	8b 9a 94 00 00
	00		 mov	 ebx, DWORD PTR [edx+148]

; 5198 : 
; 5199 :   if ( pPlayAudioRing->iOutputPosition + (int)uiLength
; 5200 :                                     > pPlayAudioRing->iQueueLength )

  01adb	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  01ade	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  01ae1	8d 34 29	 lea	 esi, DWORD PTR [ecx+ebp]
  01ae4	3b f0		 cmp	 esi, eax
  01ae6	7e 2b		 jle	 SHORT $L70926

; 5201 :   {
; 5202 :     /******************************************************************/
; 5203 :     /*  Move samples to the top of the queue.                         */
; 5204 :     /******************************************************************/
; 5205 : 
; 5206 :     iNumberToMoveToQueueTop =
; 5207 :       pPlayAudioRing->iQueueLength - pPlayAudioRing->iOutputPosition;
; 5208 : 
; 5209 :     /******************************************************************/
; 5210 :     /*  pByteSource = pPlayAudioRing->pQueueOutput;                   */
; 5211 :     /*  pByteDest =                                                   */
; 5212 :     /*    pPlayAudioRing->pQueueStart - iNumberToMoveToQueueTop;      */
; 5213 :     /*                                                                */
; 5214 :     /*  for ( uiI = 0; uiI < iNumberToMoveToQueueTop; uiI++ )         */
; 5215 :     /*    *pByteDest++ = *pByteSource++;                              */
; 5216 :     /******************************************************************/
; 5217 : 
; 5218 :     memcpy( pPlayAudioRing->pQueueStart - iNumberToMoveToQueueTop,
; 5219 :             pPlayAudioRing->pQueueOutput,
; 5220 :             iNumberToMoveToQueueTop );

  01ae8	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  01aeb	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
  01aee	2b c1		 sub	 eax, ecx
  01af0	8b c8		 mov	 ecx, eax
  01af2	2b f8		 sub	 edi, eax
  01af4	8b d1		 mov	 edx, ecx
  01af6	c1 e9 02	 shr	 ecx, 2
  01af9	f3 a5		 rep movsd
  01afb	8b ca		 mov	 ecx, edx

; 5221 : 
; 5222 :     pPlayAudioRing->pQueueOutput =
; 5223 :       pPlayAudioRing->pQueueStart - iNumberToMoveToQueueTop;
; 5224 :     pPlayAudioRing->iOutputPosition = - iNumberToMoveToQueueTop;

  01afd	8b 54 24 14	 mov	 edx, DWORD PTR _pPlayAudio$[esp+12]
  01b01	83 e1 03	 and	 ecx, 3
  01b04	f3 a4		 rep movsb
  01b06	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  01b09	2b c8		 sub	 ecx, eax
  01b0b	f7 d8		 neg	 eax
  01b0d	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx
  01b10	89 43 14	 mov	 DWORD PTR [ebx+20], eax
$L70926:

; 5225 :   }
; 5226 : 
; 5227 :   /********************************************************************/
; 5228 :   /*  If the waveOutOpen() function has opened a device that requires */
; 5229 :   /*  8 bit samples and 16 bit samples were queued, then convert the  */
; 5230 :   /*  samples to 8 bits here.                                         */
; 5231 :   /********************************************************************/
; 5232 : 
; 5233 :   if ( pPlayAudio->bConvertToEightBit )

  01b13	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  01b16	33 ff		 xor	 edi, edi
  01b18	3b c7		 cmp	 eax, edi
  01b1a	74 25		 je	 SHORT $L70927

; 5234 :   {
; 5235 :     pByteDest = pPlayAudioRing->pQueueOutput;

  01b1c	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 5236 :     pWordSource = (short *)pByteDest;
; 5237 : 
; 5238 :     for ( uiI = 0; uiI < uiLength; uiI++ )

  01b1f	3b ef		 cmp	 ebp, edi
  01b21	8b f0		 mov	 esi, eax
  01b23	76 16		 jbe	 SHORT $L70931

; 5234 :   {
; 5235 :     pByteDest = pPlayAudioRing->pQueueOutput;

  01b25	8b fd		 mov	 edi, ebp
$L70929:

; 5239 :       *pByteDest++ = (unsigned char)((*pWordSource++) >> 8 ) ^ 0x80;

  01b27	66 8b 0e	 mov	 cx, WORD PTR [esi]
  01b2a	83 c6 02	 add	 esi, 2
  01b2d	c1 f9 08	 sar	 ecx, 8
  01b30	80 f1 80	 xor	 cl, 128			; 00000080H
  01b33	88 08		 mov	 BYTE PTR [eax], cl
  01b35	40		 inc	 eax
  01b36	4f		 dec	 edi
  01b37	75 ee		 jne	 SHORT $L70929

; 5236 :     pWordSource = (short *)pByteDest;
; 5237 : 
; 5238 :     for ( uiI = 0; uiI < uiLength; uiI++ )

  01b39	33 ff		 xor	 edi, edi
$L70931:

; 5240 : 
; 5241 :     uiWriteLength = uiLength >> 1;

  01b3b	8b c5		 mov	 eax, ebp
  01b3d	d1 e8		 shr	 eax, 1

; 5242 :   }
; 5243 :   else

  01b3f	eb 02		 jmp	 SHORT $L70933
$L70927:

; 5244 :   {
; 5245 :     uiWriteLength = uiLength;

  01b41	8b c5		 mov	 eax, ebp
$L70933:

; 5246 :   }
; 5247 : 
; 5248 :   /********************************************************************/
; 5249 :   /*  Set up the WAVEHDR structure.                                   */
; 5250 :   /*  Save the buffer length in the high 16 bits of the dwUser        */
; 5251 :   /*  element of the wave header.                                     */
; 5252 :   /********************************************************************/
; 5253 : 
; 5254 : #ifdef UNDER_CE
; 5255 :   if (!pPlayAudio->bConvertToEightBit && uiWriteLength & 0x01) {
; 5256 : 	  if (uiWriteLength & 0x01)		MessageBox(NULL, _T("Misalligned data"), _T("DECtalk"), MB_OK);
; 5257 : 	  return uiWriteLength;			// Throw away the packet!!!
; 5258 :   }
; 5259 : #endif
; 5260 :   pWaveHdr->lpData          = (char *)pPlayAudioRing->pQueueOutput;

  01b43	8b 74 24 18	 mov	 esi, DWORD PTR _pWaveHdr$[esp+12]
  01b47	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]

; 5261 :   pWaveHdr->dwBufferLength  = uiWriteLength;
; 5262 :   pWaveHdr->dwBytesRecorded = 0L;
; 5263 :   pWaveHdr->dwUser          = (DWORD)uiLength;
; 5264 :   pWaveHdr->dwFlags         = 0L;
; 5265 :   pWaveHdr->dwLoops         = 0L;
; 5266 :   pWaveHdr->lpNext          = NULL;
; 5267 :   pWaveHdr->reserved        = 0L;
; 5268 : 
; 5269 :   /********************************************************************/
; 5270 :   /*  Prepare the header for the waveOutWrite() function.             */
; 5271 :   /********************************************************************/
; 5272 : 
; 5273 : #ifndef USE_MME_SERVER
; 5274 : 
; 5275 :   mmStatus = waveOutPrepareHeader( pPlayAudio->hWaveOut,
; 5276 :                                    pWaveHdr,
; 5277 :                                    sizeof(WAVEHDR));

  01b4a	6a 20		 push	 32			; 00000020H
  01b4c	56		 push	 esi
  01b4d	89 0e		 mov	 DWORD PTR [esi], ecx
  01b4f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  01b52	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  01b55	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  01b58	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  01b5b	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  01b5e	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  01b61	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  01b64	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  01b67	52		 push	 edx
  01b68	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutPrepareHeader@12

; 5278 : 
; 5279 :   if ( mmStatus != MMSYSERR_NOERROR )

  01b6e	3b c7		 cmp	 eax, edi
  01b70	74 17		 je	 SHORT $L70938

; 5280 :   {
; 5281 : #ifdef AUD_DEBUG
; 5282 : 	  OutputDebugString("WriteBufferToWaveDevice: waveOutPrepareHeader failed.\n");
; 5283 : #endif
; 5284 : 	  ReportStatusToApplication( pPlayAudio,
; 5285 :                                PA_WRITE_ERROR,
; 5286 :                                mmStatus );

  01b72	50		 push	 eax
  01b73	8b 44 24 18	 mov	 eax, DWORD PTR _pPlayAudio$[esp+16]
  01b77	6a 07		 push	 7
  01b79	50		 push	 eax

; 5332 :   }
; 5333 :   else
; 5334 :   {
; 5335 :     /******************************************************************/
; 5336 :     /*  Report any errors that occured.                               */
; 5337 :     /******************************************************************/
; 5338 : #ifdef AUD_DEBUG
; 5339 : 	OutputDebugString("WriteBufferToWaveDevice: waveOutWrite failed.\n");
; 5340 : #endif
; 5341 :     ReportStatusToApplication( pPlayAudio,
; 5342 :                                PA_WRITE_ERROR,
; 5343 :                                mmStatus );

  01b7a	e8 00 00 00 00	 call	 _ReportStatusToApplication
  01b7f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5344 :     return 0;

  01b82	33 c0		 xor	 eax, eax
  01b84	5f		 pop	 edi
  01b85	5e		 pop	 esi
  01b86	5d		 pop	 ebp
  01b87	5b		 pop	 ebx

; 5348 : }

  01b88	c3		 ret	 0
$L70938:

; 5287 :     return 0;
; 5288 :   }
; 5289 : 
; 5290 : #endif
; 5291 : 
; 5292 :   /********************************************************************/
; 5293 :   /*  Write the buffer to the wave output device.                     */
; 5294 :   /********************************************************************/
; 5295 : 
; 5296 :   LOCK_MME_CALL( mmStatus = waveOutWrite( pPlayAudio->hWaveOut,
; 5297 :                                           pWaveHdr,
; 5298 :                                           sizeof(WAVEHDR)))

  01b89	6a 20		 push	 32			; 00000020H
  01b8b	56		 push	 esi
  01b8c	8b 74 24 1c	 mov	 esi, DWORD PTR _pPlayAudio$[esp+20]
  01b90	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01b93	51		 push	 ecx
  01b94	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutWrite@12

; 5299 : 
; 5300 :   if ( mmStatus == MMSYSERR_NOERROR )

  01b9a	3b c7		 cmp	 eax, edi
  01b9c	75 2c		 jne	 SHORT $L70940

; 5301 :   {
; 5302 : 	  // tek 09may97
; 5303 : 	  pPlayAudio->iOutstandingBuffers++;// keep track..

  01b9e	8b be a0 00 00
	00		 mov	 edi, DWORD PTR [esi+160]

; 5304 : #ifdef USE_MME_SERVER
; 5305 : 
; 5306 :     /******************************************************************/
; 5307 :     /*  MME BUG WORKAROUND. Because the MME server currently does not */
; 5308 :     /*  return wave headers in the correct order, it is necessary to  */
; 5309 :     /*  put wave headers on a list whenever a wave header is written  */
; 5310 :     /*  by the waveOutWrite() function. This list is accessed in the  */
; 5311 :     /*  wave output callback routine to determine the current header. */
; 5312 :     /******************************************************************/
; 5313 : 
; 5314 :     pPlayAudio->ppWaveHdrInUseList[pPlayAudio->uiWaveHdrWriteIndex] = pWaveHdr;
; 5315 : 
; 5316 :     pPlayAudio->uiWaveHdrWriteIndex++;
; 5317 : 
; 5318 :     if ( pPlayAudio->uiWaveHdrWriteIndex >= MAXIMUM_BUFFERS_QUEUED )
; 5319 :     {
; 5320 :       pPlayAudio->uiWaveHdrWriteIndex = 0;
; 5321 :     }
; 5322 : 
; 5323 : #endif
; 5324 : 
; 5325 :     /******************************************************************/
; 5326 :     /*  Update the output pointers and the "samples waiting" count.   */
; 5327 :     /******************************************************************/
; 5328 : 
; 5329 :     pPlayAudio->iSamplesWaitingForCompletion += uiLength;

  01ba4	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  01ba7	47		 inc	 edi
  01ba8	03 d5		 add	 edx, ebp
  01baa	89 be a0 00 00
	00		 mov	 DWORD PTR [esi+160], edi
  01bb0	89 56 30	 mov	 DWORD PTR [esi+48], edx

; 5330 :     pPlayAudioRing->pQueueOutput += uiLength;

  01bb3	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]

; 5331 :     pPlayAudioRing->iOutputPosition += uiLength;

  01bb6	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  01bb9	03 cd		 add	 ecx, ebp
  01bbb	03 c5		 add	 eax, ebp
  01bbd	89 43 14	 mov	 DWORD PTR [ebx+20], eax
  01bc0	5f		 pop	 edi

; 5345 :   }
; 5346 : 
; 5347 :   return uiLength;

  01bc1	8b c5		 mov	 eax, ebp
  01bc3	5e		 pop	 esi
  01bc4	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx
  01bc7	5d		 pop	 ebp
  01bc8	5b		 pop	 ebx

; 5348 : }

  01bc9	c3		 ret	 0
$L70940:

; 5332 :   }
; 5333 :   else
; 5334 :   {
; 5335 :     /******************************************************************/
; 5336 :     /*  Report any errors that occured.                               */
; 5337 :     /******************************************************************/
; 5338 : #ifdef AUD_DEBUG
; 5339 : 	OutputDebugString("WriteBufferToWaveDevice: waveOutWrite failed.\n");
; 5340 : #endif
; 5341 :     ReportStatusToApplication( pPlayAudio,
; 5342 :                                PA_WRITE_ERROR,
; 5343 :                                mmStatus );

  01bca	50		 push	 eax
  01bcb	6a 07		 push	 7
  01bcd	56		 push	 esi
  01bce	e8 00 00 00 00	 call	 _ReportStatusToApplication
  01bd3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5344 :     return 0;

  01bd6	33 c0		 xor	 eax, eax
  01bd8	5f		 pop	 edi
  01bd9	5e		 pop	 esi
  01bda	5d		 pop	 ebp
  01bdb	5b		 pop	 ebx

; 5348 : }

  01bdc	c3		 ret	 0
_WriteBufferToWaveDevice ENDP
_pPlayAudio$ = 8
_ProcessOpenWaveOutputDeviceMessage PROC NEAR

; 5376 : {

  01be0	56		 push	 esi

; 5377 :   /********************************************************************/
; 5378 :   /*  If the wave output device is not closed then abort.             */
; 5379 :   /*  This check is necessary because the PA_Queue() function and     */
; 5380 :   /*  the Timer thread might send both the ID_Open_Wave_Output_Device */
; 5381 :   /*  message before either occurence of the message can be processed */
; 5382 :   /*  Also abort if the pause flag is set.                            */
; 5383 :   /********************************************************************/
; 5384 : 
; 5385 :   if (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_INACTIVE )
; 5386 :     && ( ! pPlayAudio->bPaused ))

  01be1	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  01be5	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  01be8	85 c0		 test	 eax, eax
  01bea	75 5c		 jne	 SHORT $L71424
  01bec	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  01bef	85 c0		 test	 eax, eax
  01bf1	75 55		 jne	 SHORT $L71424

; 5387 :   {
; 5388 :     /******************************************************************/
; 5389 :     /*  IF the wave output device is owned by the application and     */
; 5390 :     /*     the wave output device is already opened,                  */
; 5391 :     /*  THEN                                                          */
; 5392 :     /*    There will be no MM_WOM_OPEN message generated so start     */
; 5393 :     /*    audio playing right now.                                    */
; 5394 :     /*  ELSE                                                          */
; 5395 :     /*    Open the wave audio device.                                 */
; 5396 :     /*    The Process_MM_WOM_OPEN_Message function will start audio   */
; 5397 :     /*    playing later.                                              */
; 5398 :     /******************************************************************/
; 5399 : 
; 5400 :     if (( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )
; 5401 :       && ( pPlayAudio->hWaveOut != (int)NULL ))

  01bf3	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  01bf7	74 1d		 je	 SHORT $L70948
  01bf9	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01bfc	85 c0		 test	 eax, eax
  01bfe	74 16		 je	 SHORT $L70948

; 5402 :     {
; 5403 :       /****************************************************************/
; 5404 :       /*  Block the PA_WaitForPlayToComplete() function.              */
; 5405 :       /****************************************************************/
; 5406 : 
; 5407 :       OP_ResetEvent( pPlayAudio->hevAudioDeviceInactive );

  01c00	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  01c03	50		 push	 eax
  01c04	e8 00 00 00 00	 call	 _OP_ResetEvent

; 5408 : 
; 5409 :       /****************************************************************/
; 5410 :       /*  Set the device state.                                       */
; 5411 :       /****************************************************************/
; 5412 : 
; 5413 : 	  // tek 16mar98 we should never set the device state, because 
; 5414 : 	  // StartAudioPlaying manages that..! (bats622)
; 5415 :       //OP_LockMutex( pPlayAudio->hmxAudioDeviceState );
; 5416 :       //pPlayAudio->dwAudioDeviceState = AUDIO_DEVICE_ACTIVE;
; 5417 :       //OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );
; 5418 : 
; 5419 :       StartAudioPlaying( pPlayAudio );

  01c09	56		 push	 esi
  01c0a	e8 00 00 00 00	 call	 _StartAudioPlaying
  01c0f	83 c4 08	 add	 esp, 8

; 5438 :       }
; 5439 :     }
; 5440 :   }
; 5441 : 
; 5442 :   return FALSE;

  01c12	33 c0		 xor	 eax, eax
  01c14	5e		 pop	 esi

; 5443 : }

  01c15	c3		 ret	 0
$L70948:

; 5420 :     }
; 5421 :     else
; 5422 :     {
; 5423 :       if ( OpenWaveOutputDevice( pPlayAudio ) == MMSYSERR_NOERROR )

  01c16	56		 push	 esi
  01c17	e8 00 00 00 00	 call	 _OpenWaveOutputDevice
  01c1c	83 c4 04	 add	 esp, 4
  01c1f	85 c0		 test	 eax, eax
  01c21	75 25		 jne	 SHORT $L71424

; 5424 :       {
; 5425 :         /**************************************************************/
; 5426 :         /*  Block the PA_WaitForPlayToComplete() function.            */
; 5427 :         /**************************************************************/
; 5428 : 
; 5429 :         OP_ResetEvent( pPlayAudio->hevAudioDeviceInactive );

  01c23	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  01c26	51		 push	 ecx
  01c27	e8 00 00 00 00	 call	 _OP_ResetEvent

; 5430 : 
; 5431 :         /**************************************************************/
; 5432 :         /*  Set the device state.                                     */
; 5433 :         /**************************************************************/
; 5434 : 
; 5435 :         OP_LockMutex( pPlayAudio->hmxAudioDeviceState );

  01c2c	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  01c2f	52		 push	 edx
  01c30	e8 00 00 00 00	 call	 _OP_LockMutex

; 5436 :         pPlayAudio->dwAudioDeviceState = AUDIO_DEVICE_STARTING_UP;
; 5437 :         OP_UnlockMutex( pPlayAudio->hmxAudioDeviceState );

  01c35	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  01c38	c7 46 34 01 00
	00 00		 mov	 DWORD PTR [esi+52], 1
  01c3f	50		 push	 eax
  01c40	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01c45	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71424:

; 5438 :       }
; 5439 :     }
; 5440 :   }
; 5441 : 
; 5442 :   return FALSE;

  01c48	33 c0		 xor	 eax, eax
  01c4a	5e		 pop	 esi

; 5443 : }

  01c4b	c3		 ret	 0
_ProcessOpenWaveOutputDeviceMessage ENDP
_TEXT	ENDS
PUBLIC	_WaveOutCallbackRoutine@20
EXTRN	__imp__waveOutOpen@24:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_dwSampleRate$ = -4
_mmStatus$ = 8
_OpenWaveOutputDevice PROC NEAR

; 5472 : {

  01c50	51		 push	 ecx
  01c51	53		 push	 ebx
  01c52	55		 push	 ebp
  01c53	56		 push	 esi
  01c54	57		 push	 edi

; 5473 :   DWORD dwSampleRate=0;
; 5474 :   DWORD dwNumberOfChannels=0;
; 5475 :   DWORD dwBytesPerSample=0;
; 5476 :   DWORD dwOpenFlags=0;
; 5477 :   LPWAVEFORMATEX pWaveFormat;
; 5478 :   MMRESULT mmStatus;
; 5479 : 
; 5480 :   /********************************************************************/
; 5481 :   /*  The default state is no sample conversion.                      */
; 5482 :   /********************************************************************/
; 5483 : 
; 5484 :   pPlayAudio->bConvertToEightBit = FALSE;

  01c55	8b 7c 24 18	 mov	 edi, DWORD PTR _pPlayAudio$[esp+16]
  01c59	33 d2		 xor	 edx, edx
  01c5b	33 db		 xor	 ebx, ebx
  01c5d	89 54 24 10	 mov	 DWORD PTR _dwSampleRate$[esp+20], edx

; 5485 : 
; 5486 :   /********************************************************************/
; 5487 :   /*  Initialize the local WAVEFORMATEX structure.                    */
; 5488 :   /********************************************************************/
; 5489 : 
; 5490 :   pWaveFormat = pPlayAudio->pWaveFormat;

  01c61	8b b7 9c 00 00
	00		 mov	 esi, DWORD PTR [edi+156]
  01c67	89 57 50	 mov	 DWORD PTR [edi+80], edx

; 5491 : 
; 5492 :   /********************************************************************/
; 5493 :   /*  If the WAVEFORMATEX data structure has a wFormatTag element     */
; 5494 :   /*  equal to WAVE_FORMAT_PCM then the device is opened for either   */
; 5495 :   /*  16 or 8 bit output. Whether 8 or 16 bits will succeed depends   */
; 5496 :   /*  on the audio data size and the audio driver. If the audio       */
; 5497 :   /*  samples are 16 bits and only 8 bit output is supported by the   */
; 5498 :   /*  audio driver then the 16 bit audio samples are converted to 8   */
; 5499 :   /*  bit audio samples in the WriteBufferToWaveDevice() function.    */
; 5500 :   /*  This conversion is indicated by the bConvertToEightBit flag.    */
; 5501 :   /*  The wBitsPerSample element, the nChannels element , and         */
; 5502 :   /*  the nSamplesPerSec element of the WAVEFORMATEX structure are    */
; 5503 :   /*  used to calculate the values of the other elements of the       */
; 5504 :   /*  WAVEFORMATEX structure.                                         */
; 5505 :   /*                                                                  */
; 5506 :   /*  If the wFormatTag element of the WAVEFORMATEX structure         */
; 5507 :   /*  is NOT equal to WAVE_FORMAT_PCM then all of the fields of the   */
; 5508 :   /*  WAVEFORMATEX structure must be filled in and are used in the    */
; 5509 :   /*  call to the waveOutOpen() function.                             */
; 5510 :   /********************************************************************/
; 5511 : 
; 5512 :   if ( pWaveFormat->wFormatTag == WAVE_FORMAT_PCM )

  01c6a	66 83 3e 01	 cmp	 WORD PTR [esi], 1
  01c6e	75 2a		 jne	 SHORT $L70960

; 5513 :   {
; 5514 :     /******************************************************************/
; 5515 :     /*  The wFormatTag element is equal to WAVE_FORMAT_PCM.           */
; 5516 :     /******************************************************************/
; 5517 : 
; 5518 :     dwSampleRate = pWaveFormat->nSamplesPerSec;
; 5519 :     dwNumberOfChannels = pWaveFormat->nChannels;

  01c70	66 8b 5e 02	 mov	 bx, WORD PTR [esi+2]

; 5520 :     dwBytesPerSample = pWaveFormat->wBitsPerSample >> 3;

  01c74	33 c0		 xor	 eax, eax
  01c76	66 8b 46 0e	 mov	 ax, WORD PTR [esi+14]
  01c7a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  01c7d	c1 e8 03	 shr	 eax, 3

; 5521 : 
; 5522 :     /******************************************************************/
; 5523 :     /*  Initialize other WAVEFORMATEX structure elements.             */
; 5524 :     /******************************************************************/
; 5525 : 
; 5526 :     pWaveFormat->nAvgBytesPerSec =
; 5527 :       dwSampleRate * dwNumberOfChannels * dwBytesPerSample;

  01c80	8b e8		 mov	 ebp, eax
  01c82	89 4c 24 10	 mov	 DWORD PTR _dwSampleRate$[esp+20], ecx
  01c86	0f af eb	 imul	 ebp, ebx
  01c89	0f af e9	 imul	 ebp, ecx

; 5528 :     pWaveFormat->nBlockAlign =
; 5529 :       (WORD)( dwNumberOfChannels * dwBytesPerSample );

  01c8c	0f af c3	 imul	 eax, ebx
  01c8f	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  01c92	66 89 46 0c	 mov	 WORD PTR [esi+12], ax

; 5530 :     pWaveFormat->cbSize = 0;

  01c96	66 89 56 10	 mov	 WORD PTR [esi+16], dx
$L70960:

; 5531 : 
; 5532 :   }
; 5533 : 
; 5534 :   /********************************************************************/
; 5535 :   /*  Set the wave out device open flags.                             */
; 5536 :   /********************************************************************/
; 5537 : 
; 5538 :   dwOpenFlags = CALLBACK_FUNCTION;
; 5539 :   
; 5540 : #ifdef USE_MME_SERVER
; 5541 : 
; 5542 :   /********************************************************************/
; 5543 :   /*  If the WAVE_OPEN_SHARE bit is set in the device options then    */
; 5544 :   /*  enable device sharing.                                          */
; 5545 :   /********************************************************************/
; 5546 : 
; 5547 :   if ( pPlayAudio->dwDeviceOptions & WAVE_OPEN_SHAREABLE )
; 5548 :   {
; 5549 :     dwOpenFlags |= WAVE_OPEN_SHAREABLE;
; 5550 :   }
; 5551 : 
; 5552 : #endif
; 5553 : 
; 5554 :   /********************************************************************/
; 5555 :   /*  Attempt to open the wave output device.                         */
; 5556 :   /********************************************************************/
; 5557 : #ifdef AUD_DEBUG
; 5558 :   OutputDebugString("OpenWaveOutputDevice: waveOutOpen() {1}\n");
; 5559 : #endif
; 5560 : 
; 5561 : #ifdef OS_SIXTY_FOUR_BIT
; 5562 :  
; 5563 :   LOCK_MME_CALL(
; 5564 :     mmStatus = waveOutOpen( &(pPlayAudio->hWaveOut),
; 5565 :                             pPlayAudio->uiSelectedDeviceID,
; 5566 :                             (LPWAVEFORMAT)pWaveFormat,
; 5567 :                             WaveOutCallbackRoutine,
; 5568 :                             pPlayAudio->uiHandleListIndex,
; 5569 :                             dwOpenFlags ))
; 5570 : #else
; 5571 :  
; 5572 :   LOCK_MME_CALL(
; 5573 :     mmStatus = waveOutOpen( &(pPlayAudio->hWaveOut),
; 5574 :                             pPlayAudio->uiSelectedDeviceID,
; 5575 :                             (LPWAVEFORMATEX)pWaveFormat,
; 5576 :                             (DWORD)WaveOutCallbackRoutine,
; 5577 :                             (DWORD)pPlayAudio,
; 5578 :                             dwOpenFlags ))

  01c9a	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  01c9d	68 00 00 03 00	 push	 196608			; 00030000H
  01ca2	57		 push	 edi
  01ca3	68 00 00 00 00	 push	 OFFSET FLAT:_WaveOutCallbackRoutine@20
  01ca8	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  01cab	56		 push	 esi
  01cac	51		 push	 ecx
  01cad	50		 push	 eax
  01cae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutOpen@24
  01cb4	8b e8		 mov	 ebp, eax

; 5579 : #endif
; 5580 : 
; 5581 : #ifdef USE_MME_SERVER
; 5582 : 
; 5583 :   /********************************************************************/
; 5584 :   /*  THIS IS PROBABLY NOT NECESSARY, BUT IT CANNOT HURT.             */
; 5585 :   /*  The MME servers waveOutOpen() function returns a value of       */
; 5586 :   /*  WAVERR_DEVICESHAREABLE if the device is shareable. Change       */
; 5587 :   /*  this to MMSYSERR_NOERROR.                                       */
; 5588 :   /********************************************************************/
; 5589 : 
; 5590 :   if (( pPlayAudio->dwDeviceOptions & WAVE_OPEN_SHAREABLE )
; 5591 :     && ( mmStatus == WAVERR_DEVICESHAREABLE ))
; 5592 :   {
; 5593 :     mmStatus = MMSYSERR_NOERROR;
; 5594 :   }
; 5595 : 
; 5596 : #endif
; 5597 : 
; 5598 :   /********************************************************************/
; 5599 :   /*  If the requested wave output format is WAVE_FORMAT_PCM and the  */
; 5600 :   /*  number of bits per sample is 16 and the format is not supported */
; 5601 :   /*  then try to open the wave output device for 8 bit samples.      */
; 5602 :   /********************************************************************/
; 5603 : 
; 5604 :   if  (( mmStatus == WAVERR_BADFORMAT )
; 5605 :     && ( pWaveFormat->wFormatTag == WAVE_FORMAT_PCM )
; 5606 :     && ( pWaveFormat->wBitsPerSample == 16 ))

  01cb6	83 fd 20	 cmp	 ebp, 32			; 00000020H
  01cb9	75 5e		 jne	 SHORT $L70965
  01cbb	66 83 3e 01	 cmp	 WORD PTR [esi], 1
  01cbf	75 5c		 jne	 SHORT $L71428
  01cc1	66 83 7e 0e 10	 cmp	 WORD PTR [esi+14], 16	; 00000010H
  01cc6	75 55		 jne	 SHORT $L71428

; 5607 :   {
; 5608 :     /******************************************************************/
; 5609 :     /*  Initialize other WAVEFORMATEX structure elements for 8 bit    */
; 5610 :     /*  data.                                                         */
; 5611 :     /******************************************************************/
; 5612 : 
; 5613 :     pWaveFormat->nAvgBytesPerSec = dwSampleRate * dwNumberOfChannels;

  01cc8	8b eb		 mov	 ebp, ebx

; 5614 :     pWaveFormat->nBlockAlign = (WORD)dwNumberOfChannels;
; 5615 :     pWaveFormat->wBitsPerSample = 8;
; 5616 : 
; 5617 :     /******************************************************************/
; 5618 :     /*  Attempt to open the wave output device.                       */
; 5619 :     /******************************************************************/
; 5620 : #ifdef AUD_DEBUG
; 5621 :     OutputDebugString("OpenWaveOutputDevice: waveOutOpen() {2}\n");
; 5622 : #endif
; 5623 : 
; 5624 : #ifdef OS_SIXTY_FOUR_BIT
; 5625 : 
; 5626 :     LOCK_MME_CALL(
; 5627 :       mmStatus = waveOutOpen( &(pPlayAudio->hWaveOut),
; 5628 :                               pPlayAudio->uiSelectedDeviceID,
; 5629 :                               (LPWAVEFORMAT)pWaveFormat,
; 5630 :                               WaveOutCallbackRoutine,
; 5631 :                               pPlayAudio->uiHandleListIndex,
; 5632 :                               dwOpenFlags ))
; 5633 : #else
; 5634 : 
; 5635 :     LOCK_MME_CALL(
; 5636 :       mmStatus = waveOutOpen( &(pPlayAudio->hWaveOut),
; 5637 :                               pPlayAudio->uiSelectedDeviceID,
; 5638 :                               (LPWAVEFORMATEX)pWaveFormat,
; 5639 :                               (DWORD)WaveOutCallbackRoutine,
; 5640 :                               (DWORD)pPlayAudio,
; 5641 :                               dwOpenFlags ))

  01cca	68 00 00 03 00	 push	 196608			; 00030000H
  01ccf	0f af 6c 24 14	 imul	 ebp, DWORD PTR _dwSampleRate$[esp+24]
  01cd4	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  01cd7	66 89 5e 0c	 mov	 WORD PTR [esi+12], bx
  01cdb	66 c7 46 0e 08
	00		 mov	 WORD PTR [esi+14], 8
  01ce1	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
  01ce4	57		 push	 edi
  01ce5	68 00 00 00 00	 push	 OFFSET FLAT:_WaveOutCallbackRoutine@20
  01cea	56		 push	 esi
  01ceb	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  01cee	52		 push	 edx
  01cef	50		 push	 eax
  01cf0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutOpen@24
  01cf6	89 44 24 18	 mov	 DWORD PTR _mmStatus$[esp+16], eax

; 5642 : #endif
; 5643 : 
; 5644 : #ifdef USE_MME_SERVER
; 5645 : 
; 5646 :     /******************************************************************/
; 5647 :     /*  THIS IS PROBABLY NOT NECESSARY, BUT IT CANNOT HURT.           */
; 5648 :     /*  The MME servers waveOutOpen() function returns a value of     */
; 5649 :     /*  WAVERR_DEVICESHAREABLE if the device is shareable. Change     */
; 5650 :     /*  this to MMSYSERR_NOERROR.                                     */
; 5651 :     /******************************************************************/
; 5652 : 
; 5653 :     if (( pPlayAudio->dwDeviceOptions & WAVE_OPEN_SHAREABLE )
; 5654 :       && ( mmStatus == WAVERR_DEVICESHAREABLE ))
; 5655 :     {
; 5656 :       mmStatus = MMSYSERR_NOERROR;
; 5657 :     }
; 5658 : 
; 5659 : #endif
; 5660 : 
; 5661 :     /******************************************************************/
; 5662 :     /*  Reset the WAVEFORMATEX structure elements for 16 bit data.    */
; 5663 :     /******************************************************************/
; 5664 : 
; 5665 :     pWaveFormat->nAvgBytesPerSec =
; 5666 :       dwSampleRate * dwNumberOfChannels << 1;

  01cfa	8d 44 2d 00	 lea	 eax, DWORD PTR [ebp+ebp]

; 5667 :     pWaveFormat->nBlockAlign = (WORD)( dwNumberOfChannels << 1 );
; 5668 :     pWaveFormat->wBitsPerSample = 16;
; 5669 : 
; 5670 :     pPlayAudio->bConvertToEightBit = TRUE;

  01cfe	8b 6c 24 18	 mov	 ebp, DWORD PTR _mmStatus$[esp+16]
  01d02	8d 0c 1b	 lea	 ecx, DWORD PTR [ebx+ebx]
  01d05	89 46 08	 mov	 DWORD PTR [esi+8], eax
  01d08	66 89 4e 0c	 mov	 WORD PTR [esi+12], cx
  01d0c	66 c7 46 0e 10
	00		 mov	 WORD PTR [esi+14], 16	; 00000010H
  01d12	c7 47 50 01 00
	00 00		 mov	 DWORD PTR [edi+80], 1
$L70965:

; 5671 :   }
; 5672 : 
; 5673 :   /********************************************************************/
; 5674 :   /*  Test for an open error.                                         */
; 5675 :   /********************************************************************/
; 5676 : 
; 5677 :   if ( mmStatus )

  01d19	85 ed		 test	 ebp, ebp
  01d1b	74 1a		 je	 SHORT $L71429
$L71428:

; 5678 :   {
; 5679 :     /******************************************************************/
; 5680 :     /*  The error that occured WAS caused by another application      */
; 5681 :     /*  owning the wave output device.                                */
; 5682 :     /******************************************************************/
; 5683 : #ifdef AUD_DEBUG
; 5684 : 	  {
; 5685 : #include <stdio.h>
; 5686 : 		  char szTemp[256]="";
; 5687 : 		  sprintf(szTemp,"OpenWaveOutputDevice: waveOutOpen failed: status=%lu (%08lx)\n",
; 5688 : 			  mmStatus, mmStatus);
; 5689 : 		  OutputDebugString(szTemp);
; 5690 : 	  }
; 5691 : #endif //AUD_DEBUG
; 5692 :     if ( pPlayAudio->bEnableOpenErrorMessage )

  01d1d	8b 47 5c	 mov	 eax, DWORD PTR [edi+92]
  01d20	85 c0		 test	 eax, eax
  01d22	74 13		 je	 SHORT $L71429

; 5693 :     {
; 5694 :       if ( ! ReportStatusToApplication( pPlayAudio,
; 5695 :                                         PA_DEVICE_OPEN_FAILURE,
; 5696 :                                         mmStatus ))

  01d24	55		 push	 ebp
  01d25	6a 03		 push	 3
  01d27	57		 push	 edi
  01d28	e8 00 00 00 00	 call	 _ReportStatusToApplication
  01d2d	83 c4 0c	 add	 esp, 12			; 0000000cH
  01d30	85 c0		 test	 eax, eax
  01d32	75 03		 jne	 SHORT $L71429

; 5697 :       {
; 5698 :         pPlayAudio->bEnableOpenErrorMessage = FALSE;

  01d34	89 47 5c	 mov	 DWORD PTR [edi+92], eax
$L71429:
  01d37	5f		 pop	 edi

; 5699 :       }
; 5700 :     }
; 5701 :   }
; 5702 : 
; 5703 :   return mmStatus;

  01d38	8b c5		 mov	 eax, ebp
  01d3a	5e		 pop	 esi
  01d3b	5d		 pop	 ebp
  01d3c	5b		 pop	 ebx

; 5704 : }

  01d3d	59		 pop	 ecx
  01d3e	c3		 ret	 0
_OpenWaveOutputDevice ENDP
_pWaveFormat$ = 8
_GetWaveFormatSize PROC NEAR

; 5732 :   DWORD dwSize;
; 5733 : 
; 5734 :   if ( pWaveFormat->wFormatTag == WAVE_FORMAT_PCM )

  01d40	8b 44 24 04	 mov	 eax, DWORD PTR _pWaveFormat$[esp-4]
  01d44	66 83 38 01	 cmp	 WORD PTR [eax], 1
  01d48	75 06		 jne	 SHORT $L70978

; 5735 :   {
; 5736 :     dwSize = sizeof(WAVEFORMATEX);

  01d4a	b8 12 00 00 00	 mov	 eax, 18			; 00000012H

; 5741 :   }
; 5742 : 
; 5743 :   return dwSize;
; 5744 : }

  01d4f	c3		 ret	 0
$L70978:

; 5737 :   }
; 5738 :   else
; 5739 :   {
; 5740 :     dwSize = sizeof(WAVEFORMATEX) + pWaveFormat->cbSize;

  01d50	33 c9		 xor	 ecx, ecx
  01d52	66 8b 48 10	 mov	 cx, WORD PTR [eax+16]
  01d56	8b c1		 mov	 eax, ecx
  01d58	83 c0 12	 add	 eax, 18			; 00000012H

; 5741 :   }
; 5742 : 
; 5743 :   return dwSize;
; 5744 : }

  01d5b	c3		 ret	 0
_GetWaveFormatSize ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutReset@4:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_ProcessResetMessage PROC NEAR

; 5772 : {

  01d60	55		 push	 ebp
  01d61	56		 push	 esi

; 5773 :   MMRESULT mmStatus;
; 5774 : 
; 5775 :   /********************************************************************/
; 5776 :   /*  This flag causes the timer thread to abandon sending any        */
; 5777 :   /*  synchronization marks until it reaches the start of the timer   */
; 5778 :   /*  thread main loop.                                               */
; 5779 :   /********************************************************************/
; 5780 : 
; 5781 :   pPlayAudio->bTimerThreadReset = TRUE;

  01d62	8b 74 24 0c	 mov	 esi, DWORD PTR _pPlayAudio$[esp+4]
  01d66	57		 push	 edi
  01d67	bd 01 00 00 00	 mov	 ebp, 1

; 5782 : 
; 5783 : 
; 5784 :   // tek 22jan99 ResetAudioQueue now happens further down
; 5785 : 
; 5786 :   /********************************************************************/
; 5787 :   /*  Set audio position counts to zero.                              */
; 5788 :   /********************************************************************/
; 5789 : 
; 5790 :   pPlayAudio->dwPositionBase = 0;
; 5791 : 
; 5792 :   OP_LockMutex( pPlayAudio->hmxBytesPlayed );

  01d6c	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  01d6f	89 6e 68	 mov	 DWORD PTR [esi+104], ebp
  01d72	50		 push	 eax
  01d73	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], 0
  01d7a	e8 00 00 00 00	 call	 _OP_LockMutex

; 5793 :   pPlayAudio->dwBytesPlayed = 0;
; 5794 :   OP_UnlockMutex( pPlayAudio->hmxBytesPlayed );

  01d7f	8b 4e 70	 mov	 ecx, DWORD PTR [esi+112]
  01d82	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0
  01d89	51		 push	 ecx
  01d8a	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 5795 : 
; 5796 :   /********************************************************************/
; 5797 :   /*  Zero the "queued byte" counter.                                 */
; 5798 :   /********************************************************************/
; 5799 : 
; 5800 :   OP_LockMutex( pPlayAudio->hmxQueuedByteCount );

  01d8f	8b 96 80 00 00
	00		 mov	 edx, DWORD PTR [esi+128]
  01d95	52		 push	 edx
  01d96	e8 00 00 00 00	 call	 _OP_LockMutex

; 5801 :   pPlayAudio->dwQueuedByteCount = 0;
; 5802 :   OP_UnlockMutex( pPlayAudio->hmxQueuedByteCount );

  01d9b	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  01da1	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
  01da8	50		 push	 eax
  01da9	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 5803 : 
; 5804 :   /********************************************************************/
; 5805 :   /*  Free all synchronization marks in the synchronization mark      */
; 5806 :   /*  linked list.                                                    */
; 5807 :   /********************************************************************/
; 5808 : 
; 5809 :   ClearSynchronizationMarkList( pPlayAudio );

  01dae	56		 push	 esi
  01daf	e8 00 00 00 00	 call	 _ClearSynchronizationMarkList

; 5810 : 
; 5811 :   /********************************************************************/
; 5812 :   /*  If the audio device is open then reset it and return all wave   */
; 5813 :   /*  headers. Then the Process_MM_WOM_DONE_Message() function will   */
; 5814 :   /*  clear the "Reset Complete" event when all buffers have          */
; 5815 :   /*  completed. Otherwise clear the "Reset Complete" event here.     */
; 5816 :   /********************************************************************/
; 5817 : 
; 5818 :   if (( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )
; 5819 :       && ( pPlayAudio->iSamplesWaitingForCompletion != 0 ))

  01db4	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  01db7	83 c4 14	 add	 esp, 20			; 00000014H
  01dba	83 f8 02	 cmp	 eax, 2
  01dbd	75 18		 jne	 SHORT $L70986
  01dbf	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  01dc2	85 c0		 test	 eax, eax
  01dc4	74 11		 je	 SHORT $L70986

; 5820 :     {
; 5821 : #ifdef TYPING_MODE
; 5822 :       DWORD dwVolume; // tek 19nov97
; 5823 :       MMRESULT mmVolSetStatus; // tek 19nov97
; 5824 : #endif //TYPING_MODE
; 5825 :       
; 5826 :       pPlayAudio->dwAudioPlayState = AUDIO_STATE_RESET;
; 5827 : #ifdef TYPING_MODE
; 5828 :       // tek 19nov97 set the volume to zero before doing the reset, 
; 5829 :       // and put it back later.
; 5830 :       // this is part of bats518, but we need to do it here at a very
; 5831 :       // low level so we don't leave the wave device in a bad state if we
; 5832 :       // get aborted
; 5833 :       mmVolSetStatus = waveOutGetVolume(pPlayAudio->hWaveOut,&dwVolume);
; 5834 :       if (mmVolSetStatus ==  MMSYSERR_NOERROR)
; 5835 : 	{
; 5836 : 	  mmVolSetStatus = waveOutSetVolume(pPlayAudio->hWaveOut,0);
; 5837 : 	}
; 5838 : #endif //TYPING_MODE
; 5839 :   
; 5840 :       LOCK_MME_CALL( mmStatus = waveOutReset( pPlayAudio->hWaveOut ))

  01dc6	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01dc9	89 6e 38	 mov	 DWORD PTR [esi+56], ebp
  01dcc	51		 push	 ecx
  01dcd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutReset@4
  01dd3	8b f8		 mov	 edi, eax

; 5841 : #ifdef TYPING_MODE
; 5842 : 	if (mmVolSetStatus ==  MMSYSERR_NOERROR)
; 5843 : 	  {
; 5844 : 	    mmVolSetStatus = waveOutSetVolume(pPlayAudio->hWaveOut,dwVolume);
; 5845 : 	  }
; 5846 : #endif //TYPING_MODE
; 5847 :       
; 5848 :     }  // if (( pPlayAudio...
; 5849 :   else

  01dd5	eb 0e		 jmp	 SHORT $L70987
$L70986:

; 5850 :     {
; 5851 :       OP_SetEvent( pPlayAudio->hevResetComplete );

  01dd7	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  01dda	52		 push	 edx
  01ddb	e8 00 00 00 00	 call	 _OP_SetEvent
  01de0	83 c4 04	 add	 esp, 4

; 5852 : #ifdef AUD_DEBUG //tek 22may97
; 5853 :       {
; 5854 : 		  char szTemp[256]="";
; 5855 : 		  sprintf(szTemp,"ProcResetMsg: calling waveOutReset at %ld\n",
; 5856 : 			  timeGetTime()
; 5857 : 			  );
; 5858 : 		  OutputDebugString(szTemp);
; 5859 : 	  }
; 5860 : #endif //AUD_DEBUG
; 5861 : 	  
; 5862 :     mmStatus = MMSYSERR_NOERROR;

  01de3	33 ff		 xor	 edi, edi
$L70987:

; 5863 :   }
; 5864 :   // tek 22jan99 if audio is truly dead, we can call ResetAudioQueue now.
; 5865 :   if ( pPlayAudio->iSamplesWaitingForCompletion == 0 )

  01de5	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  01de8	85 c0		 test	 eax, eax
  01dea	75 09		 jne	 SHORT $L71435

; 5866 :   {
; 5867 : 	  ResetAudioQueue(pPlayAudio);

  01dec	56		 push	 esi
  01ded	e8 00 00 00 00	 call	 _ResetAudioQueue
  01df2	83 c4 04	 add	 esp, 4
$L71435:

; 5868 :   }
; 5869 : 
; 5870 : 
; 5871 :   /********************************************************************/
; 5872 :   /*  Enable the sending of Device open failure error messages.       */
; 5873 :   /********************************************************************/
; 5874 : 
; 5875 :   pPlayAudio->bEnableOpenErrorMessage = TRUE;
; 5876 : 
; 5877 :   return mmStatus;

  01df5	8b c7		 mov	 eax, edi
  01df7	89 6e 5c	 mov	 DWORD PTR [esi+92], ebp
  01dfa	5f		 pop	 edi
  01dfb	5e		 pop	 esi
  01dfc	5d		 pop	 ebp

; 5878 : }

  01dfd	c3		 ret	 0
_ProcessResetMessage ENDP
_pPlayAudio$ = 8
_ClearSynchronizationMarkList PROC NEAR

; 5906 : {

  01e00	53		 push	 ebx

; 5907 :   LPSYNC_MARK_T pSyncMark;
; 5908 :   LPSYNC_MARK_T pNextSyncMark;
; 5909 : 
; 5910 :   /********************************************************************/
; 5911 :   /*  Free all synchronization marks in the synchronization mark      */
; 5912 :   /*  linked list.                                                    */
; 5913 :   /********************************************************************/
; 5914 : 
; 5915 :   OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  01e01	8b 5c 24 08	 mov	 ebx, DWORD PTR _pPlayAudio$[esp]
  01e05	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [ebx+136]
  01e0b	50		 push	 eax
  01e0c	e8 00 00 00 00	 call	 _OP_LockMutex

; 5916 : 
; 5917 :   pSyncMark = pPlayAudio->pSyncMarkList;

  01e11	8b 83 98 00 00
	00		 mov	 eax, DWORD PTR [ebx+152]
  01e17	83 c4 04	 add	 esp, 4

; 5918 :   pPlayAudio->pSyncMarkList = NULL;
; 5919 : 
; 5920 :   while ( pSyncMark != NULL )

  01e1a	85 c0		 test	 eax, eax
  01e1c	c7 83 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+152], 0
  01e26	74 18		 je	 SHORT $L70998
  01e28	56		 push	 esi
  01e29	57		 push	 edi
  01e2a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
$L70997:

; 5921 :   {
; 5922 :     pNextSyncMark = pSyncMark->pLink;

  01e30	8b 30		 mov	 esi, DWORD PTR [eax]

; 5923 : 
; 5924 :     free( pSyncMark );

  01e32	50		 push	 eax
  01e33	ff d7		 call	 edi
  01e35	83 c4 04	 add	 esp, 4

; 5925 : 
; 5926 :     pSyncMark = pNextSyncMark;

  01e38	8b c6		 mov	 eax, esi
  01e3a	85 f6		 test	 esi, esi
  01e3c	75 f2		 jne	 SHORT $L70997
  01e3e	5f		 pop	 edi
  01e3f	5e		 pop	 esi
$L70998:

; 5927 :   }
; 5928 : 
; 5929 :   OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  01e40	8b 8b 88 00 00
	00		 mov	 ecx, DWORD PTR [ebx+136]
  01e46	51		 push	 ecx
  01e47	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01e4c	83 c4 04	 add	 esp, 4
  01e4f	5b		 pop	 ebx

; 5930 : 
; 5931 :   return;
; 5932 : }

  01e50	c3		 ret	 0
_ClearSynchronizationMarkList ENDP
_pPlayAudio$ = 8
_ResetAudioQueue PROC NEAR

; 5961 : {

  01e60	56		 push	 esi
  01e61	57		 push	 edi

; 5962 :   LPPLAY_RING_T pPlayAudioRing;
; 5963 :   unsigned int uiI; //tek 22may97
; 5964 :   pPlayAudioRing = pPlayAudio->pPlayAudioRing;

  01e62	8b 7c 24 0c	 mov	 edi, DWORD PTR _pPlayAudio$[esp+4]

; 5965 : 
; 5966 : //tek 22may97
; 5967 : #ifdef AUD_DEBUG
; 5968 :   {
; 5969 : 		  char  szTemp[256]="";
; 5970 : 		  sprintf(szTemp,"ResetAudioQueue: at %08lu\n",
; 5971 : 			  timeGetTime()
; 5972 : 			  );
; 5973 : 		  OutputDebugString(szTemp);
; 5974 :   }
; 5975 : #endif //AUD_DEBUG
; 5976 :   // tek 05nov97 bats 508? (HJ Echo problem)
; 5977 :   // this needs to be done under the QueueCount mutex..
; 5978 : 
; 5979 :   OP_LockMutex( pPlayAudio->hmxQueueCount ); // own the audio queue...

  01e66	8b 47 78	 mov	 eax, DWORD PTR [edi+120]
  01e69	8b b7 94 00 00
	00		 mov	 esi, DWORD PTR [edi+148]
  01e6f	50		 push	 eax
  01e70	e8 00 00 00 00	 call	 _OP_LockMutex

; 5980 :   pPlayAudioRing->pQueueInput = pPlayAudioRing->pQueueStart;

  01e75	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 5981 :   pPlayAudioRing->pQueueOutput = pPlayAudioRing->pQueueStart;
; 5982 :   pPlayAudioRing->iInputPosition = 0;

  01e78	33 c9		 xor	 ecx, ecx
  01e7a	83 c4 04	 add	 esp, 4
  01e7d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  01e80	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  01e83	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 5983 :   pPlayAudioRing->iOutputPosition = 0;

  01e86	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 5984 :   pPlayAudioRing->iQueueCount = 0;

  01e89	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
  01e8c	33 c0		 xor	 eax, eax
$L71004:

; 5985 : 
; 5986 :   // we use the lpData field of each wave header to signal free/busy
; 5987 :   // for that header; so, zero them out here..
; 5988 :   for ( uiI = 0; uiI < MAXIMUM_BUFFERS_QUEUED; uiI++ )
; 5989 :       pPlayAudio->ppWaveHdr[uiI]->lpData = NULL;

  01e8e	8b 97 90 00 00
	00		 mov	 edx, DWORD PTR [edi+144]
  01e94	83 c0 04	 add	 eax, 4
  01e97	83 f8 20	 cmp	 eax, 32			; 00000020H
  01e9a	8b 54 10 fc	 mov	 edx, DWORD PTR [eax+edx-4]
  01e9e	89 0a		 mov	 DWORD PTR [edx], ecx
  01ea0	7c ec		 jl	 SHORT $L71004

; 5990 : 
; 5991 :   OP_SetEvent( pPlayAudio->hevQueueNotFull );

  01ea2	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  01ea5	50		 push	 eax
  01ea6	e8 00 00 00 00	 call	 _OP_SetEvent

; 5992 :   OP_UnlockMutex( pPlayAudio->hmxQueueCount ); // tek 05nov97 unlock..

  01eab	8b 4f 78	 mov	 ecx, DWORD PTR [edi+120]
  01eae	51		 push	 ecx
  01eaf	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01eb4	83 c4 08	 add	 esp, 8
  01eb7	5f		 pop	 edi
  01eb8	5e		 pop	 esi

; 5993 : #ifdef AUD_DEBUG
; 5994 :   {
; 5995 : 		  char  szTemp[256]="";
; 5996 : 		  sprintf(szTemp,"ResetAudioQueue: exit at %08lu\n",
; 5997 : 			  timeGetTime()
; 5998 : 			  );
; 5999 : 		  OutputDebugString(szTemp);
; 6000 :   }
; 6001 : #endif //AUD_DEBUG
; 6002 :   return;
; 6003 : }

  01eb9	c3		 ret	 0
_ResetAudioQueue ENDP
_pPlayAudio$ = 8
_ProcessPauseMessage PROC NEAR

; 6030 : {

  01ec0	56		 push	 esi

; 6031 :   MMRESULT mmStatus;
; 6032 : 
; 6033 :   /********************************************************************/
; 6034 :   /*  If the wave output device is active then pause it. If it is not */
; 6035 :   /*  active then set the pause flag.                                 */
; 6036 :   /********************************************************************/
; 6037 : 
; 6038 :   if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )

  01ec1	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  01ec5	57		 push	 edi
  01ec6	83 7e 34 02	 cmp	 DWORD PTR [esi+52], 2
  01eca	75 37		 jne	 SHORT $L71012

; 6039 :   {
; 6040 :     LOCK_MME_CALL( mmStatus = waveOutPause( pPlayAudio->hWaveOut ))

  01ecc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01ecf	50		 push	 eax
  01ed0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutPause@4
  01ed6	8b f8		 mov	 edi, eax

; 6045 :   }
; 6046 : 
; 6047 :   /********************************************************************/
; 6048 :   /*  If the restart was successful then set the pause flag.          */
; 6049 :   /********************************************************************/
; 6050 : 
; 6051 :   if ( mmStatus == MMSYSERR_NOERROR )

  01ed8	85 ff		 test	 edi, edi
  01eda	75 22		 jne	 SHORT $L71444
$L71443:

; 6052 :   {
; 6053 :     OP_LockMutex( pPlayAudio->hmxPauseFlag );

  01edc	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  01ee2	51		 push	 ecx
  01ee3	e8 00 00 00 00	 call	 _OP_LockMutex

; 6054 :     pPlayAudio->bPaused = TRUE;
; 6055 :     OP_UnlockMutex( pPlayAudio->hmxPauseFlag );

  01ee8	8b 96 84 00 00
	00		 mov	 edx, DWORD PTR [esi+132]
  01eee	c7 46 58 01 00
	00 00		 mov	 DWORD PTR [esi+88], 1
  01ef5	52		 push	 edx
  01ef6	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01efb	83 c4 08	 add	 esp, 8
$L71444:

; 6056 :   }
; 6057 : 
; 6058 :   return mmStatus;

  01efe	8b c7		 mov	 eax, edi
  01f00	5f		 pop	 edi
  01f01	5e		 pop	 esi

; 6059 : }

  01f02	c3		 ret	 0
$L71012:

; 6041 :   }
; 6042 :   else
; 6043 :   {
; 6044 :     mmStatus = MMSYSERR_NOERROR;

  01f03	33 ff		 xor	 edi, edi

; 6045 :   }
; 6046 : 
; 6047 :   /********************************************************************/
; 6048 :   /*  If the restart was successful then set the pause flag.          */
; 6049 :   /********************************************************************/
; 6050 : 
; 6051 :   if ( mmStatus == MMSYSERR_NOERROR )

  01f05	eb d5		 jmp	 SHORT $L71443
_ProcessPauseMessage ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutRestart@4:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_ProcessResumeMessage PROC NEAR

; 6086 : {

  01f10	56		 push	 esi

; 6087 :   MMRESULT mmStatus;
; 6088 : 
; 6089 :   /********************************************************************/
; 6090 :   /*  If the wave output device was paused then restart it.           */
; 6091 :   /********************************************************************/
; 6092 : 
; 6093 :   if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )

  01f11	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  01f15	57		 push	 edi
  01f16	83 7e 34 02	 cmp	 DWORD PTR [esi+52], 2
  01f1a	75 40		 jne	 SHORT $L71019

; 6094 :   {
; 6095 :     LOCK_MME_CALL( mmStatus = waveOutRestart( pPlayAudio->hWaveOut ))

  01f1c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01f1f	50		 push	 eax
  01f20	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutRestart@4
  01f26	8b f8		 mov	 edi, eax

; 6100 :   }
; 6101 : 
; 6102 :   /********************************************************************/
; 6103 :   /*  If the restart was successful then reset the pause flag.        */
; 6104 :   /********************************************************************/
; 6105 : 
; 6106 :   if ( mmStatus == MMSYSERR_NOERROR )

  01f28	85 ff		 test	 edi, edi
  01f2a	75 2b		 jne	 SHORT $L71447
$L71446:

; 6107 :   {
; 6108 :     OP_LockMutex( pPlayAudio->hmxPauseFlag );

  01f2c	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  01f32	51		 push	 ecx
  01f33	e8 00 00 00 00	 call	 _OP_LockMutex

; 6109 :     pPlayAudio->bPaused = FALSE;
; 6110 :     OP_SetEvent( pPlayAudio->hevTimerThreadActive );

  01f38	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  01f3b	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  01f42	52		 push	 edx
  01f43	e8 00 00 00 00	 call	 _OP_SetEvent

; 6111 :     OP_UnlockMutex( pPlayAudio->hmxPauseFlag );

  01f48	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  01f4e	50		 push	 eax
  01f4f	e8 00 00 00 00	 call	 _OP_UnlockMutex
  01f54	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71447:

; 6112 :   }
; 6113 : 
; 6114 :   return mmStatus;

  01f57	8b c7		 mov	 eax, edi
  01f59	5f		 pop	 edi
  01f5a	5e		 pop	 esi

; 6115 : }

  01f5b	c3		 ret	 0
$L71019:

; 6096 :   }
; 6097 :   else
; 6098 :   {
; 6099 :     mmStatus = MMSYSERR_NOERROR;

  01f5c	33 ff		 xor	 edi, edi

; 6100 :   }
; 6101 : 
; 6102 :   /********************************************************************/
; 6103 :   /*  If the restart was successful then reset the pause flag.        */
; 6104 :   /********************************************************************/
; 6105 : 
; 6106 :   if ( mmStatus == MMSYSERR_NOERROR )

  01f5e	eb cc		 jmp	 SHORT $L71446
_ProcessResumeMessage ENDP
_pPlayAudio$ = 8
_pWaveFormat$ = 12
_dwSampleRate$ = -4
_ProcessSetFormatMessage PROC NEAR

; 6150 : {

  01f60	51		 push	 ecx
  01f61	53		 push	 ebx
  01f62	55		 push	 ebp
  01f63	56		 push	 esi

; 6151 :   DWORD dwSampleRate=0;
; 6152 :   DWORD dwNumberOfChannels=0;
; 6153 :   DWORD dwBytesPerSample=0;
; 6154 :   DWORD dwQueryFlags=0;
; 6155 :   MMRESULT mmStatus;
; 6156 : 
; 6157 :   /********************************************************************/
; 6158 :   /*  The wBitsPerSample element, the nChannels element, and the      */
; 6159 :   /*  nSamplesPerSec element of the WAVEFORMATEX structure are        */
; 6160 :   /*  used to calculate the values of the other elements of the       */
; 6161 :   /*  WAVEFORMATEX structure.                                         */
; 6162 :   /*                                                                  */
; 6163 :   /*  If the wFormatTag element of the WAVEFORMATEX structure         */
; 6164 :   /*  is NOT equal to WAVE_FORMAT_PCM then all of the fields of       */
; 6165 :   /*  the WAVEFORMATEX structure must be filled in and are used       */
; 6166 :   /*  in the call to the waveOutOpen() function.                      */
; 6167 :   /********************************************************************/
; 6168 : 
; 6169 :   if ( pWaveFormat->wFormatTag == WAVE_FORMAT_PCM )

  01f64	8b 74 24 18	 mov	 esi, DWORD PTR _pWaveFormat$[esp+12]
  01f68	57		 push	 edi
  01f69	33 db		 xor	 ebx, ebx
  01f6b	66 8b 0e	 mov	 cx, WORD PTR [esi]
  01f6e	33 ff		 xor	 edi, edi
  01f70	66 83 f9 01	 cmp	 cx, 1
  01f74	89 5c 24 10	 mov	 DWORD PTR _dwSampleRate$[esp+20], ebx
  01f78	75 2a		 jne	 SHORT $L71032

; 6170 :   {
; 6171 :     /******************************************************************/
; 6172 :     /*  The wFormatTag element is equal to WAVE_FORMAT_PCM.           */
; 6173 :     /******************************************************************/
; 6174 : 
; 6175 :     dwSampleRate = pWaveFormat->nSamplesPerSec;
; 6176 :     dwNumberOfChannels = pWaveFormat->nChannels;

  01f7a	66 8b 7e 02	 mov	 di, WORD PTR [esi+2]

; 6177 :     dwBytesPerSample = pWaveFormat->wBitsPerSample >> 3;

  01f7e	33 c0		 xor	 eax, eax
  01f80	66 8b 46 0e	 mov	 ax, WORD PTR [esi+14]
  01f84	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  01f87	c1 e8 03	 shr	 eax, 3

; 6178 : 
; 6179 :     /******************************************************************/
; 6180 :     /*  Initialize other WAVEFORMATEX structure elements.             */
; 6181 :     /******************************************************************/
; 6182 : 
; 6183 :     pWaveFormat->nAvgBytesPerSec =
; 6184 :       dwSampleRate * dwNumberOfChannels * dwBytesPerSample;

  01f8a	8b e8		 mov	 ebp, eax
  01f8c	89 54 24 10	 mov	 DWORD PTR _dwSampleRate$[esp+20], edx
  01f90	0f af ef	 imul	 ebp, edi
  01f93	0f af ea	 imul	 ebp, edx

; 6185 :     pWaveFormat->nBlockAlign =
; 6186 :       (WORD)( dwNumberOfChannels * dwBytesPerSample );

  01f96	0f af c7	 imul	 eax, edi
  01f99	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  01f9c	66 89 46 0c	 mov	 WORD PTR [esi+12], ax

; 6187 :     pWaveFormat->cbSize = 0;

  01fa0	66 89 5e 10	 mov	 WORD PTR [esi+16], bx
$L71032:

; 6188 :   }
; 6189 : 
; 6190 :   /********************************************************************/
; 6191 :   /*  If PA_OWN_DEVICE is specified AND the requested Sample Rate and */
; 6192 :   /*  the requested Number Of Channels do NOT match the current       */
; 6193 :   /*  settings then an error is returned.                             */
; 6194 :   /********************************************************************/
; 6195 : 
; 6196 :   if ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )

  01fa4	8b 6c 24 18	 mov	 ebp, DWORD PTR _pPlayAudio$[esp+16]
  01fa8	f6 45 3c 01	 test	 BYTE PTR [ebp+60], 1
  01fac	74 61		 je	 SHORT $L71034

; 6197 :   {
; 6198 :     /******************************************************************/
; 6199 :     /*  The audio device is owned. This means that the wave output    */
; 6200 :     /*  device will not be closed unless the PA_DestroyPlayHandle()   */
; 6201 :     /*  function is called. In this case, the requested format must   */
; 6202 :     /*  match the actual data format currently being used.            */
; 6203 :     /*  One exception is that if the wFormatTag is equal to           */
; 6204 :     /*  WAVE_FORMAT_PCM then the several other fields will            */
; 6205 :     /*  automatically match (Except the wBitsPerSample field that     */
; 6206 :     /*  does not necessarily to match in this case).                  */
; 6207 :     /******************************************************************/
; 6208 : 
; 6209 :     if (( pWaveFormat->wFormatTag != pPlayAudio->pWaveFormat->wFormatTag )
; 6210 :       || ( pWaveFormat->nSamplesPerSec
; 6211 :                 != pPlayAudio->pWaveFormat->nSamplesPerSec )
; 6212 :       || ( pWaveFormat->nChannels != pPlayAudio->pWaveFormat->nChannels ))

  01fae	8b ad 9c 00 00
	00		 mov	 ebp, DWORD PTR [ebp+156]
  01fb4	66 3b 4d 00	 cmp	 cx, WORD PTR [ebp]
  01fb8	75 4a		 jne	 SHORT $L71036
  01fba	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  01fbd	8b 55 04	 mov	 edx, DWORD PTR [ebp+4]
  01fc0	3b c2		 cmp	 eax, edx
  01fc2	75 40		 jne	 SHORT $L71036
  01fc4	66 8b 56 02	 mov	 dx, WORD PTR [esi+2]
  01fc8	66 3b 55 02	 cmp	 dx, WORD PTR [ebp+2]
  01fcc	75 36		 jne	 SHORT $L71036

; 6213 :       return MMSYSERR_ERROR;
; 6214 : 
; 6215 :     if ( pWaveFormat->wFormatTag != WAVE_FORMAT_PCM )

  01fce	66 83 f9 01	 cmp	 cx, 1
  01fd2	0f 84 b5 00 00
	00		 je	 $L71051

; 6216 :     {
; 6217 :       if (( pWaveFormat->nAvgBytesPerSec
; 6218 :                   != pPlayAudio->pWaveFormat->nAvgBytesPerSec )
; 6219 :         || ( pWaveFormat->nBlockAlign
; 6220 :                   != pPlayAudio->pWaveFormat->nBlockAlign )
; 6221 :         || ( pWaveFormat->wBitsPerSample
; 6222 :                   != pPlayAudio->pWaveFormat->wBitsPerSample )
; 6223 :         || ( pWaveFormat->cbSize != pPlayAudio->pWaveFormat->cbSize ))

  01fd8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01fdb	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  01fde	3b c1		 cmp	 eax, ecx
  01fe0	75 22		 jne	 SHORT $L71036
  01fe2	66 8b 4e 0c	 mov	 cx, WORD PTR [esi+12]
  01fe6	66 3b 4d 0c	 cmp	 cx, WORD PTR [ebp+12]
  01fea	75 18		 jne	 SHORT $L71036
  01fec	66 8b 56 0e	 mov	 dx, WORD PTR [esi+14]
  01ff0	66 3b 55 0e	 cmp	 dx, WORD PTR [ebp+14]
  01ff4	75 0e		 jne	 SHORT $L71036
  01ff6	66 8b 46 10	 mov	 ax, WORD PTR [esi+16]
  01ffa	66 3b 45 10	 cmp	 ax, WORD PTR [ebp+16]
  01ffe	0f 84 89 00 00
	00		 je	 $L71051
$L71036:
  02004	5f		 pop	 edi
  02005	5e		 pop	 esi
  02006	5d		 pop	 ebp

; 6224 :       return MMSYSERR_ERROR;

  02007	b8 01 00 00 00	 mov	 eax, 1
  0200c	5b		 pop	 ebx

; 6418 : }

  0200d	59		 pop	 ecx
  0200e	c3		 ret	 0
$L71034:

; 6225 :     }
; 6226 :   }
; 6227 :   else
; 6228 :   {
; 6229 :     /******************************************************************/
; 6230 :     /*  If the audio device is not inactive then return an error.     */
; 6231 :     /******************************************************************/
; 6232 : 
; 6233 :     if ( pPlayAudio->dwAudioDeviceState != AUDIO_DEVICE_INACTIVE )

  0200f	39 5d 34	 cmp	 DWORD PTR [ebp+52], ebx
  02012	74 0b		 je	 SHORT $L71041
  02014	5f		 pop	 edi
  02015	5e		 pop	 esi
  02016	5d		 pop	 ebp

; 6234 :     {
; 6235 :       return MMSYSERR_ALLOCATED;

  02017	b8 04 00 00 00	 mov	 eax, 4
  0201c	5b		 pop	 ebx

; 6418 : }

  0201d	59		 pop	 ecx
  0201e	c3		 ret	 0
$L71041:

; 6236 :     }
; 6237 :     else
; 6238 :     {
; 6239 :       /****************************************************************/
; 6240 :       /*  If the WAVEFORMATEX data structure has a wFormatTag         */
; 6241 :       /*  element equal to WAVE_FORMAT_PCM then the device is tested  */
; 6242 :       /*  for either 16 or 8 bit output. Whether 8 or 16 bits will    */
; 6243 :       /*  succeed depends on the audio data size and the audio        */
; 6244 :       /*  driver. If the audio samples are 16 bits and only 8 bit     */
; 6245 :       /*  output is supported by the audio driver then the 16 bit     */
; 6246 :       /*  audio samples are converted to 8 bit audio samples in the   */
; 6247 :       /*  WriteBufferToWaveDevice() function. This conversion is      */
; 6248 :       /*  indicated by the bConvertToEightBit flag.                   */
; 6249 :       /*                                                              */
; 6250 :       /*  If the wFormatTag element of the WAVEFORMATEX structure     */
; 6251 :       /*  is NOT equal to WAVE_FORMAT_PCM then all of the fields of   */
; 6252 :       /*  the WAVEFORMATEX structure must be filled in and are used   */
; 6253 :       /*  in the call to the waveOutOpen() function.                  */
; 6254 :       /****************************************************************/
; 6255 : 
; 6256 :       /****************************************************************/
; 6257 :       /*  Set the wave out device query flags.                        */
; 6258 :       /****************************************************************/
; 6259 : 
; 6260 :       dwQueryFlags = WAVE_FORMAT_QUERY;
; 6261 :   
; 6262 : #ifdef USE_MME_SERVER
; 6263 : 
; 6264 :       /****************************************************************/
; 6265 :       /*  If the WAVE_OPEN_SHARE bit is set in the device options     */
; 6266 :       /*  then enable device sharing.                                 */
; 6267 :       /****************************************************************/
; 6268 : 
; 6269 :       if ( pPlayAudio->dwDeviceOptions & WAVE_OPEN_SHAREABLE )
; 6270 :       {
; 6271 :         dwQueryFlags |= WAVE_OPEN_SHAREABLE;
; 6272 :       }
; 6273 : 
; 6274 : #endif
; 6275 : 
; 6276 : 	
; 6277 :       /****************************************************************/
; 6278 :       /*  Query the wave output device.                               */
; 6279 :       /****************************************************************/
; 6280 : 
; 6281 : #ifdef USE_MME_SERVER
; 6282 : 
; 6283 :       LOCK_MME_CALL(
; 6284 :         mmStatus = waveOutOpen( NULL,
; 6285 :                                 pPlayAudio->uiSelectedDeviceID,
; 6286 :                                 (LPWAVEFORMAT)pWaveFormat,
; 6287 :                                 0,
; 6288 :                                 0,
; 6289 :                                 dwQueryFlags ))
; 6290 : #else
; 6291 :       LOCK_MME_CALL(
; 6292 :         mmStatus = waveOutOpen( NULL,
; 6293 :                                 pPlayAudio->uiSelectedDeviceID,
; 6294 :                                 (LPWAVEFORMATEX)pWaveFormat,
; 6295 :                                 0,
; 6296 :                                 0,
; 6297 :                                 dwQueryFlags ))

  0201f	8b 4d 20	 mov	 ecx, DWORD PTR [ebp+32]
  02022	6a 01		 push	 1
  02024	53		 push	 ebx
  02025	53		 push	 ebx
  02026	56		 push	 esi
  02027	51		 push	 ecx
  02028	53		 push	 ebx
  02029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutOpen@24

; 6298 : #endif
; 6299 : 
; 6300 : #ifdef USE_MME_SERVER
; 6301 : 
; 6302 :       /****************************************************************/
; 6303 :       /*  THIS IS PROBABLY NOT NECESSARY, BUT IT CANNOT HURT.         */
; 6304 :       /*  The MME servers waveOutOpen() function returns a value of   */
; 6305 :       /*  WAVERR_DEVICESHAREABLE if the device is shareable. Change   */
; 6306 :       /*  this to MMSYSERR_NOERROR.                                   */
; 6307 :       /****************************************************************/
; 6308 : 
; 6309 :       if (( pPlayAudio->dwDeviceOptions & WAVE_OPEN_SHAREABLE )
; 6310 :         && ( mmStatus == WAVERR_DEVICESHAREABLE ))
; 6311 :       {
; 6312 :         mmStatus = MMSYSERR_NOERROR;
; 6313 :       }
; 6314 : 
; 6315 : #endif
; 6316 : 
; 6317 :       /****************************************************************/
; 6318 :       /*  If the requested wave output format is WAVE_FORMAT_PCM and  */
; 6319 :       /*  the number of bits per sample is 16 and the format is not   */
; 6320 :       /*  supported then try to query the wave output device for 8    */
; 6321 :       /*  bit samples.                                                */
; 6322 :       /****************************************************************/
; 6323 : 
; 6324 : /* TQL 05/21/1997  change this for OSF build */
; 6325 :       if(
; 6326 : #if defined WIN32
; 6327 : 	 ( mmStatus == WAVERR_BADFORMAT )
; 6328 : #endif
; 6329 : #if defined __osf__ || defined __linux__  
; 6330 : 	 ( mmStatus == MMSYSERR_NOTSUPPORTED )
; 6331 : #endif
; 6332 : 	 && ( pWaveFormat->wFormatTag == WAVE_FORMAT_PCM )
; 6333 : 	 && ( pWaveFormat->wBitsPerSample == 16 ))

  0202f	83 f8 20	 cmp	 eax, 32			; 00000020H
  02032	75 47		 jne	 SHORT $L71045
  02034	66 83 3e 01	 cmp	 WORD PTR [esi], 1
  02038	75 55		 jne	 SHORT $L71026
  0203a	66 83 7e 0e 10	 cmp	 WORD PTR [esi+14], 16	; 00000010H
  0203f	75 4e		 jne	 SHORT $L71026

; 6334 : 	{
; 6335 : 	  /**************************************************************/
; 6336 : 	  /*  Initialize other WAVEFORMATEX structure elements for 8    */
; 6337 : 	  /*  bit data.                                                 */
; 6338 : 	  /**************************************************************/
; 6339 : 	  
; 6340 : 	  pWaveFormat->nAvgBytesPerSec = dwSampleRate * dwNumberOfChannels;

  02041	8b df		 mov	 ebx, edi

; 6341 : 	  pWaveFormat->nBlockAlign = (WORD)dwNumberOfChannels;
; 6342 : 	  pWaveFormat->wBitsPerSample = 8;
; 6343 : 	  
; 6344 : 	  /**************************************************************/
; 6345 : 	  /*  Query the wave output device.                             */
; 6346 : 	  /**************************************************************/
; 6347 : 	  
; 6348 : #ifdef USE_MME_SERVER
; 6349 : 	  
; 6350 : 	  LOCK_MME_CALL(
; 6351 : 			mmStatus = waveOutOpen( NULL,
; 6352 : 						pPlayAudio->uiSelectedDeviceID,
; 6353 : 						(LPWAVEFORMAT)pWaveFormat,
; 6354 : 						0,
; 6355 : 						0,
; 6356 : 						dwQueryFlags ))
; 6357 : #else
; 6358 : 	    LOCK_MME_CALL(
; 6359 : 			  mmStatus = waveOutOpen( NULL,
; 6360 : 						  pPlayAudio->uiSelectedDeviceID,
; 6361 : 						  (LPWAVEFORMATEX)pWaveFormat,
; 6362 : 						  0,
; 6363 : 						  0,
; 6364 : 						  dwQueryFlags ))

  02043	6a 01		 push	 1
  02045	0f af 5c 24 14	 imul	 ebx, DWORD PTR _dwSampleRate$[esp+24]
  0204a	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  0204d	66 89 7e 0c	 mov	 WORD PTR [esi+12], di
  02051	66 c7 46 0e 08
	00		 mov	 WORD PTR [esi+14], 8
  02057	8b 55 20	 mov	 edx, DWORD PTR [ebp+32]
  0205a	6a 00		 push	 0
  0205c	6a 00		 push	 0
  0205e	56		 push	 esi
  0205f	52		 push	 edx
  02060	6a 00		 push	 0
  02062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutOpen@24

; 6365 : #endif
; 6366 : 	    
; 6367 : #ifdef USE_MME_SERVER
; 6368 : 	    
; 6369 : 	    /**************************************************************/
; 6370 : 	    /*  THIS IS PROBABLY NOT NECESSARY, BUT IT CANNOT HURT.       */
; 6371 : 	    /*  The MME servers waveOutOpen() function returns a value of */
; 6372 : 	    /*  WAVERR_DEVICESHAREABLE if the device is shareable. Change */
; 6373 : 	    /*  this to MMSYSERR_NOERROR.                                 */
; 6374 : 	    /**************************************************************/
; 6375 : 	    
; 6376 : 	    if (( pPlayAudio->dwDeviceOptions & WAVE_OPEN_SHAREABLE )
; 6377 : 		&& ( mmStatus == WAVERR_DEVICESHAREABLE ))
; 6378 : 	      {
; 6379 : 		mmStatus = MMSYSERR_NOERROR;
; 6380 : 	      }
; 6381 : 	  
; 6382 : #endif
; 6383 : 	  
; 6384 : 	  /**************************************************************/
; 6385 : 	  /*  Reset the WAVEFORMATEX structure elements for 16 bit      */
; 6386 : 	  /*  data.                                                     */
; 6387 : 	  /**************************************************************/
; 6388 : 	  
; 6389 : 	  pWaveFormat->nAvgBytesPerSec =
; 6390 : 	    dwSampleRate * dwNumberOfChannels << 1;

  02068	8d 0c 1b	 lea	 ecx, DWORD PTR [ebx+ebx]

; 6391 : 	  pWaveFormat->nBlockAlign = (WORD)( dwNumberOfChannels << 1 );

  0206b	8d 14 3f	 lea	 edx, DWORD PTR [edi+edi]
  0206e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  02071	66 89 56 0c	 mov	 WORD PTR [esi+12], dx

; 6392 : 	  pWaveFormat->wBitsPerSample = 16;

  02075	66 c7 46 0e 10
	00		 mov	 WORD PTR [esi+14], 16	; 00000010H
$L71045:

; 6393 : 	}
; 6394 :       
; 6395 :       /****************************************************************/
; 6396 :       /*  Test for a "query failure" error.                           */
; 6397 :       /****************************************************************/
; 6398 :       
; 6399 :       if ( mmStatus )

  0207b	85 c0		 test	 eax, eax

; 6400 : 	{
; 6401 : 	  return mmStatus;

  0207d	75 10		 jne	 SHORT $L71026

; 6402 : 	}
; 6403 :       
; 6404 :       /****************************************************************/
; 6405 :       /*  Set the new device format.                                  */
; 6406 :       /****************************************************************/
; 6407 :       
; 6408 :       mmStatus = SetNewFormat( pPlayAudio, pWaveFormat );

  0207f	56		 push	 esi
  02080	55		 push	 ebp
  02081	e8 00 00 00 00	 call	 _SetNewFormat
  02086	83 c4 08	 add	 esp, 8

; 6409 :       
; 6410 :       if ( mmStatus )

  02089	85 c0		 test	 eax, eax

; 6411 : 	{
; 6412 : 	  return mmStatus;

  0208b	75 02		 jne	 SHORT $L71026
$L71051:

; 6413 : 	}
; 6414 :     }
; 6415 :   }
; 6416 :   
; 6417 :   return MMSYSERR_NOERROR;

  0208d	33 c0		 xor	 eax, eax
$L71026:
  0208f	5f		 pop	 edi
  02090	5e		 pop	 esi
  02091	5d		 pop	 ebp
  02092	5b		 pop	 ebx

; 6418 : }

  02093	59		 pop	 ecx
  02094	c3		 ret	 0
_ProcessSetFormatMessage ENDP
_TEXT	ENDS
PUBLIC	__real@8@3ff8ccccccccccccd000
;	COMDAT __real@8@3ff8ccccccccccccd000
; File D:\work\product\dapi\src\NT\playaud.c
CONST	SEGMENT
__real@8@3ff8ccccccccccccd000 DQ 03f8999999999999ar ; 0.0125
CONST	ENDS
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pWaveFormat$ = 12
_pWaveFormatNew$ = 12
_SetNewFormat PROC NEAR

; 6458 : {

  020a0	83 ec 08	 sub	 esp, 8
  020a3	53		 push	 ebx

; 6459 :   unsigned int uiBlockAlign;
; 6460 :   unsigned int uiWriteLength;
; 6461 :   DWORD dwWaveFormatSize;
; 6462 :   LPWAVEFORMATEX pWaveFormatNew;
; 6463 :   LPWAVEFORMATEX pWaveFormatOld;
; 6464 : 
; 6465 :   /******************************************************************/
; 6466 :   /*  Get the size of the WAVEFORMATEX structure including the      */
; 6467 :   /*  possible data space indicated by the cbSize element.          */
; 6468 :   /******************************************************************/
; 6469 : 
; 6470 :   dwWaveFormatSize = GetWaveFormatSize( pWaveFormat );

  020a4	8b 5c 24 14	 mov	 ebx, DWORD PTR _pWaveFormat$[esp+8]
  020a8	56		 push	 esi
  020a9	53		 push	 ebx
  020aa	e8 00 00 00 00	 call	 _GetWaveFormatSize
  020af	83 c4 04	 add	 esp, 4

; 6471 : 
; 6472 :   // MGS change this back for osf so that we don't divide by 0 !
; 6473 : /* TQL 05/21/1997  change this for OSF build */
; 6474 :   //#ifdef WIN32
; 6475 :   if (pWaveFormat->wFormatTag == WAVE_FORMAT_PCM)

  020b2	66 83 3b 01	 cmp	 WORD PTR [ebx], 1
  020b6	8b f0		 mov	 esi, eax
  020b8	75 25		 jne	 SHORT $L71062

; 6476 :   {
; 6477 :     /******************************************************************/
; 6478 :     /*  Initialize other WAVEFORMATEX structure elements.             */
; 6479 :     /******************************************************************/
; 6480 : 
; 6481 :     pWaveFormat->nBlockAlign = pWaveFormat->nChannels * (pWaveFormat->wBitsPerSample >> 3);

  020ba	66 8b 43 0e	 mov	 ax, WORD PTR [ebx+14]

; 6482 :     pWaveFormat->nAvgBytesPerSec = pWaveFormat->nSamplesPerSec * pWaveFormat->nBlockAlign;

  020be	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  020c1	66 c1 e8 03	 shr	 ax, 3
  020c5	66 0f af 43 02	 imul	 ax, WORD PTR [ebx+2]
  020ca	66 89 43 0c	 mov	 WORD PTR [ebx+12], ax
  020ce	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  020d3	0f af c8	 imul	 ecx, eax
  020d6	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx

; 6483 :     pWaveFormat->cbSize = 0;

  020d9	66 c7 43 10 00
	00		 mov	 WORD PTR [ebx+16], 0
$L71062:

; 6484 :   }
; 6485 :   ///#endif
; 6486 : 
; 6487 :   /******************************************************************/
; 6488 :   /*  Allocate space for the new WAVEFORMATEX structure.            */
; 6489 :   /******************************************************************/
; 6490 : 
; 6491 :   LOCK_MME_CALL(
; 6492 :     pWaveFormatNew = ALLOCATE_SERVER_MEM( dwWaveFormatSize ))

  020df	56		 push	 esi
  020e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  020e6	83 c4 04	 add	 esp, 4
  020e9	89 44 24 18	 mov	 DWORD PTR _pWaveFormatNew$[esp+12], eax

; 6493 : 
; 6494 :   if ( pWaveFormatNew == NULL )

  020ed	85 c0		 test	 eax, eax
  020ef	75 0b		 jne	 SHORT $L71064
  020f1	5e		 pop	 esi

; 6495 :   {
; 6496 :     return MMSYSERR_NOMEM;

  020f2	b8 07 00 00 00	 mov	 eax, 7
  020f7	5b		 pop	 ebx

; 6610 : }

  020f8	83 c4 08	 add	 esp, 8
  020fb	c3		 ret	 0
$L71064:

; 6497 :   }
; 6498 : 
; 6499 :   /******************************************************************/
; 6500 :   /*  copy the WAVEFORMATEX structure.                              */
; 6501 :   /******************************************************************/
; 6502 : 
; 6503 :   memcpy( pWaveFormatNew,
; 6504 :           pWaveFormat,
; 6505 :           dwWaveFormatSize );

  020fc	8b ce		 mov	 ecx, esi
  020fe	55		 push	 ebp
  020ff	8b d1		 mov	 edx, ecx
  02101	57		 push	 edi
  02102	8b f3		 mov	 esi, ebx
  02104	8b f8		 mov	 edi, eax
  02106	c1 e9 02	 shr	 ecx, 2
  02109	f3 a5		 rep movsd

; 6506 : 
; 6507 :   /******************************************************************/
; 6508 :   /*  Save the old wave format structure so it can be freed.        */
; 6509 :   /******************************************************************/
; 6510 : 
; 6511 :   pWaveFormatOld = pPlayAudio->pWaveFormat;

  0210b	8b 6c 24 1c	 mov	 ebp, DWORD PTR _pPlayAudio$[esp+20]
  0210f	8b ca		 mov	 ecx, edx
  02111	83 e1 03	 and	 ecx, 3
  02114	f3 a4		 rep movsb

; 6512 : 
; 6513 :   /******************************************************************/
; 6514 :   /*  It is important that the assignment statement on the          */
; 6515 :   /*  following line executes automically so the timer thread does  */
; 6516 :   /*  not create an error.                                          */
; 6517 :   /******************************************************************/
; 6518 : 
; 6519 :   OP_LockMutex( pPlayAudio->hmxWaveFormat );

  02116	8b 85 8c 00 00
	00		 mov	 eax, DWORD PTR [ebp+140]
  0211c	8b b5 9c 00 00
	00		 mov	 esi, DWORD PTR [ebp+156]
  02122	50		 push	 eax
  02123	e8 00 00 00 00	 call	 _OP_LockMutex

; 6520 :   pPlayAudio->pWaveFormat = pWaveFormatNew;
; 6521 :   OP_UnlockMutex( pPlayAudio->hmxWaveFormat );

  02128	8b 8d 8c 00 00
	00		 mov	 ecx, DWORD PTR [ebp+140]
  0212e	8b 7c 24 24	 mov	 edi, DWORD PTR _pWaveFormatNew$[esp+24]
  02132	51		 push	 ecx
  02133	89 bd 9c 00 00
	00		 mov	 DWORD PTR [ebp+156], edi
  02139	e8 00 00 00 00	 call	 _OP_UnlockMutex
  0213e	83 c4 08	 add	 esp, 8

; 6522 : 
; 6523 :   if ( pWaveFormatOld != NULL )

  02141	85 f6		 test	 esi, esi
  02143	74 0a		 je	 SHORT $L71066

; 6524 :   {
; 6525 :     LOCK_MME_CALL( FREE_SERVER_MEM( pWaveFormatOld ))

  02145	56		 push	 esi
  02146	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0214c	83 c4 04	 add	 esp, 4
$L71066:

; 6526 :   }
; 6527 : 
; 6528 :   /********************************************************************/
; 6529 :   /*  Only write blocks that are a multiple of the block alignment.   */
; 6530 :   /********************************************************************/
; 6531 : 
; 6532 :   uiBlockAlign = pWaveFormatNew->nBlockAlign;

  0214f	33 f6		 xor	 esi, esi
  02151	66 8b 77 0c	 mov	 si, WORD PTR [edi+12]

; 6533 : 
; 6534 :   if ( uiBlockAlign == 0 )

  02155	85 f6		 test	 esi, esi
  02157	75 05		 jne	 SHORT $L71067

; 6535 :   {
; 6536 :     uiBlockAlign = 1;

  02159	be 01 00 00 00	 mov	 esi, 1
$L71067:

; 6537 :   }
; 6538 : 
; 6539 :   /********************************************************************/
; 6540 :   /*  Calculate the maximum write length written by the               */
; 6541 :   /*  WriteBufferToWaveDevice() function.                             */
; 6542 :   /********************************************************************/
; 6543 : 
; 6544 :   uiWriteLength = MAXIMUM_WRITE_LENGTH;
; 6545 :   uiWriteLength = uiWriteLength / uiBlockAlign;

  0215e	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H
  02163	33 d2		 xor	 edx, edx
  02165	f7 f6		 div	 esi

; 6546 :   pPlayAudio->uiMaximumWriteLength = uiWriteLength * uiBlockAlign;
; 6547 : 
; 6548 :   /********************************************************************/
; 6549 :   /*  Calculate the maximum startup length written to the             */
; 6550 :   /*  WriteBufferToWaveDevice() function.                             */
; 6551 :   /********************************************************************/
; 6552 : 
; 6553 :   uiWriteLength = (unsigned int)
; 6554 :     ( (STARTUP_BUFFER_SECONDS/MAXIMUM_BUFFERS_QUEUED) * (double)pWaveFormat->nAvgBytesPerSec );

  02167	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR -8+[esp+28], 0
  0216f	8b f8		 mov	 edi, eax
  02171	0f af fe	 imul	 edi, esi
  02174	89 7d 24	 mov	 DWORD PTR [ebp+36], edi
  02177	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  0217a	89 54 24 10	 mov	 DWORD PTR -8+[esp+24], edx
  0217e	df 6c 24 10	 fild	 QWORD PTR -8+[esp+24]
  02182	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@8@3ff8ccccccccccccd000
  02188	e8 00 00 00 00	 call	 __ftol

; 6555 : 
; 6556 :   if ( uiWriteLength < MINIMUM_STARTUP_WRITE_SIZE )

  0218d	3d 40 06 00 00	 cmp	 eax, 1600		; 00000640H
  02192	73 05		 jae	 SHORT $L71070

; 6557 :   {
; 6558 :     uiWriteLength = MINIMUM_STARTUP_WRITE_SIZE;

  02194	b8 40 06 00 00	 mov	 eax, 1600		; 00000640H
$L71070:

; 6559 :   }
; 6560 : 
; 6561 : #ifdef UNDER_CE
; 6562 :   // tek 23mar99 stretch the startup packet to try to avoid stutter.
; 6563 :   uiWriteLength = uiWriteLength*2;
; 6564 : #endif //UNDER_CE
; 6565 : 
; 6566 :   uiWriteLength = uiWriteLength / uiBlockAlign;

  02199	33 d2		 xor	 edx, edx
  0219b	f7 f6		 div	 esi

; 6567 :   uiWriteLength = uiWriteLength * uiBlockAlign;

  0219d	0f af c6	 imul	 eax, esi

; 6568 : 
; 6569 :   /********************************************************************/
; 6570 :   /*  Limit the maximum startup length written so that if             */
; 6571 :   /*  MAXIMUM_BUFFERS_QUEUED buffers are written, there is still      */
; 6572 :   /*  space for at least MAXIMUM_WRITE_LENGTH bytes left in the       */
; 6573 :   /*  audio queue.                                                    */
; 6574 :   /********************************************************************/
; 6575 : 
; 6576 :   if ( uiWriteLength > pPlayAudio->uiMaximumWriteLength )

  021a0	3b c7		 cmp	 eax, edi
  021a2	76 02		 jbe	 SHORT $L71071

; 6577 :   {
; 6578 :     uiWriteLength = pPlayAudio->uiMaximumWriteLength;

  021a4	8b c7		 mov	 eax, edi
$L71071:

; 6579 :   }
; 6580 : 
; 6581 :   pPlayAudio->uiStartupWriteLength = uiWriteLength;

  021a6	89 45 28	 mov	 DWORD PTR [ebp+40], eax
  021a9	5f		 pop	 edi

; 6582 : 
; 6583 : #ifdef TYPING_MODE
; 6584 :   // when we're doing fast starts, we have to make sure we write 
; 6585 :   // at least 65msec or so of audio on the first shot to keep 
; 6586 :   // the Win multimedia services from getting confused and stuttering.
; 6587 :   {
; 6588 : 	  UINT uiStutterMinWrite = (0.065) * (double)pWaveFormat->nAvgBytesPerSec;
; 6589 : 
; 6590 : 	  if (pPlayAudio->uiStartupWriteLength < uiStutterMinWrite)
; 6591 : 			   pPlayAudio->uiStartupWriteLength = uiStutterMinWrite;
; 6592 :   }
; 6593 : #endif //TYPING_MODE
; 6594 : 
; 6595 :   /********************************************************************/
; 6596 :   /*  Set the minimum startup bytes value.                            */
; 6597 :   /********************************************************************/
; 6598 :  
; 6599 : #if (defined TYPING_MODE) || (defined UNDER_CE) //mfg 21jul1999 ifdef UNDER_CE to avoid 1 sec startup delay 
; 6600 :   {
; 6601 : 	  pPlayAudio->uiMinimumStartupBytes =
; 6602 : 		2 * pPlayAudio->uiStartupWriteLength;
; 6603 :   }
; 6604 : #else
; 6605 :   pPlayAudio->uiMinimumStartupBytes =
; 6606 :     MAXIMUM_BUFFERS_QUEUED * pPlayAudio->uiStartupWriteLength;

  021aa	c1 e0 03	 shl	 eax, 3
  021ad	89 45 2c	 mov	 DWORD PTR [ebp+44], eax
  021b0	5d		 pop	 ebp
  021b1	5e		 pop	 esi

; 6607 : #endif //TYPING_MODE
; 6608 : 
; 6609 :   return MMSYSERR_NOERROR;

  021b2	33 c0		 xor	 eax, eax
  021b4	5b		 pop	 ebx

; 6610 : }

  021b5	83 c4 08	 add	 esp, 8
  021b8	c3		 ret	 0
_SetNewFormat ENDP
_pPlayAudio$ = 8
_pWaveFormat$ = 12
_ProcessGetFormatMessage PROC NEAR

; 6643 : {

  021c0	56		 push	 esi

; 6644 :   DWORD dwWaveFormatSize;
; 6645 : 
; 6646 :   /********************************************************************/
; 6647 :   /*  Get the size of the WAVEFORMATEX structure including the        */
; 6648 :   /*  possible data space indicated by the cbSize element.            */
; 6649 :   /********************************************************************/
; 6650 : 
; 6651 :   dwWaveFormatSize = GetWaveFormatSize( pPlayAudio->pWaveFormat );

  021c1	8b 74 24 08	 mov	 esi, DWORD PTR _pPlayAudio$[esp]
  021c5	57		 push	 edi
  021c6	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  021cc	50		 push	 eax
  021cd	e8 00 00 00 00	 call	 _GetWaveFormatSize

; 6652 : 
; 6653 :   /********************************************************************/
; 6654 :   /*  Copy to the new WAVEFORMATEX structure.                         */
; 6655 :   /********************************************************************/
; 6656 : 
; 6657 :   memcpy( pWaveFormat,
; 6658 :           pPlayAudio->pWaveFormat,
; 6659 :           dwWaveFormatSize );

  021d2	8b b6 9c 00 00
	00		 mov	 esi, DWORD PTR [esi+156]
  021d8	8b 7c 24 14	 mov	 edi, DWORD PTR _pWaveFormat$[esp+8]
  021dc	8b c8		 mov	 ecx, eax
  021de	83 c4 04	 add	 esp, 4
  021e1	8b d1		 mov	 edx, ecx

; 6660 : 
; 6661 :   return MMSYSERR_NOERROR;

  021e3	33 c0		 xor	 eax, eax
  021e5	c1 e9 02	 shr	 ecx, 2
  021e8	f3 a5		 rep movsd
  021ea	8b ca		 mov	 ecx, edx
  021ec	83 e1 03	 and	 ecx, 3
  021ef	f3 a4		 rep movsb
  021f1	5f		 pop	 edi
  021f2	5e		 pop	 esi

; 6662 : }

  021f3	c3		 ret	 0
_ProcessGetFormatMessage ENDP
_pPlayAudio$ = 8
_pdwVolume$ = 12
_ProcessGetVolumeMessage PROC NEAR

; 6694 :   MMRESULT mmStatus;
; 6695 : 
; 6696 :   /********************************************************************/
; 6697 :   /*  Get the wave output device volume.                              */
; 6698 :   /********************************************************************/
; 6699 : 
; 6700 :   LOCK_MME_CALL(
; 6701 :     mmStatus = waveOutGetVolume((HWAVEOUT)pPlayAudio->uiSelectedDeviceID,
; 6702 :                                 pdwVolume ))

  02200	8b 4c 24 04	 mov	 ecx, DWORD PTR _pPlayAudio$[esp-4]
  02204	8b 44 24 08	 mov	 eax, DWORD PTR _pdwVolume$[esp-4]
  02208	50		 push	 eax
  02209	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0220c	52		 push	 edx
  0220d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetVolume@8

; 6703 :   return mmStatus;
; 6704 : }

  02213	c3		 ret	 0
_ProcessGetVolumeMessage ENDP
_pPlayAudio$ = 8
_dwVolume$ = 12
_ProcessSetVolumeMessage PROC NEAR

; 6736 :   MMRESULT mmStatus;
; 6737 : 
; 6738 :   /********************************************************************/
; 6739 :   /*  If volume control is supported then set the volume.             */
; 6740 :   /********************************************************************/
; 6741 : 
; 6742 :   if ( pPlayAudio->dwDeviceSupport &
; 6743 :      ( WAVECAPS_LRVOLUME | WAVECAPS_VOLUME ))

  02220	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  02224	f6 40 48 0c	 test	 BYTE PTR [eax+72], 12	; 0000000cH
  02228	74 10		 je	 SHORT $L71091

; 6744 :   {
; 6745 :     LOCK_MME_CALL(
; 6746 :       mmStatus = waveOutSetVolume((HWAVEOUT)pPlayAudio->uiSelectedDeviceID,
; 6747 :                                   dwVolume ))

  0222a	8b 4c 24 08	 mov	 ecx, DWORD PTR _dwVolume$[esp-4]
  0222e	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  02231	51		 push	 ecx
  02232	52		 push	 edx
  02233	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutSetVolume@8

; 6752 :   }
; 6753 : 
; 6754 :   return mmStatus;
; 6755 : }

  02239	c3		 ret	 0
$L71091:

; 6748 :   }
; 6749 :   else
; 6750 :   {
; 6751 :     mmStatus = MMSYSERR_NOTSUPPORTED;

  0223a	b8 08 00 00 00	 mov	 eax, 8

; 6752 :   }
; 6753 : 
; 6754 :   return mmStatus;
; 6755 : }

  0223f	c3		 ret	 0
_ProcessSetVolumeMessage ENDP
_pPlayAudio$ = 8
_aTag$ = 12
_ProcessSynchronizationMarkMessage PROC NEAR

; 6791 : {

  02240	57		 push	 edi

; 6792 :   LPSYNC_MARK_T pSyncMark;
; 6793 :   LPSYNC_MARK_T pNextSyncMark;
; 6794 : 
; 6795 :   /********************************************************************/
; 6796 :   /*  Allocate memory for the synchronization mark structure.         */
; 6797 :   /********************************************************************/
; 6798 : 
; 6799 :   pSyncMark = (LPSYNC_MARK_T)malloc( sizeof(SYNC_MARK_T));

  02241	6a 0c		 push	 12			; 0000000cH
  02243	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  02249	8b f8		 mov	 edi, eax
  0224b	83 c4 04	 add	 esp, 4

; 6800 : 
; 6801 :   if ( pSyncMark == NULL )

  0224e	85 ff		 test	 edi, edi
  02250	75 07		 jne	 SHORT $L71104

; 6802 :   {
; 6803 :     return MMSYSERR_NOMEM;

  02252	b8 07 00 00 00	 mov	 eax, 7
  02257	5f		 pop	 edi

; 6857 : }

  02258	c3		 ret	 0
$L71104:
  02259	56		 push	 esi

; 6804 :   }
; 6805 : 
; 6806 :   /********************************************************************/
; 6807 :   /*  Fill in the synchonization mark structure.                      */
; 6808 :   /********************************************************************/
; 6809 : 
; 6810 :   OP_LockMutex( pPlayAudio->hmxQueuedByteCount );

  0225a	8b 74 24 0c	 mov	 esi, DWORD PTR _pPlayAudio$[esp+4]
  0225e	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  02264	50		 push	 eax
  02265	e8 00 00 00 00	 call	 _OP_LockMutex

; 6811 :   pSyncMark->dwPosition = pPlayAudio->dwQueuedByteCount;

  0226a	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  0226d	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 6812 :   OP_UnlockMutex( pPlayAudio->hmxQueuedByteCount );

  02270	8b 96 80 00 00
	00		 mov	 edx, DWORD PTR [esi+128]
  02276	52		 push	 edx
  02277	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 6813 : 
; 6814 :   pSyncMark->aTag = aTag;

  0227c	8b 44 24 18	 mov	 eax, DWORD PTR _aTag$[esp+12]

; 6815 :   pSyncMark->pLink = NULL;

  02280	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  02286	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 6816 : 
; 6817 :   /********************************************************************/
; 6818 :   /*  Lock the synchronization mark linked list.                      */
; 6819 :   /********************************************************************/
; 6820 : 
; 6821 :   OP_LockMutex( pPlayAudio->hmxSynchronizationMarkList );

  02289	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  0228f	51		 push	 ecx
  02290	e8 00 00 00 00	 call	 _OP_LockMutex

; 6822 : 
; 6823 :   /********************************************************************/
; 6824 :   /*  Put the synchronization mark at the end of the linked list.     */
; 6825 :   /********************************************************************/
; 6826 : 
; 6827 :   if ( pPlayAudio->pSyncMarkList == NULL )

  02295	8b 8e 98 00 00
	00		 mov	 ecx, DWORD PTR [esi+152]
  0229b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0229e	85 c9		 test	 ecx, ecx
  022a0	75 08		 jne	 SHORT $L71107

; 6828 :   {
; 6829 :     pPlayAudio->pSyncMarkList = pSyncMark;

  022a2	89 be 98 00 00
	00		 mov	 DWORD PTR [esi+152], edi

; 6830 :   }
; 6831 :   else

  022a8	eb 10		 jmp	 SHORT $L71108
$L71107:

; 6832 :   {
; 6833 :     pNextSyncMark = pPlayAudio->pSyncMarkList;
; 6834 : 
; 6835 :     while ( pNextSyncMark->pLink != NULL )

  022aa	8b 01		 mov	 eax, DWORD PTR [ecx]
  022ac	85 c0		 test	 eax, eax
  022ae	74 08		 je	 SHORT $L71112
$L71111:

; 6836 :     {
; 6837 :       pNextSyncMark = pNextSyncMark->pLink;

  022b0	8b c8		 mov	 ecx, eax
  022b2	8b 01		 mov	 eax, DWORD PTR [ecx]
  022b4	85 c0		 test	 eax, eax
  022b6	75 f8		 jne	 SHORT $L71111
$L71112:

; 6838 :     }
; 6839 : 
; 6840 :     pNextSyncMark->pLink = pSyncMark;

  022b8	89 39		 mov	 DWORD PTR [ecx], edi
$L71108:

; 6841 :   }
; 6842 : 
; 6843 :   /********************************************************************/
; 6844 :   /*  Set the timer thread active so it can process synchronization   */
; 6845 :   /*  marks.                                                          */
; 6846 :   /********************************************************************/
; 6847 : 
; 6848 :   OP_SetEvent( pPlayAudio->hevTimerThreadActive );

  022ba	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  022bd	52		 push	 edx
  022be	e8 00 00 00 00	 call	 _OP_SetEvent

; 6849 : 
; 6850 :   /********************************************************************/
; 6851 :   /*  Unlock the synchronization mark linked list.                    */
; 6852 :   /********************************************************************/
; 6853 : 
; 6854 :   OP_UnlockMutex( pPlayAudio->hmxSynchronizationMarkList );

  022c3	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  022c9	50		 push	 eax
  022ca	e8 00 00 00 00	 call	 _OP_UnlockMutex
  022cf	83 c4 08	 add	 esp, 8

; 6855 : 
; 6856 :   return MMSYSERR_NOERROR;

  022d2	33 c0		 xor	 eax, eax
  022d4	5e		 pop	 esi
  022d5	5f		 pop	 edi

; 6857 : }

  022d6	c3		 ret	 0
_ProcessSynchronizationMarkMessage ENDP
_pPlayAudio$ = 8
_pdwPosition$ = 12
_ProcessGetPositionMessage PROC NEAR

; 6890 : {

  022e0	57		 push	 edi

; 6891 :   MMRESULT mmStatus;
; 6892 : 
; 6893 :   if ( pPlayAudio->dwAudioDeviceState == AUDIO_DEVICE_ACTIVE )

  022e1	8b 7c 24 08	 mov	 edi, DWORD PTR _pPlayAudio$[esp]
  022e5	83 7f 34 02	 cmp	 DWORD PTR [edi+52], 2
  022e9	75 1b		 jne	 SHORT $L71119
  022eb	56		 push	 esi

; 6894 :   {
; 6895 :     mmStatus = AudioPosition( pPlayAudio, pdwPosition );

  022ec	8b 74 24 10	 mov	 esi, DWORD PTR _pdwPosition$[esp+4]
  022f0	56		 push	 esi
  022f1	57		 push	 edi
  022f2	e8 00 00 00 00	 call	 _AudioPosition

; 6896 : 
; 6897 :     *pdwPosition += pPlayAudio->dwPositionBase;

  022f7	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  022fa	8b 16		 mov	 edx, DWORD PTR [esi]
  022fc	83 c4 08	 add	 esp, 8
  022ff	03 d1		 add	 edx, ecx
  02301	89 16		 mov	 DWORD PTR [esi], edx
  02303	5e		 pop	 esi
  02304	5f		 pop	 edi

; 6904 :   }
; 6905 : 
; 6906 :   return mmStatus;
; 6907 : }

  02305	c3		 ret	 0
$L71119:

; 6898 :   }
; 6899 :   else
; 6900 :   {
; 6901 :     mmStatus = MMSYSERR_NOERROR;
; 6902 : 
; 6903 :     *pdwPosition = pPlayAudio->dwPositionBase;

  02306	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pdwPosition$[esp]
  0230a	8b 57 40	 mov	 edx, DWORD PTR [edi+64]
  0230d	33 c0		 xor	 eax, eax
  0230f	5f		 pop	 edi
  02310	89 11		 mov	 DWORD PTR [ecx], edx

; 6904 :   }
; 6905 : 
; 6906 :   return mmStatus;
; 6907 : }

  02312	c3		 ret	 0
_ProcessGetPositionMessage ENDP
_TEXT	ENDS
EXTRN	__imp__waveOutGetPosition@12:NEAR
_TEXT	SEGMENT
_pPlayAudio$ = 8
_pdwPosition$ = 12
_AudioPosition PROC NEAR

; 6945 : {

  02320	56		 push	 esi

; 6946 :   MMRESULT mmStatus;
; 6947 :   LPMMTIME pMmt;
; 6948 : 
; 6949 :   /********************************************************************/
; 6950 :   /*  Get the wave output device position.                            */
; 6951 :   /*  First allocate memory for the MMTIME structure.                 */
; 6952 :   /********************************************************************/
; 6953 : 
; 6954 :   LOCK_MME_CALL( pMmt = (LPMMTIME)ALLOCATE_SERVER_MEM(sizeof(MMTIME)))

  02321	6a 0c		 push	 12			; 0000000cH
  02323	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  02329	8b f0		 mov	 esi, eax
  0232b	83 c4 04	 add	 esp, 4

; 6955 : 
; 6956 :   if ( pMmt == NULL )

  0232e	85 f6		 test	 esi, esi
  02330	75 07		 jne	 SHORT $L71131

; 6957 :   {
; 6958 :     return MMSYSERR_NOMEM;

  02332	b8 07 00 00 00	 mov	 eax, 7
  02337	5e		 pop	 esi

; 7031 : }

  02338	c3		 ret	 0
$L71131:
  02339	53		 push	 ebx
  0233a	57		 push	 edi

; 6959 :   }
; 6960 : 
; 6961 :   /********************************************************************/
; 6962 :   /*  Get the position of the last sample played by the wave output   */
; 6963 :   /*  device.                                                         */
; 6964 :   /********************************************************************/
; 6965 : 
; 6966 :   pMmt->wType = TIME_BYTES;
; 6967 : 
; 6968 :   LOCK_MME_CALL( mmStatus = waveOutGetPosition( pPlayAudio->hWaveOut,
; 6969 :                                                 pMmt,
; 6970 :                                                 sizeof(MMTIME)))

  0233b	8b 7c 24 10	 mov	 edi, DWORD PTR _pPlayAudio$[esp+8]
  0233f	c7 06 04 00 00
	00		 mov	 DWORD PTR [esi], 4
  02345	6a 0c		 push	 12			; 0000000cH
  02347	56		 push	 esi
  02348	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0234b	50		 push	 eax
  0234c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutGetPosition@12
  02352	8b d8		 mov	 ebx, eax

; 6971 :   if ( mmStatus )

  02354	85 db		 test	 ebx, ebx
  02356	74 1a		 je	 SHORT $L71133

; 6972 :   {
; 6973 :     *pdwPosition = 0xFFFFFFFF;

  02358	8b 4c 24 14	 mov	 ecx, DWORD PTR _pdwPosition$[esp+8]

; 7018 :       mmStatus = MMSYSERR_ERROR;
; 7019 : 
; 7020 :       break;
; 7021 :     }
; 7022 :   }
; 7023 : 
; 7024 :   /********************************************************************/
; 7025 :   /*  Free memory for the MMTIME structure.                           */
; 7026 :   /********************************************************************/
; 7027 : 
; 7028 :   LOCK_MME_CALL( FREE_SERVER_MEM( pMmt ))

  0235c	56		 push	 esi
  0235d	c7 01 ff ff ff
	ff		 mov	 DWORD PTR [ecx], -1
  02363	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  02369	83 c4 04	 add	 esp, 4

; 7029 : 
; 7030 :   return mmStatus;

  0236c	8b c3		 mov	 eax, ebx
  0236e	5f		 pop	 edi
  0236f	5b		 pop	 ebx
  02370	5e		 pop	 esi

; 7031 : }

  02371	c3		 ret	 0
$L71133:

; 6974 :   }
; 6975 :   else
; 6976 :   {
; 6977 :     switch ( pMmt->wType )
; 6978 :     {

  02372	8b 06		 mov	 eax, DWORD PTR [esi]
  02374	48		 dec	 eax
  02375	74 7d		 je	 SHORT $L71139
  02377	48		 dec	 eax
  02378	74 48		 je	 SHORT $L71141
  0237a	83 e8 02	 sub	 eax, 2
  0237d	74 1f		 je	 SHORT $L71143

; 7011 :       }
; 7012 : 
; 7013 :       break;
; 7014 : 
; 7015 :     default:
; 7016 : 
; 7017 :       *pdwPosition = 0xFFFFFFFF;

  0237f	8b 54 24 14	 mov	 edx, DWORD PTR _pdwPosition$[esp+8]

; 7018 :       mmStatus = MMSYSERR_ERROR;
; 7019 : 
; 7020 :       break;
; 7021 :     }
; 7022 :   }
; 7023 : 
; 7024 :   /********************************************************************/
; 7025 :   /*  Free memory for the MMTIME structure.                           */
; 7026 :   /********************************************************************/
; 7027 : 
; 7028 :   LOCK_MME_CALL( FREE_SERVER_MEM( pMmt ))

  02383	56		 push	 esi
  02384	bb 01 00 00 00	 mov	 ebx, 1
  02389	c7 02 ff ff ff
	ff		 mov	 DWORD PTR [edx], -1
  0238f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  02395	83 c4 04	 add	 esp, 4

; 7029 : 
; 7030 :   return mmStatus;

  02398	8b c3		 mov	 eax, ebx
  0239a	5f		 pop	 edi
  0239b	5b		 pop	 ebx
  0239c	5e		 pop	 esi

; 7031 : }

  0239d	c3		 ret	 0
$L71143:

; 7000 :       }
; 7001 : 
; 7002 :       break;
; 7003 : 
; 7004 :     case TIME_BYTES:
; 7005 : 
; 7006 :       *pdwPosition = pMmt->u.cb;

  0239e	8b 4c 24 14	 mov	 ecx, DWORD PTR _pdwPosition$[esp+8]
  023a2	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  023a5	89 01		 mov	 DWORD PTR [ecx], eax

; 7007 : 
; 7008 :       if ( pPlayAudio->bConvertToEightBit )

  023a7	8b 57 50	 mov	 edx, DWORD PTR [edi+80]
  023aa	85 d2		 test	 edx, edx
  023ac	74 75		 je	 SHORT $L71140

; 7009 :       {
; 7010 :         *pdwPosition = *pdwPosition << 1;

  023ae	03 c0		 add	 eax, eax

; 7018 :       mmStatus = MMSYSERR_ERROR;
; 7019 : 
; 7020 :       break;
; 7021 :     }
; 7022 :   }
; 7023 : 
; 7024 :   /********************************************************************/
; 7025 :   /*  Free memory for the MMTIME structure.                           */
; 7026 :   /********************************************************************/
; 7027 : 
; 7028 :   LOCK_MME_CALL( FREE_SERVER_MEM( pMmt ))

  023b0	56		 push	 esi
  023b1	89 01		 mov	 DWORD PTR [ecx], eax
  023b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  023b9	83 c4 04	 add	 esp, 4

; 7029 : 
; 7030 :   return mmStatus;

  023bc	8b c3		 mov	 eax, ebx
  023be	5f		 pop	 edi
  023bf	5b		 pop	 ebx
  023c0	5e		 pop	 esi

; 7031 : }

  023c1	c3		 ret	 0
$L71141:

; 6988 :       }
; 6989 : 
; 6990 :       break;
; 6991 : 
; 6992 :     case TIME_SAMPLES:
; 6993 : 
; 6994 :       *pdwPosition = pMmt->u.sample
; 6995 :         * pPlayAudio->pWaveFormat->nBlockAlign;

  023c2	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  023c8	33 c0		 xor	 eax, eax
  023ca	66 8b 41 0c	 mov	 ax, WORD PTR [ecx+12]
  023ce	8b 4c 24 14	 mov	 ecx, DWORD PTR _pdwPosition$[esp+8]
  023d2	0f af 46 04	 imul	 eax, DWORD PTR [esi+4]
  023d6	89 01		 mov	 DWORD PTR [ecx], eax

; 6996 : 
; 6997 :       if ( pPlayAudio->bConvertToEightBit )

  023d8	8b 57 50	 mov	 edx, DWORD PTR [edi+80]
  023db	85 d2		 test	 edx, edx
  023dd	74 44		 je	 SHORT $L71140

; 6998 :       {
; 6999 :         *pdwPosition = *pdwPosition << 1;

  023df	8d 14 00	 lea	 edx, DWORD PTR [eax+eax]

; 7018 :       mmStatus = MMSYSERR_ERROR;
; 7019 : 
; 7020 :       break;
; 7021 :     }
; 7022 :   }
; 7023 : 
; 7024 :   /********************************************************************/
; 7025 :   /*  Free memory for the MMTIME structure.                           */
; 7026 :   /********************************************************************/
; 7027 : 
; 7028 :   LOCK_MME_CALL( FREE_SERVER_MEM( pMmt ))

  023e2	56		 push	 esi
  023e3	89 11		 mov	 DWORD PTR [ecx], edx
  023e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  023eb	83 c4 04	 add	 esp, 4

; 7029 : 
; 7030 :   return mmStatus;

  023ee	8b c3		 mov	 eax, ebx
  023f0	5f		 pop	 edi
  023f1	5b		 pop	 ebx
  023f2	5e		 pop	 esi

; 7031 : }

  023f3	c3		 ret	 0
$L71139:

; 6979 :     case TIME_MS:
; 6980 : 
; 6981 :       *pdwPosition =
; 6982 :         ( pMmt->u.ms * pPlayAudio->pWaveFormat->nSamplesPerSec
; 6983 :             * pPlayAudio->pWaveFormat->nBlockAlign ) / 1000;

  023f4	8b 87 9c 00 00
	00		 mov	 eax, DWORD PTR [edi+156]
  023fa	33 c9		 xor	 ecx, ecx
  023fc	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  02400	0f af 48 04	 imul	 ecx, DWORD PTR [eax+4]
  02404	0f af 4e 04	 imul	 ecx, DWORD PTR [esi+4]
  02408	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  0240d	f7 e1		 mul	 ecx
  0240f	8b 44 24 14	 mov	 eax, DWORD PTR _pdwPosition$[esp+8]
  02413	c1 ea 06	 shr	 edx, 6
  02416	89 10		 mov	 DWORD PTR [eax], edx

; 6984 : 
; 6985 :       if ( pPlayAudio->bConvertToEightBit )

  02418	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  0241b	85 c9		 test	 ecx, ecx
  0241d	74 04		 je	 SHORT $L71140

; 6986 :       {
; 6987 :         *pdwPosition = *pdwPosition << 1;

  0241f	03 d2		 add	 edx, edx
  02421	89 10		 mov	 DWORD PTR [eax], edx
$L71140:

; 7018 :       mmStatus = MMSYSERR_ERROR;
; 7019 : 
; 7020 :       break;
; 7021 :     }
; 7022 :   }
; 7023 : 
; 7024 :   /********************************************************************/
; 7025 :   /*  Free memory for the MMTIME structure.                           */
; 7026 :   /********************************************************************/
; 7027 : 
; 7028 :   LOCK_MME_CALL( FREE_SERVER_MEM( pMmt ))

  02423	56		 push	 esi
  02424	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0242a	83 c4 04	 add	 esp, 4

; 7029 : 
; 7030 :   return mmStatus;

  0242d	8b c3		 mov	 eax, ebx
  0242f	5f		 pop	 edi
  02430	5b		 pop	 ebx
  02431	5e		 pop	 esi

; 7031 : }

  02432	c3		 ret	 0
_AudioPosition ENDP
_pPlayAudio$ = 8
_aItem_0$ = 12
_aItem_1$ = 16
_ReportStatusToApplication PROC NEAR

; 7075 :   unsigned int uiRet;
; 7076 : 
; 7077 : #ifdef AUD_DEBUG
; 7078 :   OutputDebugString("PA: ReportStatusToApplication()\n");
; 7079 : #endif
; 7080 :   /********************************************************************/
; 7081 :   /*  If no callback routine is specified then discard the message.   */
; 7082 :   /********************************************************************/
; 7083 : 
; 7084 :   if ( 
; 7085 : 	  (pPlayAudio->CallbackRoutine != NULL )
; 7086 : #ifdef TYPING_MODE //13may97 tek don't return these in typing mode..!
; 7087 : 	  && ( !(((LPTTS_HANDLE_T)(pPlayAudio->aInstance))->bInTypingMode) )
; 7088 : #endif
; 7089 : 	 )

  02440	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  02444	8b 08		 mov	 ecx, DWORD PTR [eax]
  02446	85 c9		 test	 ecx, ecx
  02448	74 15		 je	 SHORT $L71155

; 7090 :   {
; 7091 :     uiRet = ( *pPlayAudio->CallbackRoutine )( pPlayAudio,
; 7092 :                                               pPlayAudio->aInstance,
; 7093 :                                               aItem_0,
; 7094 :                                               aItem_1 );

  0244a	8b 54 24 0c	 mov	 edx, DWORD PTR _aItem_1$[esp-4]
  0244e	52		 push	 edx
  0244f	8b 54 24 0c	 mov	 edx, DWORD PTR _aItem_0$[esp]
  02453	52		 push	 edx
  02454	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  02457	52		 push	 edx
  02458	50		 push	 eax
  02459	ff d1		 call	 ecx
  0245b	83 c4 10	 add	 esp, 16			; 00000010H

; 7099 :   }
; 7100 : 
; 7101 :   return uiRet;
; 7102 : }

  0245e	c3		 ret	 0
$L71155:

; 7095 :   }
; 7096 :   else
; 7097 :   {
; 7098 :     uiRet = 0;

  0245f	33 c0		 xor	 eax, eax

; 7099 :   }
; 7100 : 
; 7101 :   return uiRet;
; 7102 : }

  02461	c3		 ret	 0
_ReportStatusToApplication ENDP
_pPlayAudio$ = 8
_uiMessage$ = 12
_aParam$ = 16
_mDummy0$ = -4
_mDummy1$ = -8
_mReturn$ = -12
_SendPlayAudioMessage PROC NEAR

; 7140 :   ATYPE_T mDummy0;
; 7141 :   ATYPE_T mDummy1;
; 7142 :   ATYPE_T mReturn;
; 7143 : 
; 7144 :   /********************************************************************/
; 7145 :   /*  Put the message into the "play audio" message queue.            */
; 7146 :   /********************************************************************/
; 7147 : 
; 7148 :   OP_LockMutex( pShm_t->hmxGlobalSendPlayAudio );

  02470	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  02475	83 ec 0c	 sub	 esp, 12			; 0000000cH
  02478	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0247b	51		 push	 ecx
  0247c	e8 00 00 00 00	 call	 _OP_LockMutex

; 7149 : 
; 7150 :   WriteMessageQueue( pShm_t->pGlobalPlayAudioMessageQueue,
; 7151 :                      (ATYPE_T)pPlayAudio,
; 7152 :                      uiMessage,
; 7153 :                      aParam );

  02481	8b 54 24 1c	 mov	 edx, DWORD PTR _aParam$[esp+12]
  02485	8b 44 24 18	 mov	 eax, DWORD PTR _uiMessage$[esp+12]
  02489	8b 4c 24 14	 mov	 ecx, DWORD PTR _pPlayAudio$[esp+12]
  0248d	52		 push	 edx
  0248e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  02494	50		 push	 eax
  02495	51		 push	 ecx
  02496	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  02499	50		 push	 eax
  0249a	e8 00 00 00 00	 call	 _WriteMessageQueue

; 7154 : 
; 7155 :   /********************************************************************/
; 7156 :   /*  Get the result from the report message queue.                   */
; 7157 :   /********************************************************************/
; 7158 : 
; 7159 :   ReadMessageQueue( pShm_t->pGlobalReportMessageQueue,
; 7160 :                     &mDummy0,
; 7161 :                     &mDummy1,
; 7162 :                     &mReturn );

  0249f	8d 4c 24 14	 lea	 ecx, DWORD PTR _mReturn$[esp+32]
  024a3	8d 54 24 18	 lea	 edx, DWORD PTR _mDummy1$[esp+32]
  024a7	51		 push	 ecx
  024a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pShm_t
  024ae	52		 push	 edx
  024af	8d 44 24 24	 lea	 eax, DWORD PTR _mDummy0$[esp+40]
  024b3	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  024b6	50		 push	 eax
  024b7	52		 push	 edx
  024b8	e8 00 00 00 00	 call	 _ReadMessageQueue

; 7163 :   OP_UnlockMutex( pShm_t->hmxGlobalSendPlayAudio );

  024bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _pShm_t
  024c2	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  024c5	51		 push	 ecx
  024c6	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 7164 :   return (SENDRET_T)mReturn;

  024cb	8b 44 24 28	 mov	 eax, DWORD PTR _mReturn$[esp+52]

; 7165 : }

  024cf	83 c4 34	 add	 esp, 52			; 00000034H
  024d2	c3		 ret	 0
_SendPlayAudioMessage ENDP
_uiQueueLength$ = 8
_CreateMessageQueue PROC NEAR

; 7195 : {

  024e0	53		 push	 ebx
  024e1	55		 push	 ebp

; 7196 :   unsigned int uiBufferLength;
; 7197 :   LPMESSAGE_QUEUE_T pMessageQueue;
; 7198 : 
; 7199 :   /********************************************************************/
; 7200 :   /*  Allocate the message queue structure.                           */
; 7201 :   /********************************************************************/
; 7202 : 
; 7203 :   pMessageQueue = (LPMESSAGE_QUEUE_T)malloc( sizeof( MESSAGE_QUEUE_T ));

  024e2	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__malloc
  024e8	56		 push	 esi
  024e9	57		 push	 edi
  024ea	6a 28		 push	 40			; 00000028H
  024ec	ff d5		 call	 ebp
  024ee	8b f0		 mov	 esi, eax

; 7204 : 
; 7205 :   if ( pMessageQueue == NULL )

  024f0	33 ff		 xor	 edi, edi
  024f2	83 c4 04	 add	 esp, 4
  024f5	3b f7		 cmp	 esi, edi
  024f7	75 07		 jne	 SHORT $L71177
  024f9	5f		 pop	 edi
  024fa	5e		 pop	 esi
  024fb	5d		 pop	 ebp

; 7206 :   {
; 7207 :     return NULL;

  024fc	33 c0		 xor	 eax, eax
  024fe	5b		 pop	 ebx

; 7284 : }

  024ff	c3		 ret	 0
$L71177:

; 7208 :   }
; 7209 : 
; 7210 :   /********************************************************************/
; 7211 :   /*  Initialize message queue structure elements.                    */
; 7212 :   /********************************************************************/
; 7213 : 
; 7214 :   pMessageQueue->pStart = NULL;
; 7215 :   pMessageQueue->hevNotFull = NULL;
; 7216 :   pMessageQueue->hevNotEmpty = NULL;
; 7217 :   pMessageQueue->hmxMessageQueue = NULL;
; 7218 : 
; 7219 :   /********************************************************************/
; 7220 :   /*  Allocate the message queue buffer in multiples of 3 ATYPE_T     */
; 7221 :   /*  items.                                                          */
; 7222 :   /********************************************************************/
; 7223 : 
; 7224 :   uiBufferLength = NUMBER_OF_ITEMS_IN_MESSAGE * uiQueueLength;

  02500	8b 44 24 14	 mov	 eax, DWORD PTR _uiQueueLength$[esp+12]
  02504	89 3e		 mov	 DWORD PTR [esi], edi
  02506	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  02509	89 7e 20	 mov	 DWORD PTR [esi+32], edi
  0250c	8d 1c 40	 lea	 ebx, DWORD PTR [eax+eax*2]
  0250f	89 7e 24	 mov	 DWORD PTR [esi+36], edi

; 7225 : 
; 7226 :   pMessageQueue->pStart =
; 7227 :     (LPATYPE_T)malloc( uiBufferLength * sizeof(ATYPE_T));

  02512	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  02519	50		 push	 eax
  0251a	ff d5		 call	 ebp
  0251c	83 c4 04	 add	 esp, 4

; 7228 : 
; 7229 :   if ( pMessageQueue->pStart == NULL )

  0251f	3b c7		 cmp	 eax, edi
  02521	89 06		 mov	 DWORD PTR [esi], eax
  02523	75 10		 jne	 SHORT $L71186

; 7230 :   {
; 7231 :     DestroyMessageQueue( pMessageQueue );

  02525	56		 push	 esi
  02526	e8 00 00 00 00	 call	 _DestroyMessageQueue
  0252b	83 c4 04	 add	 esp, 4

; 7232 :     return NULL;

  0252e	33 c0		 xor	 eax, eax
  02530	5f		 pop	 edi
  02531	5e		 pop	 esi
  02532	5d		 pop	 ebp
  02533	5b		 pop	 ebx

; 7284 : }

  02534	c3		 ret	 0
$L71186:

; 7233 :   }
; 7234 : 
; 7235 :   /********************************************************************/
; 7236 :   /*  Allocate the message queue mutex object.                        */
; 7237 :   /********************************************************************/
; 7238 : 
; 7239 :   pMessageQueue->hmxMessageQueue = OP_CreateMutex();

  02535	e8 00 00 00 00	 call	 _OP_CreateMutex

; 7240 : 
; 7241 :   if ( pMessageQueue->hmxMessageQueue == NULL )

  0253a	3b c7		 cmp	 eax, edi
  0253c	89 46 24	 mov	 DWORD PTR [esi+36], eax
  0253f	75 10		 jne	 SHORT $L71189

; 7242 :   {
; 7243 :     DestroyMessageQueue( pMessageQueue );

  02541	56		 push	 esi
  02542	e8 00 00 00 00	 call	 _DestroyMessageQueue
  02547	83 c4 04	 add	 esp, 4

; 7244 :     return NULL;

  0254a	33 c0		 xor	 eax, eax
  0254c	5f		 pop	 edi
  0254d	5e		 pop	 esi
  0254e	5d		 pop	 ebp
  0254f	5b		 pop	 ebx

; 7284 : }

  02550	c3		 ret	 0
$L71189:

; 7245 :   }
; 7246 : 
; 7247 :   /********************************************************************/
; 7248 :   /*  Initialize the message queue structure.                         */
; 7249 :   /********************************************************************/
; 7250 : 
; 7251 :   pMessageQueue->pInput = pMessageQueue->pStart;

  02551	8b 06		 mov	 eax, DWORD PTR [esi]

; 7252 :   pMessageQueue->pOutput = pMessageQueue->pStart;
; 7253 :   pMessageQueue->uiInputPosition = 0;
; 7254 :   pMessageQueue->uiOutputPosition = 0;
; 7255 :   pMessageQueue->uiLength = uiBufferLength;
; 7256 :   pMessageQueue->uiCount = 0;
; 7257 : 
; 7258 :   /********************************************************************/
; 7259 :   /*  Create the "Not Empty" Event. The initial state is not          */
; 7260 :   /*  signalled.                                                      */
; 7261 :   /********************************************************************/
; 7262 : 
; 7263 :   pMessageQueue->hevNotEmpty = OP_CreateEvent( TRUE, FALSE );

  02553	57		 push	 edi
  02554	6a 01		 push	 1
  02556	89 46 04	 mov	 DWORD PTR [esi+4], eax
  02559	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0255c	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0255f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  02562	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  02565	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  02568	e8 00 00 00 00	 call	 _OP_CreateEvent
  0256d	83 c4 08	 add	 esp, 8

; 7264 : 
; 7265 :   if ( pMessageQueue->hevNotEmpty == NULL )

  02570	3b c7		 cmp	 eax, edi
  02572	89 46 20	 mov	 DWORD PTR [esi+32], eax
  02575	75 10		 jne	 SHORT $L71192

; 7266 :   {
; 7267 :     DestroyMessageQueue( pMessageQueue );

  02577	56		 push	 esi
  02578	e8 00 00 00 00	 call	 _DestroyMessageQueue
  0257d	83 c4 04	 add	 esp, 4

; 7268 :     return NULL;

  02580	33 c0		 xor	 eax, eax
  02582	5f		 pop	 edi
  02583	5e		 pop	 esi
  02584	5d		 pop	 ebp
  02585	5b		 pop	 ebx

; 7284 : }

  02586	c3		 ret	 0
$L71192:

; 7269 :   }
; 7270 : 
; 7271 :   /********************************************************************/
; 7272 :   /*  Create the "Not Full" Event. The initial state is signalled.    */
; 7273 :   /********************************************************************/
; 7274 : 
; 7275 :   pMessageQueue->hevNotFull = OP_CreateEvent( TRUE, TRUE );

  02587	6a 01		 push	 1
  02589	6a 01		 push	 1
  0258b	e8 00 00 00 00	 call	 _OP_CreateEvent
  02590	83 c4 08	 add	 esp, 8

; 7276 : 
; 7277 :   if ( pMessageQueue->hevNotFull == NULL )

  02593	3b c7		 cmp	 eax, edi
  02595	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  02598	75 10		 jne	 SHORT $L71195

; 7278 :   {
; 7279 :     DestroyMessageQueue( pMessageQueue );

  0259a	56		 push	 esi
  0259b	e8 00 00 00 00	 call	 _DestroyMessageQueue
  025a0	83 c4 04	 add	 esp, 4

; 7280 :     return NULL;

  025a3	33 c0		 xor	 eax, eax
  025a5	5f		 pop	 edi
  025a6	5e		 pop	 esi
  025a7	5d		 pop	 ebp
  025a8	5b		 pop	 ebx

; 7284 : }

  025a9	c3		 ret	 0
$L71195:

; 7281 :   }
; 7282 : 
; 7283 :   return pMessageQueue;

  025aa	8b c6		 mov	 eax, esi
  025ac	5f		 pop	 edi
  025ad	5e		 pop	 esi
  025ae	5d		 pop	 ebp
  025af	5b		 pop	 ebx

; 7284 : }

  025b0	c3		 ret	 0
_CreateMessageQueue ENDP
_pMessageQueue$ = 8
_DestroyMessageQueue PROC NEAR

; 7311 : {

  025c0	56		 push	 esi

; 7312 :   if ( pMessageQueue != NULL )

  025c1	8b 74 24 08	 mov	 esi, DWORD PTR _pMessageQueue$[esp]
  025c5	85 f6		 test	 esi, esi
  025c7	74 38		 je	 SHORT $L71201

; 7313 :   {
; 7314 :     /******************************************************************/
; 7315 :     /*  Delete the mutex object.                                      */
; 7316 :     /******************************************************************/
; 7317 : 
; 7318 :     OP_DestroyMutex( pMessageQueue->hmxMessageQueue );

  025c9	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  025cc	57		 push	 edi
  025cd	50		 push	 eax
  025ce	e8 00 00 00 00	 call	 _OP_DestroyMutex

; 7319 : 
; 7320 :     /******************************************************************/
; 7321 :     /*  Free the message queue events.                                */
; 7322 :     /******************************************************************/
; 7323 : 
; 7324 :     OP_DestroyEvent( pMessageQueue->hevNotEmpty );

  025d3	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  025d6	51		 push	 ecx
  025d7	e8 00 00 00 00	 call	 _OP_DestroyEvent

; 7325 : 
; 7326 :     OP_DestroyEvent( pMessageQueue->hevNotFull );

  025dc	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  025df	52		 push	 edx
  025e0	e8 00 00 00 00	 call	 _OP_DestroyEvent

; 7327 : 
; 7328 :     /******************************************************************/
; 7329 :     /*  Deallocate the message queue buffer and the message queue     */
; 7330 :     /*  structure.                                                    */
; 7331 :     /******************************************************************/
; 7332 : 
; 7333 :     if ( pMessageQueue->pStart != NULL )

  025e5	8b 06		 mov	 eax, DWORD PTR [esi]
  025e7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
  025ed	83 c4 0c	 add	 esp, 12			; 0000000cH
  025f0	85 c0		 test	 eax, eax
  025f2	74 06		 je	 SHORT $L71203

; 7334 :     {
; 7335 :       free( pMessageQueue->pStart );

  025f4	50		 push	 eax
  025f5	ff d7		 call	 edi
  025f7	83 c4 04	 add	 esp, 4
$L71203:

; 7336 :     }
; 7337 : 
; 7338 :     free( pMessageQueue );

  025fa	56		 push	 esi
  025fb	ff d7		 call	 edi
  025fd	83 c4 04	 add	 esp, 4
  02600	5f		 pop	 edi
$L71201:
  02601	5e		 pop	 esi

; 7339 :   }
; 7340 : 
; 7341 :   return;
; 7342 : }

  02602	c3		 ret	 0
_DestroyMessageQueue ENDP
_pMessageQueue$ = 8
_aItem_0$ = 12
_aItem_1$ = 16
_aItem_2$ = 20
_aArray$ = -12
_WriteMessageQueue PROC NEAR

; 7383 : {

  02610	83 ec 0c	 sub	 esp, 12			; 0000000cH
  02613	53		 push	 ebx
  02614	55		 push	 ebp
  02615	56		 push	 esi

; 7384 :   unsigned int uiI;
; 7385 :   unsigned int uiRemaining;
; 7386 :   unsigned int uiNumberToWrite;
; 7387 :   ATYPE_T aArray[NUMBER_OF_ITEMS_IN_MESSAGE];
; 7388 :   LPATYPE_T pItems;
; 7389 : 
; 7390 :   /********************************************************************/
; 7391 :   /*  Block if the message queue is busy.                             */
; 7392 :   /********************************************************************/
; 7393 : 
; 7394 :   OP_LockMutex( pMessageQueue->hmxMessageQueue );

  02616	8b 74 24 1c	 mov	 esi, DWORD PTR _pMessageQueue$[esp+20]
  0261a	57		 push	 edi
  0261b	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0261e	50		 push	 eax
  0261f	e8 00 00 00 00	 call	 _OP_LockMutex

; 7395 : 
; 7396 :   aArray[0] = aItem_0;

  02624	8b 4c 24 28	 mov	 ecx, DWORD PTR _aItem_0$[esp+28]

; 7397 :   aArray[1] = aItem_1;
; 7398 :   aArray[2] = aItem_2;

  02628	8b 44 24 30	 mov	 eax, DWORD PTR _aItem_2$[esp+28]
  0262c	8b 54 24 2c	 mov	 edx, DWORD PTR _aItem_1$[esp+28]
  02630	89 4c 24 14	 mov	 DWORD PTR _aArray$[esp+32], ecx

; 7399 :   pItems = &aArray[0];
; 7400 : 
; 7401 :   /********************************************************************/
; 7402 :   /*  If there's not enough room for the items then block.            */
; 7403 :   /*  WriteMessageQueue must own pMessageQueue->uiCount               */
; 7404 :   /*  during the compare in case multiple threads are trying to write */
; 7405 :   /*  the queue at the same time.                                     */
; 7406 :   /********************************************************************/
; 7407 : 
; 7408 :   uiNumberToWrite = NUMBER_OF_ITEMS_IN_MESSAGE;
; 7409 :   
; 7410 :   while ( pMessageQueue->uiCount + uiNumberToWrite > pMessageQueue->uiLength )

  02634	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  02637	89 44 24 1c	 mov	 DWORD PTR _aArray$[esp+40], eax
  0263b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0263e	83 c1 03	 add	 ecx, 3
  02641	83 c4 04	 add	 esp, 4
  02644	3b c8		 cmp	 ecx, eax
  02646	89 54 24 14	 mov	 DWORD PTR _aArray$[esp+32], edx
  0264a	8d 7c 24 10	 lea	 edi, DWORD PTR _aArray$[esp+28]
  0264e	76 36		 jbe	 SHORT $L71220
$L71219:

; 7411 :   {
; 7412 :   
; 7413 :     OP_ResetEvent( pMessageQueue->hevNotFull );

  02650	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  02653	52		 push	 edx
  02654	e8 00 00 00 00	 call	 _OP_ResetEvent

; 7414 : 
; 7415 :     OP_UnlockMutex( pMessageQueue->hmxMessageQueue );

  02659	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0265c	50		 push	 eax
  0265d	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 7416 :   
; 7417 :     OP_WaitForEvent( pMessageQueue->hevNotFull, OP_INFINITE );

  02662	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  02665	6a ff		 push	 -1
  02667	51		 push	 ecx
  02668	e8 00 00 00 00	 call	 _OP_WaitForEvent

; 7418 :   
; 7419 :     OP_LockMutex( pMessageQueue->hmxMessageQueue );

  0266d	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  02670	52		 push	 edx
  02671	e8 00 00 00 00	 call	 _OP_LockMutex
  02676	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  02679	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0267c	83 c0 03	 add	 eax, 3
  0267f	83 c4 14	 add	 esp, 20			; 00000014H
  02682	3b c1		 cmp	 eax, ecx
  02684	77 ca		 ja	 SHORT $L71219
$L71220:

; 7420 :   }
; 7421 : 
; 7422 :   /********************************************************************/
; 7423 :   /*  There is enough space in the message queue.                     */
; 7424 :   /*  Test to see if the data will wrap around the circular queue.    */
; 7425 :   /********************************************************************/
; 7426 : 
; 7427 :   if (( pMessageQueue->uiInputPosition + uiNumberToWrite )
; 7428 :          > pMessageQueue->uiLength )

  02686	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  02689	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0268c	8d 51 03	 lea	 edx, DWORD PTR [ecx+3]
  0268f	3b d0		 cmp	 edx, eax
  02691	76 50		 jbe	 SHORT $L71221

; 7429 :   {
; 7430 :     /******************************************************************/
; 7431 :     /*  The data will wrap around the circular queue.                 */
; 7432 :     /******************************************************************/
; 7433 : 
; 7434 :     uiRemaining = pMessageQueue->uiLength - pMessageQueue->uiInputPosition;

  02693	2b c1		 sub	 eax, ecx

; 7435 : 
; 7436 :     for ( uiI = 0; uiI < uiRemaining; uiI++ )

  02695	ba 04 00 00 00	 mov	 edx, 4
  0269a	74 16		 je	 SHORT $L71224

; 7429 :   {
; 7430 :     /******************************************************************/
; 7431 :     /*  The data will wrap around the circular queue.                 */
; 7432 :     /******************************************************************/
; 7433 : 
; 7434 :     uiRemaining = pMessageQueue->uiLength - pMessageQueue->uiInputPosition;

  0269c	8b c8		 mov	 ecx, eax
$L71222:

; 7437 :      *pMessageQueue->pInput++ = *pItems++;

  0269e	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  026a1	8b 2f		 mov	 ebp, DWORD PTR [edi]
  026a3	03 fa		 add	 edi, edx
  026a5	89 2b		 mov	 DWORD PTR [ebx], ebp
  026a7	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  026aa	03 da		 add	 ebx, edx
  026ac	49		 dec	 ecx
  026ad	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  026b0	75 ec		 jne	 SHORT $L71222
$L71224:

; 7438 : 
; 7439 :     pMessageQueue->pInput = pMessageQueue->pStart;

  026b2	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 7440 : 
; 7441 :     for ( uiI = uiRemaining; uiI < uiNumberToWrite; uiI++ )

  026b4	83 f8 03	 cmp	 eax, 3
  026b7	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  026ba	73 1b		 jae	 SHORT $L71227
  026bc	b9 03 00 00 00	 mov	 ecx, 3
  026c1	2b c8		 sub	 ecx, eax
$L71225:

; 7442 :      *pMessageQueue->pInput++ = *pItems++;

  026c3	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  026c6	8b 2f		 mov	 ebp, DWORD PTR [edi]
  026c8	03 fa		 add	 edi, edx
  026ca	89 2b		 mov	 DWORD PTR [ebx], ebp
  026cc	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  026cf	03 da		 add	 ebx, edx
  026d1	49		 dec	 ecx
  026d2	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  026d5	75 ec		 jne	 SHORT $L71225
$L71227:

; 7443 : 
; 7444 :     /******************************************************************/
; 7445 :     /*  Update the input position in a circular fashion.              */
; 7446 :     /******************************************************************/
; 7447 : 
; 7448 :     pMessageQueue->uiInputPosition = uiNumberToWrite - uiRemaining;

  026d7	ba 03 00 00 00	 mov	 edx, 3
  026dc	2b d0		 sub	 edx, eax
  026de	89 56 0c	 mov	 DWORD PTR [esi+12], edx

; 7449 :   }
; 7450 :   else

  026e1	eb 22		 jmp	 SHORT $L71228
$L71221:

; 7451 :   {
; 7452 :     /******************************************************************/
; 7453 :     /*  The data will NOT wrap around the circular queue.             */
; 7454 :     /******************************************************************/
; 7455 : 
; 7456 :     for ( uiI = 0; uiI < uiNumberToWrite; uiI++ )

  026e3	b8 03 00 00 00	 mov	 eax, 3
  026e8	ba 04 00 00 00	 mov	 edx, 4
$L71229:

; 7457 :      *pMessageQueue->pInput++ = *pItems++;

  026ed	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  026f0	8b 1f		 mov	 ebx, DWORD PTR [edi]
  026f2	03 fa		 add	 edi, edx
  026f4	89 19		 mov	 DWORD PTR [ecx], ebx
  026f6	8b 6e 04	 mov	 ebp, DWORD PTR [esi+4]
  026f9	03 ea		 add	 ebp, edx
  026fb	48		 dec	 eax
  026fc	89 6e 04	 mov	 DWORD PTR [esi+4], ebp
  026ff	75 ec		 jne	 SHORT $L71229

; 7458 : 
; 7459 :     /******************************************************************/
; 7460 :     /*  Update the input position.                                    */
; 7461 :     /******************************************************************/
; 7462 : 
; 7463 :     pMessageQueue->uiInputPosition += uiNumberToWrite;

  02701	83 46 0c 03	 add	 DWORD PTR [esi+12], 3
$L71228:

; 7464 :   }
; 7465 : 
; 7466 :   /********************************************************************/
; 7467 :   /*  Update the count of items in the message queue.                 */
; 7468 :   /********************************************************************/
; 7469 : 
; 7470 :   pMessageQueue->uiCount += uiNumberToWrite;

  02705	8b 5e 18	 mov	 ebx, DWORD PTR [esi+24]

; 7471 : 
; 7472 :   /********************************************************************/
; 7473 :   /*  Set the "Not Empty" condition.                                  */
; 7474 :   /********************************************************************/
; 7475 : 
; 7476 :   OP_SetEvent( pMessageQueue->hevNotEmpty );

  02708	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  0270b	83 c3 03	 add	 ebx, 3
  0270e	52		 push	 edx
  0270f	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  02712	e8 00 00 00 00	 call	 _OP_SetEvent

; 7477 : 
; 7478 :   /********************************************************************/
; 7479 :   /*  Free the message queue.                                         */
; 7480 :   /********************************************************************/
; 7481 : 
; 7482 :   OP_UnlockMutex( pMessageQueue->hmxMessageQueue );

  02717	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0271a	50		 push	 eax
  0271b	e8 00 00 00 00	 call	 _OP_UnlockMutex
  02720	83 c4 08	 add	 esp, 8
  02723	5f		 pop	 edi
  02724	5e		 pop	 esi
  02725	5d		 pop	 ebp
  02726	5b		 pop	 ebx

; 7483 : 
; 7484 :   return;
; 7485 : }

  02727	83 c4 0c	 add	 esp, 12			; 0000000cH
  0272a	c3		 ret	 0
_WriteMessageQueue ENDP
_pMessageQueue$ = 8
_paItem_0$ = 12
_paItem_1$ = 16
_paItem_2$ = 20
_aArray$ = -12
_ReadMessageQueue PROC NEAR

; 7524 : {

  02730	83 ec 0c	 sub	 esp, 12			; 0000000cH
  02733	53		 push	 ebx
  02734	56		 push	 esi

; 7525 :   unsigned int uiI;
; 7526 :   unsigned int uiRemaining;
; 7527 :   unsigned int uiNumberToRead;
; 7528 :   ATYPE_T aArray[NUMBER_OF_ITEMS_IN_MESSAGE];
; 7529 :   LPATYPE_T pItems;
; 7530 : 
; 7531 :   /********************************************************************/
; 7532 :   /*  Block if the message queue is busy.                             */
; 7533 :   /********************************************************************/
; 7534 : 
; 7535 :   OP_LockMutex( pMessageQueue->hmxMessageQueue );

  02735	8b 74 24 18	 mov	 esi, DWORD PTR _pMessageQueue$[esp+16]
  02739	57		 push	 edi
  0273a	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0273d	50		 push	 eax
  0273e	e8 00 00 00 00	 call	 _OP_LockMutex

; 7536 : 
; 7537 :   pItems = &aArray[0];
; 7538 : 
; 7539 :   /********************************************************************/
; 7540 :   /*  If there is no message in the message queue then block.         */
; 7541 :   /*  The ReadMessageQueue() function must own pMessageQueue->uiCount */
; 7542 :   /*  during the compare in case multiple threads are trying to read  */
; 7543 :   /*  the message queue at the same time.                             */
; 7544 :   /********************************************************************/
; 7545 : 
; 7546 :   uiNumberToRead = NUMBER_OF_ITEMS_IN_MESSAGE;
; 7547 : 
; 7548 :   while ( pMessageQueue->uiCount < uiNumberToRead )

  02743	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  02746	bb 03 00 00 00	 mov	 ebx, 3
  0274b	83 c4 04	 add	 esp, 4
  0274e	3b c3		 cmp	 eax, ebx
  02750	8d 7c 24 0c	 lea	 edi, DWORD PTR _aArray$[esp+24]
  02754	73 30		 jae	 SHORT $L71248
$L71247:

; 7549 :   {
; 7550 : 
; 7551 :     OP_ResetEvent( pMessageQueue->hevNotEmpty );

  02756	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  02759	51		 push	 ecx
  0275a	e8 00 00 00 00	 call	 _OP_ResetEvent

; 7552 : 
; 7553 :     OP_UnlockMutex( pMessageQueue->hmxMessageQueue );

  0275f	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  02762	52		 push	 edx
  02763	e8 00 00 00 00	 call	 _OP_UnlockMutex

; 7554 : 
; 7555 :     OP_WaitForEvent( pMessageQueue->hevNotEmpty, OP_INFINITE );

  02768	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0276b	6a ff		 push	 -1
  0276d	50		 push	 eax
  0276e	e8 00 00 00 00	 call	 _OP_WaitForEvent

; 7556 : 
; 7557 :     OP_LockMutex( pMessageQueue->hmxMessageQueue );

  02773	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  02776	51		 push	 ecx
  02777	e8 00 00 00 00	 call	 _OP_LockMutex
  0277c	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0277f	83 c4 14	 add	 esp, 20			; 00000014H
  02782	3b c3		 cmp	 eax, ebx
  02784	72 d0		 jb	 SHORT $L71247
$L71248:

; 7558 :   }
; 7559 : 
; 7560 :   /********************************************************************/
; 7561 :   /*  There is a message in the queue.                                */
; 7562 :   /*  Test to see if the read of the data wraps around the queue.     */
; 7563 :   /********************************************************************/
; 7564 : 
; 7565 :   if (( pMessageQueue->uiOutputPosition + uiNumberToRead )
; 7566 :           > pMessageQueue->uiLength )

  02786	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  02789	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0278c	8d 51 03	 lea	 edx, DWORD PTR [ecx+3]
  0278f	3b d0		 cmp	 edx, eax
  02791	76 46		 jbe	 SHORT $L71249

; 7567 :   {
; 7568 :     /******************************************************************/
; 7569 :     /*  The read of the data will wrap around the circular queue.     */
; 7570 :     /******************************************************************/
; 7571 : 
; 7572 :     uiRemaining = pMessageQueue->uiLength - pMessageQueue->uiOutputPosition;

  02793	2b c1		 sub	 eax, ecx
  02795	55		 push	 ebp
  02796	8b d0		 mov	 edx, eax

; 7573 : 
; 7574 :     for ( uiI = 0; uiI < uiRemaining; uiI++ )

  02798	74 16		 je	 SHORT $L71252

; 7567 :   {
; 7568 :     /******************************************************************/
; 7569 :     /*  The read of the data will wrap around the circular queue.     */
; 7570 :     /******************************************************************/
; 7571 : 
; 7572 :     uiRemaining = pMessageQueue->uiLength - pMessageQueue->uiOutputPosition;

  0279a	8b ca		 mov	 ecx, edx
$L71250:

; 7575 :       *pItems++ = *pMessageQueue->pOutput++;

  0279c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0279f	83 c7 04	 add	 edi, 4
  027a2	8b 28		 mov	 ebp, DWORD PTR [eax]
  027a4	83 c0 04	 add	 eax, 4
  027a7	89 6f fc	 mov	 DWORD PTR [edi-4], ebp
  027aa	49		 dec	 ecx
  027ab	89 46 08	 mov	 DWORD PTR [esi+8], eax
  027ae	75 ec		 jne	 SHORT $L71250
$L71252:

; 7576 : 
; 7577 :     pMessageQueue->pOutput = pMessageQueue->pStart;

  027b0	8b 06		 mov	 eax, DWORD PTR [esi]

; 7578 : 
; 7579 :     for ( uiI = uiRemaining; uiI < uiNumberToRead; uiI++ )

  027b2	3b d3		 cmp	 edx, ebx
  027b4	89 46 08	 mov	 DWORD PTR [esi+8], eax
  027b7	73 18		 jae	 SHORT $L71255
  027b9	8b cb		 mov	 ecx, ebx
  027bb	2b ca		 sub	 ecx, edx
$L71253:

; 7580 :       *pItems++ = *pMessageQueue->pOutput++;

  027bd	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  027c0	83 c7 04	 add	 edi, 4
  027c3	8b 28		 mov	 ebp, DWORD PTR [eax]
  027c5	83 c0 04	 add	 eax, 4
  027c8	89 6f fc	 mov	 DWORD PTR [edi-4], ebp
  027cb	49		 dec	 ecx
  027cc	89 46 08	 mov	 DWORD PTR [esi+8], eax
  027cf	75 ec		 jne	 SHORT $L71253
$L71255:

; 7581 : 
; 7582 :     /******************************************************************/
; 7583 :     /*  Update the output position in a circular fashion.             */
; 7584 :     /******************************************************************/
; 7585 : 
; 7586 :     pMessageQueue->uiOutputPosition = uiNumberToRead - uiRemaining;

  027d1	2b da		 sub	 ebx, edx
  027d3	5d		 pop	 ebp
  027d4	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 7587 :   }
; 7588 :   else

  027d7	eb 19		 jmp	 SHORT $L71256
$L71249:

; 7589 :   {
; 7590 :     /******************************************************************/
; 7591 :     /*  The read of the data will NOT wrap around the circular queue. */
; 7592 :     /******************************************************************/
; 7593 : 
; 7594 :     for ( uiI = 0; uiI < uiNumberToRead; uiI++ )

  027d9	8b cb		 mov	 ecx, ebx
$L71257:

; 7595 :       *pItems++ = *pMessageQueue->pOutput++;

  027db	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  027de	83 c7 04	 add	 edi, 4
  027e1	8b 18		 mov	 ebx, DWORD PTR [eax]
  027e3	83 c0 04	 add	 eax, 4
  027e6	89 5f fc	 mov	 DWORD PTR [edi-4], ebx
  027e9	49		 dec	 ecx
  027ea	89 46 08	 mov	 DWORD PTR [esi+8], eax
  027ed	75 ec		 jne	 SHORT $L71257

; 7596 : 
; 7597 :     /******************************************************************/
; 7598 :     /*  Update the output position.                                   */
; 7599 :     /******************************************************************/
; 7600 : 
; 7601 :     pMessageQueue->uiOutputPosition += uiNumberToRead;

  027ef	89 56 10	 mov	 DWORD PTR [esi+16], edx
$L71256:

; 7602 :   }
; 7603 : 
; 7604 :   /********************************************************************/
; 7605 :   /*  Update the count of items in the message queue.                 */
; 7606 :   /********************************************************************/
; 7607 : 
; 7608 :   pMessageQueue->uiCount -= uiNumberToRead;

  027f2	8b 5e 18	 mov	 ebx, DWORD PTR [esi+24]

; 7609 : 
; 7610 :   /********************************************************************/
; 7611 :   /*  Set the "Not Full" condition.                                   */
; 7612 :   /********************************************************************/
; 7613 : 
; 7614 :   OP_SetEvent( pMessageQueue->hevNotFull );

  027f5	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  027f8	83 c3 fd	 add	 ebx, -3			; fffffffdH
  027fb	51		 push	 ecx
  027fc	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  027ff	e8 00 00 00 00	 call	 _OP_SetEvent

; 7615 : 
; 7616 :   /********************************************************************/
; 7617 :   /*  Copy the data to the output arguments.                          */
; 7618 :   /********************************************************************/
; 7619 : 
; 7620 :   *paItem_0 = aArray[0];

  02804	8b 54 24 24	 mov	 edx, DWORD PTR _paItem_0$[esp+24]
  02808	8b 44 24 10	 mov	 eax, DWORD PTR _aArray$[esp+28]

; 7621 :   *paItem_1 = aArray[1];

  0280c	8b 4c 24 28	 mov	 ecx, DWORD PTR _paItem_1$[esp+24]
  02810	89 02		 mov	 DWORD PTR [edx], eax
  02812	8b 54 24 14	 mov	 edx, DWORD PTR _aArray$[esp+32]

; 7622 :   *paItem_2 = aArray[2];

  02816	8b 44 24 2c	 mov	 eax, DWORD PTR _paItem_2$[esp+24]
  0281a	89 11		 mov	 DWORD PTR [ecx], edx
  0281c	8b 4c 24 18	 mov	 ecx, DWORD PTR _aArray$[esp+36]
  02820	89 08		 mov	 DWORD PTR [eax], ecx

; 7623 : 
; 7624 :   /******************************************************************/
; 7625 :   /*  Free the message queue.                                       */
; 7626 :   /******************************************************************/
; 7627 : 
; 7628 :   OP_UnlockMutex( pMessageQueue->hmxMessageQueue );

  02822	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  02825	52		 push	 edx
  02826	e8 00 00 00 00	 call	 _OP_UnlockMutex
  0282b	83 c4 08	 add	 esp, 8
  0282e	5f		 pop	 edi
  0282f	5e		 pop	 esi
  02830	5b		 pop	 ebx

; 7629 :   return;
; 7630 : }

  02831	83 c4 0c	 add	 esp, 12			; 0000000cH
  02834	c3		 ret	 0
_ReadMessageQueue ENDP
_uiMessage$ = 12
_dwInstance$ = 16
_lParam1$ = 20
_WaveOutCallbackRoutine@20 PROC NEAR

; 7674 :   HPLAY_AUDIO_T pPlayAudio;
; 7675 :   switch ( uiMessage )
; 7676 :   {

  02840	8b 44 24 08	 mov	 eax, DWORD PTR _uiMessage$[esp-4]
  02844	2d bb 03 00 00	 sub	 eax, 955		; 000003bbH
  02849	74 1b		 je	 SHORT $L71276
  0284b	48		 dec	 eax
  0284c	74 0f		 je	 SHORT $L71286
  0284e	48		 dec	 eax
  0284f	75 33		 jne	 SHORT $L71273

; 7704 :     break;
; 7705 : 
; 7706 :   case MM_WOM_DONE:
; 7707 : 
; 7708 :     /******************************************************************/
; 7709 :     /*  Get the audio handle.                                         */
; 7710 :     /******************************************************************/
; 7711 : 
; 7712 : #ifdef OS_SIXTY_FOUR_BIT
; 7713 : 
; 7714 :     OP_LockMutex( pShm_t->hmxGlobalHandleList );
; 7715 :     pPlayAudio = pShm_t->ppGlobalHandleList[dwInstance];
; 7716 :     OP_UnlockMutex( pShm_t->hmxGlobalHandleList );
; 7717 : 
; 7718 : #else
; 7719 : 
; 7720 :     pPlayAudio = (HPLAY_AUDIO_T)dwInstance;
; 7721 : 
; 7722 : #endif
; 7723 : 
; 7724 :   /********************************************************************/
; 7725 :   /*  Determine the address of the WAVEHDR structure. For Windows,    */
; 7726 :   /*  the address is the same as the address written by the           */
; 7727 :   /*  waveOutWrite() function call that caused this MM_WOM_DONE       */
; 7728 :   /*  message. For the MME Server the returned WAVEHDR address is     */
; 7729 :   /*  different.                                                      */
; 7730 :   /********************************************************************/
; 7731 : 
; 7732 : #ifdef USE_MME_SERVER
; 7733 : 
; 7734 :     /******************************************************************/
; 7735 :     /*  MME BUG WORKAROUND. Because the MME server currently does not */
; 7736 :     /*  return wave headers in the correct order, it is necessary to  */
; 7737 :     /*  put wave headers on a list whenever a wave header is written  */
; 7738 :     /*  by the waveOutWrite() function. This list is accessed in the  */
; 7739 :     /*  wave output callback routine to determine the current header. */
; 7740 :     /******************************************************************/
; 7741 : 
; 7742 :     lParam1 =
; 7743 :       (LPARAM)pPlayAudio->ppWaveHdrInUseList[pPlayAudio->uiWaveHdrReadIndex];
; 7744 : 
; 7745 :     pPlayAudio->uiWaveHdrReadIndex++;
; 7746 : 
; 7747 :     if ( pPlayAudio->uiWaveHdrReadIndex >= MAXIMUM_BUFFERS_QUEUED )
; 7748 :     {
; 7749 :       pPlayAudio->uiWaveHdrReadIndex = 0;
; 7750 :     }
; 7751 : 
; 7752 : #endif
; 7753 : 
; 7754 :     /******************************************************************/
; 7755 :     /*  Put the MM_WOM_DONE message into the "play audio" message     */
; 7756 :     /*  queue. Send the address of the returned wave header.          */
; 7757 :     /******************************************************************/
; 7758 : 
; 7759 :     WriteMessageQueue( pShm_t->pGlobalPlayAudioMessageQueue,
; 7760 :                        (ATYPE_T)pPlayAudio,
; 7761 :                        (ATYPE_T)uiMessage,
; 7762 :                        (ATYPE_T)lParam1 );

  02851	8b 44 24 10	 mov	 eax, DWORD PTR _lParam1$[esp-4]
  02855	50		 push	 eax
  02856	68 bd 03 00 00	 push	 957			; 000003bdH

; 7763 : 
; 7764 :     break;

  0285b	eb 10		 jmp	 SHORT $L71485
$L71286:

; 7765 : 
; 7766 :   case MM_WOM_CLOSE:
; 7767 : 
; 7768 :     /******************************************************************/
; 7769 :     /*  Get the audio handle.                                         */
; 7770 :     /******************************************************************/
; 7771 : 
; 7772 : #ifdef OS_SIXTY_FOUR_BIT
; 7773 : 
; 7774 :     OP_LockMutex( pShm_t->hmxGlobalHandleList );
; 7775 :     pPlayAudio = pShm_t->ppGlobalHandleList[dwInstance];
; 7776 :     OP_UnlockMutex( pShm_t->hmxGlobalHandleList );
; 7777 : 
; 7778 : #else
; 7779 : 
; 7780 :     pPlayAudio = (HPLAY_AUDIO_T)dwInstance;
; 7781 : 
; 7782 : #endif
; 7783 : 
; 7784 :     /******************************************************************/
; 7785 :     /*  Put the MM_WOM_CLOSE message into the "play audio" message    */
; 7786 :     /*  queue.                                                        */
; 7787 :     /******************************************************************/
; 7788 : 
; 7789 :     WriteMessageQueue( pShm_t->pGlobalPlayAudioMessageQueue,
; 7790 :                        (ATYPE_T)pPlayAudio,
; 7791 :                        (ATYPE_T)uiMessage,
; 7792 :                        (ATYPE_T)0 );

  0285d	6a 00		 push	 0
  0285f	68 bc 03 00 00	 push	 956			; 000003bcH

; 7793 :     break;

  02864	eb 07		 jmp	 SHORT $L71485
$L71276:

; 7677 :   case MM_WOM_OPEN:
; 7678 : 
; 7679 :     /******************************************************************/
; 7680 :     /*  Get the audio handle.                                         */
; 7681 :     /******************************************************************/
; 7682 : 
; 7683 : #ifdef OS_SIXTY_FOUR_BIT
; 7684 : 
; 7685 :     OP_LockMutex( pShm_t->hmxGlobalHandleList );
; 7686 :     pPlayAudio = pShm_t->ppGlobalHandleList[dwInstance];
; 7687 :     OP_UnlockMutex( pShm_t->hmxGlobalHandleList );
; 7688 : 
; 7689 : #else
; 7690 : 
; 7691 :     pPlayAudio = (HPLAY_AUDIO_T)dwInstance;
; 7692 : 
; 7693 : #endif
; 7694 : 
; 7695 :     /******************************************************************/
; 7696 :     /*  Put the MM_WOM_OPEN message into the "play audio" message     */
; 7697 :     /*  queue.                                                        */
; 7698 :     /******************************************************************/
; 7699 : 
; 7700 :     WriteMessageQueue( pShm_t->pGlobalPlayAudioMessageQueue,
; 7701 :                        (ATYPE_T)pPlayAudio,
; 7702 :                        (ATYPE_T)uiMessage,
; 7703 :                        (ATYPE_T)0 );

  02866	6a 00		 push	 0
  02868	68 bb 03 00 00	 push	 955			; 000003bbH
$L71485:
  0286d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pShm_t
  02873	8b 4c 24 14	 mov	 ecx, DWORD PTR _dwInstance$[esp+4]
  02877	51		 push	 ecx
  02878	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0287b	50		 push	 eax
  0287c	e8 00 00 00 00	 call	 _WriteMessageQueue
  02881	83 c4 10	 add	 esp, 16			; 00000010H
$L71273:

; 7794 : 
; 7795 :   default:
; 7796 : 
; 7797 :     break;
; 7798 :   }
; 7799 : 
; 7800 :   return;
; 7801 : }

  02884	c2 14 00	 ret	 20			; 00000014H
_WaveOutCallbackRoutine@20 ENDP
_TEXT	ENDS
PUBLIC	_PA_DoSync
_TEXT	SEGMENT
_pPlayAudio$ = 8
_PA_DoSync PROC NEAR

; 7810 : 	// tek 19jun97 we do nothing if we're not working to a device..
; 7811 : 	if (pPlayAudio == NULL)

  02890	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  02894	85 c0		 test	 eax, eax
  02896	74 2a		 je	 SHORT $L71301

; 7812 : 		return;
; 7813 : 
; 7814 : 	  // if there are audio samples to
; 7815 : 	  // play, and the audio device isn't playing them, then start
; 7816 : 	  // the audio device.
; 7817 : #ifdef AUD_DEBUG
; 7818 :   {
; 7819 : 	  // tek 12nov97 corrected as part of the BATS508 edits
; 7820 : 		  char  szTemp[256]="";
; 7821 : 		  sprintf(szTemp,"DoSync at %08lu\n",
; 7822 : 			  timeGetTime()
; 7823 : 			  );	  
; 7824 : 		  OutputDebugString(szTemp);
; 7825 :   }
; 7826 : #endif //AUD_DEBUG
; 7827 :   {
; 7828 :     // tek 19nov97 restructured this logic..
; 7829 :     // if we have something to do..
; 7830 :     if (pPlayAudio->pPlayAudioRing->iQueueCount)

  02898	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  0289e	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  028a1	85 d2		 test	 edx, edx
  028a3	74 1d		 je	 SHORT $L71301

; 7831 : 		  {
; 7832 : 			  // if we own the device, just do it.
; 7833 : 			  if ( pPlayAudio->dwDeviceOptions & PA_OWN_DEVICE )

  028a5	f6 40 3c 01	 test	 BYTE PTR [eax+60], 1
  028a9	74 0a		 je	 SHORT $L71299

; 7834 : 			  {
; 7835 : 			 StartAudioPlaying(pPlayAudio);

  028ab	50		 push	 eax
  028ac	e8 00 00 00 00	 call	 _StartAudioPlaying
  028b1	83 c4 04	 add	 esp, 4

; 7844 : 				  }
; 7845 : 			  }
; 7846 : 		  } // if we have something to do..
; 7847 : 	  }
; 7848 : 
; 7849 : }

  028b4	c3		 ret	 0
$L71299:

; 7836 : 			  }
; 7837 : 			  else // we don't own the device..
; 7838 : 			  {
; 7839 : 				  // if the device is running, do this. if not, it is up to the
; 7840 : 				  // timer thread to start things.
; 7841 : 				  if (AUDIO_DEVICE_ACTIVE == pPlayAudio->dwAudioDeviceState)

  028b5	83 78 34 02	 cmp	 DWORD PTR [eax+52], 2
  028b9	75 07		 jne	 SHORT $L71301

; 7842 : 				  {
; 7843 : 					StartAudioPlaying(pPlayAudio);

  028bb	50		 push	 eax
  028bc	e8 00 00 00 00	 call	 _StartAudioPlaying
  028c1	59		 pop	 ecx
$L71301:

; 7844 : 				  }
; 7845 : 			  }
; 7846 : 		  } // if we have something to do..
; 7847 : 	  }
; 7848 : 
; 7849 : }

  028c2	c3		 ret	 0
_PA_DoSync ENDP
_TEXT	ENDS
PUBLIC	_PA_GetBytesPerSecond
_TEXT	SEGMENT
_pPlayAudio$ = 8
_PA_GetBytesPerSecond PROC NEAR

; 7856 : 	return(pPlayAudio->pWaveFormat->nAvgBytesPerSec);

  028d0	8b 44 24 04	 mov	 eax, DWORD PTR _pPlayAudio$[esp-4]
  028d4	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [eax+156]
  028da	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 7857 : }

  028dd	c3		 ret	 0
_PA_GetBytesPerSecond ENDP
_TEXT	ENDS
END
