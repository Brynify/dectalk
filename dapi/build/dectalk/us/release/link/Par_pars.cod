	TITLE	D:\work\product\dapi\src\Cmd\Par_pars.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0DP@EDMP@par_get_return_level?$DLno?5place?5to@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT _par_get_return_level
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _par_set_return_level
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _par_copy_index_list
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _par_copy_index
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _par_is_index_set
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_char_type_table
PUBLIC	_par_status_string
PUBLIC	_par_check_word_string
PUBLIC	_par_save_string
PUBLIC	_par_insert_string
PUBLIC	_par_compound_break
PUBLIC	_par_replace_string
PUBLIC	_par_delete_string
PUBLIC	_par_dom_dict_search
PUBLIC	_ERROR_func1
PUBLIC	_ERROR_func2
PUBLIC	_perform_action_funcs
_DATA	SEGMENT
_char_type_table DD 00H
	DD	01000H
	DD	08H
	DD	010H
	DD	0800H
	DD	0200H
	DD	04H
	DD	080H
	DD	0400H
	DD	04000H
	DD	040H
	DD	02H
	DD	0100H
	DD	02000H
	DD	020H
	DD	01H
_perform_action_funcs DD FLAT:_ERROR_func2
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func1
	DD	FLAT:_ERROR_func2
	DD	FLAT:_par_delete_string
	DD	FLAT:_ERROR_func2
	DD	FLAT:_par_save_string
	DD	FLAT:_ERROR_func2
	DD	FLAT:_par_replace_string
	DD	FLAT:_par_insert_string
	DD	FLAT:_par_compound_break
	DD	FLAT:_ERROR_func2
	DD	FLAT:_par_dom_dict_search
	DD	FLAT:_par_status_string
	DD	FLAT:_par_check_word_string
$SG71356 DB	'I am a pud-fart. ', 00H
_DATA	ENDS
_TEXT	SEGMENT
_output_array$ = 16
_ret_value$ = 32
_ERROR_func1 PROC NEAR

; 568  : 	strcpy(output_array+ret_value->output_pos,"I am a pud-fart. ");

  00000	8b 44 24 1c	 mov	 eax, DWORD PTR _ret_value$[esp-4]
  00004	8b 54 24 0c	 mov	 edx, DWORD PTR _output_array$[esp-4]
  00008	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000b	03 ca		 add	 ecx, edx
  0000d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR $SG71356
  00013	89 11		 mov	 DWORD PTR [ecx], edx
  00015	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR $SG71356+4
  0001b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0001e	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR $SG71356+8
  00024	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00027	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR $SG71356+12
  0002d	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00030	66 8b 15 10 00
	00 00		 mov	 dx, WORD PTR $SG71356+16
  00037	66 89 51 10	 mov	 WORD PTR [ecx+16], dx

; 569  : 	ret_value->output_offset=strlen("I am a pud-fart. ");

  0003b	c7 40 0c 11 00
	00 00		 mov	 DWORD PTR [eax+12], 17	; 00000011H

; 570  : 	return;
; 571  : }

  00042	c3		 ret	 0
_ERROR_func1 ENDP
_ERROR_func2 PROC NEAR

; 590  : 	return;
; 591  : }

  00050	c3		 ret	 0
_ERROR_func2 ENDP
_TEXT	ENDS
PUBLIC	_par_copy_word_to_output
PUBLIC	_par_skip_white_space
PUBLIC	_par_match_rule
PUBLIC	_par_process_input
PUBLIC	??_C@_0DP@EDMP@par_get_return_level?$DLno?5place?5to@ ; `string'
PUBLIC	??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@ ; `string'
EXTRN	_num_rule_sections:DWORD
EXTRN	_rule_sections:BYTE
EXTRN	_num_rules:DWORD
EXTRN	_rule_index_table:BYTE
EXTRN	_rule_data_table:BYTE
EXTRN	_parser_char_types:BYTE
EXTRN	__imp__printf:NEAR
EXTRN	_cm_util_flush_init:NEAR
_DATA	SEGMENT
	ORG $+2
$SG71505 DB	'par_process_input; no such rule section %d', 0aH, 00H
$SG71506 DB	'Invalid rule section. ', 00H
	ORG $+1
$SG71537 DB	'special rule value is out of range', 0aH, 00H
$SG71572 DB	'rule number is R%d', 0aH, 00H
$SG71590 DB	'Rule hit:R%d', 0aH, 00H
_DATA	ENDS
;	COMDAT ??_C@_0DP@EDMP@par_get_return_level?$DLno?5place?5to@
; File D:\work\product\dapi\src\Cmd\par_pars1.c
_DATA	SEGMENT
??_C@_0DP@EDMP@par_get_return_level?$DLno?5place?5to@ DB 'par_get_return_'
	DB	'level;no place to go to, going to next rule %d', 0aH, 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@
_DATA	SEGMENT
??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@ DB 'par_set_return_'
	DB	'level;too many levels of gorets throwing away %d', 0aH, 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_input_array$ = 12
_new_input$ = 16
_output_array$ = 20
_dict_hit_array$ = 24
_input_indexes$ = 28
_new_input_indexes$ = 32
_output_indexes$ = 36
_in_lang_flag$ = 40
_in_mode_flag$ = 44
_rule$ = 48
_go_until$ = 52
_match_array$ = 56
_ret_value$ = 60
_new_ret$ = -180
_hit_ret$ = -72
_save_ret$ = -112
_current_rule_R_value$ = -116
_cur_rule_next_hit$ = -136
_cur_rule_next_miss$ = -188
_cur_rule_next_go_hit$ = -132
_cur_rule_next_go_miss$ = -192
_cur_rule_copy_hit$ = -196
_done$ = -184
_j$ = -188
_current_rule_number$ = -200
_return_rule$ = -40
_return_level$ = -204
_input_length$ = -80
_new_input_diff$ = -128
_do_not_copy_next_word$ = -124
_pCmd_t$ = -140
_pKsd_t$ = -148
_par_process_input PROC NEAR

; 953  : {

  00060	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH

; 954  : /* 
; 955  :  *	this structure holds the information about where the
; 956  :  *	current search left off in the search of the array
; 957  : 	*/
; 958  : 	/* GL 02/08/1997  add one more item for parser_flag */
; 959  : #ifndef NEW_PARSER_FILE_LOADING
; 960  : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0 }; 
; 961  : 	return_value_t		hit_ret = { 0,0,0,0,0,0,0,0 }; 
; 962  : 	return_value_t		save_ret = { 0,0,0,0,0,0,0,0 };
; 963  : #else
; 964  : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0,NULL }; 
; 965  : 	return_value_t		hit_ret = { 0,0,0,0,0,0,0,0,NULL }; 
; 966  : 	return_value_t		save_ret = { 0,0,0,0,0,0,0,0,NULL };
; 967  : #endif
; 968  : 	U8 *		 		current_rule;	/* a pointer to the current rule */
; 969  : #if (defined DISPLAY_RULES_HIT) || !(defined PARSER_STANDALONE_DEBUG)
; 970  : 	unsigned int		current_rule_R_value;
; 971  : #endif
; 972  : 	int 				cur_rule_next_hit;
; 973  : 	int					cur_rule_next_miss;
; 974  : 	int					cur_rule_next_go_hit;
; 975  : 	int					cur_rule_next_go_miss;
; 976  : 	int					cur_rule_copy_hit;
; 977  : 	unsigned int		current_value;
; 978  : 	int  				done=0;
; 979  : 	int 				i;
; 980  : 	int					j;
; 981  : 	int					k;
; 982  : 	int					last_rule_was_hit=0;
; 983  : 	int 				current_rule_number=0;
; 984  : 	int					return_rule[PAR_MAX_RETURN_LEVEL];
; 985  : 	int					return_level=0;
; 986  : 	int					input_length=0;
; 987  : 	int					new_input_diff=0;
; 988  : 	int					input_size,output_size,size_diff;
; 989  : 	int					rule_p;
; 990  : 	int					temp,do_not_copy_next_word=0;
; 991  : 	U32 *				rule_modes;
; 992  : 	U16	*				rule_flags;
; 993  : 	
; 994  : #ifndef PARSER_STANDALONE_DEBUG
; 995  : 	PCMD_T pCmd_t;
; 996  : 	PKSD_T  pKsd_t;
; 997  : 	pCmd_t=phTTS->pCMDThreadData;

  00066	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR _phTTS$[esp+200]
  0006d	53		 push	 ebx

; 998  : 	pKsd_t=phTTS->pKernelShareData;
; 999  : #endif
; 1000 : 	
; 1001 : #ifdef DEBUG
; 1002 : 	printf("entering par_process_input\n");
; 1003 : #endif
; 1004 : 	new_ret.input_pos=ret_value->input_pos+ret_value->input_offset;	

  0006e	8b 9c 24 08 01
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+204]
  00075	55		 push	 ebp
  00076	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00079	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0007c	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0007f	56		 push	 esi
  00080	8b 33		 mov	 esi, DWORD PTR [ebx]
  00082	89 54 24 44	 mov	 DWORD PTR _pKsd_t$[esp+216], edx

; 1005 : 	new_ret.input_offset=0;
; 1006 : 	new_ret.output_pos=ret_value->output_pos+ret_value->output_offset;

  00086	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  00089	03 c6		 add	 eax, esi
  0008b	89 44 24 24	 mov	 DWORD PTR _new_ret$[esp+216], eax
  0008f	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00092	03 c2		 add	 eax, edx
  00094	89 4c 24 4c	 mov	 DWORD PTR _pCmd_t$[esp+216], ecx

; 1007 : 	new_ret.output_offset=0;                 
; 1008 : 	/* GL 02/08/1997 set the initial parser_flag value */
; 1009 : 	new_ret.parser_flag = ret_value->parser_flag;
; 1010 : #ifdef NEW_PARSER_FILE_LOADING
; 1011 : #ifdef PARSER_STANDALONE_DEBUG
; 1012 : 	new_ret.phTTS=NULL;
; 1013 : #else
; 1014 : 	new_ret.phTTS=phTTS;
; 1015 : #endif
; 1016 : #endif
; 1017 : 	
; 1018 : 	if (rule>num_rule_sections)

  00098	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _num_rule_sections
  0009e	89 44 24 2c	 mov	 DWORD PTR _new_ret$[esp+224], eax
  000a2	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  000a5	33 ed		 xor	 ebp, ebp
  000a7	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+244], eax
  000ab	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR _rule$[esp+212]
  000b2	3b c1		 cmp	 eax, ecx
  000b4	57		 push	 edi
  000b5	89 6c 24 38	 mov	 DWORD PTR _new_ret$[esp+236], ebp
  000b9	89 6c 24 3c	 mov	 DWORD PTR _new_ret$[esp+240], ebp
  000bd	89 6c 24 40	 mov	 DWORD PTR _new_ret$[esp+244], ebp
  000c1	89 ac 24 94 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+220], ebp
  000c8	89 ac 24 98 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+224], ebp
  000cf	89 ac 24 9c 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+228], ebp
  000d6	89 ac 24 a0 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+232], ebp
  000dd	89 ac 24 a4 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+236], ebp
  000e4	89 ac 24 a8 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+240], ebp
  000eb	89 ac 24 ac 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+244], ebp
  000f2	89 ac 24 b0 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+248], ebp
  000f9	89 6c 24 24	 mov	 DWORD PTR _done$[esp+220], ebp
  000fd	89 6c 24 10	 mov	 DWORD PTR _return_level$[esp+220], ebp
  00101	89 6c 24 5c	 mov	 DWORD PTR _new_input_diff$[esp+220], ebp
  00105	89 6c 24 60	 mov	 DWORD PTR _do_not_copy_next_word$[esp+220], ebp
  00109	89 6c 24 2c	 mov	 DWORD PTR _new_ret$[esp+224], ebp
  0010d	89 6c 24 34	 mov	 DWORD PTR _new_ret$[esp+232], ebp
  00111	7e 32		 jle	 SHORT $L71504

; 1019 : 	{
; 1020 : 		printf("par_process_input; no such rule section %d\n",rule);

  00113	50		 push	 eax
  00114	68 00 00 00 00	 push	 OFFSET FLAT:$SG71505
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf

; 1021 : 		strcpy(output_array,"Invalid rule section. ");

  0011f	8b bc 24 f4 00
	00 00		 mov	 edi, DWORD PTR _output_array$[esp+224]
  00126	b9 05 00 00 00	 mov	 ecx, 5
  0012b	be 00 00 00 00	 mov	 esi, OFFSET FLAT:$SG71506
  00130	83 c4 08	 add	 esp, 8
  00133	f3 a5		 rep movsd
  00135	66 a5		 movsw
  00137	a4		 movsb
  00138	5f		 pop	 edi
  00139	5e		 pop	 esi

; 1635 : #ifdef DEBUG
; 1636 : 	printf("leaving par_process_input\n");
; 1637 : #endif
; 1638 : 	return(ret_value);

  0013a	8b c3		 mov	 eax, ebx
  0013c	5d		 pop	 ebp
  0013d	5b		 pop	 ebx

; 1639 : }                       

  0013e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00144	c3		 ret	 0
$L71504:

; 1022 : 		return(ret_value);
; 1023 : 	}
; 1024 : 	memset(return_rule,-1,sizeof(return_rule));
; 1025 : 
; 1026 : 	input_length=strlen(input_array);

  00145	8b b4 24 e4 00
	00 00		 mov	 esi, DWORD PTR _input_array$[esp+216]
  0014c	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00151	83 c8 ff	 or	 eax, -1
  00154	8d bc 24 b4 00
	00 00		 lea	 edi, DWORD PTR _return_rule$[esp+220]
  0015b	f3 ab		 rep stosd
  0015d	8b fe		 mov	 edi, esi
  0015f	83 c9 ff	 or	 ecx, -1
  00162	33 c0		 xor	 eax, eax
  00164	f2 ae		 repne scasb
  00166	f7 d1		 not	 ecx
  00168	49		 dec	 ecx

; 1027 : 	
; 1028 : 	strcpy(new_input,input_array);

  00169	8b fe		 mov	 edi, esi
  0016b	8b d1		 mov	 edx, ecx
  0016d	83 c9 ff	 or	 ecx, -1
  00170	f2 ae		 repne scasb
  00172	f7 d1		 not	 ecx
  00174	2b f9		 sub	 edi, ecx
  00176	8b c1		 mov	 eax, ecx
  00178	8b f7		 mov	 esi, edi
  0017a	8b bc 24 e8 00
	00 00		 mov	 edi, DWORD PTR _new_input$[esp+216]
  00181	c1 e9 02	 shr	 ecx, 2
  00184	f3 a5		 rep movsd
  00186	8b c8		 mov	 ecx, eax
  00188	83 e1 03	 and	 ecx, 3
  0018b	f3 a4		 rep movsb

; 1029 : 	memcpy(new_input_indexes,input_indexes,input_length*sizeof(index_data_t));

  0018d	8b b4 24 f4 00
	00 00		 mov	 esi, DWORD PTR _input_indexes$[esp+216]
  00194	8b bc 24 f8 00
	00 00		 mov	 edi, DWORD PTR _new_input_indexes$[esp+216]
  0019b	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]

; 1030 : 	
; 1031 : 	input_length=(input_length*2)/3; /* input_length * 2/3 */

  0019e	03 d2		 add	 edx, edx
  001a0	d1 e1		 shl	 ecx, 1
  001a2	8b c1		 mov	 eax, ecx
  001a4	c1 e9 02	 shr	 ecx, 2
  001a7	f3 a5		 rep movsd
  001a9	8b c8		 mov	 ecx, eax
  001ab	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  001b0	f7 ea		 imul	 edx
  001b2	83 e1 03	 and	 ecx, 3
  001b5	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+224]
  001b9	f3 a4		 rep movsb
  001bb	8b b4 24 e8 00
	00 00		 mov	 esi, DWORD PTR _new_input$[esp+216]
  001c2	8b ca		 mov	 ecx, edx
  001c4	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  001c7	03 d1		 add	 edx, ecx
  001c9	bf 01 00 00 00	 mov	 edi, 1
  001ce	89 94 24 8c 00
	00 00		 mov	 DWORD PTR _input_length$[esp+220], edx
$L71509:

; 1032 : 	/* copy the input array to a temporary location for hit next rules */
; 1033 :     
; 1034 :     while (((new_input[new_ret.input_pos+new_ret.input_offset]!='\0') && (go_until==0)) ||    	   
; 1035 :     	   (((new_ret.input_pos+new_ret.input_offset-new_input_diff)<input_length) && (go_until==1) ) )

  001d5	8b 4c 24 28	 mov	 ecx, DWORD PTR _new_ret$[esp+220]
  001d9	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]
  001dc	80 3c 32 00	 cmp	 BYTE PTR [edx+esi], 0
  001e0	74 09		 je	 SHORT $L71512
  001e2	39 ac 24 0c 01
	00 00		 cmp	 DWORD PTR _go_until$[esp+216], ebp
  001e9	74 24		 je	 SHORT $L71511
$L71512:
  001eb	8b 54 24 5c	 mov	 edx, DWORD PTR _new_input_diff$[esp+220]
  001ef	2b c2		 sub	 eax, edx
  001f1	03 c1		 add	 eax, ecx
  001f3	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR _input_length$[esp+220]
  001fa	3b c1		 cmp	 eax, ecx
  001fc	0f 8d fd 09 00
	00		 jge	 $L71510
  00202	39 bc 24 0c 01
	00 00		 cmp	 DWORD PTR _go_until$[esp+216], edi
  00209	0f 85 f0 09 00
	00		 jne	 $L71510
$L71511:

; 1036 : 	{
; 1037 : #ifndef PARSER_STANDALONE_DEBUG
; 1038 : 		/* checking cmd_flushing */
; 1039 : 		if (pKsd_t->text_flush || (pKsd_t->cmd_flush == CMD_flush_toss))

  0020f	8b 44 24 48	 mov	 eax, DWORD PTR _pKsd_t$[esp+220]
  00213	39 a8 70 01 00
	00		 cmp	 DWORD PTR [eax+368], ebp
  00219	0f 85 72 09 00
	00		 jne	 $L71514
  0021f	39 b8 6c 01 00
	00		 cmp	 DWORD PTR [eax+364], edi
  00225	0f 84 66 09 00
	00		 je	 $L71514

; 1040 : 		{
; 1041 : 			cm_util_flush_init(phTTS);
; 1042 : 			return(&pCmd_t->ret_value);
; 1043 : 		}              
; 1044 : #endif
; 1045 : 		if (par_skip_white_space(new_input,new_input_indexes,output_array,output_indexes,&new_ret)== -1)

  0022b	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR _output_indexes$[esp+216]
  00232	8b 94 24 ec 00
	00 00		 mov	 edx, DWORD PTR _output_array$[esp+216]
  00239	8d 44 24 28	 lea	 eax, DWORD PTR _new_ret$[esp+220]
  0023d	50		 push	 eax
  0023e	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR _new_input_indexes$[esp+220]
  00245	51		 push	 ecx
  00246	52		 push	 edx
  00247	50		 push	 eax
  00248	56		 push	 esi
  00249	e8 00 00 00 00	 call	 _par_skip_white_space
  0024e	83 c4 14	 add	 esp, 20			; 00000014H
  00251	83 f8 ff	 cmp	 eax, -1
  00254	75 04		 jne	 SHORT $L71516

; 1046 : 			/* skip whitespace between words */		
; 1047 : 			/* copies one whitespace to the output array */
; 1048 : 			/* if there is an index, an extra space may end up in the output */
; 1049 : 		{
; 1050 : 			done=1;

  00256	89 7c 24 24	 mov	 DWORD PTR _done$[esp+220], edi
$L71516:

; 1051 : 		}  	               
; 1052 : 		par_copy_return_value(&save_ret,&new_ret);	/* save the values if the matching ends on a non white */
; 1053 : 		current_rule=NULL;                     
; 1054 : 		current_rule_number=rule_sections[rule];
; 1055 : 		last_rule_was_hit=0;
; 1056 : #ifdef DEBUG
; 1057 : 		par_print_rule_error("par_process_input;1 the input is",new_input,new_ret.input_pos+new_ret.input_offset);
; 1058 : 		par_print_rule_error("par_process_input;1 the output is",output_array,new_ret.output_pos+new_ret.output_offset);
; 1059 : #endif
; 1060 : 		while (!done)

  0025a	8b 44 24 24	 mov	 eax, DWORD PTR _done$[esp+220]
  0025e	b9 08 00 00 00	 mov	 ecx, 8
  00263	8d 74 24 28	 lea	 esi, DWORD PTR _new_ret$[esp+220]
  00267	8d 7c 24 6c	 lea	 edi, DWORD PTR _save_ret$[esp+220]
  0026b	f3 a5		 rep movsd
  0026d	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR _rule$[esp+216]
  00274	33 ed		 xor	 ebp, ebp
  00276	85 c0		 test	 eax, eax
  00278	8b 1c 8d 00 00
	00 00		 mov	 ebx, DWORD PTR _rule_sections[ecx*4]
  0027f	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00283	0f 85 89 08 00
	00		 jne	 $L71527
$L71520:

; 1061 : 		{  	
; 1062 : #ifndef PARSER_STANDALONE_DEBUG
; 1063 : 			/* checking cmd_flushing */
; 1064 : 			if (pKsd_t->text_flush || (pKsd_t->cmd_flush == CMD_flush_toss))

  00289	8b 54 24 48	 mov	 edx, DWORD PTR _pKsd_t$[esp+220]
  0028d	8b 82 70 01 00
	00		 mov	 eax, DWORD PTR [edx+368]
  00293	85 c0		 test	 eax, eax
  00295	0f 85 3f 09 00
	00		 jne	 $L71523
  0029b	83 ba 6c 01 00
	00 01		 cmp	 DWORD PTR [edx+364], 1
  002a2	0f 84 32 09 00
	00		 je	 $L71523

; 1068 : 			}              
; 1069 : #endif
; 1070 : 			/* MGS commented out for speed */
; 1071 : 			//			par_initialize_arrays(match_array);
; 1072 : //			memset(match_array->array_lengths,0,sizeof(match_array->array_lengths));
; 1073 : 			current_rule=&(rule_data_table[rule_index_table[current_rule_number]]); /* this line will change for the new rule tables */

  002a8	8b 3c 9d 00 00
	00 00		 mov	 edi, DWORD PTR _rule_index_table[ebx*4]

; 1074 : 			rule_p=0;
; 1075 : #ifdef DEBUG
; 1076 : 			par_print_rule_error("par_process_input;2 the input is",new_input,new_ret.input_pos+new_ret.input_offset);
; 1077 : 			par_print_rule_error("par_process_input;2 the output is",output_array,new_ret.input_pos+new_ret.output_offset);
; 1078 : #endif
; 1079 : 			/* 
; 1080 : 			* check for stop. if the last rule was a hit rule, 
; 1081 : 			* put the old values for the input and output back
; 1082 : 			*/
; 1083 : 			rule_flags=(U16 *)current_rule;
; 1084 : 			current_value=*rule_flags;

  002af	33 c9		 xor	 ecx, ecx
  002b1	81 c7 00 00 00
	00		 add	 edi, OFFSET FLAT:_rule_data_table
  002b7	66 8b 0f	 mov	 cx, WORD PTR [edi]

; 1085 : //			current_value=(*((U16 *)(current_rule)));
; 1086 : 			if (current_value & BIN_SPECIAL_RULE_MASK)

  002ba	8b c1		 mov	 eax, ecx
  002bc	25 00 e0 00 00	 and	 eax, 57344		; 0000e000H
  002c1	0f 84 a4 00 00
	00		 je	 $L71525

; 1087 : 			{
; 1088 : 				switch (current_value & BIN_SPECIAL_RULE_MASK)
; 1089 : 				{

  002c7	3d 00 a0 00 00	 cmp	 eax, 40960		; 0000a000H
  002cc	77 4f		 ja	 SHORT $L72828
  002ce	0f 84 88 00 00
	00		 je	 $L71534
  002d4	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  002d9	0f 84 05 08 00
	00		 je	 $L71530
  002df	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  002e4	0f 85 1a 08 00
	00		 jne	 $L72892

; 1104 : 				case BIN_RETURN:
; 1105 : 					current_rule_number=par_get_return_level(return_rule,&return_level,current_rule_number);

  002ea	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  002ee	85 c0		 test	 eax, eax
  002f0	7e 12		 jle	 SHORT $L72832
  002f2	8b 9c 84 b0 00
	00 00		 mov	 ebx, DWORD PTR _return_rule$[esp+eax*4+216]
  002f9	48		 dec	 eax
  002fa	89 44 24 10	 mov	 DWORD PTR _return_level$[esp+220], eax
  002fe	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00302	eb 85		 jmp	 SHORT $L71520
$L72832:
  00304	53		 push	 ebx
  00305	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0DP@EDMP@par_get_return_level?$DLno?5place?5to@ ; `string'
  0030a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00310	83 c4 08	 add	 esp, 8
  00313	43		 inc	 ebx
  00314	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx

; 1106 : 					continue;

  00318	e9 6c ff ff ff	 jmp	 $L71520
$L72828:

; 1087 : 			{
; 1088 : 				switch (current_value & BIN_SPECIAL_RULE_MASK)
; 1089 : 				{

  0031d	3d 00 c0 00 00	 cmp	 eax, 49152		; 0000c000H
  00322	0f 85 dc 07 00
	00		 jne	 $L72892

; 1107 : 				case BIN_GOTO:
; 1108 : //					current_rule_number=(*((U16 *)(current_rule+2)));
; 1109 : 					current_rule_number=*(rule_flags+1);
; 1110 : 					continue;
; 1111 : 					/* put in goret and return here */
; 1112 : 				case BIN_GORET:
; 1113 : 					par_set_return_level(return_rule,&return_level,current_rule_number+1);

  00328	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  0032c	43		 inc	 ebx
  0032d	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00330	7d 1b		 jge	 SHORT $L72837
  00332	89 9c 84 b4 00
	00 00		 mov	 DWORD PTR _return_rule$[esp+eax*4+220], ebx
  00339	40		 inc	 eax

; 1114 : 					current_rule_number=*(rule_flags+1);

  0033a	33 db		 xor	 ebx, ebx
  0033c	89 44 24 10	 mov	 DWORD PTR _return_level$[esp+220], eax
  00340	66 8b 5f 02	 mov	 bx, WORD PTR [edi+2]
  00344	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx

; 1115 : // 					current_rule_number=(*((U16 *)(current_rule+2)));
; 1116 : 					continue;

  00348	e9 3c ff ff ff	 jmp	 $L71520

; 1107 : 				case BIN_GOTO:
; 1108 : //					current_rule_number=(*((U16 *)(current_rule+2)));
; 1109 : 					current_rule_number=*(rule_flags+1);
; 1110 : 					continue;
; 1111 : 					/* put in goret and return here */
; 1112 : 				case BIN_GORET:
; 1113 : 					par_set_return_level(return_rule,&return_level,current_rule_number+1);

$L72837:
  0034d	53		 push	 ebx
  0034e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@ ; `string'
  00353	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00359	83 c4 08	 add	 esp, 8
$L71534:

; 1114 : 					current_rule_number=*(rule_flags+1);

  0035c	33 db		 xor	 ebx, ebx
  0035e	66 8b 5f 02	 mov	 bx, WORD PTR [edi+2]
  00362	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx

; 1115 : // 					current_rule_number=(*((U16 *)(current_rule+2)));
; 1116 : 					continue;

  00366	e9 1e ff ff ff	 jmp	 $L71520
$L71525:

; 1119 : 					break;
; 1120 : 				}
; 1121 : 				break;
; 1122 : 			}
; 1123 : /* GL 04/16/98  add this for rule number caculation under debug mode */
; 1124 : /*              keep the debug setting for DISPLAY_RULES_HIT         */
; 1125 : #ifndef PARSER_STANDALONE_DEBUG
; 1126 : 			if (DT_DBG(CMD_DBG,0x0010))

  0036b	66 8b 82 78 04
	00 00		 mov	 ax, WORD PTR [edx+1144]
  00372	f6 c4 80	 test	 ah, -128		; ffffff80H
  00375	74 0e		 je	 SHORT $L71538
  00377	a8 10		 test	 al, 16			; 00000010H
  00379	74 0a		 je	 SHORT $L71538

; 1127 : 			{
; 1128 : 				rule_p+=2; /* advance past the special rule value flags */
; 1129 : 				current_rule_R_value=(*((U16 *)(current_rule+rule_p)));

  0037b	33 c0		 xor	 eax, eax
  0037d	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  00381	89 44 24 68	 mov	 DWORD PTR _current_rule_R_value$[esp+220], eax
$L71538:

; 1130 : 				rule_p+=2;;
; 1131 : 			}
; 1132 : 			else
; 1133 : 			{
; 1134 : 				rule_p+=4;
; 1135 : 			}
; 1136 : #endif
; 1137 : #ifdef DISPLAY_RULES_HIT
; 1138 : 			rule_p+=2; /* advance past the special rule value flags */
; 1139 : 			current_rule_R_value=(*((U16 *)(current_rule+rule_p)));
; 1140 : 			rule_p+=2;;
; 1141 : //#else
; 1142 : //			rule_p+=4;
; 1143 : #endif
; 1144 : 
; 1145 : //			new_ret.rule=0;
; 1146 : 			new_ret.value=FAIL;
; 1147 : //			i=0;
; 1148 : 			/* check the language tag */
; 1149 : 			/* get the language flag */
; 1150 : 			rule_modes=(U32 *)(current_rule+rule_p);
; 1151 : #ifdef DEBUG
; 1152 : 			printf("the language flag is 0x%08X\n",*rule_modes);
; 1153 : #endif
; 1154 : 			/* check the language flag against the kernel langauge flag for the correct langauage */
; 1155 : 			
; 1156 : 			if ((last_rule_was_hit==0) && (((*rule_modes) & in_lang_flag)==0))

  00385	85 ed		 test	 ebp, ebp
  00387	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR _new_ret$[esp+240], 0
  0038f	75 36		 jne	 SHORT $L71545
  00391	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR _in_lang_flag$[esp+216]
  00398	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0039b	85 c2		 test	 eax, edx
  0039d	75 17		 jne	 SHORT $L72899
$L72913:

; 1157 : 			{
; 1158 : 				current_rule_number++;	/* go to the next rule */
; 1159 : 				if (current_rule_number>=num_rules)		

  0039f	a1 00 00 00 00	 mov	 eax, DWORD PTR _num_rules
  003a4	43		 inc	 ebx
  003a5	3b d8		 cmp	 ebx, eax
  003a7	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  003ab	0f 8d 61 07 00
	00		 jge	 $L71527

; 1160 : 					done=1;
; 1161 : 				continue;

  003b1	e9 d3 fe ff ff	 jmp	 $L71520
$L72899:

; 1162 : 			}                                          
; 1163 : 			/* check the rule mode here */
; 1164 : #ifdef DEBUG
; 1165 : 			printf("the mode flag is 0x%08X\n",rule_modes[1]);
; 1166 : #endif
; 1167 : 			/*	044	MGS		09/24/1997	BATS#469 Fix for NWS parser problem */
; 1168 : 			if (last_rule_was_hit==0)
; 1169 : 			{
; 1170 : 				if ((rule_modes[1] != 0xFFFFFFFF) &&
; 1171 : 					((rule_modes[1] & in_mode_flag)==0))	

  003b6	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  003b9	83 f8 ff	 cmp	 eax, -1
  003bc	74 09		 je	 SHORT $L71545
  003be	85 84 24 04 01
	00 00		 test	 DWORD PTR _in_mode_flag$[esp+216], eax

; 1172 : 				{
; 1173 : 					current_rule_number++;	/* go to the next rule */
; 1174 : 					if (current_rule_number>=num_rules)		
; 1175 : 						done=1;
; 1176 : 					continue;

  003c5	74 d8		 je	 SHORT $L72913
$L71545:

; 1177 : 				}
; 1178 : 			}
; 1179 : 			rule_p+=8;
; 1180 : 			if ((current_value & (BIN_DICT_HIT | BIN_DICT_MISS)))

  003c7	f6 c1 c0	 test	 cl, 192			; 000000c0H
  003ca	be 0c 00 00 00	 mov	 esi, 12			; 0000000cH
  003cf	74 57		 je	 SHORT $L71554

; 1181 : 			{
; 1182 : 				if ((current_value & BIN_DICT_HIT) && 
; 1183 : 					(dict_hit_array[new_ret.input_pos+new_ret.input_offset]!=DICT_MISS_VALUE))

  003d1	f6 c1 80	 test	 cl, 128			; 00000080H
  003d4	74 17		 je	 SHORT $L71548
  003d6	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+224]
  003da	8b 54 24 28	 mov	 edx, DWORD PTR _new_ret$[esp+220]
  003de	03 c2		 add	 eax, edx
  003e0	8b 94 24 f0 00
	00 00		 mov	 edx, DWORD PTR _dict_hit_array$[esp+216]
  003e7	80 3c 10 00	 cmp	 BYTE PTR [eax+edx], 0
  003eb	75 3b		 jne	 SHORT $L71554
$L71548:

; 1184 : 				{
; 1185 : #ifdef DEBUG
; 1186 : 					printf("processing rule because of dictionary HIT on the word\n");
; 1187 : #endif				
; 1188 : 				}
; 1189 : 				else
; 1190 : 				{
; 1191 : 					if ((current_value & BIN_DICT_MISS) && 
; 1192 : 						(dict_hit_array[new_ret.input_pos+new_ret.input_offset]==DICT_MISS_VALUE))

  003ed	f6 c1 40	 test	 cl, 64			; 00000040H
  003f0	74 17		 je	 SHORT $L71550
  003f2	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+224]
  003f6	8b 54 24 28	 mov	 edx, DWORD PTR _new_ret$[esp+220]
  003fa	03 c2		 add	 eax, edx
  003fc	8b 94 24 f0 00
	00 00		 mov	 edx, DWORD PTR _dict_hit_array$[esp+216]
  00403	80 3c 10 00	 cmp	 BYTE PTR [eax+edx], 0
  00407	74 1f		 je	 SHORT $L71554
$L71550:

; 1193 : 					{
; 1194 : #ifdef DEBUG
; 1195 : 						printf("processing rule because of dictionary MISS on the word\n");
; 1196 : #endif
; 1197 : 					}
; 1198 : 					else
; 1199 : 					{
; 1200 : 						current_rule_number++;
; 1201 : 						if (current_rule_number>=num_rules)		

  00409	a1 00 00 00 00	 mov	 eax, DWORD PTR _num_rules
  0040e	43		 inc	 ebx
  0040f	3b d8		 cmp	 ebx, eax
  00411	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00415	0f 8d f7 06 00
	00		 jge	 $L71527

; 1202 : 							done=1;
; 1203 : 						else
; 1204 : 							done= -1;
; 1205 : 					}
; 1206 : 				}
; 1207 : 			} /* if (current_rule->dict_flag!=UNSET_PARAM) */
; 1208 : 			if (done)
; 1209 : 			{
; 1210 : 				if (done<0)
; 1211 : 					done=0;

  0041b	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _done$[esp+220], 0

; 1212 : 				continue;

  00423	e9 61 fe ff ff	 jmp	 $L71520
$L71554:

; 1213 : 			}
; 1214 : 			
; 1215 : 			if (current_value & BIN_NEXT_HIT)

  00428	f6 c5 10	 test	 ch, 16			; 00000010H
  0042b	74 14		 je	 SHORT $L71556

; 1216 : 			{
; 1217 : 				cur_rule_next_hit = *((U16 *)(current_rule+rule_p));

  0042d	33 c0		 xor	 eax, eax

; 1218 : 				rule_p+=2;

  0042f	be 0e 00 00 00	 mov	 esi, 14			; 0000000eH
  00434	66 8b 47 0c	 mov	 ax, WORD PTR [edi+12]

; 1219 : 			}
; 1220 : 			else

  00438	83 ca ff	 or	 edx, -1
  0043b	89 44 24 54	 mov	 DWORD PTR _cur_rule_next_hit$[esp+220], eax
  0043f	eb 07		 jmp	 SHORT $L71558
$L71556:

; 1221 : 			{
; 1222 : 				cur_rule_next_hit=-1;

  00441	83 ca ff	 or	 edx, -1
  00444	89 54 24 54	 mov	 DWORD PTR _cur_rule_next_hit$[esp+220], edx
$L71558:

; 1223 : 			}
; 1224 : 			if (current_value & BIN_NEXT_MISS)

  00448	f6 c5 08	 test	 ch, 8
  0044b	74 0f		 je	 SHORT $L71559

; 1225 : 			{
; 1226 : 				cur_rule_next_miss = *((U16 *)(current_rule+rule_p));

  0044d	33 c0		 xor	 eax, eax
  0044f	66 8b 04 3e	 mov	 ax, WORD PTR [esi+edi]

; 1227 : 				rule_p+=2;

  00453	83 c6 02	 add	 esi, 2
  00456	89 44 24 20	 mov	 DWORD PTR _cur_rule_next_miss$[esp+220], eax

; 1228 : 			}
; 1229 : 			else

  0045a	eb 04		 jmp	 SHORT $L71561
$L71559:

; 1230 : 			{
; 1231 : 				cur_rule_next_miss=-1;

  0045c	89 54 24 20	 mov	 DWORD PTR _cur_rule_next_miss$[esp+220], edx
$L71561:

; 1232 : 			}
; 1233 : 			if (current_value & BIN_GORET_HIT)

  00460	f6 c5 04	 test	 ch, 4
  00463	74 0f		 je	 SHORT $L71562

; 1234 : 			{
; 1235 : 				cur_rule_next_go_hit = *((U16 *)(current_rule+rule_p));

  00465	33 c0		 xor	 eax, eax
  00467	66 8b 04 3e	 mov	 ax, WORD PTR [esi+edi]

; 1236 : 				rule_p+=2;

  0046b	83 c6 02	 add	 esi, 2
  0046e	89 44 24 58	 mov	 DWORD PTR _cur_rule_next_go_hit$[esp+220], eax

; 1237 : 			}
; 1238 : 			else

  00472	eb 04		 jmp	 SHORT $L71564
$L71562:

; 1239 : 			{
; 1240 : 				cur_rule_next_go_hit=-1;

  00474	89 54 24 58	 mov	 DWORD PTR _cur_rule_next_go_hit$[esp+220], edx
$L71564:

; 1241 : 			}
; 1242 : 			if (current_value & BIN_GORET_MISS)

  00478	f6 c5 02	 test	 ch, 2
  0047b	74 0f		 je	 SHORT $L71565

; 1243 : 			{
; 1244 : 				cur_rule_next_go_miss = *((U16 *)(current_rule+rule_p));

  0047d	33 c0		 xor	 eax, eax
  0047f	66 8b 04 3e	 mov	 ax, WORD PTR [esi+edi]

; 1245 : 				rule_p+=2;

  00483	83 c6 02	 add	 esi, 2
  00486	89 44 24 1c	 mov	 DWORD PTR _cur_rule_next_go_miss$[esp+220], eax

; 1246 : 			}
; 1247 : 			else

  0048a	eb 04		 jmp	 SHORT $L71567
$L71565:

; 1248 : 			{
; 1249 : 				cur_rule_next_go_miss=-1;

  0048c	89 54 24 1c	 mov	 DWORD PTR _cur_rule_next_go_miss$[esp+220], edx
$L71567:

; 1250 : 			}
; 1251 : 			if (current_value & BIN_COPY_HIT)

  00490	f6 c5 01	 test	 ch, 1
  00493	74 0f		 je	 SHORT $L71568

; 1252 : 			{
; 1253 : 				cur_rule_copy_hit = *((U16 *)(current_rule+rule_p));

  00495	33 c0		 xor	 eax, eax
  00497	66 8b 04 3e	 mov	 ax, WORD PTR [esi+edi]

; 1254 : 				rule_p+=2;

  0049b	83 c6 02	 add	 esi, 2
  0049e	89 44 24 18	 mov	 DWORD PTR _cur_rule_copy_hit$[esp+220], eax

; 1255 : 			}
; 1256 : 			else

  004a2	eb 04		 jmp	 SHORT $L71570
$L71568:

; 1257 : 			{
; 1258 : 				cur_rule_copy_hit=-1;

  004a4	89 54 24 18	 mov	 DWORD PTR _cur_rule_copy_hit$[esp+220], edx
$L71570:

; 1259 : 			}
; 1260 : 			
; 1261 : #ifdef DEBUG_RULES
; 1262 : #ifdef PARSER_STANDALONE_DEBUG
; 1263 : 			fprintf(stderr,"rule number is R%d\n",current_rule_R_value);
; 1264 : 			fprintf(stderr,"next hit rule is %d\n",cur_rule_next_hit);
; 1265 : 			fprintf(stderr,"next_miss_rule is %d\n",cur_rule_next_miss);
; 1266 : #else
; 1267 : 			printf("rule number is R%d\n",current_rule_R_value);
; 1268 : 			printf("next hit rule is %d\n",cur_rule_next_hit);
; 1269 : 			printf("next_miss_rule is %d\n",cur_rule_next_miss);
; 1270 : #endif
; 1271 : #endif
; 1272 : 			
; 1273 : 			
; 1274 : #ifdef DISPLAY_RULES_TESTED
; 1275 : #ifdef OUTPUT_HITS_NORMAL
; 1276 : 			printf("rule number is R%d\n",current_rule_R_value);
; 1277 : #else
; 1278 : 			fprintf(stderr,"rule number is R%d\n",current_rule_R_value);
; 1279 : #endif
; 1280 : #endif
; 1281 : #ifndef PARSER_STANDALONE_DEBUG
; 1282 : 			if (DT_DBG(CMD_DBG,0x0200))

  004a8	8b 44 24 48	 mov	 eax, DWORD PTR _pKsd_t$[esp+220]
  004ac	66 8b 80 78 04
	00 00		 mov	 ax, WORD PTR [eax+1144]
  004b3	f6 c4 80	 test	 ah, -128		; ffffff80H
  004b6	74 18		 je	 SHORT $L71571
  004b8	f6 c4 02	 test	 ah, 2
  004bb	74 13		 je	 SHORT $L71571

; 1283 : 			{
; 1284 : 				printf("rule number is R%d\n",current_rule_R_value);

  004bd	8b 4c 24 68	 mov	 ecx, DWORD PTR _current_rule_R_value$[esp+220]
  004c1	51		 push	 ecx
  004c2	68 00 00 00 00	 push	 OFFSET FLAT:$SG71572
  004c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  004cd	83 c4 08	 add	 esp, 8
$L71571:

; 1285 : 				//par_print_rule_error("input before match",new_input,new_ret.input_pos+new_ret.input_offset);
; 1286 : 			}
; 1287 : #endif
; 1288 : 
; 1289 : 			
; 1290 : #ifdef DEBUG
; 1291 : 			par_print_rule_error("par_process_input; before par_match_rule",current_rule,new_ret.rule);
; 1292 : #endif
; 1293 : 			
; 1294 : #ifndef PARSER_STANDALONE_DEBUG
; 1295 : 			/* checking cmd_flushing */
; 1296 : 			if (pKsd_t->text_flush || (pKsd_t->cmd_flush == CMD_flush_toss))

  004d0	8b 44 24 48	 mov	 eax, DWORD PTR _pKsd_t$[esp+220]
  004d4	8b 88 70 01 00
	00		 mov	 ecx, DWORD PTR [eax+368]
  004da	85 c9		 test	 ecx, ecx
  004dc	0f 85 d3 06 00
	00		 jne	 $L71574
  004e2	83 b8 6c 01 00
	00 01		 cmp	 DWORD PTR [eax+364], 1
  004e9	0f 84 c6 06 00
	00		 je	 $L71574

; 1300 : 			}              
; 1301 : #endif
; 1302 : 			new_ret.rule=rule_p;
; 1303 : 			par_match_rule(current_rule,BIN_END_OF_RULE,new_input,output_array,new_input_indexes,output_indexes,match_array,&new_ret,0);

  004ef	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR _match_array$[esp+216]
  004f6	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR _output_indexes$[esp+216]
  004fd	8b ac 24 e8 00
	00 00		 mov	 ebp, DWORD PTR _new_input$[esp+216]
  00504	8d 54 24 28	 lea	 edx, DWORD PTR _new_ret$[esp+220]
  00508	6a 00		 push	 0
  0050a	52		 push	 edx
  0050b	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR _new_input_indexes$[esp+224]
  00512	50		 push	 eax
  00513	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR _output_array$[esp+228]
  0051a	51		 push	 ecx
  0051b	52		 push	 edx
  0051c	50		 push	 eax
  0051d	55		 push	 ebp
  0051e	6a 00		 push	 0
  00520	57		 push	 edi
  00521	89 74 24 5c	 mov	 DWORD PTR _new_ret$[esp+272], esi
  00525	e8 00 00 00 00	 call	 _par_match_rule

; 1304 : 			
; 1305 : #ifndef PARSER_STANDALONE_DEBUG
; 1306 : 			/* checking cmd_flushing */
; 1307 : 			if (pKsd_t->text_flush || (pKsd_t->cmd_flush == CMD_flush_toss))

  0052a	8b 74 24 6c	 mov	 esi, DWORD PTR _pKsd_t$[esp+256]
  0052e	83 c4 24	 add	 esp, 36			; 00000024H
  00531	8b 86 70 01 00
	00		 mov	 eax, DWORD PTR [esi+368]
  00537	85 c0		 test	 eax, eax
  00539	0f 85 52 06 00
	00		 jne	 $L71514
  0053f	8b 8e 6c 01 00
	00		 mov	 ecx, DWORD PTR [esi+364]
  00545	b8 01 00 00 00	 mov	 eax, 1
  0054a	3b c8		 cmp	 ecx, eax
  0054c	0f 84 3f 06 00
	00		 je	 $L71514

; 1311 : 			}              
; 1312 : #endif
; 1313 : 			//printf("C parser_flag is %d\n",new_ret.parser_flag);
; 1314 :             /* GL 02/08/1997, set the parser_flag back to the caller */
; 1315 : 			ret_value->parser_flag = new_ret.parser_flag;

  00552	8b 94 24 14 01
	00 00		 mov	 edx, DWORD PTR _ret_value$[esp+216]
  00559	8b 4c 24 44	 mov	 ecx, DWORD PTR _new_ret$[esp+248]
  0055d	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 1316 : 			
; 1317 : 			/* 
; 1318 : 			* at this point in the matching, either a rule has hit and was processed or the 
; 1319 : 			* current word has to be copied to the output 
; 1320 : 			*/
; 1321 : 			if (new_ret.value == SUCCESS)

  00560	8b 4c 24 3c	 mov	 ecx, DWORD PTR _new_ret$[esp+240]
  00564	3b c8		 cmp	 ecx, eax
  00566	0f 85 f5 04 00
	00		 jne	 $L71577

; 1322 : 			{         
; 1323 : 				/*	check to be sure the matching left off at the end of a word */
; 1324 : 				temp=new_ret.input_pos+new_ret.input_offset;

  0056c	8b 44 24 28	 mov	 eax, DWORD PTR _new_ret$[esp+220]
  00570	8b 4c 24 2c	 mov	 ecx, DWORD PTR _new_ret$[esp+224]

; 1325 : 			//	temp1=parser_char_types[new_input[temp]];
; 1326 : 				if (!((new_input[temp]=='\0') ||
; 1327 : 				      ((parser_char_types[new_input[temp]] & (TYPE_white))!=0) ||
; 1328 : 				      (((parser_char_types[new_input[temp]] & (TYPE_clause))!=0) &&
; 1329 : 				       ((new_input[temp+1]=='\0') || 
; 1330 : 				        (parser_char_types[new_input[temp+1]] & (TYPE_white))!=0)) ||
; 1331 : 				      (((parser_char_types[output_array[new_ret.output_pos+new_ret.output_offset-1]] & (TYPE_white))!=0) &&
; 1332 : 					   /*((parser_char_types[new_input[temp]] & (TYPE_white))==0) && */ (do_not_copy_next_word=1))
; 1333 : 					 
; 1334 : 					 
; 1335 : 					 
; 1336 : 					 
; 1337 : 					 ))

  00574	8b 54 24 34	 mov	 edx, DWORD PTR _new_ret$[esp+232]
  00578	03 c8		 add	 ecx, eax
  0057a	8a 04 29	 mov	 al, BYTE PTR [ecx+ebp]
  0057d	84 c0		 test	 al, al
  0057f	74 53		 je	 SHORT $L71578
  00581	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00586	66 8b 04 45 00
	00 00 00	 mov	 ax, WORD PTR _parser_char_types[eax*2]
  0058e	a8 20		 test	 al, 32			; 00000020H
  00590	75 42		 jne	 SHORT $L71578
  00592	f6 c4 08	 test	 ah, 8
  00595	74 17		 je	 SHORT $L71579
  00597	8a 44 29 01	 mov	 al, BYTE PTR [ecx+ebp+1]
  0059b	84 c0		 test	 al, al
  0059d	74 35		 je	 SHORT $L71578
  0059f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005a4	f6 04 45 00 00
	00 00 20	 test	 BYTE PTR _parser_char_types[eax*2], 32 ; 00000020H
  005ac	75 26		 jne	 SHORT $L71578
$L71579:
  005ae	8b 44 24 30	 mov	 eax, DWORD PTR _new_ret$[esp+228]
  005b2	8b bc 24 ec 00
	00 00		 mov	 edi, DWORD PTR _output_array$[esp+216]
  005b9	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  005bc	33 c0		 xor	 eax, eax
  005be	8a 44 39 ff	 mov	 al, BYTE PTR [ecx+edi-1]
  005c2	f6 04 45 00 00
	00 00 20	 test	 BYTE PTR _parser_char_types[eax*2], 32 ; 00000020H
  005ca	74 5d		 je	 SHORT $L71580
  005cc	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR _do_not_copy_next_word$[esp+220], 1
$L71578:

; 1377 : 						{
; 1378 : 							current_rule_number=cur_rule_next_miss;
; 1379 : 							last_rule_was_hit= -1;				/* reset the last_rule_was_hit flag */
; 1380 : 						}
; 1381 : 						else
; 1382 : 						{
; 1383 : 							current_rule_number++;      		/* go to the next rule in the rule table */
; 1384 : 							last_rule_was_hit=0;				/* reset the last_rule_was_hit flag */
; 1385 : 						}
; 1386 : 					}
; 1387 : 					
; 1388 : 				} /* if (((new_input[new_ret.input_pos+new_ret.input_offset]!='\0') && */
; 1389 : 				else                      
; 1390 : 				{
; 1391 : 					/* here is where next hit rules have to be done */
; 1392 : 					/* 	
; 1393 : 					*	the amount of data that was writen o the output array if the difference 
; 1394 : 					*	between new_ret.output_offset and save_ret.output_offset
; 1395 : 					*	The amount of data read is the difference between new_ret.input_offset
; 1396 : 					*	and save_ret.input_offset
; 1397 : 					*/          
; 1398 : 					/*  
; 1399 : 					*	the data in the output starting at save_ret.output_offset has to be 
; 1400 : 					*	copied into new_input starting at save_ret.input_offset
; 1401 : 					*/ 
; 1402 : 					/*	if the output is larger than the input, move the input over output-input characters
; 1403 : 					*	if the output is the same size as the input, overwrite the input with the output
; 1404 : 					*	if the output is smaller than the input, place the output input-output 
; 1405 : 					*		characters to the right
; 1406 : 					*/
; 1407 : 					/* debug switch */
; 1408 : #ifndef PARSER_STANDALONE_DEBUG
; 1409 : 					if (DT_DBG(CMD_DBG,0x0010))

  005d4	66 8b 86 78 04
	00 00		 mov	 ax, WORD PTR [esi+1144]
  005db	f6 c4 80	 test	 ah, -128		; ffffff80H
  005de	74 1b		 je	 SHORT $L71589
  005e0	a8 10		 test	 al, 16			; 00000010H
  005e2	74 17		 je	 SHORT $L71589

; 1410 : 					{
; 1411 : 						printf("Rule hit:R%d\n",current_rule_R_value);

  005e4	8b 54 24 68	 mov	 edx, DWORD PTR _current_rule_R_value$[esp+220]
  005e8	52		 push	 edx
  005e9	68 00 00 00 00	 push	 OFFSET FLAT:$SG71590
  005ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  005f4	8b 54 24 3c	 mov	 edx, DWORD PTR _new_ret$[esp+240]
  005f8	83 c4 08	 add	 esp, 8
$L71589:

; 1412 : 					}
; 1413 : #endif
; 1414 : #ifdef DISPLAY_RULES_HIT
; 1415 : #ifdef PARSER_STANDALONE_DEBUG
; 1416 : #ifdef OUTPUT_HITS_NORMAL
; 1417 : 					fprintf(stderr,"H");
; 1418 : 					printf("the rule hit was R%d\n",current_rule_R_value);
; 1419 : 					printf("output array=%s\n",output_array);
; 1420 : #else
; 1421 : 					fprintf(stderr,"the rule hit was R%d\n",current_rule_R_value);
; 1422 : 					printf("output array=%s\n",output_array);
; 1423 : #endif
; 1424 : #else
; 1425 : 					printf("the rule hit was R%d\n",current_rule_R_value);
; 1426 : #endif
; 1427 : 
; 1428 : #endif
; 1429 : 					 
; 1430 : #if 0
; 1431 : 					if (((parser_char_types[output_array[new_ret.output_pos+new_ret.output_offset-1]] & (TYPE_white))!=0) &&
; 1432 : 					   ((temp1 & (TYPE_white))==0))
; 1433 : 					{
; 1434 : 						do_not_copy_next_word=1;
; 1435 : 					}
; 1436 : #endif
; 1437 : 					if (cur_rule_copy_hit!=-1)

  005fb	8b 4c 24 18	 mov	 ecx, DWORD PTR _cur_rule_copy_hit$[esp+220]
  005ff	83 c8 ff	 or	 eax, -1
  00602	3b c8		 cmp	 ecx, eax
  00604	0f 84 cc 00 00
	00		 je	 $L71591

; 1438 : 					{
; 1439 : 						last_rule_was_hit=1;
; 1440 : 						current_rule_number=cur_rule_copy_hit;

  0060a	8b d9		 mov	 ebx, ecx

; 1441 : 						par_copy_return_value(&save_ret,&new_ret);

  0060c	b9 08 00 00 00	 mov	 ecx, 8
  00611	8d 74 24 28	 lea	 esi, DWORD PTR _new_ret$[esp+220]
  00615	8d 7c 24 6c	 lea	 edi, DWORD PTR _save_ret$[esp+220]
  00619	bd 01 00 00 00	 mov	 ebp, 1
  0061e	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00622	f3 a5		 rep movsd

; 1442 : 					}
; 1443 : 					else

  00624	e9 a2 04 00 00	 jmp	 $L71618
$L71580:

; 1338 : 
; 1339 : 
; 1340 : 
; 1341 : /*				if (
; 1342 : 					(
; 1343 : 					 (new_input[new_ret.input_pos+new_ret.input_offset]!='\0') &&					
; 1344 : 					 !(
; 1345 : 					  ((parser_char_types[new_input[new_ret.input_pos+new_ret.input_offset]] & (TYPE_white))!=0)  ||
; 1346 : 					  (
; 1347 : 					   ((parser_char_types[new_input[new_ret.input_pos+new_ret.input_offset]] & (TYPE_clause))!=0) &&
; 1348 : 					   ( 
; 1349 : 					    (new_input[new_ret.input_pos+new_ret.input_offset+1]=='\0') ||
; 1350 : 					    ((parser_char_types[new_input[new_ret.input_pos+new_ret.input_offset+1]] & (TYPE_white))!=0) 
; 1351 : 					   )
; 1352 : 					  )
; 1353 : 					 )
; 1354 : 					) 
; 1355 : 				   )
; 1356 : */
; 1357 : 				{
; 1358 : 					par_copy_return_value(&new_ret,&save_ret);
; 1359 : 					if (cur_rule_next_go_miss!= -1)

  00629	8b 44 24 1c	 mov	 eax, DWORD PTR _cur_rule_next_go_miss$[esp+220]
  0062d	b9 08 00 00 00	 mov	 ecx, 8
  00632	8d 74 24 6c	 lea	 esi, DWORD PTR _save_ret$[esp+220]
  00636	8d 7c 24 28	 lea	 edi, DWORD PTR _new_ret$[esp+220]
  0063a	83 f8 ff	 cmp	 eax, -1
  0063d	f3 a5		 rep movsd
  0063f	74 7a		 je	 SHORT $L71582

; 1360 : 					{
; 1361 : 						if (cur_rule_next_miss!= -1)

  00641	8b 4c 24 20	 mov	 ecx, DWORD PTR _cur_rule_next_miss$[esp+220]
  00645	83 f9 ff	 cmp	 ecx, -1
  00648	74 2c		 je	 SHORT $L71583

; 1362 : 						{
; 1363 : 							par_set_return_level(return_rule,&return_level,cur_rule_next_miss);

  0064a	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  0064e	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00651	7d 1c		 jge	 SHORT $L72843

; 1369 : 							//return_rule[return_level++]=current_rule_number+1;
; 1370 : 						}
; 1371 : 						current_rule_number=cur_rule_next_go_miss;

  00653	8b 5c 24 1c	 mov	 ebx, DWORD PTR _cur_rule_next_go_miss$[esp+220]
  00657	89 8c 84 b4 00
	00 00		 mov	 DWORD PTR _return_rule$[esp+eax*4+220], ecx
  0065e	40		 inc	 eax
  0065f	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00663	89 44 24 10	 mov	 DWORD PTR _return_level$[esp+220], eax

; 1372 : 						last_rule_was_hit= -1;

  00667	83 cd ff	 or	 ebp, -1

; 1373 : 					}
; 1374 : 					else

  0066a	e9 5c 04 00 00	 jmp	 $L71618

; 1362 : 						{
; 1363 : 							par_set_return_level(return_rule,&return_level,cur_rule_next_miss);

$L72843:
  0066f	8b 4c 24 20	 mov	 ecx, DWORD PTR _cur_rule_next_miss$[esp+220]
  00673	51		 push	 ecx

; 1364 : 							//return_rule[return_level++]=next_miss_rule;
; 1365 : 						}
; 1366 : 						else

  00674	eb 27		 jmp	 SHORT $L72920
$L71583:

; 1367 : 						{
; 1368 : 							par_set_return_level(return_rule,&return_level,current_rule_number+1);

  00676	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  0067a	43		 inc	 ebx
  0067b	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0067e	7d 1c		 jge	 SHORT $L72885
$L72921:
  00680	89 9c 84 b4 00
	00 00		 mov	 DWORD PTR _return_rule$[esp+eax*4+220], ebx

; 1369 : 							//return_rule[return_level++]=current_rule_number+1;
; 1370 : 						}
; 1371 : 						current_rule_number=cur_rule_next_go_miss;

  00687	8b 5c 24 1c	 mov	 ebx, DWORD PTR _cur_rule_next_go_miss$[esp+220]
  0068b	40		 inc	 eax
  0068c	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00690	89 44 24 10	 mov	 DWORD PTR _return_level$[esp+220], eax

; 1372 : 						last_rule_was_hit= -1;

  00694	83 cd ff	 or	 ebp, -1

; 1373 : 					}
; 1374 : 					else

  00697	e9 2f 04 00 00	 jmp	 $L71618

; 1578 : 					{
; 1579 : 						par_set_return_level(return_rule,&return_level,current_rule_number+1);

$L72885:

; 1367 : 						{
; 1368 : 							par_set_return_level(return_rule,&return_level,current_rule_number+1);

  0069c	53		 push	 ebx
$L72920:
  0069d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@ ; `string'
  006a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf

; 1369 : 							//return_rule[return_level++]=current_rule_number+1;
; 1370 : 						}
; 1371 : 						current_rule_number=cur_rule_next_go_miss;

  006a8	8b 5c 24 24	 mov	 ebx, DWORD PTR _cur_rule_next_go_miss$[esp+228]
  006ac	83 c4 08	 add	 esp, 8
  006af	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx

; 1372 : 						last_rule_was_hit= -1;

  006b3	83 cd ff	 or	 ebp, -1

; 1373 : 					}
; 1374 : 					else

  006b6	e9 10 04 00 00	 jmp	 $L71618
$L71582:

; 1375 : 					{
; 1376 : 						if (cur_rule_next_miss!= -1)	/* this is also a miss */

  006bb	8b 44 24 20	 mov	 eax, DWORD PTR _cur_rule_next_miss$[esp+220]
  006bf	83 f8 ff	 cmp	 eax, -1
  006c2	0f 84 fc 03 00
	00		 je	 $L71586

; 1587 : 					{
; 1588 : 						current_rule_number=cur_rule_next_miss;

  006c8	8b d8		 mov	 ebx, eax
  006ca	83 cd ff	 or	 ebp, -1
  006cd	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  006d1	e9 f5 03 00 00	 jmp	 $L71618
$L71591:

; 1444 : 
; 1445 : 					if ((cur_rule_next_hit!= -1) || (cur_rule_next_go_hit!= -1))

  006d6	39 44 24 54	 cmp	 DWORD PTR _cur_rule_next_hit$[esp+220], eax
  006da	75 13		 jne	 SHORT $L71595
  006dc	39 44 24 58	 cmp	 DWORD PTR _cur_rule_next_go_hit$[esp+220], eax
  006e0	75 0d		 jne	 SHORT $L71595

; 1560 : 					} /* if ((current_rule->next_hit_rule!= -1) || (current_rule->next_goret_hit!= -1)) */
; 1561 : 					else
; 1562 : 					{
; 1563 : 						done=1;

  006e2	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR _done$[esp+220], 1

; 1564 : 						last_rule_was_hit=0;

  006ea	e9 da 03 00 00	 jmp	 $L72916
$L71595:

; 1446 : 					{
; 1447 : 						par_copy_return_value(&hit_ret,&new_ret);
; 1448 : 						input_size=new_ret.input_offset-save_ret.input_offset;

  006ef	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+224]

; 1449 : 						output_size=new_ret.output_offset-save_ret.output_offset;

  006f3	8b 5c 24 78	 mov	 ebx, DWORD PTR _save_ret$[esp+232]
  006f7	b9 08 00 00 00	 mov	 ecx, 8
  006fc	8d 74 24 28	 lea	 esi, DWORD PTR _new_ret$[esp+220]
  00700	8d bc 24 94 00
	00 00		 lea	 edi, DWORD PTR _hit_ret$[esp+220]
  00707	2b d3		 sub	 edx, ebx
  00709	f3 a5		 rep movsd
  0070b	8b 74 24 70	 mov	 esi, DWORD PTR _save_ret$[esp+224]
  0070f	2b c6		 sub	 eax, esi

; 1450 : 						if (output_size>input_size)

  00711	3b c2		 cmp	 eax, edx
  00713	0f 8d e8 01 00
	00		 jge	 $L72917

; 1451 : 						{
; 1452 : #ifdef DEBUG
; 1453 : 							printf("par_process_input;the output is larger than the input\n");
; 1454 : #endif
; 1455 : 							size_diff=output_size-input_size;

  00719	8b ea		 mov	 ebp, edx
  0071b	2b e8		 sub	 ebp, eax

; 1456 : 							/* should check for overrunning the new input array */
; 1457 : 							/* copy the input to its new location */
; 1458 : #ifdef NEW_DEBUG
; 1459 : 							par_print_rule_error("the input_array before moving, changing",new_input,new_ret.input_pos+new_ret.input_offset);
; 1460 : 							par_print_rule_error("the output_array before moving, changing",output_array,new_ret.output_pos+new_ret.output_offset);
; 1461 : #endif
; 1462 : 							
; 1463 : 							if (save_ret.input_offset > size_diff)

  0071d	8b c6		 mov	 eax, esi
  0071f	3b c5		 cmp	 eax, ebp
  00721	7e 75		 jle	 SHORT $L71598

; 1464 : 							{
; 1465 : 								memcpy(new_input+(save_ret.input_pos+save_ret.input_offset-size_diff),output_array+(save_ret.output_offset+save_ret.output_pos),output_size);

  00723	8b 44 24 74	 mov	 eax, DWORD PTR _save_ret$[esp+228]
  00727	8b ce		 mov	 ecx, esi
  00729	8b 74 24 6c	 mov	 esi, DWORD PTR _save_ret$[esp+220]
  0072d	2b cd		 sub	 ecx, ebp
  0072f	8b ac 24 e8 00
	00 00		 mov	 ebp, DWORD PTR _new_input$[esp+216]
  00736	89 4c 24 1c	 mov	 DWORD PTR -192+[esp+220], ecx
  0073a	8d 3c 31	 lea	 edi, DWORD PTR [ecx+esi]
  0073d	8b b4 24 ec 00
	00 00		 mov	 esi, DWORD PTR _output_array$[esp+216]
  00744	89 7c 24 18	 mov	 DWORD PTR -196+[esp+220], edi
  00748	8b ca		 mov	 ecx, edx
  0074a	03 fd		 add	 edi, ebp
  0074c	03 c3		 add	 eax, ebx
  0074e	8b e9		 mov	 ebp, ecx
  00750	03 f0		 add	 esi, eax
  00752	c1 e9 02	 shr	 ecx, 2
  00755	f3 a5		 rep movsd
  00757	8b cd		 mov	 ecx, ebp
  00759	83 e1 03	 and	 ecx, 3
  0075c	f3 a4		 rep movsb

; 1466 : 								/* copy the index data */
; 1467 : 								// MGS 04/05/2000 fixed problem with "this is com2" pronounced as "this is c om 2" with indexing
; 1468 : 								par_copy_index_list(new_input_indexes,(save_ret.input_pos+save_ret.input_offset-size_diff),output_indexes,(save_ret.output_offset+save_ret.output_pos),output_size);

  0075e	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  00761	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00764	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR _output_indexes$[esp+216]
  0076b	d1 e1		 shl	 ecx, 1
  0076d	8d 34 50	 lea	 esi, DWORD PTR [eax+edx*2]
  00770	8b 44 24 18	 mov	 eax, DWORD PTR -196+[esp+220]
  00774	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00777	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR _new_input_indexes$[esp+216]
  0077e	8d 3c 50	 lea	 edi, DWORD PTR [eax+edx*2]
  00781	8b d1		 mov	 edx, ecx
  00783	c1 e9 02	 shr	 ecx, 2
  00786	f3 a5		 rep movsd

; 1469 : 								/* hit_ret.input_offset+=size_diff; */
; 1470 : 								new_ret.input_offset=save_ret.input_offset-size_diff;

  00788	8b 44 24 1c	 mov	 eax, DWORD PTR -192+[esp+220]
  0078c	8b ca		 mov	 ecx, edx
  0078e	83 e1 03	 and	 ecx, 3
  00791	f3 a4		 rep movsb

; 1471 : 								new_ret.output_offset=save_ret.output_offset;
; 1472 : 								save_ret.input_offset-=size_diff;
; 1473 : 							}
; 1474 : 							else

  00793	e9 3a 02 00 00	 jmp	 $L72918
$L71598:

; 1475 : 							{
; 1476 : 								j=new_ret.input_offset+new_ret.input_pos;

  00798	8b 4c 24 2c	 mov	 ecx, DWORD PTR _new_ret$[esp+224]
  0079c	8b 44 24 28	 mov	 eax, DWORD PTR _new_ret$[esp+220]

; 1477 : 								for (i=strlen(new_input)+size_diff;i>j;i--)

  007a0	8b bc 24 e8 00
	00 00		 mov	 edi, DWORD PTR _new_input$[esp+216]
  007a7	03 c8		 add	 ecx, eax
  007a9	89 4c 24 20	 mov	 DWORD PTR _j$[esp+220], ecx
  007ad	83 c9 ff	 or	 ecx, -1
  007b0	33 c0		 xor	 eax, eax
  007b2	f2 ae		 repne scasb
  007b4	8b 44 24 20	 mov	 eax, DWORD PTR _j$[esp+220]
  007b8	f7 d1		 not	 ecx
  007ba	49		 dec	 ecx
  007bb	8b f1		 mov	 esi, ecx
  007bd	03 f5		 add	 esi, ebp
  007bf	3b f0		 cmp	 esi, eax
  007c1	0f 8e a6 00 00
	00		 jle	 $L71602
  007c7	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR _dict_hit_array$[esp+216]
  007ce	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR _new_input$[esp+216]
  007d5	8d 5c 6d 00	 lea	 ebx, DWORD PTR [ebp+ebp*2]
  007d9	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  007dc	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  007df	d1 e1		 shl	 ecx, 1
  007e1	d1 e3		 shl	 ebx, 1
  007e3	2b 84 24 f0 00
	00 00		 sub	 eax, DWORD PTR _dict_hit_array$[esp+216]
  007ea	89 7c 24 1c	 mov	 DWORD PTR -192+[esp+220], edi
  007ee	89 4c 24 18	 mov	 DWORD PTR -196+[esp+220], ecx
  007f2	89 9c 24 90 00
	00 00		 mov	 DWORD PTR -76+[esp+220], ebx
  007f9	89 44 24 64	 mov	 DWORD PTR -120+[esp+220], eax
  007fd	eb 07		 jmp	 SHORT $L71600
$L72907:
  007ff	8b 9c 24 90 00
	00 00		 mov	 ebx, DWORD PTR -76+[esp+220]
$L71600:

; 1478 : 								{
; 1479 : 									k=i-size_diff;

  00806	2b cb		 sub	 ecx, ebx

; 1480 : #ifdef DEBUG
; 1481 : 									printf("process_input;copying new_input[%d]%c(%0X)=new_input[%d]%c(%0X)\n",i,new_input[i],new_input[i],k,new_input[k],new_input[k]);
; 1482 : #endif
; 1483 : 									new_input[i]=new_input[k];

  00808	8b 5c 24 64	 mov	 ebx, DWORD PTR -120+[esp+220]
  0080c	8b c6		 mov	 eax, esi
  0080e	89 4c 24 4c	 mov	 DWORD PTR -144+[esp+220], ecx
  00812	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR _new_input$[esp+216]
  00819	2b c5		 sub	 eax, ebp
  0081b	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  0081e	88 0c 3b	 mov	 BYTE PTR [ebx+edi], cl

; 1484 : 									par_copy_index(new_input_indexes,i,new_input_indexes,k);

  00821	8b 7c 24 4c	 mov	 edi, DWORD PTR -144+[esp+220]
  00825	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR _new_input_indexes$[esp+216]
  0082c	8b 5c 24 18	 mov	 ebx, DWORD PTR -196+[esp+220]
  00830	03 f9		 add	 edi, ecx
  00832	03 d9		 add	 ebx, ecx
  00834	4e		 dec	 esi
  00835	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00837	89 0b		 mov	 DWORD PTR [ebx], ecx
  00839	66 8b 4f 04	 mov	 cx, WORD PTR [edi+4]

; 1485 : 									dict_hit_array[i]=dict_hit_array[k];

  0083d	8b 7c 24 1c	 mov	 edi, DWORD PTR -192+[esp+220]
  00841	66 89 4b 04	 mov	 WORD PTR [ebx+4], cx
  00845	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR _dict_hit_array$[esp+216]
  0084c	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  0084f	8b 4c 24 18	 mov	 ecx, DWORD PTR -196+[esp+220]
  00853	88 07		 mov	 BYTE PTR [edi], al
  00855	8b 44 24 20	 mov	 eax, DWORD PTR _j$[esp+220]
  00859	83 e9 06	 sub	 ecx, 6
  0085c	4f		 dec	 edi
  0085d	3b f0		 cmp	 esi, eax
  0085f	89 4c 24 18	 mov	 DWORD PTR -196+[esp+220], ecx
  00863	89 7c 24 1c	 mov	 DWORD PTR -192+[esp+220], edi
  00867	7f 96		 jg	 SHORT $L72907

; 1477 : 								for (i=strlen(new_input)+size_diff;i>j;i--)

  00869	8b 5c 24 78	 mov	 ebx, DWORD PTR _save_ret$[esp+232]
$L71602:

; 1486 : 									
; 1487 : 								}
; 1488 : 								new_input_diff+=size_diff;

  0086d	8b 4c 24 5c	 mov	 ecx, DWORD PTR _new_input_diff$[esp+220]

; 1489 : #ifdef DEBUG
; 1490 : 								par_print_rule_error("111 input",new_input,new_ret.input_pos+new_ret.input_offset);
; 1491 : 								par_print_rule_error("111 output",output_array,new_ret.output_pos+new_ret.output_offset);
; 1492 : #endif
; 1493 : 								/* copy the changed data */
; 1494 : 								memcpy(new_input+(save_ret.input_offset+save_ret.input_pos),output_array+(save_ret.output_offset+save_ret.output_pos),output_size);

  00871	8b 74 24 70	 mov	 esi, DWORD PTR _save_ret$[esp+224]
  00875	03 cd		 add	 ecx, ebp
  00877	89 4c 24 5c	 mov	 DWORD PTR _new_input_diff$[esp+220], ecx
  0087b	8b 4c 24 74	 mov	 ecx, DWORD PTR _save_ret$[esp+228]
  0087f	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  00882	8b 4c 24 6c	 mov	 ecx, DWORD PTR _save_ret$[esp+220]
  00886	89 44 24 4c	 mov	 DWORD PTR -144+[esp+220], eax
  0088a	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  0088d	8b b4 24 ec 00
	00 00		 mov	 esi, DWORD PTR _output_array$[esp+216]
  00894	03 f0		 add	 esi, eax
  00896	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR _new_input$[esp+216]
  0089d	89 7c 24 18	 mov	 DWORD PTR -196+[esp+220], edi
  008a1	8b ca		 mov	 ecx, edx
  008a3	03 f8		 add	 edi, eax
  008a5	8b c1		 mov	 eax, ecx
  008a7	c1 e9 02	 shr	 ecx, 2
  008aa	f3 a5		 rep movsd
  008ac	8b c8		 mov	 ecx, eax

; 1495 : 								/* copy the index data */
; 1496 : 								par_copy_index_list(new_input_indexes,(save_ret.input_offset+save_ret.input_pos),output_indexes,(save_ret.output_offset+save_ret.output_pos),output_size);

  008ae	8b 44 24 4c	 mov	 eax, DWORD PTR -144+[esp+220]
  008b2	83 e1 03	 and	 ecx, 3
  008b5	f3 a4		 rep movsb
  008b7	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  008ba	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  008bd	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR _output_indexes$[esp+216]
  008c4	d1 e1		 shl	 ecx, 1
  008c6	8d 34 50	 lea	 esi, DWORD PTR [eax+edx*2]
  008c9	8b 44 24 18	 mov	 eax, DWORD PTR -196+[esp+220]
  008cd	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  008d0	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR _new_input_indexes$[esp+216]
  008d7	8d 3c 50	 lea	 edi, DWORD PTR [eax+edx*2]
  008da	8b d1		 mov	 edx, ecx
  008dc	c1 e9 02	 shr	 ecx, 2
  008df	f3 a5		 rep movsd

; 1497 : 								hit_ret.input_offset+=size_diff;

  008e1	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR _hit_ret$[esp+224]
  008e8	8b ca		 mov	 ecx, edx
  008ea	83 e1 03	 and	 ecx, 3
  008ed	03 c5		 add	 eax, ebp
  008ef	89 84 24 98 00
	00 00		 mov	 DWORD PTR _hit_ret$[esp+224], eax

; 1498 : 								new_ret.input_offset=save_ret.input_offset;

  008f6	8b 44 24 70	 mov	 eax, DWORD PTR _save_ret$[esp+224]
  008fa	f3 a4		 rep movsb

; 1499 : 								new_ret.output_offset=save_ret.output_offset;
; 1500 : 							}
; 1501 : #ifdef DEBUG
; 1502 : 							par_print_rule_error("222 input",new_input,new_ret.input_pos+new_ret.input_offset);
; 1503 : 							par_print_rule_error("222 output",output_array,new_ret.output_pos+new_ret.output_offset);
; 1504 : #endif
; 1505 : #ifdef NEW_DEBUG
; 1506 : 							par_print_rule_error("the input_array after moving, changing",new_input,new_ret.input_pos+new_ret.input_offset);
; 1507 : 							par_print_rule_error("the output_array after moving, changing",output_array,new_ret.output_pos+new_ret.output_offset);
; 1508 : #endif
; 1509 : 						} /* if (output_size>input_size) */
; 1510 : 						else

  008fc	e9 d1 00 00 00	 jmp	 $L72918
$L72917:

; 1511 : 						{
; 1512 : 							if (input_size==output_size)

  00901	75 64		 jne	 SHORT $L71604

; 1513 : 							{
; 1514 : #ifdef DEBUG
; 1515 : 								printf("par_process_input;the output is the same size as the input\n");
; 1516 : #endif              
; 1517 : 								/* overwrite the input with the output */
; 1518 : 								memcpy(new_input+save_ret.input_offset+save_ret.input_pos,output_array+save_ret.output_offset+save_ret.output_pos,input_size);

  00903	8b 4c 24 74	 mov	 ecx, DWORD PTR _save_ret$[esp+228]
  00907	8d 14 0b	 lea	 edx, DWORD PTR [ebx+ecx]
  0090a	8b 4c 24 6c	 mov	 ecx, DWORD PTR _save_ret$[esp+220]
  0090e	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  00911	8b b4 24 ec 00
	00 00		 mov	 esi, DWORD PTR _output_array$[esp+216]
  00918	89 7c 24 18	 mov	 DWORD PTR -196+[esp+220], edi
  0091c	8b c8		 mov	 ecx, eax
  0091e	03 fd		 add	 edi, ebp
  00920	8b e9		 mov	 ebp, ecx
  00922	03 f2		 add	 esi, edx

; 1519 : 								/* overwrite the index data with the output index data */
; 1520 : 								par_copy_index_list(new_input_indexes,save_ret.input_offset+save_ret.input_pos,output_indexes,save_ret.output_offset+save_ret.output_pos,input_size);

  00924	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  00927	c1 e9 02	 shr	 ecx, 2
  0092a	f3 a5		 rep movsd
  0092c	8b cd		 mov	 ecx, ebp
  0092e	83 e1 03	 and	 ecx, 3
  00931	f3 a4		 rep movsb
  00933	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00936	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR _output_indexes$[esp+216]
  0093d	d1 e1		 shl	 ecx, 1
  0093f	8d 34 50	 lea	 esi, DWORD PTR [eax+edx*2]
  00942	8b 44 24 18	 mov	 eax, DWORD PTR -196+[esp+220]
  00946	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00949	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR _new_input_indexes$[esp+216]
  00950	8d 3c 50	 lea	 edi, DWORD PTR [eax+edx*2]
  00953	8b d1		 mov	 edx, ecx
  00955	c1 e9 02	 shr	 ecx, 2
  00958	f3 a5		 rep movsd

; 1521 : 								new_ret.input_offset=save_ret.input_offset;

  0095a	8b 44 24 70	 mov	 eax, DWORD PTR _save_ret$[esp+224]
  0095e	8b ca		 mov	 ecx, edx
  00960	83 e1 03	 and	 ecx, 3
  00963	f3 a4		 rep movsb

; 1522 : 								new_ret.output_offset=save_ret.output_offset;
; 1523 : 							} /* if (input_size==output_size) */
; 1524 : 							else

  00965	eb 6b		 jmp	 SHORT $L72918
$L71604:

; 1525 : 							{
; 1526 : #ifdef DEBUG
; 1527 : 								printf("par_process_input;the output is smaller than the input\n");
; 1528 : #endif                                   
; 1529 : 								/* 
; 1530 : 								* place the output in the input array so the end of the output
; 1531 : 								* matches up with the end of the input that was just processed 
; 1532 : 								*/
; 1533 : 								size_diff=input_size-output_size;

  00967	2b c2		 sub	 eax, edx
  00969	8b c8		 mov	 ecx, eax

; 1534 : 								/* copy the output to the proper place in the input */
; 1535 : 								memcpy(new_input+save_ret.input_offset+save_ret.input_pos+size_diff,output_array+save_ret.output_offset+save_ret.output_pos,output_size);

  0096b	8b 44 24 74	 mov	 eax, DWORD PTR _save_ret$[esp+228]
  0096f	03 ce		 add	 ecx, esi
  00971	8b 74 24 6c	 mov	 esi, DWORD PTR _save_ret$[esp+220]
  00975	89 4c 24 64	 mov	 DWORD PTR -120+[esp+220], ecx
  00979	03 c3		 add	 eax, ebx
  0097b	8d 3c 31	 lea	 edi, DWORD PTR [ecx+esi]
  0097e	8b b4 24 ec 00
	00 00		 mov	 esi, DWORD PTR _output_array$[esp+216]
  00985	89 7c 24 4c	 mov	 DWORD PTR -144+[esp+220], edi
  00989	8b ca		 mov	 ecx, edx
  0098b	03 fd		 add	 edi, ebp
  0098d	8b e9		 mov	 ebp, ecx
  0098f	03 f0		 add	 esi, eax
  00991	c1 e9 02	 shr	 ecx, 2
  00994	f3 a5		 rep movsd
  00996	8b cd		 mov	 ecx, ebp
  00998	83 e1 03	 and	 ecx, 3
  0099b	f3 a4		 rep movsb

; 1536 : 								/* copy the indexes into their new home */
; 1537 : 								par_copy_index_list(new_input_indexes,save_ret.input_offset+save_ret.input_pos+size_diff,output_indexes,save_ret.output_offset+save_ret.output_pos,output_size);

  0099d	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  009a0	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  009a3	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR _output_indexes$[esp+216]
  009aa	d1 e1		 shl	 ecx, 1
  009ac	8d 34 50	 lea	 esi, DWORD PTR [eax+edx*2]
  009af	8b 44 24 4c	 mov	 eax, DWORD PTR -144+[esp+220]
  009b3	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  009b6	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR _new_input_indexes$[esp+216]
  009bd	8d 3c 50	 lea	 edi, DWORD PTR [eax+edx*2]
  009c0	8b d1		 mov	 edx, ecx
  009c2	c1 e9 02	 shr	 ecx, 2
  009c5	f3 a5		 rep movsd

; 1538 : 								new_ret.input_offset=save_ret.input_offset+size_diff;

  009c7	8b 44 24 64	 mov	 eax, DWORD PTR -120+[esp+220]
  009cb	8b ca		 mov	 ecx, edx
  009cd	83 e1 03	 and	 ecx, 3
  009d0	f3 a4		 rep movsb
$L72918:

; 1539 : 								new_ret.output_offset=save_ret.output_offset;

  009d2	89 5c 24 34	 mov	 DWORD PTR _new_ret$[esp+232], ebx

; 1540 : 							} /* if (input_size==output_size) */
; 1541 : 						} /* if (output_size>input_size) */
; 1542 : 						if (cur_rule_next_go_hit!= -1)

  009d6	8b 5c 24 58	 mov	 ebx, DWORD PTR _cur_rule_next_go_hit$[esp+220]
  009da	83 fb ff	 cmp	 ebx, -1
  009dd	89 44 24 2c	 mov	 DWORD PTR _new_ret$[esp+224], eax
  009e1	74 60		 je	 SHORT $L71606

; 1543 : 						{
; 1544 : 							if (cur_rule_next_hit!= -1)

  009e3	8b 4c 24 54	 mov	 ecx, DWORD PTR _cur_rule_next_hit$[esp+220]
  009e7	83 f9 ff	 cmp	 ecx, -1
  009ea	74 28		 je	 SHORT $L71607

; 1545 : 							{
; 1546 : 								par_set_return_level(return_rule,&return_level,cur_rule_next_hit);

  009ec	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  009f0	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  009f3	7d 0e		 jge	 SHORT $L72869
  009f5	89 8c 84 b4 00
	00 00		 mov	 DWORD PTR _return_rule$[esp+eax*4+220], ecx
  009fc	40		 inc	 eax
  009fd	89 44 24 10	 mov	 DWORD PTR _return_level$[esp+220], eax
  00a01	eb 44		 jmp	 SHORT $L72875
$L72869:
  00a03	51		 push	 ecx

; 1547 : 							}
; 1548 : 							else
; 1549 : 							{
; 1550 : 								par_set_return_level(return_rule,&return_level,current_rule_number+1);

  00a04	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@ ; `string'
  00a09	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00a0f	83 c4 08	 add	 esp, 8

; 1551 : 							}
; 1552 : 							current_rule_number=cur_rule_next_go_hit;
; 1553 : 						}
; 1554 : 						else

  00a12	eb 33		 jmp	 SHORT $L72875
$L71607:

; 1547 : 							}
; 1548 : 							else
; 1549 : 							{
; 1550 : 								par_set_return_level(return_rule,&return_level,current_rule_number+1);

  00a14	8b 4c 24 14	 mov	 ecx, DWORD PTR _current_rule_number$[esp+220]
  00a18	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00a1b	8b 4c 24 10	 mov	 ecx, DWORD PTR _return_level$[esp+220]
  00a1f	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00a22	7d 0e		 jge	 SHORT $L72874
  00a24	89 84 8c b4 00
	00 00		 mov	 DWORD PTR _return_rule$[esp+ecx*4+220], eax
  00a2b	41		 inc	 ecx
  00a2c	89 4c 24 10	 mov	 DWORD PTR _return_level$[esp+220], ecx
  00a30	eb 15		 jmp	 SHORT $L72875
$L72874:
  00a32	50		 push	 eax
  00a33	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EB@PJJM@par_set_return_level?$DLtoo?5many?5le@ ; `string'
  00a38	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00a3e	83 c4 08	 add	 esp, 8

; 1551 : 							}
; 1552 : 							current_rule_number=cur_rule_next_go_hit;
; 1553 : 						}
; 1554 : 						else

  00a41	eb 04		 jmp	 SHORT $L72875
$L71606:

; 1555 : 						{						
; 1556 : 							current_rule_number=cur_rule_next_hit;         

  00a43	8b 5c 24 54	 mov	 ebx, DWORD PTR _cur_rule_next_hit$[esp+220]

; 1547 : 							}
; 1548 : 							else
; 1549 : 							{
; 1550 : 								par_set_return_level(return_rule,&return_level,current_rule_number+1);

$L72875:

; 1557 : 						}
; 1558 : 						par_copy_return_value(&save_ret,&new_ret);

  00a47	b9 08 00 00 00	 mov	 ecx, 8
  00a4c	8d 74 24 28	 lea	 esi, DWORD PTR _new_ret$[esp+220]
  00a50	8d 7c 24 6c	 lea	 edi, DWORD PTR _save_ret$[esp+220]
  00a54	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00a58	f3 a5		 rep movsd

; 1559 : 						last_rule_was_hit=1;

  00a5a	bd 01 00 00 00	 mov	 ebp, 1

; 1565 : 					} /* if ((current_rule->next_hit_rule!= -1) || (current_rule->next_goret_hit!= -1)) */
; 1566 : 				} /* if (((new_input[new_ret.input_pos+new_ret.input_offset]!='\0') && */
; 1567 : 			} /* if (new_ret.value == SUCCESS) */
; 1568 : 			else                  

  00a5f	eb 6a		 jmp	 SHORT $L71618
$L71577:

; 1569 : 			{
; 1570 : 				/* next miss rules are done here */
; 1571 : 				if (cur_rule_next_go_miss!= -1)

  00a61	83 7c 24 1c ff	 cmp	 DWORD PTR _cur_rule_next_go_miss$[esp+220], -1
  00a66	74 48		 je	 SHORT $L71613

; 1572 : 				{
; 1573 : 					if (cur_rule_next_miss!= -1)

  00a68	8b 4c 24 20	 mov	 ecx, DWORD PTR _cur_rule_next_miss$[esp+220]
  00a6c	83 f9 ff	 cmp	 ecx, -1
  00a6f	74 2c		 je	 SHORT $L71614

; 1574 : 					{
; 1575 : 						par_set_return_level(return_rule,&return_level,cur_rule_next_miss);

  00a71	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  00a75	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00a78	7d 19		 jge	 SHORT $L72880
  00a7a	8b 5c 24 1c	 mov	 ebx, DWORD PTR _cur_rule_next_go_miss$[esp+220]
  00a7e	89 8c 84 b4 00
	00 00		 mov	 DWORD PTR _return_rule$[esp+eax*4+220], ecx
  00a85	40		 inc	 eax
  00a86	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00a8a	89 44 24 10	 mov	 DWORD PTR _return_level$[esp+220], eax
  00a8e	83 cd ff	 or	 ebp, -1
  00a91	eb 38		 jmp	 SHORT $L71618
$L72880:
  00a93	8b 54 24 20	 mov	 edx, DWORD PTR _cur_rule_next_miss$[esp+220]
  00a97	52		 push	 edx

; 1576 : 					}
; 1577 : 					else

  00a98	e9 00 fc ff ff	 jmp	 $L72920
$L71614:

; 1578 : 					{
; 1579 : 						par_set_return_level(return_rule,&return_level,current_rule_number+1);

  00a9d	8b 44 24 10	 mov	 eax, DWORD PTR _return_level$[esp+220]
  00aa1	43		 inc	 ebx
  00aa2	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00aa5	0f 8d f1 fb ff
	ff		 jge	 $L72885

; 1580 : 					}
; 1581 : 					current_rule_number=cur_rule_next_go_miss;
; 1582 : 					last_rule_was_hit= -1;
; 1583 : 				}
; 1584 : 				else

  00aab	e9 d0 fb ff ff	 jmp	 $L72921
$L71613:

; 1585 : 				{
; 1586 : 					if (cur_rule_next_miss!= -1)	/* this is also a miss */

  00ab0	8b 44 24 20	 mov	 eax, DWORD PTR _cur_rule_next_miss$[esp+220]
  00ab4	83 f8 ff	 cmp	 eax, -1
  00ab7	74 0b		 je	 SHORT $L71586

; 1587 : 					{
; 1588 : 						current_rule_number=cur_rule_next_miss;

  00ab9	8b d8		 mov	 ebx, eax
  00abb	83 cd ff	 or	 ebp, -1
  00abe	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
  00ac2	eb 07		 jmp	 SHORT $L71618
$L71586:

; 1589 : 						last_rule_was_hit= -1;				/* reset the last_rule_was_hit flag */
; 1590 : 					}
; 1591 : 					else
; 1592 : 					{
; 1593 : 						current_rule_number++;      		/* go to the next rule in the rule table */

  00ac4	43		 inc	 ebx
  00ac5	89 5c 24 14	 mov	 DWORD PTR _current_rule_number$[esp+220], ebx
$L72916:

; 1594 : 						last_rule_was_hit=0;				/* reset the last_rule_was_hit flag */

  00ac9	33 ed		 xor	 ebp, ebp
$L71618:

; 1595 : 					}
; 1596 : 				}
; 1597 : 			} /* if (new_ret.value == SUCCESS) */
; 1598 : 			  /*
; 1599 : 			  * the processing has tried all the rules and either the
; 1600 : 			  * last rule has hit or none of them hit 
; 1601 : 			*/
; 1602 : 			if ((current_rule_number>=num_rules) || (current_rule_number<0))

  00acb	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR _num_rules
  00ad1	7d 3f		 jge	 SHORT $L71527
  00ad3	85 db		 test	 ebx, ebx
  00ad5	7c 3b		 jl	 SHORT $L71527
  00ad7	8b 44 24 24	 mov	 eax, DWORD PTR _done$[esp+220]
  00adb	85 c0		 test	 eax, eax
  00add	75 33		 jne	 SHORT $L71527

; 1051 : 		}  	               
; 1052 : 		par_copy_return_value(&save_ret,&new_ret);	/* save the values if the matching ends on a non white */
; 1053 : 		current_rule=NULL;                     
; 1054 : 		current_rule_number=rule_sections[rule];
; 1055 : 		last_rule_was_hit=0;
; 1056 : #ifdef DEBUG
; 1057 : 		par_print_rule_error("par_process_input;1 the input is",new_input,new_ret.input_pos+new_ret.input_offset);
; 1058 : 		par_print_rule_error("par_process_input;1 the output is",output_array,new_ret.output_pos+new_ret.output_offset);
; 1059 : #endif
; 1060 : 		while (!done)

  00adf	e9 a5 f7 ff ff	 jmp	 $L71520
$L71530:

; 1090 : 				case BIN_STOP:
; 1091 : 					done=1;
; 1092 : 					/* 
; 1093 : 					* potential bug if the matching is down a return level and 
; 1094 : 					* encounters a stop, the return level is left in place and could start
; 1095 : 					* to overwrite memory 
; 1096 : 					*/
; 1097 : 					return_level=0;
; 1098 : 					if (last_rule_was_hit>0)

  00ae4	85 ed		 test	 ebp, ebp
  00ae6	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _return_level$[esp+220], 0
  00aee	7e 22		 jle	 SHORT $L71527

; 1099 : 					{
; 1100 : 						//new_ret.output_offset=hit_ret.output_offset;
; 1101 : 						par_copy_return_value(&new_ret,&hit_ret);

  00af0	b9 08 00 00 00	 mov	 ecx, 8
  00af5	8d b4 24 94 00
	00 00		 lea	 esi, DWORD PTR _hit_ret$[esp+220]
  00afc	8d 7c 24 28	 lea	 edi, DWORD PTR _new_ret$[esp+220]
  00b00	f3 a5		 rep movsd

; 1102 : 					}
; 1103 : 					continue;          

  00b02	eb 0e		 jmp	 SHORT $L71527
$L72892:

; 1117 : 				default:
; 1118 : 					printf("special rule value is out of range\n");

  00b04	68 00 00 00 00	 push	 OFFSET FLAT:$SG71537
  00b09	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00b0f	83 c4 04	 add	 esp, 4
$L71527:

; 1603 : 				done=1;         
; 1604 : #ifdef DEBUG
; 1605 : 			printf("process_input done = %d\n",done);
; 1606 : #endif
; 1607 : 			
; 1608 : 		}	/* while (!done) */
; 1609 : 		/* copy the word to the output */
; 1610 : 		/* this copies the data from the current position in the input until it hits a whitespace */
; 1611 : 		/* -1 signals that the end of the input string has been reached */
; 1612 : 		/* should check for overrunning the output array */
; 1613 : 		if (do_not_copy_next_word==1)

  00b12	83 7c 24 60 01	 cmp	 DWORD PTR _do_not_copy_next_word$[esp+220], 1
  00b17	75 28		 jne	 SHORT $L71621

; 1614 : 		{
; 1615 : 			do_not_copy_next_word=0;
; 1616 : 			done=0;
; 1617 : 		}
; 1618 : 		else

  00b19	8b 9c 24 14 01
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+216]
  00b20	8b b4 24 e8 00
	00 00		 mov	 esi, DWORD PTR _new_input$[esp+216]
  00b27	33 c0		 xor	 eax, eax
  00b29	bf 01 00 00 00	 mov	 edi, 1
  00b2e	89 44 24 60	 mov	 DWORD PTR _do_not_copy_next_word$[esp+220], eax
  00b32	89 44 24 24	 mov	 DWORD PTR _done$[esp+220], eax
  00b36	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+224]
  00b3a	33 ed		 xor	 ebp, ebp
  00b3c	e9 94 f6 ff ff	 jmp	 $L71509
$L71621:

; 1619 : 		{
; 1620 : 			if (par_copy_word_to_output(new_input,output_array,new_input_indexes,output_indexes,&new_ret)== -1)

  00b41	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR _output_indexes$[esp+216]
  00b48	8b 94 24 f8 00
	00 00		 mov	 edx, DWORD PTR _new_input_indexes$[esp+216]
  00b4f	8b b4 24 e8 00
	00 00		 mov	 esi, DWORD PTR _new_input$[esp+216]
  00b56	8d 44 24 28	 lea	 eax, DWORD PTR _new_ret$[esp+220]
  00b5a	50		 push	 eax
  00b5b	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR _output_array$[esp+220]
  00b62	51		 push	 ecx
  00b63	52		 push	 edx
  00b64	50		 push	 eax
  00b65	56		 push	 esi
  00b66	e8 00 00 00 00	 call	 _par_copy_word_to_output

; 1621 : 			{
; 1622 : 				done=1;
; 1623 : 			}
; 1624 : 			else
; 1625 : 			{
; 1626 : 				done=0;
; 1627 : 			}
; 1628 : 		}
; 1629 : 		
; 1630 : 	}	/* while (new_input[]!='\0') */

  00b6b	8b 9c 24 28 01
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+236]
  00b72	83 c4 14	 add	 esp, 20			; 00000014H
  00b75	33 c9		 xor	 ecx, ecx
  00b77	83 f8 ff	 cmp	 eax, -1
  00b7a	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+224]
  00b7e	bf 01 00 00 00	 mov	 edi, 1
  00b83	0f 94 c1	 sete	 cl
  00b86	89 4c 24 24	 mov	 DWORD PTR _done$[esp+220], ecx
  00b8a	33 ed		 xor	 ebp, ebp
  00b8c	e9 44 f6 ff ff	 jmp	 $L71509
$L71514:

; 1308 : 			{
; 1309 : 				cm_util_flush_init(phTTS);

  00b91	8b 94 24 e0 00
	00 00		 mov	 edx, DWORD PTR _phTTS$[esp+216]
  00b98	52		 push	 edx
  00b99	e8 00 00 00 00	 call	 _cm_util_flush_init

; 1310 : 				return(&pCmd_t->ret_value);

  00b9e	8b 44 24 54	 mov	 eax, DWORD PTR _pCmd_t$[esp+224]
  00ba2	83 c4 04	 add	 esp, 4
  00ba5	05 68 57 00 00	 add	 eax, 22376		; 00005768H
  00baa	5f		 pop	 edi
  00bab	5e		 pop	 esi
  00bac	5d		 pop	 ebp
  00bad	5b		 pop	 ebx

; 1639 : }                       

  00bae	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00bb4	c3		 ret	 0
$L71574:

; 1297 : 			{
; 1298 : 				cm_util_flush_init(phTTS);

  00bb5	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR _phTTS$[esp+216]
  00bbc	51		 push	 ecx
  00bbd	e8 00 00 00 00	 call	 _cm_util_flush_init

; 1299 : 				return(&pCmd_t->ret_value);

  00bc2	8b 54 24 54	 mov	 edx, DWORD PTR _pCmd_t$[esp+224]
  00bc6	83 c4 04	 add	 esp, 4
  00bc9	5f		 pop	 edi
  00bca	5e		 pop	 esi
  00bcb	5d		 pop	 ebp
  00bcc	8d 82 68 57 00
	00		 lea	 eax, DWORD PTR [edx+22376]
  00bd2	5b		 pop	 ebx

; 1639 : }                       

  00bd3	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00bd9	c3		 ret	 0
$L71523:

; 1065 : 			{
; 1066 : 				cm_util_flush_init(phTTS);

  00bda	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR _phTTS$[esp+216]
  00be1	50		 push	 eax
  00be2	e8 00 00 00 00	 call	 _cm_util_flush_init

; 1067 : 				return(&pCmd_t->ret_value);

  00be7	8b 4c 24 54	 mov	 ecx, DWORD PTR _pCmd_t$[esp+224]
  00beb	83 c4 04	 add	 esp, 4
  00bee	5f		 pop	 edi
  00bef	5e		 pop	 esi
  00bf0	5d		 pop	 ebp
  00bf1	8d 81 68 57 00
	00		 lea	 eax, DWORD PTR [ecx+22376]
  00bf7	5b		 pop	 ebx

; 1639 : }                       

  00bf8	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00bfe	c3		 ret	 0
$L71510:

; 1631 : 	output_array[new_ret.output_pos+new_ret.output_offset]='\0';

  00bff	8b 4c 24 30	 mov	 ecx, DWORD PTR _new_ret$[esp+228]
  00c03	8b 44 24 34	 mov	 eax, DWORD PTR _new_ret$[esp+232]
  00c07	03 c1		 add	 eax, ecx
  00c09	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR _output_array$[esp+216]
  00c10	5f		 pop	 edi
  00c11	5e		 pop	 esi
  00c12	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1632 : 	
; 1633 : 	ret_value->input_offset=new_ret.input_offset-new_input_diff;	 /* the offsets are the change from the current pos */

  00c16	8b 44 24 24	 mov	 eax, DWORD PTR _new_ret$[esp+216]

; 1634 : 	ret_value->output_offset=new_ret.output_offset; /* so add the values to the callers offsets */

  00c1a	8b 4c 24 2c	 mov	 ecx, DWORD PTR _new_ret$[esp+224]
  00c1e	2b c2		 sub	 eax, edx
  00c20	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00c23	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx

; 1635 : #ifdef DEBUG
; 1636 : 	printf("leaving par_process_input\n");
; 1637 : #endif
; 1638 : 	return(ret_value);

  00c26	8b c3		 mov	 eax, ebx
  00c28	5d		 pop	 ebp
  00c29	5b		 pop	 ebx

; 1639 : }                       

  00c2a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00c30	c3		 ret	 0
_par_process_input ENDP
_TEXT	ENDS
PUBLIC	_par_print_rule_error
PUBLIC	_par_copy_string_data
PUBLIC	_par_match_string
_DATA	SEGMENT
	ORG $+2
$SG71756 DB	'par_match_rule;end of state slash not found', 00H
_DATA	ENDS
_TEXT	SEGMENT
_output_array$ = 20
_input_indexes$ = 24
_output_indexes$ = 28
_match_array$ = 32
_ret_value$ = 36
_dict_state_flag$ = 40
_new_ret$ = -32
_save_state_num$ = -60
_range_value$ = -48
_in_rule_index$ = 36
_length_of_input$ = -56
_insert_operation_flags$ = -52
_end_of_match$ = -64
_current_rule$ = 8
_state$ = 12
_input_array$ = 16
_par_match_rule PROC NEAR

; 1915 : {

  00c40	83 ec 40	 sub	 esp, 64			; 00000040H
  00c43	53		 push	 ebx

; 1916 : 	
; 1917 : 	//	int end_marker=End_Is_Slash;			/* used to store the end of state marker for comparison */
; 1918 : 	return_value_t	new_ret;				/* the return_value data */
; 1919 : 	int new_operation=BIN_END_OF_RULE;		/* the current_operation */
; 1920 : 	int num_chars_matched=0; 				/* the number of characters matched by par_match_string */
; 1921 : 	int save_state_num=0;					/* the number of the array to save the matching result into or
; 1922 : 											 * the dictionary number */
; 1923 : 	range_value_t range_value = {0,0,0,0};	/* 
; 1924 : 											*	a structure to store the minimum and maximum values of 
; 1925 : 											* 	a digit range find 
; 1926 : 											*/
; 1927 : 	U8 *new_rule;
; 1928 : 	int in_rule_index;
; 1929 : 	int next_rule_number,rule_p,length=0;
; 1930 : 	int length_of_input;
; 1931 : 	int temp;
; 1932 : #ifdef GERMAN_COMPOUND_NOUNS
; 1933 : 	int insert_operation_flags;
; 1934 : #endif
; 1935 : 	U8 end_of_match;
; 1936 : //	U8 end_of_action;
; 1937 : //	U8 end_of_hit;
; 1938 : 											
; 1939 : #ifdef DEBUG
; 1940 : 	printf("entering par_match_rule state=%d\n",state);
; 1941 : #endif
; 1942 : #ifdef SANITY_CHECKING
; 1943 : 	/* check the inputs or bail out at this point */                                      
; 1944 : 	if (ret_value==NULL) /* there was no input structure,  bail and return NULL */
; 1945 : 	{
; 1946 : #ifdef DEBUG
; 1947 : 		printf("leaving par_match_rule ret_value is NULL\n");
; 1948 : #endif
; 1949 : 		return;
; 1950 : 	}	
; 1951 : 	if (current_rule==NULL || input_array==NULL || output_array==NULL || match_array==NULL)
; 1952 : 	{	/* return a failed value */
; 1953 : 		ret_value->value=FATAL_FAIL;
; 1954 : #ifdef DEBUG
; 1955 : 		printf("leaving par_match_rule some input is NULL returning FAIL\n");
; 1956 : #endif
; 1957 : 		return;
; 1958 : 	}
; 1959 : #endif
; 1960 : 	length_of_input=strlen(input_array);

  00c44	8b 5c 24 50	 mov	 ebx, DWORD PTR _input_array$[esp+64]
  00c48	55		 push	 ebp
  00c49	56		 push	 esi
  00c4a	57		 push	 edi
  00c4b	8b fb		 mov	 edi, ebx
  00c4d	83 c9 ff	 or	 ecx, -1
  00c50	33 c0		 xor	 eax, eax
  00c52	33 ed		 xor	 ebp, ebp

; 1961 : 
; 1962 : 	/* update the state information and pointer to ret_value for par_look_ahead */                   
; 1963 : 	new_ret.input_pos=ret_value->input_pos+ret_value->input_offset;	

  00c54	8b 74 24 70	 mov	 esi, DWORD PTR _ret_value$[esp+76]
  00c58	f2 ae		 repne scasb
  00c5a	8b 06		 mov	 eax, DWORD PTR [esi]

; 1964 : 	new_ret.input_offset=0;
; 1965 : 	new_ret.output_pos=ret_value->output_pos+ret_value->output_offset;

  00c5c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00c5f	f7 d1		 not	 ecx
  00c61	49		 dec	 ecx

; 1966 : 	new_ret.output_offset=0;
; 1967 : 	new_ret.value=SUCCESS;
; 1968 : 	/* GL 02/08/1997 set the initial parser_flag */
; 1969 : 	new_ret.parser_flag = ret_value->parser_flag;   
; 1970 : #ifdef NEW_PARSER_FILE_LOADING
; 1971 : 	new_ret.phTTS=ret_value->phTTS;
; 1972 : #endif
; 1973 : 
; 1974 : 	/* 
; 1975 : 	*	NULL_STATE is used for the first call to the par_match_rule function to 
; 1976 : 	*	tell it to go into COPY_STATE and that the end of state marker is a NULL 
; 1977 : 	*/
; 1978 : 	new_ret.rule=in_rule_index=ret_value->rule;
; 1979 : 	if (state==BIN_END_OF_RULE) 	

  00c62	8b 7c 24 58	 mov	 edi, DWORD PTR _state$[esp+76]
  00c66	89 4c 24 18	 mov	 DWORD PTR _length_of_input$[esp+80], ecx
  00c6a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00c6d	03 c1		 add	 eax, ecx
  00c6f	b9 01 00 00 00	 mov	 ecx, 1
  00c74	89 44 24 30	 mov	 DWORD PTR _new_ret$[esp+80], eax
  00c78	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00c7b	03 d0		 add	 edx, eax
  00c7d	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00c80	89 44 24 4c	 mov	 DWORD PTR _new_ret$[esp+108], eax
  00c84	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00c87	85 ff		 test	 edi, edi
  00c89	89 6c 24 14	 mov	 DWORD PTR _save_state_num$[esp+80], ebp
  00c8d	89 6c 24 20	 mov	 DWORD PTR _range_value$[esp+80], ebp
  00c91	89 6c 24 24	 mov	 DWORD PTR _range_value$[esp+84], ebp
  00c95	89 6c 24 28	 mov	 DWORD PTR _range_value$[esp+88], ebp
  00c99	89 6c 24 2c	 mov	 DWORD PTR _range_value$[esp+92], ebp
  00c9d	89 6c 24 34	 mov	 DWORD PTR _new_ret$[esp+84], ebp
  00ca1	89 54 24 38	 mov	 DWORD PTR _new_ret$[esp+88], edx
  00ca5	89 6c 24 3c	 mov	 DWORD PTR _new_ret$[esp+92], ebp
  00ca9	89 4c 24 44	 mov	 DWORD PTR _new_ret$[esp+100], ecx
  00cad	89 44 24 70	 mov	 DWORD PTR _in_rule_index$[esp+76], eax
  00cb1	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
  00cb5	75 31		 jne	 SHORT $L71707

; 1980 : 	{
; 1981 : 		//		state=BIN_COPY;
; 1982 : 		end_of_match=255;

  00cb7	c6 44 24 10 ff	 mov	 BYTE PTR _end_of_match$[esp+80], 255 ; 000000ffH
$L71708:

; 1994 : 	{
; 1995 : 		new_ret.optional=ret_value->optional;

  00cbc	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]

; 1996 : 	}
; 1997 : 	/* 
; 1998 : 	* copy the return value data from the input to the temporary location for the
; 1999 : 	* children of this function to use 
; 2000 : 	*/
; 2001 : 	/*
; 2002 : 	*	if this is in save state the array number has to be retrieved here to 
; 2003 : 	*  know which array to place the data into 
; 2004 : 	*/
; 2005 : 	if (state==BIN_SAVE)

  00cbf	83 ff 17	 cmp	 edi, 23			; 00000017H
  00cc2	89 4c 24 48	 mov	 DWORD PTR _new_ret$[esp+104], ecx

; 2006 : 	{
; 2007 : 		/* get the number from the rule to save the result in */
; 2008 : 		new_ret.rule++;	/* skip the operation */
; 2009 : 		save_state_num=current_rule[new_ret.rule];
; 2010 : 	}
; 2011 : 	if (state==BIN_DICTIONARY)

  00cc6	74 05		 je	 SHORT $L72950
  00cc8	83 ff 1d	 cmp	 edi, 29			; 0000001dH
  00ccb	75 29		 jne	 SHORT $L71711
$L72950:

; 2012 : 	{
; 2013 : 		new_ret.rule++;

  00ccd	8b 44 24 70	 mov	 eax, DWORD PTR _in_rule_index$[esp+76]

; 2014 : 		save_state_num=current_rule[new_ret.rule];

  00cd1	8b 7c 24 54	 mov	 edi, DWORD PTR _current_rule$[esp+76]
  00cd5	40		 inc	 eax
  00cd6	33 c9		 xor	 ecx, ecx
  00cd8	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
  00cdc	8a 0c 38	 mov	 cl, BYTE PTR [eax+edi]
  00cdf	89 4c 24 14	 mov	 DWORD PTR _save_state_num$[esp+80], ecx

; 2015 : 	}
; 2016 : #ifdef GERMAN_COMPOUND_NOUNS
; 2017 : 	if (state==BIN_INSERT)

  00ce3	e9 2d 01 00 00	 jmp	 $L72929
$L71707:

; 1983 : 	}
; 1984 : 
; 1985 : 	/* set the optional flag if the state is optional */
; 1986 : 	if (state==BIN_OPTIONAL)

  00ce8	83 ff 16	 cmp	 edi, 22			; 00000016H
  00ceb	75 cf		 jne	 SHORT $L71708

; 1987 : 	{                                         
; 1988 : #ifdef DEBUG
; 1989 : 		printf("set optional to 1\n");
; 1990 : #endif
; 1991 : 		new_ret.optional=1;

  00ced	89 4c 24 48	 mov	 DWORD PTR _new_ret$[esp+104], ecx

; 1992 : 	}     
; 1993 : 	else

  00cf1	e9 1f 01 00 00	 jmp	 $L72929
$L71711:

; 2015 : 	}
; 2016 : #ifdef GERMAN_COMPOUND_NOUNS
; 2017 : 	if (state==BIN_INSERT)

  00cf6	83 ff 1a	 cmp	 edi, 26			; 0000001aH
  00cf9	75 1a		 jne	 SHORT $L71712

; 2018 : 	{
; 2019 : 		insert_operation_flags=current_rule[new_ret.rule];

  00cfb	8b 7c 24 70	 mov	 edi, DWORD PTR _in_rule_index$[esp+76]
  00cff	8b 5c 24 54	 mov	 ebx, DWORD PTR _current_rule$[esp+76]
  00d03	33 c9		 xor	 ecx, ecx
  00d05	8a 0c 1f	 mov	 cl, BYTE PTR [edi+ebx]

; 2020 : 	}
; 2021 : #endif
; 2022 : 	if (state==BIN_MACRO)

  00d08	8b 5c 24 5c	 mov	 ebx, DWORD PTR _input_array$[esp+76]
  00d0c	89 4c 24 1c	 mov	 DWORD PTR _insert_operation_flags$[esp+80], ecx
  00d10	e9 00 01 00 00	 jmp	 $L72929
$L71712:
  00d15	83 ff 18	 cmp	 edi, 24			; 00000018H
  00d18	0f 85 f2 00 00
	00		 jne	 $L71713

; 2023 : 	{
; 2024 : 		rule_p=new_ret.rule;
; 2025 : 		rule_p++; /* skip state identifier */

  00d1e	8b 54 24 70	 mov	 edx, DWORD PTR _in_rule_index$[esp+76]

; 2026 : 		next_rule_number=get_short(&current_rule[rule_p]);

  00d22	8b 44 24 54	 mov	 eax, DWORD PTR _current_rule$[esp+76]
  00d26	33 c9		 xor	 ecx, ecx
  00d28	8a 6c 10 02	 mov	 ch, BYTE PTR [eax+edx+2]
  00d2c	8d 6a 01	 lea	 ebp, DWORD PTR [edx+1]
  00d2f	8a 0c 28	 mov	 cl, BYTE PTR [eax+ebp]

; 2027 : 		rule_p+=2;

  00d32	83 c5 02	 add	 ebp, 2
  00d35	8b c1		 mov	 eax, ecx

; 2028 : 		
; 2029 : 		new_rule=(&(rule_data_table[rule_index_table[next_rule_number]]));
; 2030 : 		new_ret.rule=0;

  00d37	33 c9		 xor	 ecx, ecx
  00d39	89 4c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ecx
  00d3d	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _rule_index_table[eax*4]
  00d44	05 00 00 00 00	 add	 eax, OFFSET FLAT:_rule_data_table

; 2031 : 		if (new_rule[0] & BIN_NEXT_HIT)	 new_ret.rule+=2;

  00d49	84 08		 test	 BYTE PTR [eax], cl
  00d4b	74 3c		 je	 SHORT $L71721
  00d4d	b9 02 00 00 00	 mov	 ecx, 2
  00d52	89 4c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ecx

; 2032 : 		if (new_rule[0] & BIN_NEXT_MISS)  new_ret.rule+=2;

  00d56	8a 10		 mov	 dl, BYTE PTR [eax]
  00d58	f6 c2 00	 test	 dl, 0
  00d5b	74 2c		 je	 SHORT $L71721
  00d5d	03 c9		 add	 ecx, ecx
  00d5f	89 4c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ecx

; 2033 : 		if (new_rule[0] & BIN_GORET_HIT)  new_ret.rule+=2;

  00d63	8a 10		 mov	 dl, BYTE PTR [eax]
  00d65	f6 c2 00	 test	 dl, 0
  00d68	74 1f		 je	 SHORT $L71721
  00d6a	83 c1 02	 add	 ecx, 2
  00d6d	89 4c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ecx

; 2034 : 		if (new_rule[0] & BIN_GORET_MISS) new_ret.rule+=2;

  00d71	8a 10		 mov	 dl, BYTE PTR [eax]
  00d73	f6 c2 00	 test	 dl, 0
  00d76	74 11		 je	 SHORT $L71721
  00d78	83 c1 02	 add	 ecx, 2
  00d7b	89 4c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ecx

; 2035 : 		if (new_rule[0] & BIN_COPY_HIT) new_ret.rule+=2;

  00d7f	8a 10		 mov	 dl, BYTE PTR [eax]
  00d81	f6 c2 00	 test	 dl, 0
  00d84	74 03		 je	 SHORT $L71721
  00d86	83 c1 02	 add	 ecx, 2
$L71721:

; 2036 : 		new_ret.rule+=12;

  00d89	83 c1 0c	 add	 ecx, 12			; 0000000cH

; 2037 : 		
; 2038 : 		par_match_rule(new_rule,BIN_END_OF_RULE,input_array,output_array,input_indexes,output_indexes,match_array,&new_ret,0);

  00d8c	8d 54 24 30	 lea	 edx, DWORD PTR _new_ret$[esp+80]
  00d90	89 4c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ecx
  00d94	8b 4c 24 6c	 mov	 ecx, DWORD PTR _match_array$[esp+76]
  00d98	6a 00		 push	 0
  00d9a	52		 push	 edx
  00d9b	8b 54 24 70	 mov	 edx, DWORD PTR _output_indexes$[esp+84]
  00d9f	51		 push	 ecx
  00da0	8b 4c 24 70	 mov	 ecx, DWORD PTR _input_indexes$[esp+88]
  00da4	52		 push	 edx
  00da5	8b 54 24 70	 mov	 edx, DWORD PTR _output_array$[esp+92]
  00da9	51		 push	 ecx
  00daa	52		 push	 edx
  00dab	53		 push	 ebx
  00dac	6a 00		 push	 0
  00dae	50		 push	 eax
  00daf	e8 00 00 00 00	 call	 _par_match_rule

; 2039 : 		/* fixed macro state */
; 2040 : 		new_ret.rule=rule_p;
; 2041 : 		if ((new_ret.input_pos+new_ret.input_offset > length_of_input)) 

  00db4	8b 4c 24 54	 mov	 ecx, DWORD PTR _new_ret$[esp+116]
  00db8	8b 54 24 58	 mov	 edx, DWORD PTR _new_ret$[esp+120]
  00dbc	03 d1		 add	 edx, ecx
  00dbe	8b 4c 24 3c	 mov	 ecx, DWORD PTR _length_of_input$[esp+116]
  00dc2	83 c4 24	 add	 esp, 36			; 00000024H
  00dc5	8b c5		 mov	 eax, ebp
  00dc7	3b d1		 cmp	 edx, ecx
  00dc9	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
  00dcd	7e 1a		 jle	 SHORT $L71724

; 2042 : 		{
; 2043 : 			if (new_ret.optional==1)

  00dcf	83 7c 24 48 01	 cmp	 DWORD PTR _new_ret$[esp+104], 1
  00dd4	0f 85 5a 02 00
	00		 jne	 $L71723

; 2044 : 			{
; 2045 : //				new_ret.optional= -1;
; 2046 : 				ret_value->value=OPT_FAIL;

  00dda	c7 46 14 02 00
	00 00		 mov	 DWORD PTR [esi+20], 2
  00de1	5f		 pop	 edi
  00de2	5e		 pop	 esi
  00de3	5d		 pop	 ebp
  00de4	5b		 pop	 ebx

; 2311 : #ifdef DEBUG
; 2312 : 	printf("leaving par_match_rule success\n");
; 2313 : #endif
; 2314 : }

  00de5	83 c4 40	 add	 esp, 64			; 00000040H
  00de8	c3		 ret	 0
$L71724:

; 2047 : //				ret_value->rule=rule_p;
; 2048 : 				return;
; 2049 : 			}
; 2050 : 			else
; 2051 : 			{
; 2052 : //				new_ret.value=END_OF_STRING;
; 2053 : 				ret_value->value=END_OF_STRING;
; 2054 : 				return;
; 2055 : 			}
; 2056 : 		}
; 2057 : 		if ((new_ret.value==FAIL) && (new_ret.optional))

  00de9	8b 4c 24 44	 mov	 ecx, DWORD PTR _new_ret$[esp+100]
  00ded	85 c9		 test	 ecx, ecx
  00def	0f 85 0a 02 00
	00		 jne	 $L72935
  00df5	8b 44 24 48	 mov	 eax, DWORD PTR _new_ret$[esp+104]
  00df9	85 c0		 test	 eax, eax
  00dfb	0f 84 c7 01 00
	00		 je	 $L72934

; 2058 : 		{
; 2059 : //			new_ret.optional= -1;
; 2060 : 			ret_value->value=OPT_FAIL;

  00e01	c7 46 14 02 00
	00 00		 mov	 DWORD PTR [esi+20], 2
  00e08	5f		 pop	 edi
  00e09	5e		 pop	 esi
  00e0a	5d		 pop	 ebp
  00e0b	5b		 pop	 ebx

; 2311 : #ifdef DEBUG
; 2312 : 	printf("leaving par_match_rule success\n");
; 2313 : #endif
; 2314 : }

  00e0c	83 c4 40	 add	 esp, 64			; 00000040H
  00e0f	c3		 ret	 0
$L71713:

; 2061 : //			ret_value->rule=new_ret.rule;
; 2062 : 			return;
; 2063 : 		}                                                                 
; 2064 : 	}
; 2065 : 	else
; 2066 : 	{
; 2067 : 		/* extract the state data */
; 2068 : 		if (state>=BIN_COPY)

  00e10	83 ff 14	 cmp	 edi, 20			; 00000014H
  00e13	7c 59		 jl	 SHORT $L72924
$L72929:

; 2069 : 		{
; 2070 : 			new_ret.rule++;	/* skip the operation */
; 2071 : 			end_of_match=current_rule[new_ret.rule];

  00e15	8b 4c 24 54	 mov	 ecx, DWORD PTR _current_rule$[esp+76]
  00e19	40		 inc	 eax
  00e1a	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
  00e1e	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]

; 2072 : 			new_ret.rule++;

  00e21	40		 inc	 eax
  00e22	88 4c 24 10	 mov	 BYTE PTR _end_of_match$[esp+80], cl

; 2073 : #ifndef GERMAN_COMPOUND_NOUNS
; 2074 : 			if (state>=BIN_REPLACE && state <=BIN_BEFORE)
; 2075 : #else
; 2076 : 			if (state>=BIN_REPLACE && state <=BIN_INSERT)

  00e26	8b 4c 24 58	 mov	 ecx, DWORD PTR _state$[esp+76]
  00e2a	83 f9 19	 cmp	 ecx, 25			; 00000019H
  00e2d	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
  00e31	7c 23		 jl	 SHORT $L71728
  00e33	83 f9 1a	 cmp	 ecx, 26			; 0000001aH
  00e36	7f 1e		 jg	 SHORT $L71728

; 2077 : #endif
; 2078 : 			{
; 2079 : 				new_ret.rule++;
; 2080 : 				if (current_rule[in_rule_index] & BIN_CONDITIONAL_REPLACE)

  00e38	8b 4c 24 70	 mov	 ecx, DWORD PTR _in_rule_index$[esp+76]
  00e3c	8b 7c 24 54	 mov	 edi, DWORD PTR _current_rule$[esp+76]
  00e40	40		 inc	 eax
  00e41	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
  00e45	f6 04 39 80	 test	 BYTE PTR [ecx+edi], 128	; 00000080H
  00e49	74 1f		 je	 SHORT $L72938

; 2081 : 				{
; 2082 : 					new_ret.rule+=current_rule[new_ret.rule];
; 2083 : 					new_ret.rule++; /* add 1 for the conditional number */

  00e4b	33 c9		 xor	 ecx, ecx
  00e4d	8a 0c 38	 mov	 cl, BYTE PTR [eax+edi]
  00e50	8d 44 08 01	 lea	 eax, DWORD PTR [eax+ecx+1]

; 2084 : 				}
; 2085 : 			}
; 2086 : 			else

  00e54	eb 10		 jmp	 SHORT $L72951
$L71728:

; 2087 : 			{
; 2088 : 				if (state==BIN_DICTIONARY)

  00e56	83 f9 1d	 cmp	 ecx, 29			; 0000001dH
  00e59	75 05		 jne	 SHORT $L71731

; 2089 : 				{
; 2090 : 					new_ret.rule+=2;

  00e5b	83 c0 02	 add	 eax, 2

; 2091 : 				}
; 2092 : 				else

  00e5e	eb 06		 jmp	 SHORT $L72951
$L71731:

; 2093 : 				{
; 2094 : 					if (state==BIN_STATUS)

  00e60	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  00e63	75 05		 jne	 SHORT $L72938

; 2095 : 					{
; 2096 : 						new_ret.rule++;

  00e65	40		 inc	 eax
$L72951:
  00e66	89 44 24 40	 mov	 DWORD PTR _new_ret$[esp+96], eax
$L72938:

; 2084 : 				}
; 2085 : 			}
; 2086 : 			else

  00e6a	8b 7c 24 58	 mov	 edi, DWORD PTR _state$[esp+76]
$L72924:

; 2097 : 					}
; 2098 : 				}
; 2099 : 			}
; 2100 : 		}
; 2101 : 		
; 2102 : 		/* 
; 2103 : 		* decide whether the string in the position being processed is another rule 
; 2104 : 		* or if it is a character type or string to be matched.
; 2105 : 		*/
; 2106 : #if 0
; 2107 : 		while ((current_rule[new_ret.rule]!=0) && (new_ret.rule <= end_of_match) && (new_ret.optional!=-1) &&
; 2108 : 			(new_ret.value!=FATAL_FAIL) && (new_ret.value!=FAIL) && (new_ret.value!=END_OF_STRING)) /* && */
; 2109 : #endif
; 2110 : 
; 2111 : 		
; 2112 : 		while ((new_ret.rule <= end_of_match) && ((temp=current_rule[new_ret.rule])!=0) &&  (new_ret.value==SUCCESS))

  00e6e	8b 4c 24 10	 mov	 ecx, DWORD PTR _end_of_match$[esp+80]
  00e72	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00e78	3b c1		 cmp	 eax, ecx
  00e7a	89 4c 24 5c	 mov	 DWORD PTR 16+[esp+76], ecx
  00e7e	0f 8f ca 01 00
	00		 jg	 $L72944
$L71735:
  00e84	8b 7c 24 54	 mov	 edi, DWORD PTR _current_rule$[esp+76]
  00e88	33 c9		 xor	 ecx, ecx
  00e8a	8a 0c 38	 mov	 cl, BYTE PTR [eax+edi]
  00e8d	85 c9		 test	 ecx, ecx
  00e8f	0f 84 f9 00 00
	00		 je	 $L71736
  00e95	83 7c 24 44 01	 cmp	 DWORD PTR _new_ret$[esp+100], 1
  00e9a	0f 85 ee 00 00
	00		 jne	 $L71736

; 2113 : 			/*(new_ret.input_pos+new_ret.input_offset < (int)strlen(input_array))*/ 	/* slow ?? */
; 2114 : 			/* process all the data in this action state that is before the ending slash */
; 2115 : 		{
; 2116 : 			new_operation=temp & BIN_OPERATION_MASK;

  00ea0	83 e1 1f	 and	 ecx, 31			; 0000001fH

; 2117 : 			if ((new_operation <= BIN_SETS))
; 2118 : 			{
; 2119 : 				num_chars_matched=par_match_string(current_rule,new_operation,input_array,match_array,&new_ret,&range_value,1,0);

  00ea3	6a 00		 push	 0
  00ea5	8b c1		 mov	 eax, ecx
  00ea7	83 f8 13	 cmp	 eax, 19			; 00000013H
  00eaa	7f 74		 jg	 SHORT $L71737
  00eac	8d 54 24 24	 lea	 edx, DWORD PTR _range_value$[esp+84]
  00eb0	6a 01		 push	 1
  00eb2	52		 push	 edx
  00eb3	8b 54 24 78	 mov	 edx, DWORD PTR _match_array$[esp+88]
  00eb7	8d 4c 24 3c	 lea	 ecx, DWORD PTR _new_ret$[esp+92]
  00ebb	51		 push	 ecx
  00ebc	52		 push	 edx
  00ebd	53		 push	 ebx
  00ebe	50		 push	 eax
  00ebf	8b 44 24 70	 mov	 eax, DWORD PTR _current_rule$[esp+104]
  00ec3	50		 push	 eax
  00ec4	e8 00 00 00 00	 call	 _par_match_string
  00ec9	8b f8		 mov	 edi, eax
  00ecb	83 c4 20	 add	 esp, 32			; 00000020H

; 2120 : 				
; 2121 : 				/* copy matched data to the output string */
; 2122 : 				if (num_chars_matched== -1)

  00ece	83 ff ff	 cmp	 edi, -1
  00ed1	0f 84 c1 00 00
	00		 je	 $L72925

; 2135 : 						return;
; 2136 : 					}
; 2137 : 				}
; 2138 : 				if (num_chars_matched== 0 && new_ret.optional)

  00ed7	85 ff		 test	 edi, edi
  00ed9	75 0c		 jne	 SHORT $L71741
  00edb	8b 44 24 48	 mov	 eax, DWORD PTR _new_ret$[esp+104]
  00edf	85 c0		 test	 eax, eax
  00ee1	0f 85 67 02 00
	00		 jne	 $L72936
$L71741:

; 2139 : 				{
; 2140 : 					new_ret.value=OPT_FAIL;
; 2141 : 					break;
; 2142 : 				}
; 2143 : #ifdef DEBUG
; 2144 : 				par_print_rule_error("after par_match_string",current_rule,new_ret.rule);
; 2145 : #endif
; 2146 : 				par_copy_string_data(input_array,input_indexes,output_array,output_indexes,num_chars_matched,&new_ret);

  00ee7	8b 54 24 68	 mov	 edx, DWORD PTR _output_indexes$[esp+76]
  00eeb	8b 44 24 60	 mov	 eax, DWORD PTR _output_array$[esp+76]
  00eef	8d 4c 24 30	 lea	 ecx, DWORD PTR _new_ret$[esp+80]
  00ef3	51		 push	 ecx
  00ef4	8b 4c 24 68	 mov	 ecx, DWORD PTR _input_indexes$[esp+80]
  00ef8	57		 push	 edi
  00ef9	52		 push	 edx
  00efa	50		 push	 eax
  00efb	51		 push	 ecx
  00efc	53		 push	 ebx
  00efd	e8 00 00 00 00	 call	 _par_copy_string_data

; 2147 : 				/* update new_ret output_offset */
; 2148 : 				new_ret.output_offset+=num_chars_matched;

  00f02	8b 6c 24 54	 mov	 ebp, DWORD PTR _new_ret$[esp+116]

; 2149 : 				new_ret.input_offset+=num_chars_matched; 

  00f06	8b 44 24 4c	 mov	 eax, DWORD PTR _new_ret$[esp+108]
  00f0a	83 c4 18	 add	 esp, 24			; 00000018H
  00f0d	03 ef		 add	 ebp, edi
  00f0f	03 c7		 add	 eax, edi
  00f11	89 6c 24 3c	 mov	 DWORD PTR _new_ret$[esp+92], ebp
  00f15	89 44 24 34	 mov	 DWORD PTR _new_ret$[esp+84], eax

; 2150 : 			}
; 2151 : 			else

  00f19	b8 03 00 00 00	 mov	 eax, 3
  00f1e	eb 39		 jmp	 SHORT $L71745
$L71737:

; 2152 : 			{
; 2153 : 					/* recursively call the par_match_rule function with the new action state */
; 2154 : 				par_match_rule(current_rule,new_operation,input_array,output_array,input_indexes,output_indexes,match_array,&new_ret,0);

  00f20	8b 4c 24 70	 mov	 ecx, DWORD PTR _match_array$[esp+80]
  00f24	8d 54 24 34	 lea	 edx, DWORD PTR _new_ret$[esp+84]
  00f28	52		 push	 edx
  00f29	8b 54 24 70	 mov	 edx, DWORD PTR _output_indexes$[esp+84]
  00f2d	51		 push	 ecx
  00f2e	8b 4c 24 70	 mov	 ecx, DWORD PTR _input_indexes$[esp+88]
  00f32	52		 push	 edx
  00f33	8b 54 24 70	 mov	 edx, DWORD PTR _output_array$[esp+92]
  00f37	51		 push	 ecx
  00f38	52		 push	 edx
  00f39	53		 push	 ebx
  00f3a	50		 push	 eax
  00f3b	8b 44 24 74	 mov	 eax, DWORD PTR _current_rule$[esp+108]
  00f3f	50		 push	 eax
  00f40	e8 00 00 00 00	 call	 _par_match_rule

; 2155 : 				
; 2156 : #ifdef DEBUG
; 2157 : 				par_print_rule_error("after par_match_rule",current_rule,new_ret.rule);
; 2158 : #endif
; 2159 : 				if (new_ret.value==END_OF_STRING)

  00f45	8b 4c 24 68	 mov	 ecx, DWORD PTR _new_ret$[esp+136]
  00f49	b8 03 00 00 00	 mov	 eax, 3
  00f4e	83 c4 24	 add	 esp, 36			; 00000024H
  00f51	3b c8		 cmp	 ecx, eax
  00f53	74 5d		 je	 SHORT $L72927
  00f55	8b 6c 24 3c	 mov	 ebp, DWORD PTR _new_ret$[esp+92]
$L71745:

; 2172 : 						return;
; 2173 : 					}
; 2174 : 				}
; 2175 : 				/* the matched expression should already be in the output buffer */
; 2176 : 			}                              
; 2177 : 			/* processing continues here after a call to either par_match_string() or to par_match_rule() */
; 2178 : 			if ((new_ret.input_pos+new_ret.input_offset > length_of_input)) 

  00f59	8b 4c 24 30	 mov	 ecx, DWORD PTR _new_ret$[esp+80]
  00f5d	8b 54 24 34	 mov	 edx, DWORD PTR _new_ret$[esp+84]
  00f61	03 d1		 add	 edx, ecx
  00f63	8b 4c 24 18	 mov	 ecx, DWORD PTR _length_of_input$[esp+80]
  00f67	3b d1		 cmp	 edx, ecx
  00f69	7e 0f		 jle	 SHORT $L71748

; 2179 : 			{
; 2180 : 				if (new_ret.optional==1)

  00f6b	83 7c 24 48 01	 cmp	 DWORD PTR _new_ret$[esp+104], 1
  00f70	0f 84 dc 01 00
	00		 je	 $L72937

; 2181 : 				{
; 2182 : 					new_ret.value=OPT_FAIL;
; 2183 : 					break;
; 2184 : 				}
; 2185 : 				else
; 2186 : 				{
; 2187 : 					new_ret.value=END_OF_STRING;

  00f76	89 44 24 44	 mov	 DWORD PTR _new_ret$[esp+100], eax
$L71748:

; 2097 : 					}
; 2098 : 				}
; 2099 : 			}
; 2100 : 		}
; 2101 : 		
; 2102 : 		/* 
; 2103 : 		* decide whether the string in the position being processed is another rule 
; 2104 : 		* or if it is a character type or string to be matched.
; 2105 : 		*/
; 2106 : #if 0
; 2107 : 		while ((current_rule[new_ret.rule]!=0) && (new_ret.rule <= end_of_match) && (new_ret.optional!=-1) &&
; 2108 : 			(new_ret.value!=FATAL_FAIL) && (new_ret.value!=FAIL) && (new_ret.value!=END_OF_STRING)) /* && */
; 2109 : #endif
; 2110 : 
; 2111 : 		
; 2112 : 		while ((new_ret.rule <= end_of_match) && ((temp=current_rule[new_ret.rule])!=0) &&  (new_ret.value==SUCCESS))

  00f7a	8b 44 24 40	 mov	 eax, DWORD PTR _new_ret$[esp+96]
  00f7e	8b 4c 24 5c	 mov	 ecx, DWORD PTR 16+[esp+76]

; 2179 : 			{
; 2180 : 				if (new_ret.optional==1)

  00f82	8b 54 24 38	 mov	 edx, DWORD PTR _new_ret$[esp+88]
  00f86	3b c1		 cmp	 eax, ecx
  00f88	0f 8e f6 fe ff
	ff		 jle	 $L71735
$L71736:

; 2188 : 				}
; 2189 : 			}
; 2190 : 		}
; 2191 : 	}
; 2192 : 	/* the end of state slash marker was found or there was a failure in the matching */
; 2193 : 	if (new_ret.value==FAIL)

  00f8e	8b 4c 24 44	 mov	 ecx, DWORD PTR _new_ret$[esp+100]
  00f92	85 c9		 test	 ecx, ecx
  00f94	75 73		 jne	 SHORT $L72943
  00f96	eb 38		 jmp	 SHORT $L72930
$L72925:

; 2123 : 				{
; 2124 : #ifdef DEBUG
; 2125 : 					printf("leaving par_match_rule; end of string reached in string\n");
; 2126 : #endif
; 2127 : 					if (new_ret.optional==1)

  00f98	83 7c 24 48 01	 cmp	 DWORD PTR _new_ret$[esp+104], 1

; 2128 : 					{
; 2129 : 						new_ret.value=OPT_FAIL;
; 2130 : 						break;

  00f9d	0f 84 ab 01 00
	00		 je	 $L72936

; 2131 : 					}
; 2132 : 					else
; 2133 : 					{
; 2134 : 						ret_value->value=END_OF_STRING;                         

  00fa3	c7 46 14 03 00
	00 00		 mov	 DWORD PTR [esi+20], 3
  00faa	5f		 pop	 edi
  00fab	5e		 pop	 esi
  00fac	5d		 pop	 ebp
  00fad	5b		 pop	 ebx

; 2311 : #ifdef DEBUG
; 2312 : 	printf("leaving par_match_rule success\n");
; 2313 : #endif
; 2314 : }

  00fae	83 c4 40	 add	 esp, 64			; 00000040H
  00fb1	c3		 ret	 0
$L72927:

; 2160 : 				{
; 2161 : #ifdef DEBUG
; 2162 : 					printf("leaving par_match_rule; end of string reached in rule\n");
; 2163 : #endif
; 2164 : 					if (new_ret.optional==1)

  00fb2	83 7c 24 48 01	 cmp	 DWORD PTR _new_ret$[esp+104], 1

; 2165 : 					{
; 2166 : 						new_ret.value=OPT_FAIL;
; 2167 : 						break;

  00fb7	0f 84 91 01 00
	00		 je	 $L72936

; 2168 : 					}
; 2169 : 					else						
; 2170 : 					{
; 2171 : 						ret_value->value=END_OF_STRING;

  00fbd	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00fc0	5f		 pop	 edi
  00fc1	5e		 pop	 esi
  00fc2	5d		 pop	 ebp
  00fc3	5b		 pop	 ebx

; 2311 : #ifdef DEBUG
; 2312 : 	printf("leaving par_match_rule success\n");
; 2313 : #endif
; 2314 : }

  00fc4	83 c4 40	 add	 esp, 64			; 00000040H
  00fc7	c3		 ret	 0
$L72934:

; 2188 : 				}
; 2189 : 			}
; 2190 : 		}
; 2191 : 	}
; 2192 : 	/* the end of state slash marker was found or there was a failure in the matching */
; 2193 : 	if (new_ret.value==FAIL)

  00fc8	8b 6c 24 3c	 mov	 ebp, DWORD PTR _new_ret$[esp+92]
  00fcc	8b 54 24 38	 mov	 edx, DWORD PTR _new_ret$[esp+88]
$L72930:

; 2194 : 	{
; 2195 : 	/* on failure of a rule just send back FAIL. the caller will then send FAIL back to its caller
; 2196 : 	* and so on, until the outer loop is reached with FAIL.  The original ret_value array 
; 2197 : 	* should remain unchanged for the following rules to use 
; 2198 : 		*/
; 2199 : 		ret_value->value=FAIL;

  00fd0	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2200 : #ifdef INDEX_DEBUG2
; 2201 : 		printf("cleared indexes from %d to %d in the output, failure\n",new_ret.output_pos,new_ret.output_pos+new_ret.output_offset);
; 2202 : #endif
; 2203 : 		memset(output_indexes+new_ret.output_pos,0,new_ret.output_offset*sizeof(index_data_t));

  00fd7	8b 74 24 68	 mov	 esi, DWORD PTR _output_indexes$[esp+76]
  00fdb	8d 4c 6d 00	 lea	 ecx, DWORD PTR [ebp+ebp*2]
  00fdf	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  00fe2	d1 e1		 shl	 ecx, 1
  00fe4	8d 3c 56	 lea	 edi, DWORD PTR [esi+edx*2]
  00fe7	8b d1		 mov	 edx, ecx
  00fe9	33 c0		 xor	 eax, eax
  00feb	c1 e9 02	 shr	 ecx, 2
  00fee	f3 ab		 rep stosd
  00ff0	8b ca		 mov	 ecx, edx
  00ff2	83 e1 03	 and	 ecx, 3
  00ff5	f3 aa		 rep stosb
  00ff7	5f		 pop	 edi
  00ff8	5e		 pop	 esi
  00ff9	5d		 pop	 ebp
  00ffa	5b		 pop	 ebx

; 2311 : #ifdef DEBUG
; 2312 : 	printf("leaving par_match_rule success\n");
; 2313 : #endif
; 2314 : }

  00ffb	83 c4 40	 add	 esp, 64			; 00000040H
  00ffe	c3		 ret	 0
$L72935:

; 2204 : #ifdef DEBUG
; 2205 : 		printf("leaving par_match_rule failure of the rule\n");
; 2206 : #endif
; 2207 : 		
; 2208 : 		return;

  00fff	8b 6c 24 3c	 mov	 ebp, DWORD PTR _new_ret$[esp+92]
  01003	8b 54 24 38	 mov	 edx, DWORD PTR _new_ret$[esp+88]
  01007	eb 04		 jmp	 SHORT $L71749
$L72943:
  01009	8b 7c 24 58	 mov	 edi, DWORD PTR _state$[esp+76]
$L71749:

; 2209 : 	}
; 2210 : 	if (new_ret.value==END_OF_STRING)

  0100d	83 7c 24 44 03	 cmp	 DWORD PTR _new_ret$[esp+100], 3
  01012	75 2f		 jne	 SHORT $L71751

; 2211 : 	{
; 2212 : 		/* on finding the end of the string, return END_OF_STRING to the caller */
; 2213 : #ifdef INDEX_DEBUG2
; 2214 : 		printf("cleared indexes from %d to %d in the output, end_of_string\n",new_ret.output_pos,new_ret.output_pos+new_ret.output_offset);
; 2215 : #endif
; 2216 : 		memset(output_indexes+new_ret.output_pos,0,new_ret.output_offset*sizeof(index_data_t));

  01014	8b 7c 24 68	 mov	 edi, DWORD PTR _output_indexes$[esp+76]
  01018	8d 4c 6d 00	 lea	 ecx, DWORD PTR [ebp+ebp*2]
  0101c	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  0101f	33 c0		 xor	 eax, eax
  01021	d1 e1		 shl	 ecx, 1
  01023	8d 3c 57	 lea	 edi, DWORD PTR [edi+edx*2]
  01026	8b d1		 mov	 edx, ecx
  01028	c1 e9 02	 shr	 ecx, 2
  0102b	f3 ab		 rep stosd
  0102d	8b ca		 mov	 ecx, edx
  0102f	83 e1 03	 and	 ecx, 3
  01032	f3 aa		 rep stosb
$L71723:

; 2217 : 		ret_value->value=END_OF_STRING;

  01034	c7 46 14 03 00
	00 00		 mov	 DWORD PTR [esi+20], 3
  0103b	5f		 pop	 edi
  0103c	5e		 pop	 esi
  0103d	5d		 pop	 ebp
  0103e	5b		 pop	 ebx

; 2311 : #ifdef DEBUG
; 2312 : 	printf("leaving par_match_rule success\n");
; 2313 : #endif
; 2314 : }

  0103f	83 c4 40	 add	 esp, 64			; 00000040H
  01042	c3		 ret	 0
$L71751:

; 2218 : #ifdef DEBUG
; 2219 : 		printf("leaving par_match_rule; the end of the string was encountered\n");
; 2220 : #endif
; 2221 : 		return;
; 2222 : 	}
; 2223 : 	
; 2224 : 	/* this should be the ending slash of the state */
; 2225 : 	if (new_ret.value!=OPT_FAIL)

  01043	83 7c 24 44 02	 cmp	 DWORD PTR _new_ret$[esp+100], 2
  01048	0f 84 08 01 00
	00		 je	 $L71753
$L72944:
  0104e	8b 4c 24 10	 mov	 ecx, DWORD PTR _end_of_match$[esp+80]

; 2226 : 	{
; 2227 : 		if ((state!=BIN_END_OF_RULE) && (state!=BIN_MACRO))

  01052	85 ff		 test	 edi, edi
  01054	0f 84 80 00 00
	00		 je	 $L71757
  0105a	83 ff 18	 cmp	 edi, 24			; 00000018H
  0105d	74 2d		 je	 SHORT $L71755

; 2228 : 		{
; 2229 : 			if (new_ret.rule!=(end_of_match+1))

  0105f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  01065	41		 inc	 ecx
  01066	3b c1		 cmp	 eax, ecx
  01068	74 22		 je	 SHORT $L71755

; 2230 : 			{
; 2231 : 				par_print_rule_error("par_match_rule;end of state slash not found",current_rule,new_ret.rule);

  0106a	50		 push	 eax
  0106b	8b 44 24 58	 mov	 eax, DWORD PTR _current_rule$[esp+80]
  0106f	50		 push	 eax
  01070	68 00 00 00 00	 push	 OFFSET FLAT:$SG71756
  01075	e8 00 00 00 00	 call	 _par_print_rule_error
  0107a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2232 : 				ret_value->value=FATAL_FAIL;

  0107d	c7 46 14 04 00
	00 00		 mov	 DWORD PTR [esi+20], 4
  01084	5f		 pop	 edi
  01085	5e		 pop	 esi
  01086	5d		 pop	 ebp
  01087	5b		 pop	 ebx

; 2311 : #ifdef DEBUG
; 2312 : 	printf("leaving par_match_rule success\n");
; 2313 : #endif
; 2314 : }

  01088	83 c4 40	 add	 esp, 64			; 00000040H
  0108b	c3		 ret	 0
$L71755:

; 2233 : 				return;
; 2234 : 			}
; 2235 : 		}
; 2236 : 		/* performing the action of this state */  
; 2237 : #ifdef DEBUG
; 2238 : 		printf("the current output is:%s\n",output_array);
; 2239 : 		printf("output_pos=%d output_offset=%d\n",new_ret.output_pos,new_ret.output_offset);
; 2240 : #endif
; 2241 : 		if (state!=BIN_END_OF_RULE)
; 2242 : 		{
; 2243 : #ifndef GERMAN_COMPOUND_NOUNS
; 2244 : 			(perform_action_funcs[state])(current_rule,input_array,output_array,input_indexes,output_indexes,match_array,&new_ret,&range_value,save_state_num,dict_state_flag,in_rule_index);
; 2245 : #else
; 2246 : 			(perform_action_funcs[state])(current_rule,input_array,output_array,input_indexes,output_indexes,match_array,&new_ret,&range_value,save_state_num,dict_state_flag,in_rule_index,insert_operation_flags);

  0108c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _insert_operation_flags$[esp+80]
  01090	8b 54 24 70	 mov	 edx, DWORD PTR _in_rule_index$[esp+76]
  01094	8b 44 24 74	 mov	 eax, DWORD PTR _dict_state_flag$[esp+76]
  01098	51		 push	 ecx
  01099	8b 4c 24 18	 mov	 ecx, DWORD PTR _save_state_num$[esp+84]
  0109d	52		 push	 edx
  0109e	50		 push	 eax
  0109f	8d 54 24 2c	 lea	 edx, DWORD PTR _range_value$[esp+92]
  010a3	51		 push	 ecx
  010a4	8b 4c 24 7c	 mov	 ecx, DWORD PTR _match_array$[esp+92]
  010a8	8d 44 24 40	 lea	 eax, DWORD PTR _new_ret$[esp+96]
  010ac	52		 push	 edx
  010ad	8b 54 24 7c	 mov	 edx, DWORD PTR _output_indexes$[esp+96]
  010b1	50		 push	 eax
  010b2	8b 44 24 7c	 mov	 eax, DWORD PTR _input_indexes$[esp+100]
  010b6	51		 push	 ecx
  010b7	8b 4c 24 7c	 mov	 ecx, DWORD PTR _output_array$[esp+104]
  010bb	52		 push	 edx
  010bc	8b 54 24 74	 mov	 edx, DWORD PTR _current_rule$[esp+108]
  010c0	50		 push	 eax
  010c1	51		 push	 ecx
  010c2	53		 push	 ebx
  010c3	52		 push	 edx
  010c4	ff 14 bd 00 00
	00 00		 call	 DWORD PTR _perform_action_funcs[edi*4]
  010cb	8b 44 24 70	 mov	 eax, DWORD PTR _new_ret$[esp+144]
  010cf	8b 6c 24 6c	 mov	 ebp, DWORD PTR _new_ret$[esp+140]
  010d3	8b 54 24 68	 mov	 edx, DWORD PTR _new_ret$[esp+136]
  010d7	83 c4 30	 add	 esp, 48			; 00000030H
$L71757:

; 2247 : #endif
; 2248 : 		}
; 2249 : 
; 2250 : 		//printf("B parser_flag is %d\n",new_ret.parser_flag);
; 2251 : 		/* GL 02/08/1997 set the parser_flag to caller */
; 2252 : 		ret_value->parser_flag = new_ret.parser_flag;

  010da	8b 4c 24 4c	 mov	 ecx, DWORD PTR _new_ret$[esp+108]
  010de	89 4e 1c	 mov	 DWORD PTR [esi+28], ecx

; 2253 : 		
; 2254 : 		/* updating ret_value */
; 2255 : 		/* only the value of offset is updated with the change in the offset */
; 2256 : 		/* pos values have the value of what they were at the beginning of the rule matching */
; 2257 : #ifdef DEBUG
; 2258 : 		printf("par_match_rule;the output after the action has been performed\n is %s\n",output_array);
; 2259 : #endif
; 2260 : 		if (new_ret.value==FATAL_FAIL)

  010e1	8b 4c 24 44	 mov	 ecx, DWORD PTR _new_ret$[esp+100]
  010e5	83 f9 04	 cmp	 ecx, 4
  010e8	75 0b		 jne	 SHORT $L71758

; 2261 : 		{
; 2262 : 			ret_value->value=FATAL_FAIL;

  010ea	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  010ed	5f		 pop	 edi
  010ee	5e		 pop	 esi
  010ef	5d		 pop	 ebp
  010f0	5b		 pop	 ebx

; 2311 : #ifdef DEBUG
; 2312 : 	printf("leaving par_match_rule success\n");
; 2313 : #endif
; 2314 : }

  010f1	83 c4 40	 add	 esp, 64			; 00000040H
  010f4	c3		 ret	 0
$L71758:

; 2263 : #ifdef DEBUG
; 2264 : 			printf("leaving par_match_rule fatal failure of the rule\n");
; 2265 : #endif
; 2266 : 			return;
; 2267 : 		}
; 2268 : 		if (new_ret.value==FAIL)

  010f5	85 c9		 test	 ecx, ecx
  010f7	75 2f		 jne	 SHORT $L71759

; 2269 : 		{
; 2270 : #ifdef INDEX_DEBUG2
; 2271 : 			printf("cleared indexes from %d to %d in the output, fail-fail\n",new_ret.output_pos,new_ret.output_pos+new_ret.output_offset);
; 2272 : #endif
; 2273 : 			memset(output_indexes+new_ret.output_pos,0,new_ret.output_offset*sizeof(index_data_t));

  010f9	8b 7c 24 68	 mov	 edi, DWORD PTR _output_indexes$[esp+76]
  010fd	8d 4c 6d 00	 lea	 ecx, DWORD PTR [ebp+ebp*2]
  01101	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  01104	33 c0		 xor	 eax, eax
  01106	d1 e1		 shl	 ecx, 1
  01108	8d 3c 57	 lea	 edi, DWORD PTR [edi+edx*2]
  0110b	8b d1		 mov	 edx, ecx
  0110d	c1 e9 02	 shr	 ecx, 2
  01110	f3 ab		 rep stosd
  01112	8b ca		 mov	 ecx, edx
  01114	83 e1 03	 and	 ecx, 3
  01117	f3 aa		 rep stosb

; 2274 : 			ret_value->value=FAIL;

  01119	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  01120	5f		 pop	 edi
  01121	5e		 pop	 esi
  01122	5d		 pop	 ebp
  01123	5b		 pop	 ebx

; 2311 : #ifdef DEBUG
; 2312 : 	printf("leaving par_match_rule success\n");
; 2313 : #endif
; 2314 : }

  01124	83 c4 40	 add	 esp, 64			; 00000040H
  01127	c3		 ret	 0
$L71759:

; 2275 : #ifdef DEBUG
; 2276 : 			printf("leaving par_match_rule failure of the rule\n");
; 2277 : #endif
; 2278 : 			return;
; 2279 : 
; 2280 : 		}
; 2281 : 		ret_value->value=SUCCESS;
; 2282 : 		/* 
; 2283 : 		*	make the callers return value atructure know how much data was processed 
; 2284 : 		*/
; 2285 : 		/* 	
; 2286 : 		*	these have to be changed with the change in the input value because 
; 2287 : 		*	offsets may have been non zero when the call to this function was made 
; 2288 : 		*/
; 2289 : 		ret_value->input_offset+=new_ret.input_offset;	 /* the offsets are the change from the current pos */

  01128	8b 4c 24 34	 mov	 ecx, DWORD PTR _new_ret$[esp+84]
  0112c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0112f	03 d1		 add	 edx, ecx

; 2290 : 		ret_value->output_offset+=new_ret.output_offset; /* so add the values to the callers offsets */

  01131	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01134	03 cd		 add	 ecx, ebp
  01136	c7 46 14 01 00
	00 00		 mov	 DWORD PTR [esi+20], 1
  0113d	89 56 04	 mov	 DWORD PTR [esi+4], edx
  01140	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx

; 2308 : 	}
; 2309 : 	/* ret_value->rule should be pointing to the character afterh the rule now */
; 2310 : 	ret_value->rule=new_ret.rule;

  01143	89 46 10	 mov	 DWORD PTR [esi+16], eax
  01146	5f		 pop	 edi
  01147	5e		 pop	 esi
  01148	5d		 pop	 ebp
  01149	5b		 pop	 ebx

; 2311 : #ifdef DEBUG
; 2312 : 	printf("leaving par_match_rule success\n");
; 2313 : #endif
; 2314 : }

  0114a	83 c4 40	 add	 esp, 64			; 00000040H
  0114d	c3		 ret	 0
$L72936:

; 2291 : 	}
; 2292 : 	else

  0114e	8b 6c 24 3c	 mov	 ebp, DWORD PTR _new_ret$[esp+92]
$L72937:
  01152	8b 54 24 38	 mov	 edx, DWORD PTR _new_ret$[esp+88]
$L71753:

; 2293 : 	{
; 2294 : #ifdef DEBUG
; 2295 : 		printf("par_match_rule;optional set to OPT_FAIL\n");
; 2296 : #endif
; 2297 : #ifdef INDEX_DEBUG2
; 2298 : 		printf("cleared indexes from %d to %d in the output, opt_fail\n",new_ret.output_pos,new_ret.output_pos+new_ret.output_offset);
; 2299 : #endif
; 2300 : 		memset(output_indexes+new_ret.output_pos,0,new_ret.output_offset*sizeof(index_data_t));

  01156	8b 7c 24 68	 mov	 edi, DWORD PTR _output_indexes$[esp+76]
  0115a	8d 4c 6d 00	 lea	 ecx, DWORD PTR [ebp+ebp*2]
  0115e	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  01161	33 c0		 xor	 eax, eax
  01163	d1 e1		 shl	 ecx, 1
  01165	8d 3c 57	 lea	 edi, DWORD PTR [edi+edx*2]
  01168	8b d1		 mov	 edx, ecx
  0116a	c1 e9 02	 shr	 ecx, 2
  0116d	f3 ab		 rep stosd
  0116f	8b ca		 mov	 ecx, edx
  01171	83 e1 03	 and	 ecx, 3
  01174	f3 aa		 rep stosb

; 2301 : 		if (state==BIN_OPTIONAL)

  01176	83 7c 24 58 16	 cmp	 DWORD PTR _state$[esp+76], 22 ; 00000016H
  0117b	75 1c		 jne	 SHORT $L71763

; 2302 : 		{
; 2303 : 			ret_value->rule=end_of_match+1;

  0117d	8b 44 24 10	 mov	 eax, DWORD PTR _end_of_match$[esp+80]

; 2304 : 			ret_value->value=SUCCESS;

  01181	c7 46 14 01 00
	00 00		 mov	 DWORD PTR [esi+20], 1
  01188	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0118d	5f		 pop	 edi
  0118e	40		 inc	 eax
  0118f	89 46 10	 mov	 DWORD PTR [esi+16], eax
  01192	5e		 pop	 esi
  01193	5d		 pop	 ebp
  01194	5b		 pop	 ebx

; 2311 : #ifdef DEBUG
; 2312 : 	printf("leaving par_match_rule success\n");
; 2313 : #endif
; 2314 : }

  01195	83 c4 40	 add	 esp, 64			; 00000040H
  01198	c3		 ret	 0
$L71763:

; 2305 : 			return;
; 2306 : 		}
; 2307 : 		ret_value->value=OPT_FAIL;

  01199	8b 44 24 40	 mov	 eax, DWORD PTR _new_ret$[esp+96]
  0119d	c7 46 14 02 00
	00 00		 mov	 DWORD PTR [esi+20], 2

; 2308 : 	}
; 2309 : 	/* ret_value->rule should be pointing to the character afterh the rule now */
; 2310 : 	ret_value->rule=new_ret.rule;

  011a4	89 46 10	 mov	 DWORD PTR [esi+16], eax
  011a7	5f		 pop	 edi
  011a8	5e		 pop	 esi
  011a9	5d		 pop	 ebp
  011aa	5b		 pop	 ebx

; 2311 : #ifdef DEBUG
; 2312 : 	printf("leaving par_match_rule success\n");
; 2313 : #endif
; 2314 : }

  011ab	83 c4 40	 add	 esp, 64			; 00000040H
  011ae	c3		 ret	 0
_par_match_rule ENDP
_output_array$ = 16
_output_indexes$ = 24
_ret_value$ = 32
_par_delete_string PROC NEAR

; 2519 : 	int	i,j,save_offset=0;
; 2520 : //055	MGS		10/14/1999	BATS#900 Fixed indexing in spanish phone numbers
; 2521 : 	index_data_t temp_index;
; 2522 : #ifdef DEBUG
; 2523 : 	printf("entering par_delete_string\n");
; 2524 : #endif
; 2525 : 	/*
; 2526 : 	*	check the inputs for valid data 
; 2527 : 	*/
; 2528 : #ifdef SANITY_CHECKING
; 2529 : 	if (ret_value==NULL)
; 2530 : 	{
; 2531 : #ifdef DEBUG
; 2532 : 		printf("leaving par_delete_string ret_value is NULL\n");
; 2533 : #endif
; 2534 : 		return;
; 2535 : 	}
; 2536 : 	if ((output_array==NULL))
; 2537 : 	{
; 2538 : 		ret_value->value=FATAL_FAIL;
; 2539 : #ifdef DEBUG
; 2540 : 		printf("leaving par_delete_string input is NULL\n");
; 2541 : #endif
; 2542 : 		return;
; 2543 : 	}                 
; 2544 : #endif
; 2545 : 	//055	MGS		10/14/1999	BATS#900 Fixed indexing in spanish phone numbers
; 2546 : 	save_offset=ret_value->output_offset+ret_value->output_pos;             

  011b0	8b 54 24 1c	 mov	 edx, DWORD PTR _ret_value$[esp-4]
  011b4	53		 push	 ebx

; 2547 : 	/* blank out the data being deleted */
; 2548 : 	memset((output_array+(ret_value->output_pos)),0,ret_value->output_offset);                              

  011b5	8b 5c 24 10	 mov	 ebx, DWORD PTR _output_array$[esp]
  011b9	55		 push	 ebp
  011ba	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  011bd	56		 push	 esi
  011be	57		 push	 edi
  011bf	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
  011c2	33 c0		 xor	 eax, eax
  011c4	8d 34 0f	 lea	 esi, DWORD PTR [edi+ecx]
  011c7	8b e9		 mov	 ebp, ecx
  011c9	03 fb		 add	 edi, ebx
  011cb	c1 e9 02	 shr	 ecx, 2
  011ce	f3 ab		 rep stosd
  011d0	8b cd		 mov	 ecx, ebp
  011d2	83 e1 03	 and	 ecx, 3
  011d5	f3 aa		 rep stosb

; 2549 : 	/* set the ouput_offset to 0 to logically delete the data from processing */
; 2550 : 	memset(&temp_index,0,sizeof(temp_index));
; 2551 : 	ret_value->output_offset=0;
; 2552 : 	for (j=i=ret_value->output_pos;i<save_offset;i++)

  011d7	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  011da	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
  011e1	3b ce		 cmp	 ecx, esi
  011e3	7d 5b		 jge	 SHORT $L71795
  011e5	8b 7c 24 24	 mov	 edi, DWORD PTR _output_indexes$[esp+12]
  011e9	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  011ec	03 d9		 add	 ebx, ecx
  011ee	2b f1		 sub	 esi, ecx
  011f0	8d 04 47	 lea	 eax, DWORD PTR [edi+eax*2]
  011f3	89 74 24 2c	 mov	 DWORD PTR 32+[esp+12], esi
  011f7	8b f8		 mov	 edi, eax
$L71793:

; 2553 : 	{
; 2554 : 		if (par_is_index_set(output_indexes,i))

  011f9	66 83 38 00	 cmp	 WORD PTR [eax], 0
  011fd	75 0e		 jne	 SHORT $L72957
  011ff	66 83 78 02 00	 cmp	 WORD PTR [eax+2], 0
  01204	75 07		 jne	 SHORT $L72957
  01206	66 83 78 04 00	 cmp	 WORD PTR [eax+4], 0
  0120b	74 25		 je	 SHORT $L71794
$L72957:

; 2555 : 		{
; 2556 : #ifdef INDEX_DEBUG
; 2557 : 			printf("copying index in delete state from %d to %d\n",i,j);
; 2558 : #endif
; 2559 : 			par_copy_index(output_indexes,j,output_indexes,i);

  0120d	8b c8		 mov	 ecx, eax
  0120f	8b f7		 mov	 esi, edi

; 2560 : 			/* kill the old index */
; 2561 : 			par_copy_index(output_indexes,i,&temp_index,0);
; 2562 : 			output_array[j]=PAR_INDEX_DUMMY_CHAR;
; 2563 : 			j++;

  01211	83 c7 06	 add	 edi, 6
  01214	8b 29		 mov	 ebp, DWORD PTR [ecx]
  01216	89 2e		 mov	 DWORD PTR [esi], ebp
  01218	66 8b 49 04	 mov	 cx, WORD PTR [ecx+4]
  0121c	66 89 4e 04	 mov	 WORD PTR [esi+4], cx
  01220	8b f0		 mov	 esi, eax
  01222	33 c9		 xor	 ecx, ecx
  01224	43		 inc	 ebx
  01225	89 0e		 mov	 DWORD PTR [esi], ecx
  01227	66 89 4e 04	 mov	 WORD PTR [esi+4], cx
  0122b	c6 43 ff 82	 mov	 BYTE PTR [ebx-1], 130	; 00000082H

; 2564 : 			ret_value->output_offset++;

  0122f	ff 42 0c	 inc	 DWORD PTR [edx+12]
$L71794:
  01232	8b 4c 24 2c	 mov	 ecx, DWORD PTR 32+[esp+12]
  01236	83 c0 06	 add	 eax, 6
  01239	49		 dec	 ecx
  0123a	89 4c 24 2c	 mov	 DWORD PTR 32+[esp+12], ecx
  0123e	75 b9		 jne	 SHORT $L71793
$L71795:
  01240	5f		 pop	 edi
  01241	5e		 pop	 esi
  01242	5d		 pop	 ebp
  01243	5b		 pop	 ebx

; 2565 : 		}
; 2566 : 	}
; 2567 : #ifdef DEBUG
; 2568 : 	printf("leaving par_delete_string string deleted\n");
; 2569 : #endif
; 2570 : }

  01244	c3		 ret	 0
_par_delete_string ENDP
_TEXT	ENDS
PUBLIC	_par_build_string_from_rule
_TEXT	SEGMENT
_current_rule$ = 8
_output_array$ = 16
_output_indexes$ = 24
_match_array$ = 28
_ret_value$ = 32
_range_value$ = 36
_in_rule_index$ = 48
_length$ = -708
_buf$ = -700
_temp_index$ = -600
_par_replace_string PROC NEAR

; 2611 : {

  01250	81 ec c4 02 00
	00		 sub	 esp, 708		; 000002c4H

; 2612 : 	int length;
; 2613 : 	int i,j;
; 2614 : 	unsigned char buf[100];
; 2615 : 	index_data_t  temp_index[100];
; 2616 : 	
; 2617 : 	
; 2618 : #if defined (DEBUG) || defined (INDEX_DEBUG)
; 2619 : 	printf("entering par_replace_string\n");
; 2620 : #endif
; 2621 : 	
; 2622 : 	memset(temp_index,0,100*sizeof(index_data_t));
; 2623 : 	/* 
; 2624 : 	*	check the inputs for valid data 
; 2625 : 	*/
; 2626 : #ifdef SANITY_CHECKING
; 2627 : 	if (ret_value==NULL)
; 2628 : 	{
; 2629 : #ifdef DEBUG
; 2630 : 		printf("leaving par_replace_string ret_value is NULL\n");
; 2631 : #endif
; 2632 : 		return;
; 2633 : 	}
; 2634 : 	if ((current_rule==NULL) || (output_array==NULL) || (match_array==NULL))
; 2635 : 	{
; 2636 : 		ret_value->value=FATAL_FAIL;
; 2637 : #ifdef DEBUG
; 2638 : 		printf("leaving par_replace_string inputs are invalid\n");
; 2639 : #endif
; 2640 : 		return;
; 2641 : 	}
; 2642 : #endif
; 2643 : 	/* 
; 2644 : 	*	build the string that is going to replace the current string bounded by
; 2645 : 	*	by output_pos and output_offset
; 2646 : 	*	then just copy the string built (null and all) on top of the current string
; 2647 : 	*/
; 2648 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_REPLACE,&length,in_rule_index);

  01256	8b 94 24 e4 02
	00 00		 mov	 edx, DWORD PTR _range_value$[esp+704]
  0125d	b9 96 00 00 00	 mov	 ecx, 150		; 00000096H
  01262	33 c0		 xor	 eax, eax
  01264	53		 push	 ebx
  01265	56		 push	 esi
  01266	57		 push	 edi
  01267	8b 9c 24 ec 02
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+716]
  0126e	8d 7c 24 78	 lea	 edi, DWORD PTR _temp_index$[esp+720]
  01272	f3 ab		 rep stosd
  01274	8b 84 24 fc 02
	00 00		 mov	 eax, DWORD PTR _in_rule_index$[esp+716]
  0127b	8d 4c 24 0c	 lea	 ecx, DWORD PTR _length$[esp+720]
  0127f	50		 push	 eax
  01280	8b 84 24 ec 02
	00 00		 mov	 eax, DWORD PTR _match_array$[esp+720]
  01287	51		 push	 ecx
  01288	8b 8c 24 e4 02
	00 00		 mov	 ecx, DWORD PTR _output_array$[esp+724]
  0128f	6a 19		 push	 25			; 00000019H
  01291	52		 push	 edx
  01292	53		 push	 ebx
  01293	50		 push	 eax
  01294	8b 84 24 ec 02
	00 00		 mov	 eax, DWORD PTR _current_rule$[esp+740]
  0129b	8d 54 24 2c	 lea	 edx, DWORD PTR _buf$[esp+744]
  0129f	51		 push	 ecx
  012a0	52		 push	 edx
  012a1	50		 push	 eax
  012a2	e8 00 00 00 00	 call	 _par_build_string_from_rule

; 2649 : 		/* have to do something with indexes so they don't appear in the middle of a word */
; 2650 : 	for (j=0,i=ret_value->output_pos;i<ret_value->output_pos+ret_value->output_offset;i++)

  012a7	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  012aa	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  012ad	03 ce		 add	 ecx, esi
  012af	83 c4 24	 add	 esp, 36			; 00000024H
  012b2	33 c0		 xor	 eax, eax
  012b4	3b f1		 cmp	 esi, ecx
  012b6	7d 7b		 jge	 SHORT $L71830
  012b8	8b bc 24 e4 02
	00 00		 mov	 edi, DWORD PTR _output_indexes$[esp+716]
  012bf	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  012c2	2b ce		 sub	 ecx, esi
  012c4	55		 push	 ebp
  012c5	8d 14 57	 lea	 edx, DWORD PTR [edi+edx*2]
  012c8	8b 7c 24 10	 mov	 edi, DWORD PTR _length$[esp+724]
  012cc	89 4c 24 14	 mov	 DWORD PTR -704+[esp+724], ecx
$L71828:

; 2651 : 	{
; 2652 : 		if (par_is_index_set(output_indexes,i))

  012d0	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  012d4	75 0e		 jne	 SHORT $L72974
  012d6	66 83 7a 02 00	 cmp	 WORD PTR [edx+2], 0
  012db	75 07		 jne	 SHORT $L72974
  012dd	66 83 7a 04 00	 cmp	 WORD PTR [edx+4], 0
  012e2	74 39		 je	 SHORT $L71829
$L72974:

; 2653 : 		{
; 2654 : 			/* find a space if there is one */
; 2655 : 			for (;j<length && buf[j]!=' ';j++);

  012e4	3b c7		 cmp	 eax, edi
  012e6	7d 10		 jge	 SHORT $L71835
$L71832:
  012e8	80 7c 04 18 20	 cmp	 BYTE PTR _buf$[esp+eax+724], 32 ; 00000020H
  012ed	0f 84 a6 00 00
	00		 je	 $L71834
  012f3	40		 inc	 eax
  012f4	3b c7		 cmp	 eax, edi
  012f6	7c f0		 jl	 SHORT $L71832
$L71835:

; 2667 : 			{
; 2668 : 				/* use the dummy character for the moved index */
; 2669 : 				buf[j]=PAR_INDEX_DUMMY_CHAR;
; 2670 : 				buf[j+1]='\0';     
; 2671 : #ifdef INDEX_DEBUG
; 2672 : 				printf("copying index in replace 2 from %d to buf %d\n",i,j);
; 2673 : #endif
; 2674 : 				par_copy_index(temp_index,j,output_indexes,i);

  012f8	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  012fb	8b da		 mov	 ebx, edx
  012fd	c6 44 04 18 82	 mov	 BYTE PTR _buf$[esp+eax+724], 130 ; 00000082H
  01302	c6 44 04 19 00	 mov	 BYTE PTR _buf$[esp+eax+725], 0
  01307	8b 2b		 mov	 ebp, DWORD PTR [ebx]
  01309	8d 4c 4c 7c	 lea	 ecx, DWORD PTR _temp_index$[esp+ecx*2+724]

; 2675 : 				j++;

  0130d	40		 inc	 eax

; 2676 : 				length++;

  0130e	47		 inc	 edi
  0130f	66 8b 5b 04	 mov	 bx, WORD PTR [ebx+4]
  01313	89 29		 mov	 DWORD PTR [ecx], ebp
  01315	89 7c 24 10	 mov	 DWORD PTR _length$[esp+724], edi
  01319	66 89 59 04	 mov	 WORD PTR [ecx+4], bx
$L71829:
  0131d	8b 4c 24 14	 mov	 ecx, DWORD PTR -704+[esp+724]
  01321	83 c2 06	 add	 edx, 6
  01324	49		 dec	 ecx
  01325	89 4c 24 14	 mov	 DWORD PTR -704+[esp+724], ecx
  01329	75 a5		 jne	 SHORT $L71828
  0132b	8b 9c 24 f0 02
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+720]
  01332	5d		 pop	 ebp
$L71830:

; 2677 : 			}       
; 2678 : 		}
; 2679 : 	}
; 2680 : 								
; 2681 : 	strcpy((output_array+(ret_value->output_pos)),buf);

  01333	8b 94 24 dc 02
	00 00		 mov	 edx, DWORD PTR _output_array$[esp+716]
  0133a	8d 7c 24 14	 lea	 edi, DWORD PTR _buf$[esp+720]
  0133e	83 c9 ff	 or	 ecx, -1
  01341	33 c0		 xor	 eax, eax
  01343	03 d6		 add	 edx, esi
  01345	f2 ae		 repne scasb
  01347	f7 d1		 not	 ecx
  01349	2b f9		 sub	 edi, ecx
  0134b	8b c1		 mov	 eax, ecx
  0134d	8b f7		 mov	 esi, edi
  0134f	8b fa		 mov	 edi, edx
  01351	c1 e9 02	 shr	 ecx, 2
  01354	f3 a5		 rep movsd
  01356	8b c8		 mov	 ecx, eax
  01358	83 e1 03	 and	 ecx, 3
  0135b	f3 a4		 rep movsb

; 2682 : 	/* copy the indexes too */
; 2683 : 	par_copy_index_list(output_indexes,ret_value->output_pos,temp_index,0,length);

  0135d	8b 44 24 0c	 mov	 eax, DWORD PTR _length$[esp+720]
  01361	8d 74 24 78	 lea	 esi, DWORD PTR _temp_index$[esp+720]
  01365	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  01368	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0136b	d1 e1		 shl	 ecx, 1
  0136d	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  01370	8b 84 24 e4 02
	00 00		 mov	 eax, DWORD PTR _output_indexes$[esp+716]
  01377	8d 3c 50	 lea	 edi, DWORD PTR [eax+edx*2]
  0137a	8b d1		 mov	 edx, ecx
  0137c	c1 e9 02	 shr	 ecx, 2
  0137f	f3 a5		 rep movsd
  01381	8b ca		 mov	 ecx, edx
  01383	83 e1 03	 and	 ecx, 3
  01386	f3 a4		 rep movsb

; 2684 : 	/* 
; 2685 : 	* the output offset is now the length of of the new output string 
; 2686 : 	*/
; 2687 : #ifdef DEBUG
; 2688 : 	printf("par_replace_string; length=%d\n",length);
; 2689 : #endif	
; 2690 : 	ret_value->output_offset=length;

  01388	8b 44 24 0c	 mov	 eax, DWORD PTR _length$[esp+720]
  0138c	5f		 pop	 edi
  0138d	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  01390	5e		 pop	 esi
  01391	5b		 pop	 ebx

; 2691 : 	//	ret_value->rule++;
; 2692 : #ifdef DEBUG
; 2693 : 	printf("leaving replace_state replacement is successful\n");
; 2694 : #endif
; 2695 : }

  01392	81 c4 c4 02 00
	00		 add	 esp, 708		; 000002c4H
  01398	c3		 ret	 0
$L71834:

; 2656 : 			if (j<length)

  01399	3b c7		 cmp	 eax, edi
  0139b	0f 8d 57 ff ff
	ff		 jge	 $L71835

; 2657 : 			{
; 2658 : #ifdef INDEX_DEBUG
; 2659 : 				printf("copying index in replace 1 from %d to buf %d\n",i,j);
; 2660 : #endif
; 2661 : 				par_copy_index(temp_index,j,output_indexes,i);

  013a1	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  013a4	8b da		 mov	 ebx, edx

; 2662 : 				//055	MGS		10/14/1999	BATS#900 Fixed indexing in spanish phone numbers
; 2663 : 				buf[j]=PAR_INDEX_DUMMY_CHAR;
; 2664 : 				j++;

  013a6	40		 inc	 eax
  013a7	8b 2b		 mov	 ebp, DWORD PTR [ebx]
  013a9	8d 4c 4c 7c	 lea	 ecx, DWORD PTR _temp_index$[esp+ecx*2+724]
  013ad	66 8b 5b 04	 mov	 bx, WORD PTR [ebx+4]
  013b1	89 29		 mov	 DWORD PTR [ecx], ebp
  013b3	c6 44 04 17 82	 mov	 BYTE PTR _buf$[esp+eax+723], 130 ; 00000082H
  013b8	66 89 59 04	 mov	 WORD PTR [ecx+4], bx

; 2665 : 			}
; 2666 : 			else

  013bc	e9 5c ff ff ff	 jmp	 $L71829
_par_replace_string ENDP
_TEXT	ENDS
PUBLIC	_par_break_down_word
EXTRN	_noun_num_character_in_mapping:DWORD
_TEXT	SEGMENT
_output_array$ = 16
_ret_value$ = 32
_new_input$ = -200
_new_output$ = -100
_par_compound_break PROC NEAR

; 2711 : 	int num_matched;
; 2712 : 	char new_input[100];
; 2713 : 	char new_output[100];
; 2714 : 
; 2715 : #ifdef DEBUG
; 2716 : 	printf("entering par_compound_break\n");
; 2717 : #endif
; 2718 : 
; 2719 : 	if (noun_num_character_in_mapping==0)

  013d0	a1 00 00 00 00	 mov	 eax, DWORD PTR _noun_num_character_in_mapping
  013d5	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  013db	85 c0		 test	 eax, eax
  013dd	53		 push	 ebx
  013de	55		 push	 ebp
  013df	56		 push	 esi
  013e0	57		 push	 edi
  013e1	0f 84 93 00 00
	00		 je	 $L71868

; 2720 : 	{
; 2721 : #ifdef DEBUG
; 2722 : 		printf("leaving par_compound_break, no table loaded\n");
; 2723 : #endif
; 2724 : 		return;
; 2725 : 	}
; 2726 : 
; 2727 : 	memcpy(new_input,output_array+ret_value->output_pos,ret_value->output_offset);

  013e7	8b ac 24 f4 00
	00 00		 mov	 ebp, DWORD PTR _ret_value$[esp+212]
  013ee	8b 9c 24 e4 00
	00 00		 mov	 ebx, DWORD PTR _output_array$[esp+212]
  013f5	8b f3		 mov	 esi, ebx
  013f7	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
  013fa	8b 7d 08	 mov	 edi, DWORD PTR [ebp+8]
  013fd	8b c8		 mov	 ecx, eax
  013ff	03 f7		 add	 esi, edi
  01401	8b d1		 mov	 edx, ecx
  01403	8d 7c 24 10	 lea	 edi, DWORD PTR _new_input$[esp+216]
  01407	c1 e9 02	 shr	 ecx, 2
  0140a	f3 a5		 rep movsd
  0140c	8b ca		 mov	 ecx, edx
  0140e	83 e1 03	 and	 ecx, 3
  01411	f3 a4		 rep movsb

; 2728 : 	new_input[ret_value->output_offset]='\0';

  01413	c6 44 04 10 00	 mov	 BYTE PTR _new_input$[esp+eax+216], 0

; 2729 : 	memset(new_output,0,100);

  01418	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  0141d	33 c0		 xor	 eax, eax
  0141f	8d 7c 24 74	 lea	 edi, DWORD PTR _new_output$[esp+216]
  01423	f3 ab		 rep stosd

; 2730 : 
; 2731 : 	num_matched=par_break_down_word(new_input,new_output);

  01425	8d 44 24 74	 lea	 eax, DWORD PTR _new_output$[esp+216]
  01429	8d 4c 24 10	 lea	 ecx, DWORD PTR _new_input$[esp+216]
  0142d	50		 push	 eax
  0142e	51		 push	 ecx
  0142f	e8 00 00 00 00	 call	 _par_break_down_word
  01434	83 c4 08	 add	 esp, 8

; 2732 : 
; 2733 : 	if (num_matched>0)

  01437	85 c0		 test	 eax, eax
  01439	7e 29		 jle	 SHORT $L71866

; 2734 : 	{
; 2735 : 		memcpy(output_array+ret_value->output_pos,new_output,num_matched);

  0143b	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  0143e	8b fb		 mov	 edi, ebx
  01440	8b c8		 mov	 ecx, eax
  01442	03 fa		 add	 edi, edx
  01444	8b d1		 mov	 edx, ecx
  01446	8d 74 24 74	 lea	 esi, DWORD PTR _new_output$[esp+216]
  0144a	c1 e9 02	 shr	 ecx, 2
  0144d	f3 a5		 rep movsd
  0144f	8b ca		 mov	 ecx, edx
  01451	83 e1 03	 and	 ecx, 3
  01454	f3 a4		 rep movsb
  01456	5f		 pop	 edi

; 2736 : 		ret_value->output_offset=num_matched;

  01457	89 45 0c	 mov	 DWORD PTR [ebp+12], eax
  0145a	5e		 pop	 esi
  0145b	5d		 pop	 ebp
  0145c	5b		 pop	 ebx

; 2749 : 		}
; 2750 : 	}
; 2751 : 
; 2752 : #ifdef DEBUG
; 2753 : 	printf("leaving par_compound_break\n");
; 2754 : #endif
; 2755 : 
; 2756 : 	/* rewrite the word breaker code and the word finder code */
; 2757 : 	/* the word breaker should return the number of characters
; 2758 : 	   that are in the output if successful, or -1 if failed */
; 2759 : 	/* create a new header file for the structure used in here */
; 2760 : 
; 2761 : 
; 2762 : 	/* write a file loader */
; 2763 : 	/* the file loader has to be load the file for german, and not for any other language */
; 2764 : 	/* the file loader has to globally allocate the memory, and the other threads
; 2765 : 	   have to use it */
; 2766 : }

  0145d	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  01463	c3		 ret	 0
$L71866:

; 2737 : 	}
; 2738 : 	else
; 2739 : 	{
; 2740 : 
; 2741 : 		ret_value->value=FAIL;
; 2742 : 
; 2743 : 		if (ret_value->optional==1)

  01464	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  01467	c7 45 14 00 00
	00 00		 mov	 DWORD PTR [ebp+20], 0
  0146e	83 f8 01	 cmp	 eax, 1
  01471	75 07		 jne	 SHORT $L71868

; 2744 : 		{
; 2745 : #ifdef DEBUG
; 2746 : 			printf("set optional to opt_fail\n");
; 2747 : #endif
; 2748 : 			ret_value->value=OPT_FAIL;

  01473	c7 45 14 02 00
	00 00		 mov	 DWORD PTR [ebp+20], 2
$L71868:
  0147a	5f		 pop	 edi
  0147b	5e		 pop	 esi
  0147c	5d		 pop	 ebp
  0147d	5b		 pop	 ebx

; 2749 : 		}
; 2750 : 	}
; 2751 : 
; 2752 : #ifdef DEBUG
; 2753 : 	printf("leaving par_compound_break\n");
; 2754 : #endif
; 2755 : 
; 2756 : 	/* rewrite the word breaker code and the word finder code */
; 2757 : 	/* the word breaker should return the number of characters
; 2758 : 	   that are in the output if successful, or -1 if failed */
; 2759 : 	/* create a new header file for the structure used in here */
; 2760 : 
; 2761 : 
; 2762 : 	/* write a file loader */
; 2763 : 	/* the file loader has to be load the file for german, and not for any other language */
; 2764 : 	/* the file loader has to globally allocate the memory, and the other threads
; 2765 : 	   have to use it */
; 2766 : }

  0147e	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  01484	c3		 ret	 0
_par_compound_break ENDP
_TEXT	ENDS
PUBLIC	_par_find_word_in_dict
EXTRN	_par_upper:BYTE
EXTRN	_noun_number_of_conjunctions:DWORD
EXTRN	_noun_conjunction:BYTE
_TEXT	SEGMENT
_input$ = 8
_output$ = 12
_i$ = -56
_j$ = 12
_number_of_pos$ = -48
_positions$ = -40
_par_break_down_word PROC NEAR

; 2769 : {

  01490	83 ec 38	 sub	 esp, 56			; 00000038H

; 2770 : 	int i,j;
; 2771 : 	int head=1;
; 2772 : 	int number_of_pos=0;
; 2773 : 	int positions[10];
; 2774 : 	int result;
; 2775 : 
; 2776 : #ifdef DEBUG
; 2777 : 	printf("entering par_break_down_word %s\n",input);
; 2778 : #endif
; 2779 : 	result=par_find_word_in_dict(head,input,positions,0,&number_of_pos);

  01493	8b 54 24 3c	 mov	 edx, DWORD PTR _input$[esp+52]
  01497	53		 push	 ebx
  01498	55		 push	 ebp
  01499	56		 push	 esi
  0149a	8d 44 24 14	 lea	 eax, DWORD PTR _number_of_pos$[esp+68]
  0149e	57		 push	 edi
  0149f	50		 push	 eax
  014a0	8d 4c 24 24	 lea	 ecx, DWORD PTR _positions$[esp+76]
  014a4	6a 00		 push	 0
  014a6	51		 push	 ecx
  014a7	52		 push	 edx
  014a8	6a 01		 push	 1
  014aa	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _number_of_pos$[esp+92], 0
  014b2	e8 00 00 00 00	 call	 _par_find_word_in_dict
  014b7	83 c4 14	 add	 esp, 20			; 00000014H

; 2780 : 	if (result==0)

  014ba	85 c0		 test	 eax, eax

; 2781 : 	{
; 2782 : #ifdef DEBUG
; 2783 : 		printf("leaving par_break_down_word no matches\n");
; 2784 : #endif
; 2785 : 		return(-1);

  014bc	0f 84 07 01 00
	00		 je	 $L71883

; 2786 : 	}
; 2787 : 	for (i=number_of_pos-1;i>=0;i--)

  014c2	8b 44 24 18	 mov	 eax, DWORD PTR _number_of_pos$[esp+72]
  014c6	48		 dec	 eax
  014c7	85 c0		 test	 eax, eax
  014c9	89 44 24 10	 mov	 DWORD PTR _i$[esp+72], eax
  014cd	0f 8c f6 00 00
	00		 jl	 $L71883
  014d3	8b 6c 24 50	 mov	 ebp, DWORD PTR _output$[esp+68]
  014d7	8d 5c 84 20	 lea	 ebx, DWORD PTR _positions$[esp+eax*4+72]
  014db	89 5c 24 14	 mov	 DWORD PTR -52+[esp+72], ebx
$L71881:

; 2788 : 	{
; 2789 : 		memcpy(output,input,positions[i]);

  014df	8b 03		 mov	 eax, DWORD PTR [ebx]
  014e1	8b 74 24 4c	 mov	 esi, DWORD PTR _input$[esp+68]
  014e5	8b c8		 mov	 ecx, eax
  014e7	8b fd		 mov	 edi, ebp
  014e9	8b d1		 mov	 edx, ecx
  014eb	c1 e9 02	 shr	 ecx, 2
  014ee	f3 a5		 rep movsd
  014f0	8b ca		 mov	 ecx, edx
  014f2	83 e1 03	 and	 ecx, 3
  014f5	f3 a4		 rep movsb

; 2790 : 		/* MGS make the first character of the new word uppercase */
; 2791 : 		output[0]=par_upper[output[0]];

  014f7	33 c9		 xor	 ecx, ecx

; 2792 : 		output[positions[i]]='\0';
; 2793 : 		output[positions[i]+1]='\0';
; 2794 : 		if (input[positions[i]]=='\0')

  014f9	8b 7c 24 4c	 mov	 edi, DWORD PTR _input$[esp+68]
  014fd	8a 4d 00	 mov	 cl, BYTE PTR [ebp]
  01500	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR _par_upper[ecx]
  01506	88 55 00	 mov	 BYTE PTR [ebp], dl
  01509	c6 04 28 00	 mov	 BYTE PTR [eax+ebp], 0
  0150d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0150f	c6 44 28 01 00	 mov	 BYTE PTR [eax+ebp+1], 0
  01514	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  01516	80 3c 39 00	 cmp	 BYTE PTR [ecx+edi], 0
  0151a	0f 84 b4 00 00
	00		 je	 $L72999

; 2797 : 		}
; 2798 : 		if (noun_number_of_conjunctions>0)

  01520	a1 00 00 00 00	 mov	 eax, DWORD PTR _noun_number_of_conjunctions
  01525	85 c0		 test	 eax, eax
  01527	0f 8e 84 00 00
	00		 jle	 $L71882

; 2799 : 		{
; 2800 : 			for (j=0;j<noun_number_of_conjunctions;j++)

  0152d	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_noun_conjunction
  01532	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR _j$[esp+68], 0
  0153a	89 74 24 1c	 mov	 DWORD PTR -44+[esp+72], esi
  0153e	eb 04		 jmp	 SHORT $L71886
$L73006:
  01540	8b 7c 24 4c	 mov	 edi, DWORD PTR _input$[esp+68]
$L71886:

; 2801 : 			{
; 2802 : 				if (noun_conjunction[j].length==0)

  01544	8b 06		 mov	 eax, DWORD PTR [esi]
  01546	85 c0		 test	 eax, eax
  01548	75 1c		 jne	 SHORT $L71889

; 2803 : 				{
; 2804 : 					result=par_break_down_word(input+positions[i],output+positions[i]+1);

  0154a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0154c	8d 54 28 01	 lea	 edx, DWORD PTR [eax+ebp+1]
  01550	03 c7		 add	 eax, edi
  01552	52		 push	 edx
  01553	50		 push	 eax
  01554	e8 00 00 00 00	 call	 _par_break_down_word
  01559	83 c4 08	 add	 esp, 8

; 2805 : 					if (result>0)

  0155c	85 c0		 test	 eax, eax
  0155e	0f 8f 80 00 00
	00		 jg	 $L72997

; 2812 : 					}
; 2813 : 				}
; 2814 : 				else

  01564	eb 2d		 jmp	 SHORT $L71887
$L71889:

; 2815 : 				{
; 2816 : 					if (memcmp(noun_conjunction[j].conj,input+positions[i],noun_conjunction[j].length)==0)

  01566	8b 13		 mov	 edx, DWORD PTR [ebx]
  01568	83 c6 04	 add	 esi, 4
  0156b	03 fa		 add	 edi, edx
  0156d	8b c8		 mov	 ecx, eax
  0156f	33 db		 xor	 ebx, ebx
  01571	f3 a6		 repe cmpsb
  01573	75 1a		 jne	 SHORT $L73003

; 2817 : 					{
; 2818 : 						result=par_break_down_word(input+positions[i]+noun_conjunction[j].length,output+positions[i]+noun_conjunction[j].length+1);

  01575	03 c2		 add	 eax, edx
  01577	8b 54 24 4c	 mov	 edx, DWORD PTR _input$[esp+68]
  0157b	8d 4c 28 01	 lea	 ecx, DWORD PTR [eax+ebp+1]
  0157f	03 c2		 add	 eax, edx
  01581	51		 push	 ecx
  01582	50		 push	 eax
  01583	e8 00 00 00 00	 call	 _par_break_down_word
  01588	83 c4 08	 add	 esp, 8

; 2819 : 						if (result>0)

  0158b	85 c0		 test	 eax, eax
  0158d	7f 73		 jg	 SHORT $L72998
$L73003:
  0158f	8b 5c 24 14	 mov	 ebx, DWORD PTR -52+[esp+72]
$L71887:

; 2799 : 		{
; 2800 : 			for (j=0;j<noun_number_of_conjunctions;j++)

  01593	8b 44 24 50	 mov	 eax, DWORD PTR _j$[esp+68]
  01597	8b 74 24 1c	 mov	 esi, DWORD PTR -44+[esp+72]
  0159b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _noun_number_of_conjunctions
  015a1	40		 inc	 eax
  015a2	83 c6 08	 add	 esi, 8
  015a5	3b c1		 cmp	 eax, ecx
  015a7	89 44 24 50	 mov	 DWORD PTR _j$[esp+68], eax
  015ab	89 74 24 1c	 mov	 DWORD PTR -44+[esp+72], esi
  015af	7c 8f		 jl	 SHORT $L73006
$L71882:

; 2786 : 	}
; 2787 : 	for (i=number_of_pos-1;i>=0;i--)

  015b1	8b 44 24 10	 mov	 eax, DWORD PTR _i$[esp+72]
  015b5	83 eb 04	 sub	 ebx, 4
  015b8	48		 dec	 eax
  015b9	89 5c 24 14	 mov	 DWORD PTR -52+[esp+72], ebx
  015bd	85 c0		 test	 eax, eax
  015bf	89 44 24 10	 mov	 DWORD PTR _i$[esp+72], eax
  015c3	0f 8d 16 ff ff
	ff		 jge	 $L71881
$L71883:
  015c9	5f		 pop	 edi
  015ca	5e		 pop	 esi
  015cb	5d		 pop	 ebp

; 2828 : 						}
; 2829 : 					}
; 2830 : 				}
; 2831 : 			}
; 2832 : 		}
; 2833 : 		/* insert code for connecting characters here */
; 2834 : 		/* remove the connections in reverse order from longest to shortest */
; 2835 : 	}
; 2836 : #ifdef DEBUG
; 2837 : 	printf("leaving par_break_down_word failure %s %s\n",input,output);
; 2838 : #endif
; 2839 : 	return(-1);

  015cc	83 c8 ff	 or	 eax, -1
  015cf	5b		 pop	 ebx

; 2840 : 
; 2841 : }

  015d0	83 c4 38	 add	 esp, 56			; 00000038H
  015d3	c3		 ret	 0
$L72999:

; 2795 : 		{
; 2796 : 			return(positions[i]);

  015d4	8b 44 24 10	 mov	 eax, DWORD PTR _i$[esp+72]
  015d8	5f		 pop	 edi
  015d9	5e		 pop	 esi
  015da	5d		 pop	 ebp
  015db	8b 44 84 14	 mov	 eax, DWORD PTR _positions$[esp+eax*4+60]
  015df	5b		 pop	 ebx

; 2840 : 
; 2841 : }

  015e0	83 c4 38	 add	 esp, 56			; 00000038H
  015e3	c3		 ret	 0
$L72997:

; 2806 : 					{
; 2807 : 						output[positions[i]]='-';

  015e4	8b 4c 24 10	 mov	 ecx, DWORD PTR _i$[esp+72]
  015e8	5f		 pop	 edi
  015e9	5e		 pop	 esi
  015ea	8b 54 8c 18	 mov	 edx, DWORD PTR _positions$[esp+ecx*4+64]
  015ee	8d 4c 8c 18	 lea	 ecx, DWORD PTR _positions$[esp+ecx*4+64]
  015f2	c6 04 2a 2d	 mov	 BYTE PTR [edx+ebp], 45	; 0000002dH

; 2808 : #ifdef DEBUG
; 2809 : 						printf("leaving par_break_down_word no conj %s %s %d\n",input,output,result+positions[i]+1);
; 2810 : #endif
; 2811 : 						return(result+positions[i]+1);

  015f6	8b 09		 mov	 ecx, DWORD PTR [ecx]
  015f8	5d		 pop	 ebp
  015f9	5b		 pop	 ebx
  015fa	8d 44 08 01	 lea	 eax, DWORD PTR [eax+ecx+1]

; 2840 : 
; 2841 : }

  015fe	83 c4 38	 add	 esp, 56			; 00000038H
  01601	c3		 ret	 0
$L72998:

; 2820 : 						{
; 2821 : 							memcpy(output+positions[i],noun_conjunction[j].conj,noun_conjunction[j].length);

  01602	8b 74 24 50	 mov	 esi, DWORD PTR _j$[esp+68]
  01606	8b 4c 24 10	 mov	 ecx, DWORD PTR _i$[esp+72]
  0160a	8b fd		 mov	 edi, ebp
  0160c	03 7c 8c 20	 add	 edi, DWORD PTR _positions$[esp+ecx*4+72]
  01610	8d 14 f5 00 00
	00 00		 lea	 edx, DWORD PTR _noun_conjunction[esi*8]
  01617	8d 5c 8c 20	 lea	 ebx, DWORD PTR _positions$[esp+ecx*4+72]
  0161b	8d 34 f5 04 00
	00 00		 lea	 esi, DWORD PTR _noun_conjunction[esi*8+4]
  01622	8b 0a		 mov	 ecx, DWORD PTR [edx]
  01624	89 5c 24 4c	 mov	 DWORD PTR 8+[esp+68], ebx
  01628	8b d9		 mov	 ebx, ecx
  0162a	c1 e9 02	 shr	 ecx, 2
  0162d	f3 a5		 rep movsd
  0162f	8b cb		 mov	 ecx, ebx
  01631	83 e1 03	 and	 ecx, 3
  01634	f3 a4		 rep movsb

; 2822 : 							output[positions[i]+noun_conjunction[j].length]='-';

  01636	8b 4c 24 4c	 mov	 ecx, DWORD PTR 8+[esp+68]
  0163a	8b 3a		 mov	 edi, DWORD PTR [edx]
  0163c	03 ef		 add	 ebp, edi
  0163e	5f		 pop	 edi
  0163f	8b 31		 mov	 esi, DWORD PTR [ecx]
  01641	c6 04 2e 2d	 mov	 BYTE PTR [esi+ebp], 45	; 0000002dH

; 2823 : 
; 2824 : #ifdef DEBUG
; 2825 : 							printf("leaving par_break_down_word conj %s %s %d\n",input,output,result+positions[i]+1);
; 2826 : #endif
; 2827 : 							return(result+positions[i]+noun_conjunction[j].length+1);

  01645	8b 32		 mov	 esi, DWORD PTR [edx]
  01647	8b 11		 mov	 edx, DWORD PTR [ecx]
  01649	03 c6		 add	 eax, esi
  0164b	5e		 pop	 esi
  0164c	5d		 pop	 ebp
  0164d	8d 44 10 01	 lea	 eax, DWORD PTR [eax+edx+1]
  01651	5b		 pop	 ebx

; 2840 : 
; 2841 : }

  01652	83 c4 38	 add	 esp, 56			; 00000038H
  01655	c3		 ret	 0
_par_break_down_word ENDP
_TEXT	ENDS
EXTRN	_noun_character_mapping_table:BYTE
EXTRN	_noun_index_table:BYTE
EXTRN	_noun_data_table:BYTE
_TEXT	SEGMENT
_head$ = 8
_word$ = 12
_positions$ = 16
_depth$ = 20
_num_pos$ = 24
_par_find_word_in_dict PROC NEAR

; 2845 : 	//removed unused vairable 
; 2846 : 	//int i;
; 2847 : 	comp_noun_table_entry *cur;
; 2848 : 	if (head==NOUN_UNUSED_ENTRY)

  01660	8b 44 24 04	 mov	 eax, DWORD PTR _head$[esp-4]
  01664	8b 54 24 14	 mov	 edx, DWORD PTR _num_pos$[esp-4]
  01668	53		 push	 ebx
  01669	55		 push	 ebp
  0166a	56		 push	 esi
  0166b	83 f8 ff	 cmp	 eax, -1
  0166e	57		 push	 edi
  0166f	74 5c		 je	 SHORT $L73011
  01671	8b 6c 24 20	 mov	 ebp, DWORD PTR _depth$[esp+12]
  01675	8b 74 24 18	 mov	 esi, DWORD PTR _word$[esp+12]
$L73008:

; 2849 : 	{
; 2850 : 		if (*num_pos>0)
; 2851 : 		{
; 2852 : 			return(1);
; 2853 : 		}
; 2854 : 		else
; 2855 : 		{
; 2856 : 			return(0);
; 2857 : 		}
; 2858 : 	}
; 2859 : 	if (head==0)

  01679	85 c0		 test	 eax, eax
  0167b	74 5e		 je	 SHORT $L73012

; 2864 : 	}
; 2865 : 	cur= (comp_noun_table_entry *)(&(noun_data_table[noun_index_table[head]]));

  0167d	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _noun_index_table[eax*4]
  01684	05 00 00 00 00	 add	 eax, OFFSET FLAT:_noun_data_table

; 2866 : 	if (cur->word_ending & 1)

  01689	f6 00 01	 test	 BYTE PTR [eax], 1
  0168c	74 0e		 je	 SHORT $L71911

; 2867 : 	{
; 2868 : 		positions[*num_pos]=depth;

  0168e	8b 0a		 mov	 ecx, DWORD PTR [edx]
  01690	8b 7c 24 1c	 mov	 edi, DWORD PTR _positions$[esp+12]
  01694	89 2c 8f	 mov	 DWORD PTR [edi+ecx*4], ebp

; 2869 : 		(*num_pos)++;

  01697	8b 0a		 mov	 ecx, DWORD PTR [edx]
  01699	41		 inc	 ecx
  0169a	89 0a		 mov	 DWORD PTR [edx], ecx
$L71911:

; 2870 : 	}
; 2871 : 	if (cur->word_ending & 2)

  0169c	f6 00 02	 test	 BYTE PTR [eax], 2
  0169f	75 52		 jne	 SHORT $L73013

; 2878 : 		}
; 2879 : 		else
; 2880 : 		{
; 2881 : 			if (*num_pos>0)
; 2882 : 			{
; 2883 : 				return(1);
; 2884 : 			}
; 2885 : 			else
; 2886 : 			{
; 2887 : 				return(0);
; 2888 : 			}
; 2889 : 		}
; 2890 : 	}
; 2891 : 	if (word[0]=='\0')

  016a1	8a 0e		 mov	 cl, BYTE PTR [esi]
  016a3	84 c9		 test	 cl, cl
  016a5	74 26		 je	 SHORT $L73011

; 2892 : 	{
; 2893 : 		if (*num_pos>0)
; 2894 : 		{
; 2895 : 			return(1);
; 2896 : 		}
; 2897 : 		else
; 2898 : 		{
; 2899 : 			return(0);
; 2900 : 		}
; 2901 : 	}
; 2902 : 	if (noun_character_mapping_table[word[0]]==NOUN_UNUSED_ENTRY)

  016a7	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  016ad	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _noun_character_mapping_table[ecx*4]
  016b4	83 f9 ff	 cmp	 ecx, -1
  016b7	74 14		 je	 SHORT $L73011

; 2903 : 	{
; 2904 : 		if (*num_pos>0)
; 2905 : 		{
; 2906 : 			return(1);
; 2907 : 		}
; 2908 : 		else
; 2909 : 		{
; 2910 : 			return(0);
; 2911 : 		}
; 2912 : 	}
; 2913 : 	if (noun_character_mapping_table[word[0]]>(cur->length))

  016b9	0f be 78 01	 movsx	 edi, BYTE PTR [eax+1]
  016bd	3b cf		 cmp	 ecx, edi
  016bf	7f 0c		 jg	 SHORT $L73011

; 2916 : 		{
; 2917 : 			return(1);
; 2918 : 		}
; 2919 : 		else
; 2920 : 		{
; 2921 : 			return(0);
; 2922 : 		}
; 2923 : 	}
; 2924 : 	return(par_find_word_in_dict(cur->foo.entries[noun_character_mapping_table[word[0]]],word+1,positions,depth+1,num_pos));

  016c1	0f bf 44 48 02	 movsx	 eax, WORD PTR [eax+ecx*2+2]
  016c6	45		 inc	 ebp
  016c7	46		 inc	 esi
  016c8	83 f8 ff	 cmp	 eax, -1
  016cb	75 ac		 jne	 SHORT $L73008
$L73011:

; 2914 : 	{
; 2915 : 		if (*num_pos>0)

  016cd	8b 0a		 mov	 ecx, DWORD PTR [edx]
  016cf	33 c0		 xor	 eax, eax
  016d1	5f		 pop	 edi
  016d2	5e		 pop	 esi
  016d3	85 c9		 test	 ecx, ecx
  016d5	5d		 pop	 ebp
  016d6	5b		 pop	 ebx
  016d7	0f 9f c0	 setg	 al

; 2925 : }

  016da	c3		 ret	 0
$L73012:

; 2860 : 	{
; 2861 : 		positions[*num_pos]=depth;

  016db	8b 02		 mov	 eax, DWORD PTR [edx]
  016dd	8b 4c 24 1c	 mov	 ecx, DWORD PTR _positions$[esp+12]
  016e1	5f		 pop	 edi
  016e2	5e		 pop	 esi
  016e3	89 2c 81	 mov	 DWORD PTR [ecx+eax*4], ebp

; 2862 : 		(*num_pos)++;

  016e6	8b 02		 mov	 eax, DWORD PTR [edx]
  016e8	40		 inc	 eax
  016e9	5d		 pop	 ebp
  016ea	89 02		 mov	 DWORD PTR [edx], eax

; 2863 : 		return(1);

  016ec	b8 01 00 00 00	 mov	 eax, 1
  016f1	5b		 pop	 ebx

; 2925 : }

  016f2	c3		 ret	 0
$L73013:

; 2872 : 	{
; 2873 : 	  if (memcmp(word,cur->foo.rest_of_word,cur->length)==0)

  016f3	0f be 58 01	 movsx	 ebx, BYTE PTR [eax+1]
  016f7	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
  016fa	8b cb		 mov	 ecx, ebx
  016fc	33 c0		 xor	 eax, eax
  016fe	f3 a6		 repe cmpsb
  01700	75 cb		 jne	 SHORT $L73011

; 2874 : 		{
; 2875 : 			positions[*num_pos]=depth+cur->length;

  01702	8b 0a		 mov	 ecx, DWORD PTR [edx]
  01704	8b 44 24 1c	 mov	 eax, DWORD PTR _positions$[esp+12]
  01708	03 dd		 add	 ebx, ebp
  0170a	5f		 pop	 edi
  0170b	89 1c 88	 mov	 DWORD PTR [eax+ecx*4], ebx

; 2876 : 			(*num_pos)++;

  0170e	8b 02		 mov	 eax, DWORD PTR [edx]
  01710	40		 inc	 eax
  01711	5e		 pop	 esi
  01712	89 02		 mov	 DWORD PTR [edx], eax
  01714	5d		 pop	 ebp

; 2877 : 			return(1);

  01715	b8 01 00 00 00	 mov	 eax, 1
  0171a	5b		 pop	 ebx

; 2925 : }

  0171b	c3		 ret	 0
_par_find_word_in_dict ENDP
_TEXT	ENDS
PUBLIC	_par_insert_string_before
PUBLIC	_par_insert_string_after
_TEXT	SEGMENT
_current_rule$ = 8
_input_array$ = 12
_output_array$ = 16
_input_indexes$ = 20
_output_indexes$ = 24
_match_array$ = 28
_ret_value$ = 32
_range_value$ = 36
_save_num$ = 40
_dict_state_flag$ = 44
_in_rule_index$ = 48
_insert_operation_flags$ = 52
_buf$ = -100
_length$ = 48
_new_length$ = 16
_temp_index$ = -108
_par_insert_string PROC NEAR

; 2970 : {

  01720	83 ec 6c	 sub	 esp, 108		; 0000006cH

; 2971 : 	unsigned char buf[100];
; 2972 : 	int length,new_length;
; 2973 : 	int pos,new_loc,off;
; 2974 : 	//055	MGS		10/14/1999	BATS#900 Fixed indexing in spanish phone numbers
; 2975 : 	int i;
; 2976 : 	index_data_t temp_index={0,0,0};

  01723	33 c0		 xor	 eax, eax
  01725	66 89 44 24 00	 mov	 WORD PTR _temp_index$[esp+108], ax
  0172a	66 89 44 24 02	 mov	 WORD PTR _temp_index$[esp+110], ax
  0172f	66 89 44 24 04	 mov	 WORD PTR _temp_index$[esp+112], ax

; 2977 : 	
; 2978 : #ifdef GERMAN_COMPOUND_NOUNS
; 2979 : 	if (insert_operation_flags & BIN_AFTER_FLAG)

  01734	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR _insert_operation_flags$[esp+104]
  0173b	a8 40		 test	 al, 64			; 00000040H
  0173d	74 65		 je	 SHORT $L71959

; 2980 : 	{
; 2981 : 		par_insert_string_after(current_rule,input_array,output_array,input_indexes,output_indexes,match_array,ret_value,range_value,save_num,dict_state_flag,in_rule_index,insert_operation_flags);

  0173f	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _dict_state_flag$[esp+104]
  01746	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR _save_num$[esp+104]
  0174d	50		 push	 eax
  0174e	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR _in_rule_index$[esp+108]
  01755	50		 push	 eax
  01756	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _range_value$[esp+112]
  0175d	51		 push	 ecx
  0175e	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _ret_value$[esp+116]
  01765	52		 push	 edx
  01766	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR _match_array$[esp+120]
  0176d	50		 push	 eax
  0176e	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _output_indexes$[esp+124]
  01775	51		 push	 ecx
  01776	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _input_indexes$[esp+128]
  0177d	52		 push	 edx
  0177e	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR _output_array$[esp+132]
  01785	50		 push	 eax
  01786	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _input_array$[esp+136]
  0178d	51		 push	 ecx
  0178e	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _current_rule$[esp+140]
  01795	52		 push	 edx
  01796	50		 push	 eax
  01797	51		 push	 ecx
  01798	e8 00 00 00 00	 call	 _par_insert_string_after
  0179d	83 c4 30	 add	 esp, 48			; 00000030H

; 3054 : 
; 3055 : #ifdef DEBUG
; 3056 : 	printf("leaving par_insert_string; insert is done\n");
; 3057 : #endif
; 3058 : 	return;
; 3059 : }

  017a0	83 c4 6c	 add	 esp, 108		; 0000006cH
  017a3	c3		 ret	 0
$L71959:

; 2982 : 		return;
; 2983 : 	}
; 2984 : 	if (insert_operation_flags & BIN_BEFORE_FLAG)

  017a4	a8 20		 test	 al, 32			; 00000020H
  017a6	74 65		 je	 SHORT $L71960

; 2985 : 	{
; 2986 : 		par_insert_string_before(current_rule,input_array,output_array,input_indexes,output_indexes,match_array,ret_value,range_value,save_num,dict_state_flag,in_rule_index,insert_operation_flags);

  017a8	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR _in_rule_index$[esp+104]
  017af	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _save_num$[esp+104]
  017b6	50		 push	 eax
  017b7	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR _dict_state_flag$[esp+108]
  017be	52		 push	 edx
  017bf	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR _range_value$[esp+112]
  017c6	50		 push	 eax
  017c7	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _ret_value$[esp+116]
  017ce	51		 push	 ecx
  017cf	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _match_array$[esp+120]
  017d6	52		 push	 edx
  017d7	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR _output_indexes$[esp+124]
  017de	50		 push	 eax
  017df	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _input_indexes$[esp+128]
  017e6	51		 push	 ecx
  017e7	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _output_array$[esp+132]
  017ee	52		 push	 edx
  017ef	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR _input_array$[esp+136]
  017f6	50		 push	 eax
  017f7	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _current_rule$[esp+140]
  017fe	51		 push	 ecx
  017ff	52		 push	 edx
  01800	50		 push	 eax
  01801	e8 00 00 00 00	 call	 _par_insert_string_before
  01806	83 c4 30	 add	 esp, 48			; 00000030H

; 3054 : 
; 3055 : #ifdef DEBUG
; 3056 : 	printf("leaving par_insert_string; insert is done\n");
; 3057 : #endif
; 3058 : 	return;
; 3059 : }

  01809	83 c4 6c	 add	 esp, 108		; 0000006cH
  0180c	c3		 ret	 0
$L71960:

; 2987 : 		return;
; 2988 : 	}
; 2989 : #endif
; 2990 : #ifdef DEBUG
; 2991 : 	printf("entering par_insert_string\n");
; 2992 : #endif
; 2993 : 	/* 
; 2994 : 	*	check the inputs for valid data 
; 2995 : 	*/
; 2996 : #ifdef SANITY_CHECKING
; 2997 : 	if (ret_value==NULL)
; 2998 : 	{
; 2999 : #ifdef DEBUG
; 3000 : 		printf("leaving par_insert_string ret_value is NULL\n");
; 3001 : #endif
; 3002 : 		return;
; 3003 : 	}
; 3004 : 	if ((current_rule==NULL) || (output_array==NULL) || (match_array==NULL))
; 3005 : 	{
; 3006 : 		ret_value->value=FATAL_FAIL;
; 3007 : #ifdef DEBUG
; 3008 : 		printf("leaving par_insert_string; inputs are invalid\n");
; 3009 : #endif
; 3010 : 		return;
; 3011 : 	}
; 3012 : #endif /* SANITY_CHECKING */
; 3013 : 	/* 
; 3014 : 	*	build the string that is going to be inserted 
; 3015 : 	*/
; 3016 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_INSERT,&length,in_rule_index);

  0180d	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR _in_rule_index$[esp+104]
  01814	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR _range_value$[esp+104]
  0181b	55		 push	 ebp
  0181c	8b 6c 24 7c	 mov	 ebp, DWORD PTR _output_array$[esp+108]
  01820	56		 push	 esi
  01821	57		 push	 edi
  01822	8b bc 24 94 00
	00 00		 mov	 edi, DWORD PTR _ret_value$[esp+116]
  01829	8d 94 24 a4 00
	00 00		 lea	 edx, DWORD PTR _length$[esp+116]
  01830	51		 push	 ecx
  01831	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _match_array$[esp+120]
  01838	52		 push	 edx
  01839	6a 1a		 push	 26			; 0000001aH
  0183b	50		 push	 eax
  0183c	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR _current_rule$[esp+132]
  01843	57		 push	 edi
  01844	51		 push	 ecx
  01845	8d 54 24 2c	 lea	 edx, DWORD PTR _buf$[esp+144]
  01849	55		 push	 ebp
  0184a	52		 push	 edx
  0184b	50		 push	 eax
  0184c	e8 00 00 00 00	 call	 _par_build_string_from_rule

; 3017 : 	/* 
; 3018 : 	*	the new length of the ouput string is
; 3019 : 	*	the number of characters inserted into minus 1 (the insert is only between)
; 3020 : 	*	times the length of the string to be inserted plus one (the original character)
; 3021 : 	*	plus one (the last character)
; 3022 : 	*/
; 3023 : 	new_length=(ret_value->output_offset-1)*(length+1)+1;

  01851	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  01854	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR _length$[esp+152]
  0185b	83 c4 24	 add	 esp, 36			; 00000024H
  0185e	42		 inc	 edx
  0185f	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]

; 3024 : 	
; 3025 : 	/* pos is the current position */
; 3026 : 	pos=ret_value->output_pos;

  01862	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  01865	0f af ca	 imul	 ecx, edx
  01868	41		 inc	 ecx

; 3027 : 	/* off is the pos plus the offset minus 1 (the offset is positioned for the next insert) */
; 3028 : 	off=ret_value->output_offset+ret_value->output_pos-1;

  01869	8d 54 06 ff	 lea	 edx, DWORD PTR [esi+eax-1]

; 3029 : 	/* new is the place where the last character of the inserted string will be placed */
; 3030 : 	new_loc=new_length+ret_value->output_pos-1;
; 3031 : 	while (pos<off) /* go until the offset if equal to the position */

  0186d	3b f2		 cmp	 esi, edx
  0186f	89 8c 24 84 00
	00 00		 mov	 DWORD PTR _new_length$[esp+116], ecx
  01876	89 b4 24 90 00
	00 00		 mov	 DWORD PTR 28+[esp+116], esi
  0187d	8d 44 0e ff	 lea	 eax, DWORD PTR [esi+ecx-1]
  01881	0f 8d d6 00 00
	00		 jge	 $L71963
  01887	8b b4 24 8c 00
	00 00		 mov	 esi, DWORD PTR _output_indexes$[esp+116]
  0188e	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  01891	53		 push	 ebx
  01892	8d 34 4e	 lea	 esi, DWORD PTR [esi+ecx*2]
  01895	eb 07		 jmp	 SHORT $L71962
$L73035:

; 2987 : 		return;
; 2988 : 	}
; 2989 : #endif
; 2990 : #ifdef DEBUG
; 2991 : 	printf("entering par_insert_string\n");
; 2992 : #endif
; 2993 : 	/* 
; 2994 : 	*	check the inputs for valid data 
; 2995 : 	*/
; 2996 : #ifdef SANITY_CHECKING
; 2997 : 	if (ret_value==NULL)
; 2998 : 	{
; 2999 : #ifdef DEBUG
; 3000 : 		printf("leaving par_insert_string ret_value is NULL\n");
; 3001 : #endif
; 3002 : 		return;
; 3003 : 	}
; 3004 : 	if ((current_rule==NULL) || (output_array==NULL) || (match_array==NULL))
; 3005 : 	{
; 3006 : 		ret_value->value=FATAL_FAIL;
; 3007 : #ifdef DEBUG
; 3008 : 		printf("leaving par_insert_string; inputs are invalid\n");
; 3009 : #endif
; 3010 : 		return;
; 3011 : 	}
; 3012 : #endif /* SANITY_CHECKING */
; 3013 : 	/* 
; 3014 : 	*	build the string that is going to be inserted 
; 3015 : 	*/
; 3016 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_INSERT,&length,in_rule_index);

  01897	8b b4 24 9c 00
	00 00		 mov	 esi, DWORD PTR 36+[esp+120]
$L71962:

; 3032 : 	{
; 3033 : 		/* copy the character in the current string into its new location */
; 3034 : 		output_array[new_loc]=output_array[off];                                

  0189e	8a 0c 2a	 mov	 cl, BYTE PTR [edx+ebp]

; 3035 : 		par_copy_index(output_indexes,new_loc,output_indexes,off);

  018a1	8b bc 24 90 00
	00 00		 mov	 edi, DWORD PTR _output_indexes$[esp+120]
  018a8	88 0c 28	 mov	 BYTE PTR [eax+ebp], cl
  018ab	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  018ae	8d 0c 4f	 lea	 ecx, DWORD PTR [edi+ecx*2]
  018b1	8b fe		 mov	 edi, esi
  018b3	8b 1f		 mov	 ebx, DWORD PTR [edi]
  018b5	89 19		 mov	 DWORD PTR [ecx], ebx
  018b7	66 8b 7f 04	 mov	 di, WORD PTR [edi+4]
  018bb	66 89 79 04	 mov	 WORD PTR [ecx+4], di

; 3036 : 		par_copy_index(output_indexes,off,output_indexes,PAR_MAX_OUTPUT_ARRAY-1);

  018bf	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _output_indexes$[esp+120]
  018c6	81 c1 12 15 00
	00		 add	 ecx, 5394		; 00001512H
  018cc	8b fe		 mov	 edi, esi

; 3037 : 		/* move off back to the previous character */
; 3038 : 		off--;                                       

  018ce	83 ee 06	 sub	 esi, 6
  018d1	4a		 dec	 edx
  018d2	8b 19		 mov	 ebx, DWORD PTR [ecx]
  018d4	89 b4 24 9c 00
	00 00		 mov	 DWORD PTR 36+[esp+120], esi
  018db	89 1f		 mov	 DWORD PTR [edi], ebx

; 3039 : 		/* move new back for the insert of the inset string */
; 3040 : 		new_loc-=length;                                          
; 3041 : 		/* copy the insert string to new */
; 3042 : 		memcpy(output_array+new_loc,buf,length);

  018dd	8d 74 24 18	 lea	 esi, DWORD PTR _buf$[esp+124]
  018e1	66 8b 49 04	 mov	 cx, WORD PTR [ecx+4]
  018e5	66 89 4f 04	 mov	 WORD PTR [edi+4], cx
  018e9	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR _length$[esp+120]
  018f0	2b c1		 sub	 eax, ecx
  018f2	8b d9		 mov	 ebx, ecx
  018f4	c1 e9 02	 shr	 ecx, 2
  018f7	8d 3c 28	 lea	 edi, DWORD PTR [eax+ebp]
  018fa	f3 a5		 rep movsd
  018fc	8b cb		 mov	 ecx, ebx
  018fe	83 e1 03	 and	 ecx, 3
  01901	f3 a4		 rep movsb

; 3043 : 		//055	MGS		10/14/1999	BATS#900 Fixed indexing in spanish phone numbers
; 3044 : 		/* blank the indexes in the inserted range */
; 3045 : 		for (i=new_loc;i<new_loc+length;i++)

  01903	8b b4 24 a8 00
	00 00		 mov	 esi, DWORD PTR _length$[esp+120]
  0190a	8b c8		 mov	 ecx, eax
  0190c	03 f0		 add	 esi, eax
  0190e	3b c6		 cmp	 eax, esi
  01910	7d 2c		 jge	 SHORT $L71966

; 3046 : 		{
; 3047 : 			par_copy_index(output_indexes,new_loc,&temp_index,0);

  01912	8b bc 24 90 00
	00 00		 mov	 edi, DWORD PTR _output_indexes$[esp+120]
  01919	8d 34 40	 lea	 esi, DWORD PTR [eax+eax*2]
  0191c	8d 34 77	 lea	 esi, DWORD PTR [edi+esi*2]
$L71964:
  0191f	8b 5c 24 10	 mov	 ebx, DWORD PTR _temp_index$[esp+124]
  01923	8b fe		 mov	 edi, esi
  01925	41		 inc	 ecx
  01926	89 1f		 mov	 DWORD PTR [edi], ebx
  01928	66 8b 5c 24 14	 mov	 bx, WORD PTR _temp_index$[esp+128]
  0192d	66 89 5f 04	 mov	 WORD PTR [edi+4], bx
  01931	8b bc 24 a8 00
	00 00		 mov	 edi, DWORD PTR _length$[esp+120]
  01938	03 f8		 add	 edi, eax
  0193a	3b cf		 cmp	 ecx, edi
  0193c	7c e1		 jl	 SHORT $L71964
$L71966:

; 3029 : 	/* new is the place where the last character of the inserted string will be placed */
; 3030 : 	new_loc=new_length+ret_value->output_pos-1;
; 3031 : 	while (pos<off) /* go until the offset if equal to the position */

  0193e	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR 28+[esp+120]

; 3048 : 		}
; 3049 : 		/* move new back one character */
; 3050 : 		new_loc--;

  01945	48		 dec	 eax
  01946	3b d1		 cmp	 edx, ecx
  01948	0f 8f 49 ff ff
	ff		 jg	 $L73035
  0194e	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR _new_length$[esp+120]
  01955	8b bc 24 98 00
	00 00		 mov	 edi, DWORD PTR _ret_value$[esp+120]
  0195c	5b		 pop	 ebx
$L71963:

; 3051 : 	}                                    
; 3052 : 	/* the output offset is equal to the total length of the new string */
; 3053 : 	ret_value->output_offset=new_length;

  0195d	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  01960	5f		 pop	 edi
  01961	5e		 pop	 esi
  01962	5d		 pop	 ebp

; 3054 : 
; 3055 : #ifdef DEBUG
; 3056 : 	printf("leaving par_insert_string; insert is done\n");
; 3057 : #endif
; 3058 : 	return;
; 3059 : }

  01963	83 c4 6c	 add	 esp, 108		; 0000006cH
  01966	c3		 ret	 0
_par_insert_string ENDP
_current_rule$ = 8
_output_array$ = 16
_match_array$ = 28
_ret_value$ = 32
_range_value$ = 36
_in_rule_index$ = 48
_length$ = 48
_buf$ = -100
_par_insert_string_after PROC NEAR

; 3101 : 	int length;
; 3102 : 	unsigned char buf[100];
; 3103 : 	
; 3104 : #ifdef DEBUG
; 3105 : 	printf("entering par_insert_string_after\n");
; 3106 : #endif
; 3107 : 	/*
; 3108 : 	*	check the input values
; 3109 : 	*/
; 3110 : #ifdef SANITY_CHECKING
; 3111 : 	if (ret_value==NULL)
; 3112 : 	{
; 3113 : #ifdef DEBUG
; 3114 : 		printf("leaving par_insert_string_after ret_value is NULL\n");
; 3115 : #endif
; 3116 : 		return;
; 3117 : 	}
; 3118 : 	if ((current_rule==NULL) || (output_array==NULL) || (match_array==NULL))
; 3119 : 	{
; 3120 : 		ret_value->value=FATAL_FAIL;
; 3121 : #ifdef DEBUG
; 3122 : 		printf("leaving par_insert_string_after inputs are invalid\n");
; 3123 : #endif
; 3124 : 		return;
; 3125 : 	}
; 3126 : #endif
; 3127 : 	/*
; 3128 : 	*	build the string for the insert after 
; 3129 : 	*/
; 3130 : #ifndef GERMAN_COMPOUND_NOUNS
; 3131 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_AFTER,&length,in_rule_index);
; 3132 : #else
; 3133 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_INSERT | BIN_AFTER_FLAG,&length,in_rule_index);

  01970	8b 44 24 2c	 mov	 eax, DWORD PTR _in_rule_index$[esp-4]
  01974	83 ec 64	 sub	 esp, 100		; 00000064H
  01977	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR _range_value$[esp+96]
  0197e	8d 8c 24 90 00
	00 00		 lea	 ecx, DWORD PTR _length$[esp+96]
  01985	53		 push	 ebx
  01986	8b 9c 24 84 00
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+100]
  0198d	55		 push	 ebp
  0198e	8b 6c 24 78	 mov	 ebp, DWORD PTR _output_array$[esp+104]
  01992	56		 push	 esi
  01993	57		 push	 edi
  01994	50		 push	 eax
  01995	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR _match_array$[esp+116]
  0199c	51		 push	 ecx
  0199d	6a 5a		 push	 90			; 0000005aH
  0199f	52		 push	 edx
  019a0	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR _current_rule$[esp+128]
  019a7	53		 push	 ebx
  019a8	50		 push	 eax
  019a9	8d 4c 24 28	 lea	 ecx, DWORD PTR _buf$[esp+140]
  019ad	55		 push	 ebp
  019ae	51		 push	 ecx
  019af	52		 push	 edx
  019b0	e8 00 00 00 00	 call	 _par_build_string_from_rule

; 3134 : #endif
; 3135 : 	/* copy the inserted string into its place */
; 3136 : 	/* the indexes will have been copied by copy_string _data */
; 3137 : 	strcpy((output_array+(ret_value->output_pos+ret_value->output_offset)),buf);

  019b5	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  019b8	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  019bb	03 d5		 add	 edx, ebp
  019bd	8d 7c 24 34	 lea	 edi, DWORD PTR _buf$[esp+152]
  019c1	03 d1		 add	 edx, ecx
  019c3	83 c9 ff	 or	 ecx, -1
  019c6	33 c0		 xor	 eax, eax
  019c8	83 c4 24	 add	 esp, 36			; 00000024H
  019cb	f2 ae		 repne scasb
  019cd	f7 d1		 not	 ecx
  019cf	2b f9		 sub	 edi, ecx
  019d1	8b c1		 mov	 eax, ecx
  019d3	8b f7		 mov	 esi, edi
  019d5	8b fa		 mov	 edi, edx
  019d7	c1 e9 02	 shr	 ecx, 2
  019da	f3 a5		 rep movsd
  019dc	8b c8		 mov	 ecx, eax
  019de	83 e1 03	 and	 ecx, 3
  019e1	f3 a4		 rep movsb

; 3138 : 	memcpy((output_array+(ret_value->output_pos+ret_value->output_offset)),buf,length);

  019e3	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _length$[esp+112]
  019ea	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  019ed	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  019f0	03 fd		 add	 edi, ebp
  019f2	8b d1		 mov	 edx, ecx
  019f4	8d 74 24 10	 lea	 esi, DWORD PTR _buf$[esp+116]
  019f8	03 f8		 add	 edi, eax
  019fa	c1 e9 02	 shr	 ecx, 2
  019fd	f3 a5		 rep movsd
  019ff	8b ca		 mov	 ecx, edx
  01a01	83 e1 03	 and	 ecx, 3
  01a04	f3 a4		 rep movsb

; 3139 : 	/* add the length of the inserted atring to the offset */
; 3140 : 	ret_value->output_offset+=length;

  01a06	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _length$[esp+112]
  01a0d	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  01a10	03 c8		 add	 ecx, eax
  01a12	5f		 pop	 edi
  01a13	5e		 pop	 esi
  01a14	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx
  01a17	5d		 pop	 ebp
  01a18	5b		 pop	 ebx

; 3141 : #ifdef DEBUG
; 3142 : 	printf("leaving par_insert_string_after insert after is done\n");
; 3143 : #endif
; 3144 : 	return;
; 3145 : }                                                                             

  01a19	83 c4 64	 add	 esp, 100		; 00000064H
  01a1c	c3		 ret	 0
_par_insert_string_after ENDP
_current_rule$ = 8
_output_array$ = 16
_output_indexes$ = 24
_match_array$ = 28
_ret_value$ = 32
_range_value$ = 36
_in_rule_index$ = 48
_length$ = 48
_buf$ = -100
_par_insert_string_before PROC NEAR

; 3189 : 	int length;
; 3190 : 	int i,j;
; 3191 : 	unsigned char buf[100];           
; 3192 : 	
; 3193 : #ifdef DEBUG
; 3194 : 	printf("entering par_insert_string_before\n");
; 3195 : #endif
; 3196 : 	/*
; 3197 : 	*	check the input values
; 3198 : 	*/
; 3199 : #ifdef SANITY_CHECKING
; 3200 : 	if (ret_value==NULL)
; 3201 : 	{
; 3202 : #ifdef DEBUG
; 3203 : 		printf("leaving par_insert_string_before ret_value is NULL\n");
; 3204 : #endif
; 3205 : 		return;
; 3206 : 	}
; 3207 : 	if ((current_rule==NULL) || (output_array==NULL) || (match_array==NULL))
; 3208 : 	{
; 3209 : 		ret_value->value=FATAL_FAIL;
; 3210 : #ifdef DEBUG
; 3211 : 		printf("leaving par_insert_string_before; inputs are invalid\n");
; 3212 : #endif
; 3213 : 		return;
; 3214 : 	}
; 3215 : #endif
; 3216 : 	
; 3217 : 	/* build the string to be inserted before the input string */
; 3218 : #ifndef GERMAN_COMPOUND_NOUNS
; 3219 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_BEFORE,&length,in_rule_index);
; 3220 : #else
; 3221 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_INSERT | BIN_BEFORE_FLAG,&length,in_rule_index);

  01a20	8b 44 24 2c	 mov	 eax, DWORD PTR _in_rule_index$[esp-4]
  01a24	83 ec 64	 sub	 esp, 100		; 00000064H
  01a27	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR _range_value$[esp+96]
  01a2e	8d 8c 24 90 00
	00 00		 lea	 ecx, DWORD PTR _length$[esp+96]
  01a35	53		 push	 ebx
  01a36	8b 9c 24 84 00
	00 00		 mov	 ebx, DWORD PTR _ret_value$[esp+100]
  01a3d	55		 push	 ebp
  01a3e	8b 6c 24 78	 mov	 ebp, DWORD PTR _output_array$[esp+104]
  01a42	56		 push	 esi
  01a43	57		 push	 edi
  01a44	50		 push	 eax
  01a45	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR _match_array$[esp+116]
  01a4c	51		 push	 ecx
  01a4d	6a 3a		 push	 58			; 0000003aH
  01a4f	52		 push	 edx
  01a50	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR _current_rule$[esp+128]
  01a57	53		 push	 ebx
  01a58	50		 push	 eax
  01a59	8d 4c 24 28	 lea	 ecx, DWORD PTR _buf$[esp+140]
  01a5d	55		 push	 ebp
  01a5e	51		 push	 ecx
  01a5f	52		 push	 edx
  01a60	e8 00 00 00 00	 call	 _par_build_string_from_rule

; 3222 : #endif
; 3223 : 	/* move the current string length characters to the right to make room for the insert string */
; 3224 : 	j=ret_value->output_pos+ret_value->output_offset;

  01a65	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 3225 : 	for (i=j-1;i>=ret_value->output_pos;i--)

  01a68	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  01a6b	8b 94 24 ac 00
	00 00		 mov	 edx, DWORD PTR _output_indexes$[esp+148]
  01a72	83 c4 24	 add	 esp, 36			; 00000024H
  01a75	8d 44 01 ff	 lea	 eax, DWORD PTR [ecx+eax-1]
  01a79	3b c1		 cmp	 eax, ecx
  01a7b	7c 45		 jl	 SHORT $L72025
  01a7d	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  01a80	8d 34 4a	 lea	 esi, DWORD PTR [edx+ecx*2]
$L72023:

; 3226 : 	{
; 3227 : 		output_array[i+length]=output_array[i];

  01a83	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _length$[esp+112]
  01a8a	8d 3c 08	 lea	 edi, DWORD PTR [eax+ecx]
  01a8d	8a 0c 28	 mov	 cl, BYTE PTR [eax+ebp]
  01a90	88 0c 2f	 mov	 BYTE PTR [edi+ebp], cl

; 3228 : 		par_copy_index(output_indexes,i+length,output_indexes,i);

  01a93	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _length$[esp+112]
  01a9a	03 c8		 add	 ecx, eax
  01a9c	48		 dec	 eax
  01a9d	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  01aa0	8d 14 4a	 lea	 edx, DWORD PTR [edx+ecx*2]
  01aa3	8b ce		 mov	 ecx, esi
  01aa5	83 ee 06	 sub	 esi, 6
  01aa8	8b 39		 mov	 edi, DWORD PTR [ecx]
  01aaa	89 3a		 mov	 DWORD PTR [edx], edi
  01aac	66 8b 49 04	 mov	 cx, WORD PTR [ecx+4]
  01ab0	66 89 4a 04	 mov	 WORD PTR [edx+4], cx
  01ab4	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  01ab7	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR _output_indexes$[esp+112]
  01abe	3b c1		 cmp	 eax, ecx
  01ac0	7d c1		 jge	 SHORT $L72023
$L72025:

; 3229 : 	}
; 3230 : 	/* insert the string */
; 3231 : 	memcpy((output_array+(ret_value->output_pos)),buf,length);

  01ac2	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _length$[esp+112]
  01ac9	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  01acc	8b c1		 mov	 eax, ecx
  01ace	8d 74 24 10	 lea	 esi, DWORD PTR _buf$[esp+116]
  01ad2	03 fd		 add	 edi, ebp
  01ad4	c1 e9 02	 shr	 ecx, 2
  01ad7	f3 a5		 rep movsd
  01ad9	8b c8		 mov	 ecx, eax
  01adb	83 e1 03	 and	 ecx, 3
  01ade	f3 a4		 rep movsb

; 3232 : 	for (i=0;i<length;i++)

  01ae0	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _length$[esp+112]
  01ae7	33 c9		 xor	 ecx, ecx
  01ae9	85 c0		 test	 eax, eax
  01aeb	7e 2b		 jle	 SHORT $L73053

; 3233 : 	{
; 3234 : 		par_copy_index(output_indexes,ret_value->output_pos+i,output_indexes,PAR_MAX_OUTPUT_ARRAY-1);

  01aed	8d b2 12 15 00
	00		 lea	 esi, DWORD PTR [edx+5394]
$L72026:
  01af3	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  01af6	8b fe		 mov	 edi, esi
  01af8	03 c1		 add	 eax, ecx
  01afa	41		 inc	 ecx
  01afb	8b 2f		 mov	 ebp, DWORD PTR [edi]
  01afd	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  01b00	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  01b03	89 28		 mov	 DWORD PTR [eax], ebp
  01b05	66 8b 7f 04	 mov	 di, WORD PTR [edi+4]
  01b09	66 89 78 04	 mov	 WORD PTR [eax+4], di
  01b0d	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _length$[esp+112]
  01b14	3b c8		 cmp	 ecx, eax
  01b16	7c db		 jl	 SHORT $L72026
$L73053:

; 3235 : 	}
; 3236 : 	/* add the length of the inserted string to the offset */
; 3237 : 	ret_value->output_offset+=length;

  01b18	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  01b1b	5f		 pop	 edi
  01b1c	03 c8		 add	 ecx, eax
  01b1e	5e		 pop	 esi
  01b1f	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx
  01b22	5d		 pop	 ebp
  01b23	5b		 pop	 ebx

; 3238 : 	//	ret_value->rule++;
; 3239 : #ifdef DEBUG
; 3240 : 	printf("leaving par_insert_string_before; insert before is done\n");
; 3241 : #endif
; 3242 : 	return;
; 3243 : }    

  01b24	83 c4 64	 add	 esp, 100		; 00000064H
  01b27	c3		 ret	 0
_par_insert_string_before ENDP
_output_array$ = 16
_match_array$ = 28
_ret_value$ = 32
_save_num$ = 40
_par_save_string PROC NEAR

; 3283 : 	/* this should be the last thing in the output array, but to be sure strncpy is used */
; 3284 : #ifdef DEBUG
; 3285 : 	printf("entering par_save_string\n");
; 3286 : #endif
; 3287 : 	/* 
; 3288 : 	*	check the input values 
; 3289 : 	*/
; 3290 : #ifdef SANITY_CHECKING
; 3291 : 	if (ret_value==NULL)
; 3292 : 	{
; 3293 : #ifdef DEBUG
; 3294 : 		printf("leaving par_save_string ret_value is NULL\n");
; 3295 : #endif
; 3296 : 		return;
; 3297 : 	}
; 3298 : 	if ((output_array==NULL) || (match_array==NULL))
; 3299 : 	{
; 3300 : 		ret_value->value=FATAL_FAIL;
; 3301 : #ifdef DEBUG
; 3302 : 		printf("leaving par_save_string; inputs are invalid\n");
; 3303 : #endif
; 3304 : 		return;
; 3305 : 	}
; 3306 : 	if (save_num<0 || save_num >PAR_MAX_ARRAYS)
; 3307 : 	{
; 3308 : 		printf("$%d is out of range\n",save_num);
; 3309 : 		ret_value->value=FATAL_FAIL;
; 3310 : 		return;
; 3311 : 	}
; 3312 : #endif
; 3313 : 	
; 3314 : 	/* MGS BATS #449 */
; 3315 : 	if (ret_value->output_offset>=PAR_MAX_MATCH_ARRAY)

  01b30	8b 54 24 1c	 mov	 edx, DWORD PTR _ret_value$[esp-4]
  01b34	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  01b37	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  01b3a	7c 08		 jl	 SHORT $L72054

; 3316 : 	{
; 3317 : 		ret_value->value=FATAL_FAIL;

  01b3c	c7 42 14 04 00
	00 00		 mov	 DWORD PTR [edx+20], 4

; 3325 : #ifdef DEBUG
; 3326 : 	printf("leaving par_save_string; string is saved in array %d\n",save_num);
; 3327 : #endif
; 3328 : 	return;
; 3329 : }

  01b43	c3		 ret	 0
$L72054:
  01b44	53		 push	 ebx

; 3318 : 		return;
; 3319 : 	}
; 3320 : 	/* copy the output string to the temporoar array num */
; 3321 : 	memcpy(match_array->array[save_num],(output_array+(ret_value->output_pos)),ret_value->output_offset);

  01b45	8b 5c 24 28	 mov	 ebx, DWORD PTR _save_num$[esp]
  01b49	55		 push	 ebp
  01b4a	56		 push	 esi
  01b4b	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  01b4e	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  01b51	57		 push	 edi
  01b52	8b 7c 24 1c	 mov	 edi, DWORD PTR _output_array$[esp+12]
  01b56	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  01b59	03 f7		 add	 esi, edi
  01b5b	8b 7c 24 28	 mov	 edi, DWORD PTR _match_array$[esp+12]
  01b5f	8b e9		 mov	 ebp, ecx
  01b61	d1 e0		 shl	 eax, 1
  01b63	c1 e9 02	 shr	 ecx, 2
  01b66	8d 7c 38 28	 lea	 edi, DWORD PTR [eax+edi+40]
  01b6a	f3 a5		 rep movsd
  01b6c	8b cd		 mov	 ecx, ebp
  01b6e	83 e1 03	 and	 ecx, 3
  01b71	f3 a4		 rep movsb

; 3322 : 	match_array->array_lengths[save_num]=ret_value->output_offset;

  01b73	8b 4c 24 28	 mov	 ecx, DWORD PTR _match_array$[esp+12]
  01b77	8b 72 0c	 mov	 esi, DWORD PTR [edx+12]

; 3323 : 	/* null terminate the string */
; 3324 : 	match_array->array[save_num][ret_value->output_offset]='\0';

  01b7a	03 c1		 add	 eax, ecx
  01b7c	5f		 pop	 edi
  01b7d	89 34 99	 mov	 DWORD PTR [ecx+ebx*4], esi
  01b80	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  01b83	5e		 pop	 esi
  01b84	5d		 pop	 ebp
  01b85	c6 44 08 28 00	 mov	 BYTE PTR [eax+ecx+40], 0
  01b8a	5b		 pop	 ebx

; 3325 : #ifdef DEBUG
; 3326 : 	printf("leaving par_save_string; string is saved in array %d\n",save_num);
; 3327 : #endif
; 3328 : 	return;
; 3329 : }

  01b8b	c3		 ret	 0
_par_save_string ENDP
_TEXT	ENDS
PUBLIC	_par_search_for_word
_TEXT	SEGMENT
_current_rule$ = 8
_input_array$ = 12
_output_array$ = 16
_input_indexes$ = 20
_output_indexes$ = 24
_match_array$ = 28
_ret_value$ = 32
_dict_num$ = 40
_dict_state_flag$ = 44
_in_rule_index$ = 48
_par_dom_dict_search PROC NEAR

; 3374 : {

  01b90	53		 push	 ebx
  01b91	55		 push	 ebp

; 3375 : 	int	ipos,opos;
; 3376 : 	int	result=FAIL;
; 3377 : #ifdef DEBUG
; 3378 : 	printf("entering par_dom_dict_search\n");
; 3379 : #endif
; 3380 : 	ipos=ret_value->input_pos;
; 3381 : 	opos=ret_value->output_pos;

  01b92	8b 6c 24 24	 mov	 ebp, DWORD PTR _ret_value$[esp+4]
  01b96	56		 push	 esi
  01b97	57		 push	 edi

; 3382 : 	
; 3383 : 	/* MGS BATS #449 */
; 3384 : 	if (ret_value->input_offset>=PAR_MAX_MATCH_ARRAY)

  01b98	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  01b9b	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  01b9e	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  01ba1	7c 0c		 jl	 SHORT $L72083
  01ba3	5f		 pop	 edi

; 3385 : 	{
; 3386 : 		ret_value->value=FATAL_FAIL;

  01ba4	c7 45 14 04 00
	00 00		 mov	 DWORD PTR [ebp+20], 4
  01bab	5e		 pop	 esi
  01bac	5d		 pop	 ebp
  01bad	5b		 pop	 ebx

; 3481 : 	}       
; 3482 : #ifdef DEBUG
; 3483 : 	printf("leaving par_dom_dict_search\n");
; 3484 : 	par_print_rule_error("",current_rule,ret_value->rule);
; 3485 : #endif
; 3486 : }

  01bae	c3		 ret	 0
$L72083:

; 3387 : #ifdef DEBUG
; 3388 : 		printf("leaving par_dom_dict_search fatal failure of the rule\n");
; 3389 : #endif
; 3390 : 		return;
; 3391 : 	}
; 3392 : 	if (ret_value->output_offset>=PAR_MAX_MATCH_ARRAY)

  01baf	83 7d 0c 1e	 cmp	 DWORD PTR [ebp+12], 30	; 0000001eH
  01bb3	7c 0c		 jl	 SHORT $L72084
  01bb5	5f		 pop	 edi

; 3393 : 	{
; 3394 : 		ret_value->value=FATAL_FAIL;

  01bb6	c7 45 14 04 00
	00 00		 mov	 DWORD PTR [ebp+20], 4
  01bbd	5e		 pop	 esi
  01bbe	5d		 pop	 ebp
  01bbf	5b		 pop	 ebx

; 3481 : 	}       
; 3482 : #ifdef DEBUG
; 3483 : 	printf("leaving par_dom_dict_search\n");
; 3484 : 	par_print_rule_error("",current_rule,ret_value->rule);
; 3485 : #endif
; 3486 : }

  01bc0	c3		 ret	 0
$L72084:

; 3395 : #ifdef DEBUG
; 3396 : 		printf("leaving par_dom_dict_search fatal failure of the rule\n");
; 3397 : #endif
; 3398 : 		return;
; 3399 : 	}
; 3400 : 	memcpy(match_array->array[7],input_array+ipos,ret_value->input_offset);

  01bc1	8b 75 00	 mov	 esi, DWORD PTR [ebp]
  01bc4	8b 7c 24 18	 mov	 edi, DWORD PTR _input_array$[esp+12]
  01bc8	8b 5c 24 28	 mov	 ebx, DWORD PTR _match_array$[esp+12]
  01bcc	8b c1		 mov	 eax, ecx
  01bce	03 f7		 add	 esi, edi
  01bd0	8d bb fa 00 00
	00		 lea	 edi, DWORD PTR [ebx+250]
  01bd6	c1 e9 02	 shr	 ecx, 2
  01bd9	f3 a5		 rep movsd
  01bdb	8b c8		 mov	 ecx, eax
  01bdd	83 e1 03	 and	 ecx, 3
  01be0	f3 a4		 rep movsb

; 3401 : 	match_array->array[7][ret_value->input_offset]='\0';

  01be2	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]

; 3402 : 	match_array->array_lengths[7]=ret_value->input_offset;
; 3403 : 	memcpy(match_array->array[8],output_array+opos,ret_value->output_offset);

  01be5	8b 74 24 1c	 mov	 esi, DWORD PTR _output_array$[esp+12]
  01be9	03 f2		 add	 esi, edx
  01beb	c6 84 19 fa 00
	00 00 00	 mov	 BYTE PTR [ecx+ebx+250], 0
  01bf3	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  01bf6	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  01bf9	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  01bfc	8d 83 18 01 00
	00		 lea	 eax, DWORD PTR [ebx+280]
  01c02	8b d1		 mov	 edx, ecx
  01c04	8b f8		 mov	 edi, eax
  01c06	c1 e9 02	 shr	 ecx, 2
  01c09	f3 a5		 rep movsd
  01c0b	8b ca		 mov	 ecx, edx
  01c0d	83 e1 03	 and	 ecx, 3
  01c10	f3 a4		 rep movsb

; 3404 : 	match_array->array[8][ret_value->output_offset]='\0';

  01c12	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]

; 3405 : 	match_array->array_lengths[8]=ret_value->output_offset;
; 3406 : 	result=par_search_for_word(match_array->array[8],ret_value->output_offset,match_array->array[9],dict_num,dict_state_flag);

  01c15	8b 74 24 38	 mov	 esi, DWORD PTR _dict_state_flag$[esp+12]
  01c19	8d bb 36 01 00
	00		 lea	 edi, DWORD PTR [ebx+310]
  01c1f	56		 push	 esi
  01c20	c6 84 19 18 01
	00 00 00	 mov	 BYTE PTR [ecx+ebx+280], 0
  01c28	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01c2b	8b 4c 24 38	 mov	 ecx, DWORD PTR _dict_num$[esp+16]
  01c2f	89 53 20	 mov	 DWORD PTR [ebx+32], edx
  01c32	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  01c35	51		 push	 ecx
  01c36	57		 push	 edi
  01c37	52		 push	 edx
  01c38	50		 push	 eax
  01c39	e8 00 00 00 00	 call	 _par_search_for_word

; 3407 : 	if (dict_state_flag)

  01c3e	33 d2		 xor	 edx, edx
  01c40	83 c4 14	 add	 esp, 20			; 00000014H
  01c43	3b f2		 cmp	 esi, edx
  01c45	74 14		 je	 SHORT $L72085

; 3408 : 	{
; 3409 : 		if (result)

  01c47	3b c2		 cmp	 eax, edx
  01c49	0f 84 c1 00 00
	00		 je	 $L72091
  01c4f	5f		 pop	 edi

; 3410 : 		{
; 3411 : #ifdef DEBUG
; 3412 : 			printf("leaving par_dom_dict_search 1 success\n");
; 3413 : #endif
; 3414 : 			ret_value->value=SUCCESS;

  01c50	c7 45 14 01 00
	00 00		 mov	 DWORD PTR [ebp+20], 1
  01c57	5e		 pop	 esi
  01c58	5d		 pop	 ebp
  01c59	5b		 pop	 ebx

; 3481 : 	}       
; 3482 : #ifdef DEBUG
; 3483 : 	printf("leaving par_dom_dict_search\n");
; 3484 : 	par_print_rule_error("",current_rule,ret_value->rule);
; 3485 : #endif
; 3486 : }

  01c5a	c3		 ret	 0
$L72085:

; 3415 : 			return;
; 3416 : 		}
; 3417 : #ifdef DEBUG
; 3418 : 		printf("leaving par_dom_dict_search 1 failure\n");
; 3419 : #endif
; 3420 : 		return;		
; 3421 : 	}
; 3422 : 	if (result==1)

  01c5b	83 f8 01	 cmp	 eax, 1
  01c5e	75 6e		 jne	 SHORT $L72087

; 3423 : 	{
; 3424 : 		match_array->array_lengths[9]=strlen(match_array->array[9]);

  01c60	83 c9 ff	 or	 ecx, -1
  01c63	33 c0		 xor	 eax, eax
  01c65	f2 ae		 repne scasb

; 3425 : 		if (current_rule[in_rule_index] & BIN_DICT_HIT_FAIL)

  01c67	8b 74 24 14	 mov	 esi, DWORD PTR _current_rule$[esp+12]
  01c6b	8b 7c 24 3c	 mov	 edi, DWORD PTR _in_rule_index$[esp+12]
  01c6f	f7 d1		 not	 ecx
  01c71	49		 dec	 ecx
  01c72	89 4b 24	 mov	 DWORD PTR [ebx+36], ecx
  01c75	8a 04 3e	 mov	 al, BYTE PTR [esi+edi]
  01c78	a8 80		 test	 al, 128			; 00000080H
  01c7a	74 1b		 je	 SHORT $L72090
$L73057:

; 3426 : 		{
; 3427 : 			ret_value->value=FAIL;
; 3428 : 			if (ret_value->optional==1)

  01c7c	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  01c7f	89 55 14	 mov	 DWORD PTR [ebp+20], edx
  01c82	83 f8 01	 cmp	 eax, 1
  01c85	0f 85 85 00 00
	00		 jne	 $L72091
  01c8b	5f		 pop	 edi

; 3429 : 			{
; 3430 : #ifdef DEBUG
; 3431 : 				printf("par_dom_dict_search hit set optinal to -1\n");
; 3432 : #endif
; 3433 : //				ret_value->optional= -1;
; 3434 : 				ret_value->value=OPT_FAIL;

  01c8c	c7 45 14 02 00
	00 00		 mov	 DWORD PTR [ebp+20], 2
  01c93	5e		 pop	 esi
  01c94	5d		 pop	 ebp
  01c95	5b		 pop	 ebx

; 3481 : 	}       
; 3482 : #ifdef DEBUG
; 3483 : 	printf("leaving par_dom_dict_search\n");
; 3484 : 	par_print_rule_error("",current_rule,ret_value->rule);
; 3485 : #endif
; 3486 : }

  01c96	c3		 ret	 0
$L72090:

; 3435 : 				return;
; 3436 : 			}
; 3437 : 			else
; 3438 : 			{
; 3439 : #ifdef DEBUG
; 3440 : 				par_print_rule_error("",current_rule,ret_value->rule);
; 3441 : 				printf("leaving par_dom_dict_search because of a fail hit_action\n");
; 3442 : #endif
; 3443 : 				return;
; 3444 : 			}
; 3445 : 		}
; 3446 : 		ret_value->input_offset=0;	/* reset for rematching */
; 3447 : 		ret_value->output_offset=0; /* reset for rematching */
; 3448 : 		par_match_rule(current_rule,BIN_COPY,input_array,output_array,input_indexes,output_indexes,match_array,ret_value,dict_state_flag);

  01c97	8b 44 24 24	 mov	 eax, DWORD PTR _output_indexes$[esp+12]
  01c9b	8b 4c 24 20	 mov	 ecx, DWORD PTR _input_indexes$[esp+12]
  01c9f	52		 push	 edx
  01ca0	55		 push	 ebp
  01ca1	89 55 04	 mov	 DWORD PTR [ebp+4], edx
  01ca4	89 55 0c	 mov	 DWORD PTR [ebp+12], edx
  01ca7	8b 54 24 24	 mov	 edx, DWORD PTR _output_array$[esp+20]
  01cab	53		 push	 ebx
  01cac	50		 push	 eax
  01cad	8b 44 24 28	 mov	 eax, DWORD PTR _input_array$[esp+28]
  01cb1	51		 push	 ecx
  01cb2	52		 push	 edx
  01cb3	50		 push	 eax
  01cb4	6a 14		 push	 20			; 00000014H
  01cb6	56		 push	 esi
  01cb7	e8 00 00 00 00	 call	 _par_match_rule

; 3449 : #ifdef DEBUG
; 3450 : 		printf("input_off = %d output_off =%d\n",ret_value->input_offset,ret_value->output_offset);
; 3451 : #endif
; 3452 : 		/* skip the miss_action */ /* copy the code for this from the compiler */
; 3453 : 		ret_value->rule=current_rule[in_rule_index+4]+1;

  01cbc	33 c9		 xor	 ecx, ecx
  01cbe	83 c4 24	 add	 esp, 36			; 00000024H
  01cc1	8a 4c 3e 04	 mov	 cl, BYTE PTR [esi+edi+4]
  01cc5	41		 inc	 ecx
  01cc6	5f		 pop	 edi
  01cc7	89 4d 10	 mov	 DWORD PTR [ebp+16], ecx
  01cca	5e		 pop	 esi
  01ccb	5d		 pop	 ebp
  01ccc	5b		 pop	 ebx

; 3481 : 	}       
; 3482 : #ifdef DEBUG
; 3483 : 	printf("leaving par_dom_dict_search\n");
; 3484 : 	par_print_rule_error("",current_rule,ret_value->rule);
; 3485 : #endif
; 3486 : }

  01ccd	c3		 ret	 0
$L72087:

; 3454 : 	}
; 3455 : 	else    /* if (result==1) */
; 3456 : 	{
; 3457 : 		ret_value->rule=current_rule[in_rule_index+3]+1;

  01cce	8b 44 24 14	 mov	 eax, DWORD PTR _current_rule$[esp+12]
  01cd2	8b 74 24 3c	 mov	 esi, DWORD PTR _in_rule_index$[esp+12]
  01cd6	33 c9		 xor	 ecx, ecx
  01cd8	8a 4c 30 03	 mov	 cl, BYTE PTR [eax+esi+3]
  01cdc	41		 inc	 ecx
  01cdd	89 4d 10	 mov	 DWORD PTR [ebp+16], ecx

; 3458 : 		
; 3459 : 		/* skip the hit action state */ /* copy the code for this from the compiler */
; 3460 : 		if (current_rule[in_rule_index] & BIN_DICT_MISS_FAIL)

  01ce0	8a 0c 30	 mov	 cl, BYTE PTR [eax+esi]
  01ce3	f6 c1 40	 test	 cl, 64			; 00000040H

; 3461 : 		{
; 3462 : 			ret_value->value=FAIL;
; 3463 : 			if (ret_value->optional==1)
; 3464 : 			{
; 3465 : #ifdef DEBUG
; 3466 : 				printf("par_dom_dict_search miss set optinal to -1\n");
; 3467 : #endif
; 3468 : //				ret_value->optional= -1;
; 3469 : 				ret_value->value=OPT_FAIL;
; 3470 : 				return;

  01ce6	75 94		 jne	 SHORT $L73057

; 3471 : 			}
; 3472 : #ifdef DEBUG
; 3473 : 			printf("leaving par_dom_dict_search because of a fail miss_action\n");
; 3474 : 			par_print_rule_error("",current_rule,ret_value->rule);
; 3475 : #endif
; 3476 : 			return;
; 3477 : 		}
; 3478 : 		ret_value->input_offset=0;	/* reset for rematching */
; 3479 : 		ret_value->output_offset=0; /* reset for rematching */
; 3480 : 		par_match_rule(current_rule,BIN_COPY,input_array,output_array,input_indexes,output_indexes,match_array,ret_value,dict_state_flag);

  01ce8	8b 4c 24 20	 mov	 ecx, DWORD PTR _input_indexes$[esp+12]
  01cec	89 55 04	 mov	 DWORD PTR [ebp+4], edx
  01cef	89 55 0c	 mov	 DWORD PTR [ebp+12], edx
  01cf2	52		 push	 edx
  01cf3	8b 54 24 28	 mov	 edx, DWORD PTR _output_indexes$[esp+16]
  01cf7	55		 push	 ebp
  01cf8	53		 push	 ebx
  01cf9	52		 push	 edx
  01cfa	8b 54 24 2c	 mov	 edx, DWORD PTR _output_array$[esp+28]
  01cfe	51		 push	 ecx
  01cff	8b 4c 24 2c	 mov	 ecx, DWORD PTR _input_array$[esp+32]
  01d03	52		 push	 edx
  01d04	51		 push	 ecx
  01d05	6a 14		 push	 20			; 00000014H
  01d07	50		 push	 eax
  01d08	e8 00 00 00 00	 call	 _par_match_rule
  01d0d	83 c4 24	 add	 esp, 36			; 00000024H
$L72091:
  01d10	5f		 pop	 edi
  01d11	5e		 pop	 esi
  01d12	5d		 pop	 ebp
  01d13	5b		 pop	 ebx

; 3481 : 	}       
; 3482 : #ifdef DEBUG
; 3483 : 	printf("leaving par_dom_dict_search\n");
; 3484 : 	par_print_rule_error("",current_rule,ret_value->rule);
; 3485 : #endif
; 3486 : }

  01d14	c3		 ret	 0
_par_dom_dict_search ENDP
_TEXT	ENDS
PUBLIC	_par_look_ahead_dictionary
_TEXT	SEGMENT
_current_rule$ = 8
_input_array$ = 12
_match_array$ = 16
_ret_value$ = 20
_temp_output$ = -700
_temp_indexes$ = -600
_par_look_ahead_dictionary PROC NEAR

; 3514 : {           

  01d20	81 ec bc 02 00
	00		 sub	 esp, 700		; 000002bcH

; 3515 : 	unsigned char temp_output[100];
; 3516 : 	index_data_t temp_indexes[100]; 
; 3517 : #ifdef DEBUG
; 3518 : 	printf("entering par_look_ahead_dictionary\n");
; 3519 : #endif
; 3520 : 	ret_value->output_pos=0;

  01d26	33 c0		 xor	 eax, eax

; 3521 : 	ret_value->output_offset=0;
; 3522 : 	ret_value->value=SUCCESS;	
; 3523 : 	par_match_rule(current_rule,BIN_DICTIONARY,input_array,temp_output,temp_indexes,temp_indexes,match_array,ret_value,1);

  01d28	8d 4c 24 64	 lea	 ecx, DWORD PTR _temp_indexes$[esp+700]
  01d2c	8d 54 24 64	 lea	 edx, DWORD PTR _temp_indexes$[esp+700]
  01d30	56		 push	 esi
  01d31	8b b4 24 d0 02
	00 00		 mov	 esi, DWORD PTR _ret_value$[esp+700]
  01d38	6a 01		 push	 1
  01d3a	56		 push	 esi
  01d3b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  01d3e	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  01d41	8b 84 24 d4 02
	00 00		 mov	 eax, DWORD PTR _match_array$[esp+708]
  01d48	c7 46 14 01 00
	00 00		 mov	 DWORD PTR [esi+20], 1
  01d4f	50		 push	 eax
  01d50	51		 push	 ecx
  01d51	8b 8c 24 d8 02
	00 00		 mov	 ecx, DWORD PTR _input_array$[esp+716]
  01d58	8d 44 24 14	 lea	 eax, DWORD PTR _temp_output$[esp+720]
  01d5c	52		 push	 edx
  01d5d	8b 94 24 d8 02
	00 00		 mov	 edx, DWORD PTR _current_rule$[esp+720]
  01d64	50		 push	 eax
  01d65	51		 push	 ecx
  01d66	6a 1d		 push	 29			; 0000001dH
  01d68	52		 push	 edx
  01d69	e8 00 00 00 00	 call	 _par_match_rule

; 3524 : 	if (ret_value->value==SUCCESS)

  01d6e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  01d71	83 c4 24	 add	 esp, 36			; 00000024H
  01d74	33 c0		 xor	 eax, eax
  01d76	83 f9 01	 cmp	 ecx, 1
  01d79	0f 94 c0	 sete	 al
  01d7c	5e		 pop	 esi

; 3525 : 	{
; 3526 : #ifdef DEBUG
; 3527 : 		printf("leaving par_look_ahead_dictionary success\n");
; 3528 : #endif
; 3529 : 		return(1);
; 3530 : 	}
; 3531 : #ifdef DEBUG
; 3532 : 	printf("leaving par_look_ahead_dictionary failure\n");
; 3533 : #endif                                                    
; 3534 : 	return(0);
; 3535 : }

  01d7d	81 c4 bc 02 00
	00		 add	 esp, 700		; 000002bcH
  01d83	c3		 ret	 0
_par_look_ahead_dictionary ENDP
_TEXT	ENDS
EXTRN	_dict_point:BYTE
EXTRN	_dict_index_table:BYTE
EXTRN	_dict_data_table:BYTE
EXTRN	__imp___stricmp:NEAR
_TEXT	SEGMENT
_input$ = 8
_input_length$ = 12
_output$ = 16
_dict_num$ = 20
_dict_state_flag$ = 24
_high$ = 20
_pos$ = 8
_value$ = 8
_rev_same$ = 20
_npos$ = 8
_par_search_for_word PROC NEAR

; 3568 : 	int high,low,pos;
; 3569 : 	int dict_number;
; 3570 : 	int value;
; 3571 : 	int rev_same=0,for_same=0,npos;
; 3572 : 	int save_for;
; 3573 : #ifdef DEBUG
; 3574 : 	printf("entering par_search_for_word\n");
; 3575 : #endif                        
; 3576 : 	dict_number=dict_num-1;	

  01d90	8b 44 24 10	 mov	 eax, DWORD PTR _dict_num$[esp-4]
  01d94	53		 push	 ebx
  01d95	55		 push	 ebp
  01d96	56		 push	 esi

; 3577 : 	low=dict_point[dict_number].start;

  01d97	8b 1c c5 f8 ff
	ff ff		 mov	 ebx, DWORD PTR _dict_point[eax*8-8]

; 3578 : 	rev_same=low;
; 3579 : 	high=dict_point[dict_number].end;

  01d9e	8b 0c c5 fc ff
	ff ff		 mov	 ecx, DWORD PTR _dict_point[eax*8-4]
  01da5	57		 push	 edi

; 3580 : 	for_same=high;
; 3581 : 	while (rev_same<=for_same)

  01da6	3b d9		 cmp	 ebx, ecx
  01da8	8b fb		 mov	 edi, ebx
  01daa	89 4c 24 20	 mov	 DWORD PTR _high$[esp+12], ecx
  01dae	8b e9		 mov	 ebp, ecx
  01db0	7f 50		 jg	 SHORT $L73077
$L72127:

; 3582 : 	{
; 3583 : 		pos=((rev_same+for_same)>>1); /* divide the offset by 2 */

  01db2	8d 34 2f	 lea	 esi, DWORD PTR [edi+ebp]

; 3584 : #ifdef DEBUG
; 3585 : 		printf("comparing %s to %d %s\n",input,pos,(unsigned char *)(dict_data_table+dict_index_table[pos]));
; 3586 : #endif
; 3587 : 		if ((value=_stricmp(input,(unsigned char *)(dict_data_table+dict_index_table[pos])))==0)

  01db5	8b 4c 24 14	 mov	 ecx, DWORD PTR _input$[esp+12]
  01db9	d1 fe		 sar	 esi, 1
  01dbb	8b 04 b5 00 00
	00 00		 mov	 eax, DWORD PTR _dict_index_table[esi*4]
  01dc2	05 00 00 00 00	 add	 eax, OFFSET FLAT:_dict_data_table
  01dc7	50		 push	 eax
  01dc8	51		 push	 ecx
  01dc9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___stricmp
  01dcf	83 c4 08	 add	 esp, 8
  01dd2	85 c0		 test	 eax, eax
  01dd4	74 0e		 je	 SHORT $L73079

; 3588 : 		{
; 3589 : 			break;
; 3590 : 		}
; 3591 : 		else
; 3592 : 		{
; 3593 : 			if (value<0)

  01dd6	7d 05		 jge	 SHORT $L72132

; 3594 : 			{
; 3595 : 				for_same=pos-1;;

  01dd8	8d 6e ff	 lea	 ebp, DWORD PTR [esi-1]

; 3596 : 			}
; 3597 : 			else

  01ddb	eb 03		 jmp	 SHORT $L72133
$L72132:

; 3598 : 			{
; 3599 : 				rev_same=pos+1;

  01ddd	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]
$L72133:

; 3580 : 	for_same=high;
; 3581 : 	while (rev_same<=for_same)

  01de0	3b fd		 cmp	 edi, ebp
  01de2	7e ce		 jle	 SHORT $L72127
$L73079:
  01de4	8b 4c 24 20	 mov	 ecx, DWORD PTR _high$[esp+12]
$L73065:

; 3600 : 			}
; 3601 : 		}
; 3602 : 	}
; 3603 : 	if (dict_state_flag)

  01de8	8b 54 24 24	 mov	 edx, DWORD PTR _dict_state_flag$[esp+12]
  01dec	85 d2		 test	 edx, edx
  01dee	74 1c		 je	 SHORT $L72135

; 3604 : 	{
; 3605 : 		if (value==0)

  01df0	85 c0		 test	 eax, eax
  01df2	0f 85 82 01 00
	00		 jne	 $L73070
  01df8	5f		 pop	 edi
  01df9	5e		 pop	 esi
  01dfa	5d		 pop	 ebp

; 3606 : 		{
; 3607 : #ifdef DEBUG
; 3608 : 			printf("leaving par_search_for_word in dict and short search\n");
; 3609 : #endif
; 3610 : 			return(1);

  01dfb	b8 01 00 00 00	 mov	 eax, 1
  01e00	5b		 pop	 ebx

; 3689 : #ifdef DEBUG
; 3690 : 	printf("leaving par_search_for_word failure\n");
; 3691 : #endif
; 3692 : }

  01e01	c3		 ret	 0
$L73077:

; 3580 : 	for_same=high;
; 3581 : 	while (rev_same<=for_same)

  01e02	8b 74 24 14	 mov	 esi, DWORD PTR _pos$[esp+12]
  01e06	8b 44 24 14	 mov	 eax, DWORD PTR _value$[esp+12]
  01e0a	eb dc		 jmp	 SHORT $L73065
$L72135:

; 3611 : 		}
; 3612 : 	}                                    
; 3613 : 	if (value!=0)

  01e0c	85 c0		 test	 eax, eax

; 3614 : 	{
; 3615 : #ifdef DEBUG
; 3616 : 		printf("leaving par_search_for_word not in dic\n");
; 3617 : #endif
; 3618 : 		return(0);

  01e0e	0f 85 66 01 00
	00		 jne	 $L73070

; 3619 : 	}
; 3620 : 	/* do the case sensitive part of the search */
; 3621 : 	rev_same=pos-1;

  01e14	8d 6e ff	 lea	 ebp, DWORD PTR [esi-1]

; 3622 : 	while ((rev_same>=low) && (_stricmp(input,(unsigned char *)(dict_data_table+dict_index_table[rev_same]))==0))

  01e17	3b eb		 cmp	 ebp, ebx
  01e19	7c 2e		 jl	 SHORT $L72140

; 3619 : 	}
; 3620 : 	/* do the case sensitive part of the search */
; 3621 : 	rev_same=pos-1;

  01e1b	8d 3c ad 00 00
	00 00		 lea	 edi, DWORD PTR _dict_index_table[ebp*4]
$L72139:

; 3622 : 	while ((rev_same>=low) && (_stricmp(input,(unsigned char *)(dict_data_table+dict_index_table[rev_same]))==0))

  01e22	8b 17		 mov	 edx, DWORD PTR [edi]
  01e24	8b 44 24 14	 mov	 eax, DWORD PTR _input$[esp+12]
  01e28	81 c2 00 00 00
	00		 add	 edx, OFFSET FLAT:_dict_data_table
  01e2e	52		 push	 edx
  01e2f	50		 push	 eax
  01e30	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___stricmp
  01e36	83 c4 08	 add	 esp, 8
  01e39	85 c0		 test	 eax, eax
  01e3b	75 08		 jne	 SHORT $L73081

; 3623 : 	{
; 3624 : 		rev_same--;

  01e3d	4d		 dec	 ebp
  01e3e	83 ef 04	 sub	 edi, 4
  01e41	3b eb		 cmp	 ebp, ebx
  01e43	7d dd		 jge	 SHORT $L72139
$L73081:

; 3622 : 	while ((rev_same>=low) && (_stricmp(input,(unsigned char *)(dict_data_table+dict_index_table[rev_same]))==0))

  01e45	8b 4c 24 20	 mov	 ecx, DWORD PTR _high$[esp+12]
$L72140:

; 3625 : 	}                  
; 3626 : 	for_same=pos+1;

  01e49	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]

; 3627 : 	/* BATS 895 Fixed problem with spanish phone numbers with 9 */
; 3628 : 	while ((for_same<=high) && (_stricmp(input,(unsigned char *)(dict_data_table+dict_index_table[for_same]))==0))

  01e4c	3b f9		 cmp	 edi, ecx
  01e4e	7f 2e		 jg	 SHORT $L72144

; 3625 : 	}                  
; 3626 : 	for_same=pos+1;

  01e50	8d 34 bd 00 00
	00 00		 lea	 esi, DWORD PTR _dict_index_table[edi*4]
$L72143:

; 3627 : 	/* BATS 895 Fixed problem with spanish phone numbers with 9 */
; 3628 : 	while ((for_same<=high) && (_stricmp(input,(unsigned char *)(dict_data_table+dict_index_table[for_same]))==0))

  01e57	8b 0e		 mov	 ecx, DWORD PTR [esi]
  01e59	8b 54 24 14	 mov	 edx, DWORD PTR _input$[esp+12]
  01e5d	81 c1 00 00 00
	00		 add	 ecx, OFFSET FLAT:_dict_data_table
  01e63	51		 push	 ecx
  01e64	52		 push	 edx
  01e65	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___stricmp
  01e6b	83 c4 08	 add	 esp, 8
  01e6e	85 c0		 test	 eax, eax
  01e70	75 0c		 jne	 SHORT $L72144
  01e72	8b 44 24 20	 mov	 eax, DWORD PTR _high$[esp+12]

; 3629 : 	{
; 3630 : 		for_same++;

  01e76	47		 inc	 edi
  01e77	83 c6 04	 add	 esi, 4
  01e7a	3b f8		 cmp	 edi, eax
  01e7c	7e d9		 jle	 SHORT $L72143
$L72144:

; 3631 : 	}                  
; 3632 : 	rev_same++;

  01e7e	45		 inc	 ebp

; 3633 : 	for_same--;    

  01e7f	4f		 dec	 edi

; 3634 : 	low=rev_same;
; 3635 : 	save_for=for_same;	/* take the last insensitive match, it will be lower case it any are */
; 3636 : 	while ((for_same!=rev_same) && !(parser_char_types[dict_data_table[dict_index_table[for_same]]] & TYPE_upper))

  01e80	3b fd		 cmp	 edi, ebp
  01e82	89 6c 24 20	 mov	 DWORD PTR _rev_same$[esp+12], ebp
  01e86	8b cf		 mov	 ecx, edi
  01e88	74 2b		 je	 SHORT $L73071
  01e8a	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR _dict_index_table[edi*4]
  01e91	ba 02 00 00 00	 mov	 edx, 2
  01e96	89 44 24 24	 mov	 DWORD PTR 24+[esp+12], eax
$L72146:
  01e9a	8b 30		 mov	 esi, DWORD PTR [eax]
  01e9c	33 db		 xor	 ebx, ebx
  01e9e	8a 9e 00 00 00
	00		 mov	 bl, BYTE PTR _dict_data_table[esi]
  01ea4	84 14 5d 00 00
	00 00		 test	 BYTE PTR _parser_char_types[ebx*2], dl
  01eab	75 43		 jne	 SHORT $L72147

; 3637 : 	{
; 3638 : 		for_same--;

  01ead	4f		 dec	 edi
  01eae	83 e8 04	 sub	 eax, 4
  01eb1	3b fd		 cmp	 edi, ebp
  01eb3	75 e5		 jne	 SHORT $L72146
$L73071:

; 3671 : 			{
; 3672 : #ifdef DEBUG
; 3673 : 				printf("leaving par_dom_dict_search capitilization doesn't match\n");
; 3674 : #endif
; 3675 : 				return(0);
; 3676 : 			}
; 3677 : 		}
; 3678 : 	}
; 3679 : 	if (value==0)
; 3680 : 	{
; 3681 : //		strcpy(output,((unsigned char *)(dict_data_table+dict_index_table[save_for]))+(strlen((unsigned char *)(dict_data_table+dict_index_table[save_for]))+1));
; 3682 : 		strcpy(output,((unsigned char *)(dict_data_table+dict_index_table[save_for]))+(input_length+1));

  01eb5	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _dict_index_table[ecx*4]
  01ebc	8b 54 24 18	 mov	 edx, DWORD PTR _input_length$[esp+12]
  01ec0	33 c0		 xor	 eax, eax
  01ec2	8d bc 11 01 00
	00 00		 lea	 edi, DWORD PTR _dict_data_table[ecx+edx+1]
  01ec9	83 c9 ff	 or	 ecx, -1
  01ecc	f2 ae		 repne scasb
  01ece	f7 d1		 not	 ecx
  01ed0	2b f9		 sub	 edi, ecx
  01ed2	8b c1		 mov	 eax, ecx
  01ed4	8b f7		 mov	 esi, edi
  01ed6	8b 7c 24 1c	 mov	 edi, DWORD PTR _output$[esp+12]
  01eda	c1 e9 02	 shr	 ecx, 2
  01edd	f3 a5		 rep movsd
  01edf	8b c8		 mov	 ecx, eax

; 3683 : #ifdef DEBUG
; 3684 : 		printf("leaving par_search_for_word success\n");
; 3685 : #endif
; 3686 : 		return(1);

  01ee1	b8 01 00 00 00	 mov	 eax, 1
  01ee6	83 e1 03	 and	 ecx, 3
  01ee9	f3 a4		 rep movsb
  01eeb	5f		 pop	 edi
  01eec	5e		 pop	 esi
  01eed	5d		 pop	 ebp
  01eee	5b		 pop	 ebx

; 3689 : #ifdef DEBUG
; 3690 : 	printf("leaving par_search_for_word failure\n");
; 3691 : #endif
; 3692 : }

  01eef	c3		 ret	 0
$L72147:

; 3639 : 	}
; 3640 : 	if (rev_same!=for_same)

  01ef0	3b ef		 cmp	 ebp, edi
  01ef2	74 c1		 je	 SHORT $L73071

; 3641 : 	{
; 3642 : 		while (rev_same<=for_same)

  01ef4	7f 64		 jg	 SHORT $L73078
  01ef6	eb 04		 jmp	 SHORT $L72150
$L73083:
  01ef8	8b 6c 24 20	 mov	 ebp, DWORD PTR _rev_same$[esp+12]
$L72150:

; 3643 : 		{
; 3644 : 			npos=((rev_same+for_same)>>1); /* divide the offset by 2 */
; 3645 : #ifdef DEBUG
; 3646 : 			printf("comapring case %s to %d %s\n",input,npos,(unsigned char *)(dict_data_table+dict_index_table[npos]));
; 3647 : #endif
; 3648 : 			if ((value=strcmp(input,(unsigned char *)(dict_data_table+dict_index_table[npos])))==0)

  01efc	8b 74 24 14	 mov	 esi, DWORD PTR _input$[esp+12]
  01f00	03 ef		 add	 ebp, edi
  01f02	d1 fd		 sar	 ebp, 1
  01f04	8b 04 ad 00 00
	00 00		 mov	 eax, DWORD PTR _dict_index_table[ebp*4]
  01f0b	05 00 00 00 00	 add	 eax, OFFSET FLAT:_dict_data_table
$L73073:
  01f10	8a 1e		 mov	 bl, BYTE PTR [esi]
  01f12	8a cb		 mov	 cl, bl
  01f14	3a 18		 cmp	 bl, BYTE PTR [eax]
  01f16	75 1a		 jne	 SHORT $L73074
  01f18	84 c9		 test	 cl, cl
  01f1a	74 12		 je	 SHORT $L73075
  01f1c	8a 5e 01	 mov	 bl, BYTE PTR [esi+1]
  01f1f	8a cb		 mov	 cl, bl
  01f21	3a 58 01	 cmp	 bl, BYTE PTR [eax+1]
  01f24	75 0c		 jne	 SHORT $L73074
  01f26	03 f2		 add	 esi, edx
  01f28	03 c2		 add	 eax, edx
  01f2a	84 c9		 test	 cl, cl
  01f2c	75 e2		 jne	 SHORT $L73073
$L73075:
  01f2e	33 c0		 xor	 eax, eax
  01f30	eb 05		 jmp	 SHORT $L73076
$L73074:
  01f32	1b c0		 sbb	 eax, eax
  01f34	83 d8 ff	 sbb	 eax, -1
$L73076:
  01f37	85 c0		 test	 eax, eax
  01f39	74 23		 je	 SHORT $L73072

; 3649 : 			{
; 3650 : 				break;
; 3651 : 			}
; 3652 : 			else
; 3653 : 			{
; 3654 : 				if (value<0)

  01f3b	7d 05		 jge	 SHORT $L72155

; 3655 : 				{
; 3656 : 					for_same=npos-1;

  01f3d	8d 7d ff	 lea	 edi, DWORD PTR [ebp-1]

; 3657 : 				}
; 3658 : 				else

  01f40	eb 07		 jmp	 SHORT $L72156
$L72155:

; 3659 : 				{
; 3660 : 					rev_same=npos+1;

  01f42	8d 4d 01	 lea	 ecx, DWORD PTR [ebp+1]
  01f45	89 4c 24 20	 mov	 DWORD PTR _rev_same$[esp+12], ecx
$L72156:
  01f49	39 7c 24 20	 cmp	 DWORD PTR _rev_same$[esp+12], edi
  01f4d	7e a9		 jle	 SHORT $L73083

; 3661 : 				}
; 3662 : 			}
; 3663 : 		}
; 3664 : 		if (value==0)

  01f4f	85 c0		 test	 eax, eax
  01f51	75 12		 jne	 SHORT $L72157

; 3665 : 		{
; 3666 : 			save_for=npos;

  01f53	8b cd		 mov	 ecx, ebp

; 3667 : 		}
; 3668 : 		else

  01f55	e9 5b ff ff ff	 jmp	 $L73071
$L73078:

; 3661 : 				}
; 3662 : 			}
; 3663 : 		}
; 3664 : 		if (value==0)

  01f5a	8b 6c 24 14	 mov	 ebp, DWORD PTR _npos$[esp+12]
$L73072:

; 3665 : 		{
; 3666 : 			save_for=npos;

  01f5e	8b cd		 mov	 ecx, ebp

; 3667 : 		}
; 3668 : 		else

  01f60	e9 50 ff ff ff	 jmp	 $L73071
$L72157:

; 3669 : 		{
; 3670 : 			if ((parser_char_types[dict_data_table[dict_index_table[save_for]]] & TYPE_upper))

  01f65	8b 44 24 24	 mov	 eax, DWORD PTR 24+[esp+12]
  01f69	8b 08		 mov	 ecx, DWORD PTR [eax]
  01f6b	33 c0		 xor	 eax, eax
  01f6d	8a 81 00 00 00
	00		 mov	 al, BYTE PTR _dict_data_table[ecx]
  01f73	8a 0c 45 00 00
	00 00		 mov	 cl, BYTE PTR _parser_char_types[eax*2]
$L73070:
  01f7a	5f		 pop	 edi
  01f7b	5e		 pop	 esi
  01f7c	5d		 pop	 ebp

; 3687 : 	}             
; 3688 : 	return(0);

  01f7d	33 c0		 xor	 eax, eax
  01f7f	5b		 pop	 ebx

; 3689 : #ifdef DEBUG
; 3690 : 	printf("leaving par_search_for_word failure\n");
; 3691 : #endif
; 3692 : }

  01f80	c3		 ret	 0
_par_search_for_word ENDP
_output_array$ = 16
_ret_value$ = 32
_par_check_word_string PROC NEAR

; 3731 : 	register int i;
; 3732 : 	int has_cons=0,has_vowel=0;
; 3733 : 	int temp;
; 3734 : #ifdef DEBUG
; 3735 : 	printf("entering par_check_word_string\n");
; 3736 : #endif
; 3737 : 	/*
; 3738 : 	*	check the inputs for valid data 
; 3739 : 	*/
; 3740 : #ifdef SANITY_CHECKING
; 3741 : 	if (ret_value==NULL)
; 3742 : 	{
; 3743 : #ifdef DEBUG
; 3744 : 		printf("leaving par_check_word_string ret_value is NULL\n");
; 3745 : #endif
; 3746 : 		return;
; 3747 : 	}
; 3748 : 	if ((output_array==NULL))
; 3749 : 	{
; 3750 : 		ret_value->value=FATAL_FAIL;
; 3751 : #ifdef DEBUG
; 3752 : 		printf("leaving par_check_word_string input is NULL\n");
; 3753 : #endif
; 3754 : 		return;
; 3755 : 	}                 
; 3756 : #endif
; 3757 : 	i=ret_value->output_pos;		

  01f90	8b 54 24 1c	 mov	 edx, DWORD PTR _ret_value$[esp-4]
  01f94	53		 push	 ebx
  01f95	55		 push	 ebp
  01f96	56		 push	 esi
  01f97	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  01f9a	57		 push	 edi

; 3758 : 	/* BATS 874 MGS 03/03/1999 fixed word state */
; 3759 : 	while (i<(ret_value->output_offset+ret_value->output_pos) && ((has_cons & has_vowel)==0))

  01f9b	8b 7a 0c	 mov	 edi, DWORD PTR [edx+12]
  01f9e	33 f6		 xor	 esi, esi
  01fa0	03 f9		 add	 edi, ecx
  01fa2	33 ed		 xor	 ebp, ebp
  01fa4	3b cf		 cmp	 ecx, edi
  01fa6	7d 44		 jge	 SHORT $L72199
$L72192:
  01fa8	85 ee		 test	 ebp, esi
  01faa	75 32		 jne	 SHORT $L72193

; 3760 : 	{
; 3761 : 		temp=parser_char_types[output_array[i]];

  01fac	8b 5c 24 1c	 mov	 ebx, DWORD PTR _output_array$[esp+12]
  01fb0	33 c0		 xor	 eax, eax
  01fb2	8a 04 19	 mov	 al, BYTE PTR [ecx+ebx]
  01fb5	8b d8		 mov	 ebx, eax
  01fb7	33 c0		 xor	 eax, eax
  01fb9	66 8b 04 5d 00
	00 00 00	 mov	 ax, WORD PTR _parser_char_types[ebx*2]

; 3762 : 		if (temp & TYPE_consonant)

  01fc1	f6 c4 02	 test	 ah, 2
  01fc4	74 05		 je	 SHORT $L72194

; 3763 : 		{
; 3764 : 			has_cons=1;

  01fc6	be 01 00 00 00	 mov	 esi, 1
$L72194:

; 3765 : 		}
; 3766 : 		if (temp & TYPE_vowel)

  01fcb	f6 c4 01	 test	 ah, 1
  01fce	74 05		 je	 SHORT $L72195

; 3767 : 		{
; 3768 : 			has_vowel=1;

  01fd0	bd 01 00 00 00	 mov	 ebp, 1
$L72195:

; 3769 : 		}                                
; 3770 : 		if ((temp & TYPE_alpha) == 0)

  01fd5	a8 08		 test	 al, 8
  01fd7	74 26		 je	 SHORT $L73087

; 3773 : 			{
; 3774 : 				ret_value->value=OPT_FAIL;
; 3775 : 			}
; 3776 : 			else
; 3777 : 			{	
; 3778 : 				ret_value->value=FAIL;
; 3779 : 			}
; 3780 : #ifdef DEBUG
; 3781 : 			printf("the output is not a word\n");
; 3782 : #endif
; 3783 : 			return;
; 3784 : 		}			
; 3785 : 		i++;

  01fd9	41		 inc	 ecx
  01fda	3b cf		 cmp	 ecx, edi
  01fdc	7c ca		 jl	 SHORT $L72192
$L72193:

; 3786 : 	}
; 3787 : 	/* BATS 874 MGS 03/03/1999 fixed word state */
; 3788 : 	if (has_cons && has_vowel && (ret_value->output_offset)>=2)

  01fde	85 f6		 test	 esi, esi
  01fe0	74 0a		 je	 SHORT $L72199
  01fe2	85 ed		 test	 ebp, ebp
  01fe4	74 06		 je	 SHORT $L72199
  01fe6	83 7a 0c 02	 cmp	 DWORD PTR [edx+12], 2
  01fea	7d 2d		 jge	 SHORT $L72202
$L72199:

; 3789 : 	{
; 3790 : #ifdef DEBUG
; 3791 : 		printf("the output may be a word\n");
; 3792 : #endif
; 3793 : 	}         
; 3794 : 	else
; 3795 : 	{
; 3796 : 		if (ret_value->optional)

  01fec	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  01fef	85 c0		 test	 eax, eax
  01ff1	74 1f		 je	 SHORT $L72197
  01ff3	5f		 pop	 edi
  01ff4	5e		 pop	 esi
  01ff5	5d		 pop	 ebp

; 3797 : 		{
; 3798 : 			ret_value->value=OPT_FAIL;

  01ff6	c7 42 14 02 00
	00 00		 mov	 DWORD PTR [edx+20], 2
  01ffd	5b		 pop	 ebx

; 3803 : 		}
; 3804 : #ifdef DEBUG
; 3805 : 		printf("the output is not a word\n");
; 3806 : #endif
; 3807 : 	}
; 3808 : #ifdef DEBUG
; 3809 : 	printf("leaving par_check_word_string\n");
; 3810 : #endif
; 3811 : 	return;
; 3812 : }

  01ffe	c3		 ret	 0
$L73087:

; 3771 : 		{
; 3772 : 			if (ret_value->optional)

  01fff	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  02002	85 c0		 test	 eax, eax
  02004	74 0c		 je	 SHORT $L72197
  02006	5f		 pop	 edi
  02007	5e		 pop	 esi
  02008	5d		 pop	 ebp

; 3797 : 		{
; 3798 : 			ret_value->value=OPT_FAIL;

  02009	c7 42 14 02 00
	00 00		 mov	 DWORD PTR [edx+20], 2
  02010	5b		 pop	 ebx

; 3803 : 		}
; 3804 : #ifdef DEBUG
; 3805 : 		printf("the output is not a word\n");
; 3806 : #endif
; 3807 : 	}
; 3808 : #ifdef DEBUG
; 3809 : 	printf("leaving par_check_word_string\n");
; 3810 : #endif
; 3811 : 	return;
; 3812 : }

  02011	c3		 ret	 0
$L72197:

; 3799 : 		}
; 3800 : 		else
; 3801 : 		{	
; 3802 : 			ret_value->value=FAIL;

  02012	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0
$L72202:
  02019	5f		 pop	 edi
  0201a	5e		 pop	 esi
  0201b	5d		 pop	 ebp
  0201c	5b		 pop	 ebx

; 3803 : 		}
; 3804 : #ifdef DEBUG
; 3805 : 		printf("the output is not a word\n");
; 3806 : #endif
; 3807 : 	}
; 3808 : #ifdef DEBUG
; 3809 : 	printf("leaving par_check_word_string\n");
; 3810 : #endif
; 3811 : 	return;
; 3812 : }

  0201d	c3		 ret	 0
_par_check_word_string ENDP
_TEXT	ENDS
EXTRN	__imp__atoi:NEAR
_TEXT	SEGMENT
_current_rule$ = 8
_output_array$ = 16
_match_array$ = 28
_ret_value$ = 32
_range_value$ = 36
_in_rule_index$ = 48
_length$ = -16
_buf$ = -12
_par_status_string PROC NEAR

; 3831 : {

  02020	83 ec 10	 sub	 esp, 16			; 00000010H

; 3832 : 	int length=0;
; 3833 : 	unsigned char buf[10];
; 3834 : 
; 3835 : 	par_build_string_from_rule(current_rule,buf,output_array,match_array,ret_value,range_value,BIN_STATUS,&length,in_rule_index);

  02023	8b 44 24 3c	 mov	 eax, DWORD PTR _in_rule_index$[esp+12]
  02027	8b 54 24 30	 mov	 edx, DWORD PTR _range_value$[esp+12]
  0202b	56		 push	 esi
  0202c	8b 74 24 30	 mov	 esi, DWORD PTR _ret_value$[esp+16]
  02030	8d 4c 24 04	 lea	 ecx, DWORD PTR _length$[esp+20]
  02034	50		 push	 eax
  02035	8b 44 24 30	 mov	 eax, DWORD PTR _match_array$[esp+20]
  02039	51		 push	 ecx
  0203a	8b 4c 24 28	 mov	 ecx, DWORD PTR _output_array$[esp+24]
  0203e	6a 1e		 push	 30			; 0000001eH
  02040	52		 push	 edx
  02041	56		 push	 esi
  02042	50		 push	 eax
  02043	8b 44 24 30	 mov	 eax, DWORD PTR _current_rule$[esp+40]
  02047	8d 54 24 20	 lea	 edx, DWORD PTR _buf$[esp+44]
  0204b	51		 push	 ecx
  0204c	52		 push	 edx
  0204d	50		 push	 eax
  0204e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _length$[esp+56], 0
  02056	e8 00 00 00 00	 call	 _par_build_string_from_rule

; 3836 : 	ret_value->parser_flag = atoi(buf);

  0205b	8d 4c 24 2c	 lea	 ecx, DWORD PTR _buf$[esp+56]
  0205f	51		 push	 ecx
  02060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  02066	83 c4 28	 add	 esp, 40			; 00000028H
  02069	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  0206c	5e		 pop	 esi

; 3837 : }

  0206d	83 c4 10	 add	 esp, 16			; 00000010H
  02070	c3		 ret	 0
_par_status_string ENDP
_TEXT	ENDS
PUBLIC	_par_convert_number_new2
_TEXT	SEGMENT
_current_rule$ = 8
_buf$ = 12
_output_array$ = 16
_match_array$ = 20
_ret_value$ = 24
_range_value$ = 28
_state$ = 32
_length$ = 36
_in_rule_index$ = 40
_buf_ind$ = -8
_end_of_action$ = -4
_end_of_build$ = 8
_par_build_string_from_rule PROC NEAR

; 3889 : {

  02080	83 ec 08	 sub	 esp, 8
  02083	53		 push	 ebx
  02084	55		 push	 ebp

; 3890 : 	int is_cond=0;						/* is the current replacement conditional */
; 3891 : 	int cond_num=0;						/* what number conditioal thing to replace with */
; 3892 : 	int rule_p;							/* a temporary rule pointer */
; 3893 : 	int buf_ind=0;						/* the current index into the temp buffer */
; 3894 : 	int match_l=0;						/* the length of the string in the save array */
; 3895 : 	int match_num;						/* the index of the save array to be used */
; 3896 : 	U8 end_of_action;
; 3897 : 	U8 end_of_build;
; 3898 : 	
; 3899 : #ifdef DEBUG
; 3900 : 	printf("entering par_build_string_from_rule\n");
; 3901 : #endif
; 3902 : 	/*
; 3903 : 	*	check input values
; 3904 : 	*/
; 3905 : #ifdef SANITY_CHECKING
; 3906 : 	if (ret_value==NULL)
; 3907 : 	{
; 3908 : #ifdef DEBUG
; 3909 : 		printf("leaving par_build_string_from_rule ret_value is NULL\n");
; 3910 : #endif
; 3911 : 		return(NULL);
; 3912 : 	}
; 3913 : 	if ((current_rule==NULL) || (buf == NULL) || (match_array == NULL) ||
; 3914 : 		(state == BIN_END_OF_RULE) || (length==NULL))
; 3915 : 	{
; 3916 : #ifdef DEBUG
; 3917 : 		printf("leaving par_build_string_from_rule; inputs are invalid\n");
; 3918 : #endif
; 3919 : 		ret_value->value=FATAL_FAIL;
; 3920 : 		return(NULL);
; 3921 : 	}
; 3922 : #endif
; 3923 : 	
; 3924 : 	rule_p=ret_value->rule;
; 3925 : 	end_of_action=current_rule[in_rule_index+2];

  02085	8b 6c 24 14	 mov	 ebp, DWORD PTR _current_rule$[esp+12]
  02089	56		 push	 esi
  0208a	8b 74 24 38	 mov	 esi, DWORD PTR _in_rule_index$[esp+16]
  0208e	8b 4c 24 28	 mov	 ecx, DWORD PTR _ret_value$[esp+16]
  02092	57		 push	 edi
  02093	33 ff		 xor	 edi, edi
  02095	8b 59 10	 mov	 ebx, DWORD PTR [ecx+16]
  02098	8d 44 2e 02	 lea	 eax, DWORD PTR [esi+ebp+2]
  0209c	89 44 24 3c	 mov	 DWORD PTR 40+[esp+20], eax
  020a0	89 7c 24 10	 mov	 DWORD PTR _buf_ind$[esp+24], edi
  020a4	8a 00		 mov	 al, BYTE PTR [eax]
  020a6	88 44 24 14	 mov	 BYTE PTR _end_of_action$[esp+24], al

; 3926 : 	end_of_build=end_of_action;

  020aa	88 44 24 1c	 mov	 BYTE PTR _end_of_build$[esp+20], al

; 3927 : #ifdef DEBUG
; 3928 : 	printf("current_rule[%d]=%c\n",rule_p,current_rule[rule_p]);
; 3929 : 	if (current_rule[rule_p]==BIN_EXACT)
; 3930 : 		printf("found an exact character delimiter\n");
; 3931 : #endif
; 3932 : 	buf[0]='\0';	/* clear buf just in case */

  020ae	8b 44 24 20	 mov	 eax, DWORD PTR _buf$[esp+20]
  020b2	c6 00 00	 mov	 BYTE PTR [eax], 0

; 3933 : 	/* build the string until a '/' is hit */
; 3934 : 	
; 3935 : 	if (current_rule[in_rule_index] & BIN_CONDITIONAL_REPLACE)

  020b5	8a 04 2e	 mov	 al, BYTE PTR [esi+ebp]
  020b8	a8 80		 test	 al, 128			; 00000080H
  020ba	0f 84 ed 00 00
	00		 je	 $L73095

; 3936 : 	{
; 3937 : 		is_cond=-1;
; 3938 : #ifndef GERMAN_COMPOUND_NOUNS
; 3939 : 		switch (state)
; 3940 : #else
; 3941 : 		switch(state & BIN_OPERATION_MASK)
; 3942 : #endif
; 3943 : 		{

  020c0	8b 44 24 34	 mov	 eax, DWORD PTR _state$[esp+20]
  020c4	8b d0		 mov	 edx, eax
  020c6	83 e2 1f	 and	 edx, 31			; 0000001fH
  020c9	80 fa 1a	 cmp	 dl, 26			; 0000001aH
  020cc	75 65		 jne	 SHORT $L72268

; 3944 : #ifndef GERMAN_COMPOUND_NOUNS
; 3945 : 			/* MGS fixed this, it was BIN_INSERT but it should be BIN_BEFORE */
; 3946 : 		case BIN_BEFORE:
; 3947 : #endif
; 3948 : #ifdef GERMAN_COMPOUND_NOUNS
; 3949 : 		case BIN_INSERT:
; 3950 : 			if (state & BIN_BEFORE_FLAG)

  020ce	a8 20		 test	 al, 32			; 00000020H
  020d0	74 2d		 je	 SHORT $L72263

; 3951 : 			{
; 3952 : #endif
; 3953 : 			/* read the first character in the output range */
; 3954 : 			if (range_value->range_set==2)

  020d2	8b 44 24 30	 mov	 eax, DWORD PTR _range_value$[esp+20]
  020d6	83 78 0c 02	 cmp	 DWORD PTR [eax+12], 2
  020da	75 07		 jne	 SHORT $L72264

; 3955 : 			{
; 3956 : 				cond_num=range_value->start;

  020dc	8b 00		 mov	 eax, DWORD PTR [eax]

; 3957 : 			}
; 3958 : 			else

  020de	e9 88 00 00 00	 jmp	 $L72276
$L72264:

; 3959 : 			{
; 3960 : 				cond_num=output_array[ret_value->output_pos]-'0';

  020e3	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  020e6	8b 54 24 24	 mov	 edx, DWORD PTR _output_array$[esp+20]
  020ea	33 c9		 xor	 ecx, ecx
  020ec	8a 0c 10	 mov	 cl, BYTE PTR [eax+edx]
  020ef	8b c1		 mov	 eax, ecx
  020f1	83 e8 30	 sub	 eax, 48			; 00000030H

; 3961 : 				if (cond_num<0 || cond_num>9)

  020f4	78 39		 js	 SHORT $L72267
  020f6	83 f8 09	 cmp	 eax, 9
  020f9	7e 70		 jle	 SHORT $L72276

; 3962 : 					cond_num=0;

  020fb	33 c0		 xor	 eax, eax

; 3963 : 			}
; 3964 : 			break;

  020fd	eb 6c		 jmp	 SHORT $L72276
$L72263:

; 3965 : #ifndef GERMAN_COMPOUND_NOUNS
; 3966 : 		case BIN_AFTER:
; 3967 : #else
; 3968 : 			}
; 3969 : 			if (state & BIN_AFTER_FLAG)

  020ff	a8 40		 test	 al, 64			; 00000040H
  02101	74 30		 je	 SHORT $L72268

; 3970 : 			{
; 3971 : #endif
; 3972 : 			/* convert the last character in the range */
; 3973 : 			if (range_value->range_set==2)

  02103	8b 44 24 30	 mov	 eax, DWORD PTR _range_value$[esp+20]
  02107	83 78 0c 02	 cmp	 DWORD PTR [eax+12], 2
  0210b	75 04		 jne	 SHORT $L72269

; 3974 : 			{
; 3975 : 				cond_num=range_value->start;

  0210d	8b 00		 mov	 eax, DWORD PTR [eax]

; 3976 : 			}
; 3977 : 			else

  0210f	eb 5a		 jmp	 SHORT $L72276
$L72269:

; 3978 : 			{
; 3979 : 				cond_num=output_array[ret_value->output_pos+ret_value->output_offset-1]-'0';

  02111	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  02114	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  02117	03 c2		 add	 eax, edx
  02119	8b 54 24 24	 mov	 edx, DWORD PTR _output_array$[esp+20]
  0211d	33 c9		 xor	 ecx, ecx
  0211f	8a 4c 10 ff	 mov	 cl, BYTE PTR [eax+edx-1]
  02123	8b c1		 mov	 eax, ecx
  02125	83 e8 30	 sub	 eax, 48			; 00000030H

; 3980 : 				if (cond_num<0 || cond_num>9)

  02128	78 05		 js	 SHORT $L72267
  0212a	83 f8 09	 cmp	 eax, 9
  0212d	7e 3c		 jle	 SHORT $L72276
$L72267:

; 3981 : 					cond_num=0;

  0212f	33 c0		 xor	 eax, eax

; 3982 : 			}
; 3983 : 			break;

  02131	eb 38		 jmp	 SHORT $L72276
$L72268:

; 3984 : #ifdef GERMAN_COMPOUND_NOUNS
; 3985 : 			}
; 3986 : 			/* for GERMAN_COMPOUND_NOUNS, it is intended to not have a break after 
; 3987 : 			   the case for BIN_INSERT so it can do the right thing */
; 3988 : #endif
; 3989 : 
; 3990 : 		default:
; 3991 : 			if (range_value->range_set==2)

  02133	8b 44 24 30	 mov	 eax, DWORD PTR _range_value$[esp+20]
  02137	83 78 0c 02	 cmp	 DWORD PTR [eax+12], 2
  0213b	75 04		 jne	 SHORT $L72274

; 3992 : 			{
; 3993 : 				cond_num=range_value->start;

  0213d	8b 00		 mov	 eax, DWORD PTR [eax]

; 3994 : 			}
; 3995 : 			else

  0213f	eb 2a		 jmp	 SHORT $L72276
$L72274:

; 3996 : 			{
; 3997 : 				/* convert all the character in the range */
; 3998 : 				/*	a range_value->range_set == -1 cant have any fancy conditionals
; 3999 : 				so it just does the normal stuff of converting the digits
; 4000 : 				*/
; 4001 : 				output_array[ret_value->output_offset+ret_value->output_pos]='\0';

  02141	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  02144	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  02147	03 d0		 add	 edx, eax
  02149	8b 44 24 24	 mov	 eax, DWORD PTR _output_array$[esp+20]
  0214d	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 4002 : 				cond_num=par_convert_number_new2(output_array+ret_value->output_pos);

  02151	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  02154	03 c8		 add	 ecx, eax
  02156	51		 push	 ecx
  02157	e8 00 00 00 00	 call	 _par_convert_number_new2

; 4003 : 				if (range_value->range_set==1)

  0215c	8b 4c 24 34	 mov	 ecx, DWORD PTR _range_value$[esp+24]
  02160	83 c4 04	 add	 esp, 4
  02163	83 79 0c 01	 cmp	 DWORD PTR [ecx+12], 1
  02167	75 02		 jne	 SHORT $L72276

; 4004 : 				{
; 4005 : 					cond_num-=range_value->start;

  02169	2b 01		 sub	 eax, DWORD PTR [ecx]
$L72276:

; 4006 : 				}
; 4007 : 			}
; 4008 : 		}
; 4009 : 		if (cond_num > (current_rule[in_rule_index+3]))

  0216b	33 c9		 xor	 ecx, ecx
  0216d	8a 4c 2e 03	 mov	 cl, BYTE PTR [esi+ebp+3]
  02171	3b c1		 cmp	 eax, ecx

; 4010 : 		{
; 4011 : 			cond_num=0;
; 4012 : 		}
; 4013 : 		if (cond_num==0)

  02173	7f 04		 jg	 SHORT $L73096
  02175	85 c0		 test	 eax, eax
  02177	75 06		 jne	 SHORT $L72278
$L73096:

; 4014 : 		{
; 4015 : 			end_of_build=current_rule[in_rule_index+4];

  02179	8a 54 2e 04	 mov	 dl, BYTE PTR [esi+ebp+4]

; 4016 : 		}
; 4017 : 		else

  0217d	eb 26		 jmp	 SHORT $L73101
$L72278:

; 4018 : 		{
; 4019 : 			if (cond_num == (current_rule[in_rule_index+3]))

  0217f	3b c1		 cmp	 eax, ecx
  02181	75 15		 jne	 SHORT $L72280

; 4020 : 			{
; 4021 : 				rule_p=current_rule[in_rule_index+3+cond_num]+1;

  02183	03 c5		 add	 eax, ebp
  02185	33 db		 xor	 ebx, ebx
  02187	8a 5c 30 03	 mov	 bl, BYTE PTR [eax+esi+3]

; 4022 : 				end_of_build=current_rule[in_rule_index+2];

  0218b	8b 44 24 3c	 mov	 eax, DWORD PTR 40+[esp+20]
  0218f	43		 inc	 ebx
  02190	8a 08		 mov	 cl, BYTE PTR [eax]
  02192	88 4c 24 1c	 mov	 BYTE PTR _end_of_build$[esp+20], cl

; 4023 : 			}
; 4024 : 			else

  02196	eb 11		 jmp	 SHORT $L73102
$L72280:

; 4025 : 			{
; 4026 : 				rule_p=current_rule[in_rule_index+3+cond_num]+1;

  02198	03 c5		 add	 eax, ebp
  0219a	33 db		 xor	 ebx, ebx
  0219c	03 f0		 add	 esi, eax
  0219e	8a 5e 03	 mov	 bl, BYTE PTR [esi+3]

; 4027 : 				end_of_build=current_rule[in_rule_index+4+cond_num];

  021a1	8a 56 04	 mov	 dl, BYTE PTR [esi+4]
  021a4	43		 inc	 ebx
$L73101:
  021a5	88 54 24 1c	 mov	 BYTE PTR _end_of_build$[esp+20], dl
$L73102:
  021a9	8b 4c 24 2c	 mov	 ecx, DWORD PTR _ret_value$[esp+20]
$L73095:

; 4028 : 			}
; 4029 : 		}
; 4030 : 		
; 4031 : 	}
; 4032 : 	while (rule_p<=end_of_build)

  021ad	8b 44 24 1c	 mov	 eax, DWORD PTR _end_of_build$[esp+20]
  021b1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  021b6	3b d8		 cmp	 ebx, eax
  021b8	89 44 24 30	 mov	 DWORD PTR 28+[esp+20], eax
  021bc	0f 8f 9d 00 00
	00		 jg	 $L72284
$L72283:

; 4033 : 	{
; 4034 : 		/* build the string until either a slash is found or a conditional is found */
; 4035 : 		switch (current_rule[rule_p] & BIN_OPERATION_MASK)
; 4036 : 		{

  021c2	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  021c5	83 e0 1f	 and	 eax, 31			; 0000001fH
  021c8	83 e8 10	 sub	 eax, 16			; 00000010H
  021cb	74 58		 je	 SHORT $L72289
  021cd	48		 dec	 eax
  021ce	74 41		 je	 SHORT $L72291
  021d0	48		 dec	 eax
  021d1	0f 85 ac 00 00
	00		 jne	 $L72292

; 4044 : 			break;
; 4045 : 		case BIN_RESTORE:						/* a $# sequence was found. */
; 4046 : 			rule_p++;
; 4047 : 			match_num=current_rule[rule_p];
; 4048 : 			match_l=match_array->array_lengths[match_num];	/* get the length of the strig in the array */

  021d7	8b 74 24 28	 mov	 esi, DWORD PTR _match_array$[esp+20]
  021db	43		 inc	 ebx
  021dc	33 c0		 xor	 eax, eax
  021de	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  021e1	8b 14 86	 mov	 edx, DWORD PTR [esi+eax*4]

; 4049 : 			memcpy(buf+buf_ind,match_array->array[match_num],match_l);

  021e4	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  021e7	8b ca		 mov	 ecx, edx
  021e9	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  021ec	8d 74 46 28	 lea	 esi, DWORD PTR [esi+eax*2+40]
  021f0	8b 44 24 20	 mov	 eax, DWORD PTR _buf$[esp+20]
  021f4	03 f8		 add	 edi, eax
  021f6	8b c1		 mov	 eax, ecx
  021f8	c1 e9 02	 shr	 ecx, 2
  021fb	f3 a5		 rep movsd
  021fd	8b c8		 mov	 ecx, eax
  021ff	83 e1 03	 and	 ecx, 3
  02202	f3 a4		 rep movsb

; 4050 : 			buf_ind+=match_l;   		/* add the length of the string in the array to buff_ind */

  02204	8b 4c 24 10	 mov	 ecx, DWORD PTR _buf_ind$[esp+24]
  02208	03 ca		 add	 ecx, edx

; 4051 : 			rule_p++;

  0220a	43		 inc	 ebx
  0220b	89 4c 24 10	 mov	 DWORD PTR _buf_ind$[esp+24], ecx

; 4052 : 			break;

  0220f	eb 3a		 jmp	 SHORT $L73103
$L72291:

; 4053 : 		case BIN_HEXADECIMAL:
; 4054 : 			/* a hexadecimal value was found */
; 4055 : 			/* hexadecimal values have to be specified in the format 0xab */
; 4056 : 			/* they must have 2 legal letters after the x */
; 4057 : 			rule_p++;
; 4058 : 			buf[buf_ind]=current_rule[rule_p]; /* put the value into the buffer array */

  02211	8b 54 24 20	 mov	 edx, DWORD PTR _buf$[esp+20]
  02215	8a 4c 2b 01	 mov	 cl, BYTE PTR [ebx+ebp+1]
  02219	43		 inc	 ebx
  0221a	88 0c 17	 mov	 BYTE PTR [edi+edx], cl

; 4059 : 			buf_ind++;

  0221d	47		 inc	 edi
  0221e	89 7c 24 10	 mov	 DWORD PTR _buf_ind$[esp+24], edi

; 4060 : 			rule_p++;

  02222	43		 inc	 ebx

; 4061 : 			break;

  02223	eb 2a		 jmp	 SHORT $L72286
$L72289:

; 4037 : 		case BIN_EXACT:		/* an exact string was found */
; 4038 : 			rule_p++;
; 4039 : 			match_l=current_rule[rule_p];
; 4040 : 			rule_p++;
; 4041 : 			memcpy(&buf[buf_ind],&current_rule[rule_p],match_l);

  02225	8b 54 24 20	 mov	 edx, DWORD PTR _buf$[esp+20]
  02229	43		 inc	 ebx
  0222a	33 c0		 xor	 eax, eax
  0222c	03 fa		 add	 edi, edx
  0222e	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02231	43		 inc	 ebx
  02232	8b c8		 mov	 ecx, eax
  02234	8b d1		 mov	 edx, ecx
  02236	8d 34 2b	 lea	 esi, DWORD PTR [ebx+ebp]
  02239	c1 e9 02	 shr	 ecx, 2
  0223c	f3 a5		 rep movsd
  0223e	8b ca		 mov	 ecx, edx

; 4042 : 			rule_p+=match_l;

  02240	03 d8		 add	 ebx, eax
  02242	83 e1 03	 and	 ecx, 3
  02245	f3 a4		 rep movsb

; 4043 : 			buf_ind+=match_l;

  02247	01 44 24 10	 add	 DWORD PTR _buf_ind$[esp+24], eax
$L73103:
  0224b	8b 7c 24 10	 mov	 edi, DWORD PTR _buf_ind$[esp+24]
$L72286:

; 4028 : 			}
; 4029 : 		}
; 4030 : 		
; 4031 : 	}
; 4032 : 	while (rule_p<=end_of_build)

  0224f	8b 44 24 30	 mov	 eax, DWORD PTR 28+[esp+20]
  02253	8b 4c 24 2c	 mov	 ecx, DWORD PTR _ret_value$[esp+20]
  02257	3b d8		 cmp	 ebx, eax
  02259	0f 8e 63 ff ff
	ff		 jle	 $L72283
$L72284:

; 4069 : 		}
; 4070 : 	}
; 4071 : 	/* the end of the rule has been hit */
; 4072 : 	buf[buf_ind]='\0';

  0225f	8b 44 24 20	 mov	 eax, DWORD PTR _buf$[esp+20]

; 4073 : 	*length=buf_ind;

  02263	8b 54 24 38	 mov	 edx, DWORD PTR _length$[esp+20]
  02267	c6 04 07 00	 mov	 BYTE PTR [edi+eax], 0
  0226b	89 3a		 mov	 DWORD PTR [edx], edi

; 4074 : 	ret_value->rule=end_of_action+1;

  0226d	8b 54 24 14	 mov	 edx, DWORD PTR _end_of_action$[esp+24]
  02271	5f		 pop	 edi
  02272	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  02278	5e		 pop	 esi
  02279	42		 inc	 edx
  0227a	5d		 pop	 ebp
  0227b	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0227e	5b		 pop	 ebx

; 4075 : #ifdef DEBUG2
; 4076 : 	par_print_rule_error("no error, just debugging output position",current_rule,rule_p);
; 4077 : #endif
; 4078 : #ifdef 	DEBUG
; 4079 : 	printf("leaving par_build_string_from_rule buf=%s\n",buf);
; 4080 : #endif
; 4081 : 	return(buf);
; 4082 : }

  0227f	83 c4 08	 add	 esp, 8
  02282	c3		 ret	 0
$L72292:
  02283	5f		 pop	 edi
  02284	5e		 pop	 esi
  02285	5d		 pop	 ebp

; 4062 : 		default:
; 4063 : 			/* the current character is not a recognized type */
; 4064 : #ifdef DEBUG
; 4065 : 			par_print_rule_error("build_string;unrecognized delimiter",current_rule,rule_p);
; 4066 : #endif
; 4067 : 			ret_value->value=FATAL_FAIL;

  02286	c7 41 14 04 00
	00 00		 mov	 DWORD PTR [ecx+20], 4

; 4068 : 			return(NULL);

  0228d	33 c0		 xor	 eax, eax
  0228f	5b		 pop	 ebx

; 4075 : #ifdef DEBUG2
; 4076 : 	par_print_rule_error("no error, just debugging output position",current_rule,rule_p);
; 4077 : #endif
; 4078 : #ifdef 	DEBUG
; 4079 : 	printf("leaving par_build_string_from_rule buf=%s\n",buf);
; 4080 : #endif
; 4081 : 	return(buf);
; 4082 : }

  02290	83 c4 08	 add	 esp, 8
  02293	c3		 ret	 0
_par_build_string_from_rule ENDP
_TEXT	ENDS
PUBLIC	_par_match_sets_with_ranges
PUBLIC	_par_match_digits
PUBLIC	_par_match_standard
EXTRN	_par_lower:BYTE
_TEXT	SEGMENT
_current_rule$ = 8
_char_type$ = 12
_input_array$ = 16
_match_array$ = 20
_ret_value$ = 24
_range_value$ = 28
_lookahead$ = 32
_break_on_min_match$ = 36
_par_match_string PROC NEAR

; 4128 : 	register int rule_p;
; 4129 : 	register int ipos;
; 4130 : 	int length=0;
; 4131 : 	int value;
; 4132 : 	
; 4133 : 	
; 4134 : #ifdef DEBUG
; 4135 : 	printf("entering par_match_string\n");
; 4136 : #endif
; 4137 : 	
; 4138 : 
; 4139 : 	
; 4140 : 	rule_p=ret_value->rule;
; 4141 : 	ipos=ret_value->input_pos+ret_value->input_offset;
; 4142 : 	
; 4143 : 	if (char_type<=BIN_DIGIT)

  022a0	8b 44 24 08	 mov	 eax, DWORD PTR _char_type$[esp-4]
  022a4	53		 push	 ebx
  022a5	55		 push	 ebp
  022a6	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ret_value$[esp+4]
  022aa	56		 push	 esi
  022ab	57		 push	 edi
  022ac	8b 75 04	 mov	 esi, DWORD PTR [ebp+4]
  022af	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  022b2	8b 4d 10	 mov	 ecx, DWORD PTR [ebp+16]
  022b5	03 f3		 add	 esi, ebx
  022b7	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  022ba	8b d1		 mov	 edx, ecx
  022bc	7f 50		 jg	 SHORT $L72315

; 4144 : 	{
; 4145 : 		if (current_rule[rule_p] & BIN_DIGIT_RANGE)

  022be	8b 4c 24 14	 mov	 ecx, DWORD PTR _current_rule$[esp+12]
  022c2	f6 04 0a 20	 test	 BYTE PTR [edx+ecx], 32	; 00000020H
  022c6	74 25		 je	 SHORT $L72316

; 4146 : 		{
; 4147 : 			/* check for the special digit type and if it is there */
; 4148 : 			/* use the special digit matching function. */
; 4149 : 			/* use the normal one otherwise */
; 4150 : 			length=par_match_digits(current_rule,input_array,match_array,ret_value,range_value,lookahead,break_on_min_match);

  022c8	8b 44 24 30	 mov	 eax, DWORD PTR _break_on_min_match$[esp+12]
  022cc	8b 54 24 2c	 mov	 edx, DWORD PTR _lookahead$[esp+12]
  022d0	50		 push	 eax
  022d1	8b 44 24 2c	 mov	 eax, DWORD PTR _range_value$[esp+16]
  022d5	52		 push	 edx
  022d6	8b 54 24 28	 mov	 edx, DWORD PTR _match_array$[esp+20]
  022da	50		 push	 eax
  022db	8b 44 24 28	 mov	 eax, DWORD PTR _input_array$[esp+24]
  022df	55		 push	 ebp
  022e0	52		 push	 edx
  022e1	50		 push	 eax
  022e2	51		 push	 ecx
  022e3	e8 00 00 00 00	 call	 _par_match_digits

; 4151 : 		}
; 4152 : 		else

  022e8	e9 49 01 00 00	 jmp	 $L73112
$L72316:

; 4153 : 		{
; 4154 : 			length=par_match_standard(current_rule,char_type,input_array,match_array,ret_value,lookahead,break_on_min_match);

  022ed	8b 54 24 30	 mov	 edx, DWORD PTR _break_on_min_match$[esp+12]
  022f1	52		 push	 edx
  022f2	8b 54 24 30	 mov	 edx, DWORD PTR _lookahead$[esp+16]
  022f6	52		 push	 edx
  022f7	8b 54 24 28	 mov	 edx, DWORD PTR _match_array$[esp+20]
  022fb	55		 push	 ebp
  022fc	52		 push	 edx
  022fd	8b 54 24 2c	 mov	 edx, DWORD PTR _input_array$[esp+28]
  02301	52		 push	 edx
  02302	50		 push	 eax
  02303	51		 push	 ecx
  02304	e8 00 00 00 00	 call	 _par_match_standard

; 4155 : 		}
; 4156 : 		rule_p=ret_value->rule;
; 4157 : 	}
; 4158 : 	else	/* if (char_type<=BIN_DIGIT) */

  02309	e9 28 01 00 00	 jmp	 $L73112
$L72315:

; 4159 : 	{
; 4160 : 		if (char_type<=BIN_HEXADECIMAL)

  0230e	83 f8 11	 cmp	 eax, 17			; 00000011H
  02311	0f 8f a6 00 00
	00		 jg	 $L72319

; 4161 : 		{
; 4162 : 			
; 4163 : 			if (char_type==BIN_EXACT)

  02317	83 f8 10	 cmp	 eax, 16			; 00000010H
  0231a	75 6e		 jne	 SHORT $L72320

; 4164 : 			{
; 4165 : 				rule_p++;
; 4166 : 				length=0;
; 4167 : 				value=current_rule[rule_p];

  0231c	8b 7c 24 14	 mov	 edi, DWORD PTR _current_rule$[esp+12]
  02320	42		 inc	 edx
  02321	33 db		 xor	 ebx, ebx
  02323	33 c0		 xor	 eax, eax
  02325	8a 1c 3a	 mov	 bl, BYTE PTR [edx+edi]

; 4168 : 				rule_p++;

  02328	42		 inc	 edx

; 4169 : 				if (current_rule[ret_value->rule] & BIN_CASE_INSEN)

  02329	f6 04 39 20	 test	 BYTE PTR [ecx+edi], 32	; 00000020H
  0232d	74 3b		 je	 SHORT $L72321

; 4170 : 				{
; 4171 : 					while (length<value)

  0232f	85 db		 test	 ebx, ebx
  02331	0f 8e 09 01 00
	00		 jle	 $L73108
  02337	8b 4c 24 1c	 mov	 ecx, DWORD PTR _input_array$[esp+12]
  0233b	03 f1		 add	 esi, ecx
  0233d	89 74 24 1c	 mov	 DWORD PTR 16+[esp+12], esi
$L72323:

; 4172 : 					{
; 4173 : 						if (par_lower[current_rule[rule_p]]!=par_lower[input_array[ipos+length]])

  02341	8b 74 24 1c	 mov	 esi, DWORD PTR 16+[esp+12]
  02345	33 c9		 xor	 ecx, ecx
  02347	8a 0c 06	 mov	 cl, BYTE PTR [esi+eax]
  0234a	8b f1		 mov	 esi, ecx
  0234c	33 c9		 xor	 ecx, ecx
  0234e	8a 0c 3a	 mov	 cl, BYTE PTR [edx+edi]
  02351	8a 89 00 00 00
	00		 mov	 cl, BYTE PTR _par_lower[ecx]
  02357	3a 8e 00 00 00
	00		 cmp	 cl, BYTE PTR _par_lower[esi]
  0235d	75 3c		 jne	 SHORT $L73106

; 4174 : 						{
; 4175 : #ifdef DEBUG
; 4176 : 							printf("leaving par_match_string; exact characters dont match\n");
; 4177 : #endif
; 4178 : 							if (ret_value->optional==1)
; 4179 : 							{
; 4180 : #ifdef DEBUG
; 4181 : 								printf("par_match_string; exact optional set to -1\n");
; 4182 : #endif
; 4183 : //								ret_value->optional= -1;
; 4184 : 								ret_value->value=OPT_FAIL;
; 4185 : 							}
; 4186 : 							else
; 4187 : 							{
; 4188 : 								ret_value->value=FAIL;
; 4189 : 							}
; 4190 : 							return(0);
; 4191 : 						}
; 4192 : 						length++;

  0235f	40		 inc	 eax

; 4193 : 						rule_p++;

  02360	42		 inc	 edx
  02361	3b c3		 cmp	 eax, ebx
  02363	7c dc		 jl	 SHORT $L72323

; 4172 : 					{
; 4173 : 						if (par_lower[current_rule[rule_p]]!=par_lower[input_array[ipos+length]])

  02365	e9 d2 00 00 00	 jmp	 $L72343
$L72321:

; 4194 : 					}
; 4195 : 				}
; 4196 : 				else
; 4197 : 				{
; 4198 : 					if (current_rule[rule_p]!=input_array[ipos])

  0236a	8b 44 24 1c	 mov	 eax, DWORD PTR _input_array$[esp+12]
  0236e	8a 0c 17	 mov	 cl, BYTE PTR [edi+edx]
  02371	03 fa		 add	 edi, edx
  02373	03 f0		 add	 esi, eax
  02375	3a 0e		 cmp	 cl, BYTE PTR [esi]

; 4199 : 					{
; 4200 : #ifdef DEBUG
; 4201 : 						printf("leaving par_match_string; exact characters dont match\n");
; 4202 : #endif
; 4203 : 						if (ret_value->optional==1)
; 4204 : 						{
; 4205 : #ifdef DEBUG
; 4206 : 							printf("par_match_string; exact optional set to -1\n");
; 4207 : #endif
; 4208 : 							//ret_value->optional= -1;
; 4209 : 							ret_value->value=OPT_FAIL;
; 4210 : 						}
; 4211 : 						else

  02377	75 22		 jne	 SHORT $L73106

; 4212 : 						{
; 4213 : 							ret_value->value=FAIL;
; 4214 : 						}
; 4215 : 						return(0);
; 4216 : 					}
; 4217 : 					if (memcmp(input_array+ipos,current_rule+rule_p,value)!=0)

  02379	8b cb		 mov	 ecx, ebx
  0237b	33 c0		 xor	 eax, eax
  0237d	f3 a6		 repe cmpsb

; 4218 : 					{
; 4219 : #ifdef DEBUG
; 4220 : 						printf("leaving par_match_string; exact characters dont match\n");
; 4221 : #endif
; 4222 : 						if (ret_value->optional==1)
; 4223 : 						{
; 4224 : #ifdef DEBUG
; 4225 : 							printf("par_match_string; exact optional set to -1\n");
; 4226 : #endif
; 4227 : 			//				ret_value->optional= -1;
; 4228 : 							ret_value->value=OPT_FAIL;
; 4229 : 							
; 4230 : 						}
; 4231 : 						else

  0237f	75 1a		 jne	 SHORT $L73106

; 4232 : 						{
; 4233 : 							ret_value->value=FAIL;
; 4234 : 						}
; 4235 : 						return(0);
; 4236 : 					}
; 4237 : 					rule_p+=value;

  02381	03 d3		 add	 edx, ebx

; 4238 : 					length=value;

  02383	8b c3		 mov	 eax, ebx

; 4239 : 				}
; 4240 : 			}
; 4241 : 			else /* if (char_type==BIN_EXACT) */

  02385	e9 b2 00 00 00	 jmp	 $L72343
$L72320:

; 4242 : 			{
; 4243 : 				/* BIN_HEXADECIMAL */
; 4244 : 				rule_p++;
; 4245 : 				if (input_array[ipos]!=current_rule[rule_p])

  0238a	8b 4c 24 1c	 mov	 ecx, DWORD PTR _input_array$[esp+12]
  0238e	42		 inc	 edx
  0238f	8a 04 0e	 mov	 al, BYTE PTR [esi+ecx]
  02392	8b 4c 24 14	 mov	 ecx, DWORD PTR _current_rule$[esp+12]
  02396	3a 04 0a	 cmp	 al, BYTE PTR [edx+ecx]
  02399	74 14		 je	 SHORT $L72336
$L73106:

; 4246 : 				{
; 4247 : 					if (ret_value->optional==1)

  0239b	83 7d 18 01	 cmp	 DWORD PTR [ebp+24], 1
  0239f	75 60		 jne	 SHORT $L72337
  023a1	5f		 pop	 edi

; 4248 : 					{
; 4249 : #ifdef DEBUG
; 4250 : 						printf("par_match_string; hex optional set to -1\n");
; 4251 : #endif
; 4252 : 		//				ret_value->optional= -1;
; 4253 : 						ret_value->value=OPT_FAIL;

  023a2	c7 45 14 02 00
	00 00		 mov	 DWORD PTR [ebp+20], 2
  023a9	5e		 pop	 esi
  023aa	5d		 pop	 ebp

; 4288 : 					return(0);

  023ab	33 c0		 xor	 eax, eax
  023ad	5b		 pop	 ebx

; 4329 : #ifdef DEBUG
; 4330 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4331 : #endif
; 4332 : 	return(length);
; 4333 : }

  023ae	c3		 ret	 0
$L72336:

; 4254 : 					}
; 4255 : 					else
; 4256 : 					{
; 4257 : 						ret_value->value=FAIL;
; 4258 : 					}
; 4259 : #ifdef DEBUG
; 4260 : 					printf("leaving par_match_string hexadecimal value %02X mismatch\n",value);
; 4261 : #endif
; 4262 : 					return(0);
; 4263 : 				}
; 4264 : 				length=1;
; 4265 : 				rule_p++;

  023af	42		 inc	 edx
  023b0	5f		 pop	 edi

; 4327 : 	}
; 4328 : 	ret_value->rule=rule_p;

  023b1	89 55 10	 mov	 DWORD PTR [ebp+16], edx
  023b4	5e		 pop	 esi
  023b5	5d		 pop	 ebp
  023b6	b8 01 00 00 00	 mov	 eax, 1
  023bb	5b		 pop	 ebx

; 4329 : #ifdef DEBUG
; 4330 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4331 : #endif
; 4332 : 	return(length);
; 4333 : }

  023bc	c3		 ret	 0
$L72319:

; 4266 : 			}
; 4267 : 		}
; 4268 : 		else /* if (char_type<=BIN_HEXADECIMAL) */
; 4269 : 		{
; 4270 : 			if (char_type==BIN_RESTORE)

  023bd	83 f8 12	 cmp	 eax, 18			; 00000012H
  023c0	75 50		 jne	 SHORT $L72340

; 4271 : 			{
; 4272 : 				rule_p++;
; 4273 : 				value=current_rule[rule_p];					/* get the array number */

  023c2	8b 4c 24 14	 mov	 ecx, DWORD PTR _current_rule$[esp+12]

; 4274 : 				length=match_array->array_lengths[value];	/* get the length of the strig in the array */

  023c6	8b 5c 24 20	 mov	 ebx, DWORD PTR _match_array$[esp+12]
  023ca	42		 inc	 edx
  023cb	33 c0		 xor	 eax, eax
  023cd	8a 04 0a	 mov	 al, BYTE PTR [edx+ecx]
  023d0	8b f8		 mov	 edi, eax
  023d2	8b 04 bb	 mov	 eax, DWORD PTR [ebx+edi*4]

; 4275 : 				if ((memcmp(input_array+ipos,match_array->array[value],length)!=0))

  023d5	8d 3c 7f	 lea	 edi, DWORD PTR [edi+edi*2]
  023d8	8b c8		 mov	 ecx, eax
  023da	8d 3c bf	 lea	 edi, DWORD PTR [edi+edi*4]
  023dd	8d 7c 7b 28	 lea	 edi, DWORD PTR [ebx+edi*2+40]
  023e1	8b 5c 24 1c	 mov	 ebx, DWORD PTR _input_array$[esp+12]
  023e5	03 f3		 add	 esi, ebx
  023e7	33 db		 xor	 ebx, ebx
  023e9	f3 a6		 repe cmpsb
  023eb	74 22		 je	 SHORT $L72341

; 4276 : 				{
; 4277 : 					if (ret_value->optional==1)

  023ed	83 7d 18 01	 cmp	 DWORD PTR [ebp+24], 1
  023f1	75 0e		 jne	 SHORT $L72337
  023f3	5f		 pop	 edi

; 4278 : 					{
; 4279 : #ifdef DEBUG
; 4280 : 						printf("par_match_string; save optional set to -1\n");
; 4281 : #endif
; 4282 : //						ret_value->optional= -1;
; 4283 : 						ret_value->value=OPT_FAIL;

  023f4	c7 45 14 02 00
	00 00		 mov	 DWORD PTR [ebp+20], 2
  023fb	5e		 pop	 esi
  023fc	5d		 pop	 ebp

; 4284 : 						return(0);

  023fd	33 c0		 xor	 eax, eax
  023ff	5b		 pop	 ebx

; 4329 : #ifdef DEBUG
; 4330 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4331 : #endif
; 4332 : 	return(length);
; 4333 : }

  02400	c3		 ret	 0
$L72337:
  02401	5f		 pop	 edi

; 4285 : 
; 4286 : 					}
; 4287 : 					ret_value->value=FAIL;

  02402	c7 45 14 00 00
	00 00		 mov	 DWORD PTR [ebp+20], 0
  02409	5e		 pop	 esi
  0240a	5d		 pop	 ebp

; 4288 : 					return(0);

  0240b	33 c0		 xor	 eax, eax
  0240d	5b		 pop	 ebx

; 4329 : #ifdef DEBUG
; 4330 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4331 : #endif
; 4332 : 	return(length);
; 4333 : }

  0240e	c3		 ret	 0
$L72341:

; 4289 : 				}
; 4290 : 				rule_p++;

  0240f	42		 inc	 edx

; 4291 : 			}
; 4292 : 			else /* if (char_type==BIN_RESTORE) */

  02410	eb 2a		 jmp	 SHORT $L72343
$L72340:

; 4293 : 			{
; 4294 : 				/* BIN_SETS */	
; 4295 : 				length=par_match_sets_with_ranges(current_rule,input_array,match_array,ret_value,range_value,lookahead,break_on_min_match);

  02412	8b 54 24 30	 mov	 edx, DWORD PTR _break_on_min_match$[esp+12]
  02416	8b 44 24 2c	 mov	 eax, DWORD PTR _lookahead$[esp+12]
  0241a	8b 4c 24 28	 mov	 ecx, DWORD PTR _range_value$[esp+12]
  0241e	52		 push	 edx
  0241f	8b 54 24 24	 mov	 edx, DWORD PTR _match_array$[esp+16]
  02423	50		 push	 eax
  02424	8b 44 24 24	 mov	 eax, DWORD PTR _input_array$[esp+20]
  02428	51		 push	 ecx
  02429	8b 4c 24 20	 mov	 ecx, DWORD PTR _current_rule$[esp+24]
  0242d	55		 push	 ebp
  0242e	52		 push	 edx
  0242f	50		 push	 eax
  02430	51		 push	 ecx
  02431	e8 00 00 00 00	 call	 _par_match_sets_with_ranges
$L73112:

; 4296 : 				rule_p=ret_value->rule;

  02436	8b 55 10	 mov	 edx, DWORD PTR [ebp+16]
  02439	83 c4 1c	 add	 esp, 28			; 0000001cH
$L72343:

; 4297 : 				/* find the { */ /* } */
; 4298 : 				/* find the first thing to search for */
; 4299 : 				/* save the rule pointer for multiple matches */
; 4300 : 				/* loop calling par_match_string pointing to each thing to match before the comma
; 4301 : 				and if all of them are successful, return the total nubmer of characters matched
; 4302 : 				if not, go on to the next section */
; 4303 : 				/* the ret_value structure passed is the same one that is passed to the current
; 4304 : 				par_match_string, so the rule field will be corrupted */
; 4305 : 				/* repeat the loop for each time iteration of the <#> thing */
; 4306 : 				/* set the range if only one is found */
; 4307 : 			} /* if (char_type==BIN_RESTORE) */
; 4308 : 		} /* if (char_type<=BIN_HEXADECIMAL) */
; 4309 : 	} /* if (char_type<=BIN_DIGIT) */
; 4310 : 
; 4311 : 
; 4312 : 
; 4313 : 	if (length==0)

  0243c	85 c0		 test	 eax, eax
  0243e	75 24		 jne	 SHORT $L72346
$L73108:

; 4314 : 	{
; 4315 : 		if (ret_value->optional==1)

  02440	83 7d 18 01	 cmp	 DWORD PTR [ebp+24], 1
  02444	75 0f		 jne	 SHORT $L72345
  02446	5f		 pop	 edi

; 4316 : 		{
; 4317 : 			ret_value->value=OPT_FAIL;

  02447	c7 45 14 02 00
	00 00		 mov	 DWORD PTR [ebp+20], 2

; 4327 : 	}
; 4328 : 	ret_value->rule=rule_p;

  0244e	89 55 10	 mov	 DWORD PTR [ebp+16], edx
  02451	5e		 pop	 esi
  02452	5d		 pop	 ebp
  02453	5b		 pop	 ebx

; 4329 : #ifdef DEBUG
; 4330 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4331 : #endif
; 4332 : 	return(length);
; 4333 : }

  02454	c3		 ret	 0
$L72345:
  02455	5f		 pop	 edi

; 4318 : 		}
; 4319 : 		else
; 4320 : 		{
; 4321 : 			ret_value->value=FAIL;

  02456	c7 45 14 00 00
	00 00		 mov	 DWORD PTR [ebp+20], 0

; 4327 : 	}
; 4328 : 	ret_value->rule=rule_p;

  0245d	89 55 10	 mov	 DWORD PTR [ebp+16], edx
  02460	5e		 pop	 esi
  02461	5d		 pop	 ebp
  02462	5b		 pop	 ebx

; 4329 : #ifdef DEBUG
; 4330 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4331 : #endif
; 4332 : 	return(length);
; 4333 : }

  02463	c3		 ret	 0
$L72346:

; 4322 : 		}
; 4323 : 	}
; 4324 : 	if (length==-2)

  02464	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  02467	75 02		 jne	 SHORT $L72347

; 4325 : 	{
; 4326 : 		length=0;

  02469	33 c0		 xor	 eax, eax
$L72347:
  0246b	5f		 pop	 edi

; 4327 : 	}
; 4328 : 	ret_value->rule=rule_p;

  0246c	89 55 10	 mov	 DWORD PTR [ebp+16], edx
  0246f	5e		 pop	 esi
  02470	5d		 pop	 ebp
  02471	5b		 pop	 ebx

; 4329 : #ifdef DEBUG
; 4330 : 	printf("leaving par_match_string length = %d ret_value->value=%d\n",length,ret_value->value);
; 4331 : #endif
; 4332 : 	return(length);
; 4333 : }

  02472	c3		 ret	 0
_par_match_string ENDP
_input_array$ = 8
_input_indexes$ = 12
_output_array$ = 16
_output_indexes$ = 20
_num_chars$ = 24
_ret_value$ = 28
_par_copy_string_data PROC NEAR

; 4366 : #ifdef DEBUG
; 4367 : 	printf("entering par_copy_string_data\n");
; 4368 : #endif
; 4369 : 	memcpy(&output_array[ret_value->output_pos+ret_value->output_offset],&input_array[ret_value->input_pos+ret_value->input_offset],num_chars);

  02480	8b 44 24 18	 mov	 eax, DWORD PTR _ret_value$[esp-4]
  02484	53		 push	 ebx
  02485	8b 5c 24 08	 mov	 ebx, DWORD PTR _input_array$[esp]
  02489	56		 push	 esi
  0248a	8b 30		 mov	 esi, DWORD PTR [eax]
  0248c	8b 54 24 1c	 mov	 edx, DWORD PTR _num_chars$[esp+4]
  02490	57		 push	 edi
  02491	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  02494	03 f3		 add	 esi, ebx
  02496	8b 5c 24 18	 mov	 ebx, DWORD PTR _output_array$[esp+8]
  0249a	03 f7		 add	 esi, edi
  0249c	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  0249f	03 fb		 add	 edi, ebx
  024a1	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]
  024a4	8b ca		 mov	 ecx, edx
  024a6	03 fb		 add	 edi, ebx
  024a8	8b d9		 mov	 ebx, ecx
  024aa	c1 e9 02	 shr	 ecx, 2
  024ad	f3 a5		 rep movsd
  024af	8b cb		 mov	 ecx, ebx
  024b1	83 e1 03	 and	 ecx, 3
  024b4	f3 a4		 rep movsb

; 4370 : 	
; 4371 : 	par_copy_index_list(output_indexes,ret_value->output_pos+ret_value->output_offset,input_indexes,ret_value->input_pos+ret_value->input_offset,num_chars);

  024b6	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  024b9	8b 74 24 14	 mov	 esi, DWORD PTR _input_indexes$[esp+8]
  024bd	8d 0c 52	 lea	 ecx, DWORD PTR [edx+edx*2]
  024c0	8b 10		 mov	 edx, DWORD PTR [eax]
  024c2	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  024c5	03 d3		 add	 edx, ebx
  024c7	d1 e1		 shl	 ecx, 1
  024c9	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  024cc	8d 34 56	 lea	 esi, DWORD PTR [esi+edx*2]
  024cf	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  024d2	03 d7		 add	 edx, edi
  024d4	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  024d7	8b 54 24 1c	 mov	 edx, DWORD PTR _output_indexes$[esp+8]
  024db	8d 3c 42	 lea	 edi, DWORD PTR [edx+eax*2]
  024de	8b c1		 mov	 eax, ecx
  024e0	c1 e9 02	 shr	 ecx, 2
  024e3	f3 a5		 rep movsd
  024e5	8b c8		 mov	 ecx, eax
  024e7	83 e1 03	 and	 ecx, 3
  024ea	f3 a4		 rep movsb
  024ec	5f		 pop	 edi
  024ed	5e		 pop	 esi
  024ee	5b		 pop	 ebx

; 4372 : 	/* turn this into two memcpy's */
; 4373 : #if 0
; 4374 : 	for (i=0;i<num_chars;i++)
; 4375 : 	{
; 4376 : 		output_array[ret_value->output_pos+ret_value->output_offset+i]=input_array[ret_value->input_pos+ret_value->input_offset+i];
; 4377 : 		par_copy_index(output_indexes,ret_value->output_pos+ret_value->output_offset+i,input_indexes,ret_value->input_pos+ret_value->input_offset+i);
; 4378 : 	}
; 4379 : #endif
; 4380 : #ifdef DEBUG
; 4381 : 	printf("leaving par_copy_string_data\n");
; 4382 : #endif
; 4383 : }

  024ef	c3		 ret	 0
_par_copy_string_data ENDP
_TEXT	ENDS
PUBLIC	_par_convert_number
_TEXT	SEGMENT
_string$ = 8
_num$ = 12
_par_convert_number PROC NEAR

; 4407 : {

  024f0	56		 push	 esi

; 4408 : 	register int i,total=0,temp;
; 4409 : 	
; 4410 : 	for (i=0;i<num;i++)

  024f1	8b 74 24 0c	 mov	 esi, DWORD PTR _num$[esp]
  024f5	33 c0		 xor	 eax, eax
  024f7	33 d2		 xor	 edx, edx
  024f9	85 f6		 test	 esi, esi
  024fb	57		 push	 edi
  024fc	7e 1e		 jle	 SHORT $L72366
  024fe	8b 7c 24 0c	 mov	 edi, DWORD PTR _string$[esp+4]
$L72370:

; 4411 : 	{
; 4412 : 		temp=string[i]-'0';

  02502	33 c9		 xor	 ecx, ecx
  02504	8a 0c 3a	 mov	 cl, BYTE PTR [edx+edi]
  02507	83 e9 30	 sub	 ecx, 48			; 00000030H

; 4413 : 		if ((temp<0) || (temp>9))

  0250a	78 10		 js	 SHORT $L72366
  0250c	83 f9 09	 cmp	 ecx, 9
  0250f	7f 0b		 jg	 SHORT $L72366

; 4414 : 			return(total);
; 4415 : 		total=total*10+temp;

  02511	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  02514	42		 inc	 edx
  02515	3b d6		 cmp	 edx, esi
  02517	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0251a	7c e6		 jl	 SHORT $L72370
$L72366:
  0251c	5f		 pop	 edi
  0251d	5e		 pop	 esi

; 4416 : 	}
; 4417 : 	return(total);
; 4418 : }

  0251e	c3		 ret	 0
_par_convert_number ENDP
_string$ = 8
_par_convert_number_new2 PROC NEAR

; 4445 : 	register int i,total=0,temp;
; 4446 : 	
; 4447 : 	for (i=0;;i++)
; 4448 : 	{
; 4449 : 		temp=string[i]-'0';

  02520	8b 54 24 04	 mov	 edx, DWORD PTR _string$[esp-4]
  02524	33 c9		 xor	 ecx, ecx
  02526	33 c0		 xor	 eax, eax
  02528	8a 0a		 mov	 cl, BYTE PTR [edx]
  0252a	83 e9 30	 sub	 ecx, 48			; 00000030H

; 4450 : 		if ((temp<0) || (temp>9))

  0252d	78 15		 js	 SHORT $L73126
$L72381:
  0252f	83 f9 09	 cmp	 ecx, 9
  02532	7f 10		 jg	 SHORT $L73126

; 4451 : 			return(total);
; 4452 : 		total=total*10+temp;

  02534	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  02537	42		 inc	 edx
  02538	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0253b	33 c9		 xor	 ecx, ecx
  0253d	8a 0a		 mov	 cl, BYTE PTR [edx]
  0253f	83 e9 30	 sub	 ecx, 48			; 00000030H
  02542	79 eb		 jns	 SHORT $L72381
$L73126:

; 4453 : 	}
; 4454 : 	return(total);
; 4455 : }

  02544	c3		 ret	 0
_par_convert_number_new2 ENDP
_TEXT	ENDS
PUBLIC	_par_get_int_length
_TEXT	SEGMENT
_i$ = 8
_par_get_int_length PROC NEAR

; 4477 : 	if (i<10)

  02550	8b 44 24 04	 mov	 eax, DWORD PTR _i$[esp-4]
  02554	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  02557	7d 06		 jge	 SHORT $L72389

; 4478 : 		return(1);

  02559	b8 01 00 00 00	 mov	 eax, 1

; 4484 : 		return(4);
; 4485 : 	else
; 4486 : 		return(5);
; 4487 : 
; 4488 : 
; 4489 : #if 0
; 4490 : 	register int j;
; 4491 : #ifdef DEBUG
; 4492 : 	printf("entering par_get_int_length\n");
; 4493 : #endif
; 4494 : 	if (i==0)
; 4495 : 	{
; 4496 : #ifdef DEBUG
; 4497 : 		printf("leaving par_get_int_length length=1\n");
; 4498 : #endif
; 4499 : 		return(1);
; 4500 : 	}
; 4501 : 	for (j=0;i;j++)
; 4502 : 		i/=10;
; 4503 : #ifdef DEBUG
; 4504 : 	printf("leaving par_get_int_length length=%d\n",j);
; 4505 : #endif
; 4506 : 	return(j);
; 4507 : #endif
; 4508 : }

  0255e	c3		 ret	 0
$L72389:

; 4479 : 	else if (i<100)

  0255f	83 f8 64	 cmp	 eax, 100		; 00000064H
  02562	7d 06		 jge	 SHORT $L72391

; 4480 : 		return(2);

  02564	b8 02 00 00 00	 mov	 eax, 2

; 4484 : 		return(4);
; 4485 : 	else
; 4486 : 		return(5);
; 4487 : 
; 4488 : 
; 4489 : #if 0
; 4490 : 	register int j;
; 4491 : #ifdef DEBUG
; 4492 : 	printf("entering par_get_int_length\n");
; 4493 : #endif
; 4494 : 	if (i==0)
; 4495 : 	{
; 4496 : #ifdef DEBUG
; 4497 : 		printf("leaving par_get_int_length length=1\n");
; 4498 : #endif
; 4499 : 		return(1);
; 4500 : 	}
; 4501 : 	for (j=0;i;j++)
; 4502 : 		i/=10;
; 4503 : #ifdef DEBUG
; 4504 : 	printf("leaving par_get_int_length length=%d\n",j);
; 4505 : #endif
; 4506 : 	return(j);
; 4507 : #endif
; 4508 : }

  02569	c3		 ret	 0
$L72391:

; 4481 : 	else if (i<1000)

  0256a	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  0256f	7d 06		 jge	 SHORT $L72393

; 4482 : 		return(3);

  02571	b8 03 00 00 00	 mov	 eax, 3

; 4484 : 		return(4);
; 4485 : 	else
; 4486 : 		return(5);
; 4487 : 
; 4488 : 
; 4489 : #if 0
; 4490 : 	register int j;
; 4491 : #ifdef DEBUG
; 4492 : 	printf("entering par_get_int_length\n");
; 4493 : #endif
; 4494 : 	if (i==0)
; 4495 : 	{
; 4496 : #ifdef DEBUG
; 4497 : 		printf("leaving par_get_int_length length=1\n");
; 4498 : #endif
; 4499 : 		return(1);
; 4500 : 	}
; 4501 : 	for (j=0;i;j++)
; 4502 : 		i/=10;
; 4503 : #ifdef DEBUG
; 4504 : 	printf("leaving par_get_int_length length=%d\n",j);
; 4505 : #endif
; 4506 : 	return(j);
; 4507 : #endif
; 4508 : }

  02576	c3		 ret	 0
$L72393:

; 4483 : 	else if (i<10000)

  02577	33 c9		 xor	 ecx, ecx
  02579	3d 10 27 00 00	 cmp	 eax, 10000		; 00002710H
  0257e	0f 9d c1	 setge	 cl
  02581	83 c1 04	 add	 ecx, 4
  02584	8b c1		 mov	 eax, ecx

; 4484 : 		return(4);
; 4485 : 	else
; 4486 : 		return(5);
; 4487 : 
; 4488 : 
; 4489 : #if 0
; 4490 : 	register int j;
; 4491 : #ifdef DEBUG
; 4492 : 	printf("entering par_get_int_length\n");
; 4493 : #endif
; 4494 : 	if (i==0)
; 4495 : 	{
; 4496 : #ifdef DEBUG
; 4497 : 		printf("leaving par_get_int_length length=1\n");
; 4498 : #endif
; 4499 : 		return(1);
; 4500 : 	}
; 4501 : 	for (j=0;i;j++)
; 4502 : 		i/=10;
; 4503 : #ifdef DEBUG
; 4504 : 	printf("leaving par_get_int_length length=%d\n",j);
; 4505 : #endif
; 4506 : 	return(j);
; 4507 : #endif
; 4508 : }

  02586	c3		 ret	 0
_par_get_int_length ENDP
_TEXT	ENDS
PUBLIC	_par_look_ahead
_TEXT	SEGMENT
_current_rule$ = 8
_input_array$ = 12
_ipos$ = 16
_find_index$ = 20
_match_array$ = 24
_ret_value$ = 28
_new_ret$ = -32
_range_value$ = -48
_par_look_ahead PROC NEAR

; 4546 : {

  02590	83 ec 30	 sub	 esp, 48			; 00000030H

; 4547 : #ifndef NEW_PARSER_FILE_LOADING
; 4548 : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0 };
; 4549 : #else
; 4550 : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0,NULL };
; 4551 : #endif
; 4552 : 	range_value_t		range_value = {0,0,0,0};
; 4553 : 	int char_length=0;
; 4554 : 	int value;
; 4555 : 	register int rule_p;
; 4556 : 	int char_type;
; 4557 : 
; 4558 : 	rule_p=find_index;
; 4559 : #ifdef DEBUG
; 4560 : 	printf("entering par_look_ahead\n");
; 4561 : 	par_print_rule_error("par_look_ahead; the current position is",current_rule,ret_value->rule);
; 4562 : #endif
; 4563 : 	char_type=current_rule[find_index] & BIN_OPERATION_MASK;

  02593	8b 54 24 34	 mov	 edx, DWORD PTR _current_rule$[esp+44]
  02597	53		 push	 ebx
  02598	56		 push	 esi
  02599	8b 74 24 48	 mov	 esi, DWORD PTR _find_index$[esp+52]
  0259d	57		 push	 edi
  0259e	33 db		 xor	 ebx, ebx
  025a0	8a 0c 32	 mov	 cl, BYTE PTR [edx+esi]
  025a3	89 5c 24 1c	 mov	 DWORD PTR _new_ret$[esp+60], ebx
  025a7	8a c1		 mov	 al, cl
  025a9	89 5c 24 20	 mov	 DWORD PTR _new_ret$[esp+64], ebx
  025ad	83 e0 1f	 and	 eax, 31			; 0000001fH
  025b0	89 5c 24 24	 mov	 DWORD PTR _new_ret$[esp+68], ebx
  025b4	8b f8		 mov	 edi, eax
  025b6	89 5c 24 28	 mov	 DWORD PTR _new_ret$[esp+72], ebx

; 4564 : 
; 4565 : 	if (char_type==BIN_EXACT)

  025ba	83 ff 10	 cmp	 edi, 16			; 00000010H
  025bd	89 5c 24 2c	 mov	 DWORD PTR _new_ret$[esp+76], ebx
  025c1	89 5c 24 30	 mov	 DWORD PTR _new_ret$[esp+80], ebx
  025c5	89 5c 24 34	 mov	 DWORD PTR _new_ret$[esp+84], ebx
  025c9	89 5c 24 38	 mov	 DWORD PTR _new_ret$[esp+88], ebx
  025cd	89 5c 24 0c	 mov	 DWORD PTR _range_value$[esp+60], ebx
  025d1	89 5c 24 10	 mov	 DWORD PTR _range_value$[esp+64], ebx
  025d5	89 5c 24 14	 mov	 DWORD PTR _range_value$[esp+68], ebx
  025d9	89 5c 24 18	 mov	 DWORD PTR _range_value$[esp+72], ebx
  025dd	0f 85 a1 00 00
	00		 jne	 $L72416

; 4566 : 	{
; 4567 : 		rule_p++;			/* skip the single quote */

  025e3	46		 inc	 esi

; 4568 : 		value=current_rule[rule_p]+ipos;

  025e4	33 c0		 xor	 eax, eax
  025e6	8a 04 16	 mov	 al, BYTE PTR [esi+edx]
  025e9	8b f8		 mov	 edi, eax
  025eb	8b 44 24 48	 mov	 eax, DWORD PTR _ipos$[esp+56]
  025ef	03 f8		 add	 edi, eax

; 4569 : 		rule_p++;

  025f1	46		 inc	 esi

; 4570 : 		if (current_rule[find_index] & BIN_CASE_INSEN)

  025f2	f6 c1 20	 test	 cl, 32			; 00000020H

; 4571 : 		{
; 4572 : 			if (par_lower[current_rule[rule_p]]!=par_lower[input_array[ipos]])

  025f5	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  025f8	74 53		 je	 SHORT $L72417
  025fa	8b 74 24 44	 mov	 esi, DWORD PTR _input_array$[esp+56]
  025fe	8a 19		 mov	 bl, BYTE PTR [ecx]
  02600	33 d2		 xor	 edx, edx
  02602	8a 14 06	 mov	 dl, BYTE PTR [esi+eax]
  02605	8a 9b 00 00 00
	00		 mov	 bl, BYTE PTR _par_lower[ebx]
  0260b	3a 9a 00 00 00
	00		 cmp	 bl, BYTE PTR _par_lower[edx]
  02611	74 09		 je	 SHORT $L73132
$L73135:
  02613	5f		 pop	 edi
  02614	5e		 pop	 esi

; 4573 : 			{
; 4574 : #ifdef DEBUG
; 4575 : 				printf("leaving par_look_ahead; exact failure\n");
; 4576 : #endif
; 4577 : 				return(0);

  02615	33 c0		 xor	 eax, eax
  02617	5b		 pop	 ebx

; 4734 : 					
; 4735 : 				} /* (char_type==BIN_RESTORE) */
; 4736 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4737 : 		} /* if (char_type<=BIN_DIGIT) */
; 4738 : 	} /* if (char_type==BIN_EXACT) */
; 4739 : 
; 4740 : #ifdef DEBUG
; 4741 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4742 : #endif
; 4743 : 	return(0);
; 4744 : 	
; 4745 : }

  02618	83 c4 30	 add	 esp, 48			; 00000030H
  0261b	c3		 ret	 0
$L73132:

; 4578 : 			}
; 4579 : 			while (ipos<value)

  0261c	3b c7		 cmp	 eax, edi
  0261e	0f 8d 39 01 00
	00		 jge	 $L72427
$L72420:

; 4580 : 			{
; 4581 : 				if (par_lower[current_rule[rule_p]]!=par_lower[input_array[ipos]])

  02624	33 db		 xor	 ebx, ebx
  02626	33 d2		 xor	 edx, edx
  02628	8a 19		 mov	 bl, BYTE PTR [ecx]
  0262a	8a 14 06	 mov	 dl, BYTE PTR [esi+eax]
  0262d	8a 9b 00 00 00
	00		 mov	 bl, BYTE PTR _par_lower[ebx]
  02633	3a 9a 00 00 00
	00		 cmp	 bl, BYTE PTR _par_lower[edx]
  02639	75 d8		 jne	 SHORT $L73135

; 4582 : 				{
; 4583 : #ifdef DEBUG
; 4584 : 					printf("leaving par_look_ahead; exact failure\n");
; 4585 : #endif
; 4586 : 					return(0);
; 4587 : 				}
; 4588 : 				ipos++;

  0263b	40		 inc	 eax

; 4589 : 				rule_p++;

  0263c	41		 inc	 ecx
  0263d	3b c7		 cmp	 eax, edi
  0263f	7c e3		 jl	 SHORT $L72420
  02641	5f		 pop	 edi
  02642	5e		 pop	 esi

; 4705 : 					{
; 4706 : 						if (match_array->array[value][0]!='\0')
; 4707 : 						{
; 4708 : #ifdef DEBUG
; 4709 : 							printf("leaving par_look_ahead; par_save_string success\n");
; 4710 : #endif
; 4711 : 							return(1);

  02643	b8 01 00 00 00	 mov	 eax, 1
  02648	5b		 pop	 ebx

; 4734 : 					
; 4735 : 				} /* (char_type==BIN_RESTORE) */
; 4736 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4737 : 		} /* if (char_type<=BIN_DIGIT) */
; 4738 : 	} /* if (char_type==BIN_EXACT) */
; 4739 : 
; 4740 : #ifdef DEBUG
; 4741 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4742 : #endif
; 4743 : 	return(0);
; 4744 : 	
; 4745 : }

  02649	83 c4 30	 add	 esp, 48			; 00000030H
  0264c	c3		 ret	 0
$L72417:

; 4590 : 			}
; 4591 : #ifdef DEBUG
; 4592 : 			printf("leaving par_look_ahead; exact success\n");
; 4593 : #endif
; 4594 : 			return(1);
; 4595 : 		}
; 4596 : 		else /* if (current_rule[find_index] & BIN_CASE_INSEN) */
; 4597 : 		{
; 4598 : 			if (current_rule[rule_p]!=input_array[ipos])

  0264d	8b 74 24 44	 mov	 esi, DWORD PTR _input_array$[esp+56]
  02651	8a 11		 mov	 dl, BYTE PTR [ecx]
  02653	3a 14 06	 cmp	 dl, BYTE PTR [esi+eax]
  02656	74 09		 je	 SHORT $L73133
  02658	5f		 pop	 edi
  02659	5e		 pop	 esi

; 4599 : 			{
; 4600 : #ifdef DEBUG
; 4601 : 				printf("leaving par_look_ahead; exact failure\n");
; 4602 : #endif
; 4603 : 				return(0);

  0265a	33 c0		 xor	 eax, eax
  0265c	5b		 pop	 ebx

; 4734 : 					
; 4735 : 				} /* (char_type==BIN_RESTORE) */
; 4736 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4737 : 		} /* if (char_type<=BIN_DIGIT) */
; 4738 : 	} /* if (char_type==BIN_EXACT) */
; 4739 : 
; 4740 : #ifdef DEBUG
; 4741 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4742 : #endif
; 4743 : 	return(0);
; 4744 : 	
; 4745 : }

  0265d	83 c4 30	 add	 esp, 48			; 00000030H
  02660	c3		 ret	 0
$L73133:

; 4604 : 			}
; 4605 : 
; 4606 : 			while (ipos<value)

  02661	3b c7		 cmp	 eax, edi
  02663	0f 8d f4 00 00
	00		 jge	 $L72427
$L72426:

; 4607 : 			{
; 4608 : 				if (current_rule[rule_p]!=input_array[ipos])

  02669	8a 11		 mov	 dl, BYTE PTR [ecx]
  0266b	8a 1c 06	 mov	 bl, BYTE PTR [esi+eax]
  0266e	3a d3		 cmp	 dl, bl
  02670	75 a1		 jne	 SHORT $L73135

; 4609 : 				{
; 4610 : #ifdef DEBUG
; 4611 : 					printf("leaving par_look_ahead; exact failure\n");
; 4612 : #endif
; 4613 : 					return(0);
; 4614 : 				}
; 4615 : 				ipos++;

  02672	40		 inc	 eax

; 4616 : 				rule_p++;

  02673	41		 inc	 ecx
  02674	3b c7		 cmp	 eax, edi
  02676	7c f1		 jl	 SHORT $L72426
  02678	5f		 pop	 edi
  02679	5e		 pop	 esi

; 4705 : 					{
; 4706 : 						if (match_array->array[value][0]!='\0')
; 4707 : 						{
; 4708 : #ifdef DEBUG
; 4709 : 							printf("leaving par_look_ahead; par_save_string success\n");
; 4710 : #endif
; 4711 : 							return(1);

  0267a	b8 01 00 00 00	 mov	 eax, 1
  0267f	5b		 pop	 ebx

; 4734 : 					
; 4735 : 				} /* (char_type==BIN_RESTORE) */
; 4736 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4737 : 		} /* if (char_type<=BIN_DIGIT) */
; 4738 : 	} /* if (char_type==BIN_EXACT) */
; 4739 : 
; 4740 : #ifdef DEBUG
; 4741 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4742 : #endif
; 4743 : 	return(0);
; 4744 : 	
; 4745 : }

  02680	83 c4 30	 add	 esp, 48			; 00000030H
  02683	c3		 ret	 0
$L72416:

; 4617 : 			}
; 4618 : #ifdef DEBUG
; 4619 : 			printf("leaving par_look_ahead; exact success\n");
; 4620 : #endif
; 4621 : 			return(1);
; 4622 : 		}
; 4623 : #ifdef DEBUG
; 4624 : 		printf("leaving par_look_ahead; exact failure\n");
; 4625 : #endif
; 4626 : 		return(0);
; 4627 : 	}
; 4628 : 	else /* if (char_type==BIN_EXACT) */
; 4629 : 	{
; 4630 : 		if (char_type<=BIN_DIGIT)

  02684	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  02687	7f 78		 jg	 SHORT $L72430

; 4631 : 		{
; 4632 : 			if (current_rule[find_index] & BIN_DIGIT_RANGE)
; 4633 : 			{
; 4634 : 				/* check for the special digit type and if it is there */
; 4635 : 				/* use the special digit matching function. */
; 4636 : 				/* use the normal one otherwise */
; 4637 : 				new_ret.rule= find_index;

  02689	89 74 24 2c	 mov	 DWORD PTR _new_ret$[esp+76], esi

; 4638 : 				new_ret.value=SUCCESS;

  0268d	be 01 00 00 00	 mov	 esi, 1
  02692	f6 c1 20	 test	 cl, 32			; 00000020H
  02695	89 74 24 30	 mov	 DWORD PTR _new_ret$[esp+80], esi
  02699	74 44		 je	 SHORT $L72431

; 4639 : 				new_ret.input_pos=ipos;

  0269b	8b 44 24 48	 mov	 eax, DWORD PTR _ipos$[esp+56]

; 4640 : 				char_length=par_match_digits(current_rule,input_array,match_array,&new_ret,&range_value,0,1);

  0269f	56		 push	 esi
  026a0	89 44 24 20	 mov	 DWORD PTR _new_ret$[esp+64], eax
  026a4	8d 4c 24 10	 lea	 ecx, DWORD PTR _range_value$[esp+64]
  026a8	53		 push	 ebx
  026a9	8d 44 24 24	 lea	 eax, DWORD PTR _new_ret$[esp+68]
  026ad	51		 push	 ecx
  026ae	8b 4c 24 5c	 mov	 ecx, DWORD PTR _match_array$[esp+68]
  026b2	50		 push	 eax
  026b3	8b 44 24 54	 mov	 eax, DWORD PTR _input_array$[esp+72]
  026b7	51		 push	 ecx
  026b8	50		 push	 eax
  026b9	52		 push	 edx
  026ba	e8 00 00 00 00	 call	 _par_match_digits
$L73140:

; 4641 : 				if (new_ret.value==SUCCESS)

  026bf	8b 4c 24 4c	 mov	 ecx, DWORD PTR _new_ret$[esp+108]
  026c3	83 c4 1c	 add	 esp, 28			; 0000001cH
  026c6	3b ce		 cmp	 ecx, esi
  026c8	0f 85 45 ff ff
	ff		 jne	 $L73135

; 4642 : 				{
; 4643 : 					if (char_length>0)

  026ce	3b c3		 cmp	 eax, ebx
  026d0	0f 8e 3d ff ff
	ff		 jle	 $L73135

; 4644 : 					{
; 4645 : #ifdef DEBUG
; 4646 : 						printf("leaving par_look_ahead;digit range success\n");
; 4647 : #endif
; 4648 : 						return(1);

  026d6	8b c6		 mov	 eax, esi
  026d8	5f		 pop	 edi
  026d9	5e		 pop	 esi
  026da	5b		 pop	 ebx

; 4734 : 					
; 4735 : 				} /* (char_type==BIN_RESTORE) */
; 4736 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4737 : 		} /* if (char_type<=BIN_DIGIT) */
; 4738 : 	} /* if (char_type==BIN_EXACT) */
; 4739 : 
; 4740 : #ifdef DEBUG
; 4741 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4742 : #endif
; 4743 : 	return(0);
; 4744 : 	
; 4745 : }

  026db	83 c4 30	 add	 esp, 48			; 00000030H
  026de	c3		 ret	 0
$L72431:

; 4649 : 					}
; 4650 : 				}
; 4651 : #ifdef DEBUG
; 4652 : 				printf("leaving par_look_ahead;digit range fail\n");
; 4653 : #endif
; 4654 : 				return(0);
; 4655 : 			}
; 4656 : 			else
; 4657 : 			{	/* most types */
; 4658 : 				
; 4659 : 				new_ret.rule= find_index;
; 4660 : 				new_ret.value=SUCCESS;
; 4661 : 				new_ret.input_pos=ipos;

  026df	8b 4c 24 48	 mov	 ecx, DWORD PTR _ipos$[esp+56]

; 4662 : 				char_length=par_match_standard(current_rule,char_type ,input_array,match_array,&new_ret,0,1);

  026e3	56		 push	 esi
  026e4	8d 44 24 20	 lea	 eax, DWORD PTR _new_ret$[esp+64]
  026e8	89 4c 24 20	 mov	 DWORD PTR _new_ret$[esp+64], ecx
  026ec	8b 4c 24 54	 mov	 ecx, DWORD PTR _match_array$[esp+60]
  026f0	53		 push	 ebx
  026f1	50		 push	 eax
  026f2	8b 44 24 50	 mov	 eax, DWORD PTR _input_array$[esp+68]
  026f6	51		 push	 ecx
  026f7	50		 push	 eax
  026f8	57		 push	 edi
  026f9	52		 push	 edx
  026fa	e8 00 00 00 00	 call	 _par_match_standard

; 4663 : 				if (new_ret.value==SUCCESS)
; 4664 : 				{
; 4665 : 					if (char_length>0)
; 4666 : 					{
; 4667 : #ifdef DEBUG
; 4668 : 						printf("leaving par_look_ahead;standard success\n");
; 4669 : #endif
; 4670 : 						return(1);

  026ff	eb be		 jmp	 SHORT $L73140
$L72430:

; 4671 : 					}
; 4672 : 				}
; 4673 : #ifdef DEBUG
; 4674 : 				printf("leaving par_look_ahead;standard fail\n");
; 4675 : #endif
; 4676 : 				return(0);
; 4677 : 			}
; 4678 : 			
; 4679 : 		}
; 4680 : 		else /* if (char_type<=BIN_DIGIT) */
; 4681 : 		{
; 4682 : 			if (char_type==BIN_HEXADECIMAL)

  02701	83 ff 11	 cmp	 edi, 17			; 00000011H
  02704	75 1d		 jne	 SHORT $L72438

; 4683 : 			{
; 4684 : 				rule_p++;
; 4685 : 				if (input_array[ipos]==current_rule[rule_p])

  02706	8b 4c 24 48	 mov	 ecx, DWORD PTR _ipos$[esp+56]
  0270a	8b 44 24 44	 mov	 eax, DWORD PTR _input_array$[esp+56]
  0270e	8a 5c 32 01	 mov	 bl, BYTE PTR [edx+esi+1]
  02712	5f		 pop	 edi
  02713	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  02716	33 c0		 xor	 eax, eax
  02718	3a cb		 cmp	 cl, bl
  0271a	5e		 pop	 esi
  0271b	0f 94 c0	 sete	 al
  0271e	5b		 pop	 ebx

; 4734 : 					
; 4735 : 				} /* (char_type==BIN_RESTORE) */
; 4736 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4737 : 		} /* if (char_type<=BIN_DIGIT) */
; 4738 : 	} /* if (char_type==BIN_EXACT) */
; 4739 : 
; 4740 : #ifdef DEBUG
; 4741 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4742 : #endif
; 4743 : 	return(0);
; 4744 : 	
; 4745 : }

  0271f	83 c4 30	 add	 esp, 48			; 00000030H
  02722	c3		 ret	 0
$L72438:

; 4686 : 				{
; 4687 : #ifdef DEBUG
; 4688 : 					printf("leaving par_look_ahead; hex number success\n");
; 4689 : #endif
; 4690 : 					return(1);
; 4691 : 				}
; 4692 : #ifdef DEBUG
; 4693 : 				printf("leaving par_look_ahead; hex number failure\n");
; 4694 : #endif
; 4695 : 				return(0);
; 4696 : 			}
; 4697 : 			else /* if (char_type==BIN_HEXADECIMAL) */
; 4698 : 			{
; 4699 : 				if (char_type==BIN_RESTORE)

  02723	83 ff 12	 cmp	 edi, 18			; 00000012H
  02726	75 41		 jne	 SHORT $L72441

; 4700 : 				{
; 4701 : 					rule_p++;
; 4702 : 					value=current_rule[rule_p];		/* get the array number */

  02728	33 c0		 xor	 eax, eax
  0272a	8a 44 32 01	 mov	 al, BYTE PTR [edx+esi+1]

; 4703 : 					char_length=match_array->array_lengths[value];	/* get the length of the strig in the array */
; 4704 : 					if ((memcmp(input_array+ipos,match_array->array[value],char_length)==0))

  0272e	8b 74 24 44	 mov	 esi, DWORD PTR _input_array$[esp+56]
  02732	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  02735	8d 14 89	 lea	 edx, DWORD PTR [ecx+ecx*4]

; 4724 : 					{
; 4725 : #ifdef DEBUG
; 4726 : 						printf("par_look_ahead;dictionary_state dict entry found\n");
; 4727 : #endif
; 4728 : 						return(1);
; 4729 : 					}
; 4730 : #ifdef DEBUG
; 4731 : 					printf("par_look_ahead;dictionary_state dict entry not found\n");
; 4732 : #endif
; 4733 : 					return(0);			   

  02738	8b 4c 24 50	 mov	 ecx, DWORD PTR _match_array$[esp+56]
  0273c	8d 54 51 28	 lea	 edx, DWORD PTR [ecx+edx*2+40]
  02740	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  02743	8b 44 24 48	 mov	 eax, DWORD PTR _ipos$[esp+56]
  02747	8b fa		 mov	 edi, edx
  02749	03 f0		 add	 esi, eax
  0274b	33 c0		 xor	 eax, eax
  0274d	f3 a6		 repe cmpsb
  0274f	0f 85 be fe ff
	ff		 jne	 $L73135
  02755	38 1a		 cmp	 BYTE PTR [edx], bl
  02757	0f 84 b6 fe ff
	ff		 je	 $L73135
$L72427:
  0275d	5f		 pop	 edi
  0275e	5e		 pop	 esi

; 4705 : 					{
; 4706 : 						if (match_array->array[value][0]!='\0')
; 4707 : 						{
; 4708 : #ifdef DEBUG
; 4709 : 							printf("leaving par_look_ahead; par_save_string success\n");
; 4710 : #endif
; 4711 : 							return(1);

  0275f	b8 01 00 00 00	 mov	 eax, 1
  02764	5b		 pop	 ebx

; 4734 : 					
; 4735 : 				} /* (char_type==BIN_RESTORE) */
; 4736 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4737 : 		} /* if (char_type<=BIN_DIGIT) */
; 4738 : 	} /* if (char_type==BIN_EXACT) */
; 4739 : 
; 4740 : #ifdef DEBUG
; 4741 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4742 : #endif
; 4743 : 	return(0);
; 4744 : 	
; 4745 : }

  02765	83 c4 30	 add	 esp, 48			; 00000030H
  02768	c3		 ret	 0
$L72441:

; 4712 : 						}
; 4713 : 					}
; 4714 : #ifdef DEBUG
; 4715 : 					printf("leaving par_look_ahead; par_save_string failure\n");
; 4716 : #endif
; 4717 : 					return(0);
; 4718 : 				}
; 4719 : 				else /* (char_type==BIN_RESTORE) */
; 4720 : 				{	/* BIN_DICTIONARY */
; 4721 : 					par_copy_return_value(&new_ret,ret_value);			  

  02769	8b 74 24 54	 mov	 esi, DWORD PTR _ret_value$[esp+56]
  0276d	b9 08 00 00 00	 mov	 ecx, 8
  02772	8d 7c 24 1c	 lea	 edi, DWORD PTR _new_ret$[esp+60]

; 4722 : 					new_ret.input_pos=ipos;
; 4723 : 					if (par_look_ahead_dictionary(current_rule,input_array,match_array,&new_ret))

  02776	8d 44 24 1c	 lea	 eax, DWORD PTR _new_ret$[esp+60]
  0277a	f3 a5		 rep movsd
  0277c	8b 4c 24 48	 mov	 ecx, DWORD PTR _ipos$[esp+56]
  02780	50		 push	 eax
  02781	8b 44 24 48	 mov	 eax, DWORD PTR _input_array$[esp+60]
  02785	89 4c 24 20	 mov	 DWORD PTR _new_ret$[esp+64], ecx
  02789	8b 4c 24 54	 mov	 ecx, DWORD PTR _match_array$[esp+60]
  0278d	51		 push	 ecx
  0278e	50		 push	 eax
  0278f	52		 push	 edx
  02790	e8 00 00 00 00	 call	 _par_look_ahead_dictionary
  02795	83 c4 10	 add	 esp, 16			; 00000010H
  02798	f7 d8		 neg	 eax
  0279a	1b c0		 sbb	 eax, eax
  0279c	5f		 pop	 edi
  0279d	5e		 pop	 esi
  0279e	5b		 pop	 ebx
  0279f	f7 d8		 neg	 eax

; 4734 : 					
; 4735 : 				} /* (char_type==BIN_RESTORE) */
; 4736 : 			} /* if (char_type<=BIN_HEXADECIMAL) */
; 4737 : 		} /* if (char_type<=BIN_DIGIT) */
; 4738 : 	} /* if (char_type==BIN_EXACT) */
; 4739 : 
; 4740 : #ifdef DEBUG
; 4741 : 	printf("leaving par_look_ahead; how did it get here??\n");
; 4742 : #endif
; 4743 : 	return(0);
; 4744 : 	
; 4745 : }

  027a1	83 c4 30	 add	 esp, 48			; 00000030H
  027a4	c3		 ret	 0
_par_look_ahead ENDP
_input_array$ = 8
_output_array$ = 12
_input_indexes$ = 16
_output_indexes$ = 20
_ret_value$ = 24
_par_copy_word_to_output PROC NEAR

; 4773 : {

  027b0	53		 push	 ebx
  027b1	55		 push	 ebp

; 4774 : 	int i,ipos,opos;
; 4775 : 	
; 4776 : #ifdef DEBUG
; 4777 : 	printf("entering par_copy_word_to_output\n");
; 4778 : #endif
; 4779 : 	if ((ret_value==NULL) || (input_array==NULL) || (output_array==NULL))

  027b2	8b 6c 24 1c	 mov	 ebp, DWORD PTR _ret_value$[esp+4]
  027b6	85 ed		 test	 ebp, ebp
  027b8	0f 84 cb 00 00
	00		 je	 $L72465
  027be	8b 5c 24 0c	 mov	 ebx, DWORD PTR _input_array$[esp+4]
  027c2	85 db		 test	 ebx, ebx
  027c4	0f 84 bf 00 00
	00		 je	 $L72465
  027ca	8b 44 24 10	 mov	 eax, DWORD PTR _output_array$[esp+4]
  027ce	85 c0		 test	 eax, eax
  027d0	0f 84 b3 00 00
	00		 je	 $L72465

; 4785 : 	}                      
; 4786 : 	ipos=ret_value->input_pos+ret_value->input_offset;

  027d6	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  027d9	56		 push	 esi
  027da	8b 75 04	 mov	 esi, DWORD PTR [ebp+4]

; 4787 : 	opos=ret_value->output_pos+ret_value->output_offset;

  027dd	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  027e0	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
  027e3	03 f1		 add	 esi, ecx
  027e5	57		 push	 edi
  027e6	03 d0		 add	 edx, eax

; 4788 : 	i=0;
; 4789 : 	/* this function only copies non whitespace, so it never has to check for indexes */
; 4790 : 	while (((parser_char_types[(int)(input_array[ipos+i])] & TYPE_white)==0) && (input_array[ipos+i]!='\0'))

  027e8	8a 0c 1e	 mov	 cl, BYTE PTR [esi+ebx]
  027eb	33 c0		 xor	 eax, eax
  027ed	8b f9		 mov	 edi, ecx
  027ef	81 e7 ff 00 00
	00		 and	 edi, 255		; 000000ffH
  027f5	f6 04 7d 00 00
	00 00 20	 test	 BYTE PTR _parser_char_types[edi*2], 32 ; 00000020H
  027fd	75 69		 jne	 SHORT $L72469
  027ff	8b 5c 24 20	 mov	 ebx, DWORD PTR _output_indexes$[esp+12]
  02803	8d 3c 52	 lea	 edi, DWORD PTR [edx+edx*2]
  02806	8d 3c 7b	 lea	 edi, DWORD PTR [ebx+edi*2]
  02809	8b 5c 24 1c	 mov	 ebx, DWORD PTR _input_indexes$[esp+12]
  0280d	89 7c 24 20	 mov	 DWORD PTR 20+[esp+12], edi
  02811	8d 3c 76	 lea	 edi, DWORD PTR [esi+esi*2]
  02814	8d 3c 7b	 lea	 edi, DWORD PTR [ebx+edi*2]
  02817	8b 5c 24 14	 mov	 ebx, DWORD PTR _input_array$[esp+12]
$L72468:
  0281b	84 c9		 test	 cl, cl
  0281d	74 49		 je	 SHORT $L72469

; 4791 : 	{
; 4792 : 		output_array[opos+i]=input_array[ipos+i];        

  0281f	8b 6c 24 18	 mov	 ebp, DWORD PTR _output_array$[esp+12]
  02823	8d 1c 10	 lea	 ebx, DWORD PTR [eax+edx]

; 4793 : 		/* copy the index anyway even if it isn't there */
; 4794 : 		par_copy_index(output_indexes,opos+i,input_indexes,ipos+i);
; 4795 : #ifdef DEBUG
; 4796 : 		printf("output_array[%d]=%c ",opos+i,output_array[opos+i]);
; 4797 : #endif
; 4798 : 		i++;

  02826	40		 inc	 eax
  02827	88 0c 2b	 mov	 BYTE PTR [ebx+ebp], cl
  0282a	8b 5c 24 20	 mov	 ebx, DWORD PTR 20+[esp+12]
  0282e	8b cf		 mov	 ecx, edi
  02830	83 c7 06	 add	 edi, 6
  02833	8b 29		 mov	 ebp, DWORD PTR [ecx]
  02835	89 2b		 mov	 DWORD PTR [ebx], ebp
  02837	66 8b 49 04	 mov	 cx, WORD PTR [ecx+4]
  0283b	66 89 4b 04	 mov	 WORD PTR [ebx+4], cx
  0283f	8b cb		 mov	 ecx, ebx
  02841	8b 5c 24 14	 mov	 ebx, DWORD PTR _input_array$[esp+12]
  02845	83 c1 06	 add	 ecx, 6
  02848	89 4c 24 20	 mov	 DWORD PTR 20+[esp+12], ecx
  0284c	8d 0c 1e	 lea	 ecx, DWORD PTR [esi+ebx]
  0284f	8a 0c 01	 mov	 cl, BYTE PTR [ecx+eax]
  02852	8b e9		 mov	 ebp, ecx
  02854	81 e5 ff 00 00
	00		 and	 ebp, 255		; 000000ffH
  0285a	f6 04 6d 00 00
	00 00 20	 test	 BYTE PTR _parser_char_types[ebp*2], 32 ; 00000020H
  02862	8b 6c 24 24	 mov	 ebp, DWORD PTR _ret_value$[esp+12]
  02866	74 b3		 je	 SHORT $L72468
$L72469:

; 4799 : 	}
; 4800 : 	ret_value->input_offset+=i;

  02868	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]

; 4801 : 	ret_value->output_offset+=i;

  0286b	8b 7d 0c	 mov	 edi, DWORD PTR [ebp+12]
  0286e	03 c8		 add	 ecx, eax
  02870	03 f8		 add	 edi, eax

; 4802 : 	if (input_array[ipos+i]=='\0')

  02872	03 c6		 add	 eax, esi
  02874	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  02877	89 7d 0c	 mov	 DWORD PTR [ebp+12], edi
  0287a	5f		 pop	 edi
  0287b	8a 04 18	 mov	 al, BYTE PTR [eax+ebx]
  0287e	5e		 pop	 esi
  0287f	f6 d8		 neg	 al
  02881	1b c0		 sbb	 eax, eax
  02883	5d		 pop	 ebp
  02884	f7 d8		 neg	 eax
  02886	48		 dec	 eax
  02887	5b		 pop	 ebx

; 4803 : 	{
; 4804 : #ifdef DEBUG
; 4805 : 		printf("leaving par_copy_word_to_output b -1\n");
; 4806 : #endif
; 4807 : 		return(-1);
; 4808 : 	}
; 4809 : #ifdef DEBUG
; 4810 : 	printf("leaving par_copy_word_to_output b \n");
; 4811 : #endif
; 4812 : 	return(0);
; 4813 : }

  02888	c3		 ret	 0
$L72465:
  02889	5d		 pop	 ebp

; 4780 : 	{
; 4781 : #ifdef DEBUG
; 4782 : 		printf("leaving par_copy_word_to_output a 0\n");
; 4783 : #endif
; 4784 : 		return(0);

  0288a	33 c0		 xor	 eax, eax
  0288c	5b		 pop	 ebx

; 4803 : 	{
; 4804 : #ifdef DEBUG
; 4805 : 		printf("leaving par_copy_word_to_output b -1\n");
; 4806 : #endif
; 4807 : 		return(-1);
; 4808 : 	}
; 4809 : #ifdef DEBUG
; 4810 : 	printf("leaving par_copy_word_to_output b \n");
; 4811 : #endif
; 4812 : 	return(0);
; 4813 : }

  0288d	c3		 ret	 0
_par_copy_word_to_output ENDP
_input_array$ = 8
_input_indexes$ = 12
_output_array$ = 16
_output_indexes$ = 20
_ret_value$ = 24
_ipos$ = -4
_par_skip_white_space PROC NEAR

; 4842 : {

  02890	83 ec 08	 sub	 esp, 8
  02893	55		 push	 ebp

; 4843 : 	int i,ipos,opos,j;
; 4844 : 	
; 4845 : #ifdef DEBUG
; 4846 : 	printf("entering par_skip_white_space\n");
; 4847 : #endif
; 4848 : 	if ((ret_value==NULL) || (input_array==NULL) || (output_array==NULL))

  02894	8b 6c 24 20	 mov	 ebp, DWORD PTR _ret_value$[esp+8]
  02898	85 ed		 test	 ebp, ebp
  0289a	0f 84 10 01 00
	00		 je	 $L72490
  028a0	8b 44 24 10	 mov	 eax, DWORD PTR _input_array$[esp+8]
  028a4	85 c0		 test	 eax, eax
  028a6	0f 84 04 01 00
	00		 je	 $L72490
  028ac	8b 4c 24 18	 mov	 ecx, DWORD PTR _output_array$[esp+8]
  028b0	85 c9		 test	 ecx, ecx
  028b2	0f 84 f8 00 00
	00		 je	 $L72490

; 4854 : 	}
; 4855 : 	ipos=ret_value->input_pos+ret_value->input_offset;
; 4856 : 	opos=ret_value->output_pos+ret_value->output_offset;

  028b8	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  028bb	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  028be	53		 push	 ebx
  028bf	8b 5d 04	 mov	 ebx, DWORD PTR [ebp+4]
  028c2	56		 push	 esi
  028c3	8b 75 00	 mov	 esi, DWORD PTR [ebp]
  028c6	03 de		 add	 ebx, esi
  028c8	03 ca		 add	 ecx, edx

; 4857 : 	i=0;                                             
; 4858 : 	j=0;
; 4859 : 	while (((parser_char_types[(int)(input_array[ipos+i])] & TYPE_white)!=0) && (input_array[ipos+i]!='\0'))

  028ca	03 c3		 add	 eax, ebx
  028cc	33 d2		 xor	 edx, edx
  028ce	89 44 24 0c	 mov	 DWORD PTR -8+[esp+20], eax
  028d2	57		 push	 edi
  028d3	8a 10		 mov	 dl, BYTE PTR [eax]
  028d5	33 f6		 xor	 esi, esi
  028d7	33 ff		 xor	 edi, edi
  028d9	89 5c 24 14	 mov	 DWORD PTR _ipos$[esp+24], ebx
  028dd	f6 04 55 00 00
	00 00 20	 test	 BYTE PTR _parser_char_types[edx*2], 32 ; 00000020H
  028e5	0f 84 9e 00 00
	00		 je	 $L72494
  028eb	8b 54 24 28	 mov	 edx, DWORD PTR _output_indexes$[esp+20]
  028ef	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  028f2	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  028f5	8d 14 5b	 lea	 edx, DWORD PTR [ebx+ebx*2]
  028f8	89 44 24 28	 mov	 DWORD PTR 20+[esp+20], eax
  028fc	8b 44 24 20	 mov	 eax, DWORD PTR _input_indexes$[esp+20]
  02900	8d 44 50 04	 lea	 eax, DWORD PTR [eax+edx*2+4]
$L72493:
  02904	8b 54 24 10	 mov	 edx, DWORD PTR -8+[esp+24]
  02908	8a 14 32	 mov	 dl, BYTE PTR [edx+esi]
  0290b	84 d2		 test	 dl, dl
  0290d	74 7a		 je	 SHORT $L72494

; 4860 : 	{
; 4861 : 		if (i==0 || par_is_index_set(input_indexes,ipos+i))

  0290f	85 f6		 test	 esi, esi
  02911	74 14		 je	 SHORT $L73154
  02913	66 83 78 fc 00	 cmp	 WORD PTR [eax-4], 0
  02918	75 0d		 jne	 SHORT $L73154
  0291a	66 83 78 fe 00	 cmp	 WORD PTR [eax-2], 0
  0291f	75 06		 jne	 SHORT $L73154
  02921	66 83 38 00	 cmp	 WORD PTR [eax], 0
  02925	74 43		 je	 SHORT $L72498
$L73154:

; 4862 : 		{
; 4863 : 			output_array[opos+j]=input_array[ipos+i];

  02927	8b 6c 24 24	 mov	 ebp, DWORD PTR _output_array$[esp+20]
  0292b	8d 1c 0f	 lea	 ebx, DWORD PTR [edi+ecx]
  0292e	88 14 2b	 mov	 BYTE PTR [ebx+ebp], dl

; 4864 : 			if (par_is_index_set(input_indexes,ipos+i))

  02931	66 83 78 fc 00	 cmp	 WORD PTR [eax-4], 0
  02936	75 0d		 jne	 SHORT $L73161
  02938	66 83 78 fe 00	 cmp	 WORD PTR [eax-2], 0
  0293d	75 06		 jne	 SHORT $L73161
  0293f	66 83 38 00	 cmp	 WORD PTR [eax], 0
  02943	74 15		 je	 SHORT $L72497
$L73161:

; 4865 : 			{                                       
; 4866 : #ifdef INDEX_DEBUG
; 4867 : 				printf("copying index from %d to %d\n",ipos+i,opos+j);
; 4868 : #endif
; 4869 : 				par_copy_index(output_indexes,opos+j,input_indexes,ipos+i);

  02945	8b 54 24 28	 mov	 edx, DWORD PTR 20+[esp+20]
  02949	8b 68 fc	 mov	 ebp, DWORD PTR [eax-4]
  0294c	8b da		 mov	 ebx, edx

; 4870 : 				j++;

  0294e	47		 inc	 edi
  0294f	89 2b		 mov	 DWORD PTR [ebx], ebp
  02951	66 8b 28	 mov	 bp, WORD PTR [eax]
  02954	66 89 6b 04	 mov	 WORD PTR [ebx+4], bp

; 4871 : 			}
; 4872 : 			else

  02958	eb 05		 jmp	 SHORT $L73172
$L72497:

; 4873 : 			{
; 4874 : 				j++;

  0295a	8b 54 24 28	 mov	 edx, DWORD PTR 20+[esp+20]
  0295e	47		 inc	 edi
$L73172:
  0295f	8b 6c 24 2c	 mov	 ebp, DWORD PTR _ret_value$[esp+20]
  02963	83 c2 06	 add	 edx, 6
  02966	89 54 24 28	 mov	 DWORD PTR 20+[esp+20], edx
$L72498:
  0296a	8b 5c 24 10	 mov	 ebx, DWORD PTR -8+[esp+24]

; 4875 : 			}
; 4876 : #ifdef INDEX_DEBUG
; 4877 : 			if (i!=0)
; 4878 : 			{
; 4879 : 				printf("copied extra space because of index\n");
; 4880 : 			}
; 4881 : 			printf("output_array[%d]=%c\n",opos+i,output_array[opos+i]);
; 4882 : #endif
; 4883 : 		}
; 4884 : 		i++;

  0296e	46		 inc	 esi
  0296f	33 d2		 xor	 edx, edx
  02971	83 c0 06	 add	 eax, 6
  02974	8a 14 33	 mov	 dl, BYTE PTR [ebx+esi]
  02977	f6 04 55 00 00
	00 00 20	 test	 BYTE PTR _parser_char_types[edx*2], 32 ; 00000020H
  0297f	8b 5c 24 14	 mov	 ebx, DWORD PTR _ipos$[esp+24]
  02983	0f 85 7b ff ff
	ff		 jne	 $L72493
$L72494:

; 4885 : 	}
; 4886 : 	ret_value->input_offset+=i;

  02989	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  0298c	03 ce		 add	 ecx, esi

; 4887 : 	if (i>0)

  0298e	85 f6		 test	 esi, esi
  02990	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  02993	7e 03		 jle	 SHORT $L72499

; 4888 : 		ret_value->output_offset+=j;

  02995	01 7d 0c	 add	 DWORD PTR [ebp+12], edi
$L72499:

; 4889 : 	if (input_array[ipos+i]=='\0')

  02998	8b 44 24 1c	 mov	 eax, DWORD PTR _input_array$[esp+20]
  0299c	03 f3		 add	 esi, ebx
  0299e	5f		 pop	 edi
  0299f	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  029a2	5e		 pop	 esi
  029a3	f6 d8		 neg	 al
  029a5	1b c0		 sbb	 eax, eax
  029a7	5b		 pop	 ebx
  029a8	f7 d8		 neg	 eax
  029aa	48		 dec	 eax
  029ab	5d		 pop	 ebp

; 4890 : 	{
; 4891 : #ifdef DEBUG
; 4892 : 		printf("leaving par_skip_white_space b -1\n");
; 4893 : #endif
; 4894 : 		return(-1);
; 4895 : 	}
; 4896 : #ifdef DEBUG
; 4897 : 	printf("leaving par_skip_white_space b 0\n");
; 4898 : #endif
; 4899 : 	return(0);
; 4900 : }

  029ac	83 c4 08	 add	 esp, 8
  029af	c3		 ret	 0
$L72490:

; 4849 : 	{
; 4850 : #ifdef DEBUG
; 4851 : 		printf("leaving par_skip_white_space a 0\n");
; 4852 : #endif
; 4853 : 		return(0);

  029b0	33 c0		 xor	 eax, eax
  029b2	5d		 pop	 ebp

; 4890 : 	{
; 4891 : #ifdef DEBUG
; 4892 : 		printf("leaving par_skip_white_space b -1\n");
; 4893 : #endif
; 4894 : 		return(-1);
; 4895 : 	}
; 4896 : #ifdef DEBUG
; 4897 : 	printf("leaving par_skip_white_space b 0\n");
; 4898 : #endif
; 4899 : 	return(0);
; 4900 : }

  029b3	83 c4 08	 add	 esp, 8
  029b6	c3		 ret	 0
_par_skip_white_space ENDP
_TEXT	ENDS
_DATA	SEGMENT
$SG72509 DB	'%s', 0aH, 00H
$SG72510 DB	'error in rule at position %d', 0aH, 00H
	ORG $+2
$SG72511 DB	'rule, %s', 0aH, 00H
	ORG $+2
$SG72512 DB	'      ', 00H
	ORG $+1
$SG72516 DB	' ', 00H
	ORG $+2
$SG72517 DB	'^', 0aH, 00H
_DATA	ENDS
_TEXT	SEGMENT
_message$ = 8
_current_rule$ = 12
_pos$ = 16
_par_print_rule_error PROC NEAR

; 4926 : 	int i;
; 4927 : 	printf("%s\n",message);

  029c0	8b 44 24 04	 mov	 eax, DWORD PTR _message$[esp-4]
  029c4	56		 push	 esi
  029c5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__printf
  029cb	57		 push	 edi
  029cc	50		 push	 eax
  029cd	68 00 00 00 00	 push	 OFFSET FLAT:$SG72509
  029d2	ff d6		 call	 esi

; 4928 : 	printf("error in rule at position %d\n",pos);

  029d4	8b 7c 24 1c	 mov	 edi, DWORD PTR _pos$[esp+12]
  029d8	57		 push	 edi
  029d9	68 00 00 00 00	 push	 OFFSET FLAT:$SG72510
  029de	ff d6		 call	 esi

; 4929 : 	printf("rule, %s\n",current_rule);

  029e0	8b 4c 24 20	 mov	 ecx, DWORD PTR _current_rule$[esp+20]
  029e4	51		 push	 ecx
  029e5	68 00 00 00 00	 push	 OFFSET FLAT:$SG72511
  029ea	ff d6		 call	 esi

; 4930 : 	printf("      ");

  029ec	68 00 00 00 00	 push	 OFFSET FLAT:$SG72512
  029f1	ff d6		 call	 esi
  029f3	83 c4 1c	 add	 esp, 28			; 0000001cH

; 4931 : 	for (i=0;i<pos;i++)

  029f6	85 ff		 test	 edi, edi
  029f8	7e 0d		 jle	 SHORT $L72515
$L72513:

; 4932 : 	{
; 4933 : 		printf(" ");

  029fa	68 00 00 00 00	 push	 OFFSET FLAT:$SG72516
  029ff	ff d6		 call	 esi
  02a01	83 c4 04	 add	 esp, 4
  02a04	4f		 dec	 edi
  02a05	75 f3		 jne	 SHORT $L72513
$L72515:

; 4934 : 	}
; 4935 : 	printf("^\n");

  02a07	68 00 00 00 00	 push	 OFFSET FLAT:$SG72517
  02a0c	ff d6		 call	 esi
  02a0e	83 c4 04	 add	 esp, 4
  02a11	5f		 pop	 edi
  02a12	5e		 pop	 esi

; 4936 : }

  02a13	c3		 ret	 0
_par_print_rule_error ENDP
_current_rule$ = 8
_char_type$ = 12
_input_array$ = 16
_match_array$ = 20
_ret_value$ = 24
_lookahead$ = 28
_break_on_min_match$ = 32
_rule_p$ = 12
_length$ = -52
_ipos$ = -20
_min_range$ = -40
_match_is_over$ = -48
_satisfied_min_cond$ = -32
_new_char_type$ = -8
_i$ = -44
_counter$ = 8
_match_non_match$ = -12
_in_rule_p$ = -4
_next_type$ = -36
_num_desc$ = -28
_large_desc$ = -16
_par_match_standard PROC NEAR

; 4999 : {

  02a20	83 ec 34	 sub	 esp, 52			; 00000034H

; 5000 : 	int rule_p;
; 5001 : 	int length=0;
; 5002 : 	int ipos;
; 5003 : 	int min_range= -1,max_range= -1;
; 5004 : 	int match_is_over=0;
; 5005 : 	int satisfied_min_cond= -1;
; 5006 :     int new_char_type;
; 5007 : 	int i=0,counter;          
; 5008 : 	int match_non_match=1;         /* 1 is match 0 is non-match */
; 5009 : //	int find_type= -2;
; 5010 : 	int temp;
; 5011 : 	int temp2;
; 5012 : 	int in_rule_p;
; 5013 : 	int next_type=0;
; 5014 : 	int num_desc;
; 5015 : 	int large_desc=0;
; 5016 : 	
; 5017 : 	
; 5018 : #ifdef DEBUG
; 5019 : 	printf("entering par_match_standard\n");
; 5020 : #endif
; 5021 : #ifdef SANITY_CHECKING
; 5022 : 	if (ret_value==NULL)
; 5023 : 	{
; 5024 : #ifdef DEBUG
; 5025 : 		printf("leaving par_match_standard a 0\n");
; 5026 : #endif
; 5027 : 		return(0);
; 5028 : 	}
; 5029 : 	if ((current_rule==NULL) || (input_array==NULL))
; 5030 : 	{
; 5031 : 		ret_value->value=FATAL_FAIL;
; 5032 : #ifdef DEBUG
; 5033 : 		printf("leaving par_match_standard b 0\n");
; 5034 : #endif
; 5035 : 		return(0);
; 5036 : 	}
; 5037 : #endif
; 5038 : 	rule_p=ret_value->rule;

  02a23	8b 44 24 48	 mov	 eax, DWORD PTR _ret_value$[esp+48]
  02a27	53		 push	 ebx
  02a28	55		 push	 ebp

; 5039 : 	in_rule_p=rule_p;
; 5040 : 	ipos=ret_value->input_pos+ret_value->input_offset;
; 5041 : 	/* skip past the type delimiter */
; 5042 : 	new_char_type=char_type_table[char_type];
; 5043 : 	if (current_rule[rule_p] & BIN_LOOK_FROM_DISABLE)

  02a29	8b 6c 24 40	 mov	 ebp, DWORD PTR _current_rule$[esp+56]
  02a2d	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]
  02a30	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  02a33	56		 push	 esi
  02a34	57		 push	 edi
  02a35	8b 38		 mov	 edi, DWORD PTR [eax]
  02a37	8b 44 24 4c	 mov	 eax, DWORD PTR _char_type$[esp+64]
  02a3b	33 f6		 xor	 esi, esi
  02a3d	b9 01 00 00 00	 mov	 ecx, 1
  02a42	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _char_type_table[eax*4]
  02a49	03 d7		 add	 edx, edi
  02a4b	89 44 24 3c	 mov	 DWORD PTR _new_char_type$[esp+68], eax
  02a4f	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02a52	a8 40		 test	 al, 64			; 00000040H
  02a54	89 74 24 10	 mov	 DWORD PTR _length$[esp+68], esi
  02a58	89 74 24 14	 mov	 DWORD PTR _match_is_over$[esp+68], esi
  02a5c	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR _satisfied_min_cond$[esp+68], -1
  02a64	89 74 24 18	 mov	 DWORD PTR _i$[esp+68], esi
  02a68	89 4c 24 38	 mov	 DWORD PTR _match_non_match$[esp+68], ecx
  02a6c	89 74 24 20	 mov	 DWORD PTR _next_type$[esp+68], esi
  02a70	89 74 24 34	 mov	 DWORD PTR _large_desc$[esp+68], esi
  02a74	89 5c 24 40	 mov	 DWORD PTR _in_rule_p$[esp+68], ebx
  02a78	89 54 24 30	 mov	 DWORD PTR _ipos$[esp+68], edx
  02a7c	74 04		 je	 SHORT $L72550

; 5044 : 	{
; 5045 : 		lookahead=0;

  02a7e	89 74 24 5c	 mov	 DWORD PTR _lookahead$[esp+64], esi
$L72550:

; 5046 : #ifdef DEBUG
; 5047 : 		printf("match_standard set no lookahead\n");
; 5048 : #endif
; 5049 : 	}
; 5050 : 	rule_p++; /* move past operation */

  02a82	43		 inc	 ebx

; 5051 : 	temp=current_rule[rule_p];

  02a83	33 c0		 xor	 eax, eax
  02a85	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]

; 5052 : 	if (temp & BIN_COMPLIMENT)

  02a88	a8 80		 test	 al, -128		; ffffff80H
  02a8a	74 04		 je	 SHORT $L72551

; 5053 : 	{
; 5054 : #ifdef DEBUG
; 5055 : 		printf("match_standard set to non matches\n");
; 5056 : #endif
; 5057 : 		match_non_match=0;

  02a8c	89 74 24 38	 mov	 DWORD PTR _match_non_match$[esp+68], esi
$L72551:

; 5058 : 	}
; 5059 : 	if (temp & BIN_LARGE_DESC)

  02a90	a8 40		 test	 al, 64			; 00000040H
  02a92	74 04		 je	 SHORT $L72552

; 5060 : 	{
; 5061 : 		large_desc=1;

  02a94	89 4c 24 34	 mov	 DWORD PTR _large_desc$[esp+68], ecx
$L72552:

; 5062 : #ifdef DEBUG
; 5063 : 		printf("match_standard using large descriptors\n");
; 5064 : #endif
; 5065 : 	}
; 5066 : 	num_desc=(temp & BIN_SIZE_DESC_MASK);

  02a98	83 e0 3f	 and	 eax, 63			; 0000003fH

; 5067 : 	counter=0;
; 5068 : 	rule_p++; /* move past number of descrpitors */

  02a9b	43		 inc	 ebx
  02a9c	8b f8		 mov	 edi, eax

; 5069 : 	if (lookahead!=0)

  02a9e	8b 44 24 5c	 mov	 eax, DWORD PTR _lookahead$[esp+64]
  02aa2	85 c0		 test	 eax, eax
  02aa4	89 7c 24 28	 mov	 DWORD PTR _num_desc$[esp+68], edi
  02aa8	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR _counter$[esp+64], 0
  02ab0	74 0a		 je	 SHORT $L73177

; 5070 : 	{
; 5071 : 		next_type=current_rule[rule_p];

  02ab2	33 c9		 xor	 ecx, ecx
  02ab4	8a 0c 2b	 mov	 cl, BYTE PTR [ebx+ebp]

; 5072 : 		rule_p++; /* move past next type */

  02ab7	43		 inc	 ebx
  02ab8	89 4c 24 20	 mov	 DWORD PTR _next_type$[esp+68], ecx
$L73177:

; 5073 : 	}
; 5074 : 	/* either there is a number or there is a star of a plus */ 
; 5075 : 	while ((counter<num_desc) && (match_is_over==0))

  02abc	85 ff		 test	 edi, edi
  02abe	0f 8e af 02 00
	00		 jle	 $L73189
$L72555:
  02ac4	8b 44 24 14	 mov	 eax, DWORD PTR _match_is_over$[esp+68]
  02ac8	85 c0		 test	 eax, eax
  02aca	0f 85 9a 02 00
	00		 jne	 $L73186

; 5076 : 	{
; 5077 : 		if (large_desc)

  02ad0	8b 44 24 34	 mov	 eax, DWORD PTR _large_desc$[esp+68]
  02ad4	85 c0		 test	 eax, eax
  02ad6	74 65		 je	 SHORT $L72557

; 5078 : 		{
; 5079 : 			temp=get_short(current_rule+rule_p);
; 5080 : 			rule_p+=2;
; 5081 : 			counter++;

  02ad8	8b 4c 24 48	 mov	 ecx, DWORD PTR _counter$[esp+64]
  02adc	33 c0		 xor	 eax, eax
  02ade	8a 64 2b 01	 mov	 ah, BYTE PTR [ebx+ebp+1]
  02ae2	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02ae5	83 c3 02	 add	 ebx, 2
  02ae8	41		 inc	 ecx
  02ae9	89 5c 24 4c	 mov	 DWORD PTR _rule_p$[esp+64], ebx
  02aed	89 4c 24 48	 mov	 DWORD PTR _counter$[esp+64], ecx

; 5082 : 			min_range = temp & BIN_MAX_LARGE_DESC;

  02af1	8b c8		 mov	 ecx, eax
  02af3	81 e1 ff 3f 00
	00		 and	 ecx, 16383		; 00003fffH

; 5083 : 			max_range=min_range;
; 5084 : 			if (temp & BIN_LARGE_ANY_NUMBER)

  02af9	f6 c4 80	 test	 ah, -128		; ffffff80H
  02afc	89 4c 24 1c	 mov	 DWORD PTR _min_range$[esp+68], ecx
  02b00	8b f9		 mov	 edi, ecx
  02b02	74 07		 je	 SHORT $L72561

; 5085 : 			{
; 5086 : 				max_range=INT_MAX;

  02b04	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH

; 5087 : 			}
; 5088 : 			else

  02b09	eb 7b		 jmp	 SHORT $L72572
$L72561:

; 5089 : 			{
; 5090 : 				if (temp & BIN_LARGE_CONTINUE)

  02b0b	f6 c4 40	 test	 ah, 64			; 00000040H
  02b0e	74 76		 je	 SHORT $L72572

; 5091 : 				{
; 5092 : 					temp=get_short(current_rule+rule_p);
; 5093 : 					rule_p+=2;
; 5094 : 					counter++;

  02b10	8b 7c 24 48	 mov	 edi, DWORD PTR _counter$[esp+64]
  02b14	33 c0		 xor	 eax, eax
  02b16	8a 64 2b 01	 mov	 ah, BYTE PTR [ebx+ebp+1]
  02b1a	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02b1d	83 c3 02	 add	 ebx, 2
  02b20	47		 inc	 edi
  02b21	89 5c 24 4c	 mov	 DWORD PTR _rule_p$[esp+64], ebx
  02b25	89 7c 24 48	 mov	 DWORD PTR _counter$[esp+64], edi

; 5095 : 					max_range = temp & BIN_MAX_LARGE_DESC;

  02b29	8b f8		 mov	 edi, eax
  02b2b	81 e7 ff 3f 00
	00		 and	 edi, 16383		; 00003fffH

; 5096 : 					if (temp & BIN_LARGE_ANY_NUMBER)

  02b31	f6 c4 80	 test	 ah, -128		; ffffff80H
  02b34	74 50		 je	 SHORT $L72572

; 5097 : 					{
; 5098 : 						max_range=INT_MAX;

  02b36	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH

; 5099 : 					}
; 5100 : 				}
; 5101 : 			}
; 5102 : 		}
; 5103 : 		else

  02b3b	eb 49		 jmp	 SHORT $L72572
$L72557:

; 5104 : 		{
; 5105 : 			temp=current_rule[rule_p];
; 5106 : 			rule_p++;
; 5107 : 			counter++;

  02b3d	8b 7c 24 48	 mov	 edi, DWORD PTR _counter$[esp+64]
  02b41	33 c0		 xor	 eax, eax
  02b43	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02b46	43		 inc	 ebx
  02b47	47		 inc	 edi
  02b48	89 5c 24 4c	 mov	 DWORD PTR _rule_p$[esp+64], ebx
  02b4c	89 7c 24 48	 mov	 DWORD PTR _counter$[esp+64], edi

; 5108 : 			min_range = temp & BIN_MAX_SMALL_DESC;

  02b50	8b f8		 mov	 edi, eax
  02b52	83 e7 3f	 and	 edi, 63			; 0000003fH

; 5109 : 			max_range=min_range;
; 5110 : 			if (temp & BIN_SMALL_ANY_NUMBER)

  02b55	a8 80		 test	 al, -128		; ffffff80H
  02b57	89 7c 24 1c	 mov	 DWORD PTR _min_range$[esp+68], edi

; 5111 : 			{
; 5112 : 				max_range=INT_MAX;
; 5113 : 			}
; 5114 : 			else

  02b5b	75 20		 jne	 SHORT $L73206

; 5115 : 			{
; 5116 : 				if (temp & BIN_SMALL_CONTINUE)

  02b5d	a8 40		 test	 al, 64			; 00000040H
  02b5f	74 21		 je	 SHORT $L73194

; 5117 : 				{
; 5118 : 					temp=current_rule[rule_p];
; 5119 : 					rule_p++;
; 5120 : 					counter++;

  02b61	8b 7c 24 48	 mov	 edi, DWORD PTR _counter$[esp+64]
  02b65	33 c0		 xor	 eax, eax
  02b67	8a 04 2b	 mov	 al, BYTE PTR [ebx+ebp]
  02b6a	43		 inc	 ebx
  02b6b	47		 inc	 edi
  02b6c	89 5c 24 4c	 mov	 DWORD PTR _rule_p$[esp+64], ebx
  02b70	89 7c 24 48	 mov	 DWORD PTR _counter$[esp+64], edi

; 5121 : 					max_range = temp & BIN_MAX_SMALL_DESC;

  02b74	8b f8		 mov	 edi, eax
  02b76	83 e7 3f	 and	 edi, 63			; 0000003fH

; 5122 : 					if (temp & BIN_SMALL_ANY_NUMBER)

  02b79	a8 80		 test	 al, -128		; ffffff80H
  02b7b	74 05		 je	 SHORT $L73194
$L73206:

; 5123 : 					{
; 5124 : 						max_range=INT_MAX;

  02b7d	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
$L73194:
  02b82	8b 4c 24 1c	 mov	 ecx, DWORD PTR _min_range$[esp+68]
$L72572:

; 5125 : 					}
; 5126 : 				}
; 5127 : 			}
; 5128 : 		}
; 5129 : 		
; 5130 : 		
; 5131 : 		
; 5132 : 		/* do the character matching starting at length until min_length */
; 5133 : 		/* then match from min_length to max_length */
; 5134 : 		/* once min_length is reached, do lookahead for the next char type if necessary */
; 5135 : 		if (min_range==0)

  02b86	85 c9		 test	 ecx, ecx
  02b88	75 3f		 jne	 SHORT $L72576

; 5136 : 		{
; 5137 : 			/* signal that there could be success on a zero length string */
; 5138 : 			/* or the end of string could be successful too */
; 5139 : 			satisfied_min_cond= -2;                          
; 5140 : 			if (length==0)

  02b8a	85 f6		 test	 esi, esi
  02b8c	c7 44 24 24 fe
	ff ff ff	 mov	 DWORD PTR _satisfied_min_cond$[esp+68], -2 ; fffffffeH
  02b94	75 2f		 jne	 SHORT $L73195

; 5141 : 			{
; 5142 : 				if (lookahead)

  02b96	8b 44 24 5c	 mov	 eax, DWORD PTR _lookahead$[esp+64]
  02b9a	85 c0		 test	 eax, eax
  02b9c	74 27		 je	 SHORT $L73195

; 5143 : 				{
; 5144 : 					if ((par_look_ahead(current_rule,input_array,ipos,next_type,match_array,ret_value)==1))

  02b9e	8b 44 24 58	 mov	 eax, DWORD PTR _ret_value$[esp+64]
  02ba2	8b 4c 24 54	 mov	 ecx, DWORD PTR _match_array$[esp+64]
  02ba6	50		 push	 eax
  02ba7	8b 44 24 24	 mov	 eax, DWORD PTR _next_type$[esp+72]
  02bab	51		 push	 ecx
  02bac	8b 4c 24 58	 mov	 ecx, DWORD PTR _input_array$[esp+72]
  02bb0	50		 push	 eax
  02bb1	52		 push	 edx
  02bb2	51		 push	 ecx
  02bb3	55		 push	 ebp
  02bb4	e8 00 00 00 00	 call	 _par_look_ahead
  02bb9	83 c4 18	 add	 esp, 24			; 00000018H
  02bbc	83 f8 01	 cmp	 eax, 1
  02bbf	0f 84 c1 01 00
	00		 je	 $L73191
$L73195:
  02bc5	8b 54 24 30	 mov	 edx, DWORD PTR _ipos$[esp+68]
$L72576:

; 5145 : 					{
; 5146 : 						break;
; 5147 : 					}
; 5148 : 				}
; 5149 : 			}
; 5150 : 		}
; 5151 : 		if (match_non_match==1)

  02bc9	8b 44 24 38	 mov	 eax, DWORD PTR _match_non_match$[esp+68]

; 5152 : 		{
; 5153 : 			
; 5154 : 			for (i=length;i<max_range;i++)

  02bcd	89 74 24 18	 mov	 DWORD PTR _i$[esp+68], esi
  02bd1	83 f8 01	 cmp	 eax, 1
  02bd4	0f 85 bc 00 00
	00		 jne	 $L72577
  02bda	3b f7		 cmp	 esi, edi
  02bdc	0f 8d 74 01 00
	00		 jge	 $L72591
  02be2	8b 4c 24 50	 mov	 ecx, DWORD PTR _input_array$[esp+64]
  02be6	8d 5e 01	 lea	 ebx, DWORD PTR [esi+1]
  02be9	03 f2		 add	 esi, edx
  02beb	b8 01 00 00 00	 mov	 eax, 1
  02bf0	03 f1		 add	 esi, ecx
  02bf2	2b c1		 sub	 eax, ecx
  02bf4	89 44 24 2c	 mov	 DWORD PTR -24+[esp+68], eax
$L72578:

; 5155 : 			{
; 5156 : 				temp2=input_array[ipos+i];
; 5157 : 				
; 5158 : 				if ((((parser_char_types[temp2]) & new_char_type)==0) || (temp2=='\0'))

  02bf8	8b 4c 24 3c	 mov	 ecx, DWORD PTR _new_char_type$[esp+68]
  02bfc	33 c0		 xor	 eax, eax
  02bfe	8a 06		 mov	 al, BYTE PTR [esi]
  02c00	33 d2		 xor	 edx, edx
  02c02	66 8b 14 45 00
	00 00 00	 mov	 dx, WORD PTR _parser_char_types[eax*2]
  02c0a	85 d1		 test	 edx, ecx
  02c0c	0f 84 34 01 00
	00		 je	 $L73182
  02c12	85 c0		 test	 eax, eax
  02c14	0f 84 2c 01 00
	00		 je	 $L73182

; 5159 : 				{   
; 5160 : 					/* the matching failed in the section between the last range and the current range */
; 5161 : 					/* return length as the number of character matched */
; 5162 : 					match_is_over=1;
; 5163 : 					break;
; 5164 : 				}
; 5165 : 				temp=i+1;
; 5166 : 				if ((temp)>=min_range)

  02c1a	3b 5c 24 1c	 cmp	 ebx, DWORD PTR _min_range$[esp+68]
  02c1e	7c 5e		 jl	 SHORT $L72579

; 5167 : 				{
; 5168 : 					satisfied_min_cond=length=temp;
; 5169 : 					if (break_on_min_match==1)

  02c20	8b 4c 24 60	 mov	 ecx, DWORD PTR _break_on_min_match$[esp+64]
  02c24	b8 01 00 00 00	 mov	 eax, 1
  02c29	3b c8		 cmp	 ecx, eax
  02c2b	89 5c 24 10	 mov	 DWORD PTR _length$[esp+68], ebx
  02c2f	89 5c 24 24	 mov	 DWORD PTR _satisfied_min_cond$[esp+68], ebx
  02c33	0f 84 07 01 00
	00		 je	 $L73181

; 5170 : 					{
; 5171 : 						match_is_over=1;
; 5172 : 						break;
; 5173 : 					}					    
; 5174 : 					if ((lookahead) && ((counter<num_desc) || ( ((temp)<max_range))))

  02c39	8b 44 24 5c	 mov	 eax, DWORD PTR _lookahead$[esp+64]
  02c3d	85 c0		 test	 eax, eax
  02c3f	74 3d		 je	 SHORT $L72579
  02c41	8b 54 24 28	 mov	 edx, DWORD PTR _num_desc$[esp+68]
  02c45	8b 44 24 48	 mov	 eax, DWORD PTR _counter$[esp+64]
  02c49	3b c2		 cmp	 eax, edx
  02c4b	7c 04		 jl	 SHORT $L72586
  02c4d	3b df		 cmp	 ebx, edi
  02c4f	7d 2d		 jge	 SHORT $L72579
$L72586:

; 5175 : 					{
; 5176 : 						if (par_look_ahead(current_rule,input_array,ipos+temp,next_type,match_array,ret_value)==1)

  02c51	8b 44 24 58	 mov	 eax, DWORD PTR _ret_value$[esp+64]
  02c55	8b 4c 24 54	 mov	 ecx, DWORD PTR _match_array$[esp+64]
  02c59	8b 54 24 20	 mov	 edx, DWORD PTR _next_type$[esp+68]
  02c5d	50		 push	 eax
  02c5e	8b 44 24 30	 mov	 eax, DWORD PTR -24+[esp+72]
  02c62	51		 push	 ecx
  02c63	8b 4c 24 58	 mov	 ecx, DWORD PTR _input_array$[esp+72]
  02c67	03 c6		 add	 eax, esi
  02c69	52		 push	 edx
  02c6a	50		 push	 eax
  02c6b	51		 push	 ecx
  02c6c	55		 push	 ebp
  02c6d	e8 00 00 00 00	 call	 _par_look_ahead
  02c72	83 c4 18	 add	 esp, 24			; 00000018H
  02c75	83 f8 01	 cmp	 eax, 1
  02c78	0f 84 c8 00 00
	00		 je	 $L73182
$L72579:

; 5152 : 		{
; 5153 : 			
; 5154 : 			for (i=length;i<max_range;i++)

  02c7e	8b 44 24 18	 mov	 eax, DWORD PTR _i$[esp+68]
  02c82	40		 inc	 eax
  02c83	46		 inc	 esi
  02c84	43		 inc	 ebx
  02c85	3b c7		 cmp	 eax, edi
  02c87	89 44 24 18	 mov	 DWORD PTR _i$[esp+68], eax
  02c8b	0f 8c 67 ff ff
	ff		 jl	 $L72578

; 5143 : 				{
; 5144 : 					if ((par_look_ahead(current_rule,input_array,ipos,next_type,match_array,ret_value)==1))

  02c91	e9 b8 00 00 00	 jmp	 $L73205
$L72577:

; 5177 : 						{
; 5178 : 							match_is_over=1;
; 5179 : 							break;
; 5180 : 						}
; 5181 : 					}
; 5182 : 				}
; 5183 : 			}
; 5184 : 		}
; 5185 : 		else
; 5186 : 		{
; 5187 : 			for (i=length;i<max_range;i++)

  02c96	3b f7		 cmp	 esi, edi
  02c98	0f 8d b8 00 00
	00		 jge	 $L72591
  02c9e	8b 4c 24 50	 mov	 ecx, DWORD PTR _input_array$[esp+64]
  02ca2	8d 5e 01	 lea	 ebx, DWORD PTR [esi+1]
  02ca5	03 f2		 add	 esi, edx
  02ca7	b8 01 00 00 00	 mov	 eax, 1
  02cac	03 f1		 add	 esi, ecx
  02cae	2b c1		 sub	 eax, ecx
  02cb0	89 44 24 2c	 mov	 DWORD PTR -24+[esp+68], eax
$L72589:

; 5188 : 			{
; 5189 : 				temp2=input_array[ipos+i];
; 5190 : 				
; 5191 : 				if ((((parser_char_types[temp2]) & new_char_type)!=0) || (temp2=='\0'))

  02cb4	8b 4c 24 3c	 mov	 ecx, DWORD PTR _new_char_type$[esp+68]
  02cb8	33 c0		 xor	 eax, eax
  02cba	8a 06		 mov	 al, BYTE PTR [esi]
  02cbc	33 d2		 xor	 edx, edx
  02cbe	66 8b 14 45 00
	00 00 00	 mov	 dx, WORD PTR _parser_char_types[eax*2]
  02cc6	85 d1		 test	 edx, ecx
  02cc8	75 7c		 jne	 SHORT $L73182
  02cca	85 c0		 test	 eax, eax
  02ccc	74 78		 je	 SHORT $L73182

; 5196 : 					break;
; 5197 : 				}
; 5198 : 				temp=i+1;
; 5199 : 				if ((temp)>=min_range)

  02cce	3b 5c 24 1c	 cmp	 ebx, DWORD PTR _min_range$[esp+68]
  02cd2	7c 57		 jl	 SHORT $L72590

; 5200 : 				{
; 5201 : 					satisfied_min_cond=length=temp;
; 5202 : 					if (break_on_min_match==1)

  02cd4	8b 4c 24 60	 mov	 ecx, DWORD PTR _break_on_min_match$[esp+64]
  02cd8	b8 01 00 00 00	 mov	 eax, 1
  02cdd	3b c8		 cmp	 ecx, eax
  02cdf	89 5c 24 10	 mov	 DWORD PTR _length$[esp+68], ebx
  02ce3	89 5c 24 24	 mov	 DWORD PTR _satisfied_min_cond$[esp+68], ebx
  02ce7	74 57		 je	 SHORT $L73181

; 5206 : 					}					    
; 5207 : 					if ((lookahead) && ((counter<num_desc) || (((temp)<max_range))))

  02ce9	8b 44 24 5c	 mov	 eax, DWORD PTR _lookahead$[esp+64]
  02ced	85 c0		 test	 eax, eax
  02cef	74 3a		 je	 SHORT $L72590
  02cf1	8b 54 24 28	 mov	 edx, DWORD PTR _num_desc$[esp+68]
  02cf5	8b 44 24 48	 mov	 eax, DWORD PTR _counter$[esp+64]
  02cf9	3b c2		 cmp	 eax, edx
  02cfb	7c 04		 jl	 SHORT $L72597
  02cfd	3b df		 cmp	 ebx, edi
  02cff	7d 2a		 jge	 SHORT $L72590
$L72597:

; 5208 : 					{
; 5209 : 						if (par_look_ahead(current_rule,input_array,ipos+temp,next_type,match_array,ret_value)==1)

  02d01	8b 44 24 58	 mov	 eax, DWORD PTR _ret_value$[esp+64]
  02d05	8b 4c 24 54	 mov	 ecx, DWORD PTR _match_array$[esp+64]
  02d09	8b 54 24 20	 mov	 edx, DWORD PTR _next_type$[esp+68]
  02d0d	50		 push	 eax
  02d0e	8b 44 24 30	 mov	 eax, DWORD PTR -24+[esp+72]
  02d12	51		 push	 ecx
  02d13	52		 push	 edx
  02d14	8b 54 24 5c	 mov	 edx, DWORD PTR _input_array$[esp+76]
  02d18	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  02d1b	51		 push	 ecx
  02d1c	52		 push	 edx
  02d1d	55		 push	 ebp
  02d1e	e8 00 00 00 00	 call	 _par_look_ahead
  02d23	83 c4 18	 add	 esp, 24			; 00000018H
  02d26	83 f8 01	 cmp	 eax, 1
  02d29	74 1b		 je	 SHORT $L73182
$L72590:

; 5177 : 						{
; 5178 : 							match_is_over=1;
; 5179 : 							break;
; 5180 : 						}
; 5181 : 					}
; 5182 : 				}
; 5183 : 			}
; 5184 : 		}
; 5185 : 		else
; 5186 : 		{
; 5187 : 			for (i=length;i<max_range;i++)

  02d2b	8b 44 24 18	 mov	 eax, DWORD PTR _i$[esp+68]
  02d2f	40		 inc	 eax
  02d30	46		 inc	 esi
  02d31	43		 inc	 ebx
  02d32	3b c7		 cmp	 eax, edi
  02d34	89 44 24 18	 mov	 DWORD PTR _i$[esp+68], eax
  02d38	0f 8c 76 ff ff
	ff		 jl	 $L72589

; 5143 : 				{
; 5144 : 					if ((par_look_ahead(current_rule,input_array,ipos,next_type,match_array,ret_value)==1))

  02d3e	eb 0e		 jmp	 SHORT $L73205
$L73181:

; 5203 : 					{
; 5204 : 						match_is_over=1;

  02d40	89 44 24 14	 mov	 DWORD PTR _match_is_over$[esp+68], eax

; 5205 : 						break;

  02d44	eb 08		 jmp	 SHORT $L73205
$L73182:

; 5192 : 				{   
; 5193 : 					/* the matching failed in the section between the last range and the current range */
; 5194 : 					/* return length as the number of character matched */
; 5195 : 					match_is_over=1;

  02d46	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _match_is_over$[esp+68], 1
$L73205:
  02d4e	8b 74 24 10	 mov	 esi, DWORD PTR _length$[esp+68]
  02d52	8b 5c 24 4c	 mov	 ebx, DWORD PTR _rule_p$[esp+64]
$L72591:
  02d56	8b 7c 24 28	 mov	 edi, DWORD PTR _num_desc$[esp+68]
  02d5a	8b 44 24 48	 mov	 eax, DWORD PTR _counter$[esp+64]
  02d5e	8b 54 24 30	 mov	 edx, DWORD PTR _ipos$[esp+68]
  02d62	3b c7		 cmp	 eax, edi
  02d64	0f 8c 5a fd ff
	ff		 jl	 $L72555
$L73186:

; 5210 : 						{
; 5211 : 							match_is_over=1;
; 5212 : 							break;
; 5213 : 						}
; 5214 : 					}
; 5215 : 				}
; 5216 : 			}
; 5217 : 		}
; 5218 : 	}
; 5219 : #ifdef DEBUG
; 5220 : 	printf("par_match_standard;rule_p=%d\n",rule_p);
; 5221 : #endif
; 5222 : 	/* look for the next format type specifier */
; 5223 : 	/* look up in the table of ambiguity to know whether or not to do the lookahead parsing */
; 5224 : 	/* start mathcing the string */
; 5225 : 	/* once the minimum requirement for the type is met, start checking for the next type if required */
; 5226 : 	/* end the matching once the lookahead is successful or the current match hits the maximum 
; 5227 : 	number of characters */                
; 5228 : 	if (satisfied_min_cond== -1)

  02d6a	8b 44 24 24	 mov	 eax, DWORD PTR _satisfied_min_cond$[esp+68]
  02d6e	83 f8 ff	 cmp	 eax, -1
  02d71	75 0a		 jne	 SHORT $L72599
$L73189:
  02d73	5f		 pop	 edi
  02d74	5e		 pop	 esi
  02d75	5d		 pop	 ebp

; 5229 : 	{   /* changed for speed */ 
; 5230 : //		ret_value->value=FAIL;
; 5231 : 		return(0);

  02d76	33 c0		 xor	 eax, eax
  02d78	5b		 pop	 ebx

; 5271 : }

  02d79	83 c4 34	 add	 esp, 52			; 00000034H
  02d7c	c3		 ret	 0
$L72599:

; 5232 : 	}
; 5233 : 	if (satisfied_min_cond== -2)

  02d7d	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  02d80	75 37		 jne	 SHORT $L72600

; 5234 : 	{
; 5235 : 		if (length==0)

  02d82	85 f6		 test	 esi, esi
  02d84	75 10		 jne	 SHORT $L72604
$L73191:

; 5236 : 		{
; 5237 : 			length= -2;
; 5238 : 		}
; 5239 : 	}
; 5240 : 	else

  02d86	8b 7c 24 28	 mov	 edi, DWORD PTR _num_desc$[esp+68]
  02d8a	c7 44 24 10 fe
	ff ff ff	 mov	 DWORD PTR _length$[esp+68], -2 ; fffffffeH
  02d92	8b 74 24 10	 mov	 esi, DWORD PTR _length$[esp+68]
$L72604:

; 5247 : 			}
; 5248 : 		}                                        
; 5249 : 	}
; 5250 : 	if (counter!=num_desc)

  02d96	39 7c 24 48	 cmp	 DWORD PTR _counter$[esp+64], edi
  02d9a	74 44		 je	 SHORT $L72605

; 5251 : 	{
; 5252 : 		temp=in_rule_p;
; 5253 : 		temp+=2;

  02d9c	8b 54 24 40	 mov	 edx, DWORD PTR _in_rule_p$[esp+68]

; 5254 : 		if (lookahead)

  02da0	8b 4c 24 5c	 mov	 ecx, DWORD PTR _lookahead$[esp+64]
  02da4	85 c9		 test	 ecx, ecx
  02da6	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  02da9	74 01		 je	 SHORT $L72606

; 5255 : 			temp++;

  02dab	40		 inc	 eax
$L72606:

; 5256 : 		if (large_desc)

  02dac	8b 4c 24 34	 mov	 ecx, DWORD PTR _large_desc$[esp+68]
  02db0	85 c9		 test	 ecx, ecx
  02db2	74 24		 je	 SHORT $L72607

; 5257 : 		{
; 5258 : 			temp+=num_desc<<1;

  02db4	8d 04 78	 lea	 eax, DWORD PTR [eax+edi*2]

; 5259 : 		}
; 5260 : 		else

  02db7	eb 21		 jmp	 SHORT $L72608
$L72600:

; 5241 : 	{
; 5242 : 		if (input_array[ipos+i]=='\0')

  02db9	8b 44 24 18	 mov	 eax, DWORD PTR _i$[esp+68]
  02dbd	8b 4c 24 50	 mov	 ecx, DWORD PTR _input_array$[esp+64]
  02dc1	03 d0		 add	 edx, eax
  02dc3	80 3c 0a 00	 cmp	 BYTE PTR [edx+ecx], 0
  02dc7	75 cd		 jne	 SHORT $L72604

; 5243 : 		{
; 5244 : 			if (length==0)

  02dc9	85 f6		 test	 esi, esi
  02dcb	75 c9		 jne	 SHORT $L72604
  02dcd	5f		 pop	 edi
  02dce	5e		 pop	 esi
  02dcf	5d		 pop	 ebp

; 5245 : 			{	/* changed for speed */
; 5246 : 				return(-1);

  02dd0	83 c8 ff	 or	 eax, -1
  02dd3	5b		 pop	 ebx

; 5271 : }

  02dd4	83 c4 34	 add	 esp, 52			; 00000034H
  02dd7	c3		 ret	 0
$L72607:

; 5261 : 		{
; 5262 : 			temp+=num_desc;

  02dd8	03 c7		 add	 eax, edi
$L72608:

; 5263 : 		}
; 5264 : 		rule_p=temp;

  02dda	89 44 24 4c	 mov	 DWORD PTR _rule_p$[esp+64], eax
  02dde	8b d8		 mov	 ebx, eax
$L72605:

; 5265 : 	}
; 5266 : 	ret_value->rule=rule_p;

  02de0	8b 44 24 58	 mov	 eax, DWORD PTR _ret_value$[esp+64]
  02de4	5f		 pop	 edi
  02de5	89 58 10	 mov	 DWORD PTR [eax+16], ebx

; 5267 : #ifdef DEBUG
; 5268 : 	printf("leaving par_match_standard length=%d ret_value->value=%d\n",length,ret_value->value);
; 5269 : #endif
; 5270 : 	return(length);

  02de8	8b c6		 mov	 eax, esi
  02dea	5e		 pop	 esi
  02deb	5d		 pop	 ebp
  02dec	5b		 pop	 ebx

; 5271 : }

  02ded	83 c4 34	 add	 esp, 52			; 00000034H
  02df0	c3		 ret	 0
_par_match_standard ENDP
_current_rule$ = 8
_input_array$ = 12
_match_array$ = 16
_ret_value$ = 20
_range_value$ = 24
_lookahead$ = 28
_break_on_min_match$ = 32
_length$ = -24
_ipos$ = -28
_max_range$ = -8
_match_is_over$ = -36
_satisfied_min_cond$ = -16
_satisfied_start$ = -12
_temp_num$ = -40
_i$ = -44
_counter$ = 8
_in_rule_p$ = -4
_next_type$ = -20
_num_desc$ = -48
_large_desc$ = -32
_par_match_digits PROC NEAR

; 5308 : {

  02e00	83 ec 30	 sub	 esp, 48			; 00000030H

; 5309 : 	int rule_p;							/* a temproary rule pointer */
; 5310 : 	int	length=0;						/* the length of the matched characters */
; 5311 : 	int	ipos;							/* the input_pos+input_offset from ret_value */
; 5312 : 	int min_range= -1;					/* the minimum value of the current range */
; 5313 : 	int	max_range= -1;					/* the maximum value of the range */
; 5314 : 	int	match_is_over=0;				/* a flag to signal that the matching has failed */
; 5315 : 	int	satisfied_min_cond= -1;			/* holds the value of the largest number that

  02e03	83 c8 ff	 or	 eax, -1
  02e06	53		 push	 ebx
  02e07	89 44 24 24	 mov	 DWORD PTR _satisfied_min_cond$[esp+52], eax

; 5316 : 										* is still in the range found so far */
; 5317 : 	int	satisfied_start= -1;			/* holds the starting value of the number in satisfied_min_cond */

  02e0b	89 44 24 28	 mov	 DWORD PTR _satisfied_start$[esp+52], eax

; 5318 : 	int temp_num=0;						/* a temporary variable to hold the current number being processes */
; 5319 : 	int end_of_type=0;					/* flag that signals the end of the type specifier has been reached in the rule */
; 5320 : 	register int i=0;
; 5321 : 	int counter;          
; 5322 : 	//int find_type= -2;						/* the type that par_look_ahead found */
; 5323 : 	int temp;
; 5324 : 	int in_rule_p;
; 5325 : 	int next_type=0;
; 5326 : 	int num_desc;
; 5327 : 	int new_char_type;
; 5328 : 	int large_desc=0;
; 5329 : 	
; 5330 : 	
; 5331 : #ifdef DEBUG
; 5332 : 	printf("entering par_match_digits\n");
; 5333 : #endif            
; 5334 : #ifdef SANITY_CHECKING
; 5335 : 	if (ret_value==NULL)
; 5336 : 	{
; 5337 : #ifdef DEBUG
; 5338 : 		printf("leaving par_match_digits a 0\n");
; 5339 : #endif
; 5340 : 		return(0);
; 5341 : 	}
; 5342 : 	if ((current_rule==NULL) || (input_array==NULL) ||
; 5343 : 		(range_value==NULL))
; 5344 : 	{
; 5345 : 		ret_value->value=FATAL_FAIL;
; 5346 : #ifdef DEBUG
; 5347 : 		printf("leaving par_match_digits b 0\n");
; 5348 : #endif
; 5349 : 		return(0);
; 5350 : 	}
; 5351 : #endif
; 5352 : 	
; 5353 : 	rule_p=ret_value->rule;

  02e0f	8b 44 24 44	 mov	 eax, DWORD PTR _ret_value$[esp+48]
  02e13	55		 push	 ebp

; 5354 : 	in_rule_p=rule_p;
; 5355 : 	ipos=ret_value->input_pos+ret_value->input_offset;
; 5356 : 	/* skip past the type delimiter */
; 5357 : 	new_char_type=char_type_table[BIN_DIGIT];
; 5358 : 	if (current_rule[rule_p] & BIN_LOOK_FROM_DISABLE)

  02e14	8b 6c 24 3c	 mov	 ebp, DWORD PTR _current_rule$[esp+52]
  02e18	56		 push	 esi
  02e19	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  02e1c	8b 10		 mov	 edx, DWORD PTR [eax]
  02e1e	57		 push	 edi
  02e1f	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  02e22	33 f6		 xor	 esi, esi
  02e24	03 ca		 add	 ecx, edx
  02e26	8a 04 2f	 mov	 al, BYTE PTR [edi+ebp]
  02e29	89 74 24 28	 mov	 DWORD PTR _length$[esp+64], esi
  02e2d	a8 40		 test	 al, 64			; 00000040H
  02e2f	89 74 24 1c	 mov	 DWORD PTR _match_is_over$[esp+64], esi
  02e33	89 74 24 18	 mov	 DWORD PTR _temp_num$[esp+64], esi
  02e37	89 74 24 14	 mov	 DWORD PTR _i$[esp+64], esi
  02e3b	89 74 24 2c	 mov	 DWORD PTR _next_type$[esp+64], esi
  02e3f	89 74 24 20	 mov	 DWORD PTR _large_desc$[esp+64], esi
  02e43	89 7c 24 3c	 mov	 DWORD PTR _in_rule_p$[esp+64], edi
  02e47	89 4c 24 24	 mov	 DWORD PTR _ipos$[esp+64], ecx
  02e4b	74 04		 je	 SHORT $L72642

; 5359 : 	{
; 5360 : 		lookahead=0;

  02e4d	89 74 24 58	 mov	 DWORD PTR _lookahead$[esp+60], esi
$L72642:

; 5361 : #ifdef DEBUG
; 5362 : 		printf("match_standard set no lookahead\n");
; 5363 : #endif
; 5364 : 	}
; 5365 : 	rule_p++; /* move past operation */
; 5366 : 	if (current_rule[rule_p] & BIN_LARGE_DESC)

  02e51	8a 44 2f 01	 mov	 al, BYTE PTR [edi+ebp+1]
  02e55	47		 inc	 edi
  02e56	a8 40		 test	 al, 64			; 00000040H

; 5367 : 	{
; 5368 : 		large_desc=1;

  02e58	ba 01 00 00 00	 mov	 edx, 1
  02e5d	74 04		 je	 SHORT $L72643
  02e5f	89 54 24 20	 mov	 DWORD PTR _large_desc$[esp+64], edx
$L72643:

; 5369 : #ifdef DEBUG
; 5370 : 		printf("match_standard using large descriptors\n");
; 5371 : #endif
; 5372 : 	}
; 5373 : 	num_desc=(current_rule[rule_p] & BIN_SIZE_DESC_MASK);
; 5374 : 	counter=0;
; 5375 : 	rule_p++; /* move past number of descrpitors */
; 5376 : 	if (lookahead!=0)

  02e63	8b 4c 24 58	 mov	 ecx, DWORD PTR _lookahead$[esp+60]
  02e67	83 e0 3f	 and	 eax, 63			; 0000003fH
  02e6a	47		 inc	 edi
  02e6b	3b ce		 cmp	 ecx, esi
  02e6d	89 44 24 10	 mov	 DWORD PTR _num_desc$[esp+64], eax
  02e71	89 74 24 44	 mov	 DWORD PTR _counter$[esp+60], esi
  02e75	74 0a		 je	 SHORT $L73208

; 5377 : 	{
; 5378 : 		next_type=current_rule[rule_p];

  02e77	33 c9		 xor	 ecx, ecx
  02e79	8a 0c 2f	 mov	 cl, BYTE PTR [edi+ebp]

; 5379 : 		rule_p++; /* move past next type */

  02e7c	47		 inc	 edi
  02e7d	89 4c 24 2c	 mov	 DWORD PTR _next_type$[esp+64], ecx
$L73208:

; 5380 : 	}
; 5381 : 	/* either there is a number or there is a star of a plus */ 
; 5382 : 	
; 5383 : 	while ((counter<num_desc) && (match_is_over==0))

  02e81	8b 5c 24 54	 mov	 ebx, DWORD PTR _range_value$[esp+60]
  02e85	3b c6		 cmp	 eax, esi
  02e87	0f 8e 03 02 00
	00		 jle	 $L73212
  02e8d	eb 0b		 jmp	 SHORT $L72646
$L73216:
  02e8f	8b 44 24 10	 mov	 eax, DWORD PTR _num_desc$[esp+64]
  02e93	ba 01 00 00 00	 mov	 edx, 1
  02e98	33 f6		 xor	 esi, esi
$L72646:
  02e9a	39 74 24 1c	 cmp	 DWORD PTR _match_is_over$[esp+64], esi
  02e9e	0f 85 ec 01 00
	00		 jne	 $L73212

; 5384 : 	{
; 5385 : 		if (large_desc)

  02ea4	39 74 24 20	 cmp	 DWORD PTR _large_desc$[esp+64], esi
  02ea8	74 4c		 je	 SHORT $L72648

; 5386 : 		{
; 5387 : 			temp=get_short(current_rule+rule_p);
; 5388 : 			rule_p+=2;
; 5389 : 			counter++;

  02eaa	8b 44 24 44	 mov	 eax, DWORD PTR _counter$[esp+60]
  02eae	33 c9		 xor	 ecx, ecx
  02eb0	8a 6c 2f 01	 mov	 ch, BYTE PTR [edi+ebp+1]
  02eb4	8a 0c 2f	 mov	 cl, BYTE PTR [edi+ebp]
  02eb7	83 c7 02	 add	 edi, 2
  02eba	40		 inc	 eax
  02ebb	89 44 24 44	 mov	 DWORD PTR _counter$[esp+60], eax

; 5390 : 			min_range = temp & BIN_MAX_LARGE_DESC;

  02ebf	8b c1		 mov	 eax, ecx
  02ec1	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH

; 5391 : 			max_range=min_range;
; 5392 : 			if (temp & BIN_LARGE_ANY_NUMBER)

  02ec6	f6 c5 80	 test	 ch, -128		; ffffff80H
  02ec9	8b f0		 mov	 esi, eax

; 5393 : 			{
; 5394 : 				max_range=INT_MAX;
; 5395 : 			}
; 5396 : 			else

  02ecb	75 62		 jne	 SHORT $L73225

; 5397 : 			{
; 5398 : 				if (temp & BIN_LARGE_CONTINUE)

  02ecd	f6 c5 40	 test	 ch, 64			; 00000040H
  02ed0	74 62		 je	 SHORT $L72663

; 5399 : 				{
; 5400 : 					temp=get_short(current_rule+rule_p);
; 5401 : 					rule_p+=2;
; 5402 : 					counter++;

  02ed2	8b 74 24 44	 mov	 esi, DWORD PTR _counter$[esp+60]
  02ed6	33 c9		 xor	 ecx, ecx
  02ed8	8a 6c 2f 01	 mov	 ch, BYTE PTR [edi+ebp+1]
  02edc	8a 0c 2f	 mov	 cl, BYTE PTR [edi+ebp]
  02edf	83 c7 02	 add	 edi, 2
  02ee2	46		 inc	 esi
  02ee3	89 74 24 44	 mov	 DWORD PTR _counter$[esp+60], esi

; 5403 : 					max_range = temp & BIN_MAX_LARGE_DESC;

  02ee7	8b f1		 mov	 esi, ecx
  02ee9	81 e6 ff 3f 00
	00		 and	 esi, 16383		; 00003fffH

; 5404 : 					if (temp & BIN_LARGE_ANY_NUMBER)

  02eef	f6 c5 80	 test	 ch, -128		; ffffff80H
  02ef2	74 40		 je	 SHORT $L72663

; 5405 : 					{
; 5406 : 						max_range=INT_MAX;
; 5407 : 					}
; 5408 : 				}
; 5409 : 			}
; 5410 : 		}
; 5411 : 		else

  02ef4	eb 39		 jmp	 SHORT $L73225
$L72648:

; 5412 : 		{
; 5413 : 			temp=current_rule[rule_p];
; 5414 : 			rule_p++;
; 5415 : 			counter++;

  02ef6	8b 44 24 44	 mov	 eax, DWORD PTR _counter$[esp+60]
  02efa	33 c9		 xor	 ecx, ecx
  02efc	8a 0c 2f	 mov	 cl, BYTE PTR [edi+ebp]
  02eff	47		 inc	 edi
  02f00	40		 inc	 eax
  02f01	89 44 24 44	 mov	 DWORD PTR _counter$[esp+60], eax

; 5416 : 			min_range = temp & BIN_MAX_SMALL_DESC;

  02f05	8b c1		 mov	 eax, ecx
  02f07	83 e0 3f	 and	 eax, 63			; 0000003fH

; 5417 : 			max_range=min_range;
; 5418 : 			if (temp & BIN_SMALL_ANY_NUMBER)

  02f0a	f6 c1 80	 test	 cl, -128		; ffffff80H
  02f0d	8b f0		 mov	 esi, eax

; 5419 : 			{
; 5420 : 				max_range=INT_MAX;
; 5421 : 			}
; 5422 : 			else

  02f0f	75 1e		 jne	 SHORT $L73225

; 5423 : 			{
; 5424 : 				if (temp & BIN_SMALL_CONTINUE)

  02f11	f6 c1 40	 test	 cl, 64			; 00000040H
  02f14	74 1e		 je	 SHORT $L72663

; 5425 : 				{
; 5426 : 					temp=current_rule[rule_p];
; 5427 : 					rule_p++;
; 5428 : 					counter++;

  02f16	8b 74 24 44	 mov	 esi, DWORD PTR _counter$[esp+60]
  02f1a	33 c9		 xor	 ecx, ecx
  02f1c	8a 0c 2f	 mov	 cl, BYTE PTR [edi+ebp]
  02f1f	47		 inc	 edi
  02f20	46		 inc	 esi
  02f21	89 74 24 44	 mov	 DWORD PTR _counter$[esp+60], esi

; 5429 : 					max_range = temp & BIN_MAX_SMALL_DESC;

  02f25	8b f1		 mov	 esi, ecx
  02f27	83 e6 3f	 and	 esi, 63			; 0000003fH

; 5430 : 					if (temp & BIN_SMALL_ANY_NUMBER)

  02f2a	f6 c1 80	 test	 cl, -128		; ffffff80H
  02f2d	74 05		 je	 SHORT $L72663
$L73225:

; 5431 : 					{
; 5432 : 						max_range=INT_MAX;

  02f2f	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
$L72663:

; 5433 : 					}
; 5434 : 				}
; 5435 : 			}
; 5436 : 		}
; 5437 : 		
; 5438 : 		/* do the character matching starting at length until min_length */
; 5439 : 		/* then match from min_length to max_length */
; 5440 : 		/* once min_length is reached, do lookahead for the next char type if necessary */
; 5441 : 		/* this is the conversion from actual number to number lengths */
; 5442 : 		if (range_value->range_set==0)

  02f34	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  02f37	85 c9		 test	 ecx, ecx
  02f39	75 07		 jne	 SHORT $L72664

; 5443 : 		{
; 5444 : 			range_value->range_set=1;

  02f3b	89 53 0c	 mov	 DWORD PTR [ebx+12], edx

; 5445 : 			range_value->start=min_range;

  02f3e	89 03		 mov	 DWORD PTR [ebx], eax

; 5446 : 		}
; 5447 : 		else

  02f40	eb 1f		 jmp	 SHORT $L72667
$L72664:

; 5448 : 		{
; 5449 : 			if (range_value->range_set==2)

  02f42	83 f9 02	 cmp	 ecx, 2
  02f45	75 07		 jne	 SHORT $L72666

; 5450 : 			{
; 5451 : 				range_value->range_set= -1;

  02f47	c7 43 0c ff ff
	ff ff		 mov	 DWORD PTR [ebx+12], -1
$L72666:

; 5452 : 			}
; 5453 : 			if (range_value->range_set==1)

  02f4e	39 53 0c	 cmp	 DWORD PTR [ebx+12], edx
  02f51	75 0e		 jne	 SHORT $L72667

; 5454 : 			{
; 5455 : 				range_value->start+=((min_range-range_value->end)-1);

  02f53	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  02f56	8b d0		 mov	 edx, eax
  02f58	2b d1		 sub	 edx, ecx
  02f5a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  02f5c	4a		 dec	 edx
  02f5d	03 ca		 add	 ecx, edx
  02f5f	89 0b		 mov	 DWORD PTR [ebx], ecx
$L72667:

; 5459 : 		range_value->end=max_range;
; 5460 : 		min_range=par_get_int_length(min_range);

  02f61	50		 push	 eax
  02f62	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  02f65	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  02f68	e8 00 00 00 00	 call	 _par_get_int_length

; 5461 : 		max_range=par_get_int_length(max_range);

  02f6d	56		 push	 esi
  02f6e	e8 00 00 00 00	 call	 _par_get_int_length

; 5462 : #ifdef DIGIT_DEBUG
; 5463 : 		printf("par_match_digits; before match length=%d match_is_over=%d satisfied_min_cond=%d\n",length,match_is_over,satisfied_min_cond);
; 5464 : 		printf("par_match_digits; before match min_range=%d max_range=%d\n",min_range,max_range);
; 5465 : #endif
; 5466 : 		for (i=0;(((parser_char_types[input_array[ipos+i]] & TYPE_digit)!=0) &&
; 5467 : 			((temp_num=par_convert_number(input_array+ipos,i+1))<=range_value->end) &&
; 5468 : 			(i<max_range))
; 5469 : 			;i++)

  02f73	8b 4c 24 50	 mov	 ecx, DWORD PTR _input_array$[esp+68]
  02f77	89 44 24 40	 mov	 DWORD PTR _max_range$[esp+72], eax
  02f7b	8b 44 24 2c	 mov	 eax, DWORD PTR _ipos$[esp+72]
  02f7f	33 d2		 xor	 edx, edx
  02f81	03 c1		 add	 eax, ecx
  02f83	83 c4 08	 add	 esp, 8
  02f86	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _i$[esp+64], 0
  02f8e	89 44 24 54	 mov	 DWORD PTR 24+[esp+60], eax
  02f92	8a 10		 mov	 dl, BYTE PTR [eax]
  02f94	f6 04 55 00 00
	00 00 01	 test	 BYTE PTR _parser_char_types[edx*2], 1
  02f9c	0f 84 c5 00 00
	00		 je	 $L73219

; 5456 : 			}
; 5457 : 		}
; 5458 : 		range_value->min=min_range;

  02fa2	be 01 00 00 00	 mov	 esi, 1
  02fa7	eb 04		 jmp	 SHORT $L72668
$L73218:
  02fa9	8b 44 24 54	 mov	 eax, DWORD PTR 24+[esp+60]
$L72668:

; 5462 : #ifdef DIGIT_DEBUG
; 5463 : 		printf("par_match_digits; before match length=%d match_is_over=%d satisfied_min_cond=%d\n",length,match_is_over,satisfied_min_cond);
; 5464 : 		printf("par_match_digits; before match min_range=%d max_range=%d\n",min_range,max_range);
; 5465 : #endif
; 5466 : 		for (i=0;(((parser_char_types[input_array[ipos+i]] & TYPE_digit)!=0) &&
; 5467 : 			((temp_num=par_convert_number(input_array+ipos,i+1))<=range_value->end) &&
; 5468 : 			(i<max_range))
; 5469 : 			;i++)

  02fad	56		 push	 esi
  02fae	50		 push	 eax
  02faf	e8 00 00 00 00	 call	 _par_convert_number
  02fb4	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  02fb7	83 c4 08	 add	 esp, 8
  02fba	3b c1		 cmp	 eax, ecx
  02fbc	89 44 24 18	 mov	 DWORD PTR _temp_num$[esp+64], eax
  02fc0	0f 8f aa 00 00
	00		 jg	 $L73227
  02fc6	8b 54 24 38	 mov	 edx, DWORD PTR _max_range$[esp+64]
  02fca	8b 4c 24 14	 mov	 ecx, DWORD PTR _i$[esp+64]
  02fce	3b ca		 cmp	 ecx, edx
  02fd0	0f 8d 95 00 00
	00		 jge	 $L72670

; 5470 : 		{
; 5471 : #ifdef DIGIT_DEBUG
; 5472 : 			printf("looping in par_match_digits i=%d temp_num=%d\n",i,temp_num);
; 5473 : #endif
; 5474 : 			if (temp_num>=range_value->min)

  02fd6	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  02fd9	7c 5b		 jl	 SHORT $L72669

; 5475 : 			{
; 5476 : #ifdef DIGIT_DEBUG
; 5477 : 				printf("matched %d\n",temp_num);
; 5478 : #endif
; 5479 : 				temp=length=i+1;
; 5480 : 				satisfied_min_cond=temp_num;
; 5481 : 				satisfied_start=range_value->start;

  02fdb	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  02fdd	89 74 24 28	 mov	 DWORD PTR _length$[esp+64], esi
  02fe1	89 4c 24 34	 mov	 DWORD PTR _satisfied_start$[esp+64], ecx

; 5482 : 				if (break_on_min_match==1)

  02fe5	b9 01 00 00 00	 mov	 ecx, 1
  02fea	39 4c 24 5c	 cmp	 DWORD PTR _break_on_min_match$[esp+60], ecx
  02fee	89 44 24 30	 mov	 DWORD PTR _satisfied_min_cond$[esp+64], eax
  02ff2	74 65		 je	 SHORT $L73210

; 5486 : 				}
; 5487 : 				if ((lookahead) && ((counter<num_desc) || (((temp)<max_range))))

  02ff4	8b 44 24 58	 mov	 eax, DWORD PTR _lookahead$[esp+60]
  02ff8	85 c0		 test	 eax, eax
  02ffa	74 3a		 je	 SHORT $L72669
  02ffc	8b 44 24 10	 mov	 eax, DWORD PTR _num_desc$[esp+64]
  03000	8b 4c 24 44	 mov	 ecx, DWORD PTR _counter$[esp+60]
  03004	3b c8		 cmp	 ecx, eax
  03006	7c 04		 jl	 SHORT $L72674
  03008	3b f2		 cmp	 esi, edx
  0300a	7d 2a		 jge	 SHORT $L72669
$L72674:

; 5488 : 				{
; 5489 : 					if (par_look_ahead(current_rule,input_array,ipos+temp,next_type,match_array,ret_value)==1)

  0300c	8b 4c 24 50	 mov	 ecx, DWORD PTR _ret_value$[esp+60]
  03010	8b 54 24 4c	 mov	 edx, DWORD PTR _match_array$[esp+60]
  03014	8b 44 24 2c	 mov	 eax, DWORD PTR _next_type$[esp+64]
  03018	51		 push	 ecx
  03019	8b 4c 24 28	 mov	 ecx, DWORD PTR _ipos$[esp+68]
  0301d	52		 push	 edx
  0301e	50		 push	 eax
  0301f	8b 44 24 54	 mov	 eax, DWORD PTR _input_array$[esp+72]
  03023	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  03026	52		 push	 edx
  03027	50		 push	 eax
  03028	55		 push	 ebp
  03029	e8 00 00 00 00	 call	 _par_look_ahead
  0302e	83 c4 18	 add	 esp, 24			; 00000018H
  03031	83 f8 01	 cmp	 eax, 1
  03034	74 29		 je	 SHORT $L73211
$L72669:

; 5462 : #ifdef DIGIT_DEBUG
; 5463 : 		printf("par_match_digits; before match length=%d match_is_over=%d satisfied_min_cond=%d\n",length,match_is_over,satisfied_min_cond);
; 5464 : 		printf("par_match_digits; before match min_range=%d max_range=%d\n",min_range,max_range);
; 5465 : #endif
; 5466 : 		for (i=0;(((parser_char_types[input_array[ipos+i]] & TYPE_digit)!=0) &&
; 5467 : 			((temp_num=par_convert_number(input_array+ipos,i+1))<=range_value->end) &&
; 5468 : 			(i<max_range))
; 5469 : 			;i++)

  03036	8b 44 24 14	 mov	 eax, DWORD PTR _i$[esp+64]
  0303a	8b 54 24 54	 mov	 edx, DWORD PTR 24+[esp+60]
  0303e	40		 inc	 eax
  0303f	33 c9		 xor	 ecx, ecx
  03041	89 44 24 14	 mov	 DWORD PTR _i$[esp+64], eax
  03045	46		 inc	 esi
  03046	8a 0c 02	 mov	 cl, BYTE PTR [edx+eax]
  03049	f6 04 4d 00 00
	00 00 01	 test	 BYTE PTR _parser_char_types[ecx*2], 1
  03051	0f 85 52 ff ff
	ff		 jne	 $L73218

; 5492 : 						break;
; 5493 : 					}
; 5494 : 				}
; 5495 : 			}
; 5496 : 		}
; 5497 : 		if ((temp_num>range_value->end) && (counter==num_desc))

  03057	eb 0e		 jmp	 SHORT $L73219
$L73210:

; 5483 : 				{
; 5484 : 					match_is_over=1;

  03059	89 4c 24 1c	 mov	 DWORD PTR _match_is_over$[esp+64], ecx

; 5485 : 					break;

  0305d	eb 0c		 jmp	 SHORT $L72670
$L73211:

; 5490 : 					{
; 5491 : 						match_is_over=1;

  0305f	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _match_is_over$[esp+64], 1
$L73219:
  03067	8b 44 24 18	 mov	 eax, DWORD PTR _temp_num$[esp+64]
$L72670:

; 5492 : 						break;
; 5493 : 					}
; 5494 : 				}
; 5495 : 			}
; 5496 : 		}
; 5497 : 		if ((temp_num>range_value->end) && (counter==num_desc))

  0306b	3b 43 04	 cmp	 eax, DWORD PTR [ebx+4]
  0306e	7e 0c		 jle	 SHORT $L72676
$L73227:
  03070	8b 44 24 44	 mov	 eax, DWORD PTR _counter$[esp+60]
  03074	8b 4c 24 10	 mov	 ecx, DWORD PTR _num_desc$[esp+64]
  03078	3b c1		 cmp	 eax, ecx
  0307a	74 39		 je	 SHORT $L73223
$L72676:

; 5380 : 	}
; 5381 : 	/* either there is a number or there is a star of a plus */ 
; 5382 : 	
; 5383 : 	while ((counter<num_desc) && (match_is_over==0))

  0307c	8b 4c 24 10	 mov	 ecx, DWORD PTR _num_desc$[esp+64]
  03080	8b 44 24 44	 mov	 eax, DWORD PTR _counter$[esp+60]
  03084	3b c1		 cmp	 eax, ecx
  03086	0f 8c 03 fe ff
	ff		 jl	 $L73216
  0308c	8b c1		 mov	 eax, ecx
  0308e	33 f6		 xor	 esi, esi
$L73212:

; 5498 : 		{
; 5499 : 			break;
; 5500 : 		}
; 5501 : 	}                              
; 5502 : #ifdef DIGIT_DEBUG
; 5503 : 	printf("take 2 length=%d match_is_over=%d satisfied_min_cond=%d\n",length,match_is_over,satisfied_min_cond);
; 5504 : 	printf("take 2 min_range=%d max_range=%d\n",min_range,max_range);
; 5505 : #endif
; 5506 : #ifdef DEBUG
; 5507 : 	printf("par_match_digits;rule_p=%d\n",rule_p);
; 5508 : #endif
; 5509 : 	if (counter!=num_desc)

  03090	39 44 24 44	 cmp	 DWORD PTR _counter$[esp+60], eax
  03094	74 21		 je	 SHORT $L72677

; 5510 : 	{
; 5511 : 		temp=in_rule_p;
; 5512 : 		temp+=2;

  03096	8b 54 24 3c	 mov	 edx, DWORD PTR _in_rule_p$[esp+64]

; 5513 : 		if (lookahead)

  0309a	8b 4c 24 58	 mov	 ecx, DWORD PTR _lookahead$[esp+60]
  0309e	3b ce		 cmp	 ecx, esi
  030a0	8d 7a 02	 lea	 edi, DWORD PTR [edx+2]
  030a3	74 01		 je	 SHORT $L72678

; 5514 : 			temp++;

  030a5	47		 inc	 edi
$L72678:

; 5515 : 		if (large_desc)

  030a6	39 74 24 20	 cmp	 DWORD PTR _large_desc$[esp+64], esi
  030aa	74 05		 je	 SHORT $L72679

; 5516 : 		{
; 5517 : 			temp+=num_desc<<1;

  030ac	8d 3c 47	 lea	 edi, DWORD PTR [edi+eax*2]

; 5518 : 		}
; 5519 : 		else

  030af	eb 06		 jmp	 SHORT $L72677
$L72679:

; 5520 : 		{
; 5521 : 			temp+=num_desc;

  030b1	03 f8		 add	 edi, eax

; 5522 : 		}
; 5523 : 		rule_p=temp;

  030b3	eb 02		 jmp	 SHORT $L72677
$L73223:
  030b5	33 f6		 xor	 esi, esi
$L72677:

; 5524 : 	}
; 5525 : 	
; 5526 : 	/* if satisfied_min_cond was not changed, there was no successful matching */
; 5527 :    	if (satisfied_min_cond== -1)

  030b7	83 7c 24 30 ff	 cmp	 DWORD PTR _satisfied_min_cond$[esp+64], -1
  030bc	75 0a		 jne	 SHORT $L72681
  030be	5f		 pop	 edi
  030bf	5e		 pop	 esi
  030c0	5d		 pop	 ebp

; 5528 :    	{
; 5529 : 		return(0);

  030c1	33 c0		 xor	 eax, eax
  030c3	5b		 pop	 ebx

; 5559 : }

  030c4	83 c4 30	 add	 esp, 48			; 00000030H
  030c7	c3		 ret	 0
$L72681:

; 5530 : 	}
; 5531 : 	else
; 5532 :    	{   
; 5533 : 	/* if there was a successful match that was not the last one set range_value->start to 
; 5534 :    		   the value of start at the when the match was hit */
; 5535 : 		if (range_value->start!=satisfied_start)

  030c8	8b 44 24 34	 mov	 eax, DWORD PTR _satisfied_start$[esp+64]
  030cc	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  030ce	3b c8		 cmp	 ecx, eax
  030d0	74 02		 je	 SHORT $L72683

; 5536 : 		{
; 5537 : 			range_value->start=satisfied_start;

  030d2	89 03		 mov	 DWORD PTR [ebx], eax
$L72683:

; 5538 : 		}
; 5539 : 	}
; 5540 : 	if (input_array[ipos+i]=='\0')

  030d4	8b 44 24 24	 mov	 eax, DWORD PTR _ipos$[esp+64]
  030d8	8b 4c 24 14	 mov	 ecx, DWORD PTR _i$[esp+64]
  030dc	8b 54 24 48	 mov	 edx, DWORD PTR _input_array$[esp+60]
  030e0	03 c1		 add	 eax, ecx
  030e2	80 3c 10 00	 cmp	 BYTE PTR [eax+edx], 0
  030e6	75 11		 jne	 SHORT $L72685

; 5541 : 	{
; 5542 : 		if (length==0)

  030e8	39 74 24 28	 cmp	 DWORD PTR _length$[esp+64], esi
  030ec	75 0b		 jne	 SHORT $L72685
  030ee	5f		 pop	 edi
  030ef	5e		 pop	 esi
  030f0	5d		 pop	 ebp

; 5543 : 		{	/* changed for speed */
; 5544 : 			return(-1);

  030f1	83 c8 ff	 or	 eax, -1
  030f4	5b		 pop	 ebx

; 5559 : }

  030f5	83 c4 30	 add	 esp, 48			; 00000030H
  030f8	c3		 ret	 0
$L72685:

; 5545 : 		}
; 5546 : 	}                                        
; 5547 : 	ret_value->rule=rule_p; 

  030f9	8b 44 24 50	 mov	 eax, DWORD PTR _ret_value$[esp+60]
  030fd	89 78 10	 mov	 DWORD PTR [eax+16], edi

; 5548 : #ifdef DIGIT_DEBUG    
; 5549 : 	par_print_rule_error("par_match_digits;testing the rule_p index",current_rule,rule_p);
; 5550 : #endif
; 5551 : #ifdef DEBUG
; 5552 : 	printf("leaving par_match_digits length=%d\n",length);
; 5553 : #else
; 5554 : #ifdef DIGIT_DEBUG
; 5555 : 	printf("leaving par_match_digits length=%d ret_value->value=%d\n",length,ret_value->value);
; 5556 : #endif
; 5557 : #endif
; 5558 :    	return(length);

  03100	8b 44 24 28	 mov	 eax, DWORD PTR _length$[esp+64]
  03104	5f		 pop	 edi
  03105	5e		 pop	 esi
  03106	5d		 pop	 ebp
  03107	5b		 pop	 ebx

; 5559 : }

  03108	83 c4 30	 add	 esp, 48			; 00000030H
  0310b	c3		 ret	 0
_par_match_digits ENDP
_TEXT	ENDS
PUBLIC	_par_match_set
_TEXT	SEGMENT
_ipos$ = -64
_total_length$ = -76
_match_is_over$ = -72
_satisfied_min_cond$ = -68
_counter$ = 8
_sect_p$ = -56
_section_p$ = -44
_end_of_all_types$ = -36
_num_desc$ = -40
_large_desc$ = -60
_new_ret$ = -32
_current_rule$ = 8
_input_array$ = 12
_match_array$ = 16
_ret_value$ = 20
_range_value$ = 24
_lookahead$ = 28
_break_on_min_match$ = 32
_times$ = -52
_par_match_sets_with_ranges PROC NEAR

; 5596 : {

  03110	83 ec 4c	 sub	 esp, 76			; 0000004cH

; 5597 : 	int rule_p;
; 5598 : 	int times=0,length=0,ipos,total_length=0;
; 5599 : 	int min_range= -1,max_range= -1;
; 5600 : 	int match_is_over=0;                              
; 5601 : 	int satisfied_min_cond= -1;
; 5602 : 	//	int par_look_ahead_success=0;
; 5603 : 	int i=0;
; 5604 : 	int temp;
; 5605 : 	int counter;
; 5606 : 	int sect_p,section_p;
; 5607 : 	int end_of_all_types,num_desc;
; 5608 : 	int large_desc;
; 5609 : 	//	int num_sections;
; 5610 : 	/* int find_type= -2; */ /* uncomment when look_ahead is implimented from sets */
; 5611 : #ifndef NEW_PARSER_FILE_LOADING
; 5612 : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0 }; 
; 5613 : #else
; 5614 : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0,NULL }; 
; 5615 : #endif
; 5616 : 	
; 5617 : #ifdef DEBUG
; 5618 : 	printf("entering par_match_sets_and_ranges\n");
; 5619 : #endif
; 5620 : #ifdef SANITY_CHECKING	
; 5621 : 	if (ret_value==NULL)
; 5622 : 	{
; 5623 : #ifdef DEBUG
; 5624 : 		printf("leaving par_match_sets_and_ranges a 0\n");
; 5625 : #endif
; 5626 : 		return(0);
; 5627 : 	}
; 5628 : 	if ((current_rule==NULL) || (input_array==NULL))
; 5629 : 	{
; 5630 : 		ret_value->value=FATAL_FAIL;
; 5631 : #ifdef DEBUG
; 5632 : 		printf("leaving par_match_sets_and_ranges b 0\n");
; 5633 : #endif
; 5634 : 		return(0);
; 5635 : 	}
; 5636 : #endif
; 5637 : 	rule_p=ret_value->rule;
; 5638 : 	ipos=ret_value->input_pos+ret_value->input_offset;

  03113	8b 54 24 5c	 mov	 edx, DWORD PTR _ret_value$[esp+72]
  03117	53		 push	 ebx
  03118	55		 push	 ebp
  03119	56		 push	 esi
  0311a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0311d	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 5639 : 	
; 5640 : 	/* skip past the type delimiter */
; 5641 : 	
; 5642 : 	rule_p++;
; 5643 : 	
; 5644 : 	new_ret.input_pos=ret_value->input_pos+ret_value->input_offset;	
; 5645 : 	new_ret.input_offset=0;
; 5646 : 	new_ret.output_pos=ret_value->output_pos+ret_value->output_offset;

  0311f	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  03122	03 c8		 add	 ecx, eax
  03124	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  03127	89 4c 24 18	 mov	 DWORD PTR _ipos$[esp+88], ecx
  0312b	89 4c 24 38	 mov	 DWORD PTR _new_ret$[esp+88], ecx
  0312f	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  03132	03 ce		 add	 ecx, esi
  03134	57		 push	 edi

; 5647 : 	new_ret.output_offset=0;
; 5648 : 	new_ret.value=SUCCESS;
; 5649 : #ifdef NEW_PARSER_FILE_LOADING
; 5650 : 	new_ret.phTTS=ret_value->phTTS;
; 5651 : #endif
; 5652 : 	
; 5653 : 	section_p=rule_p; /* the location of the number of sections */
; 5654 : 	
; 5655 : 	//	num_sections=current_rule[rule_p];	
; 5656 : 	
; 5657 : 	
; 5658 : 	end_of_all_types=current_rule[section_p+current_rule[rule_p]]+1;

  03135	8b 7c 24 60	 mov	 edi, DWORD PTR _current_rule$[esp+88]
  03139	33 ed		 xor	 ebp, ebp
  0313b	89 4c 24 44	 mov	 DWORD PTR _new_ret$[esp+100], ecx
  0313f	40		 inc	 eax
  03140	b9 01 00 00 00	 mov	 ecx, 1
  03145	33 db		 xor	 ebx, ebx
  03147	89 6c 24 4c	 mov	 DWORD PTR _new_ret$[esp+108], ebp
  0314b	89 6c 24 54	 mov	 DWORD PTR _new_ret$[esp+116], ebp
  0314f	89 6c 24 58	 mov	 DWORD PTR _new_ret$[esp+120], ebp
  03153	89 6c 24 40	 mov	 DWORD PTR _new_ret$[esp+96], ebp
  03157	89 6c 24 48	 mov	 DWORD PTR _new_ret$[esp+104], ebp
  0315b	89 4c 24 50	 mov	 DWORD PTR _new_ret$[esp+112], ecx
  0315f	8a 1c 38	 mov	 bl, BYTE PTR [eax+edi]
  03162	89 44 24 30	 mov	 DWORD PTR _section_p$[esp+92], eax
  03166	03 c3		 add	 eax, ebx
  03168	33 db		 xor	 ebx, ebx
  0316a	89 6c 24 28	 mov	 DWORD PTR _times$[esp+92], ebp
  0316e	89 6c 24 10	 mov	 DWORD PTR _total_length$[esp+92], ebp
  03172	8a 1c 38	 mov	 bl, BYTE PTR [eax+edi]
  03175	89 6c 24 14	 mov	 DWORD PTR _match_is_over$[esp+92], ebp
  03179	8b f3		 mov	 esi, ebx
  0317b	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR _satisfied_min_cond$[esp+92], -1
  03183	46		 inc	 esi
  03184	89 74 24 38	 mov	 DWORD PTR _end_of_all_types$[esp+92], esi

; 5659 : 	
; 5660 : 	rule_p+=(current_rule[rule_p])+1;	/* the location of the descriptors */

  03188	8d 70 01	 lea	 esi, DWORD PTR [eax+1]

; 5661 : 	
; 5662 : 	if (current_rule[rule_p] & BIN_LARGE_DESC)

  0318b	8a 44 38 01	 mov	 al, BYTE PTR [eax+edi+1]
  0318f	a8 40		 test	 al, 64			; 00000040H
  03191	74 0f		 je	 SHORT $L72719

; 5663 : 	{
; 5664 : 		large_desc=1;
; 5665 : 		sect_p=rule_p+(current_rule[rule_p] <<1)+1;

  03193	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  03198	89 4c 24 20	 mov	 DWORD PTR _large_desc$[esp+92], ecx
  0319c	8d 4c 46 01	 lea	 ecx, DWORD PTR [esi+eax*2+1]

; 5666 : 	}
; 5667 : 	else

  031a0	eb 0d		 jmp	 SHORT $L73246
$L72719:

; 5668 : 	{
; 5669 : 		large_desc=0;
; 5670 : 		sect_p=rule_p+(current_rule[rule_p])+1; // the for the start of the sections of the sets 

  031a2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  031a7	89 6c 24 20	 mov	 DWORD PTR _large_desc$[esp+92], ebp
  031ab	8d 4c 30 01	 lea	 ecx, DWORD PTR [eax+esi+1]
$L73246:
  031af	89 4c 24 24	 mov	 DWORD PTR _sect_p$[esp+92], ecx

; 5671 : 	}
; 5672 : 	//	new_ret.rule=section_p;
; 5673 : 	
; 5674 : 	num_desc=(current_rule[rule_p] & BIN_SIZE_DESC_MASK);

  031b3	83 e0 3f	 and	 eax, 63			; 0000003fH

; 5675 : 	counter=0;

  031b6	33 c9		 xor	 ecx, ecx

; 5676 : 	rule_p++; /* move past number of descrpitors */

  031b8	46		 inc	 esi

; 5677 : 	
; 5678 : 	/* either there is a number or there is a star of a plus */
; 5679 : 	while ((counter<num_desc) && (match_is_over==0))

  031b9	3b c5		 cmp	 eax, ebp
  031bb	89 44 24 34	 mov	 DWORD PTR _num_desc$[esp+92], eax
  031bf	0f 8e a3 01 00
	00		 jle	 $L73239
  031c5	eb 02		 jmp	 SHORT $L72722
$L73244:
  031c7	33 ed		 xor	 ebp, ebp
$L72722:
  031c9	39 6c 24 14	 cmp	 DWORD PTR _match_is_over$[esp+92], ebp
  031cd	0f 85 8c 01 00
	00		 jne	 $L73236

; 5680 : 	{
; 5681 : 		if (large_desc)

  031d3	39 6c 24 20	 cmp	 DWORD PTR _large_desc$[esp+92], ebp
  031d7	74 45		 je	 SHORT $L72724

; 5682 : 		{
; 5683 : 			temp=get_short(current_rule+rule_p);

  031d9	33 c0		 xor	 eax, eax
  031db	8a 64 37 01	 mov	 ah, BYTE PTR [edi+esi+1]
  031df	8a 04 3e	 mov	 al, BYTE PTR [esi+edi]

; 5684 : 			rule_p+=2;

  031e2	83 c6 02	 add	 esi, 2

; 5685 : 			counter++;
; 5686 : 			min_range = temp & BIN_MAX_LARGE_DESC;

  031e5	8b d8		 mov	 ebx, eax
  031e7	41		 inc	 ecx
  031e8	81 e3 ff 3f 00
	00		 and	 ebx, 16383		; 00003fffH
  031ee	89 4c 24 60	 mov	 DWORD PTR _counter$[esp+88], ecx

; 5687 : 			max_range=min_range;
; 5688 : 			if (temp & BIN_LARGE_ANY_NUMBER)

  031f2	f6 c4 80	 test	 ah, -128		; ffffff80H
  031f5	8b eb		 mov	 ebp, ebx

; 5689 : 			{
; 5690 : 				max_range=INT_MAX;
; 5691 : 			}
; 5692 : 			else

  031f7	75 53		 jne	 SHORT $L73247

; 5693 : 			{
; 5694 : 				if (temp & BIN_LARGE_CONTINUE)

  031f9	f6 c4 40	 test	 ah, 64			; 00000040H
  031fc	74 53		 je	 SHORT $L72739

; 5695 : 				{
; 5696 : 					temp=get_short(current_rule+rule_p);

  031fe	33 c0		 xor	 eax, eax
  03200	8a 64 37 01	 mov	 ah, BYTE PTR [edi+esi+1]
  03204	8a 04 3e	 mov	 al, BYTE PTR [esi+edi]

; 5697 : 					rule_p+=2;

  03207	83 c6 02	 add	 esi, 2

; 5698 : 					counter++;
; 5699 : 					max_range = temp & BIN_MAX_LARGE_DESC;

  0320a	8b e8		 mov	 ebp, eax
  0320c	41		 inc	 ecx
  0320d	81 e5 ff 3f 00
	00		 and	 ebp, 16383		; 00003fffH
  03213	89 4c 24 60	 mov	 DWORD PTR _counter$[esp+88], ecx

; 5700 : 					if (temp & BIN_LARGE_ANY_NUMBER)

  03217	f6 c4 80	 test	 ah, -128		; ffffff80H
  0321a	74 35		 je	 SHORT $L72739

; 5701 : 					{
; 5702 : 						max_range=INT_MAX;
; 5703 : 					}
; 5704 : 				}
; 5705 : 			}
; 5706 : 		}
; 5707 : 		else

  0321c	eb 2e		 jmp	 SHORT $L73247
$L72724:

; 5708 : 		{
; 5709 : 			temp=current_rule[rule_p];

  0321e	33 c0		 xor	 eax, eax
  03220	8a 04 3e	 mov	 al, BYTE PTR [esi+edi]

; 5710 : 			rule_p++;

  03223	46		 inc	 esi

; 5711 : 			counter++;
; 5712 : 			min_range = temp & BIN_MAX_SMALL_DESC;

  03224	8b d8		 mov	 ebx, eax
  03226	41		 inc	 ecx
  03227	83 e3 3f	 and	 ebx, 63			; 0000003fH
  0322a	89 4c 24 60	 mov	 DWORD PTR _counter$[esp+88], ecx

; 5713 : 			max_range=min_range;
; 5714 : 			if (temp & BIN_SMALL_ANY_NUMBER)

  0322e	a8 80		 test	 al, -128		; ffffff80H
  03230	8b eb		 mov	 ebp, ebx

; 5715 : 			{
; 5716 : 				max_range=INT_MAX;
; 5717 : 			}
; 5718 : 			else

  03232	75 18		 jne	 SHORT $L73247

; 5719 : 			{
; 5720 : 				if (temp & BIN_SMALL_CONTINUE)

  03234	a8 40		 test	 al, 64			; 00000040H
  03236	74 19		 je	 SHORT $L72739

; 5721 : 				{
; 5722 : 					temp=current_rule[rule_p];

  03238	33 c0		 xor	 eax, eax
  0323a	8a 04 3e	 mov	 al, BYTE PTR [esi+edi]

; 5723 : 					rule_p++;

  0323d	46		 inc	 esi

; 5724 : 					counter++;
; 5725 : 					max_range = temp & BIN_MAX_SMALL_DESC;

  0323e	8b e8		 mov	 ebp, eax
  03240	41		 inc	 ecx
  03241	83 e5 3f	 and	 ebp, 63			; 0000003fH
  03244	89 4c 24 60	 mov	 DWORD PTR _counter$[esp+88], ecx

; 5726 : 					if (temp & BIN_SMALL_ANY_NUMBER)

  03248	a8 80		 test	 al, -128		; ffffff80H
  0324a	74 05		 je	 SHORT $L72739
$L73247:

; 5727 : 					{
; 5728 : 						max_range=INT_MAX;

  0324c	bd ff ff ff 7f	 mov	 ebp, 2147483647		; 7fffffffH
$L72739:

; 5729 : 					}
; 5730 : 				}
; 5731 : 			}
; 5732 : 		}
; 5733 : 		
; 5734 : 		
; 5735 : 		/* do the character matching starting at length until min_length */
; 5736 : 		/* then match from min_length to max_length */
; 5737 : 		/* once min_length is reached, do lookahead for the next char type if necessary */
; 5738 : 		if (min_range==0)

  03251	85 db		 test	 ebx, ebx
  03253	75 15		 jne	 SHORT $L72741

; 5739 : 		{
; 5740 : 			/* signal that there could be success on a zero length string */
; 5741 : 			/* or the end of string could be successful too */
; 5742 : 			satisfied_min_cond= -2;
; 5743 : 			if (break_on_min_match==1)

  03255	8b 44 24 78	 mov	 eax, DWORD PTR _break_on_min_match$[esp+88]
  03259	c7 44 24 18 fe
	ff ff ff	 mov	 DWORD PTR _satisfied_min_cond$[esp+92], -2 ; fffffffeH
  03261	83 f8 01	 cmp	 eax, 1
  03264	0f 84 19 01 00
	00		 je	 $L73245
$L72741:

; 5744 : 			{
; 5745 : 				break;
; 5746 : 			}
; 5747 : 		}
; 5748 : 		for (i=times;i<max_range;i++)

  0326a	8b 44 24 28	 mov	 eax, DWORD PTR _times$[esp+92]
  0326e	3b c5		 cmp	 eax, ebp
  03270	0f 8d d3 00 00
	00		 jge	 $L72744
  03276	40		 inc	 eax
  03277	89 44 24 2c	 mov	 DWORD PTR -48+[esp+92], eax
$L72742:

; 5749 : 		{
; 5750 : 			/* place the call to par_match_set here */
; 5751 : 			/* return the length of the thing matched */
; 5752 : 			length=par_match_set(current_rule,input_array,section_p,sect_p,ipos,match_array,range_value,&new_ret,lookahead);

  0327b	8b 54 24 74	 mov	 edx, DWORD PTR _lookahead$[esp+88]
  0327f	8b 4c 24 70	 mov	 ecx, DWORD PTR _range_value$[esp+88]
  03283	8d 44 24 3c	 lea	 eax, DWORD PTR _new_ret$[esp+92]
  03287	52		 push	 edx
  03288	8b 54 24 6c	 mov	 edx, DWORD PTR _match_array$[esp+92]
  0328c	50		 push	 eax
  0328d	8b 44 24 24	 mov	 eax, DWORD PTR _ipos$[esp+100]
  03291	51		 push	 ecx
  03292	8b 4c 24 30	 mov	 ecx, DWORD PTR _sect_p$[esp+104]
  03296	52		 push	 edx
  03297	8b 54 24 40	 mov	 edx, DWORD PTR _section_p$[esp+108]
  0329b	50		 push	 eax
  0329c	8b 44 24 78	 mov	 eax, DWORD PTR _input_array$[esp+108]
  032a0	51		 push	 ecx
  032a1	52		 push	 edx
  032a2	50		 push	 eax
  032a3	57		 push	 edi
  032a4	e8 00 00 00 00	 call	 _par_match_set
  032a9	83 c4 24	 add	 esp, 36			; 00000024H

; 5753 : 			if (length== -1)

  032ac	83 f8 ff	 cmp	 eax, -1
  032af	74 72		 je	 SHORT $L73231

; 5765 : 			}
; 5766 : 			if (length==0 && new_ret.value==SUCCESS)

  032b1	8b 4c 24 50	 mov	 ecx, DWORD PTR _new_ret$[esp+112]
  032b5	85 c0		 test	 eax, eax
  032b7	75 13		 jne	 SHORT $L72749
  032b9	ba 01 00 00 00	 mov	 edx, 1
  032be	3b ca		 cmp	 ecx, edx
  032c0	75 22		 jne	 SHORT $L72750

; 5767 : 			{
; 5768 : 				if (total_length==0)

  032c2	8b 4c 24 10	 mov	 ecx, DWORD PTR _total_length$[esp+92]
  032c6	85 c9		 test	 ecx, ecx
  032c8	74 73		 je	 SHORT $L73232

; 5774 : 					match_is_over=1;
; 5775 : 					break;
; 5776 : 				}
; 5777 : 			}
; 5778 : 			if (length>0)

  032ca	eb 25		 jmp	 SHORT $L73238
$L72749:
  032cc	85 c0		 test	 eax, eax
  032ce	7e 14		 jle	 SHORT $L72750

; 5779 : 			{
; 5780 : 				ipos+=length;

  032d0	8b 54 24 1c	 mov	 edx, DWORD PTR _ipos$[esp+92]
  032d4	03 d0		 add	 edx, eax
  032d6	89 54 24 1c	 mov	 DWORD PTR _ipos$[esp+92], edx

; 5781 : 				total_length+=length;

  032da	8b 54 24 10	 mov	 edx, DWORD PTR _total_length$[esp+92]
  032de	03 d0		 add	 edx, eax
  032e0	89 54 24 10	 mov	 DWORD PTR _total_length$[esp+92], edx
$L72750:

; 5782 : 			}
; 5783 : 			if (new_ret.value==FAIL)

  032e4	85 c9		 test	 ecx, ecx
  032e6	0f 84 86 00 00
	00		 je	 $L73233
  032ec	ba 01 00 00 00	 mov	 edx, 1
$L73238:

; 5787 : 			}
; 5788 : 			if ((i+1)>=min_range)

  032f1	8b 4c 24 2c	 mov	 ecx, DWORD PTR -48+[esp+92]
  032f5	3b cb		 cmp	 ecx, ebx
  032f7	7c 16		 jl	 SHORT $L72752

; 5789 : 			{
; 5790 : 				satisfied_min_cond=total_length;

  032f9	8b 44 24 10	 mov	 eax, DWORD PTR _total_length$[esp+92]

; 5791 : 				times=i+1;

  032fd	89 4c 24 28	 mov	 DWORD PTR _times$[esp+92], ecx
  03301	89 44 24 18	 mov	 DWORD PTR _satisfied_min_cond$[esp+92], eax

; 5792 : 				/* par_look_ahead cannot be done from here */
; 5793 : 				if (break_on_min_match==1)

  03305	8b 44 24 78	 mov	 eax, DWORD PTR _break_on_min_match$[esp+88]
  03309	3b c2		 cmp	 eax, edx
  0330b	74 38		 je	 SHORT $L73234

; 5794 : 				{
; 5795 : 					match_is_over=1;
; 5796 : 					break;
; 5797 : 				}						    
; 5798 : 				
; 5799 : 			}
; 5800 : 			else

  0330d	eb 04		 jmp	 SHORT $L72743
$L72752:

; 5801 : 			{
; 5802 : 				if (length==0)

  0330f	85 c0		 test	 eax, eax
  03311	74 32		 je	 SHORT $L73234
$L72743:

; 5744 : 			{
; 5745 : 				break;
; 5746 : 			}
; 5747 : 		}
; 5748 : 		for (i=times;i<max_range;i++)

  03313	41		 inc	 ecx
  03314	89 4c 24 2c	 mov	 DWORD PTR -48+[esp+92], ecx
  03318	49		 dec	 ecx
  03319	3b cd		 cmp	 ecx, ebp
  0331b	0f 8c 5a ff ff
	ff		 jl	 $L72742

; 5739 : 		{
; 5740 : 			/* signal that there could be success on a zero length string */
; 5741 : 			/* or the end of string could be successful too */
; 5742 : 			satisfied_min_cond= -2;
; 5743 : 			if (break_on_min_match==1)

  03321	eb 26		 jmp	 SHORT $L72744
$L73231:

; 5754 : 			{
; 5755 : 				match_is_over=1;     
; 5756 : 				if (satisfied_min_cond>0)

  03323	8b 44 24 18	 mov	 eax, DWORD PTR _satisfied_min_cond$[esp+92]
  03327	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _match_is_over$[esp+92], 1
  0332f	85 c0		 test	 eax, eax
  03331	7f 16		 jg	 SHORT $L72744

; 5757 : 				{
; 5758 : 					length=total_length;
; 5759 : 				}
; 5760 : 				else
; 5761 : 				{
; 5762 : 					total_length= -1;

  03333	c7 44 24 10 ff
	ff ff ff	 mov	 DWORD PTR _total_length$[esp+92], -1

; 5763 : 				}
; 5764 : 				break;

  0333b	eb 0c		 jmp	 SHORT $L72744
$L73232:

; 5769 : 				{
; 5770 : #ifdef DEBUG
; 5771 : 					printf("set satisfied_min_cond to -2\n");
; 5772 : #endif
; 5773 : 					satisfied_min_cond= -2;

  0333d	c7 44 24 18 fe
	ff ff ff	 mov	 DWORD PTR _satisfied_min_cond$[esp+92], -2 ; fffffffeH
$L73234:

; 5803 : 				{
; 5804 : 					match_is_over=1;

  03345	89 54 24 14	 mov	 DWORD PTR _match_is_over$[esp+92], edx
$L72744:

; 5677 : 	
; 5678 : 	/* either there is a number or there is a star of a plus */
; 5679 : 	while ((counter<num_desc) && (match_is_over==0))

  03349	8b 4c 24 60	 mov	 ecx, DWORD PTR _counter$[esp+88]
  0334d	8b 44 24 34	 mov	 eax, DWORD PTR _num_desc$[esp+92]
  03351	8b 54 24 6c	 mov	 edx, DWORD PTR _ret_value$[esp+88]
  03355	3b c8		 cmp	 ecx, eax
  03357	0f 8c 6a fe ff
	ff		 jl	 $L73244
  0335d	33 ed		 xor	 ebp, ebp
$L73236:

; 5805 : 					break;
; 5806 : 				}
; 5807 : 			}
; 5808 : 			
; 5809 : 		}
; 5810 : #ifdef DEBUG
; 5811 : 		printf("par_match_sets_and_ranges;rule_p=%d\n",rule_p);
; 5812 : #endif
; 5813 : 	}	/* while loop inner */
; 5814 :     /* look for the next format type specifier */
; 5815 :     /* look up in the table of ambiguity to know whether or not to do the lookahead parsing */
; 5816 :     /* start mathcing the string */
; 5817 : 	/* once the minimum requirement for the type is met, start checking for the next type if required */
; 5818 :     /* end the matching once the lookahead is successful or the current match hits the maximum 
; 5819 : 	number of characters */                
; 5820 : 	
; 5821 : 	
; 5822 : 	rule_p=end_of_all_types;
; 5823 : 	
; 5824 :    	if (satisfied_min_cond== -1)

  0335f	8b 44 24 18	 mov	 eax, DWORD PTR _satisfied_min_cond$[esp+92]
  03363	83 f8 ff	 cmp	 eax, -1
  03366	75 14		 jne	 SHORT $L72756
$L73239:
  03368	5f		 pop	 edi
  03369	5e		 pop	 esi
  0336a	5d		 pop	 ebp

; 5825 :    	{                                               
; 5826 : 		return(0);

  0336b	33 c0		 xor	 eax, eax
  0336d	5b		 pop	 ebx

; 5850 : }

  0336e	83 c4 4c	 add	 esp, 76			; 0000004cH
  03371	c3		 ret	 0
$L73233:

; 5784 : 			{
; 5785 : 				match_is_over=1;

  03372	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _match_is_over$[esp+92], 1

; 5786 : 				break;

  0337a	eb cd		 jmp	 SHORT $L72744
$L72756:

; 5827 :    	}
; 5828 :    	if (satisfied_min_cond== -2)

  0337c	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  0337f	75 25		 jne	 SHORT $L72757
  03381	eb 02		 jmp	 SHORT $L73240
$L73245:
  03383	33 ed		 xor	 ebp, ebp
$L73240:

; 5829 :    	{
; 5830 : 		if (total_length==0)

  03385	39 6c 24 10	 cmp	 DWORD PTR _total_length$[esp+92], ebp
  03389	75 08		 jne	 SHORT $L72761

; 5831 : 		{
; 5832 : 			total_length= -2;

  0338b	c7 44 24 10 fe
	ff ff ff	 mov	 DWORD PTR _total_length$[esp+92], -2 ; fffffffeH
$L72761:

; 5842 : 			}
; 5843 : 		}                                        
; 5844 : 	}
; 5845 : 	ret_value->rule=rule_p;

  03393	8b 4c 24 38	 mov	 ecx, DWORD PTR _end_of_all_types$[esp+92]

; 5846 : #ifdef DEBUG
; 5847 : 	printf("leaving par_match_sets_and_ranges length=%d total_length=%d ret_value->value=%d\n",length,total_length,ret_value->value);
; 5848 : #endif
; 5849 :    	return(total_length);

  03397	8b 44 24 10	 mov	 eax, DWORD PTR _total_length$[esp+92]
  0339b	5f		 pop	 edi
  0339c	5e		 pop	 esi
  0339d	5d		 pop	 ebp
  0339e	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  033a1	5b		 pop	 ebx

; 5850 : }

  033a2	83 c4 4c	 add	 esp, 76			; 0000004cH
  033a5	c3		 ret	 0
$L72757:

; 5833 : 		}
; 5834 :    	}
; 5835 :    	else
; 5836 : 	{
; 5837 : 		if (input_array[ipos]=='\0')

  033a6	8b 4c 24 64	 mov	 ecx, DWORD PTR _input_array$[esp+88]
  033aa	8b 44 24 1c	 mov	 eax, DWORD PTR _ipos$[esp+92]
  033ae	80 3c 08 00	 cmp	 BYTE PTR [eax+ecx], 0
  033b2	75 df		 jne	 SHORT $L72761

; 5838 : 		{
; 5839 : 			if (total_length==0)

  033b4	39 6c 24 10	 cmp	 DWORD PTR _total_length$[esp+92], ebp
  033b8	75 d9		 jne	 SHORT $L72761
  033ba	5f		 pop	 edi
  033bb	5e		 pop	 esi
  033bc	5d		 pop	 ebp

; 5840 : 			{	/* changed fo speed */
; 5841 : 				return(-1);

  033bd	83 c8 ff	 or	 eax, -1
  033c0	5b		 pop	 ebx

; 5850 : }

  033c1	83 c4 4c	 add	 esp, 76			; 0000004cH
  033c4	c3		 ret	 0
_par_match_sets_with_ranges ENDP
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+1
$SG72802 DB	'par_match_set; no charcter type found', 00H
_DATA	ENDS
_TEXT	SEGMENT
_current_rule$ = 8
_input_array$ = 12
_rule_p$ = 16
_sect_p$ = 20
_ipos$ = 24
_match_array$ = 28
_range_value$ = 32
_ret_value$ = 36
_lookahead$ = 40
_new_ret$ = -64
_save_ret$ = -32
_length$ = -72
_a_success$ = -68
_num_match$ = -76
_num_sections$ = 24
_end_of_all_sections$ = 8
_par_match_set PROC NEAR

; 5890 : {

  033d0	83 ec 4c	 sub	 esp, 76			; 0000004cH

; 5893 : 	return_value_t		save_ret = { 0,0,0,0,0,0,0,0 };	/* a copy to restore new_ret */
; 5894 : #else
; 5895 : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0,NULL }; 	/* for par_match_string to use */
; 5896 : 	return_value_t		save_ret = { 0,0,0,0,0,0,0,0,NULL };	/* a copy to restore new_ret */
; 5897 : #endif
; 5898 : 	int length=0;
; 5899 : 	int a_success=FAIL;
; 5900 : 	int this_success=0;
; 5901 : 	int num_chars_matched=0;
; 5902 : 	int num_match=0;
; 5903 : 	int new_char_type;
; 5904 : 	int num_sections;
; 5905 : 	int end_of_all_sections;
; 5906 : 	
; 5907 : #ifdef DEBUG
; 5908 : 	printf("entering par_match_set\n");
; 5909 : #endif
; 5910 : #ifdef SANITY_CHECKING
; 5911 : 	if (ret_value==NULL)
; 5912 : 	{
; 5913 : #ifdef DEBUG
; 5914 : 		printf("leaving par_match_set ret_value is NULL\n");
; 5915 : #endif
; 5916 : 		return(0);
; 5917 : 	}
; 5918 : 	if ((current_rule==NULL) || (input_array==NULL) || 
; 5919 : 		(match_array==NULL) || (range_value==NULL))
; 5920 : 	{
; 5921 : 		ret_value->value=FATAL_FAIL;
; 5922 : #ifdef DEBUG
; 5923 : 		printf("leaving par_match_set, inputs are bad\n");
; 5924 : #endif
; 5925 : 		return(0);
; 5926 : 	}
; 5927 : #endif
; 5928 : 	new_ret.rule=sect_p;
; 5929 : 	new_ret.input_pos=ipos;

  033d3	8b 4c 24 60	 mov	 ecx, DWORD PTR _ipos$[esp+72]

; 5930 : 	new_ret.optional=ret_value->optional;

  033d7	8b 54 24 6c	 mov	 edx, DWORD PTR _ret_value$[esp+72]
  033db	53		 push	 ebx
  033dc	55		 push	 ebp
  033dd	8b 6c 24 64	 mov	 ebp, DWORD PTR _sect_p$[esp+80]
  033e1	33 c0		 xor	 eax, eax
  033e3	89 4c 24 14	 mov	 DWORD PTR _new_ret$[esp+84], ecx
  033e7	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]

; 5931 : 	new_ret.value=SUCCESS;
; 5932 : 	
; 5933 : 	par_copy_return_value(&save_ret,&new_ret);
; 5934 : 	
; 5935 : 	num_sections=current_rule[rule_p];

  033ea	8b 5c 24 58	 mov	 ebx, DWORD PTR _current_rule$[esp+80]
  033ee	56		 push	 esi
  033ef	89 44 24 1c	 mov	 DWORD PTR _new_ret$[esp+92], eax
  033f3	89 44 24 20	 mov	 DWORD PTR _new_ret$[esp+96], eax
  033f7	89 44 24 24	 mov	 DWORD PTR _new_ret$[esp+100], eax
  033fb	89 44 24 34	 mov	 DWORD PTR _new_ret$[esp+116], eax
  033ff	89 44 24 10	 mov	 DWORD PTR _length$[esp+88], eax
  03403	89 44 24 14	 mov	 DWORD PTR _a_success$[esp+88], eax
  03407	89 44 24 0c	 mov	 DWORD PTR _num_match$[esp+88], eax
  0340b	57		 push	 edi
  0340c	8b c5		 mov	 eax, ebp
  0340e	89 4c 24 34	 mov	 DWORD PTR _new_ret$[esp+116], ecx
  03412	b9 08 00 00 00	 mov	 ecx, 8
  03417	8d 74 24 1c	 lea	 esi, DWORD PTR _new_ret$[esp+92]
  0341b	8d 7c 24 3c	 lea	 edi, DWORD PTR _save_ret$[esp+92]
  0341f	89 44 24 2c	 mov	 DWORD PTR _new_ret$[esp+108], eax
  03423	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR _new_ret$[esp+112], 1

; 5936 : 	end_of_all_sections=current_rule[rule_p+num_sections];

  0342b	33 d2		 xor	 edx, edx
  0342d	f3 a5		 rep movsd
  0342f	8b 7c 24 68	 mov	 edi, DWORD PTR _rule_p$[esp+88]
  03433	33 c9		 xor	 ecx, ecx
  03435	8a 0c 3b	 mov	 cl, BYTE PTR [ebx+edi]
  03438	8d 34 3b	 lea	 esi, DWORD PTR [ebx+edi]
  0343b	89 4c 24 70	 mov	 DWORD PTR _num_sections$[esp+88], ecx
  0343f	03 cb		 add	 ecx, ebx
  03441	8a 14 39	 mov	 dl, BYTE PTR [ecx+edi]
  03444	8b ca		 mov	 ecx, edx

; 5937 : 	
; 5938 : 	while ((new_ret.rule<=end_of_all_sections) && (a_success==FAIL))

  03446	3b e9		 cmp	 ebp, ecx
  03448	89 4c 24 60	 mov	 DWORD PTR _end_of_all_sections$[esp+88], ecx
  0344c	0f 8f 00 01 00
	00		 jg	 $L73252

; 5891 : #ifndef NEW_PARSER_FILE_LOADING
; 5892 : 	return_value_t		new_ret = { 0,0,0,0,0,0,0,0 }; 	/* for par_match_string to use */

  03452	8b 6c 24 78	 mov	 ebp, DWORD PTR _range_value$[esp+88]
$L72793:

; 5937 : 	
; 5938 : 	while ((new_ret.rule<=end_of_all_sections) && (a_success==FAIL))

  03456	8b 4c 24 18	 mov	 ecx, DWORD PTR _a_success$[esp+92]
  0345a	85 c9		 test	 ecx, ecx
  0345c	0f 85 fb 00 00
	00		 jne	 $L72812

; 5939 : 	{
; 5940 : 		this_success=SUCCESS;     
; 5941 : 		length=0;
; 5942 : 		rule_p++; /* go to the next section */

  03462	46		 inc	 esi

; 5943 : 		while ((new_ret.rule<=current_rule[rule_p]) && (a_success==FAIL))

  03463	33 c9		 xor	 ecx, ecx
  03465	bf 01 00 00 00	 mov	 edi, 1
  0346a	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _length$[esp+92], 0
  03472	8a 0e		 mov	 cl, BYTE PTR [esi]
  03474	89 74 24 6c	 mov	 DWORD PTR 20+[esp+88], esi
  03478	3b c1		 cmp	 eax, ecx
  0347a	7f 6d		 jg	 SHORT $L73253
$L72796:

; 5944 : 		{
; 5945 : 			if (new_char_type=(current_rule[new_ret.rule] & BIN_OPERATION_MASK))

  0347c	8a 0c 18	 mov	 cl, BYTE PTR [eax+ebx]
  0347f	83 e1 1f	 and	 ecx, 31			; 0000001fH
  03482	0f 84 ec 00 00
	00		 je	 $L72798

; 5946 : 			{
; 5947 : 				num_chars_matched=par_match_string(current_rule,new_char_type,input_array,match_array,&new_ret,range_value,0,0);

  03488	8b 44 24 74	 mov	 eax, DWORD PTR _match_array$[esp+88]
  0348c	6a 00		 push	 0
  0348e	6a 00		 push	 0
  03490	8d 54 24 24	 lea	 edx, DWORD PTR _new_ret$[esp+100]
  03494	55		 push	 ebp
  03495	52		 push	 edx
  03496	8b 54 24 74	 mov	 edx, DWORD PTR _input_array$[esp+104]
  0349a	50		 push	 eax
  0349b	52		 push	 edx
  0349c	51		 push	 ecx
  0349d	53		 push	 ebx
  0349e	e8 00 00 00 00	 call	 _par_match_string

; 5948 : 				length+=num_chars_matched;

  034a3	8b 4c 24 34	 mov	 ecx, DWORD PTR _length$[esp+124]

; 5949 : 				new_ret.input_pos+=num_chars_matched;

  034a7	8b 54 24 3c	 mov	 edx, DWORD PTR _new_ret$[esp+124]
  034ab	83 c4 20	 add	 esp, 32			; 00000020H
  034ae	03 c8		 add	 ecx, eax
  034b0	03 d0		 add	 edx, eax

; 5950 : 				if (num_chars_matched== -1)

  034b2	83 f8 ff	 cmp	 eax, -1
  034b5	89 4c 24 14	 mov	 DWORD PTR _length$[esp+92], ecx
  034b9	89 54 24 1c	 mov	 DWORD PTR _new_ret$[esp+92], edx
  034bd	0f 84 a6 00 00
	00		 je	 $L73251

; 5966 : 			}
; 5967 : 			if (new_ret.value==FAIL)

  034c3	8b 44 24 30	 mov	 eax, DWORD PTR _new_ret$[esp+112]
  034c7	85 c0		 test	 eax, eax
  034c9	75 0d		 jne	 SHORT $L73255

; 5968 : 			{
; 5969 : #ifdef DEBUG
; 5970 : 				printf("par_match_set;this section has failed, look for the next section\n");
; 5971 : #endif
; 5972 : 				this_success=FAIL;
; 5973 : 				new_ret.rule=current_rule[rule_p]+1;

  034cb	33 c0		 xor	 eax, eax
  034cd	33 ff		 xor	 edi, edi
  034cf	8a 06		 mov	 al, BYTE PTR [esi]
  034d1	40		 inc	 eax
  034d2	89 44 24 2c	 mov	 DWORD PTR _new_ret$[esp+108], eax
  034d6	eb 04		 jmp	 SHORT $L72803
$L73255:
  034d8	8b 44 24 2c	 mov	 eax, DWORD PTR _new_ret$[esp+108]
$L72803:

; 5943 : 		while ((new_ret.rule<=current_rule[rule_p]) && (a_success==FAIL))

  034dc	33 c9		 xor	 ecx, ecx
  034de	8a 0e		 mov	 cl, BYTE PTR [esi]
  034e0	3b c1		 cmp	 eax, ecx
  034e2	7e 98		 jle	 SHORT $L72796

; 5974 : 			} 
; 5975 : 			else
; 5976 : 			{
; 5977 : #ifdef DEBUG
; 5978 : 				printf("this type has succeeded, matching next type\n");
; 5979 : #endif
; 5980 : 			}
; 5981 : 		}    
; 5982 : #ifdef DEBUG
; 5983 : 		par_print_rule_error("par_match_set;after a comma or brace has been found",current_rule,new_ret.rule);
; 5984 : #endif
; 5985 : 		if (this_success==SUCCESS)

  034e4	83 ff 01	 cmp	 edi, 1
  034e7	75 28		 jne	 SHORT $L72805
$L73253:

; 5986 : 		{
; 5987 : 			a_success=SUCCESS;
; 5988 : #ifdef DEBUG
; 5989 : 			printf("par_match_set;this section has succeeded\n");
; 5990 : #endif
; 5991 : 			if (range_value->range_set==0)

  034e9	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  034ec	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _a_success$[esp+92], 1
  034f4	85 c9		 test	 ecx, ecx
  034f6	75 10		 jne	 SHORT $L72806

; 5992 : 			{
; 5993 : 				range_value->range_set=2;
; 5994 : 				range_value->start=num_match;

  034f8	8b 54 24 10	 mov	 edx, DWORD PTR _num_match$[esp+92]
  034fc	c7 45 0c 02 00
	00 00		 mov	 DWORD PTR [ebp+12], 2
  03503	89 55 00	 mov	 DWORD PTR [ebp], edx

; 5995 : 			}
; 5996 : 			else

  03506	eb 38		 jmp	 SHORT $L72810
$L72806:

; 5997 : 			{	
; 5998 : 				range_value->range_set= -1;

  03508	c7 45 0c ff ff
	ff ff		 mov	 DWORD PTR [ebp+12], -1

; 5999 : 			}
; 6000 : 		}            
; 6001 : 		else

  0350f	eb 2f		 jmp	 SHORT $L72810
$L72805:

; 6002 : 		{
; 6003 : 			if (num_match==num_sections)

  03511	8b 4c 24 70	 mov	 ecx, DWORD PTR _num_sections$[esp+88]
  03515	8b 54 24 10	 mov	 edx, DWORD PTR _num_match$[esp+92]
  03519	3b d1		 cmp	 edx, ecx
  0351b	74 23		 je	 SHORT $L72810

; 6004 : 			{
; 6005 : #ifdef DEBUG
; 6006 : 				printf("par_match_set;all sections failed\n");
; 6007 : #endif
; 6008 : 			}
; 6009 : 			else
; 6010 : 			{
; 6011 : #ifdef DEBUG
; 6012 : 				printf("par_match_set;this section has failed, going to next section\n");
; 6013 : #endif
; 6014 : 				par_copy_return_value(&new_ret,&save_ret);
; 6015 : 				num_match++;

  0351d	42		 inc	 edx

; 6016 : 				new_ret.rule=current_rule[rule_p]+1;

  0351e	33 c0		 xor	 eax, eax
  03520	89 54 24 10	 mov	 DWORD PTR _num_match$[esp+92], edx
  03524	8b 54 24 6c	 mov	 edx, DWORD PTR 20+[esp+88]
  03528	b9 08 00 00 00	 mov	 ecx, 8
  0352d	8d 74 24 3c	 lea	 esi, DWORD PTR _save_ret$[esp+92]
  03531	8a 02		 mov	 al, BYTE PTR [edx]
  03533	8d 7c 24 1c	 lea	 edi, DWORD PTR _new_ret$[esp+92]
  03537	f3 a5		 rep movsd
  03539	40		 inc	 eax
  0353a	8b f2		 mov	 esi, edx
  0353c	89 44 24 2c	 mov	 DWORD PTR _new_ret$[esp+108], eax
$L72810:
  03540	3b 44 24 60	 cmp	 eax, DWORD PTR _end_of_all_sections$[esp+88]
  03544	0f 8e 0c ff ff
	ff		 jle	 $L72793

; 6017 : 			}
; 6018 : 		}
; 6019 : 	}
; 6020 : 	if (a_success==FAIL)

  0354a	8b 44 24 18	 mov	 eax, DWORD PTR _a_success$[esp+92]
  0354e	85 c0		 test	 eax, eax
  03550	75 0b		 jne	 SHORT $L72812
$L73252:

; 6021 : 	{
; 6022 : 		ret_value->value=FAIL;

  03552	8b 4c 24 7c	 mov	 ecx, DWORD PTR _ret_value$[esp+88]
  03556	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
$L72812:

; 6023 : #ifdef DEBUG
; 6024 : 		printf("par_match_set; it failed\n");
; 6025 : #endif
; 6026 : 	}    
; 6027 : #ifdef DEBUG
; 6028 : 	printf("leaving par_match_set length=%d ret_value->value=%d\n",length,ret_value->value);
; 6029 : #endif
; 6030 : 	return(length);

  0355d	8b 44 24 14	 mov	 eax, DWORD PTR _length$[esp+92]
  03561	5f		 pop	 edi
  03562	5e		 pop	 esi
  03563	5d		 pop	 ebp
  03564	5b		 pop	 ebx

; 6031 : }	

  03565	83 c4 4c	 add	 esp, 76			; 0000004cH
  03568	c3		 ret	 0
$L73251:
  03569	5f		 pop	 edi
  0356a	5e		 pop	 esi
  0356b	5d		 pop	 ebp

; 5951 : 				{	/* changed for speed */
; 5952 : 					return(-1);

  0356c	83 c8 ff	 or	 eax, -1
  0356f	5b		 pop	 ebx

; 6031 : }	

  03570	83 c4 4c	 add	 esp, 76			; 0000004cH
  03573	c3		 ret	 0
$L72798:

; 5953 : 				}
; 5954 : #ifdef DEBUG
; 5955 : 				par_print_rule_error("par_match_set;after par_match_string",current_rule,new_ret.rule);
; 5956 : #endif
; 5957 : 			}
; 5958 : 			else
; 5959 : 			{
; 5960 : 				if (lookahead)

  03574	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR _lookahead$[esp+88]
  0357b	85 c9		 test	 ecx, ecx
  0357d	74 0f		 je	 SHORT $L72801

; 5961 : 				{
; 5962 : 					par_print_rule_error("par_match_set; no charcter type found",current_rule,new_ret.rule);

  0357f	50		 push	 eax
  03580	53		 push	 ebx
  03581	68 00 00 00 00	 push	 OFFSET FLAT:$SG72802
  03586	e8 00 00 00 00	 call	 _par_print_rule_error
  0358b	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72801:

; 5963 : 				}
; 5964 : 				ret_value->value=FATAL_FAIL;

  0358e	8b 44 24 7c	 mov	 eax, DWORD PTR _ret_value$[esp+88]
  03592	5f		 pop	 edi
  03593	5e		 pop	 esi
  03594	5d		 pop	 ebp
  03595	c7 40 14 04 00
	00 00		 mov	 DWORD PTR [eax+20], 4

; 5965 : 				return(0);

  0359c	33 c0		 xor	 eax, eax
  0359e	5b		 pop	 ebx

; 6031 : }	

  0359f	83 c4 4c	 add	 esp, 76			; 0000004cH
  035a2	c3		 ret	 0
_par_match_set ENDP
_TEXT	ENDS
END
