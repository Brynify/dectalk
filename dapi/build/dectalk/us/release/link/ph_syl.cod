	TITLE	D:\work\product\dapi\src\Ph\ph_syl.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_ascky_check
PUBLIC	_common_affixes
PUBLIC	_syl_vowels
PUBLIC	_syl_cons
_DATA	SEGMENT
_ascky_check DB	00H
	DB	069H
	DB	049H
	DB	065H
	DB	045H
	DB	040H
	DB	061H
	DB	041H
	DB	057H
	DB	05eH
	DB	063H
	DB	06fH
	DB	04fH
	DB	055H
	DB	075H
	DB	052H
	DB	059H
	DB	078H
	DB	07cH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	077H
	DB	079H
	DB	072H
	DB	06cH
	DB	068H
	DB	00H
	DB	00H
	DB	06dH
	DB	06eH
	DB	047H
	DB	04cH
	DB	00H
	DB	04eH
	DB	066H
	DB	076H
	DB	054H
	DB	044H
	DB	073H
	DB	07aH
	DB	053H
	DB	05aH
	DB	070H
	DB	062H
	DB	074H
	DB	064H
	DB	06bH
	DB	067H
	DB	026H
	DB	051H
	DB	071H
	DB	043H
	DB	04aH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+1
_common_affixes DD FLAT:$SG71221
	DD	FLAT:$SG71222
	DD	FLAT:$SG71223
	DD	FLAT:$SG71224
	DD	FLAT:$SG71225
	DD	FLAT:$SG71226
	DD	FLAT:$SG71227
	DD	FLAT:$SG71228
	DD	FLAT:$SG71229
	DD	FLAT:$SG71230
	DD	FLAT:$SG71231
	DD	FLAT:$SG71232
	DD	FLAT:$SG71233
	DD	FLAT:$SG71234
	DD	FLAT:$SG71235
	DD	FLAT:$SG71236
	DD	FLAT:$SG71237
	DD	FLAT:$SG71238
	DD	FLAT:$SG71239
	DD	FLAT:$SG71240
	DD	FLAT:$SG71241
	DD	FLAT:$SG71242
	DD	FLAT:$SG71243
	DD	FLAT:$SG71244
	DD	FLAT:$SG71245
	DD	FLAT:$SG71246
	DD	FLAT:$SG71247
	DD	FLAT:$SG71248
	DD	FLAT:$SG71249
	DD	FLAT:$SG71250
	DD	FLAT:$SG71251
	DD	FLAT:$SG71252
	DD	FLAT:$SG71253
	DD	FLAT:$SG71254
	DD	FLAT:$SG71255
	DD	FLAT:$SG71256
	DD	FLAT:$SG71257
	DD	FLAT:$SG71258
	DD	FLAT:$SG71259
	DD	FLAT:$SG71260
	DD	FLAT:$SG71261
	DD	FLAT:$SG71262
	DD	FLAT:$SG71263
	DD	FLAT:$SG71264
	DD	FLAT:$SG71265
	DD	FLAT:$SG71266
	DD	FLAT:$SG71267
	DD	FLAT:$SG71268
	DD	FLAT:$SG71269
	DD	FLAT:$SG71270
	DD	FLAT:$SG71271
	DD	FLAT:$SG71272
	DD	FLAT:$SG71273
	DD	FLAT:$SG71274
	DD	FLAT:$SG71275
	DD	FLAT:$SG71276
	DD	FLAT:$SG71277
	DD	FLAT:$SG71278
	DD	FLAT:$SG71279
	DD	FLAT:$SG71280
	DD	FLAT:$SG71281
	DD	FLAT:$SG71282
	DD	FLAT:$SG71283
	DD	FLAT:$SG71284
	DD	FLAT:$SG71285
	DD	FLAT:$SG71286
	DD	FLAT:$SG71287
	DD	FLAT:$SG71288
	DD	FLAT:$SG71289
	DD	FLAT:$SG71290
	DD	FLAT:$SG71291
	DD	FLAT:$SG71292
	DD	FLAT:$SG71293
	DD	FLAT:$SG71294
	DD	FLAT:$SG71295
	DD	FLAT:$SG71296
	DD	00H
_syl_vowels DB	'a@AeEiIoOuU^WRc|xLN', 00H
_syl_cons DD	FLAT:$SG71299
	DD	FLAT:$SG71300
	DD	FLAT:$SG71301
	DD	FLAT:$SG71302
	DD	FLAT:$SG71303
	DD	FLAT:$SG71304
	DD	FLAT:$SG71305
	DD	FLAT:$SG71306
	DD	FLAT:$SG71307
	DD	FLAT:$SG71308
	DD	FLAT:$SG71309
	DD	FLAT:$SG71310
	DD	FLAT:$SG71311
	DD	FLAT:$SG71312
	DD	FLAT:$SG71313
	DD	FLAT:$SG71314
	DD	FLAT:$SG71315
	DD	FLAT:$SG71316
	DD	FLAT:$SG71317
	DD	FLAT:$SG71318
	DD	FLAT:$SG71319
	DD	FLAT:$SG71320
	DD	FLAT:$SG71321
	DD	FLAT:$SG71322
	DD	FLAT:$SG71323
	DD	FLAT:$SG71324
	DD	FLAT:$SG71325
	DD	FLAT:$SG71326
	DD	FLAT:$SG71327
	DD	FLAT:$SG71328
	DD	FLAT:$SG71329
	DD	FLAT:$SG71330
	DD	FLAT:$SG71331
	DD	FLAT:$SG71332
	DD	FLAT:$SG71333
	DD	FLAT:$SG71334
	DD	FLAT:$SG71335
	DD	FLAT:$SG71336
	DD	FLAT:$SG71337
	DD	FLAT:$SG71338
	DD	FLAT:$SG71339
	DD	FLAT:$SG71340
	DD	FLAT:$SG71341
	DD	FLAT:$SG71342
	DD	FLAT:$SG71343
	DD	FLAT:$SG71344
	DD	FLAT:$SG71345
	DD	FLAT:$SG71346
	DD	FLAT:$SG71347
	DD	FLAT:$SG71348
	DD	FLAT:$SG71349
	DD	FLAT:$SG71350
	DD	FLAT:$SG71351
	DD	FLAT:$SG71352
	DD	FLAT:$SG71353
	DD	FLAT:$SG71354
	DD	FLAT:$SG71355
	DD	FLAT:$SG71356
	DD	FLAT:$SG71357
	DD	FLAT:$SG71358
	DD	00H
$SG71221 DB	'sElvz', 00H
	ORG $+2
$SG71222 DB	'kwIst', 00H
	ORG $+2
$SG71223 DB	'flEks', 00H
	ORG $+2
$SG71224 DB	'sfir', 00H
	ORG $+3
$SG71225 DB	'stAn', 00H
	ORG $+3
$SG71226 DB	'gr@f', 00H
	ORG $+3
$SG71227 DB	'ples', 00H
	ORG $+3
$SG71228 DB	'plen', 00H
	ORG $+3
$SG71229 DB	'skop', 00H
	ORG $+3
$SG71230 DB	'baks', 00H
	ORG $+3
$SG71231 DB	'ston', 00H
	ORG $+3
$SG71232 DB	'wRT', 00H
$SG71233 DB	'lxnd', 00H
	ORG $+3
$SG71234 DB	'l@nd', 00H
	ORG $+3
$SG71235 DB	'k@st', 00H
	ORG $+3
$SG71236 DB	'fI|S', 00H
	ORG $+3
$SG71237 DB	'h@nd', 00H
	ORG $+3
$SG71238 DB	'yard', 00H
	ORG $+3
$SG71239 DB	'kcpf', 00H
	ORG $+3
$SG71240 DB	'mxnt', 00H
	ORG $+3
$SG71241 DB	'mEnt', 00H
	ORG $+3
$SG71242 DB	'sElf', 00H
	ORG $+3
$SG71243 DB	'st@t', 00H
	ORG $+3
$SG71244 DB	'SI|p', 00H
	ORG $+3
$SG71245 DB	'sAt', 00H
$SG71246 DB	'vIl', 00H
$SG71247 DB	'b@k', 00H
$SG71248 DB	'bot', 00H
$SG71249 DB	'lAf', 00H
$SG71250 DB	'lAk', 00H
$SG71251 DB	'pAp', 00H
$SG71252 DB	'wck', 00H
$SG71253 DB	'wcS', 00H
$SG71254 DB	'wUd', 00H
$SG71255 DB	'wRk', 00H
$SG71256 DB	'kek', 00H
$SG71257 DB	'bcl', 00H
$SG71258 DB	'bEl', 00H
$SG71259 DB	'del', 00H
$SG71260 DB	'hIl', 00H
$SG71261 DB	'hol', 00H
$SG71262 DB	'hUd', 00H
$SG71263 DB	'l|s', 00H
$SG71264 DB	'm@n', 00H
$SG71265 DB	'mxn', 00H
$SG71266 DB	'mor', 00H
$SG71267 DB	'nEk', 00H
$SG71268 DB	'n|s', 00H
$SG71269 DB	'Sap', 00H
$SG71270 DB	'Z|n', 00H
$SG71271 DB	'S|n', 00H
$SG71272 DB	'tel', 00H
$SG71273 DB	'tin', 00H
$SG71274 DB	'tAm', 00H
$SG71275 DB	'wRd', 00H
$SG71276 DB	'wer', 00H
$SG71277 DB	'wIl', 00H
$SG71278 DB	'wAz', 00H
$SG71279 DB	'b@g', 00H
$SG71280 DB	'k@p', 00H
$SG71281 DB	'kar', 00H
$SG71282 DB	'k@t', 00H
$SG71283 DB	'dxm', 00H
$SG71284 DB	'flA', 00H
$SG71285 DB	'mxn', 00H
$SG71286 DB	'm@n', 00H
$SG71287 DB	'mEn', 00H
$SG71288 DB	'n^t', 00H
$SG71289 DB	'pad', 00H
$SG71290 DB	'ek', 00H
	ORG $+1
$SG71291 DB	'bO', 00H
	ORG $+1
$SG71292 DB	'de', 00H
	ORG $+1
$SG71293 DB	'fL', 00H
	ORG $+1
$SG71294 DB	'|J', 00H
	ORG $+1
$SG71295 DB	'sc', 00H
	ORG $+1
$SG71296 DB	'we', 00H
	ORG $+1
$SG71299 DB	'spl', 00H
$SG71300 DB	'spr', 00H
$SG71301 DB	'str', 00H
$SG71302 DB	'skw', 00H
$SG71303 DB	'skl', 00H
$SG71304 DB	'skr', 00H
$SG71305 DB	' Sm', 00H
$SG71306 DB	' SL', 00H
$SG71307 DB	'pl', 00H
	ORG $+1
$SG71308 DB	'pr', 00H
	ORG $+1
$SG71309 DB	'bl', 00H
	ORG $+1
$SG71310 DB	'br', 00H
	ORG $+1
$SG71311 DB	'fl', 00H
	ORG $+1
$SG71312 DB	'fr', 00H
	ORG $+1
$SG71313 DB	'tw', 00H
	ORG $+1
$SG71314 DB	'tr', 00H
	ORG $+1
$SG71315 DB	'dw', 00H
	ORG $+1
$SG71316 DB	'dr', 00H
	ORG $+1
$SG71317 DB	'Tw', 00H
	ORG $+1
$SG71318 DB	'Tr', 00H
	ORG $+1
$SG71319 DB	'kw', 00H
	ORG $+1
$SG71320 DB	'kl', 00H
	ORG $+1
$SG71321 DB	'kr', 00H
	ORG $+1
$SG71322 DB	'gw', 00H
	ORG $+1
$SG71323 DB	'gl', 00H
	ORG $+1
$SG71324 DB	'gr', 00H
	ORG $+1
$SG71325 DB	'sw', 00H
	ORG $+1
$SG71326 DB	'sl', 00H
	ORG $+1
$SG71327 DB	'sp', 00H
	ORG $+1
$SG71328 DB	'st', 00H
	ORG $+1
$SG71329 DB	'sk', 00H
	ORG $+1
$SG71330 DB	'sm', 00H
	ORG $+1
$SG71331 DB	'sn', 00H
	ORG $+1
$SG71332 DB	'Sw', 00H
	ORG $+1
$SG71333 DB	'Sl', 00H
	ORG $+1
$SG71334 DB	'Sr', 00H
	ORG $+1
$SG71335 DB	' Y', 00H
	ORG $+1
$SG71336 DB	'y', 00H
	ORG $+2
$SG71337 DB	'f', 00H
	ORG $+2
$SG71338 DB	't', 00H
	ORG $+2
$SG71339 DB	'd', 00H
	ORG $+2
$SG71340 DB	'T', 00H
	ORG $+2
$SG71341 DB	'k', 00H
	ORG $+2
$SG71342 DB	'g', 00H
	ORG $+2
$SG71343 DB	's', 00H
	ORG $+2
$SG71344 DB	'S', 00H
	ORG $+2
$SG71345 DB	'p', 00H
	ORG $+2
$SG71346 DB	'w', 00H
	ORG $+2
$SG71347 DB	'l', 00H
	ORG $+2
$SG71348 DB	'r', 00H
	ORG $+2
$SG71349 DB	'h', 00H
	ORG $+2
$SG71350 DB	'D', 00H
	ORG $+2
$SG71351 DB	'z', 00H
	ORG $+2
$SG71352 DB	'Z', 00H
	ORG $+2
$SG71353 DB	'C', 00H
	ORG $+2
$SG71354 DB	'J', 00H
	ORG $+2
$SG71355 DB	'n', 00H
	ORG $+2
$SG71356 DB	'm', 00H
	ORG $+2
$SG71357 DB	'v', 00H
	ORG $+2
$SG71358 DB	'b', 00H
_DATA	ENDS
PUBLIC	_saysyllable
_TEXT	SEGMENT
_phTTS$ = 8
_temp_symbols$ = -1860
_temp_user_durs$ = -1240
_temp_user_f0$ = -620
_saysyllable PROC NEAR

; 189  : {

  00000	81 ec 48 07 00
	00		 sub	 esp, 1864		; 00000748H

; 190  : 
; 191  : 	int i, j, k;   /* MVP int m; was unreferenced varaible */
; 192  : 	int last, old_tot;
; 193  : 	short temp_symbols[NPHON_MAX + SAFETY + 2];
; 194  : 	short temp_user_durs[NPHON_MAX + SAFETY + 2];
; 195  : 	short temp_user_f0[NPHON_MAX + SAFETY + 2];
; 196  : 
; 197  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;
; 198  : 	PDPH_T pDph_t = phTTS->pPHThreadData;

  00006	8b 84 24 4c 07
	00 00		 mov	 eax, DWORD PTR _phTTS$[esp+1860]
  0000d	53		 push	 ebx
  0000e	55		 push	 ebp
  0000f	56		 push	 esi
  00010	8b 68 18	 mov	 ebp, DWORD PTR [eax+24]
  00013	57		 push	 edi

; 199  : 
; 200  : 	/* 
; 201  : 	 *  then, save the clause ...
; 202  : 	 */
; 203  : 
; 204  : 	for (i = 0; i <= pDph_t->nsymbtot; i++)

  00014	0f bf bd 5a 17
	00 00		 movsx	 edi, WORD PTR [ebp+5978]
  0001b	85 ff		 test	 edi, edi
  0001d	89 7c 24 10	 mov	 DWORD PTR -1864+[esp+1880], edi
  00021	7c 57		 jl	 SHORT $L71372
  00023	8b b5 60 17 00
	00		 mov	 esi, DWORD PTR [ebp+5984]
  00029	8d 44 3f 02	 lea	 eax, DWORD PTR [edi+edi+2]
  0002d	8b c8		 mov	 ecx, eax
  0002f	8d bc 24 ec 04
	00 00		 lea	 edi, DWORD PTR _temp_user_f0$[esp+1880]
  00036	d1 e9		 shr	 ecx, 1
  00038	d1 e9		 shr	 ecx, 1
  0003a	f3 a5		 rep movsd
  0003c	8b 95 5c 17 00
	00		 mov	 edx, DWORD PTR [ebp+5980]
  00042	8d 9d fe 14 00
	00		 lea	 ebx, DWORD PTR [ebp+5374]
  00048	13 c9		 adc	 ecx, ecx
  0004a	66 f3 a5	 rep movsw

; 205  : 	{
; 206  : 		temp_symbols[i] = pDph_t->symbols[i];
; 207  : 		temp_user_durs[i] = pDph_t->user_durs[i];

  0004d	8b c8		 mov	 ecx, eax
  0004f	8b f2		 mov	 esi, edx
  00051	d1 e9		 shr	 ecx, 1
  00053	8d bc 24 80 02
	00 00		 lea	 edi, DWORD PTR _temp_user_durs$[esp+1880]
  0005a	d1 e9		 shr	 ecx, 1
  0005c	f3 a5		 rep movsd
  0005e	13 c9		 adc	 ecx, ecx
  00060	66 f3 a5	 rep movsw
  00063	8b c8		 mov	 ecx, eax
  00065	8b f3		 mov	 esi, ebx
  00067	d1 e9		 shr	 ecx, 1
  00069	8d 7c 24 14	 lea	 edi, DWORD PTR _temp_symbols$[esp+1880]
  0006d	d1 e9		 shr	 ecx, 1
  0006f	f3 a5		 rep movsd
  00071	13 c9		 adc	 ecx, ecx
  00073	66 f3 a5	 rep movsw
  00076	8b 7c 24 10	 mov	 edi, DWORD PTR -1864+[esp+1880]
$L71372:

; 208  : 		temp_user_f0[i] = pDph_t->user_f0[i];
; 209  : 	}
; 210  : 
; 211  : 	old_tot = pDph_t->nsymbtot;
; 212  : 	last = 0;

  0007a	33 f6		 xor	 esi, esi

; 213  : 	while (last <= old_tot)

  0007c	85 ff		 test	 edi, edi
  0007e	0f 8c 1a 01 00
	00		 jl	 $L71377
  00084	eb 04		 jmp	 SHORT $L71376
$L71581:
  00086	8b 7c 24 10	 mov	 edi, DWORD PTR -1864+[esp+1880]
$L71376:

; 216  : 		last += 1;

  0008a	46		 inc	 esi

; 217  : 		for (j = 0; (temp_symbols[j + last] != WBOUND) && (j + last < old_tot) && (j < 256); j++)

  0008b	33 c9		 xor	 ecx, ecx
  0008d	66 83 7c 74 14
	6f		 cmp	 WORD PTR _temp_symbols$[esp+esi*2+1880], 111 ; 0000006fH
  00093	c7 85 ac 27 00
	00 6f 00 00 00	 mov	 DWORD PTR [ebp+10156], 111 ; 0000006fH
  0009d	8d 44 74 14	 lea	 eax, DWORD PTR _temp_symbols$[esp+esi*2+1880]
  000a1	74 27		 je	 SHORT $L71380

; 214  : 	{
; 215  : 		pDph_t->phone_struct[0] = WBOUND;

  000a3	8d 95 b0 27 00
	00		 lea	 edx, DWORD PTR [ebp+10160]
$L71378:

; 217  : 		for (j = 0; (temp_symbols[j + last] != WBOUND) && (j + last < old_tot) && (j < 256); j++)

  000a9	8d 1c 31	 lea	 ebx, DWORD PTR [ecx+esi]
  000ac	3b df		 cmp	 ebx, edi
  000ae	7d 1a		 jge	 SHORT $L71380
  000b0	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  000b6	7d 12		 jge	 SHORT $L71380

; 218  : 			pDph_t->phone_struct[j + 1] = temp_symbols[j + last];

  000b8	0f bf 18	 movsx	 ebx, WORD PTR [eax]
  000bb	83 c0 02	 add	 eax, 2
  000be	89 1a		 mov	 DWORD PTR [edx], ebx
  000c0	41		 inc	 ecx
  000c1	83 c2 04	 add	 edx, 4
  000c4	66 83 38 6f	 cmp	 WORD PTR [eax], 111	; 0000006fH
  000c8	75 df		 jne	 SHORT $L71378
$L71380:

; 219  : 		pDph_t->phone_struct[j + 1] = 0;

  000ca	33 db		 xor	 ebx, ebx

; 220  : 		/* 
; 221  : 		 *  syllabify it, and return the length of syllable_struct ...
; 222  : 		 */
; 223  : 		k = ph_syllab (pDph_t, j);

  000cc	51		 push	 ecx
  000cd	55		 push	 ebp
  000ce	89 9c 8d b0 27
	00 00		 mov	 DWORD PTR [ebp+ecx*4+10160], ebx
  000d5	e8 00 00 00 00	 call	 _ph_syllab
  000da	8b f8		 mov	 edi, eax

; 224  : 		pDph_t->syllable_struct[k] = 0;
; 225  : 		/* 
; 226  : 		 *  now, after the comma, start breaking the word up ....
; 227  : 		 */
; 228  : 		syl_clause_init (pDph_t);

  000dc	55		 push	 ebp
  000dd	89 9c bd ac 23
	00 00		 mov	 DWORD PTR [ebp+edi*4+9132], ebx
  000e4	e8 00 00 00 00	 call	 _syl_clause_init
  000e9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 229  : 		while (--k >= 0)

  000ec	4f		 dec	 edi
  000ed	0f 88 87 00 00
	00		 js	 $L71383
  000f3	8d 9c bd ac 23
	00 00		 lea	 ebx, DWORD PTR [ebp+edi*4+9132]
  000fa	47		 inc	 edi
$L71382:

; 230  : 		{
; 231  : 			/* 
; 232  : 			 *  count up the sounded phones ...
; 233  : 			 */
; 234  : 			if (ascky_check[temp_symbols[last]])

  000fb	66 8b 44 74 14	 mov	 ax, WORD PTR _temp_symbols$[esp+esi*2+1880]
  00100	0f bf c8	 movsx	 ecx, ax
  00103	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR _ascky_check[ecx]
  00109	84 d2		 test	 dl, dl
  0010b	74 07		 je	 SHORT $L71384

; 235  : 				pDph_t->nphone++;

  0010d	66 ff 85 a4 23
	00 00		 inc	 WORD PTR [ebp+9124]
$L71384:

; 236  : 			if (pDph_t->syllable_struct[k] == SBOUND)

  00114	83 3b 6c	 cmp	 DWORD PTR [ebx], 108	; 0000006cH
  00117	75 12		 jne	 SHORT $L71385

; 237  : 				speak_syllable (phTTS);

  00119	8b 94 24 5c 07
	00 00		 mov	 edx, DWORD PTR _phTTS$[esp+1876]
  00120	52		 push	 edx
  00121	e8 00 00 00 00	 call	 _speak_syllable
  00126	83 c4 04	 add	 esp, 4

; 238  : 			else

  00129	eb 49		 jmp	 SHORT $L71386
$L71385:

; 239  : 			{
; 240  : 				pDph_t->symbols[pDph_t->nsymbtot] = temp_symbols[last];

  0012b	0f bf 8d 5a 17
	00 00		 movsx	 ecx, WORD PTR [ebp+5978]
  00132	66 89 84 4d fe
	14 00 00	 mov	 WORD PTR [ebp+ecx*2+5374], ax

; 241  : 				pDph_t->user_durs[pDph_t->nsymbtot] = temp_user_durs[last];

  0013a	8b 85 5c 17 00
	00		 mov	 eax, DWORD PTR [ebp+5980]
  00140	0f bf 95 5a 17
	00 00		 movsx	 edx, WORD PTR [ebp+5978]
  00147	66 8b 8c 74 80
	02 00 00	 mov	 cx, WORD PTR _temp_user_durs$[esp+esi*2+1880]
  0014f	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 242  : 				pDph_t->user_f0[pDph_t->nsymbtot++] = temp_user_f0[last++];

  00153	8b 85 60 17 00
	00		 mov	 eax, DWORD PTR [ebp+5984]
  00159	0f bf 95 5a 17
	00 00		 movsx	 edx, WORD PTR [ebp+5978]
  00160	66 8b 8c 74 ec
	04 00 00	 mov	 cx, WORD PTR _temp_user_f0$[esp+esi*2+1880]
  00168	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
  0016c	66 ff 85 5a 17
	00 00		 inc	 WORD PTR [ebp+5978]
  00173	46		 inc	 esi
$L71386:
  00174	83 eb 04	 sub	 ebx, 4
  00177	4f		 dec	 edi
  00178	75 81		 jne	 SHORT $L71382
$L71383:

; 243  : 			}
; 244  : 		}
; 245  : 		/* 
; 246  : 		 *  take care of the last accumulated syllable ...
; 247  : 		 */
; 248  : 		if (pDph_t->nsymbtot > 1)

  0017a	66 83 bd 5a 17
	00 00 01	 cmp	 WORD PTR [ebp+5978], 1
  00182	7e 10		 jle	 SHORT $L71387

; 249  : 			speak_syllable (phTTS);

  00184	8b 94 24 5c 07
	00 00		 mov	 edx, DWORD PTR _phTTS$[esp+1876]
  0018b	52		 push	 edx
  0018c	e8 00 00 00 00	 call	 _speak_syllable
  00191	83 c4 04	 add	 esp, 4
$L71387:
  00194	3b 74 24 10	 cmp	 esi, DWORD PTR -1864+[esp+1880]
  00198	0f 8e e8 fe ff
	ff		 jle	 $L71581
$L71377:
  0019e	5f		 pop	 edi
  0019f	5e		 pop	 esi
  001a0	5d		 pop	 ebp
  001a1	5b		 pop	 ebx

; 250  : 	}
; 251  : }

  001a2	81 c4 48 07 00
	00		 add	 esp, 1864		; 00000748H
  001a8	c3		 ret	 0
_saysyllable ENDP
_TEXT	ENDS
PUBLIC	_syl_find_vowel
_TEXT	SEGMENT
_ph$ = 8
_off$ = -4
_syl_find_vowel PROC NEAR

; 99   : {

  001b0	51		 push	 ecx

; 106  : 	for (i = 0; ph[i] != WBOUND; i--)

  001b1	8b 44 24 08	 mov	 eax, DWORD PTR _ph$[esp]
  001b5	53		 push	 ebx
  001b6	55		 push	 ebp
  001b7	33 d2		 xor	 edx, edx
  001b9	66 8b 08	 mov	 cx, WORD PTR [eax]
  001bc	56		 push	 esi
  001bd	66 83 f9 6f	 cmp	 cx, 111			; 0000006fH
  001c1	57		 push	 edi
  001c2	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _off$[esp+20], 1
  001ca	74 58		 je	 SHORT $L71398

; 100  : #ifdef SPANISH
; 101  : 	int	vc, hit = 0;
; 102  : #endif
; 103  :         int i, j, k=0, l, off;
; 104  : 
; 105  : 	off = 1;

  001cc	8b e8		 mov	 ebp, eax
$L71396:

; 107  : 	{
; 108  : 		if (ascky_check[ph[i]])

  001ce	0f bf c9	 movsx	 ecx, cx
  001d1	8a 99 00 00 00
	00		 mov	 bl, BYTE PTR _ascky_check[ecx]
  001d7	84 db		 test	 bl, bl
  001d9	74 32		 je	 SHORT $L71402

; 109  : 		{
; 110  : #ifdef ENGLISH_US
; 111  : 			for (j = 0; syl_vowels[j] != 0; j++)

  001db	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _syl_vowels
  001e1	84 c9		 test	 cl, cl
  001e3	74 28		 je	 SHORT $L71402

; 112  : 			{
; 113  : 				if (ascky_check[ph[i]] == syl_vowels[j])

  001e5	66 8b 7d 00	 mov	 di, WORD PTR [ebp]
  001e9	0f bf f7	 movsx	 esi, di
  001ec	8a 9e 00 00 00
	00		 mov	 bl, BYTE PTR _ascky_check[esi]
  001f2	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_syl_vowels
$L71400:
  001f7	3a d9		 cmp	 bl, cl
  001f9	74 32		 je	 SHORT $L71588

; 120  : 						return (off);
; 121  : 					return (off);
; 122  : 				}
; 123  : 				if (ph[i] == YU)

  001fb	66 83 ff 10	 cmp	 di, 16			; 00000010H
  001ff	0f 84 b2 00 00
	00		 je	 $L71589
  00205	8a 4e 01	 mov	 cl, BYTE PTR [esi+1]
  00208	46		 inc	 esi
  00209	84 c9		 test	 cl, cl
  0020b	75 ea		 jne	 SHORT $L71400
$L71402:

; 127  : 						return (off);
; 128  : 					else
; 129  : 						return (0);
; 130  : 				}
; 131  : 			}
; 132  : #endif
; 133  : #ifdef ENGLISH_UK
; 134  : 			for (j = 0; syl_vowels[j] != 0; j++)
; 135  : 			{
; 136  : 				if (ascky_check[ph[i]] == syl_vowels[j])
; 137  : 				{
; 138  : 					for (k = 1; ascky_check[ph[i - k]] == 0 && ph[i - k] != WBOUND; k++);
; 139  : 					if (ph[i - k] != YU)
; 140  : 						return (off);
; 141  : 					for (l = k + 1; ascky_check[ph[i - l]] == 0 && ph[i - l] != WBOUND; l++);
; 142  : 					if (ph[i - l] != WBOUND)
; 143  : 						return (off);
; 144  : 					return (off);
; 145  : 				}
; 146  : 				if (ph[i] == YU)
; 147  : 				{
; 148  : 					for (k += 1; ascky_check[ph[i - k]] == 0 && ph[i - k] != WBOUND; k++);
; 149  : 					if (ph[i - k] != WBOUND)
; 150  : 						return (off);
; 151  : 					else
; 152  : 						return (0);
; 153  : 				}
; 154  : 			}
; 155  : #endif
; 156  : #ifdef SPANISH
; 157  : 			for (j = 0; syl_vowels[j] != 0; j++)
; 158  : 			{
; 159  : 				if (ascky_check[ph[i]] == syl_vowels[j])
; 160  : 				{
; 161  : 					/* 
; 162  : 					 * any vowel before i and u or Y and W become one.
; 163  : 					 * also if this or any vowel preceed by iuYW it also 
; 164  : 					 * becomes one vowel as with ia ana iai 
; 165  : 					 */
; 166  : 					vc = i;
; 167  : 					if (ph[i] == 3 || (ph[i] >= 5 && ph[i] <= 7))
; 168  : 					{
; 169  : 						if (ascky_check[ph[i - 1]] == syl_vowels[j])
; 170  : 							hit = 1;
; 171  : 						vc--;
; 172  : 					}
; 173  : 					vc--;
; 174  : 					while (ph[vc] >= BLOCK_RULES && ph[vc] < SBOUND)
; 175  : 					{
; 176  : 						hit = 1;
; 177  : 						vc--;
; 178  : 					}
; 179  : 					/* if preceeded by 'i' || 'u' ||'y' || 'w' */
; 180  : 					if (ph[vc] == 3 || (ph[vc] >= 5 && ph[vc] <= 7))
; 181  : 					{
; 182  : 						hit = 1;
; 183  : 					}
; 184  : 					if (hit)
; 185  : 						off += i - vc;
; 186  : 					return (off);
; 187  : 				}
; 188  : 			}
; 189  : #endif
; 190  : 		}
; 191  : 		off += 1;

  0020d	8b 4c 24 10	 mov	 ecx, DWORD PTR _off$[esp+20]
  00211	83 ed 02	 sub	 ebp, 2
  00214	41		 inc	 ecx
  00215	4a		 dec	 edx
  00216	89 4c 24 10	 mov	 DWORD PTR _off$[esp+20], ecx
  0021a	66 8b 4d 00	 mov	 cx, WORD PTR [ebp]
  0021e	66 83 f9 6f	 cmp	 cx, 111			; 0000006fH
  00222	75 aa		 jne	 SHORT $L71396
$L71398:
  00224	5f		 pop	 edi
  00225	5e		 pop	 esi
  00226	5d		 pop	 ebp

; 192  : 	}
; 193  : 	return (0);

  00227	66 33 c0	 xor	 ax, ax
  0022a	5b		 pop	 ebx

; 194  : }

  0022b	59		 pop	 ecx
  0022c	c3		 ret	 0
$L71588:

; 114  : 				{
; 115  : 					for (k = 1; ascky_check[ph[i - k]] == 0 && ph[i - k] != WBOUND; k++);

  0022d	66 8b 4c 50 fe	 mov	 cx, WORD PTR [eax+edx*2-2]
  00232	bf 01 00 00 00	 mov	 edi, 1
  00237	0f bf f1	 movsx	 esi, cx
  0023a	8a 9e 00 00 00
	00		 mov	 bl, BYTE PTR _ascky_check[esi]
  00240	84 db		 test	 bl, bl
  00242	75 1e		 jne	 SHORT $L71406
  00244	8d 74 50 fe	 lea	 esi, DWORD PTR [eax+edx*2-2]
$L71404:
  00248	66 83 f9 6f	 cmp	 cx, 111			; 0000006fH
  0024c	74 14		 je	 SHORT $L71406
  0024e	66 8b 4e fe	 mov	 cx, WORD PTR [esi-2]
  00252	83 ee 02	 sub	 esi, 2
  00255	0f bf d9	 movsx	 ebx, cx
  00258	47		 inc	 edi
  00259	80 bb 00 00 00
	00 00		 cmp	 BYTE PTR _ascky_check[ebx], 0
  00260	74 e6		 je	 SHORT $L71404
$L71406:

; 116  : 					if (ph[i - k] != YU)

  00262	8b ca		 mov	 ecx, edx
  00264	2b cf		 sub	 ecx, edi
  00266	66 83 3c 48 10	 cmp	 WORD PTR [eax+ecx*2], 16 ; 00000010H
  0026b	74 0b		 je	 SHORT $L71407

; 117  : 						return (off);

  0026d	66 8b 44 24 10	 mov	 ax, WORD PTR _off$[esp+20]
  00272	5f		 pop	 edi
  00273	5e		 pop	 esi
  00274	5d		 pop	 ebp
  00275	5b		 pop	 ebx

; 194  : }

  00276	59		 pop	 ecx
  00277	c3		 ret	 0
$L71407:

; 118  : 					for (l = k + 1; ascky_check[ph[i - l]] == 0 && ph[i - l] != WBOUND; l++);

  00278	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  0027b	2b d6		 sub	 edx, esi
  0027d	66 8b 0c 50	 mov	 cx, WORD PTR [eax+edx*2]
  00281	8d 14 50	 lea	 edx, DWORD PTR [eax+edx*2]
  00284	0f bf c1	 movsx	 eax, cx
  00287	8a 98 00 00 00
	00		 mov	 bl, BYTE PTR _ascky_check[eax]
  0028d	84 db		 test	 bl, bl
  0028f	75 1b		 jne	 SHORT $L71410
$L71408:
  00291	66 83 f9 6f	 cmp	 cx, 111			; 0000006fH
  00295	74 15		 je	 SHORT $L71410
  00297	66 8b 4a fe	 mov	 cx, WORD PTR [edx-2]
  0029b	83 ea 02	 sub	 edx, 2
  0029e	0f bf c1	 movsx	 eax, cx
  002a1	46		 inc	 esi
  002a2	8a 98 00 00 00
	00		 mov	 bl, BYTE PTR _ascky_check[eax]
  002a8	84 db		 test	 bl, bl
  002aa	74 e5		 je	 SHORT $L71408
$L71410:

; 119  : 					if (ph[i - l] != WBOUND)

  002ac	66 8b 44 24 10	 mov	 ax, WORD PTR _off$[esp+20]
  002b1	5f		 pop	 edi
  002b2	5e		 pop	 esi
  002b3	5d		 pop	 ebp
  002b4	5b		 pop	 ebx

; 194  : }

  002b5	59		 pop	 ecx
  002b6	c3		 ret	 0
$L71589:

; 124  : 				{
; 125  : 					for (k += 1; ascky_check[ph[i - k]] == 0 && ph[i - k] != WBOUND; k++);

  002b7	66 8b 4c 50 fe	 mov	 cx, WORD PTR [eax+edx*2-2]
  002bc	bf 01 00 00 00	 mov	 edi, 1
  002c1	0f bf f1	 movsx	 esi, cx
  002c4	8a 9e 00 00 00
	00		 mov	 bl, BYTE PTR _ascky_check[esi]
  002ca	84 db		 test	 bl, bl
  002cc	75 1e		 jne	 SHORT $L71415
  002ce	8d 74 50 fe	 lea	 esi, DWORD PTR [eax+edx*2-2]
$L71413:
  002d2	66 83 f9 6f	 cmp	 cx, 111			; 0000006fH
  002d6	74 14		 je	 SHORT $L71415
  002d8	66 8b 4e fe	 mov	 cx, WORD PTR [esi-2]
  002dc	83 ee 02	 sub	 esi, 2
  002df	0f bf d9	 movsx	 ebx, cx
  002e2	47		 inc	 edi
  002e3	80 bb 00 00 00
	00 00		 cmp	 BYTE PTR _ascky_check[ebx], 0
  002ea	74 e6		 je	 SHORT $L71413
$L71415:

; 126  : 					if (ph[i - k] != WBOUND)

  002ec	2b d7		 sub	 edx, edi
  002ee	8b 4c 24 10	 mov	 ecx, DWORD PTR _off$[esp+20]
  002f2	5f		 pop	 edi
  002f3	5e		 pop	 esi
  002f4	66 8b 04 50	 mov	 ax, WORD PTR [eax+edx*2]
  002f8	5d		 pop	 ebp
  002f9	66 2d 6f 00	 sub	 ax, 111			; 0000006fH
  002fd	5b		 pop	 ebx
  002fe	66 f7 d8	 neg	 ax
  00301	1b c0		 sbb	 eax, eax
  00303	23 c1		 and	 eax, ecx

; 194  : }

  00305	59		 pop	 ecx
  00306	c3		 ret	 0
_syl_find_vowel ENDP
_TEXT	ENDS
PUBLIC	_syl_find_cons
_TEXT	SEGMENT
_ph$ = 8
_syl_find_cons PROC NEAR

; 209  : {

  00310	53		 push	 ebx
  00311	55		 push	 ebp

; 210  : 	short                   *tp;
; 211  : 	int                     i= 0 , j = 0, len = 0;
; 212  : 
; 213  : #ifdef ENGLISH_US
; 214  : 	tp = ph;
; 215  : 	if (*tp-- == 26)

  00312	8b 6c 24 0c	 mov	 ebp, DWORD PTR _ph$[esp+4]
  00316	56		 push	 esi
  00317	57		 push	 edi
  00318	66 83 7d 00 1a	 cmp	 WORD PTR [ebp], 26	; 0000001aH
  0031d	75 24		 jne	 SHORT $L71428

; 216  : 	{
; 217  : 		for (j = 0; syl_vowels[j] != 0; j++)

  0031f	a0 00 00 00 00	 mov	 al, BYTE PTR _syl_vowels
  00324	84 c0		 test	 al, al
  00326	74 1b		 je	 SHORT $L71428

; 218  : 		{
; 219  : 			if (ascky_check[*tp] == syl_vowels[j])

  00328	0f bf 4d fe	 movsx	 ecx, WORD PTR [ebp-2]
  0032c	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR _ascky_check[ecx]
  00332	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_syl_vowels
$L71426:
  00337	3a d0		 cmp	 dl, al
  00339	74 5a		 je	 SHORT $L71602
  0033b	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  0033e	41		 inc	 ecx
  0033f	84 c0		 test	 al, al
  00341	75 f4		 jne	 SHORT $L71426
$L71428:

; 220  : 			{
; 221  : 				return (0);
; 222  : 			}
; 223  : 		}
; 224  : 	}
; 225  : #endif
; 226  : #ifdef ENGLISH_UK
; 227  : 	tp = ph;
; 228  : 	if (*tp-- == 26)
; 229  : 	{
; 230  : 		for (j = 0; syl_vowels[j] != 0; j++)
; 231  : 		{
; 232  : 			if (ascky_check[*tp] == syl_vowels[j])
; 233  : 			{
; 234  : 				return (0);
; 235  : 			}
; 236  : 		}
; 237  : 	}
; 238  : #endif
; 239  : 	for (j = 0; syl_cons[j]; j++)

  00343	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _syl_cons
  00349	85 f6		 test	 esi, esi
  0034b	74 48		 je	 SHORT $L71602
  0034d	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_syl_cons
$L71430:

; 240  : 	{
; 241  : 		for (i = 0; syl_cons[j][i]; i++);

  00352	8a 06		 mov	 al, BYTE PTR [esi]
  00354	33 c9		 xor	 ecx, ecx
  00356	84 c0		 test	 al, al
  00358	74 0b		 je	 SHORT $L71435
  0035a	8b 37		 mov	 esi, DWORD PTR [edi]
$L71433:
  0035c	8a 44 0e 01	 mov	 al, BYTE PTR [esi+ecx+1]
  00360	41		 inc	 ecx
  00361	84 c0		 test	 al, al
  00363	75 f7		 jne	 SHORT $L71433
$L71435:

; 242  : /* printf(" %s ons %d \n",syl_cons[j],len); */
; 243  : 		len = i;

  00365	8b c1		 mov	 eax, ecx

; 244  : 		tp = ph;

  00367	8b d5		 mov	 edx, ebp
$L71437:

; 246  : 		{
; 247  : 			if (ascky_check[*tp] == 0)

  00369	0f bf 1a	 movsx	 ebx, WORD PTR [edx]
  0036c	8a 9b 00 00 00
	00		 mov	 bl, BYTE PTR _ascky_check[ebx]
  00372	84 db		 test	 bl, bl
  00374	75 06		 jne	 SHORT $L71439

; 248  : 			{
; 249  : #ifdef ENGLISH_US
; 250  : 				tp++;

  00376	83 c2 02	 add	 edx, 2

; 251  : #endif      
; 252  : #ifdef ENGLISH_UK
; 253  : 				tp++;
; 254  : #endif      
; 255  : #ifdef SPANISH
; 256  : 				tp--;
; 257  : #endif
; 258  : 				len += 1;

  00379	40		 inc	 eax

; 259  : 
; 260  : 			}
; 261  : 			else

  0037a	eb 09		 jmp	 SHORT $L71441
$L71439:

; 262  : 			{
; 263  : /* 
; 264  :  * printf("asc = %c \n",syl_cons[j][i-1]);
; 265  :  * 
; 266  :  * printf("look at   %d %c \n",ascky_check[*tp],ascky_check[*tp]); 
; 267  :  */
; 268  : 				if (syl_cons[j][--i] != ascky_check[*tp--])

  0037c	49		 dec	 ecx
  0037d	83 ea 02	 sub	 edx, 2
  00380	38 1c 0e	 cmp	 BYTE PTR [esi+ecx], bl
  00383	75 06		 jne	 SHORT $L71431
$L71441:

; 269  : 					break;
; 270  : 			}
; 271  : 			if (i == 0)

  00385	85 c9		 test	 ecx, ecx
  00387	74 0f		 je	 SHORT $L71420

; 245  : 		while (true)

  00389	eb de		 jmp	 SHORT $L71437
$L71431:

; 220  : 			{
; 221  : 				return (0);
; 222  : 			}
; 223  : 		}
; 224  : 	}
; 225  : #endif
; 226  : #ifdef ENGLISH_UK
; 227  : 	tp = ph;
; 228  : 	if (*tp-- == 26)
; 229  : 	{
; 230  : 		for (j = 0; syl_vowels[j] != 0; j++)
; 231  : 		{
; 232  : 			if (ascky_check[*tp] == syl_vowels[j])
; 233  : 			{
; 234  : 				return (0);
; 235  : 			}
; 236  : 		}
; 237  : 	}
; 238  : #endif
; 239  : 	for (j = 0; syl_cons[j]; j++)

  0038b	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0038e	83 c7 04	 add	 edi, 4
  00391	85 f6		 test	 esi, esi
  00393	75 bd		 jne	 SHORT $L71430
$L71602:

; 272  : 				return (len);
; 273  : 		}
; 274  : 	}
; 275  : 	return (0);

  00395	66 33 c0	 xor	 ax, ax
$L71420:
  00398	5f		 pop	 edi
  00399	5e		 pop	 esi
  0039a	5d		 pop	 ebp
  0039b	5b		 pop	 ebx

; 276  : }

  0039c	c3		 ret	 0
_syl_find_cons ENDP
_TEXT	ENDS
PUBLIC	_logsyllable
EXTRN	_TextToSpeechErrorHandler:NEAR
EXTRN	__imp__fprintf:NEAR
EXTRN	__imp__EnterCriticalSection@4:NEAR
EXTRN	__imp__LeaveCriticalSection@4:NEAR
_DATA	SEGMENT
	ORG $+2
$SG71483 DB	'[:syll ', 00H
$SG71486 DB	'[:syll ', 00H
$SG71491 DB	'%c', 00H
	ORG $+1
$SG71494 DB	'%c', 00H
	ORG $+1
$SG71496 DB	' --> ', 00H
	ORG $+2
$SG71499 DB	' --> ', 00H
	ORG $+2
$SG71504 DB	'%c', 00H
	ORG $+1
$SG71507 DB	'%c', 00H
	ORG $+1
$SG71509 DB	']', 0aH, 00H
	ORG $+1
$SG71512 DB	']', 0aH, 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_i$ = -12
_k$ = -4
_pDph_t$ = -8
_logsyllable PROC NEAR

; 358  : {

  003a0	83 ec 0c	 sub	 esp, 12			; 0000000cH
  003a3	53		 push	 ebx
  003a4	56		 push	 esi
  003a5	57		 push	 edi

; 359  : 	int                     i, j, k;
; 360  : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  003a6	8b 7c 24 1c	 mov	 edi, DWORD PTR _phTTS$[esp+20]

; 361  : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 362  : 
; 363  : #ifndef MSDOS
; 364  : /* 
; 365  :  * LPTTS_HANDLE_T phTTS;
; 366  :  * 
; 367  :  * phTTS = TextToSpeechGetHandle(); 
; 368  :  */
; 369  : #endif
; 370  : 
; 371  : #ifdef WIN32
; 372  : 	EnterCriticalSection (phTTS->pcsLogFile);

  003aa	8b 87 c4 00 00
	00		 mov	 eax, DWORD PTR [edi+196]
  003b0	8b 5f 18	 mov	 ebx, DWORD PTR [edi+24]
  003b3	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  003b6	50		 push	 eax
  003b7	89 5c 24 14	 mov	 DWORD PTR _pDph_t$[esp+28], ebx
  003bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 373  : #endif
; 374  : #if defined (__osf__) || defined (__linux__)
; 375  : 	/* GL 04/21/1997  change this as the latest OSF code */
; 376  : 	/*ToggleLogfileMutex (MUTEX_RESERVE);*/
; 377  : 	OP_LockMutex( phTTS->pcsLogFile );
; 378  : #endif
; 379  : 
; 380  : 	for (i = 1; i < pDph_t->nsymbtot; i++)

  003c1	b8 01 00 00 00	 mov	 eax, 1
  003c6	66 39 83 5a 17
	00 00		 cmp	 WORD PTR [ebx+5978], ax
  003cd	89 44 24 0c	 mov	 DWORD PTR _i$[esp+24], eax
  003d1	0f 8e 89 02 00
	00		 jle	 $L71478
  003d7	55		 push	 ebp

; 415  : 			}
; 416  : 		}
; 417  : #endif
; 418  : 
; 419  : #ifdef MSDOS
; 420  : 
; 421  : 		/* 
; 422  : 		 * the table pKsd_t->ascky should be change 
; 423  : 		 * when a [:lang ] commad is engountered 
; 424  : 		 */
; 425  : 		for (j = 0; pDph_t->phone_struct[j]; j++)
; 426  : 		{
; 427  : #ifndef MSDOS
; 428  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 429  : 			fprintf(pKsd_t->dbglog, pKsd_t->ascky[pDph_t->phone_struct[j]]);
; 430  : #endif // #ifndef MSDOS
; 431  : 		printf ("%c", pKsd_t->ascky[pDph_t->phone_struct[j]]);	
; 432  : 		}
; 433  : 
; 434  : #ifndef MSDOS
; 435  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 436  : 			fprintf(pKsd_t->dbglog," --> ");
; 437  : #endif // #ifndef MSDOS
; 438  : 		printf (" --> ");
; 439  : 
; 440  : 		while (--k)
; 441  : 		{
; 442  : #ifndef MSDOS
; 443  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 444  : 			fprintf(pKsd_t->dbglog,"%c", pKsd_t->ascky[pDph_t->syllable_struct[k]]);
; 445  : #endif // #ifndef MSDOS
; 446  : 		printf ("%c", pKsd_t->ascky[pDph_t->syllable_struct[k]]);
; 447  : 		}
; 448  : #ifndef MSDOS
; 449  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 450  : 			fprintf(pKsd_t->dbglog,"%c","]\n");
; 451  : #endif // #ifndef MSDOS
; 452  : 		printf ("]\n");
; 453  : 		SIGNAL_PRINT;
; 454  : #else //#ifdef MSDOS
; 455  : 
; 456  : 		for (j = 0; pDph_t->phone_struct[j]; j++)

  003d8	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__fprintf
$L71476:
  003de	8b 4c 24 10	 mov	 ecx, DWORD PTR _i$[esp+28]
  003e2	c7 83 ac 27 00
	00 6f 00 00 00	 mov	 DWORD PTR [ebx+10156], 111 ; 0000006fH
  003ec	33 c0		 xor	 eax, eax
  003ee	66 83 bc 4b fe
	14 00 00 6f	 cmp	 WORD PTR [ebx+ecx*2+5374], 111 ; 0000006fH
  003f7	8d 8c 4b fe 14
	00 00		 lea	 ecx, DWORD PTR [ebx+ecx*2+5374]
  003fe	74 3e		 je	 SHORT $L71481

; 381  : 	{
; 382  : 		/* 
; 383  : 		 *  first, isolate phonemic words ...
; 384  : 		 */
; 385  : 		pDph_t->phone_struct[0] = WBOUND;

  00400	8d 93 b0 27 00
	00		 lea	 edx, DWORD PTR [ebx+10160]
  00406	eb 04		 jmp	 SHORT $L71479
$L71617:
  00408	8b 5c 24 14	 mov	 ebx, DWORD PTR _pDph_t$[esp+28]
$L71479:

; 386  : 		for (j = 0; pDph_t->symbols[i + j] != WBOUND && i + j < pDph_t->nsymbtot && j < 256; j++)

  0040c	8b 7c 24 10	 mov	 edi, DWORD PTR _i$[esp+28]
  00410	0f bf 9b 5a 17
	00 00		 movsx	 ebx, WORD PTR [ebx+5978]
  00417	03 f8		 add	 edi, eax
  00419	3b fb		 cmp	 edi, ebx
  0041b	7d 19		 jge	 SHORT $L71618
  0041d	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00422	7d 12		 jge	 SHORT $L71618

; 387  : 		{
; 388  : 			pDph_t->phone_struct[j + 1] = pDph_t->symbols[i + j];

  00424	0f bf 39	 movsx	 edi, WORD PTR [ecx]
  00427	83 c1 02	 add	 ecx, 2
  0042a	89 3a		 mov	 DWORD PTR [edx], edi
  0042c	40		 inc	 eax
  0042d	83 c2 04	 add	 edx, 4
  00430	66 83 39 6f	 cmp	 WORD PTR [ecx], 111	; 0000006fH
  00434	75 d2		 jne	 SHORT $L71617
$L71618:

; 386  : 		for (j = 0; pDph_t->symbols[i + j] != WBOUND && i + j < pDph_t->nsymbtot && j < 256; j++)

  00436	8b 5c 24 14	 mov	 ebx, DWORD PTR _pDph_t$[esp+28]
  0043a	8b 7c 24 20	 mov	 edi, DWORD PTR _phTTS$[esp+24]
$L71481:

; 389  : 		}
; 390  : 		j++;    
; 391  : 		pDph_t->phone_struct[j]=0;
; 392  : 		pDph_t->phone_struct[j+1]=0;
; 393  : 		i += j - 1;

  0043e	8b 54 24 10	 mov	 edx, DWORD PTR _i$[esp+28]
  00442	40		 inc	 eax
  00443	33 c9		 xor	 ecx, ecx

; 394  : 		k = ph_syllab (pDph_t, j);

  00445	50		 push	 eax
  00446	89 8c 83 ac 27
	00 00		 mov	 DWORD PTR [ebx+eax*4+10156], ecx
  0044d	89 8c 83 b0 27
	00 00		 mov	 DWORD PTR [ebx+eax*4+10160], ecx
  00454	8d 4c 02 ff	 lea	 ecx, DWORD PTR [edx+eax-1]
  00458	53		 push	 ebx
  00459	89 4c 24 18	 mov	 DWORD PTR _i$[esp+36], ecx
  0045d	e8 00 00 00 00	 call	 _ph_syllab
  00462	89 44 24 20	 mov	 DWORD PTR _k$[esp+36], eax

; 395  : #ifdef MSDOS
; 396  : 		WAIT_PRINT;
; 397  : 		printf ("[:syll ");
; 398  : #else
; 399  : #ifdef PRINTFDEBUG
; 400  : 		printf ("[:syll ");
; 401  : #endif
; 402  : 		
; 403  : #ifndef MSDOS
; 404  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/

  00466	8b 86 7c 04 00
	00		 mov	 eax, DWORD PTR [esi+1148]
  0046c	83 c4 08	 add	 esp, 8
  0046f	85 c0		 test	 eax, eax
  00471	74 0b		 je	 SHORT $L71482

; 405  : 			fprintf(pKsd_t->dbglog,"[:syll ");

  00473	68 00 00 00 00	 push	 OFFSET FLAT:$SG71483
  00478	50		 push	 eax
  00479	ff d5		 call	 ebp
  0047b	83 c4 08	 add	 esp, 8
$L71482:

; 406  : #endif
; 407  : 		
; 408  : 		if (pKsd_t->logflag & LOG_SYLLABLES)

  0047e	f6 86 04 02 00
	00 10		 test	 BYTE PTR [esi+516], 16	; 00000010H
  00485	74 22		 je	 SHORT $L71485

; 409  : 		{
; 410  : 			if (fprintf (phTTS->pLogFile, "[:syll ") < 0)

  00487	8b 97 98 00 00
	00		 mov	 edx, DWORD PTR [edi+152]
  0048d	68 00 00 00 00	 push	 OFFSET FLAT:$SG71486
  00492	52		 push	 edx
  00493	ff d5		 call	 ebp
  00495	83 c4 08	 add	 esp, 8
  00498	85 c0		 test	 eax, eax
  0049a	7d 0d		 jge	 SHORT $L71485

; 411  : 			{
; 412  : 				TextToSpeechErrorHandler (phTTS,
; 413  : 										  ERROR_WRITING_FILE,
; 414  : 										  0L);

  0049c	6a 00		 push	 0
  0049e	6a 05		 push	 5
  004a0	57		 push	 edi
  004a1	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  004a6	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71485:

; 415  : 			}
; 416  : 		}
; 417  : #endif
; 418  : 
; 419  : #ifdef MSDOS
; 420  : 
; 421  : 		/* 
; 422  : 		 * the table pKsd_t->ascky should be change 
; 423  : 		 * when a [:lang ] commad is engountered 
; 424  : 		 */
; 425  : 		for (j = 0; pDph_t->phone_struct[j]; j++)
; 426  : 		{
; 427  : #ifndef MSDOS
; 428  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 429  : 			fprintf(pKsd_t->dbglog, pKsd_t->ascky[pDph_t->phone_struct[j]]);
; 430  : #endif // #ifndef MSDOS
; 431  : 		printf ("%c", pKsd_t->ascky[pDph_t->phone_struct[j]]);	
; 432  : 		}
; 433  : 
; 434  : #ifndef MSDOS
; 435  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 436  : 			fprintf(pKsd_t->dbglog," --> ");
; 437  : #endif // #ifndef MSDOS
; 438  : 		printf (" --> ");
; 439  : 
; 440  : 		while (--k)
; 441  : 		{
; 442  : #ifndef MSDOS
; 443  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 444  : 			fprintf(pKsd_t->dbglog,"%c", pKsd_t->ascky[pDph_t->syllable_struct[k]]);
; 445  : #endif // #ifndef MSDOS
; 446  : 		printf ("%c", pKsd_t->ascky[pDph_t->syllable_struct[k]]);
; 447  : 		}
; 448  : #ifndef MSDOS
; 449  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 450  : 			fprintf(pKsd_t->dbglog,"%c","]\n");
; 451  : #endif // #ifndef MSDOS
; 452  : 		printf ("]\n");
; 453  : 		SIGNAL_PRINT;
; 454  : #else //#ifdef MSDOS
; 455  : 
; 456  : 		for (j = 0; pDph_t->phone_struct[j]; j++)

  004a9	8b 83 ac 27 00
	00		 mov	 eax, DWORD PTR [ebx+10156]
  004af	85 c0		 test	 eax, eax
  004b1	74 7c		 je	 SHORT $L71489
  004b3	8d bb ac 27 00
	00		 lea	 edi, DWORD PTR [ebx+10156]
$L71487:

; 457  : 		{
; 458  : #ifdef PRINTFDEBUG
; 459  : 			printf ("%c", pKsd_t->ascky[pDph_t->phone_struct[j]]);
; 460  : #endif
; 461  : #ifndef MSDOS
; 462  : 			if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/

  004b9	8b 86 7c 04 00
	00		 mov	 eax, DWORD PTR [esi+1148]
  004bf	85 c0		 test	 eax, eax
  004c1	74 1d		 je	 SHORT $L71490

; 463  : 				fprintf(pKsd_t->dbglog,"%c", pKsd_t->ascky[pDph_t->phone_struct[j]]);

  004c3	8b 8e 58 04 00
	00		 mov	 ecx, DWORD PTR [esi+1112]
  004c9	8b 17		 mov	 edx, DWORD PTR [edi]
  004cb	33 db		 xor	 ebx, ebx
  004cd	8a 1c 11	 mov	 bl, BYTE PTR [ecx+edx]
  004d0	53		 push	 ebx
  004d1	68 00 00 00 00	 push	 OFFSET FLAT:$SG71491
  004d6	50		 push	 eax
  004d7	ff d5		 call	 ebp
  004d9	8b 5c 24 20	 mov	 ebx, DWORD PTR _pDph_t$[esp+40]
  004dd	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71490:

; 464  : #endif // #ifndef MSDOS
; 465  : 
; 466  : 			if (pKsd_t->logflag & LOG_SYLLABLES)

  004e0	f6 86 04 02 00
	00 10		 test	 BYTE PTR [esi+516], 16	; 00000010H
  004e7	74 38		 je	 SHORT $L71488

; 467  : 			{
; 468  : 
; 469  : 
; 470  : 				if (fprintf (phTTS->pLogFile,
; 471  : 							 "%c", pKsd_t->ascky[pDph_t->phone_struct[j]]) < 0)

  004e9	8b 86 58 04 00
	00		 mov	 eax, DWORD PTR [esi+1112]
  004ef	8b 0f		 mov	 ecx, DWORD PTR [edi]
  004f1	33 d2		 xor	 edx, edx
  004f3	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  004f6	8b 44 24 20	 mov	 eax, DWORD PTR _phTTS$[esp+24]
  004fa	52		 push	 edx
  004fb	68 00 00 00 00	 push	 OFFSET FLAT:$SG71494
  00500	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00506	51		 push	 ecx
  00507	ff d5		 call	 ebp
  00509	83 c4 0c	 add	 esp, 12			; 0000000cH
  0050c	85 c0		 test	 eax, eax
  0050e	7d 11		 jge	 SHORT $L71488

; 472  : 				{
; 473  : 					TextToSpeechErrorHandler (phTTS,
; 474  : 											  ERROR_WRITING_FILE,
; 475  : 											  0L);

  00510	8b 54 24 20	 mov	 edx, DWORD PTR _phTTS$[esp+24]
  00514	6a 00		 push	 0
  00516	6a 05		 push	 5
  00518	52		 push	 edx
  00519	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  0051e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71488:
  00521	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00524	83 c7 04	 add	 edi, 4
  00527	85 c0		 test	 eax, eax
  00529	75 8e		 jne	 SHORT $L71487

; 415  : 			}
; 416  : 		}
; 417  : #endif
; 418  : 
; 419  : #ifdef MSDOS
; 420  : 
; 421  : 		/* 
; 422  : 		 * the table pKsd_t->ascky should be change 
; 423  : 		 * when a [:lang ] commad is engountered 
; 424  : 		 */
; 425  : 		for (j = 0; pDph_t->phone_struct[j]; j++)
; 426  : 		{
; 427  : #ifndef MSDOS
; 428  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 429  : 			fprintf(pKsd_t->dbglog, pKsd_t->ascky[pDph_t->phone_struct[j]]);
; 430  : #endif // #ifndef MSDOS
; 431  : 		printf ("%c", pKsd_t->ascky[pDph_t->phone_struct[j]]);	
; 432  : 		}
; 433  : 
; 434  : #ifndef MSDOS
; 435  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 436  : 			fprintf(pKsd_t->dbglog," --> ");
; 437  : #endif // #ifndef MSDOS
; 438  : 		printf (" --> ");
; 439  : 
; 440  : 		while (--k)
; 441  : 		{
; 442  : #ifndef MSDOS
; 443  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 444  : 			fprintf(pKsd_t->dbglog,"%c", pKsd_t->ascky[pDph_t->syllable_struct[k]]);
; 445  : #endif // #ifndef MSDOS
; 446  : 		printf ("%c", pKsd_t->ascky[pDph_t->syllable_struct[k]]);
; 447  : 		}
; 448  : #ifndef MSDOS
; 449  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/
; 450  : 			fprintf(pKsd_t->dbglog,"%c","]\n");
; 451  : #endif // #ifndef MSDOS
; 452  : 		printf ("]\n");
; 453  : 		SIGNAL_PRINT;
; 454  : #else //#ifdef MSDOS
; 455  : 
; 456  : 		for (j = 0; pDph_t->phone_struct[j]; j++)

  0052b	8b 7c 24 20	 mov	 edi, DWORD PTR _phTTS$[esp+24]
$L71489:

; 476  : 				}
; 477  : 			}
; 478  : 		}
; 479  : 
; 480  : #ifdef PRINTFDEBUG
; 481  : 		printf (" --> ");
; 482  : #endif
; 483  : #ifndef MSDOS
; 484  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/

  0052f	8b 86 7c 04 00
	00		 mov	 eax, DWORD PTR [esi+1148]
  00535	85 c0		 test	 eax, eax
  00537	74 0b		 je	 SHORT $L71495

; 485  : 				fprintf(pKsd_t->dbglog, " --> ");

  00539	68 00 00 00 00	 push	 OFFSET FLAT:$SG71496
  0053e	50		 push	 eax
  0053f	ff d5		 call	 ebp
  00541	83 c4 08	 add	 esp, 8
$L71495:

; 486  : #endif// #ifndef MSDOS
; 487  : 		if (pKsd_t->logflag & LOG_SYLLABLES)

  00544	f6 86 04 02 00
	00 10		 test	 BYTE PTR [esi+516], 16	; 00000010H
  0054b	74 22		 je	 SHORT $L71613

; 488  : 		{
; 489  : 
; 490  : 			if (fprintf (phTTS->pLogFile, " --> ") < 0)

  0054d	8b 87 98 00 00
	00		 mov	 eax, DWORD PTR [edi+152]
  00553	68 00 00 00 00	 push	 OFFSET FLAT:$SG71499
  00558	50		 push	 eax
  00559	ff d5		 call	 ebp
  0055b	83 c4 08	 add	 esp, 8
  0055e	85 c0		 test	 eax, eax
  00560	7d 0d		 jge	 SHORT $L71613

; 491  : 			{
; 492  : 				TextToSpeechErrorHandler (phTTS,
; 493  : 										  ERROR_WRITING_FILE,
; 494  : 										  0L);

  00562	6a 00		 push	 0
  00564	6a 05		 push	 5
  00566	57		 push	 edi
  00567	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  0056c	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71613:

; 495  : 			}
; 496  : 		}
; 497  : 
; 498  : 		while (--k)

  0056f	8b 44 24 18	 mov	 eax, DWORD PTR _k$[esp+28]
  00573	48		 dec	 eax
  00574	89 44 24 18	 mov	 DWORD PTR _k$[esp+28], eax
  00578	0f 84 89 00 00
	00		 je	 $L71502
  0057e	8b c8		 mov	 ecx, eax
  00580	8b d0		 mov	 edx, eax
  00582	89 54 24 18	 mov	 DWORD PTR -4+[esp+28], edx
  00586	8d bc 8b ac 23
	00 00		 lea	 edi, DWORD PTR [ebx+ecx*4+9132]
$L71501:

; 499  : 		{
; 500  : #ifdef PRINTFDEBUG
; 501  : 			printf ("%c", pKsd_t->ascky[pDph_t->syllable_struct[k]]);
; 502  : #endif
; 503  : #ifndef MSDOS
; 504  : 			if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/

  0058d	8b 86 7c 04 00
	00		 mov	 eax, DWORD PTR [esi+1148]
  00593	85 c0		 test	 eax, eax
  00595	74 1d		 je	 SHORT $L71503

; 505  : 				fprintf(pKsd_t->dbglog,"%c", pKsd_t->ascky[pDph_t->syllable_struct[k]]);

  00597	8b 8e 58 04 00
	00		 mov	 ecx, DWORD PTR [esi+1112]
  0059d	8b 17		 mov	 edx, DWORD PTR [edi]
  0059f	33 db		 xor	 ebx, ebx
  005a1	8a 1c 11	 mov	 bl, BYTE PTR [ecx+edx]
  005a4	53		 push	 ebx
  005a5	68 00 00 00 00	 push	 OFFSET FLAT:$SG71504
  005aa	50		 push	 eax
  005ab	ff d5		 call	 ebp
  005ad	8b 5c 24 20	 mov	 ebx, DWORD PTR _pDph_t$[esp+40]
  005b1	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71503:

; 506  : #endif// #ifndef MSDOS
; 507  : 			if (pKsd_t->logflag & LOG_SYLLABLES)

  005b4	f6 86 04 02 00
	00 10		 test	 BYTE PTR [esi+516], 16	; 00000010H
  005bb	74 38		 je	 SHORT $L71506

; 508  : 			{
; 509  : 				if (fprintf (phTTS->pLogFile,
; 510  : 							 "%c", pKsd_t->ascky[pDph_t->syllable_struct[k]]) < 0)

  005bd	8b 86 58 04 00
	00		 mov	 eax, DWORD PTR [esi+1112]
  005c3	8b 0f		 mov	 ecx, DWORD PTR [edi]
  005c5	33 d2		 xor	 edx, edx
  005c7	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  005ca	8b 44 24 20	 mov	 eax, DWORD PTR _phTTS$[esp+24]
  005ce	52		 push	 edx
  005cf	68 00 00 00 00	 push	 OFFSET FLAT:$SG71507
  005d4	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  005da	51		 push	 ecx
  005db	ff d5		 call	 ebp
  005dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  005e0	85 c0		 test	 eax, eax
  005e2	7d 11		 jge	 SHORT $L71506

; 511  : 				{
; 512  : 					TextToSpeechErrorHandler (phTTS,
; 513  : 											  ERROR_WRITING_FILE,
; 514  : 											  0L);

  005e4	8b 54 24 20	 mov	 edx, DWORD PTR _phTTS$[esp+24]
  005e8	6a 00		 push	 0
  005ea	6a 05		 push	 5
  005ec	52		 push	 edx
  005ed	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  005f2	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71506:
  005f5	8b 44 24 18	 mov	 eax, DWORD PTR -4+[esp+28]
  005f9	83 ef 04	 sub	 edi, 4
  005fc	48		 dec	 eax
  005fd	89 44 24 18	 mov	 DWORD PTR -4+[esp+28], eax
  00601	75 8a		 jne	 SHORT $L71501

; 495  : 			}
; 496  : 		}
; 497  : 
; 498  : 		while (--k)

  00603	8b 7c 24 20	 mov	 edi, DWORD PTR _phTTS$[esp+24]
$L71502:

; 515  : 				}
; 516  : 			}
; 517  : 		}
; 518  : 
; 519  : #ifdef PRINTFDEBUG
; 520  : 		printf ("]\n");
; 521  : #endif
; 522  : #ifndef MSDOS
; 523  : 		if (pKsd_t->dbglog)		/* mfg added for dbglog.txt logging support*/

  00607	8b 86 7c 04 00
	00		 mov	 eax, DWORD PTR [esi+1148]
  0060d	85 c0		 test	 eax, eax
  0060f	74 0b		 je	 SHORT $L71508

; 524  : 			fprintf(pKsd_t->dbglog,"]\n");

  00611	68 00 00 00 00	 push	 OFFSET FLAT:$SG71509
  00616	50		 push	 eax
  00617	ff d5		 call	 ebp
  00619	83 c4 08	 add	 esp, 8
$L71508:

; 525  : #endif// #ifndef MSDOS
; 526  : 		if (pKsd_t->logflag & LOG_SYLLABLES)

  0061c	f6 86 04 02 00
	00 10		 test	 BYTE PTR [esi+516], 16	; 00000010H
  00623	74 22		 je	 SHORT $L71477

; 527  : 		{
; 528  : 			if (fprintf (phTTS->pLogFile, "]\n") < 0)

  00625	8b 87 98 00 00
	00		 mov	 eax, DWORD PTR [edi+152]
  0062b	68 00 00 00 00	 push	 OFFSET FLAT:$SG71512
  00630	50		 push	 eax
  00631	ff d5		 call	 ebp
  00633	83 c4 08	 add	 esp, 8
  00636	85 c0		 test	 eax, eax
  00638	7d 0d		 jge	 SHORT $L71477

; 529  : 			{
; 530  : 				TextToSpeechErrorHandler (phTTS,
; 531  : 										  ERROR_WRITING_FILE,
; 532  : 										  0L);

  0063a	6a 00		 push	 0
  0063c	6a 05		 push	 5
  0063e	57		 push	 edi
  0063f	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  00644	83 c4 0c	 add	 esp, 12			; 0000000cH
$L71477:
  00647	8b 44 24 10	 mov	 eax, DWORD PTR _i$[esp+28]
  0064b	0f bf 8b 5a 17
	00 00		 movsx	 ecx, WORD PTR [ebx+5978]
  00652	40		 inc	 eax
  00653	3b c1		 cmp	 eax, ecx
  00655	89 44 24 10	 mov	 DWORD PTR _i$[esp+28], eax
  00659	0f 8c 7f fd ff
	ff		 jl	 $L71476
  0065f	5d		 pop	 ebp
$L71478:

; 533  : 			}
; 534  : 		}
; 535  : #endif // #ifdef MSDOS
; 536  : 
; 537  : 	}
; 538  : #ifdef WIN32
; 539  : 	LeaveCriticalSection (phTTS->pcsLogFile);

  00660	8b 97 c4 00 00
	00		 mov	 edx, DWORD PTR [edi+196]
  00666	52		 push	 edx
  00667	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0066d	5f		 pop	 edi
  0066e	5e		 pop	 esi
  0066f	5b		 pop	 ebx

; 540  : #endif
; 541  : #if defined (__osf__) || defined (__linux__)
; 542  : 	/* GL 04/21/1997  change this as the latest OSF code */
; 543  : 	/* ToggleLogfileMutex (MUTEX_RELEASE);*/
; 544  : 	OP_UnlockMutex( phTTS->pcsLogFile );
; 545  : #endif
; 546  : 
; 547  : }

  00670	83 c4 0c	 add	 esp, 12			; 0000000cH
  00673	c3		 ret	 0
_logsyllable ENDP
_pDph_t$ = 8
_j$ = 12
_ph_syllab PROC NEAR

; 564  : {

  00680	53		 push	 ebx

; 565  : 	int k; 
; 566  : 	short len;
; 567  : 
; 568  : 	/* 
; 569  : 	 *  first, strip off any  ...
; 570  : 	 */
; 571  : 
; 572  : 	k = 0;

  00681	8b 5c 24 08	 mov	 ebx, DWORD PTR _pDph_t$[esp]
  00685	55		 push	 ebp
  00686	56		 push	 esi
  00687	8b 74 24 14	 mov	 esi, DWORD PTR _j$[esp+8]
  0068b	57		 push	 edi
  0068c	33 ff		 xor	 edi, edi
$L71521:

; 573  : 	while (true)
; 574  : 	{
; 575  : #ifdef __linux__
; 576  : 		len = syl_find_affix (pDph_t, (short int *)&(pDph_t->phone_struct[j]));
; 577  : #else
; 578  :                 len = syl_find_affix (pDph_t, &(pDph_t->phone_struct[j]));

  0068e	8d ac b3 ac 27
	00 00		 lea	 ebp, DWORD PTR [ebx+esi*4+10156]
  00695	55		 push	 ebp
  00696	53		 push	 ebx
  00697	e8 00 00 00 00	 call	 _syl_find_affix
  0069c	83 c4 08	 add	 esp, 8

; 579  : #endif
; 580  : 		if (len == 0)

  0069f	66 85 c0	 test	 ax, ax
  006a2	74 73		 je	 SHORT $L71636

; 581  : 			break;
; 582  : 		while (len-- && j)

  006a4	48		 dec	 eax
  006a5	8d 8c bb ac 23
	00 00		 lea	 ecx, DWORD PTR [ebx+edi*4+9132]
  006ac	8b d5		 mov	 edx, ebp
$L71525:
  006ae	85 f6		 test	 esi, esi
  006b0	0f 84 8d 01 00
	00		 je	 $L71547

; 583  : 			pDph_t->syllable_struct[k++] = pDph_t->phone_struct[j--];

  006b6	8b 2a		 mov	 ebp, DWORD PTR [edx]
  006b8	47		 inc	 edi
  006b9	89 29		 mov	 DWORD PTR [ecx], ebp
  006bb	83 c1 04	 add	 ecx, 4
  006be	4e		 dec	 esi
  006bf	83 ea 04	 sub	 edx, 4
  006c2	66 8b e8	 mov	 bp, ax
  006c5	48		 dec	 eax
  006c6	66 85 ed	 test	 bp, bp
  006c9	75 e3		 jne	 SHORT $L71525

; 584  : 		if (j == 0)

  006cb	85 f6		 test	 esi, esi
  006cd	0f 84 70 01 00
	00		 je	 $L71547
  006d3	8d 84 bb ac 23
	00 00		 lea	 eax, DWORD PTR [ebx+edi*4+9132]
  006da	8d 94 b3 ac 27
	00 00		 lea	 edx, DWORD PTR [ebx+esi*4+10156]
$L71529:

; 585  : 			break;
; 586  : 		while (j && ascky_check[pDph_t->phone_struct[j]] == 0)

  006e1	8b 0a		 mov	 ecx, DWORD PTR [edx]
  006e3	80 b9 00 00 00
	00 00		 cmp	 BYTE PTR _ascky_check[ecx], 0
  006ea	75 0e		 jne	 SHORT $L71530

; 587  : 			pDph_t->syllable_struct[k++] = pDph_t->phone_struct[j--];

  006ec	89 08		 mov	 DWORD PTR [eax], ecx
  006ee	47		 inc	 edi
  006ef	83 c0 04	 add	 eax, 4
  006f2	4e		 dec	 esi
  006f3	83 ea 04	 sub	 edx, 4
  006f6	85 f6		 test	 esi, esi
  006f8	75 e7		 jne	 SHORT $L71529
$L71530:

; 588  : 		if (pDph_t->syllable_struct[k-1] != SBOUND)		/* fix duplicated syllable boundries */

  006fa	8b 8c bb a8 23
	00 00		 mov	 ecx, DWORD PTR [ebx+edi*4+9128]
  00701	b8 6c 00 00 00	 mov	 eax, 108		; 0000006cH
  00706	3b c8		 cmp	 ecx, eax
  00708	74 84		 je	 SHORT $L71521

; 589  : 			pDph_t->syllable_struct[k++] = SBOUND;

  0070a	89 84 bb ac 23
	00 00		 mov	 DWORD PTR [ebx+edi*4+9132], eax
  00711	47		 inc	 edi
  00712	e9 77 ff ff ff	 jmp	 $L71521
$L71636:

; 590  : 		
; 591  : 	}
; 592  : 	/* 
; 593  : 	 *  Now, syllablify the rest of it ...
; 594  : 	 */
; 595  : 	if (j != 0)

  00717	85 f6		 test	 esi, esi
  00719	0f 84 24 01 00
	00		 je	 $L71547
$L71534:

; 596  : 	{
; 597  : 		while (true)
; 598  : 		{
; 599  : 			/* 
; 600  : 			 *  Find vowel ...
; 601  : 			 */
; 602  : #ifdef __linux__
; 603  : 			len = syl_find_vowel ((short int *)&(pDph_t->phone_struct[j]));
; 604  : #else
; 605  :                         len = syl_find_vowel (&(pDph_t->phone_struct[j]));

  0071f	8d ac b3 ac 27
	00 00		 lea	 ebp, DWORD PTR [ebx+esi*4+10156]
  00726	55		 push	 ebp
  00727	e8 00 00 00 00	 call	 _syl_find_vowel
  0072c	83 c4 04	 add	 esp, 4

; 606  : #endif
; 607  : 			if (len)

  0072f	66 85 c0	 test	 ax, ax
  00732	0f 84 ea 00 00
	00		 je	 $L71635

; 608  : 			{
; 609  : 				while (len-- && j)

  00738	48		 dec	 eax
  00739	8d 8c bb ac 23
	00 00		 lea	 ecx, DWORD PTR [ebx+edi*4+9132]
  00740	8b d5		 mov	 edx, ebp
$L71538:
  00742	85 f6		 test	 esi, esi
  00744	0f 84 f9 00 00
	00		 je	 $L71547

; 610  : 				{
; 611  : 					pDph_t->syllable_struct[k++] = pDph_t->phone_struct[j--];

  0074a	8b 2a		 mov	 ebp, DWORD PTR [edx]
  0074c	47		 inc	 edi
  0074d	89 29		 mov	 DWORD PTR [ecx], ebp
  0074f	83 c1 04	 add	 ecx, 4
  00752	4e		 dec	 esi
  00753	83 ea 04	 sub	 edx, 4
  00756	66 8b e8	 mov	 bp, ax
  00759	48		 dec	 eax
  0075a	66 85 ed	 test	 bp, bp
  0075d	75 e3		 jne	 SHORT $L71538

; 612  : 				}
; 613  : 				if (j == 0)

  0075f	85 f6		 test	 esi, esi
  00761	0f 84 dc 00 00
	00		 je	 $L71547
  00767	8d 84 bb ac 23
	00 00		 lea	 eax, DWORD PTR [ebx+edi*4+9132]
  0076e	8d 94 b3 ac 27
	00 00		 lea	 edx, DWORD PTR [ebx+esi*4+10156]
$L71542:

; 614  : 					break;
; 615  : 				while (j && ascky_check[pDph_t->phone_struct[j]] == 0)

  00775	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00777	80 b9 00 00 00
	00 00		 cmp	 BYTE PTR _ascky_check[ecx], 0
  0077e	75 0e		 jne	 SHORT $L71543

; 616  : 					pDph_t->syllable_struct[k++] = pDph_t->phone_struct[j--];

  00780	89 08		 mov	 DWORD PTR [eax], ecx
  00782	47		 inc	 edi
  00783	83 c0 04	 add	 eax, 4
  00786	4e		 dec	 esi
  00787	83 ea 04	 sub	 edx, 4
  0078a	85 f6		 test	 esi, esi
  0078c	75 e7		 jne	 SHORT $L71542
$L71543:

; 622  : 				break;
; 623  : 			}
; 624  : 			/* 
; 625  : 			 *  head cons ...
; 626  : 			 */
; 627  : #ifdef __linux__
; 628  : 			len = syl_find_cons ((short int *) &(pDph_t->phone_struct[j]));
; 629  : #else
; 630  :                         len = syl_find_cons (&(pDph_t->phone_struct[j]));

  0078e	8d ac b3 ac 27
	00 00		 lea	 ebp, DWORD PTR [ebx+esi*4+10156]
  00795	55		 push	 ebp
  00796	e8 00 00 00 00	 call	 _syl_find_cons
  0079b	83 c4 04	 add	 esp, 4

; 631  : #endif
; 632  : 			if (len)

  0079e	66 85 c0	 test	 ax, ax
  007a1	74 2d		 je	 SHORT $L71634

; 633  : 			{
; 634  : 				while (len-- && j)

  007a3	48		 dec	 eax
  007a4	8d 8c bb ac 23
	00 00		 lea	 ecx, DWORD PTR [ebx+edi*4+9132]
  007ab	8b d5		 mov	 edx, ebp
$L71550:
  007ad	85 f6		 test	 esi, esi
  007af	0f 84 8e 00 00
	00		 je	 $L71547

; 635  : 					pDph_t->syllable_struct[k++] = pDph_t->phone_struct[j--];

  007b5	8b 2a		 mov	 ebp, DWORD PTR [edx]
  007b7	47		 inc	 edi
  007b8	89 29		 mov	 DWORD PTR [ecx], ebp
  007ba	83 c1 04	 add	 ecx, 4
  007bd	4e		 dec	 esi
  007be	83 ea 04	 sub	 edx, 4
  007c1	66 8b e8	 mov	 bp, ax
  007c4	48		 dec	 eax
  007c5	66 85 ed	 test	 bp, bp
  007c8	75 e3		 jne	 SHORT $L71550

; 636  : 				if (j == 0)

  007ca	85 f6		 test	 esi, esi
  007cc	74 75		 je	 SHORT $L71547

; 637  : 					break;
; 638  : 			}
; 639  : 			/* 
; 640  : 			 *  syllable break must be here ... if we are not word initial ...
; 641  : 			 */
; 642  : 			while (j && ascky_check[pDph_t->phone_struct[j]] == 0)

  007ce	eb 04		 jmp	 SHORT $L71656
$L71634:
  007d0	85 f6		 test	 esi, esi
  007d2	74 6f		 je	 SHORT $L71547
$L71656:
  007d4	8d 84 bb ac 23
	00 00		 lea	 eax, DWORD PTR [ebx+edi*4+9132]
  007db	8d 94 b3 ac 27
	00 00		 lea	 edx, DWORD PTR [ebx+esi*4+10156]
$L71554:
  007e2	8b 0a		 mov	 ecx, DWORD PTR [edx]
  007e4	80 b9 00 00 00
	00 00		 cmp	 BYTE PTR _ascky_check[ecx], 0
  007eb	75 10		 jne	 SHORT $L71555

; 643  : 				pDph_t->syllable_struct[k++] = pDph_t->phone_struct[j--];

  007ed	89 08		 mov	 DWORD PTR [eax], ecx
  007ef	47		 inc	 edi
  007f0	83 c0 04	 add	 eax, 4
  007f3	4e		 dec	 esi
  007f4	83 ea 04	 sub	 edx, 4
  007f7	85 f6		 test	 esi, esi
  007f9	74 48		 je	 SHORT $L71547

; 637  : 					break;
; 638  : 			}
; 639  : 			/* 
; 640  : 			 *  syllable break must be here ... if we are not word initial ...
; 641  : 			 */
; 642  : 			while (j && ascky_check[pDph_t->phone_struct[j]] == 0)

  007fb	eb e5		 jmp	 SHORT $L71554
$L71555:

; 644  : 			if (j == 0)

  007fd	85 f6		 test	 esi, esi
  007ff	74 42		 je	 SHORT $L71547

; 645  : 			{
; 646  : 				break;
; 647  : 			}
; 648  : 			if (pDph_t->syllable_struct[k-1] != SBOUND)	/* fix duplicated syllable boundries */	

  00801	8b 8c bb a8 23
	00 00		 mov	 ecx, DWORD PTR [ebx+edi*4+9128]
  00808	b8 6c 00 00 00	 mov	 eax, 108		; 0000006cH
  0080d	3b c8		 cmp	 ecx, eax
  0080f	0f 84 0a ff ff
	ff		 je	 $L71534

; 649  : 				pDph_t->syllable_struct[k++] = SBOUND;

  00815	89 84 bb ac 23
	00 00		 mov	 DWORD PTR [ebx+edi*4+9132], eax
  0081c	47		 inc	 edi
  0081d	e9 fd fe ff ff	 jmp	 $L71534
$L71635:

; 617  : 			}
; 618  : 			else
; 619  : 			{
; 620  : 				while (j)

  00822	85 f6		 test	 esi, esi
  00824	74 1d		 je	 SHORT $L71547
  00826	8d 84 bb ac 23
	00 00		 lea	 eax, DWORD PTR [ebx+edi*4+9132]
  0082d	8d 9c b3 ac 27
	00 00		 lea	 ebx, DWORD PTR [ebx+esi*4+10156]
  00834	03 fe		 add	 edi, esi
$L71546:

; 621  : 					pDph_t->syllable_struct[k++] = pDph_t->phone_struct[j--];

  00836	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00838	83 eb 04	 sub	 ebx, 4
  0083b	89 08		 mov	 DWORD PTR [eax], ecx
  0083d	83 c0 04	 add	 eax, 4
  00840	4e		 dec	 esi
  00841	75 f3		 jne	 SHORT $L71546
$L71547:

; 650  : 		}
; 651  : 	}
; 652  : 	return (k);

  00843	8b c7		 mov	 eax, edi
  00845	5f		 pop	 edi
  00846	5e		 pop	 esi
  00847	5d		 pop	 ebp
  00848	5b		 pop	 ebx

; 653  : }

  00849	c3		 ret	 0
_ph_syllab ENDP
_ph$ = 12
_syl_find_affix PROC NEAR

; 291  : {

  00850	53		 push	 ebx
  00851	55		 push	 ebp
  00852	56		 push	 esi
  00853	57		 push	 edi

; 292  : 	short *tp;
; 293  : 	int i, j, len = 0;
; 294  : 
; 295  : 	for (j = 0; common_affixes[j]; j++)

  00854	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _common_affixes
  0085a	85 ff		 test	 edi, edi
  0085c	74 51		 je	 SHORT $L71454
  0085e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_common_affixes
$L71452:

; 296  : 	{
; 297  : 		for (i = 0; common_affixes[j][i]; i++);

  00863	8a 17		 mov	 dl, BYTE PTR [edi]
  00865	33 c9		 xor	 ecx, ecx
  00867	84 d2		 test	 dl, dl
  00869	74 0b		 je	 SHORT $L71457
  0086b	8b 38		 mov	 edi, DWORD PTR [eax]
$L71455:
  0086d	8a 54 0f 01	 mov	 dl, BYTE PTR [edi+ecx+1]
  00871	41		 inc	 ecx
  00872	84 d2		 test	 dl, dl
  00874	75 f7		 jne	 SHORT $L71455
$L71457:

; 298  : 		len = i;
; 299  : 		tp = ph;

  00876	8b 74 24 18	 mov	 esi, DWORD PTR _ph$[esp+12]
  0087a	8b e9		 mov	 ebp, ecx
$L71459:

; 301  : 		{
; 302  : 			if (ascky_check[*tp] == 0)

  0087c	0f bf 16	 movsx	 edx, WORD PTR [esi]
  0087f	8a 92 00 00 00
	00		 mov	 dl, BYTE PTR _ascky_check[edx]
  00885	84 d2		 test	 dl, dl
  00887	75 06		 jne	 SHORT $L71461

; 303  : 			{
; 304  : #ifdef ENGLISH_US
; 305  : 				tp++;

  00889	83 c6 02	 add	 esi, 2

; 306  : #endif
; 307  : #ifdef ENGLISH_UK
; 308  : 				tp++;
; 309  : #endif
; 310  : #ifdef SPANISH
; 311  : 				tp--;
; 312  : #endif
; 313  : 				len += 1;

  0088c	45		 inc	 ebp

; 314  : 			}
; 315  : 			else if (common_affixes[j][--i] != ascky_check[*tp--])

  0088d	eb 10		 jmp	 SHORT $L71463
$L71461:
  0088f	49		 dec	 ecx
  00890	33 db		 xor	 ebx, ebx
  00892	0f be d2	 movsx	 edx, dl
  00895	8a 1c 0f	 mov	 bl, BYTE PTR [edi+ecx]
  00898	83 ee 02	 sub	 esi, 2
  0089b	3b da		 cmp	 ebx, edx
  0089d	75 06		 jne	 SHORT $L71453
$L71463:

; 316  : 				break;
; 317  : 			if (i == 0)

  0089f	85 c9		 test	 ecx, ecx
  008a1	74 14		 je	 SHORT $L71675

; 300  : 		while (true)

  008a3	eb d7		 jmp	 SHORT $L71459
$L71453:

; 292  : 	short *tp;
; 293  : 	int i, j, len = 0;
; 294  : 
; 295  : 	for (j = 0; common_affixes[j]; j++)

  008a5	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  008a8	83 c0 04	 add	 eax, 4
  008ab	85 ff		 test	 edi, edi
  008ad	75 b4		 jne	 SHORT $L71452
$L71454:
  008af	5f		 pop	 edi
  008b0	5e		 pop	 esi
  008b1	5d		 pop	 ebp

; 319  : 		}
; 320  : 	}
; 321  : 	return (0);

  008b2	66 33 c0	 xor	 ax, ax
  008b5	5b		 pop	 ebx

; 322  : }

  008b6	c3		 ret	 0
$L71675:
  008b7	5f		 pop	 edi

; 318  : 				return (len);

  008b8	66 8b c5	 mov	 ax, bp
  008bb	5e		 pop	 esi
  008bc	5d		 pop	 ebp
  008bd	5b		 pop	 ebx

; 322  : }

  008be	c3		 ret	 0
_syl_find_affix ENDP
_pDph_t$ = 8
_syl_clause_init PROC NEAR

; 670  : 	pDph_t->symbols[0] = COMMA;

  008c0	8b 44 24 04	 mov	 eax, DWORD PTR _pDph_t$[esp-4]
  008c4	56		 push	 esi
  008c5	ba 73 00 00 00	 mov	 edx, 115		; 00000073H

; 671  : 	pDph_t->user_durs[0] = 0;

  008ca	33 c9		 xor	 ecx, ecx
  008cc	8b b0 5c 17 00
	00		 mov	 esi, DWORD PTR [eax+5980]
  008d2	66 89 90 fe 14
	00 00		 mov	 WORD PTR [eax+5374], dx
  008d9	66 89 0e	 mov	 WORD PTR [esi], cx

; 672  : 	pDph_t->user_f0[0] = 0;

  008dc	8b b0 60 17 00
	00		 mov	 esi, DWORD PTR [eax+5984]
  008e2	66 89 0e	 mov	 WORD PTR [esi], cx

; 673  : 	pDph_t->bound = COMMA;

  008e5	89 90 a0 23 00
	00		 mov	 DWORD PTR [eax+9120], edx

; 674  : 	pDph_t->lastoffs = 0;

  008eb	89 88 a8 23 00
	00		 mov	 DWORD PTR [eax+9128], ecx

; 675  : 	pDph_t->nphone = 0;
; 676  : 	pDph_t->asperation = 0;

  008f1	89 88 98 23 00
	00		 mov	 DWORD PTR [eax+9112], ecx

; 677  : 	pDph_t->nsymbtot = 1;

  008f7	66 c7 80 5a 17
	00 00 01 00	 mov	 WORD PTR [eax+5978], 1

; 678  : 	pDph_t->nphone = 0;

  00900	66 89 88 a4 23
	00 00		 mov	 WORD PTR [eax+9124], cx
  00907	5e		 pop	 esi

; 679  : }

  00908	c3		 ret	 0
_syl_clause_init ENDP
_TEXT	ENDS
EXTRN	_write_pipe:NEAR
EXTRN	_phclause:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pipe_item$ = 8
_speak_syllable PROC NEAR

; 696  : /* GL 04/21/1997  change this as the latest OSF code */
; 697  : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 698  : 	DT_PIPE_T               pipe_item[1];
; 699  : #endif
; 700  : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;

  00910	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00914	56		 push	 esi
  00915	57		 push	 edi

; 701  : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;
; 702  : 
; 703  : 	pDph_t->symbols[pDph_t->nsymbtot] = COMMA;
; 704  : 	pDph_t->user_durs[pDph_t->nsymbtot] = 0;
; 705  : 	pDph_t->user_f0[pDph_t->nsymbtot++] = 0;
; 706  : 	phclause (phTTS);

  00916	50		 push	 eax
  00917	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  0091a	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  0091d	0f bf 8e 5a 17
	00 00		 movsx	 ecx, WORD PTR [esi+5978]
  00924	66 c7 84 4e fe
	14 00 00 73 00	 mov	 WORD PTR [esi+ecx*2+5374], 115 ; 00000073H
  0092e	8b 8e 5c 17 00
	00		 mov	 ecx, DWORD PTR [esi+5980]
  00934	0f bf 96 5a 17
	00 00		 movsx	 edx, WORD PTR [esi+5978]
  0093b	66 c7 04 51 00
	00		 mov	 WORD PTR [ecx+edx*2], 0
  00941	8b 8e 60 17 00
	00		 mov	 ecx, DWORD PTR [esi+5984]
  00947	0f bf 96 5a 17
	00 00		 movsx	 edx, WORD PTR [esi+5978]
  0094e	66 c7 04 51 00
	00		 mov	 WORD PTR [ecx+edx*2], 0
  00954	66 ff 86 5a 17
	00 00		 inc	 WORD PTR [esi+5978]
  0095b	e8 00 00 00 00	 call	 _phclause

; 707  : 	syl_clause_init (pDph_t);

  00960	56		 push	 esi
  00961	e8 00 00 00 00	 call	 _syl_clause_init

; 708  : 
; 709  : /* GL 04/21/1997  change this as the latest OSF code */
; 710  : /* write forced clause boundary symbol to VTM */
; 711  : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 712  : 	pipe_item[0] = SPC_type_force;

  00966	66 c7 44 24 14
	0b 00		 mov	 WORD PTR _pipe_item$[esp+12], 11 ; 0000000bH

; 713  : 	write_pipe (pKsd_t->vtm_pipe, pipe_item, 1);

  0096d	8b 87 dc 00 00
	00		 mov	 eax, DWORD PTR [edi+220]
  00973	8d 54 24 14	 lea	 edx, DWORD PTR _pipe_item$[esp+12]
  00977	6a 01		 push	 1
  00979	52		 push	 edx
  0097a	50		 push	 eax
  0097b	e8 00 00 00 00	 call	 _write_pipe
  00980	83 c4 14	 add	 esp, 20			; 00000014H
  00983	5f		 pop	 edi
  00984	5e		 pop	 esi

; 714  : #endif
; 715  : 
; 716  : }

  00985	c3		 ret	 0
_speak_syllable ENDP
_TEXT	ENDS
END
