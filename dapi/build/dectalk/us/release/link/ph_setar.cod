	TITLE	D:\work\product\dapi\src\Ph\ph_setar.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_phsettar
EXTRN	_partyp:BYTE
EXTRN	_divtab:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_inhdr_frames$ = -20
_pholas$ = -28
_fealas$ = -24
_feacur$ = -36
_feanex$ = -40
_struclm2$ = -12
_struclas$ = -32
_struccur$ = -44
_strucnex$ = -16
_ndips$ = -4
_phonp2$ = -8
_phsettar PROC NEAR

; 318  : {

  00000	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi

; 319  : 	/* 
; 320  : 	 * MVP :The following variables are made local to phsettar,
; 321  : 	 * Earlier they were static at file scope 
; 322  : 	 */
; 323  : 	short inhdr_frames = 0;
; 324  : 	short pholas = 0;
; 325  : 	short fealas = 0, feacur = 0, feanex = 0;
; 326  : 	short struclm2 = 0, struclas = 0, struccur = 0, strucnex = 0;
; 327  : 	short *ndips;      /* pointer in dipspec[]                   */
; 328  : 	short temp;
; 329  : 	short phonp2=0;
; 330  : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;
; 331  : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 332  : 	PDPHSETTAR_ST   pDphsettar = pDph_t->pSTphsettar;
; 333  : 
; 334  : 	/* Initialize program at beginning of each clause */
; 335  : 
; 336  : 	init_variables (phTTS, &inhdr_frames, &pDph_t->shrink,
; 337  : 					&pDph_t->shrif, &pDph_t->shrib,
; 338  : 					&pholas, &fealas, &feacur,
; 339  : 					&feanex, &struclm2, &struclas,
; 340  : 					&struccur, &strucnex, &ndips,&phonp2);

  00006	8d 6c 24 30	 lea	 ebp, DWORD PTR _phonp2$[esp+56]
  0000a	57		 push	 edi
  0000b	55		 push	 ebp
  0000c	8d 6c 24 3c	 lea	 ebp, DWORD PTR _ndips$[esp+64]
  00010	8b 44 24 44	 mov	 eax, DWORD PTR _phTTS$[esp+60]
  00014	55		 push	 ebp
  00015	8d 6c 24 34	 lea	 ebp, DWORD PTR _strucnex$[esp+68]
  00019	55		 push	 ebp
  0001a	8d 6c 24 1c	 lea	 ebp, DWORD PTR _struccur$[esp+72]
  0001e	55		 push	 ebp
  0001f	8d 6c 24 2c	 lea	 ebp, DWORD PTR _struclas$[esp+76]
  00023	55		 push	 ebp
  00024	8d 6c 24 44	 lea	 ebp, DWORD PTR _struclm2$[esp+80]
  00028	8b 78 18	 mov	 edi, DWORD PTR [eax+24]
  0002b	55		 push	 ebp
  0002c	8d 6c 24 2c	 lea	 ebp, DWORD PTR _feanex$[esp+84]
  00030	33 db		 xor	 ebx, ebx
  00032	55		 push	 ebp
  00033	8d 6c 24 34	 lea	 ebp, DWORD PTR _feacur$[esp+88]
  00037	55		 push	 ebp
  00038	8d 6c 24 44	 lea	 ebp, DWORD PTR _fealas$[esp+92]
  0003c	55		 push	 ebp
  0003d	8d 6c 24 44	 lea	 ebp, DWORD PTR _pholas$[esp+96]
  00041	8d 87 bc 2b 00
	00		 lea	 eax, DWORD PTR [edi+11196]
  00047	8d 8f ba 2b 00
	00		 lea	 ecx, DWORD PTR [edi+11194]
  0004d	55		 push	 ebp
  0004e	8d 97 b8 2b 00
	00		 lea	 edx, DWORD PTR [edi+11192]
  00054	50		 push	 eax
  00055	51		 push	 ecx
  00056	52		 push	 edx
  00057	8b 54 24 74	 mov	 edx, DWORD PTR _phTTS$[esp+108]
  0005b	8d 4c 24 5c	 lea	 ecx, DWORD PTR _inhdr_frames$[esp+112]
  0005f	89 5c 24 5c	 mov	 DWORD PTR _inhdr_frames$[esp+112], ebx
  00063	51		 push	 ecx
  00064	89 5c 24 58	 mov	 DWORD PTR _pholas$[esp+116], ebx
  00068	89 5c 24 5c	 mov	 DWORD PTR _fealas$[esp+116], ebx
  0006c	89 5c 24 50	 mov	 DWORD PTR _feacur$[esp+116], ebx
  00070	89 5c 24 4c	 mov	 DWORD PTR _feanex$[esp+116], ebx
  00074	89 5c 24 68	 mov	 DWORD PTR _struclm2$[esp+116], ebx
  00078	89 5c 24 54	 mov	 DWORD PTR _struclas$[esp+116], ebx
  0007c	89 5c 24 48	 mov	 DWORD PTR _struccur$[esp+116], ebx
  00080	89 5c 24 64	 mov	 DWORD PTR _strucnex$[esp+116], ebx
  00084	89 5c 24 6c	 mov	 DWORD PTR _phonp2$[esp+116], ebx
  00088	8b b7 d0 2b 00
	00		 mov	 esi, DWORD PTR [edi+11216]
  0008e	52		 push	 edx
  0008f	e8 00 00 00 00	 call	 _init_variables
  00094	83 c4 3c	 add	 esp, 60			; 0000003cH

; 341  : 
; 342  : 	/* Turn off breathyness switch at end of a phrase */    
; 343  : 	/* 12/10/1996 EDB */
; 344  : 	if ((pDphsettar->phcur == SIL)/* || ((struccur & FHAT_BEGINS) IS_PLUS)*/)

  00097	66 39 5e 18	 cmp	 WORD PTR [esi+24], bx
  0009b	75 07		 jne	 SHORT $L71849

; 345  : 			pDph_t->breathysw = 0;

  0009d	66 89 9f 6a 03
	00 00		 mov	 WORD PTR [edi+874], bx
$L71849:

; 346  : 	
; 347  : 	/* Turn on breathyness switch during last syllable of clause */
; 348  : 	/* (generally restricted to female voices via spdef LX) */
; 349  : 	if ((struccur & FSENTENDS) IS_PLUS)

  000a4	8b 44 24 10	 mov	 eax, DWORD PTR _struccur$[esp+60]
  000a8	25 00 01 00 00	 and	 eax, 256		; 00000100H
  000ad	66 85 c0	 test	 ax, ax
  000b0	74 09		 je	 SHORT $L71850

; 350  : 	{
; 351  : 		pDph_t->breathysw = 1;

  000b2	66 c7 87 6a 03
	00 00 01 00	 mov	 WORD PTR [edi+874], 1
$L71850:

; 352  : 	}
; 353  : 	/* Main loop: For each parameter, set target and transition specs    */
; 354  : 
; 355  : 	for (pDphsettar->np = &PF1; pDphsettar->np <= &PTILT; pDphsettar->np++)

  000bb	8d 47 24	 lea	 eax, DWORD PTR [edi+36]
  000be	8d 8f 40 02 00
	00		 lea	 ecx, DWORD PTR [edi+576]
  000c4	3b c1		 cmp	 eax, ecx
  000c6	89 46 10	 mov	 DWORD PTR [esi+16], eax
  000c9	0f 87 ba 03 00
	00		 ja	 $L71853
$L71851:

; 356  : 	{
; 357  : 		pDphsettar->par_type = partyp[pDphsettar->np - &PF1];   /* formfreq, ampl, etc. */

  000cf	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  000d2	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  000d7	8b cd		 mov	 ecx, ebp
  000d9	2b cf		 sub	 ecx, edi
  000db	83 e9 24	 sub	 ecx, 36			; 00000024H
  000de	f7 e9		 imul	 ecx
  000e0	c1 fa 03	 sar	 edx, 3
  000e3	8b ca		 mov	 ecx, edx
  000e5	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000e8	8a 94 0a 00 00
	00 00		 mov	 dl, BYTE PTR _partyp[edx+ecx]
  000ef	88 56 14	 mov	 BYTE PTR [esi+20], dl

; 358  : 
; 359  : 		/* 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 */
; 360  : 		/* Set target value associated with end time of last phone         */
; 361  : 		/* 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 */
; 362  : 
; 363  : 		pDphsettar->np->tarlas = pDphsettar->np->tarend;

  000f2	66 8b 45 1a	 mov	 ax, WORD PTR [ebp+26]
  000f6	66 89 45 18	 mov	 WORD PTR [ebp+24], ax

; 364  : 
; 365  : 		/* 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 */
; 366  : 		/* Set target value associated with onset of next phone            */
; 367  : 		/* and compute any shift due to coartic with adjacent phones       */
; 368  : 		/* 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 */
; 369  : 
; 370  : 		pDphsettar->np->tarnex = getbegtar (phTTS, (pDph_t->nphone + 1));       /* Calls gettar() */

  000fa	66 8b 8f a4 23
	00 00		 mov	 cx, WORD PTR [edi+9124]
  00101	8b 6c 24 40	 mov	 ebp, DWORD PTR _phTTS$[esp+56]
  00105	66 41		 inc	 cx
  00107	51		 push	 ecx
  00108	55		 push	 ebp
  00109	e8 00 00 00 00	 call	 _getbegtar
  0010e	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00111	66 89 42 16	 mov	 WORD PTR [edx+22], ax

; 371  : 
; 372  : 		/* 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 */
; 373  : 		/* Set target value(s) associated with current phone               */
; 374  : 		/* tarcur is target at phone beginning                             */
; 375  : 		/* tarend is target at phone ending                                */
; 376  : 		/* if diphthongized, also set sequence of time,value commands &    */
; 377  : 		/* add special coartic such as change in [ih] due to postvoc [l] */
; 378  : 		/* 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 */
; 379  : 
; 380  : 		pDphsettar->np->tarcur = gettar (phTTS, pDph_t->nphone);        /* target or -pointer to target     */

  00115	66 8b 87 a4 23
	00 00		 mov	 ax, WORD PTR [edi+9124]
  0011c	50		 push	 eax
  0011d	55		 push	 ebp
  0011e	e8 00 00 00 00	 call	 _gettar
  00123	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00126	83 c4 10	 add	 esp, 16			; 00000010H
  00129	66 89 01	 mov	 WORD PTR [ecx], ax

; 381  : 			pDphsettar->np->dipcum = 0;        /* Diph time since phone begin      */

  0012c	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0012f	66 89 5a 06	 mov	 WORD PTR [edx+6], bx

; 382  : 		if (pDphsettar->np->tarcur < -1)

  00133	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00136	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00139	66 3d ff ff	 cmp	 ax, -1
  0013d	7d 28		 jge	 SHORT $L71854

; 383  : 		{   /* -pointer: diphthongized vowel    */
; 384  : 
; 385  : 			make_dip (pDph_t, (-pDphsettar->np->tarcur), inhdr_frames, pDph_t->shrink,
; 386  : 					  struccur, &ndips);    /* Cur seg diphthongized, generate  */

  0013f	8b 54 24 10	 mov	 edx, DWORD PTR _struccur$[esp+60]
  00143	8d 4c 24 38	 lea	 ecx, DWORD PTR _ndips$[esp+60]
  00147	51		 push	 ecx
  00148	66 8b 8f b8 2b
	00 00		 mov	 cx, WORD PTR [edi+11192]
  0014f	52		 push	 edx
  00150	8b 54 24 30	 mov	 edx, DWORD PTR _inhdr_frames$[esp+68]
  00154	51		 push	 ecx
  00155	52		 push	 edx
  00156	f7 d8		 neg	 eax
  00158	50		 push	 eax
  00159	57		 push	 edi
  0015a	e8 00 00 00 00	 call	 _make_dip
  0015f	83 c4 18	 add	 esp, 24			; 00000018H

; 387  : 			/* several straight lines (this    */
; 388  : 		}
; 389  : 		/* routine also sets pDphsettar->np->tarend)   */
; 390  : 		else

  00162	e9 81 00 00 00	 jmp	 $L71855
$L71854:

; 391  : 		{
; 392  : 			pDphsettar->np->deldip = 0;             /* Set dipthong increment to zero    */

  00167	66 89 59 04	 mov	 WORD PTR [ecx+4], bx

; 393  : 			pDphsettar->np->durlin = pDph_t->durfon;        /* and dipth dur to phone duration   */

  0016b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0016e	66 8b 8f e0 14
	00 00		 mov	 cx, WORD PTR [edi+5344]
  00175	66 89 48 02	 mov	 WORD PTR [eax+2], cx

; 394  : 
; 395  : 			/* 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 */
; 396  : 			/* General coartic rule for curr sonor cons: prev. & next phones      */
; 397  : 			/* modify formant freqs: 5% tarlas, 5% tarnex, 90% tarcur           */
; 398  : 			/* (only effective for -diph -obst because of p_ locus[] tables)            */
; 399  : 			/* Special case for /r/ and /rr/ in Spanish                           */
; 400  : 			/* 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 */
; 401  : 			if (pDphsettar->par_type IS_FORM_FREQ)

  00179	8a 46 14	 mov	 al, BYTE PTR [esi+20]
  0017c	3c 03		 cmp	 al, 3
  0017e	75 5e		 jne	 SHORT $L71856

; 402  : 			{
; 403  : 				pDphsettar->gencoartic = N10PRCNT;

  00180	66 c7 46 0c 66
	06		 mov	 WORD PTR [esi+12], 1638	; 00000666H

; 404  : #ifdef GERMAN 
; 405  : 				pDph_t->arg3 = 0;
; 406  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 407  : 				/* special german coarticulation rules              */
; 408  : 				/* /R/-coarticulation rules before vowel                */
; 409  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 410  : 				if ((pDphsettar->phcur == R) && (pholas != EX) &&
; 411  : 					((fealas & FVOWEL) IS_PLUS))
; 412  : 				{
; 413  : 					pDphsettar->gencoartic = N20PRCNT;
; 414  : 					pDph_t->arg3 = R;
; 415  : 
; 416  : 				}
; 417  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 418  : 				/* special rule for /@r/ suffix                 */
; 419  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 420  : 				else if ((pDphsettar->phcur == EX) && (pDphsettar->phonex == R))
; 421  : 				{
; 422  : 					if (pDphsettar->np == &PF1)
; 423  : 					{
; 424  : 						pDphsettar->np->tarcur = 520;
; 425  : 					}
; 426  : 					if (pDphsettar->np == &PF2)
; 427  : 					{
; 428  : 						pDphsettar->np->tarcur = 1300;
; 429  : 					}
; 430  : 					pDphsettar->gencoartic = 0;
; 431  : 					pDph_t->arg3 = R;
; 432  : 
; 433  : 				}
; 434  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 435  : 				/* no modification of /r/ after /@/             */
; 436  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 437  : 				else if ((pholas == EX) && (pDphsettar->phcur == R))
; 438  : 				{
; 439  : 					pDphsettar->gencoartic = 0;
; 440  : 					pDph_t->arg3 = R;
; 441  : 
; 442  : 				}
; 443  : 
; 444  : #ifdef LRULES
; 445  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 446  : 				/* special german coarticulation rules              */
; 447  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 448  : 				else if (pDphsettar->phcur == L)
; 449  : 				{
; 450  : 					if (((feanex & FVOWEL) IS_PLUS) &&
; 451  : 						((begtyp[pDphsettar->phonex] != 2) &&
; 452  : 						 (begtyp[pDphsettar->phonex] != 6) &&
; 453  : 						 !((endtyp[pholas] != 1) &&
; 454  : 						   (begtyp[pDphsettar->phonex] == 1))))
; 455  : 					{
; 456  : 						if (pDphsettar->np == &PF1)
; 457  : 						{
; 458  : 							pDphsettar->gencoartic = N30PRCNT;
; 459  : 						}
; 460  : 						else
; 461  : 						{
; 462  : 							pDphsettar->gencoartic = N50PRCNT;
; 463  : 						}
; 464  : 						pDph_t->arg3 = L;
; 465  : 					}
; 466  : 					else if ((endtyp[pholas] == 1) ||
; 467  : 							 ((endtyp[pholas] == 2) ||
; 468  : 							  (endtyp[pholas] == 6)))
; 469  : 					{
; 470  : 						if (pDphsettar->np == &PF1)
; 471  : 						{
; 472  : 							pDphsettar->gencoartic = N40PRCNT;
; 473  : 						}
; 474  : 						else
; 475  : 						{
; 476  : 							pDphsettar->gencoartic = N50PRCNT;
; 477  : 						}
; 478  : 						pDph_t->arg3 = R;
; 479  : 					}
; 480  : 					/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 481  : 					/* make 'L' audible in 'schwa'-'L'-'nasal' cluster           */
; 482  : 					/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 483  : 					else if ((pholas == EX) &&
; 484  : 							 ((featb[pDphsettar->phonex] & FNASAL) IS_PLUS))
; 485  : 					{
; 486  : 						if (pDphsettar->np == &PF1)
; 487  : 						{
; 488  : 							pDphsettar->np->tarnex -= 0;
; 489  : 						}
; 490  : 						else if (pDphsettar->np == &PF2)
; 491  : 						{
; 492  : 							pDphsettar->np->tarnex += 200;
; 493  : 						}
; 494  : 						pDphsettar->gencoartic = 0;
; 495  : 						pDph_t->arg3 = L;
; 496  : 					}
; 497  : 
; 498  : 				}
; 499  : #endif
; 500  : 				/* eab 4/2/7/98 f2 needs some dropping in these contexts*/
; 501  : 				if (pDphsettar->phcur == RR && (pDphsettar->phonex == U))
; 502  : 						if (pDphsettar->np == &PF2)
; 503  : 						{
; 504  : 							pDphsettar->np->tarcur -= 300;
; 505  : 						}
; 506  : 					
; 507  : #ifdef RRULES
; 508  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 509  : 				/* special coarticulation rules for uvular R (RR)           */
; 510  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 511  : 				else if ((pDphsettar->phcur == RR))
; 512  : 				{
; 513  : 					pDphsettar->gencoartic = N20PRCNT;
; 514  : 					pDph_t->arg3 = 0;
; 515  : 					if (begtyp[pDphsettar->phonex] == 1)
; 516  : 					{
; 517  : 						pDphsettar->gencoartic += N10PRCNT;
; 518  : 						pDph_t->arg3 = L;
; 519  : 					}
; 520  : 					if (endtyp[pDphsettar->phonex] == 1)
; 521  : 					{
; 522  : 						pDphsettar->gencoartic += N30PRCNT;
; 523  : 						pDph_t->arg3 = R;
; 524  : 					}
; 525  : 
; 526  : 				}
; 527  : #endif
; 528  : 				else
; 529  : 				{                                          /* standard dt3 treatment */
; 530  : #endif  /* #ifdef GERMAN */
; 531  : 				if ((struccur & FSTRESS) IS_MINUS)

  00186	8a 44 24 10	 mov	 al, BYTE PTR _struccur$[esp+60]
  0018a	a8 03		 test	 al, 3
  0018c	75 16		 jne	 SHORT $L71858

; 532  : 				{
; 533  : 					/* Increased coarticulation, especially F2, if unstressed */
; 534  : 					pDphsettar->gencoartic = N15PRCNT;
; 535  : 					if (pDphsettar->np == &PF2)

  0018e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00191	8d 47 48	 lea	 eax, DWORD PTR [edi+72]
  00194	3b c8		 cmp	 ecx, eax
  00196	66 c7 46 0c 99
	09		 mov	 WORD PTR [esi+12], 2457	; 00000999H
  0019c	75 06		 jne	 SHORT $L71858

; 536  : 					{
; 537  : 						pDphsettar->gencoartic = N25PRCNT;

  0019e	66 c7 46 0c 00
	10		 mov	 WORD PTR [esi+12], 4096	; 00001000H
$L71858:

; 538  : 					}
; 539  : 				} 
; 540  : #ifdef GERMAN
; 541  : 				}
; 542  : 				/* end of else, standard dt3 treatment */
; 543  : 				if (pDphsettar->np->tarnex <= 0)
; 544  : 				{
; 545  : 					pDph_t->arg1 = pDphsettar->np->tarlas - pDphsettar->np->tarcur;
; 546  : 				}
; 547  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 548  : 				/* german R-coarticulation only with previous phonemes      */
; 549  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 550  : 				else if (pDph_t->arg3 == R)
; 551  : 				{
; 552  : 					pDph_t->arg1 = pDphsettar->np->tarlas - pDphsettar->np->tarcur;
; 553  : 
; 554  : 				}
; 555  : 
; 556  : #ifdef LRULES
; 557  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 558  : 				/* most german L-coarticulation only with next phonemes     */
; 559  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 560  : 				else if (pDph_t->arg3 == L)
; 561  : 				{
; 562  : 					pDph_t->arg1 = pDphsettar->np->tarnex - pDphsettar->np->tarcur;
; 563  : 
; 564  : 				}
; 565  : #endif
; 566  : 				else
; 567  : 				{
; 568  : #endif /* #ifdef GERMAN */                              
; 569  : 				pDph_t->arg1 = ((pDphsettar->np->tarlas + pDphsettar->np->tarnex) >> 1) - pDphsettar->np->tarcur;

  001a4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  001a7	0f bf 50 18	 movsx	 edx, WORD PTR [eax+24]
  001ab	0f bf 48 16	 movsx	 ecx, WORD PTR [eax+22]
  001af	03 d1		 add	 edx, ecx
  001b1	d1 fa		 sar	 edx, 1
  001b3	66 2b 10	 sub	 dx, WORD PTR [eax]
  001b6	66 89 97 f8 14
	00 00		 mov	 WORD PTR [edi+5368], dx

; 570  : #ifdef GERMAN
; 571  : 				}
; 572  : #endif
; 573  : 				pDph_t->arg2 = pDphsettar->gencoartic;

  001bd	66 8b 46 0c	 mov	 ax, WORD PTR [esi+12]
  001c1	66 89 87 fa 14
	00 00		 mov	 WORD PTR [edi+5370], ax

; 574  : 				pDphsettar->np->tarcur += mlsh1 (pDph_t->arg1, pDph_t->arg2);

  001c8	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  001cb	0f bf d0	 movsx	 edx, ax
  001ce	0f bf 87 f8 14
	00 00		 movsx	 eax, WORD PTR [edi+5368]
  001d5	0f af d0	 imul	 edx, eax
  001d8	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  001db	66 01 11	 add	 WORD PTR [ecx], dx
$L71856:

; 575  : 			}
; 576  : 			pDphsettar->np->tarend = pDphsettar->np->tarcur;        /* Tar at end of cur phone */

  001de	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  001e1	66 8b 08	 mov	 cx, WORD PTR [eax]
  001e4	66 89 48 1a	 mov	 WORD PTR [eax+26], cx
$L71855:

; 577  : 		}
; 578  : 		/* end of 'else' begun in rule 3 */
; 579  : 
; 580  : 		/* 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 */
; 581  : 		/* Compute (approx.) general coartic of tarnex with tarend         */
; 582  : 		/* THIS IS BAD, FIX IT IF POSSIBLE                                 */
; 583  : 		/* 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 */
; 584  : 		if (pDphsettar->par_type IS_FORM_FREQ)

  001e8	80 7e 14 03	 cmp	 BYTE PTR [esi+20], 3
  001ec	75 32		 jne	 SHORT $L71859

; 585  : 		{
; 586  : 			pDph_t->arg2 = N10PRCNT;

  001ee	66 c7 87 fa 14
	00 00 66 06	 mov	 WORD PTR [edi+5370], 1638 ; 00000666H

; 587  : #ifdef GERMAN
; 588  : 			pDph_t->arg3 = 0;
; 589  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 590  : 			/* special german coarticulation rules             */
; 591  : 			/* /R/-coarticulation rules after vowel                */
; 592  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 593  : 			if ((pDphsettar->phonex == R) && (pDphsettar->phcur != EX) &&
; 594  : 				((feacur & FVOWEL) IS_PLUS))
; 595  : 			{
; 596  : 				pDph_t->arg2 = N20PRCNT;
; 597  : 				pDph_t->arg3 = R;
; 598  : 
; 599  : 			}
; 600  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 601  : 			/* special rule for '@r' suffix                    */
; 602  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 603  : 			else if ((pDphsettar->phcur == EX) && (pDphsettar->phonex == R))
; 604  : 			{
; 605  : 				pDph_t->arg2 = 0;
; 606  : 				pDph_t->arg3 = R;
; 607  : 
; 608  : 			}
; 609  : 
; 610  : #ifdef LRULES
; 611  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 612  : 			/* special german coarticulation rules, if next phoneme is 'L' */
; 613  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 614  : 			else if (pDphsettar->phonex == L)
; 615  : 			{
; 616  : 				if (((featb[phonp2] & FVOWEL) IS_PLUS) &&
; 617  : 					((begtyp[phonp2] != 2) &&
; 618  : 					 (begtyp[phonp2] != 6) &&
; 619  : 					 !((endtyp[pDphsettar->phcur] != 1) &&
; 620  : 					   (begtyp[phonp2] == 1))))
; 621  : 				{
; 622  : 					if (pDphsettar->np == &PF1)
; 623  : 					{
; 624  : 						pDph_t->arg2 = N30PRCNT;
; 625  : 					}
; 626  : 					else
; 627  : 					{
; 628  : 						pDph_t->arg2 = N50PRCNT;
; 629  : 					}
; 630  : 					pDph_t->arg3 = L;
; 631  : 				}
; 632  : 				else if ((endtyp[pDphsettar->phcur] == 1) ||
; 633  : 						 ((endtyp[pDphsettar->phcur] == 2) ||
; 634  : 						  (endtyp[pDphsettar->phcur] == 6)))
; 635  : 				{
; 636  : 					if (pDphsettar->np == &PF1)
; 637  : 					{
; 638  : 						pDph_t->arg2 = N20PRCNT;        /* n40prcnt, eab 5/95  */
; 639  : 					}
; 640  : 					else
; 641  : 					{
; 642  : 						pDph_t->arg2 = N20PRCNT;        /* n50prcnt, eab 5/95 */
; 643  : 					}
; 644  : 					pDph_t->arg3 = R;
; 645  : 				}
; 646  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 647  : 				/* make 'L' audible in 'schwa'-'L'-'nasal' cluster          */
; 648  : 				/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 649  : 				else if ((pDphsettar->phcur == EX) &&
; 650  : 						 ((featb[phonp2] & FNASAL) IS_PLUS))
; 651  : 				{
; 652  : 					if (pDphsettar->np == &PF1)
; 653  : 					{
; 654  : 						pDphsettar->np->tarnex -= 0;
; 655  : 					}
; 656  : 					else if (pDphsettar->np == &PF2)
; 657  : 					{
; 658  : 						pDphsettar->np->tarnex += 200;
; 659  : 					}
; 660  : 					pDph_t->arg2 = 0;
; 661  : 					pDph_t->arg3 = L;
; 662  : 				}
; 663  : 
; 664  : 			}
; 665  : #endif
; 666  : 
; 667  : #ifdef RRULES
; 668  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 669  : 			/* special coarticulation rules for uvular R (RR)          */
; 670  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 671  : 			else if ((pDphsettar->phonex == RR))
; 672  : 			{
; 673  : 				pDph_t->arg2 = N20PRCNT;
; 674  : 				pDph_t->arg3 = 0;
; 675  : 				if (begtyp[phonp2] == 1)
; 676  : 				{
; 677  : 					pDph_t->arg2 += N10PRCNT;
; 678  : 					pDph_t->arg3 = L;
; 679  : 				}
; 680  : 				if (endtyp[phonp2] == 1)
; 681  : 				{
; 682  : 					pDph_t->arg2 += N30PRCNT;
; 683  : 					pDph_t->arg3 = R;
; 684  : 				}
; 685  : 
; 686  : 			}
; 687  : #endif
; 688  : 			else
; 689  : 			{                                                  /* standard dt3 treatment */
; 690  : 				if ((struccur & FSTRESS) IS_MINUS)
; 691  : 				{
; 692  : 					/* Increased coarticulation, especially F2, if unstressed */
; 693  : 					pDph_t->arg2 = N15PRCNT;
; 694  : 					if (pDphsettar->np == &PF2)
; 695  : 					{
; 696  : 						pDph_t->arg2 = N25PRCNT;
; 697  : 					}
; 698  : 				}
; 699  : 			}
; 700  : 			/* end of else, standard dt3 treatment */
; 701  : 			if (pDphsettar->np->tarnex <= 0)
; 702  : 			{
; 703  : 				pDph_t->arg1 = pDphsettar->np->tarend;
; 704  : 			}
; 705  : 
; 706  : #ifdef LRULES
; 707  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 708  : 			/* some german L-coarticulation rules with second next phonemes    */
; 709  : 			/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 710  : 			else if (pDph_t->arg3 == L)
; 711  : 			{
; 712  : 				pDph_t->arg1 = pDphsettar->np->tarend - getbegtar (phTTS,pDph_t->nphone + 2);
; 713  : 				/* Calls gettar() */
; 714  : 
; 715  : 			}
; 716  : #endif
; 717  : 			else
; 718  : 			{
; 719  : #endif /* #ifdef GERMAN */
; 720  : 				pDph_t->arg1 = pDphsettar->np->tarend - pDphsettar->np->tarnex;

  001f7	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  001fa	66 8b 41 1a	 mov	 ax, WORD PTR [ecx+26]
  001fe	66 2b 41 16	 sub	 ax, WORD PTR [ecx+22]
  00202	66 89 87 f8 14
	00 00		 mov	 WORD PTR [edi+5368], ax

; 721  : #ifdef GERMAN
; 722  : 		}
; 723  : #endif
; 724  : 			pDphsettar->np->tarnex += mlsh1 (pDph_t->arg1, pDph_t->arg2);

  00209	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0020c	0f bf d0	 movsx	 edx, ax
  0020f	0f bf 87 fa 14
	00 00		 movsx	 eax, WORD PTR [edi+5370]
  00216	0f af d0	 imul	 edx, eax
  00219	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  0021c	66 01 51 16	 add	 WORD PTR [ecx+22], dx
$L71859:

; 725  : 		}
; 726  : 		/*WINprintf("pholas=%d  pDphsettar->phcur=%d  pDphsettar->phonex=%d \n",
; 727  : 	  pholas, pDphsettar->phcur, pDphsettar->phonex); */
; 728  : 		
; 729  : 
; 730  : 		/* 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 */
; 731  : 		/* Smooth forward from beginning of current phone            */
; 732  : 		/* Default bouval is halfway, half of transition duration is 30 ms */
; 733  : 		/* 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 */
; 734  : 
; 735  : 		pDphsettar->bouval = (pDphsettar->np->tarlas + pDphsettar->np->tarcur) >> 1;

  00220	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00223	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  00227	0f bf 10	 movsx	 edx, WORD PTR [eax]
  0022a	03 ca		 add	 ecx, edx

; 736  : 		pDphsettar->durtran = NF30MS;

  0022c	66 c7 46 06 05
	00		 mov	 WORD PTR [esi+6], 5
  00232	d1 f9		 sar	 ecx, 1
  00234	66 89 0e	 mov	 WORD PTR [esi], cx

; 737  : 		/* 
; 738  : 		 * printf("pDph_t->shrif %d, pholas %d, fealas %d, feacur %d, struclas %d, struccur %d, 
; 739  : 		 * feanex %d\n",pDph_t->shrif, pholas,fealas, feacur, struclas, struccur,feanex);
; 740  : 		 */
; 741  : 		forw_smooth_rules (phTTS, pDph_t->shrif, pholas,
; 742  : 						   fealas, feacur, struclas, struccur,feanex);          /* This routine contains all the "smarts" */

  00237	8b 44 24 14	 mov	 eax, DWORD PTR _feanex$[esp+60]
  0023b	8b 4c 24 10	 mov	 ecx, DWORD PTR _struccur$[esp+60]
  0023f	8b 54 24 1c	 mov	 edx, DWORD PTR _struclas$[esp+60]
  00243	50		 push	 eax
  00244	8b 44 24 1c	 mov	 eax, DWORD PTR _feacur$[esp+64]
  00248	51		 push	 ecx
  00249	8b 4c 24 2c	 mov	 ecx, DWORD PTR _fealas$[esp+68]
  0024d	52		 push	 edx
  0024e	8b 54 24 2c	 mov	 edx, DWORD PTR _pholas$[esp+72]
  00252	50		 push	 eax
  00253	66 8b 87 ba 2b
	00 00		 mov	 ax, WORD PTR [edi+11194]
  0025a	51		 push	 ecx
  0025b	52		 push	 edx
  0025c	50		 push	 eax
  0025d	55		 push	 ebp
  0025e	e8 00 00 00 00	 call	 _forw_smooth_rules

; 743  : 		 
; 744  : 	/*	 printf("forward durtran %d tarend %d tarlas %d bouval %d tbacktr %d\n",
; 745  : 		  pDphsettar->durtran, pDphsettar->np->tarend,pDphsettar->np->tarlas,
; 746  : 		  pDphsettar->bouval, pDphsettar->np->tbacktr); 
; 747  : 	*/	 
; 748  : 
; 749  : 		/* Convert bouval and pDphsettar->durtran into params used directly by phdraw() */
; 750  : 		pDphsettar->np->ftran = 0;

  00263	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00266	83 c4 20	 add	 esp, 32			; 00000020H
  00269	66 89 59 08	 mov	 WORD PTR [ecx+8], bx

; 751  : 		if (pDphsettar->durtran > 0)

  0026d	66 39 5e 06	 cmp	 WORD PTR [esi+6], bx
  00271	7e 5d		 jle	 SHORT $L71861

; 752  : 		{
; 753  : 			/* Incremental change per frame                        */
; 754  : 			/* (shift left 3 bits to avoid roundoff accumulation)  */
; 755  : 			pDphsettar->np->ftran = (pDphsettar->bouval - pDphsettar->np->tarcur) << 3;

  00273	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00276	66 8b 16	 mov	 dx, WORD PTR [esi]
  00279	66 2b 10	 sub	 dx, WORD PTR [eax]
  0027c	c1 e2 03	 shl	 edx, 3
  0027f	66 89 50 08	 mov	 WORD PTR [eax+8], dx

; 756  : 			if (pDphsettar->np->ftran != 0)

  00283	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00286	66 8b 40 08	 mov	 ax, WORD PTR [eax+8]
  0028a	66 3b c3	 cmp	 ax, bx
  0028d	74 41		 je	 SHORT $L71861

; 757  : 			{
; 758  : 				pDph_t->arg1 = pDphsettar->np->ftran;

  0028f	66 89 87 f8 14
	00 00		 mov	 WORD PTR [edi+5368], ax

; 759  : 				pDph_t->arg2 = divtab[pDphsettar->durtran];

  00296	0f bf 4e 06	 movsx	 ecx, WORD PTR [esi+6]
  0029a	66 8b 04 4d 00
	00 00 00	 mov	 ax, WORD PTR _divtab[ecx*2]
  002a2	66 89 87 fa 14
	00 00		 mov	 WORD PTR [edi+5370], ax

; 760  : 				pDphsettar->np->dftran = mlsh1 (pDph_t->arg1, pDph_t->arg2);

  002a9	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  002ac	0f bf d0	 movsx	 edx, ax
  002af	0f bf 87 f8 14
	00 00		 movsx	 eax, WORD PTR [edi+5368]
  002b6	0f af d0	 imul	 edx, eax
  002b9	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  002bc	66 89 51 0a	 mov	 WORD PTR [ecx+10], dx

; 761  : 				pDphsettar->np->ftran = pDphsettar->np->dftran * pDphsettar->durtran;

  002c0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  002c3	66 8b 50 0a	 mov	 dx, WORD PTR [eax+10]
  002c7	66 0f af 56 06	 imul	 dx, WORD PTR [esi+6]
  002cc	66 89 50 08	 mov	 WORD PTR [eax+8], dx
$L71861:

; 762  : 			}
; 763  : 		}
; 764  : 		//debugforward (" Unknown rule must have been executed", pDphsettar->np);
; 765  : 
; 766  : 		/* Slowish vowel-vowel formant motions across consonant modeled by   */
; 767  : 		/* a separate transition increment and duration, so far only for F2 */
; 768  : 		/* (vvbouval and vvdurtran set in routine forw_smooth_rules() which */
; 769  : 		/* calls setloc() which calls vv_coartic_across_c())                  */
; 770  : 		if (pDphsettar->np == &PF2)

  002d0	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  002d3	8d 47 48	 lea	 eax, DWORD PTR [edi+72]
  002d6	3b c8		 cmp	 ecx, eax
  002d8	75 76		 jne	 SHORT $L71862

; 771  : 		{
; 772  : 			pDph_t->fvvtran = 0;
; 773  : 			pDph_t->dfvvtran = 0;
; 774  : 			/* Truncate tran dur if exceeds duration of current phone */
; 775  : 			if (pDphsettar->vvdurtran > pDph_t->durfon)

  002da	66 8b 87 e0 14
	00 00		 mov	 ax, WORD PTR [edi+5344]
  002e1	66 89 9f 60 03
	00 00		 mov	 WORD PTR [edi+864], bx
  002e8	66 89 9f 66 03
	00 00		 mov	 WORD PTR [edi+870], bx
  002ef	66 39 46 08	 cmp	 WORD PTR [esi+8], ax
  002f3	7e 04		 jle	 SHORT $L71863

; 776  : 				pDphsettar->vvdurtran = pDph_t->durfon;

  002f5	66 89 46 08	 mov	 WORD PTR [esi+8], ax
$L71863:

; 777  : 			if ((pDphsettar->vvdurtran > 0) && (pDphsettar->vvbouval != 0))

  002f9	66 39 5e 08	 cmp	 WORD PTR [esi+8], bx
  002fd	7e 49		 jle	 SHORT $L71864
  002ff	66 8b 46 04	 mov	 ax, WORD PTR [esi+4]
  00303	66 3b c3	 cmp	 ax, bx
  00306	74 40		 je	 SHORT $L71864

; 778  : 			{
; 779  : 				/* Shift left 3 bits to avoid roundoff accumulation */
; 780  : 				pDph_t->arg1 = pDphsettar->vvbouval << 3;

  00308	c1 e0 03	 shl	 eax, 3
  0030b	66 89 87 f8 14
	00 00		 mov	 WORD PTR [edi+5368], ax

; 781  : 				pDph_t->arg2 = divtab[pDphsettar->vvdurtran];

  00312	0f bf 4e 08	 movsx	 ecx, WORD PTR [esi+8]

; 782  : 				pDph_t->dfvvtran = mlsh1 (pDph_t->arg1, pDph_t->arg2);  /* pDphsettar->vvbouval*8 / pDphsettar->vvdurtran */

  00316	0f bf 97 f8 14
	00 00		 movsx	 edx, WORD PTR [edi+5368]
  0031d	66 8b 04 4d 00
	00 00 00	 mov	 ax, WORD PTR _divtab[ecx*2]
  00325	66 89 87 fa 14
	00 00		 mov	 WORD PTR [edi+5370], ax
  0032c	0f bf c0	 movsx	 eax, ax
  0032f	0f af c2	 imul	 eax, edx
  00332	c1 f8 0e	 sar	 eax, 14			; 0000000eH
  00335	66 89 87 66 03
	00 00		 mov	 WORD PTR [edi+870], ax

; 783  : 				pDph_t->fvvtran = pDph_t->dfvvtran * pDphsettar->vvdurtran;

  0033c	66 0f af 46 08	 imul	 ax, WORD PTR [esi+8]
  00341	66 89 87 60 03
	00 00		 mov	 WORD PTR [edi+864], ax
$L71864:

; 784  : 			}
; 785  : 			pDphsettar->vvdurtran = 0;

  00348	66 89 5e 08	 mov	 WORD PTR [esi+8], bx

; 786  : 			pDphsettar->vvbouval = 0;

  0034c	66 89 5e 04	 mov	 WORD PTR [esi+4], bx
$L71862:

; 787  : 		}
; 788  : 		/* 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 */
; 789  : 		/* Smooth backward from end of current phone                               */
; 790  : 		/* Default bouval is halfway, half of transition duration is 30 ms                 */
; 791  : 		/* 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 */
; 792  : 
; 793  : 		pDphsettar->bouval = (pDphsettar->np->tarend + pDphsettar->np->tarnex) >> 1;

  00350	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00353	0f bf 48 1a	 movsx	 ecx, WORD PTR [eax+26]
  00357	0f bf 50 16	 movsx	 edx, WORD PTR [eax+22]
  0035b	03 ca		 add	 ecx, edx

; 794  : 		pDphsettar->durtran = NF25MS;

  0035d	66 c7 46 06 04
	00		 mov	 WORD PTR [esi+6], 4
  00363	d1 f9		 sar	 ecx, 1
  00365	66 89 0e	 mov	 WORD PTR [esi], cx

; 795  : 
; 796  : 		/* 
; 797  : 		 * printf("pDph_t->shrib %d, pDphsettar->phcur %d feacur %d, feanex %d, 
; 798  : 		 * strucnex %d\n",pDph_t->shrib, pDphsettar->phcur, feacur, feanex, strucnex); 
; 799  : 		 */
; 800  : 		/* This routine contains all the "smarts" */
; 801  : 		back_smooth_rules (phTTS, pDph_t->shrib, feacur, feanex, strucnex);     

  00368	8b 44 24 2c	 mov	 eax, DWORD PTR _strucnex$[esp+60]
  0036c	8b 4c 24 14	 mov	 ecx, DWORD PTR _feanex$[esp+60]
  00370	8b 54 24 18	 mov	 edx, DWORD PTR _feacur$[esp+60]
  00374	50		 push	 eax
  00375	66 8b 87 bc 2b
	00 00		 mov	 ax, WORD PTR [edi+11196]
  0037c	51		 push	 ecx
  0037d	52		 push	 edx
  0037e	50		 push	 eax
  0037f	55		 push	 ebp
  00380	e8 00 00 00 00	 call	 _back_smooth_rules

; 802  : 		
; 803  : 		 /*
; 804  : 		  printf("backward durtran %d tarend %d tarlas %d bouval %d tbacktr %d\n",
; 805  : 		  pDphsettar->durtran, 
; 806  : 		  pDphsettar->np->tarend,pDphsettar->np->tarlas,pDphsettar->bouval, 
; 807  : 		  pDphsettar->np->tbacktr);
; 808  : 		 */
; 809  : 
; 810  : 		/* Convert bouval and pDphsettar->durtran into params used directly by phdraw() */
; 811  : 		pDphsettar->np->btran = 0;

  00385	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00388	83 c4 14	 add	 esp, 20			; 00000014H
  0038b	66 89 59 0c	 mov	 WORD PTR [ecx+12], bx

; 812  : 		pDphsettar->np->dbtran = 0;

  0038f	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00392	66 89 5a 0e	 mov	 WORD PTR [edx+14], bx

; 813  : 		if (pDphsettar->durtran > 0)

  00396	66 39 5e 06	 cmp	 WORD PTR [esi+6], bx
  0039a	7e 43		 jle	 SHORT $L71866

; 814  : 		{
; 815  : 			/* Shift left 3 bits to avoid roundoff accumulation */
; 816  : 			temp = (pDphsettar->bouval - pDphsettar->np->tarend) << 3;

  0039c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0039f	66 8b 06	 mov	 ax, WORD PTR [esi]
  003a2	66 2b 41 1a	 sub	 ax, WORD PTR [ecx+26]
  003a6	c1 e0 03	 shl	 eax, 3

; 817  : 			if (temp != 0)

  003a9	66 3b c3	 cmp	 ax, bx
  003ac	74 31		 je	 SHORT $L71866

; 818  : 			{
; 819  : 				pDph_t->arg1 = temp;

  003ae	66 89 87 f8 14
	00 00		 mov	 WORD PTR [edi+5368], ax

; 820  : 				pDph_t->arg2 = divtab[pDphsettar->durtran];

  003b5	0f bf 56 06	 movsx	 edx, WORD PTR [esi+6]

; 821  : 				pDphsettar->np->dbtran = mlsh1 (pDph_t->arg1, pDph_t->arg2);

  003b9	0f bf 8f f8 14
	00 00		 movsx	 ecx, WORD PTR [edi+5368]
  003c0	66 8b 04 55 00
	00 00 00	 mov	 ax, WORD PTR _divtab[edx*2]
  003c8	66 89 87 fa 14
	00 00		 mov	 WORD PTR [edi+5370], ax
  003cf	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  003d2	0f bf c0	 movsx	 eax, ax
  003d5	0f af c1	 imul	 eax, ecx
  003d8	c1 f8 0e	 sar	 eax, 14			; 0000000eH
  003db	66 89 42 0e	 mov	 WORD PTR [edx+14], ax
$L71866:

; 822  : 			}
; 823  : 		}
; 824  : 		//debugbackward (" Unknown rule must have been executed", pDphsettar->np);
; 825  : 
; 826  : 		/* Slowish vowel-vowel formant motions across consonant modeled by   */
; 827  : 		/* a separate transition increment and duration, so far only for F2 */
; 828  : 		/* (vvbouval and pDphsettar->vvdurtran set in routine back_smooth_rules() which */
; 829  : 		/* calls setloc() which calls vv_coartic_across_c())                  */
; 830  : 		if (pDphsettar->np == &PF2)

  003df	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  003e2	8d 47 48	 lea	 eax, DWORD PTR [edi+72]
  003e5	3b c8		 cmp	 ecx, eax
  003e7	0f 85 83 00 00
	00		 jne	 $L71852

; 831  : 		{
; 832  : 			pDph_t->bvvtran = 0;       /* Default if no vv-coartic */
; 833  : 			pDph_t->dbvvtran = 0;      /* Default if no vv-coartic */
; 834  : 			pDph_t->tvvbacktr = pDph_t->durfon;             /* Default if no vv-coartic */

  003ed	66 8b 87 e0 14
	00 00		 mov	 ax, WORD PTR [edi+5344]
  003f4	66 89 9f 62 03
	00 00		 mov	 WORD PTR [edi+866], bx
  003fb	66 89 9f 68 03
	00 00		 mov	 WORD PTR [edi+872], bx
  00402	66 89 87 64 03
	00 00		 mov	 WORD PTR [edi+868], ax

; 835  : 			/* Truncate tran dur if exceeds duration of current phone */
; 836  : 			if (pDphsettar->vvdurtran > pDph_t->durfon)

  00409	66 39 46 08	 cmp	 WORD PTR [esi+8], ax
  0040d	7e 04		 jle	 SHORT $L71868

; 837  : 				pDphsettar->vvdurtran = pDph_t->durfon;

  0040f	66 89 46 08	 mov	 WORD PTR [esi+8], ax
$L71868:

; 838  : 			if ((pDphsettar->vvdurtran > 0) && (pDphsettar->vvbouval != 0))

  00413	66 8b 46 08	 mov	 ax, WORD PTR [esi+8]
  00417	66 3b c3	 cmp	 ax, bx
  0041a	7e 4c		 jle	 SHORT $L71869
  0041c	66 39 5e 04	 cmp	 WORD PTR [esi+4], bx
  00420	74 46		 je	 SHORT $L71869

; 839  : 			{
; 840  : 				pDph_t->tvvbacktr = pDph_t->durfon - pDphsettar->vvdurtran;

  00422	66 8b 8f e0 14
	00 00		 mov	 cx, WORD PTR [edi+5344]
  00429	66 2b c8	 sub	 cx, ax
  0042c	66 89 8f 64 03
	00 00		 mov	 WORD PTR [edi+868], cx

; 841  : 				/* Shift left 3 bits to avoid roundoff accumulation */
; 842  : 				pDph_t->arg1 = pDphsettar->vvbouval << 3;

  00433	66 8b 56 04	 mov	 dx, WORD PTR [esi+4]
  00437	66 c1 e2 03	 shl	 dx, 3
  0043b	66 89 97 f8 14
	00 00		 mov	 WORD PTR [edi+5368], dx

; 843  : 				pDph_t->arg2 = divtab[pDphsettar->vvdurtran];

  00442	0f bf 46 08	 movsx	 eax, WORD PTR [esi+8]

; 844  : 				pDph_t->dbvvtran = mlsh1 (pDph_t->arg1, pDph_t->arg2);  /* vvbouval*8 / pDphsettar->vvdurtran */

  00446	0f bf d2	 movsx	 edx, dx
  00449	66 8b 04 45 00
	00 00 00	 mov	 ax, WORD PTR _divtab[eax*2]
  00451	0f bf c8	 movsx	 ecx, ax
  00454	0f af ca	 imul	 ecx, edx
  00457	c1 f9 0e	 sar	 ecx, 14			; 0000000eH
  0045a	66 89 87 fa 14
	00 00		 mov	 WORD PTR [edi+5370], ax
  00461	66 89 8f 68 03
	00 00		 mov	 WORD PTR [edi+872], cx
$L71869:

; 845  : 			}
; 846  : 			pDphsettar->vvdurtran = 0;

  00468	66 89 5e 08	 mov	 WORD PTR [esi+8], bx

; 847  : 			pDphsettar->vvbouval = 0;

  0046c	66 89 5e 04	 mov	 WORD PTR [esi+4], bx
$L71852:
  00470	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00473	8d 87 40 02 00
	00		 lea	 eax, DWORD PTR [edi+576]
  00479	83 c2 24	 add	 edx, 36			; 00000024H
  0047c	8b ca		 mov	 ecx, edx
  0047e	89 56 10	 mov	 DWORD PTR [esi+16], edx
  00481	3b c8		 cmp	 ecx, eax
  00483	0f 86 46 fc ff
	ff		 jbe	 $L71851
$L71853:

; 848  : 		}
; 849  : 	}
; 850  : 	/* 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 */
; 851  : 	/* Special rules that override values computed in regular way.          */
; 852  : 	/* From the beginning of the current phone to a time "tspesh",          */
; 853  : 	/* place the constant value "pspesh" in the given parameter track.      */
; 854  : 	/* (Used to generate bursts, aspiration for [ptk], voicebar for [bdg]) */
; 855  : 	/* 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 */
; 856  : 
; 857  : 	special_rules (phTTS, fealas, feacur, feanex, struclm2, struccur, pholas, struclas);

  00489	8b 44 24 1c	 mov	 eax, DWORD PTR _struclas$[esp+60]
  0048d	8b 4c 24 20	 mov	 ecx, DWORD PTR _pholas$[esp+60]
  00491	8b 54 24 10	 mov	 edx, DWORD PTR _struccur$[esp+60]
  00495	50		 push	 eax
  00496	8b 44 24 34	 mov	 eax, DWORD PTR _struclm2$[esp+64]
  0049a	51		 push	 ecx
  0049b	8b 4c 24 1c	 mov	 ecx, DWORD PTR _feanex$[esp+68]
  0049f	52		 push	 edx
  004a0	8b 54 24 24	 mov	 edx, DWORD PTR _feacur$[esp+72]
  004a4	50		 push	 eax
  004a5	8b 44 24 34	 mov	 eax, DWORD PTR _fealas$[esp+76]
  004a9	51		 push	 ecx
  004aa	8b 4c 24 54	 mov	 ecx, DWORD PTR _phTTS$[esp+76]
  004ae	52		 push	 edx
  004af	50		 push	 eax
  004b0	51		 push	 ecx
  004b1	e8 00 00 00 00	 call	 _special_rules
  004b6	83 c4 20	 add	 esp, 32			; 00000020H
  004b9	5f		 pop	 edi
  004ba	5e		 pop	 esi
  004bb	5d		 pop	 ebp
  004bc	5b		 pop	 ebx

; 858  : }

  004bd	83 c4 2c	 add	 esp, 44			; 0000002cH
  004c0	c3		 ret	 0
_phsettar ENDP
_TEXT	ENDS
EXTRN	_featb:BYTE
EXTRN	_place:BYTE
EXTRN	_begtyp:BYTE
EXTRN	_endtyp:BYTE
EXTRN	_ptram:BYTE
EXTRN	_parini:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_nphone_temp$ = 12
_phone_temp$ = 12
_phlas_temp$ = 8
_phnex_temp$ = -12
_tartemp$ = 12
_npar$ = -8
_pDphsettar$ = -4
_gettar	PROC NEAR

; 69   : {

  004d0	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 70   : 	short                   phone_temp, phlas_temp, phnex_temp, tartemp, pphotr, begtypnex, npar;
; 71   : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  004d3	8b 44 24 10	 mov	 eax, DWORD PTR _phTTS$[esp+8]
  004d7	53		 push	 ebx
  004d8	55		 push	 ebp
  004d9	56		 push	 esi
  004da	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  004dd	57		 push	 edi

; 72   : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 73   : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;

  004de	8b 81 d0 2b 00
	00		 mov	 eax, DWORD PTR [ecx+11216]
  004e4	89 44 24 18	 mov	 DWORD PTR _pDphsettar$[esp+28], eax

; 74   : 
; 75   : 	npar = pDphsettar->np - &PF1;

  004e8	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]
  004eb	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  004f0	8b d3		 mov	 edx, ebx
  004f2	2b d1		 sub	 edx, ecx
  004f4	83 ea 24	 sub	 edx, 36			; 00000024H
  004f7	f7 ea		 imul	 edx
  004f9	c1 fa 03	 sar	 edx, 3
  004fc	8b c2		 mov	 eax, edx
  004fe	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00501	03 d0		 add	 edx, eax
  00503	8b c2		 mov	 eax, edx

; 76   : 	if (pDphsettar->np < &PFZ)                      

  00505	8d 91 90 00 00
	00		 lea	 edx, DWORD PTR [ecx+144]
  0050b	3b da		 cmp	 ebx, edx
  0050d	89 44 24 14	 mov	 DWORD PTR _npar$[esp+28], eax

; 77   : 		pphotr = (npar) * TOT_ALLOPHONES;

  00511	8d 14 c0	 lea	 edx, DWORD PTR [eax+eax*8]
  00514	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  00517	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  0051a	72 04		 jb	 SHORT $L71379

; 78   : 	else
; 79   : 		pphotr = (npar - 1) * TOT_ALLOPHONES;

  0051c	8d 7c 40 c7	 lea	 edi, DWORD PTR [eax+eax*2-57]
$L71379:

; 80   : 		/* No table entries for PAP parameter */
; 81   : 
; 82   : 	phlas_temp = get_phone (pDph_t, nphone_temp - 1);

  00520	66 8b 74 24 24	 mov	 si, WORD PTR _nphone_temp$[esp+24]
  00525	0f bf ee	 movsx	 ebp, si
  00528	8d 45 ff	 lea	 eax, DWORD PTR [ebp-1]
  0052b	85 c0		 test	 eax, eax
  0052d	7c 1a		 jl	 SHORT $L71990
  0052f	0f bf 91 e2 14
	00 00		 movsx	 edx, WORD PTR [ecx+5346]
  00536	3b c2		 cmp	 eax, edx
  00538	7d 0f		 jge	 SHORT $L71990
  0053a	66 8b 84 69 c4
	03 00 00	 mov	 ax, WORD PTR [ecx+ebp*2+964]
  00542	66 89 44 24 20	 mov	 WORD PTR _phlas_temp$[esp+24], ax
  00547	eb 08		 jmp	 SHORT $L71991
$L71990:
  00549	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _phlas_temp$[esp+24], 0
$L71991:

; 83   : 	phone_temp = get_phone (pDph_t, nphone_temp);

  00551	33 d2		 xor	 edx, edx
  00553	66 3b f2	 cmp	 si, dx
  00556	7c 18		 jl	 SHORT $L71992
  00558	66 3b b1 e2 14
	00 00		 cmp	 si, WORD PTR [ecx+5346]
  0055f	7d 0f		 jge	 SHORT $L71992
  00561	66 8b 84 69 c6
	03 00 00	 mov	 ax, WORD PTR [ecx+ebp*2+966]
  00569	66 89 44 24 24	 mov	 WORD PTR _phone_temp$[esp+24], ax
  0056e	eb 04		 jmp	 SHORT $L71993
$L71992:
  00570	89 54 24 24	 mov	 DWORD PTR _phone_temp$[esp+24], edx
$L71993:

; 84   : 	phnex_temp = get_phone (pDph_t, nphone_temp + 1);

  00574	8d 45 01	 lea	 eax, DWORD PTR [ebp+1]
  00577	3b c2		 cmp	 eax, edx
  00579	7c 1a		 jl	 SHORT $L71994
  0057b	0f bf b1 e2 14
	00 00		 movsx	 esi, WORD PTR [ecx+5346]
  00582	3b c6		 cmp	 eax, esi
  00584	7d 0f		 jge	 SHORT $L71994
  00586	66 8b 94 69 c8
	03 00 00	 mov	 dx, WORD PTR [ecx+ebp*2+968]
  0058e	66 89 54 24 10	 mov	 WORD PTR _phnex_temp$[esp+28], dx
  00593	eb 04		 jmp	 SHORT $L71995
$L71994:
  00595	89 54 24 10	 mov	 DWORD PTR _phnex_temp$[esp+28], edx
$L71995:

; 85   : 
; 86   : 	/* GETTAR:  F1, F2, F3, B1, B2, B3 */
; 87   : 	if ((pDphsettar->par_type = partyp[npar]) IS_FORM_FREQ_OR_BW)

  00599	8b 74 24 14	 mov	 esi, DWORD PTR _npar$[esp+28]
  0059d	8b 54 24 18	 mov	 edx, DWORD PTR _pDphsettar$[esp+28]
  005a1	0f bf c6	 movsx	 eax, si
  005a4	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _partyp[eax]
  005aa	3c 02		 cmp	 al, 2
  005ac	88 42 14	 mov	 BYTE PTR [edx+20], al
  005af	0f 8e 7a 01 00
	00		 jle	 $L71380

; 88   : 	{
; 89   : 		if ((tartemp = pDph_t->p_tar[phone_temp + pphotr]) < -1)

  005b5	0f bf 54 24 24	 movsx	 edx, WORD PTR _phone_temp$[esp+24]
  005ba	0f bf f7	 movsx	 esi, di
  005bd	8b b9 f0 14 00
	00		 mov	 edi, DWORD PTR [ecx+5360]
  005c3	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  005c6	66 8b 04 47	 mov	 ax, WORD PTR [edi+eax*2]
  005ca	66 3d ff ff	 cmp	 ax, -1

; 90   : 		{
; 91   : 			/* printf("tartem1 %d of %d \n",*tartemp,phone_temp); */
; 92   : 			return (tartemp);		   /* Pointer to diph info in p_diph[] */

  005ce	0f 8c a4 03 00
	00		 jl	 $L71367

; 93   : 		}
; 94   : 		else if (tartemp == -1)

  005d4	0f 85 94 00 00
	00		 jne	 $L71390

; 95   : 		{
; 96   : 			/* Tar undefined, use tarval of next segment */
; 97   : 			if ((tartemp = pDph_t->p_tar[phnex_temp + pphotr]) == -1)

  005da	0f bf 44 24 10	 movsx	 eax, WORD PTR _phnex_temp$[esp+28]
  005df	03 c6		 add	 eax, esi
  005e1	66 8b 04 47	 mov	 ax, WORD PTR [edi+eax*2]
  005e5	66 3d ff ff	 cmp	 ax, -1
  005e9	0f 85 83 00 00
	00		 jne	 $L72013

; 98   : 			{
; 99   : 				/* Tar still undefined, use tarval of second-next segment */
; 100  : 				if ((tartemp = pDph_t->p_tar[get_phone (pDph_t, nphone_temp + 2) + pphotr]) == -1)

  005ef	8d 45 02	 lea	 eax, DWORD PTR [ebp+2]
  005f2	85 c0		 test	 eax, eax
  005f4	7c 15		 jl	 SHORT $L71996
  005f6	0f bf 99 e2 14
	00 00		 movsx	 ebx, WORD PTR [ecx+5346]
  005fd	3b c3		 cmp	 eax, ebx
  005ff	7d 0a		 jge	 SHORT $L71996
  00601	0f bf 84 69 ca
	03 00 00	 movsx	 eax, WORD PTR [ecx+ebp*2+970]
  00609	eb 02		 jmp	 SHORT $L71997
$L71996:
  0060b	33 c0		 xor	 eax, eax
$L71997:
  0060d	03 c6		 add	 eax, esi
  0060f	66 8b 04 47	 mov	 ax, WORD PTR [edi+eax*2]
  00613	66 3d ff ff	 cmp	 ax, -1
  00617	75 59		 jne	 SHORT $L72013

; 101  : 				{
; 102  : 					/* Tar still undefined, use previous phone */
; 103  : 					if ((tartemp = pDph_t->p_tar[phlas_temp + pphotr]) < -1)

  00619	0f bf 44 24 20	 movsx	 eax, WORD PTR _phlas_temp$[esp+24]
  0061e	03 c6		 add	 eax, esi
  00620	66 8b 04 47	 mov	 ax, WORD PTR [edi+eax*2]
  00624	66 3d ff ff	 cmp	 ax, -1
  00628	7d 35		 jge	 SHORT $L72014

; 104  : 					{
; 105  : 						/* Diphthonized seg, use last target value */
; 106  : 						while (pDph_t->p_diph[-tartemp] != -1)

  0062a	8b b1 ec 14 00
	00		 mov	 esi, DWORD PTR [ecx+5356]
  00630	0f bf f8	 movsx	 edi, ax
  00633	d1 e7		 shl	 edi, 1
  00635	8b de		 mov	 ebx, esi
  00637	2b df		 sub	 ebx, edi
  00639	66 83 3b ff	 cmp	 WORD PTR [ebx], -1
  0063d	74 10		 je	 SHORT $L71389
$L71388:

; 107  : 						{
; 108  : 							tartemp--;

  0063f	48		 dec	 eax
  00640	8b de		 mov	 ebx, esi
  00642	0f bf f8	 movsx	 edi, ax
  00645	d1 e7		 shl	 edi, 1
  00647	2b df		 sub	 ebx, edi
  00649	66 83 3b ff	 cmp	 WORD PTR [ebx], -1
  0064d	75 f0		 jne	 SHORT $L71388
$L71389:

; 109  : 						}
; 110  : 						tartemp = pDph_t->p_diph[-tartemp - 1];

  0064f	0f bf c0	 movsx	 eax, ax
  00652	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  00656	2b f0		 sub	 esi, eax
  00658	66 8b 06	 mov	 ax, WORD PTR [esi]

; 111  : 					}
; 112  : 					/* If this doesn't work, use default value */
; 113  : 					if (tartemp == -1)

  0065b	66 3d ff ff	 cmp	 ax, -1
$L72014:
  0065f	75 11		 jne	 SHORT $L72013

; 114  : 					{
; 115  : 						tartemp = parini[npar];

  00661	0f bf 44 24 14	 movsx	 eax, WORD PTR _npar$[esp+28]
  00666	66 8b 04 45 00
	00 00 00	 mov	 ax, WORD PTR _parini[eax*2]
$L71390:

; 116  : 					}
; 117  : 				}
; 118  : 			}
; 119  : 		}
; 120  : 		if (tartemp < -1)

  0066e	66 3d ff ff	 cmp	 ax, -1
$L72013:
  00672	7d 10		 jge	 SHORT $L71391

; 121  : 		{
; 122  : 			tartemp = pDph_t->p_diph[-tartemp];

  00674	8b 89 ec 14 00
	00		 mov	 ecx, DWORD PTR [ecx+5356]
  0067a	0f bf c0	 movsx	 eax, ax
  0067d	d1 e0		 shl	 eax, 1
  0067f	2b c8		 sub	 ecx, eax
  00681	66 8b 01	 mov	 ax, WORD PTR [ecx]
$L71391:

; 123  : 		}
; 124  : 		/* Fricatives have higher F1 if preceeded by a vowel */
; 125  : 		if ((npar == F1 - 1)
; 126  : 			&& ((featb[phone_temp] & FOBST) IS_PLUS)
; 127  : 			&& ((featb[phone_temp] & FSTOP) IS_MINUS)
; 128  : 			&& ((featb[phlas_temp] & FSYLL) IS_PLUS))

  00684	8b 74 24 14	 mov	 esi, DWORD PTR _npar$[esp+28]
  00688	66 85 f6	 test	 si, si
  0068b	75 2a		 jne	 SHORT $L71392
  0068d	66 8b 0c 55 00
	00 00 00	 mov	 cx, WORD PTR _featb[edx*2]
  00695	f6 c1 20	 test	 cl, 32			; 00000020H
  00698	74 1d		 je	 SHORT $L71392
  0069a	81 e1 00 20 00
	00		 and	 ecx, 8192		; 00002000H
  006a0	66 85 c9	 test	 cx, cx
  006a3	75 12		 jne	 SHORT $L71392
  006a5	0f bf 54 24 20	 movsx	 edx, WORD PTR _phlas_temp$[esp+24]
  006aa	f6 04 55 00 00
	00 00 01	 test	 BYTE PTR _featb[edx*2], 1
  006b2	74 03		 je	 SHORT $L71392

; 129  : 		{
; 130  : 			tartemp += 40;

  006b4	83 c0 28	 add	 eax, 40			; 00000028H
$L71392:

; 131  : 		}
; 132  : 		/* Special rule for B2 of \n/ before non-front vowels */
; 133  : 		if (((phone_temp == N) || (phone_temp == EN))
; 134  : 			&& (npar == B2 - 1))

  006b7	8b 4c 24 24	 mov	 ecx, DWORD PTR _phone_temp$[esp+24]
  006bb	66 83 f9 20	 cmp	 cx, 32			; 00000020H
  006bf	74 06		 je	 SHORT $L71394
  006c1	66 83 f9 24	 cmp	 cx, 36			; 00000024H
  006c5	75 19		 jne	 SHORT $L71395
$L71394:
  006c7	66 83 fe 05	 cmp	 si, 5
  006cb	75 13		 jne	 SHORT $L71395

; 135  : 		{
; 136  : 			if (begtyp[phnex_temp] != 1)

  006cd	0f bf 54 24 10	 movsx	 edx, WORD PTR _phnex_temp$[esp+28]
  006d2	66 83 3c 55 00
	00 00 00 01	 cmp	 WORD PTR _begtyp[edx*2], 1
  006db	74 03		 je	 SHORT $L71395

; 137  : 			{
; 138  : 				tartemp += 60;

  006dd	83 c0 3c	 add	 eax, 60			; 0000003cH
$L71395:

; 139  : 			}
; 140  : 		}
; 141  : 		/* Special rule for B3 of \n/ adjacent to high-front vowels */
; 142  : 		if (((phone_temp == N) || (phone_temp == EN) || (phone_temp == NX))
; 143  : 			&& (npar == B3 - 1))

  006e0	66 83 f9 20	 cmp	 cx, 32			; 00000020H
  006e4	74 10		 je	 SHORT $L71397
  006e6	66 83 f9 24	 cmp	 cx, 36			; 00000024H
  006ea	74 0a		 je	 SHORT $L71397
  006ec	66 83 f9 21	 cmp	 cx, 33			; 00000021H
  006f0	0f 85 82 02 00
	00		 jne	 $L71367
$L71397:
  006f6	66 83 fe 06	 cmp	 si, 6
  006fa	0f 85 78 02 00
	00		 jne	 $L71367

; 144  : 		{
; 145  : 			if (((place[phnex_temp] & F2BACKI) IS_PLUS)
; 146  : 				|| ((place[phlas_temp] & F2BACKF) IS_PLUS))

  00700	0f bf 4c 24 10	 movsx	 ecx, WORD PTR _phnex_temp$[esp+28]
  00705	f6 04 4d 00 00
	00 00 40	 test	 BYTE PTR _place[ecx*2], 64 ; 00000040H
  0070d	75 13		 jne	 SHORT $L71399
  0070f	0f bf 54 24 20	 movsx	 edx, WORD PTR _phlas_temp$[esp+24]
  00714	f6 04 55 00 00
	00 00 80	 test	 BYTE PTR _place[edx*2], -128 ; ffffff80H
  0071c	0f 84 56 02 00
	00		 je	 $L71367
$L71399:
  00722	5f		 pop	 edi
  00723	5e		 pop	 esi
  00724	5d		 pop	 ebp

; 147  : 			{
; 148  : 				tartemp = 1600;

  00725	b8 40 06 00 00	 mov	 eax, 1600		; 00000640H
  0072a	5b		 pop	 ebx

; 306  : 			}
; 307  : 		}
; 308  : 	}
; 309  : 	
; 310  : 	return (tartemp);
; 311  : }

  0072b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0072e	c3		 ret	 0
$L71380:

; 149  : 			}
; 150  : 		}
; 151  : 	}
; 152  : 	/* 
; 153  : 	 * eab do nasals differently by nasalizing vowel before it and then 
; 154  : 	 * reduce dur on n not vowel in rule 22 context. The code actually nasalizes
; 155  : 	 * anything in front of it 
; 156  : 	 */
; 157  : 	/* GETTAR:  FZ */
; 158  : 	else if (pDphsettar->par_type IS_NASAL_ZERO_FREQ)

  0072f	3c 01		 cmp	 al, 1
  00731	75 27		 jne	 SHORT $L71401

; 159  : 	{
; 160  : 		tartemp = NON_NASAL_ZERO;				   /* Default for non-nasalized, cancel FP=280 */
; 161  : 		if ((featb[phone_temp] & FNASAL) IS_PLUS)

  00733	0f bf 4c 24 24	 movsx	 ecx, WORD PTR _phone_temp$[esp+24]
  00738	b8 22 01 00 00	 mov	 eax, 290		; 00000122H
  0073d	f6 04 4d 00 00
	00 00 80	 test	 BYTE PTR _featb[ecx*2], -128 ; ffffff80H
  00745	74 05		 je	 SHORT $L71402

; 162  : 		{
; 163  : 			tartemp = NASAL_ZERO_ALVELAR;			   /* Value dur nasal murmur (527=max) */

  00747	b8 90 01 00 00	 mov	 eax, 400		; 00000190H
$L71402:
  0074c	5f		 pop	 edi
  0074d	5e		 pop	 esi
  0074e	5d		 pop	 ebp

; 164  : 		}
; 165  : 		pDphsettar->nasvowel = 0;

  0074f	66 c7 42 16 00
	00		 mov	 WORD PTR [edx+22], 0
  00755	5b		 pop	 ebx

; 306  : 			}
; 307  : 		}
; 308  : 	}
; 309  : 	
; 310  : 	return (tartemp);
; 311  : }

  00756	83 c4 0c	 add	 esp, 12			; 0000000cH
  00759	c3		 ret	 0
$L71401:

; 166  :     /* if ((pDphsettar->phonex == N  || pDphsettar->phonex == M) && (phone_temp != R )) { tartemp = 300; pDphsettar->nasvowel=1; }        */
; 167  : 	}
; 168  : 	/* GETTAR:  AV, AP */
; 169  : 	else if (pDphsettar->par_type IS_AV_OR_AH)

  0075a	84 c0		 test	 al, al
  0075c	0f 85 b2 00 00
	00		 jne	 $L71404

; 170  : 	{
; 171  : 		/* Rules for voicing amplitude */
; 172  : 		if (npar == AV - 1)

  00762	66 83 fe 07	 cmp	 si, 7
  00766	75 7e		 jne	 SHORT $L71405

; 173  : 		{
; 174  : 			tartemp = pDph_t->p_tar[phone_temp + pphotr];

  00768	8b 74 24 24	 mov	 esi, DWORD PTR _phone_temp$[esp+24]
  0076c	0f bf d6	 movsx	 edx, si
  0076f	0f bf c7	 movsx	 eax, di
  00772	8b b9 f0 14 00
	00		 mov	 edi, DWORD PTR [ecx+5360]

; 175  : #ifdef SLOWTALK
; 176  : 			/* 5/13/98 EAB The glotal stop in this instance goes all the way to perceived silence
; 177  : 			for some reason it was too strong so I fixed it*/
; 178  : 
; 179  : 			if(pKsd_t->sprate <100)
; 180  : 				if (phone_temp == Q)
; 181  : 					tartemp -=30;
; 182  : #endif
; 183  : 			/* Dummy vowel has less intensity */
; 184  : 			if ((pDph_t->allofeats[nphone_temp] & FDUMMY_VOWEL) IS_PLUS)

  00778	8b 8c a9 34 06
	00 00		 mov	 ecx, DWORD PTR [ecx+ebp*4+1588]
  0077f	03 c2		 add	 eax, edx
  00781	f6 c5 08	 test	 ch, 8
  00784	66 8b 04 47	 mov	 ax, WORD PTR [edi+eax*2]
  00788	74 03		 je	 SHORT $L71406

; 185  : 			{
; 186  : 				tartemp -= 7;

  0078a	83 e8 07	 sub	 eax, 7
$L71406:

; 187  : 			}
; 188  : 			/* Voiced stop devoiced if preceding seg voiceless */
; 189  : 			if (((featb[phone_temp] & FPLOSV) IS_PLUS)
; 190  : 				&& ((featb[phlas_temp] & FVOICD) IS_MINUS))

  0078d	f6 04 55 00 00
	00 00 40	 test	 BYTE PTR _featb[edx*2], 64 ; 00000040H
  00795	74 11		 je	 SHORT $L71407
  00797	0f bf 54 24 20	 movsx	 edx, WORD PTR _phlas_temp$[esp+24]
  0079c	f6 04 55 00 00
	00 00 02	 test	 BYTE PTR _featb[edx*2], 2
  007a4	75 02		 jne	 SHORT $L71407

; 191  : 			{
; 192  : 				tartemp = 0;

  007a6	33 c0		 xor	 eax, eax
$L71407:

; 193  : 			}
; 194  : 			/* Voice [h] if unstressed and preceeded by voiced seg */
; 195  : 			if ((phone_temp == HX)
; 196  : 				&& ((featb[phlas_temp] & FVOICD) IS_PLUS)
; 197  : 				&& ((pDph_t->allofeats[nphone_temp] & FSTRESS_1) IS_MINUS))

  007a8	66 83 fe 1c	 cmp	 si, 28			; 0000001cH
  007ac	75 19		 jne	 SHORT $L71408
  007ae	0f bf 54 24 20	 movsx	 edx, WORD PTR _phlas_temp$[esp+24]
  007b3	f6 04 55 00 00
	00 00 02	 test	 BYTE PTR _featb[edx*2], 2
  007bb	74 0a		 je	 SHORT $L71408
  007bd	f6 c1 01	 test	 cl, 1
  007c0	75 05		 jne	 SHORT $L71408

; 198  : 			{
; 199  : 				tartemp = 54;

  007c2	b8 36 00 00 00	 mov	 eax, 54			; 00000036H
$L71408:

; 200  : 			}
; 201  : 
; 202  : 			/* Reduce amplitudes if unstressed 4/4/98 Found another problem the original code was in the wrong 
; 203  : 			place so it effected both aspiration and av and in the right circumstances could cause problems
; 204  : 			this needs to be shecked in all the langauges*/
; 205  : 				/* Reduce amplitudes if unstressed */
; 206  : 		/*	eab 2/96 This only handles stressted unstress and doesn't
; 207  : 			accomadate other stress levels today*/
; 208  : 		if ((pDph_t->allofeats[nphone_temp] & FSTRESS) IS_MINUS)

  007c7	f6 c1 03	 test	 cl, 3
  007ca	0f 85 a8 01 00
	00		 jne	 $L71367

; 209  : 		{
; 210  : 			tartemp -= 4;

  007d0	83 e8 04	 sub	 eax, 4

; 211  : 			if (tartemp < 0)

  007d3	66 85 c0	 test	 ax, ax
  007d6	0f 8d 9c 01 00
	00		 jge	 $L71367
$L71412:
  007dc	5f		 pop	 edi
  007dd	5e		 pop	 esi
  007de	5d		 pop	 ebp

; 212  : 				tartemp = 0;

  007df	33 c0		 xor	 eax, eax
  007e1	5b		 pop	 ebx

; 306  : 			}
; 307  : 		}
; 308  : 	}
; 309  : 	
; 310  : 	return (tartemp);
; 311  : }

  007e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  007e5	c3		 ret	 0
$L71405:

; 213  : 		}
; 214  : 		}
; 215  : 		/* Rules for aspiration amplitude */
; 216  : 		else
; 217  : 		{
; 218  : 			if (phone_temp == HX)

  007e6	66 83 7c 24 24
	1c		 cmp	 WORD PTR _phone_temp$[esp+24], 28 ; 0000001cH
  007ec	75 ee		 jne	 SHORT $L71412

; 219  : 			{
; 220  : 				tartemp = 53;
; 221  : 				if (begtyp[phnex_temp] != 1)

  007ee	0f bf 4c 24 10	 movsx	 ecx, WORD PTR _phnex_temp$[esp+28]
  007f3	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  007f8	66 83 3c 4d 00
	00 00 00 01	 cmp	 WORD PTR _begtyp[ecx*2], 1
  00801	0f 84 71 01 00
	00		 je	 $L71367
  00807	5f		 pop	 edi
  00808	5e		 pop	 esi
  00809	5d		 pop	 ebp

; 222  : 				{
; 223  : 					tartemp = 60;	   /* Stronger asp before +back */

  0080a	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
  0080f	5b		 pop	 ebx

; 306  : 			}
; 307  : 		}
; 308  : 	}
; 309  : 	
; 310  : 	return (tartemp);
; 311  : }

  00810	83 c4 0c	 add	 esp, 12			; 0000000cH
  00813	c3		 ret	 0
$L71404:

; 224  : 				}
; 225  : 			}
; 226  : 			else
; 227  : 			{
; 228  : 				tartemp = 0;
; 229  : 			}
; 230  : 		}
; 231  : 	
; 232  : 	}
; 233  : 	/* GETTAR:  A2, A3, A4, A5, A6, AB */
; 234  : 	else if (pDphsettar->par_type IS_PARALLEL_FORM_AMP)

  00814	3c 02		 cmp	 al, 2
  00816	0f 85 58 01 00
	00		 jne	 $L72001

; 235  : 	{
; 236  : 		/* If ptram >0, it is a pointer in obstruent array taram */
; 237  : 		if ((pDphsettar->np != &PTILT) && ((tartemp = ptram[phone_temp]) > 0))

  0081c	8d b9 40 02 00
	00		 lea	 edi, DWORD PTR [ecx+576]
  00822	3b df		 cmp	 ebx, edi
  00824	74 74		 je	 SHORT $L72000
  00826	0f bf 54 24 24	 movsx	 edx, WORD PTR _phone_temp$[esp+24]
  0082b	66 8b 04 55 00
	00 00 00	 mov	 ax, WORD PTR _ptram[edx*2]
  00833	66 85 c0	 test	 ax, ax
  00836	7e 66		 jle	 SHORT $L71421

; 238  : 		{
; 239  : 			begtypnex = begtyp[phnex_temp] - 1;

  00838	8b 54 24 10	 mov	 edx, DWORD PTR _phnex_temp$[esp+28]
  0083c	0f bf f2	 movsx	 esi, dx
  0083f	66 8b 34 75 00
	00 00 00	 mov	 si, WORD PTR _begtyp[esi*2]
  00847	66 4e		 dec	 si

; 240  : 			if (phnex_temp == SIL)

  00849	66 85 d2	 test	 dx, dx
  0084c	75 0f		 jne	 SHORT $L71418

; 241  : 				begtypnex = endtyp[phlas_temp] - 1;

  0084e	0f bf 54 24 20	 movsx	 edx, WORD PTR _phlas_temp$[esp+24]
  00853	66 8b 34 55 00
	00 00 00	 mov	 si, WORD PTR _endtyp[edx*2]
  0085b	66 4e		 dec	 si
$L71418:

; 242  : 			if (begtypnex == 4)

  0085d	66 83 fe 04	 cmp	 si, 4
  00861	75 05		 jne	 SHORT $L71419

; 243  : 				begtypnex = 2;

  00863	be 02 00 00 00	 mov	 esi, 2
$L71419:

; 244  : 
; 245  : 			tartemp += (npar - A2 + 1 + (6 * begtypnex));

  00868	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]

; 246  : 			tartemp = pDph_t->p_amp[tartemp];

  0086b	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  0086e	8b 54 24 14	 mov	 edx, DWORD PTR _npar$[esp+28]
  00872	8d 44 10 f7	 lea	 eax, DWORD PTR [eax+edx-9]
  00876	0f bf d0	 movsx	 edx, ax
  00879	8b 81 f4 14 00
	00		 mov	 eax, DWORD PTR [ecx+5364]
  0087f	66 8b 04 50	 mov	 ax, WORD PTR [eax+edx*2]

; 247  : 
; 248  : 			/* Burst has less intensity if dummy vowel next */
; 249  : 			if ((pDph_t->allofeats[nphone_temp + 1] & FDUMMY_VOWEL) IS_PLUS)

  00883	8b 94 a9 38 06
	00 00		 mov	 edx, DWORD PTR [ecx+ebp*4+1592]
  0088a	f6 c6 08	 test	 dh, 8
  0088d	74 0f		 je	 SHORT $L71421

; 250  : 			{
; 251  : 				if (tartemp >= 4)

  0088f	66 3d 04 00	 cmp	 ax, 4
  00893	7c 09		 jl	 SHORT $L71421

; 252  : 				{
; 253  : 					tartemp -= 4;

  00895	83 e8 04	 sub	 eax, 4
  00898	eb 04		 jmp	 SHORT $L71421
$L72000:
  0089a	8b 44 24 24	 mov	 eax, DWORD PTR _tartemp$[esp+24]
$L71421:

; 254  : 				}
; 255  : 			}
; 256  : 		}
; 257  : 		/* GETTAR:  TLT */
; 258  : 
; 259  : 		/* Source spectral tilt: highly tilted for obstruents */
; 260  : 		/* (Voiced obstruents are special case, set F1=0 to signal voicebar) */
; 261  : 		if (pDphsettar->np == &PTILT)

  0089e	3b df		 cmp	 ebx, edi
  008a0	0f 85 d2 00 00
	00		 jne	 $L71367

; 262  : 		{
; 263  : 			tartemp = 0;
; 264  : 			if (phone_temp == SIL)

  008a6	8b 54 24 24	 mov	 edx, DWORD PTR _phone_temp$[esp+24]
  008aa	33 c0		 xor	 eax, eax
  008ac	66 85 d2	 test	 dx, dx
  008af	75 19		 jne	 SHORT $L71423
$L71424:

; 272  : 			}
; 273  : 
; 274  : 			else if ((pDph_t->allofeats[nphone_temp] & FDUMMY_VOWEL) IS_PLUS)

  008b1	8b 94 a9 34 06
	00 00		 mov	 edx, DWORD PTR [ecx+ebp*4+1588]
  008b8	f6 c6 08	 test	 dh, 8
  008bb	74 20		 je	 SHORT $L71426
  008bd	5f		 pop	 edi
  008be	5e		 pop	 esi
  008bf	5d		 pop	 ebp

; 275  : 			{
; 276  : 				tartemp = 20;

  008c0	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  008c5	5b		 pop	 ebx

; 306  : 			}
; 307  : 		}
; 308  : 	}
; 309  : 	
; 310  : 	return (tartemp);
; 311  : }

  008c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  008c9	c3		 ret	 0
$L71423:

; 265  : 			{
; 266  : 				tartemp = 0;
; 267  : 			}
; 268  : 			/* eab hx energy too high at high frequency try controling with tilt */
; 269  : 			if (phone_temp == HX)

  008ca	66 83 fa 1c	 cmp	 dx, 28			; 0000001cH
  008ce	75 e1		 jne	 SHORT $L71424
  008d0	5f		 pop	 edi
  008d1	5e		 pop	 esi
  008d2	5d		 pop	 ebp

; 270  : 			{
; 271  : 				tartemp = 20;

  008d3	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  008d8	5b		 pop	 ebx

; 306  : 			}
; 307  : 		}
; 308  : 	}
; 309  : 	
; 310  : 	return (tartemp);
; 311  : }

  008d9	83 c4 0c	 add	 esp, 12			; 0000000cH
  008dc	c3		 ret	 0
$L71426:

; 277  : 			}
; 278  : 			else if ((featb[phone_temp] & FOBST) IS_PLUS)

  008dd	0f bf 74 24 24	 movsx	 esi, WORD PTR _phone_temp$[esp+24]
  008e2	d1 e6		 shl	 esi, 1
  008e4	66 8b 96 00 00
	00 00		 mov	 dx, WORD PTR _featb[esi]
  008eb	f6 c2 20	 test	 dl, 32			; 00000020H
  008ee	74 27		 je	 SHORT $L71428

; 279  : 			{
; 280  : 				tartemp = 7;
; 281  : 				if (((featb[phone_temp] & FVOICD) IS_PLUS)
; 282  : 					&& (((featb[phone_temp] & FPLOSV) IS_PLUS)
; 283  : 						|| (pDphsettar->phcur == JH)))

  008f0	f6 c2 02	 test	 dl, 2
  008f3	b8 07 00 00 00	 mov	 eax, 7
  008f8	74 7e		 je	 SHORT $L71367
  008fa	f6 c2 40	 test	 dl, 64			; 00000040H
  008fd	75 0b		 jne	 SHORT $L71430
  008ff	8b 4c 24 18	 mov	 ecx, DWORD PTR _pDphsettar$[esp+28]
  00903	66 83 79 18 37	 cmp	 WORD PTR [ecx+24], 55	; 00000037H
  00908	75 6e		 jne	 SHORT $L71367
$L71430:
  0090a	5f		 pop	 edi
  0090b	5e		 pop	 esi
  0090c	5d		 pop	 ebp

; 284  : 				{
; 285  : 					tartemp = 40;	   /* Max tilt for [b,d,g] */

  0090d	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  00912	5b		 pop	 ebx

; 306  : 			}
; 307  : 		}
; 308  : 	}
; 309  : 	
; 310  : 	return (tartemp);
; 311  : }

  00913	83 c4 0c	 add	 esp, 12			; 0000000cH
  00916	c3		 ret	 0
$L71428:

; 286  : 				}
; 287  : 			}
; 288  : 			else if ((featb[phone_temp] & FNASAL) IS_PLUS)

  00917	f6 c2 80	 test	 dl, -128		; ffffff80H
  0091a	74 2a		 je	 SHORT $L71432

; 289  : 			{
; 290  : 				//tartemp = 6;		   /* Tilt down nasal murmurs */
; 291  : 				//EAB 1/26/99 This is ph88 code that hsould be able to be removed when nasals correct
; 292  : 				if(begtyp[phnex_temp] == 1) 

  0091c	8b 4c 24 10	 mov	 ecx, DWORD PTR _phnex_temp$[esp+28]
  00920	0f bf d1	 movsx	 edx, cx
  00923	66 83 3c 55 00
	00 00 00 01	 cmp	 WORD PTR _begtyp[edx*2], 1
  0092c	75 05		 jne	 SHORT $L71433

; 293  : 				{
; 294  : 					tartemp = 16;	/* Tilt more before front vowel to */

  0092e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
$L71433:

; 295  : 				}			        
; 296  : 									/* compensate for wrong FZ placement */
; 297  : 
; 298  : 			    if(phnex_temp == IY)

  00933	66 83 f9 01	 cmp	 cx, 1
  00937	75 3f		 jne	 SHORT $L71367
  00939	5f		 pop	 edi
  0093a	5e		 pop	 esi
  0093b	5d		 pop	 ebp

; 299  : 					tartemp = 26;

  0093c	b8 1a 00 00 00	 mov	 eax, 26			; 0000001aH
  00941	5b		 pop	 ebx

; 306  : 			}
; 307  : 		}
; 308  : 	}
; 309  : 	
; 310  : 	return (tartemp);
; 311  : }

  00942	83 c4 0c	 add	 esp, 12			; 0000000cH
  00945	c3		 ret	 0
$L71432:

; 300  : 			}
; 301  : /*	      Female front vowels should be tilted down slightly */
; 302  : 			else if ((pDph_t->malfem == FEMALE)
; 303  : 			&& ((begtyp[phone_temp] == 1) || (endtyp[phone_temp] == 1))) 

  00946	66 83 b9 e4 14
	00 00 00	 cmp	 WORD PTR [ecx+5348], 0
  0094e	75 28		 jne	 SHORT $L71367
  00950	b9 01 00 00 00	 mov	 ecx, 1
  00955	66 39 8e 00 00
	00 00		 cmp	 WORD PTR _begtyp[esi], cx
  0095c	74 09		 je	 SHORT $L71437
  0095e	66 39 8e 00 00
	00 00		 cmp	 WORD PTR _endtyp[esi], cx
  00965	75 11		 jne	 SHORT $L71367
$L71437:
  00967	5f		 pop	 edi
  00968	5e		 pop	 esi
  00969	5d		 pop	 ebp

; 304  : 			{
; 305  : 				tartemp += 3;

  0096a	b8 03 00 00 00	 mov	 eax, 3
  0096f	5b		 pop	 ebx

; 306  : 			}
; 307  : 		}
; 308  : 	}
; 309  : 	
; 310  : 	return (tartemp);
; 311  : }

  00970	83 c4 0c	 add	 esp, 12			; 0000000cH
  00973	c3		 ret	 0
$L72001:

; 304  : 			{
; 305  : 				tartemp += 3;

  00974	8b 44 24 24	 mov	 eax, DWORD PTR _tartemp$[esp+24]
$L71367:
  00978	5f		 pop	 edi
  00979	5e		 pop	 esi
  0097a	5d		 pop	 ebp
  0097b	5b		 pop	 ebx

; 306  : 			}
; 307  : 		}
; 308  : 	}
; 309  : 	
; 310  : 	return (tartemp);
; 311  : }

  0097c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0097f	c3		 ret	 0
_gettar	ENDP
_phTTS$ = 8
_shrif$ = 12
_pholas$ = 16
_fealas$ = 20
_feacur$ = 24
_struclas$ = 28
_feanex$ = 36
_forw_smooth_rules PROC NEAR

; 446  : {

  00980	53		 push	 ebx

; 447  : 	short                   temp;	   /* MVP MI : This variable is made local */
; 448  : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  00981	8b 5c 24 08	 mov	 ebx, DWORD PTR _phTTS$[esp]
  00985	55		 push	 ebp
  00986	56		 push	 esi
  00987	57		 push	 edi
  00988	8b 7b 18	 mov	 edi, DWORD PTR [ebx+24]

; 449  : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 450  : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;
; 451  : 
; 452  : 	//debugforward ("Set default", pDphsettar->np);
; 453  : 	/* FORWARD SMOOTH: F1, F2, F3 */
; 454  : 	if (pDphsettar->par_type IS_FORM_FREQ)

  0098b	bd 03 00 00 00	 mov	 ebp, 3
  00990	8b b7 d0 2b 00
	00		 mov	 esi, DWORD PTR [edi+11216]
  00996	8a 46 14	 mov	 al, BYTE PTR [esi+20]
  00999	3c 03		 cmp	 al, 3
  0099b	0f 85 5b 02 00
	00		 jne	 $L71501

; 455  : 	{
; 456  : 		/* 0. Use default values for obst-obst transition */
; 457  : 		if ((feacur & FSONOR) IS_PLUS)

  009a1	8b 44 24 24	 mov	 eax, DWORD PTR _feacur$[esp+12]
  009a5	66 8b 54 24 1c	 mov	 dx, WORD PTR _pholas$[esp+12]
  009aa	a8 10		 test	 al, 16			; 00000010H
  009ac	bd 05 00 00 00	 mov	 ebp, 5
  009b1	0f 84 96 00 00
	00		 je	 $L71511

; 458  : 		{
; 459  : 			if ((feacur & FSONCON) IS_MINUS)

  009b7	25 00 02 00 00	 and	 eax, 512		; 00000200H
  009bc	66 85 c0	 test	 ax, ax
  009bf	75 69		 jne	 SHORT $L71503

; 460  : 			{
; 461  : 				pDphsettar->durtran = NF45MS;
; 462  : 				if ((fealas & FSONCON) IS_PLUS)

  009c1	8b 44 24 20	 mov	 eax, DWORD PTR _fealas$[esp+12]
  009c5	66 c7 46 06 07
	00		 mov	 WORD PTR [esi+6], 7
  009cb	25 00 02 00 00	 and	 eax, 512		; 00000200H
  009d0	66 85 c0	 test	 ax, ax
  009d3	74 3b		 je	 SHORT $L71504

; 463  : 				{
; 464  : 					/* 1. Soncon-vowel transition, use 25-75% rule */
; 465  : 					pDphsettar->bouval = (pDphsettar->bouval + pDphsettar->np->tarlas) >> 1;

  009d5	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  009d8	0f bf 2e	 movsx	 ebp, WORD PTR [esi]
  009db	0f bf 41 18	 movsx	 eax, WORD PTR [ecx+24]
  009df	03 c5		 add	 eax, ebp
  009e1	d1 f8		 sar	 eax, 1

; 466  : 					/* Make F1 discontinuous for light /l/ */
; 467  : 					if ((pholas == LL) && (pDphsettar->np == &PF1))

  009e3	66 83 fa 1b	 cmp	 dx, 27			; 0000001bH
  009e7	66 89 06	 mov	 WORD PTR [esi], ax
  009ea	75 0f		 jne	 SHORT $L71505
  009ec	8d 57 24	 lea	 edx, DWORD PTR [edi+36]
  009ef	3b ca		 cmp	 ecx, edx
  009f1	75 5a		 jne	 SHORT $L71511

; 468  : 					{
; 469  : 						pDphsettar->bouval += 80;

  009f3	83 c0 50	 add	 eax, 80			; 00000050H
  009f6	66 89 06	 mov	 WORD PTR [esi], ax

; 470  : 					}
; 471  : 					/* Make F3 & F2 transitions slower out of /r/ */
; 472  : 					if ((pholas == R) && (pDphsettar->np != &PF1))

  009f9	eb 52		 jmp	 SHORT $L71511
$L71505:
  009fb	66 83 fa 1a	 cmp	 dx, 26			; 0000001aH
  009ff	75 4c		 jne	 SHORT $L71511
  00a01	8d 47 24	 lea	 eax, DWORD PTR [edi+36]
  00a04	3b c8		 cmp	 ecx, eax
  00a06	74 45		 je	 SHORT $L71511

; 473  : 					{
; 474  : 						pDphsettar->durtran = NF70MS;

  00a08	66 c7 46 06 0b
	00		 mov	 WORD PTR [esi+6], 11	; 0000000bH

; 475  : 					}
; 476  : 				}
; 477  : 				else

  00a0e	eb 3d		 jmp	 SHORT $L71511
$L71504:

; 478  : 				{
; 479  : 					/* 2. Vowel-[vowel/h] transition */
; 480  : 					/* Preceeding seg has strong influence on [h] init val */
; 481  : 					if (pDphsettar->phcur == HX)

  00a10	66 83 7e 18 1c	 cmp	 WORD PTR [esi+24], 28	; 0000001cH
  00a15	75 36		 jne	 SHORT $L71511

; 482  : 					{
; 483  : 						pDphsettar->bouval = (pDphsettar->bouval + pDphsettar->np->tarlas) >> 1;

  00a17	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00a1a	0f bf 06	 movsx	 eax, WORD PTR [esi]
  00a1d	0f bf 51 18	 movsx	 edx, WORD PTR [ecx+24]
  00a21	03 d0		 add	 edx, eax
  00a23	d1 fa		 sar	 edx, 1
  00a25	66 89 16	 mov	 WORD PTR [esi], dx

; 484  : 					}
; 485  : 				}
; 486  : 			}
; 487  : 			else

  00a28	eb 23		 jmp	 SHORT $L71511
$L71503:

; 488  : 			{
; 489  : 				/* Phcur is a sonorant conson */
; 490  : 				if ((fealas & FSONCON) IS_MINUS)

  00a2a	8b 4c 24 20	 mov	 ecx, DWORD PTR _fealas$[esp+12]
  00a2e	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00a34	66 85 c9	 test	 cx, cx
  00a37	75 10		 jne	 SHORT $L71510

; 491  : 				{
; 492  : 					/* 3. Vowel-soncon trans, use 75-25% rule */
; 493  : 					pDphsettar->bouval = (pDphsettar->bouval + pDphsettar->np->tarcur) >> 1;

  00a39	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00a3c	0f bf 0e	 movsx	 ecx, WORD PTR [esi]
  00a3f	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00a42	03 c1		 add	 eax, ecx
  00a44	d1 f8		 sar	 eax, 1
  00a46	66 89 06	 mov	 WORD PTR [esi], ax
$L71510:

; 494  : 					pDphsettar->durtran = NF30MS;
; 495  : 				}
; 496  : 				else
; 497  : 				{
; 498  : 					/* 4. Soncon-soncon transition */
; 499  : 					pDphsettar->durtran = NF30MS;

  00a49	66 89 6e 06	 mov	 WORD PTR [esi+6], bp
$L71511:

; 500  : 				}
; 501  : 			}
; 502  : 		}
; 503  : 		/* Bound value = previous target if current phone is sil */
; 504  : 		/* eab not if it's the first sil EAB 4/apr/95 I've fixed this once before */
; 505  : 		if (pDphsettar->phcur == SIL)

  00a4d	66 83 7e 18 00	 cmp	 WORD PTR [esi+24], 0
  00a52	75 3e		 jne	 SHORT $L71512

; 506  : 		{
; 507  : 			/*Eab 7/31/96 changed > 2 to >1 for ending sil*/
; 508  : 			if (pDph_t->nphone > 1)

  00a54	66 83 bf a4 23
	00 00 01	 cmp	 WORD PTR [edi+9124], 1
  00a5c	7e 1a		 jle	 SHORT $L71513

; 509  : 			{
; 510  : 				pDphsettar->bouval = pDphsettar->np->tarlas;

  00a5e	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00a61	66 8b 42 18	 mov	 ax, WORD PTR [edx+24]
  00a65	66 89 06	 mov	 WORD PTR [esi], ax

; 515  : 			}
; 516  :             pDphsettar->durtran = pDph_t->durfon;

  00a68	66 8b 87 e0 14
	00 00		 mov	 ax, WORD PTR [edi+5344]
  00a6f	66 89 46 06	 mov	 WORD PTR [esi+6], ax

; 517  : 		}
; 518  : 		else

  00a73	e9 2b 01 00 00	 jmp	 $L71533
$L71513:

; 511  : 			}
; 512  : 			else
; 513  : 			{
; 514  : 				pDphsettar->bouval = pDphsettar->np->tarnex;

  00a78	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00a7b	66 8b 51 16	 mov	 dx, WORD PTR [ecx+22]
  00a7f	66 89 16	 mov	 WORD PTR [esi], dx

; 515  : 			}
; 516  :             pDphsettar->durtran = pDph_t->durfon;

  00a82	66 8b 87 e0 14
	00 00		 mov	 ax, WORD PTR [edi+5344]
  00a89	66 89 46 06	 mov	 WORD PTR [esi+6], ax

; 517  : 		}
; 518  : 		else

  00a8d	e9 11 01 00 00	 jmp	 $L71533
$L71512:

; 519  : 		{
; 520  : 			/* 5. pholas=obst, pDphsettar->phcur=sonor transition */
; 521  : 			if (setloc (phTTS, pDph_t->nphone - 1, pDph_t->nphone, 'i', pDph_t->nphone - 2, feanex))

  00a92	66 8b 87 a4 23
	00 00		 mov	 ax, WORD PTR [edi+9124]
  00a99	8b 6c 24 30	 mov	 ebp, DWORD PTR _feanex$[esp+12]
  00a9d	55		 push	 ebp
  00a9e	8d 48 fe	 lea	 ecx, DWORD PTR [eax-2]
  00aa1	51		 push	 ecx
  00aa2	6a 69		 push	 105			; 00000069H
  00aa4	50		 push	 eax
  00aa5	48		 dec	 eax
  00aa6	50		 push	 eax
  00aa7	53		 push	 ebx
  00aa8	e8 00 00 00 00	 call	 _setloc

; 522  : 			{
; 523  : 				//debugforward (" Use locus,percent", pDphsettar->np);
; 524  : 			}
; 525  : 			/* 6. pholas=sonor, pDphsettar->phcur=obst transition */
; 526  : 			if (setloc (phTTS, pDph_t->nphone, pDph_t->nphone - 1, 'f', pDph_t->nphone + 1,feanex))

  00aad	66 8b 87 a4 23
	00 00		 mov	 ax, WORD PTR [edi+9124]
  00ab4	55		 push	 ebp
  00ab5	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00ab8	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00abb	52		 push	 edx
  00abc	6a 66		 push	 102			; 00000066H
  00abe	51		 push	 ecx
  00abf	50		 push	 eax
  00ac0	53		 push	 ebx
  00ac1	e8 00 00 00 00	 call	 _setloc

; 527  : 			{
; 528  : 				//debugforward (" Use locus,percent", pDphsettar->np);
; 529  : 			}
; 530  : 			/* Dummy vowel for final plosive release into silence is too */
; 531  : 			/* short for an extensive formant transition, make tran less */
; 532  : 			if ((struccur & FDUMMY_VOWEL) IS_PLUS)
; 533  : 			{
; 534  : 				/* OUT                      xx += ((pDphsettar->bouval - pDphsettar->np->tarend) >> 1); pDphsettar->np->tarend += xx;   (DOESN'T
; 535  : 				 * WORK) END OUT */
; 536  : 			}
; 537  : 			/* F1 raised at onset of voiceless plosive release */
; 538  : 			if (((fealas & FPLOSV) IS_PLUS)
; 539  : 				&& ((fealas & FVOICD) IS_MINUS))

  00ac6	8a 44 24 50	 mov	 al, BYTE PTR _fealas$[esp+60]
  00aca	83 c4 30	 add	 esp, 48			; 00000030H
  00acd	a8 40		 test	 al, 64			; 00000040H
  00acf	74 12		 je	 SHORT $L71520
  00ad1	a8 02		 test	 al, 2
  00ad3	75 0e		 jne	 SHORT $L71520

; 540  : 			{
; 541  : 				if (pDphsettar->np == &PF1)

  00ad5	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00ad8	8d 57 24	 lea	 edx, DWORD PTR [edi+36]
  00adb	3b c2		 cmp	 eax, edx
  00add	75 04		 jne	 SHORT $L71520

; 542  : 					pDphsettar->bouval += 100;

  00adf	66 83 06 64	 add	 WORD PTR [esi], 100	; 00000064H
$L71520:

; 543  : 			}
; 544  : 			/* Transitions modified inside obstruents */
; 545  : 			if ((feacur & FOBST) IS_PLUS)

  00ae3	8a 44 24 24	 mov	 al, BYTE PTR _feacur$[esp+12]
  00ae7	a8 20		 test	 al, 32			; 00000020H
  00ae9	74 25		 je	 SHORT $L71523

; 546  : 			{
; 547  : 				pDphsettar->durtran = NF30MS;
; 548  : 				if (pDphsettar->np == &PF1)

  00aeb	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00aee	8d 4f 24	 lea	 ecx, DWORD PTR [edi+36]
  00af1	3b d1		 cmp	 edx, ecx
  00af3	66 c7 46 06 05
	00		 mov	 WORD PTR [esi+6], 5
  00af9	75 06		 jne	 SHORT $L71522

; 549  : 					pDphsettar->durtran = NF20MS;

  00afb	66 c7 46 06 03
	00		 mov	 WORD PTR [esi+6], 3
$L71522:

; 550  : 				/* Transitions take all of plosive duration */
; 551  : 				if ((feacur & FPLOSV) IS_PLUS)

  00b01	a8 40		 test	 al, 64			; 00000040H
  00b03	74 0b		 je	 SHORT $L71523

; 552  : 				{
; 553  : 					pDphsettar->durtran = pDph_t->durfon;

  00b05	66 8b 97 e0 14
	00 00		 mov	 dx, WORD PTR [edi+5344]
  00b0c	66 89 56 06	 mov	 WORD PTR [esi+6], dx
$L71523:

; 554  : 				}
; 555  : 			}
; 556  : 			/* Higher formant transitions slow inside a nasal */
; 557  : 			if ((feacur & FNASAL) IS_PLUS)

  00b10	a8 80		 test	 al, -128		; ffffff80H
  00b12	0f 84 8b 00 00
	00		 je	 $L71533

; 558  : 			{
; 559  : 				pDphsettar->durtran = pDph_t->durfon;
; 560  : 				/* Except F1, which jumps to value above FNZRO */
; 561  : 				if (pDphsettar->np == &PF1)

  00b18	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00b1b	66 8b 87 e0 14
	00 00		 mov	 ax, WORD PTR [edi+5344]
  00b22	8d 4f 24	 lea	 ecx, DWORD PTR [edi+36]
  00b25	66 89 46 06	 mov	 WORD PTR [esi+6], ax
  00b29	3b d1		 cmp	 edx, ecx
  00b2b	75 08		 jne	 SHORT $L71525

; 562  : 				{
; 563  : 					pDphsettar->durtran = 0;

  00b2d	66 c7 46 06 00
	00		 mov	 WORD PTR [esi+6], 0

; 564  : 				}
; 565  : 				/* Lower F2 & F3 of [n] nasal murmur after front vowels */
; 566  : 				else if (((pDphsettar->phcur == N) || (pDphsettar->phcur == EN))

  00b33	eb 6e		 jmp	 SHORT $L71533
$L71525:

; 567  : 						 && (endtyp[pholas] == 1))

  00b35	66 8b 4e 18	 mov	 cx, WORD PTR [esi+24]
  00b39	66 83 f9 20	 cmp	 cx, 32			; 00000020H
  00b3d	74 06		 je	 SHORT $L71528
  00b3f	66 83 f9 24	 cmp	 cx, 36			; 00000024H
  00b43	75 3d		 jne	 SHORT $L71527
$L71528:
  00b45	0f bf 44 24 1c	 movsx	 eax, WORD PTR _pholas$[esp+12]
  00b4a	d1 e0		 shl	 eax, 1
  00b4c	66 83 b8 00 00
	00 00 01	 cmp	 WORD PTR _endtyp[eax], 1
  00b54	75 2c		 jne	 SHORT $L71527

; 568  : 				{
; 569  : 					if (pDphsettar->np == &PF2)

  00b56	8d 4f 48	 lea	 ecx, DWORD PTR [edi+72]
  00b59	3b d1		 cmp	 edx, ecx
  00b5b	75 18		 jne	 SHORT $L71530

; 570  : 					{
; 571  : 						pDphsettar->bouval -= 100;

  00b5d	66 83 06 9c	 add	 WORD PTR [esi], -100	; ffffff9cH

; 572  : 						if ((place[pholas] & F2BACKF) IS_PLUS)

  00b61	8a 98 00 00 00
	00		 mov	 bl, BYTE PTR _place[eax]
  00b67	66 8b 0e	 mov	 cx, WORD PTR [esi]
  00b6a	f6 c3 80	 test	 bl, -128		; ffffff80H
  00b6d	74 06		 je	 SHORT $L71530

; 573  : 						{
; 574  : 							pDphsettar->bouval -= 100;

  00b6f	83 c1 9c	 add	 ecx, -100		; ffffff9cH
  00b72	66 89 0e	 mov	 WORD PTR [esi], cx
$L71530:

; 575  : 						}
; 576  : 					}
; 577  : 					if (pDphsettar->np == &PF3)

  00b75	8d 47 6c	 lea	 eax, DWORD PTR [edi+108]
  00b78	3b d0		 cmp	 edx, eax
  00b7a	75 27		 jne	 SHORT $L71533

; 578  : 						pDphsettar->bouval -= 100;;

  00b7c	66 83 06 9c	 add	 WORD PTR [esi], -100	; ffffff9cH

; 579  : 				}
; 580  : 				/* Lower F2 of [m] nasal murmur near [i,e] */
; 581  : 				else if ((pDphsettar->np == &PF2) && (pDphsettar->phcur == M)

  00b80	eb 21		 jmp	 SHORT $L71533
$L71527:

; 582  : 						 && ((place[pholas] & F2BACKF) IS_PLUS))

  00b82	8d 47 48	 lea	 eax, DWORD PTR [edi+72]
  00b85	3b d0		 cmp	 edx, eax
  00b87	75 1a		 jne	 SHORT $L71533
  00b89	66 83 f9 1f	 cmp	 cx, 31			; 0000001fH
  00b8d	75 14		 jne	 SHORT $L71533
  00b8f	0f bf 4c 24 1c	 movsx	 ecx, WORD PTR _pholas$[esp+12]
  00b94	f6 04 4d 00 00
	00 00 80	 test	 BYTE PTR _place[ecx*2], -128 ; ffffff80H
  00b9c	74 05		 je	 SHORT $L71533

; 583  : 				{
; 584  : 					pDphsettar->bouval -= 150;

  00b9e	66 81 06 6a ff	 add	 WORD PTR [esi], -150	; ffffff6aH
$L71533:

; 585  : 				}
; 586  : 			}
; 587  : 		}
; 588  : 		/* Shrink transition dur inside sonor if sonor short */
; 589  : 		if (((feacur & FOBST) IS_MINUS)
; 590  : 			&& (endtyp[pholas] != OBSTRUENT)   /* Unless prev seg is obst */
; 591  : 			&& (pDphsettar->durtran > 0))

  00ba3	f6 44 24 24 20	 test	 BYTE PTR _feacur$[esp+12], 32 ; 00000020H
  00ba8	0f 85 83 03 00
	00		 jne	 $L71583
  00bae	0f bf 54 24 1c	 movsx	 edx, WORD PTR _pholas$[esp+12]
  00bb3	66 83 3c 55 00
	00 00 00 04	 cmp	 WORD PTR _endtyp[edx*2], 4
  00bbc	0f 84 6f 03 00
	00		 je	 $L71583
  00bc2	66 8b 46 06	 mov	 ax, WORD PTR [esi+6]
  00bc6	66 85 c0	 test	 ax, ax
  00bc9	0f 8e 62 03 00
	00		 jle	 $L71583

; 592  : 		{
; 593  : 			pDph_t->arg1 = pDphsettar->durtran;

  00bcf	66 89 87 f8 14
	00 00		 mov	 WORD PTR [edi+5368], ax

; 594  : 			pDph_t->arg2 = shrif;

  00bd6	66 8b 44 24 18	 mov	 ax, WORD PTR _shrif$[esp+12]

; 595  : 			pDphsettar->durtran = mlsh1 (pDph_t->arg1, pDph_t->arg2) + 1;

  00bdb	0f bf 8f f8 14
	00 00		 movsx	 ecx, WORD PTR [edi+5368]
  00be2	0f bf d0	 movsx	 edx, ax
  00be5	0f af ca	 imul	 ecx, edx
  00be8	c1 f9 0e	 sar	 ecx, 14			; 0000000eH
  00beb	41		 inc	 ecx
  00bec	66 89 87 fa 14
	00 00		 mov	 WORD PTR [edi+5370], ax
  00bf3	66 89 4e 06	 mov	 WORD PTR [esi+6], cx

; 596  : 		}
; 597  : 	}
; 598  : 	/* FORWARD SMOOTH:  FN */
; 599  : 	else if (pDphsettar->par_type IS_NASAL_ZERO_FREQ)

  00bf7	e9 35 03 00 00	 jmp	 $L71583
$L71501:
  00bfc	3c 01		 cmp	 al, 1
  00bfe	75 2d		 jne	 SHORT $L71536

; 600  : 	{
; 601  : 		pDphsettar->durtran = 0;
; 602  : 		if (((fealas & FNASAL) IS_PLUS)
; 603  : 			&& ((feacur & FNASAL) IS_MINUS))

  00c00	8a 44 24 20	 mov	 al, BYTE PTR _fealas$[esp+12]
  00c04	66 c7 46 06 00
	00		 mov	 WORD PTR [esi+6], 0
  00c0a	a8 80		 test	 al, -128		; ffffff80H
  00c0c	0f 84 1f 03 00
	00		 je	 $L71583
  00c12	f6 44 24 24 80	 test	 BYTE PTR _feacur$[esp+12], -128 ; ffffff80H
  00c17	0f 85 14 03 00
	00		 jne	 $L71583

; 604  : 		{
; 605  : 			pDphsettar->bouval = NASAL_ZERO_BOUNDARY;

  00c1d	66 c7 06 72 01	 mov	 WORD PTR [esi], 370	; 00000172H

; 606  : 			pDphsettar->durtran = NF80MS;

  00c22	66 c7 46 06 0d
	00		 mov	 WORD PTR [esi+6], 13	; 0000000dH

; 607  : 		}
; 608  : 	}
; 609  : 	/* FORWARD SMOOTH:  B1, B2, B3 */
; 610  : 	else if (pDphsettar->par_type IS_FORM_BW)

  00c28	e9 04 03 00 00	 jmp	 $L71583
$L71536:
  00c2d	3c 04		 cmp	 al, 4
  00c2f	0f 85 60 01 00
	00		 jne	 $L71539

; 611  : 	{
; 612  : 		/* Default transition duration is 40 ms */
; 613  : 		pDphsettar->durtran = NF40MS;
; 614  : 		/* Widen first formant bw if preceeding seg voiceless */
; 615  : 		if ((feacur & FVOICD) IS_PLUS)

  00c35	8a 44 24 24	 mov	 al, BYTE PTR _feacur$[esp+12]
  00c39	66 c7 46 06 06
	00		 mov	 WORD PTR [esi+6], 6
  00c3f	a8 02		 test	 al, 2
  00c41	bb 08 00 00 00	 mov	 ebx, 8
  00c46	74 28		 je	 SHORT $L71540

; 616  : 		{
; 617  : 			if ((pDphsettar->np == &PB1)
; 618  : 				&& ((fealas & FVOICD) IS_MINUS))

  00c48	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00c4b	8d 8f b4 00 00
	00		 lea	 ecx, DWORD PTR [edi+180]
  00c51	3b c1		 cmp	 eax, ecx
  00c53	75 1f		 jne	 SHORT $L71542
  00c55	f6 44 24 20 02	 test	 BYTE PTR _fealas$[esp+12], 2
  00c5a	75 18		 jne	 SHORT $L71542

; 619  : 			{
; 620  : 				pDphsettar->durtran = NF50MS;

  00c5c	66 89 5e 06	 mov	 WORD PTR [esi+6], bx

; 621  : 				/* More increase for low vowels (F1 high) */
; 622  : 				pDphsettar->bouval = pDphsettar->np->tarcur + (PF1.tarcur >> 3);

  00c60	66 8b 57 24	 mov	 dx, WORD PTR [edi+36]
  00c64	66 c1 fa 03	 sar	 dx, 3
  00c68	66 03 10	 add	 dx, WORD PTR [eax]
  00c6b	66 89 16	 mov	 WORD PTR [esi], dx

; 623  : 			}
; 624  : 		}
; 625  : 		else

  00c6e	eb 04		 jmp	 SHORT $L71542
$L71540:

; 626  : 		{                                       
; 627  : 			pDphsettar->durtran = NF20MS;

  00c70	66 89 6e 06	 mov	 WORD PTR [esi+6], bp
$L71542:

; 628  : 		}
; 629  : 		/* Treat boundary with silence */
; 630  : 		if (pholas == SIL)

  00c74	66 83 7c 24 1c
	00		 cmp	 WORD PTR _pholas$[esp+12], 0
  00c7a	75 2f		 jne	 SHORT $L71543

; 631  : 		{
; 632  : 			pDphsettar->bouval = pDphsettar->np->tarcur + ((&PB3 - pDphsettar->np) * 50);

  00c7c	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  00c7f	8b cf		 mov	 ecx, edi
  00c81	2b cd		 sub	 ecx, ebp
  00c83	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00c88	81 c1 fc 00 00
	00		 add	 ecx, 252		; 000000fcH
  00c8e	f7 e9		 imul	 ecx
  00c90	c1 fa 03	 sar	 edx, 3
  00c93	8b c2		 mov	 eax, edx
  00c95	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00c98	03 d0		 add	 edx, eax
  00c9a	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  00c9d	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00ca0	d1 e1		 shl	 ecx, 1
  00ca2	66 03 4d 00	 add	 cx, WORD PTR [ebp]
  00ca6	66 89 0e	 mov	 WORD PTR [esi], cx

; 633  : 			pDphsettar->durtran = NF50MS;
; 634  : 		}
; 635  : 		else if (pDphsettar->phcur == SIL)

  00ca9	eb 6b		 jmp	 SHORT $L71546
$L71543:
  00cab	66 83 7e 18 00	 cmp	 WORD PTR [esi+24], 0
  00cb0	75 68		 jne	 SHORT $L71545

; 636  : 		{
; 637  : 			pDphsettar->bouval = pDphsettar->np->tarlas + ((&PB3 - pDphsettar->np) * 50);

  00cb2	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  00cb5	8b cf		 mov	 ecx, edi
  00cb7	2b cd		 sub	 ecx, ebp
  00cb9	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00cbe	81 c1 fc 00 00
	00		 add	 ecx, 252		; 000000fcH
  00cc4	f7 e9		 imul	 ecx
  00cc6	c1 fa 03	 sar	 edx, 3
  00cc9	8b c2		 mov	 eax, edx
  00ccb	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00cce	03 d0		 add	 edx, eax
  00cd0	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  00cd3	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00cd6	d1 e1		 shl	 ecx, 1
  00cd8	66 03 4d 18	 add	 cx, WORD PTR [ebp+24]
  00cdc	66 89 0e	 mov	 WORD PTR [esi], cx

; 638  : 			if (((featb[pDph_t->allophons[pDph_t->nphone - 2]] & FVOICD) IS_MINUS)
; 639  : 				&& ((struclas & FDUMMY_VOWEL) IS_PLUS)
; 640  : 				&& (pDphsettar->np == &PB1))

  00cdf	0f bf 97 a4 23
	00 00		 movsx	 edx, WORD PTR [edi+9124]
  00ce6	0f bf 84 57 c2
	03 00 00	 movsx	 eax, WORD PTR [edi+edx*2+962]
  00cee	f6 04 45 00 00
	00 00 02	 test	 BYTE PTR _featb[eax*2], 2
  00cf6	75 1e		 jne	 SHORT $L71546
  00cf8	8b 4c 24 28	 mov	 ecx, DWORD PTR _struclas$[esp+12]
  00cfc	81 e1 00 08 00
	00		 and	 ecx, 2048		; 00000800H
  00d02	66 85 c9	 test	 cx, cx
  00d05	74 0f		 je	 SHORT $L71546
  00d07	8d 97 b4 00 00
	00		 lea	 edx, DWORD PTR [edi+180]
  00d0d	3b ea		 cmp	 ebp, edx
  00d0f	75 05		 jne	 SHORT $L71546

; 641  : 			{
; 642  : 				pDphsettar->bouval = 260;	/* Kluge to avoid discontinutiy */

  00d11	66 c7 06 04 01	 mov	 WORD PTR [esi], 260	; 00000104H
$L71546:

; 643  : 			}
; 644  : 			pDphsettar->durtran = NF50MS;

  00d16	66 89 5e 06	 mov	 WORD PTR [esi+6], bx
$L71545:

; 645  : 		}
; 646  : 		/* eab narrow b2 somewhat to compensate for volume drop in nasalizing vowel klugy way for now. */
; 647  : 
; 648  : 		if (pDphsettar->nasvowel)

  00d1a	66 83 7e 16 00	 cmp	 WORD PTR [esi+22], 0
  00d1f	74 04		 je	 SHORT $L71547

; 649  : 		{
; 650  : 			pDphsettar->bouval -= 20;

  00d21	66 83 06 ec	 add	 WORD PTR [esi], -20	; ffffffecH
$L71547:

; 651  : 		}
; 652  : 
; 653  : 		/* BW1 widen, to nasalize transition out of previous nasal */
; 654  : 		if ((fealas & FNASAL) IS_PLUS)

  00d25	f6 44 24 20 80	 test	 BYTE PTR _fealas$[esp+12], -128 ; ffffff80H
  00d2a	74 53		 je	 SHORT $L71551

; 655  : 		{
; 656  : 			pDphsettar->bouval = pDphsettar->np->tarcur;	/* B2,B3 not influ by nasal */

  00d2c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 657  : 			/* Except F2 of [n], which is wider in a non-front vowel */
; 658  : 			if ((pDphsettar->np == &PB2) && ((pholas == N) || (pholas == EN))
; 659  : 				&& (begtyp[pDphsettar->phcur] != 1))

  00d2f	8d 97 d8 00 00
	00		 lea	 edx, DWORD PTR [edi+216]
  00d35	3b c2		 cmp	 eax, edx
  00d37	66 8b 08	 mov	 cx, WORD PTR [eax]
  00d3a	66 89 0e	 mov	 WORD PTR [esi], cx
  00d3d	75 2c		 jne	 SHORT $L71549
  00d3f	66 8b 54 24 1c	 mov	 dx, WORD PTR _pholas$[esp+12]
  00d44	66 83 fa 20	 cmp	 dx, 32			; 00000020H
  00d48	74 06		 je	 SHORT $L71550
  00d4a	66 83 fa 24	 cmp	 dx, 36			; 00000024H
  00d4e	75 1b		 jne	 SHORT $L71549
$L71550:
  00d50	0f bf 56 18	 movsx	 edx, WORD PTR [esi+24]
  00d54	66 83 3c 55 00
	00 00 00 01	 cmp	 WORD PTR _begtyp[edx*2], 1
  00d5d	74 0c		 je	 SHORT $L71549

; 660  : 			{
; 661  : 				pDphsettar->bouval += 60;

  00d5f	83 c1 3c	 add	 ecx, 60			; 0000003cH

; 662  : 				pDphsettar->durtran = NF60MS;

  00d62	66 c7 46 06 09
	00		 mov	 WORD PTR [esi+6], 9
  00d68	66 89 0e	 mov	 WORD PTR [esi], cx
$L71549:

; 663  : 			}
; 664  : 			if (pDphsettar->np == &PB1)

  00d6b	8d 8f b4 00 00
	00		 lea	 ecx, DWORD PTR [edi+180]
  00d71	3b c1		 cmp	 eax, ecx
  00d73	75 0a		 jne	 SHORT $L71551

; 665  : 			{
; 666  : 				pDphsettar->durtran = NF100MS;
; 667  : 				pDphsettar->bouval += 70;

  00d75	66 83 06 46	 add	 WORD PTR [esi], 70	; 00000046H
  00d79	66 c7 46 06 10
	00		 mov	 WORD PTR [esi+6], 16	; 00000010H
$L71551:

; 668  : 			}
; 669  : 		}
; 670  : 		/* Nasals have constant bandwidths at target values */
; 671  : 		if ((feacur & FNASAL) IS_PLUS)

  00d7f	f6 44 24 24 80	 test	 BYTE PTR _feacur$[esp+12], -128 ; ffffff80H
  00d84	0f 84 a7 01 00
	00		 je	 $L71583

; 672  : 		{
; 673  : 			pDphsettar->durtran = 0;

  00d8a	66 c7 46 06 00
	00		 mov	 WORD PTR [esi+6], 0

; 674  : 			//debugforward (" Nasal has const par val", pDphsettar->np);
; 675  : 		}
; 676  : 	}
; 677  : 	/* FORWARD SMOOTH:  AV, AP, A2, A3, A4, A5, A6, AB */
; 678  : 
; 679  : 	/* Default pDphsettar->bouval is average of tarcur & tarend, default tc is 30 ms */
; 680  : 	else if ((pDphsettar->par_type IS_PARALLEL_FORM_AMP)

  00d90	e9 9c 01 00 00	 jmp	 $L71583
$L71539:

; 681  : 			 || (pDphsettar->par_type IS_AV_OR_AH))

  00d95	3c 02		 cmp	 al, 2
  00d97	74 08		 je	 SHORT $L71555
  00d99	84 c0		 test	 al, al
  00d9b	0f 85 90 01 00
	00		 jne	 $L71583
$L71555:

; 682  : 	{
; 683  : 
; 684  : 		/* See if onset, i.e. plosive or large source intensity increase */
; 685  : 		temp = pDphsettar->np->tarcur - 10;

  00da1	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]

; 686  : 		if ((pDphsettar->bouval < temp) || ((fealas & FPLOSV) IS_PLUS)
; 687  : 			|| (pholas == JH))

  00da4	8b 5c 24 24	 mov	 ebx, DWORD PTR _feacur$[esp+12]
  00da8	8b 54 24 20	 mov	 edx, DWORD PTR _fealas$[esp+12]
  00dac	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00daf	66 2d 0a 00	 sub	 ax, 10			; 0000000aH
  00db3	66 39 06	 cmp	 WORD PTR [esi], ax
  00db6	7c 0d		 jl	 SHORT $L71557
  00db8	f6 c2 40	 test	 dl, 64			; 00000040H
  00dbb	75 08		 jne	 SHORT $L71557
  00dbd	66 83 7c 24 1c
	37		 cmp	 WORD PTR _pholas$[esp+12], 55 ; 00000037H
  00dc3	75 47		 jne	 SHORT $L71563
$L71557:

; 688  : 		{
; 689  : 			pDphsettar->bouval = temp;
; 690  : 			if ((feacur & FOBST) IS_MINUS)

  00dc5	f6 c3 20	 test	 bl, 32			; 00000020H
  00dc8	66 89 06	 mov	 WORD PTR [esi], ax
  00dcb	75 04		 jne	 SHORT $L71558

; 691  : 				pDphsettar->durtran = NF20MS;

  00dcd	66 89 6e 06	 mov	 WORD PTR [esi+6], bp
$L71558:

; 692  : 			/* Voicing is special */
; 693  : 			if (pDphsettar->np == &PAV)

  00dd1	8d af 20 01 00
	00		 lea	 ebp, DWORD PTR [edi+288]
  00dd7	3b cd		 cmp	 ecx, ebp
  00dd9	75 31		 jne	 SHORT $L71563

; 694  : 			{
; 695  : 				/* Gradual buildup of voicing */
; 696  : 				if (pholas == SIL)

  00ddb	66 83 7c 24 1c
	00		 cmp	 WORD PTR _pholas$[esp+12], 0
  00de1	75 0f		 jne	 SHORT $L71561

; 697  : 				{
; 698  : 					if ((feacur & FVOICD) IS_PLUS)

  00de3	f6 c3 02	 test	 bl, 2
  00de6	74 0a		 je	 SHORT $L71561

; 699  : 					{
; 700  : 						pDphsettar->durtran = NF45MS;
; 701  : 						pDphsettar->bouval -= 8;

  00de8	66 83 06 f8	 add	 WORD PTR [esi], -8	; fffffff8H
  00dec	66 c7 46 06 07
	00		 mov	 WORD PTR [esi+6], 7
$L71561:

; 702  : 					}
; 703  : 				}
; 704  : 				/* Obstruent voicing onset is abrupt */
; 705  : 				if ((fealas & FOBST) IS_PLUS)

  00df2	f6 c2 20	 test	 dl, 32			; 00000020H
  00df5	74 06		 je	 SHORT $L71562

; 706  : 				{
; 707  : 					pDphsettar->bouval = temp + 6;

  00df7	83 c0 06	 add	 eax, 6
  00dfa	66 89 06	 mov	 WORD PTR [esi], ax
$L71562:

; 708  : 				}
; 709  : 				/* Plosive onset is abrupt (used mainly for [bdg]) */
; 710  : 				if ((fealas & FPLOSV) IS_PLUS)

  00dfd	f6 c2 40	 test	 dl, 64			; 00000040H
  00e00	74 0a		 je	 SHORT $L71563

; 711  : 				{
; 712  : 					pDphsettar->bouval = pDphsettar->np->tarcur - 5;

  00e02	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00e05	66 2d 05 00	 sub	 ax, 5
  00e09	66 89 06	 mov	 WORD PTR [esi], ax
$L71563:

; 713  : 				}
; 714  : 			}
; 715  : 			//debugforward (" Onset", pDphsettar->np);
; 716  : 		}
; 717  : 		/* If last nasal, and source amp increased, abrupt onset */
; 718  : 		if (((fealas & FNASAL) IS_PLUS)
; 719  : 			&& ((feacur & FVOICD) IS_PLUS))

  00e0c	f6 c2 80	 test	 dl, -128		; ffffff80H
  00e0f	74 0d		 je	 SHORT $L72024
  00e11	f6 c3 02	 test	 bl, 2
  00e14	74 08		 je	 SHORT $L72024

; 720  : 		{
; 721  : 			pDphsettar->durtran = 0;

  00e16	33 ed		 xor	 ebp, ebp
  00e18	66 89 6e 06	 mov	 WORD PTR [esi+6], bp
  00e1c	eb 02		 jmp	 SHORT $L71564
$L72024:
  00e1e	33 ed		 xor	 ebp, ebp
$L71564:

; 722  : 			//debugforward (" Onset from nasal", pDphsettar->np);
; 723  : 		}
; 724  : 		/* Voicing source amp const in intervocalic nasal */
; 725  : 		if ((feacur & FNASAL) IS_PLUS)

  00e20	f6 c3 80	 test	 bl, -128		; ffffff80H
  00e23	74 13		 je	 SHORT $L71567

; 726  : 		{
; 727  : 			if ((fealas & FVOICD) IS_PLUS)

  00e25	f6 c2 02	 test	 dl, 2
  00e28	74 0e		 je	 SHORT $L71567

; 728  : 			{
; 729  : 				if (pDphsettar->np == &PAV)

  00e2a	8d 87 20 01 00
	00		 lea	 eax, DWORD PTR [edi+288]
  00e30	3b c8		 cmp	 ecx, eax
  00e32	75 04		 jne	 SHORT $L71567

; 730  : 					pDphsettar->durtran = 0;

  00e34	66 89 6e 06	 mov	 WORD PTR [esi+6], bp
$L71567:

; 731  : 			}
; 732  : 		}
; 733  : 		/* See if offset, i.e. source intensity decreasing */
; 734  : 		temp = pDphsettar->np->tarlas - 10;

  00e38	66 8b 41 18	 mov	 ax, WORD PTR [ecx+24]
  00e3c	66 2d 0a 00	 sub	 ax, 10			; 0000000aH

; 735  : 		if (pDphsettar->bouval < temp)

  00e40	66 39 06	 cmp	 WORD PTR [esi], ax
  00e43	7d 20		 jge	 SHORT $L71570

; 736  : 		{
; 737  : 			/* Reduce bounval by 3 dB because bval time is onset */
; 738  : 			/* of next phoneme */
; 739  : 			pDphsettar->bouval = temp - 3;

  00e45	83 c0 fd	 add	 eax, -3			; fffffffdH

; 740  : 			/* Source amplitudes fall gradually into silence */
; 741  : 			if (pDphsettar->phcur == SIL)

  00e48	66 39 6e 18	 cmp	 WORD PTR [esi+24], bp
  00e4c	66 89 06	 mov	 WORD PTR [esi], ax
  00e4f	75 06		 jne	 SHORT $L71569

; 742  : 				pDphsettar->durtran = NF70MS;

  00e51	66 c7 46 06 0b
	00		 mov	 WORD PTR [esi+6], 11	; 0000000bH
$L71569:

; 743  : 			/* Except voicing offset is abrupt */
; 744  : 			if (pDphsettar->np == &PAV)

  00e57	8d 87 20 01 00
	00		 lea	 eax, DWORD PTR [edi+288]
  00e5d	3b c8		 cmp	 ecx, eax
  00e5f	75 04		 jne	 SHORT $L71570

; 745  : 				pDphsettar->durtran = 0;

  00e61	66 89 6e 06	 mov	 WORD PTR [esi+6], bp
$L71570:

; 746  : 			//debugforward (" Offset", pDphsettar->np);
; 747  : 		}
; 748  : 		/* Buildup A3 gradually in [C, J] */
; 749  : 		if (pDphsettar->np == &PA3)

  00e65	8d 87 8c 01 00
	00		 lea	 eax, DWORD PTR [edi+396]
  00e6b	3b c8		 cmp	 ecx, eax
  00e6d	75 29		 jne	 SHORT $L71572

; 750  : 		{
; 751  : 			if ((pDphsettar->phcur == CH) || (pDphsettar->phcur == JH))

  00e6f	66 8b 46 18	 mov	 ax, WORD PTR [esi+24]
  00e73	66 3d 36 00	 cmp	 ax, 54			; 00000036H
  00e77	74 06		 je	 SHORT $L71573
  00e79	66 3d 37 00	 cmp	 ax, 55			; 00000037H
  00e7d	75 19		 jne	 SHORT $L71572
$L71573:

; 752  : 			{
; 753  : 				pDphsettar->durtran = pDph_t->durfon - NF15MS;

  00e7f	66 8b 87 e0 14
	00 00		 mov	 ax, WORD PTR [edi+5344]
  00e86	66 2d 02 00	 sub	 ax, 2
  00e8a	66 89 46 06	 mov	 WORD PTR [esi+6], ax

; 754  : 				pDphsettar->bouval = pDphsettar->np->tarcur - 30;

  00e8e	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00e91	66 2d 1e 00	 sub	 ax, 30			; 0000001eH
  00e95	66 89 06	 mov	 WORD PTR [esi], ax
$L71572:

; 755  : 				//debugforward (" CH/JH rule", pDphsettar->np);
; 756  : 			}
; 757  : 		}
; 758  : 		/* Offset of a vowel into voiceless open vocal tract is breathy */
; 759  : 		if (pDphsettar->np == &PAP)

  00e98	8d 87 44 01 00
	00		 lea	 eax, DWORD PTR [edi+324]
  00e9e	3b c8		 cmp	 ecx, eax
  00ea0	75 48		 jne	 SHORT $L71579

; 760  : 		{
; 761  : 			if ((pDphsettar->phcur == SIL) || (pDphsettar->phcur == F) || (pDphsettar->phcur == TH)
; 762  : 				|| (pDphsettar->phcur == S) || (pDphsettar->phcur == SH))

  00ea2	66 8b 46 18	 mov	 ax, WORD PTR [esi+24]
  00ea6	66 3b c5	 cmp	 ax, bp
  00ea9	74 18		 je	 SHORT $L71576
  00eab	66 3d 25 00	 cmp	 ax, 37			; 00000025H
  00eaf	74 12		 je	 SHORT $L71576
  00eb1	66 3d 27 00	 cmp	 ax, 39			; 00000027H
  00eb5	74 0c		 je	 SHORT $L71576
  00eb7	66 3d 29 00	 cmp	 ax, 41			; 00000029H
  00ebb	74 06		 je	 SHORT $L71576
  00ebd	66 3d 2b 00	 cmp	 ax, 43			; 0000002bH
  00ec1	75 27		 jne	 SHORT $L71579
$L71576:

; 763  : 			{
; 764  : 				if (((fealas & FVOICD) IS_PLUS)
; 765  : 					&& ((fealas & FOBST) IS_MINUS))

  00ec3	f6 c2 02	 test	 dl, 2
  00ec6	74 22		 je	 SHORT $L71579
  00ec8	f6 c2 20	 test	 dl, 32			; 00000020H
  00ecb	75 1d		 jne	 SHORT $L71579

; 766  : 				{
; 767  : 					if (pDphsettar->phcur == SIL)

  00ecd	66 3b c5	 cmp	 ax, bp
  00ed0	75 0d		 jne	 SHORT $L71578

; 768  : 					{
; 769  : 						pDphsettar->bouval = 52;

  00ed2	66 c7 06 34 00	 mov	 WORD PTR [esi], 52	; 00000034H

; 770  : 						pDphsettar->durtran = NF80MS;

  00ed7	66 c7 46 06 0d
	00		 mov	 WORD PTR [esi+6], 13	; 0000000dH

; 771  : 					}
; 772  : 					else

  00edd	eb 0b		 jmp	 SHORT $L71579
$L71578:

; 773  : 					{
; 774  : 						pDphsettar->bouval = 48;

  00edf	66 c7 06 30 00	 mov	 WORD PTR [esi], 48	; 00000030H

; 775  : 						pDphsettar->durtran = NF45MS;

  00ee4	66 c7 46 06 07
	00		 mov	 WORD PTR [esi+6], 7
$L71579:

; 776  : 					}
; 777  : 				}
; 778  : 			}
; 779  : 		}
; 780  : 		/* FORWARD SMOOTH:  TLT */
; 781  : 
; 782  : 		/* Tilt parameter jumps to target values near stops and silence */
; 783  : 		if (pDphsettar->np == &PTILT)

  00eea	8d 87 40 02 00
	00		 lea	 eax, DWORD PTR [edi+576]
  00ef0	3b c8		 cmp	 ecx, eax
  00ef2	75 3d		 jne	 SHORT $L71583

; 784  : 		{
; 785  : 			pDphsettar->durtran = NF25MS;
; 786  : 			if (pholas == SIL)

  00ef4	66 39 6c 24 1c	 cmp	 WORD PTR _pholas$[esp+12], bp
  00ef9	66 c7 46 06 04
	00		 mov	 WORD PTR [esi+6], 4
  00eff	75 06		 jne	 SHORT $L71581

; 787  : 			{
; 788  : 				pDphsettar->bouval = pDphsettar->np->tarcur;

  00f01	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00f04	66 89 0e	 mov	 WORD PTR [esi], cx
$L71581:

; 789  : 			}
; 790  : 			if (pDphsettar->phcur == SIL)

  00f07	66 39 6e 18	 cmp	 WORD PTR [esi+24], bp
  00f0b	75 0a		 jne	 SHORT $L71582

; 791  : 			{
; 792  : 				/* Reach into par buffer to get actual previous value */
; 793  : 				pDphsettar->bouval = pDph_t->parstochip[OUT_TLT];

  00f0d	66 8b 87 8a 03
	00 00		 mov	 ax, WORD PTR [edi+906]
  00f14	66 89 06	 mov	 WORD PTR [esi], ax
$L71582:

; 794  : 			}
; 795  : 			if (((fealas & FSTOP) IS_PLUS)
; 796  : 				|| ((feacur & FSTOP) IS_PLUS))

  00f17	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  00f1d	66 85 d2	 test	 dx, dx
  00f20	75 0b		 jne	 SHORT $L71584
  00f22	81 e3 00 20 00
	00		 and	 ebx, 8192		; 00002000H
  00f28	66 85 db	 test	 bx, bx
  00f2b	74 04		 je	 SHORT $L71583
$L71584:

; 797  : 			{
; 798  : 				pDphsettar->durtran = 0;

  00f2d	66 89 6e 06	 mov	 WORD PTR [esi+6], bp
$L71583:

; 799  : 			}
; 800  : 		}
; 801  : 	}
; 802  : 	/* Truncate tran dur if exceeds duration of current phone */
; 803  : 	if (pDphsettar->durtran > pDph_t->durfon)

  00f31	66 8b bf e0 14
	00 00		 mov	 di, WORD PTR [edi+5344]
  00f38	66 39 7e 06	 cmp	 WORD PTR [esi+6], di
  00f3c	7e 04		 jle	 SHORT $L71585

; 804  : 		pDphsettar->durtran = pDph_t->durfon;

  00f3e	66 89 7e 06	 mov	 WORD PTR [esi+6], di
$L71585:

; 805  : 	/* Or duration of 20 frames */
; 806  : 	if (pDphsettar->durtran > NF130MS)

  00f42	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00f47	66 39 46 06	 cmp	 WORD PTR [esi+6], ax
  00f4b	7e 04		 jle	 SHORT $L71586

; 807  : 		pDphsettar->durtran = NF130MS;

  00f4d	66 89 46 06	 mov	 WORD PTR [esi+6], ax
$L71586:

; 808  : 	/* Do not allow amplitude value to go below zero */
; 809  : 	if (pDphsettar->bouval < 0)

  00f51	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  00f55	7d 05		 jge	 SHORT $L71587

; 810  : 		pDphsettar->bouval = 0;

  00f57	66 c7 06 00 00	 mov	 WORD PTR [esi], 0
$L71587:
  00f5c	5f		 pop	 edi
  00f5d	5e		 pop	 esi
  00f5e	5d		 pop	 ebp
  00f5f	5b		 pop	 ebx

; 811  : }

  00f60	c3		 ret	 0
_forw_smooth_rules ENDP
_phTTS$ = 8
_shrib$ = 12
_feacur$ = 16
_feanex$ = 20
_strucnex$ = 24
_back_smooth_rules PROC NEAR

; 835  : {

  00f70	53		 push	 ebx
  00f71	55		 push	 ebp

; 836  : 	short                   temp;	   /* MVP MI : This varaible is made local */
; 837  : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  00f72	8b 6c 24 0c	 mov	 ebp, DWORD PTR _phTTS$[esp+4]
  00f76	56		 push	 esi
  00f77	57		 push	 edi
  00f78	8b 5d 18	 mov	 ebx, DWORD PTR [ebp+24]

; 838  : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 839  : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;

  00f7b	8b b3 d0 2b 00
	00		 mov	 esi, DWORD PTR [ebx+11216]

; 840  : 
; 841  : 	//debugfackward ("Set default", pDphsettar->np);
; 842  : 
; 843  : 	/* BACKWARD SMOOTH:  F1, F2, F3 */
; 844  : 	if (pDphsettar->par_type IS_FORM_FREQ)

  00f81	8a 46 14	 mov	 al, BYTE PTR [esi+20]
  00f84	3c 03		 cmp	 al, 3
  00f86	0f 85 0f 02 00
	00		 jne	 $L71603

; 845  : 	{
; 846  : 		/* 0. Use default values for obst-obst transition */
; 847  : 		if ((feacur & FSONOR) IS_PLUS)

  00f8c	8b 44 24 1c	 mov	 eax, DWORD PTR _feacur$[esp+12]
  00f90	8b 7c 24 20	 mov	 edi, DWORD PTR _feanex$[esp+12]
  00f94	a8 10		 test	 al, 16			; 00000010H
  00f96	0f 84 91 00 00
	00		 je	 $L71612

; 848  : 		{
; 849  : 			pDphsettar->durtran = NF45MS;
; 850  : 			if ((feacur & FSONCON) IS_MINUS)

  00f9c	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00fa1	66 c7 46 06 07
	00		 mov	 WORD PTR [esi+6], 7
  00fa7	66 85 c0	 test	 ax, ax
  00faa	75 58		 jne	 SHORT $L71605

; 851  : 			{
; 852  : 				if ((feanex & FSONCON) IS_PLUS)

  00fac	8b c7		 mov	 eax, edi
  00fae	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00fb3	66 85 c0	 test	 ax, ax
  00fb6	74 32		 je	 SHORT $L71606

; 853  : 				{
; 854  : 					/* 1. Vowel-soncon trans, use 75-25% rule */
; 855  : 					pDphsettar->bouval = (pDphsettar->bouval + pDphsettar->np->tarnex) >> 1;

  00fb8	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00fbb	0f bf 16	 movsx	 edx, WORD PTR [esi]
  00fbe	0f bf 48 16	 movsx	 ecx, WORD PTR [eax+22]
  00fc2	03 ca		 add	 ecx, edx
  00fc4	d1 f9		 sar	 ecx, 1
  00fc6	66 89 0e	 mov	 WORD PTR [esi], cx

; 856  : 					/* F3 transitions slower esp for [r,l] */
; 857  : 					if (pDphsettar->np == &PF3)

  00fc9	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  00fcc	3b c1		 cmp	 eax, ecx
  00fce	75 06		 jne	 SHORT $L71607

; 858  : 					{
; 859  : 						pDphsettar->durtran = NF64MS;

  00fd0	66 c7 46 06 0a
	00		 mov	 WORD PTR [esi+6], 10	; 0000000aH
$L71607:

; 860  : 					}
; 861  : 					/* First formant jumps down 80 Hz in /l/ */
; 862  : 					if ((pDphsettar->phonex == LL) && (pDphsettar->np == &PF1))

  00fd6	66 83 7e 0a 1b	 cmp	 WORD PTR [esi+10], 27	; 0000001bH
  00fdb	75 50		 jne	 SHORT $L71612
  00fdd	8d 53 24	 lea	 edx, DWORD PTR [ebx+36]
  00fe0	3b c2		 cmp	 eax, edx
  00fe2	75 49		 jne	 SHORT $L71612

; 863  : 					{
; 864  : 						pDphsettar->bouval += 80;

  00fe4	66 83 06 50	 add	 WORD PTR [esi], 80	; 00000050H

; 865  : 					}
; 866  : 				}
; 867  : 				else

  00fe8	eb 43		 jmp	 SHORT $L71612
$L71606:

; 868  : 				{
; 869  : 					/* 2. Vowel-[vowel/h] transition */
; 870  : 					/* Following [h] has little influence on pDphsettar->bouval */
; 871  : 					if (pDphsettar->phonex == HX)

  00fea	66 83 7e 0a 1c	 cmp	 WORD PTR [esi+10], 28	; 0000001cH
  00fef	75 3c		 jne	 SHORT $L71612

; 872  : 					{
; 873  : 						pDphsettar->bouval = (pDphsettar->bouval + pDphsettar->np->tarend) >> 1;

  00ff1	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00ff4	0f bf 16	 movsx	 edx, WORD PTR [esi]
  00ff7	0f bf 48 1a	 movsx	 ecx, WORD PTR [eax+26]
  00ffb	03 ca		 add	 ecx, edx
  00ffd	d1 f9		 sar	 ecx, 1
  00fff	66 89 0e	 mov	 WORD PTR [esi], cx

; 874  : 					}
; 875  : 				}
; 876  : 			}
; 877  : 			else

  01002	eb 29		 jmp	 SHORT $L71612
$L71605:

; 878  : 			{
; 879  : 				pDphsettar->durtran = NF40MS;
; 880  : 				if ((feanex & FSONCON) IS_MINUS)

  01004	8b c7		 mov	 eax, edi
  01006	66 c7 46 06 06
	00		 mov	 WORD PTR [esi+6], 6
  0100c	25 00 02 00 00	 and	 eax, 512		; 00000200H
  01011	66 85 c0	 test	 ax, ax
  01014	75 17		 jne	 SHORT $L71612

; 881  : 				{
; 882  : 					/* 3. Soncon-vowel trans, use 25-75% rule */
; 883  : 					pDphsettar->bouval = (pDphsettar->bouval + pDphsettar->np->tarend) >> 1;

  01016	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  01019	0f bf 06	 movsx	 eax, WORD PTR [esi]
  0101c	0f bf 51 1a	 movsx	 edx, WORD PTR [ecx+26]
  01020	03 d0		 add	 edx, eax

; 884  : 					pDphsettar->durtran = NF20MS;

  01022	66 c7 46 06 03
	00		 mov	 WORD PTR [esi+6], 3
  01028	d1 fa		 sar	 edx, 1
  0102a	66 89 16	 mov	 WORD PTR [esi], dx
$L71612:

; 885  : 				}
; 886  : 				else
; 887  : 				{
; 888  : 					/* 4. Soncon-soncon transition */
; 889  : 					/* Use defaults */
; 890  : 				}
; 891  : 			}
; 892  : 		}
; 893  : 		/* No backward smoothing if next phone is silence */
; 894  : 		if (pDphsettar->phonex == SIL)

  0102d	66 83 7e 0a 00	 cmp	 WORD PTR [esi+10], 0
  01032	75 0b		 jne	 SHORT $L71614

; 895  : 		{
; 896  : 			pDphsettar->durtran = 0;

  01034	66 c7 46 06 00
	00		 mov	 WORD PTR [esi+6], 0

; 897  : 		}
; 898  : 		else

  0103a	e9 04 01 00 00	 jmp	 $L71631
$L71614:

; 899  : 		{
; 900  : 			/* 5. pDphsettar->phcur=sonor, pDphsettar->phonex=obst transition */
; 901  : 			if (setloc (phTTS, pDph_t->nphone + 1, pDph_t->nphone, 'f', pDph_t->nphone + 2,feanex))

  0103f	66 8b 83 a4 23
	00 00		 mov	 ax, WORD PTR [ebx+9124]
  01046	57		 push	 edi
  01047	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  0104a	51		 push	 ecx
  0104b	6a 66		 push	 102			; 00000066H
  0104d	50		 push	 eax
  0104e	40		 inc	 eax
  0104f	50		 push	 eax
  01050	55		 push	 ebp
  01051	e8 00 00 00 00	 call	 _setloc

; 902  : 			{
; 903  : 				//debugfackward (" Use locus,percent", pDphsettar->np);
; 904  : 			}
; 905  : 			/* 6. pDphsettar->phcur=obst, pDphsettar->phonex=sonor transition */
; 906  : 			if (setloc (phTTS, pDph_t->nphone, pDph_t->nphone + 1, 'i', pDph_t->nphone - 1,feanex))

  01056	66 8b 83 a4 23
	00 00		 mov	 ax, WORD PTR [ebx+9124]
  0105d	57		 push	 edi
  0105e	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  01061	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  01064	52		 push	 edx
  01065	6a 69		 push	 105			; 00000069H
  01067	51		 push	 ecx
  01068	50		 push	 eax
  01069	55		 push	 ebp
  0106a	e8 00 00 00 00	 call	 _setloc

; 907  : 			{
; 908  : 				//debugfackward (" Use locus,percent", pDphsettar->np);
; 909  : 			}
; 910  : 			/* Transitions slow inside obstruents */
; 911  : 			if ((feacur & FOBST) IS_PLUS)

  0106f	8a 44 24 4c	 mov	 al, BYTE PTR _feacur$[esp+60]
  01073	83 c4 30	 add	 esp, 48			; 00000030H
  01076	a8 20		 test	 al, 32			; 00000020H
  01078	74 37		 je	 SHORT $L71621

; 912  : 			{
; 913  : 				pDphsettar->durtran = NF30MS;
; 914  : 				if (pDphsettar->np == &PF1)

  0107a	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0107d	8d 43 24	 lea	 eax, DWORD PTR [ebx+36]
  01080	3b c8		 cmp	 ecx, eax
  01082	66 c7 46 06 05
	00		 mov	 WORD PTR [esi+6], 5
  01088	75 06		 jne	 SHORT $L71619

; 915  : 					pDphsettar->durtran = NF20MS;

  0108a	66 c7 46 06 03
	00		 mov	 WORD PTR [esi+6], 3
$L71619:

; 916  : 				/* Transitions take all of plosive duration */
; 917  : 				if ((feacur & FPLOSV) IS_PLUS)

  01090	f6 44 24 1c 40	 test	 BYTE PTR _feacur$[esp+12], 64 ; 00000040H
  01095	74 1a		 je	 SHORT $L71621

; 918  : 				{
; 919  : 					pDphsettar->durtran = pDph_t->durfon;

  01097	66 8b 93 e0 14
	00 00		 mov	 dx, WORD PTR [ebx+5344]

; 920  : 					if ((pDphsettar->np == &PF1) && ((feacur & FVOICD) IS_MINUS))

  0109e	3b c8		 cmp	 ecx, eax
  010a0	66 89 56 06	 mov	 WORD PTR [esi+6], dx
  010a4	75 0b		 jne	 SHORT $L71621
  010a6	f6 44 24 1c 02	 test	 BYTE PTR _feacur$[esp+12], 2
  010ab	75 04		 jne	 SHORT $L71621

; 921  : 					{
; 922  : 						pDphsettar->bouval += 100;

  010ad	66 83 06 64	 add	 WORD PTR [esi], 100	; 00000064H
$L71621:

; 923  : 					}
; 924  : 				}
; 925  : 			}
; 926  : 			/* Higher formant transitions slow inside a nasal */
; 927  : 			if ((feacur & FNASAL) IS_PLUS)

  010b1	f6 44 24 1c 80	 test	 BYTE PTR _feacur$[esp+12], -128 ; ffffff80H
  010b6	0f 84 87 00 00
	00		 je	 $L71631

; 928  : 			{
; 929  : 				pDphsettar->durtran = pDph_t->durfon;
; 930  : 				/* Except F1, which jumps to value below FNZRO */
; 931  : 				if (pDphsettar->np == &PF1)

  010bc	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  010bf	66 8b 83 e0 14
	00 00		 mov	 ax, WORD PTR [ebx+5344]
  010c6	8d 4b 24	 lea	 ecx, DWORD PTR [ebx+36]
  010c9	66 89 46 06	 mov	 WORD PTR [esi+6], ax
  010cd	3b d1		 cmp	 edx, ecx
  010cf	75 08		 jne	 SHORT $L71623

; 932  : 				{
; 933  : 					pDphsettar->durtran = 0;

  010d1	66 c7 46 06 00
	00		 mov	 WORD PTR [esi+6], 0

; 934  : 				}
; 935  : 				/* Lower F2 & F3 of [n] nasal murmur before front vowels */
; 936  : 				else if (((pDphsettar->phcur == N) || (pDphsettar->phcur == EN))

  010d7	eb 6a		 jmp	 SHORT $L71631
$L71623:

; 937  : 						 && (begtyp[pDphsettar->phonex] == 1))

  010d9	66 8b 4e 18	 mov	 cx, WORD PTR [esi+24]
  010dd	66 83 f9 20	 cmp	 cx, 32			; 00000020H
  010e1	74 06		 je	 SHORT $L71626
  010e3	66 83 f9 24	 cmp	 cx, 36			; 00000024H
  010e7	75 3a		 jne	 SHORT $L71625
$L71626:
  010e9	0f bf 46 0a	 movsx	 eax, WORD PTR [esi+10]
  010ed	d1 e0		 shl	 eax, 1
  010ef	66 83 b8 00 00
	00 00 01	 cmp	 WORD PTR _begtyp[eax], 1
  010f7	75 2a		 jne	 SHORT $L71625

; 938  : 				{
; 939  : 					if (pDphsettar->np == &PF2)

  010f9	8d 4b 48	 lea	 ecx, DWORD PTR [ebx+72]
  010fc	3b d1		 cmp	 edx, ecx
  010fe	75 16		 jne	 SHORT $L71628

; 940  : 					{
; 941  : 						pDphsettar->bouval -= 100;

  01100	66 83 06 9c	 add	 WORD PTR [esi], -100	; ffffff9cH
  01104	66 8b 0e	 mov	 cx, WORD PTR [esi]

; 942  : 						if ((place[pDphsettar->phonex] & F2BACKI) IS_PLUS)

  01107	f6 80 00 00 00
	00 40		 test	 BYTE PTR _place[eax], 64 ; 00000040H
  0110e	74 06		 je	 SHORT $L71628

; 943  : 						{
; 944  : 							pDphsettar->bouval -= 100;

  01110	83 c1 9c	 add	 ecx, -100		; ffffff9cH
  01113	66 89 0e	 mov	 WORD PTR [esi], cx
$L71628:

; 945  : 						}
; 946  : 					}
; 947  : 					if (pDphsettar->np == &PF3)

  01116	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  01119	3b d0		 cmp	 edx, eax
  0111b	75 26		 jne	 SHORT $L71631

; 948  : 						pDphsettar->bouval -= 100;

  0111d	66 83 06 9c	 add	 WORD PTR [esi], -100	; ffffff9cH

; 949  : 				}
; 950  : 				/* Lower F2 of [m] murmur near [i,y,yu,ir] */
; 951  : 				else if ((pDphsettar->np == &PF2) && (pDphsettar->phcur == M)

  01121	eb 20		 jmp	 SHORT $L71631
$L71625:

; 952  : 						 && ((place[pDphsettar->phonex] & F2BACKI) IS_PLUS))

  01123	8d 43 48	 lea	 eax, DWORD PTR [ebx+72]
  01126	3b d0		 cmp	 edx, eax
  01128	75 19		 jne	 SHORT $L71631
  0112a	66 83 f9 1f	 cmp	 cx, 31			; 0000001fH
  0112e	75 13		 jne	 SHORT $L71631
  01130	0f bf 4e 0a	 movsx	 ecx, WORD PTR [esi+10]
  01134	f6 04 4d 00 00
	00 00 40	 test	 BYTE PTR _place[ecx*2], 64 ; 00000040H
  0113c	74 05		 je	 SHORT $L71631

; 953  : 				{
; 954  : 					pDphsettar->bouval -= 150;

  0113e	66 81 06 6a ff	 add	 WORD PTR [esi], -150	; ffffff6aH
$L71631:

; 955  : 				}
; 956  : 			}
; 957  : 		}
; 958  : 		/* Shrink tran dur inside sonorant if sonorant short */
; 959  : 		if (((feacur & FOBST) IS_MINUS)
; 960  : 			&& (begtyp[pDphsettar->phonex] != 4)	/* Unless next seg is obst */
; 961  : 			&& (pDphsettar->durtran > 0))

  01143	f6 44 24 1c 20	 test	 BYTE PTR _feacur$[esp+12], 32 ; 00000020H
  01148	0f 85 18 04 00
	00		 jne	 $endbsmo$71662
  0114e	0f bf 56 0a	 movsx	 edx, WORD PTR [esi+10]
  01152	66 83 3c 55 00
	00 00 00 04	 cmp	 WORD PTR _begtyp[edx*2], 4
  0115b	0f 84 05 04 00
	00		 je	 $endbsmo$71662
  01161	66 8b 46 06	 mov	 ax, WORD PTR [esi+6]
  01165	66 85 c0	 test	 ax, ax
  01168	0f 8e f8 03 00
	00		 jle	 $endbsmo$71662

; 962  : 		{
; 963  : 			pDph_t->arg1 = pDphsettar->durtran;

  0116e	66 89 83 f8 14
	00 00		 mov	 WORD PTR [ebx+5368], ax

; 964  : 			pDph_t->arg2 = shrib;

  01175	66 8b 44 24 18	 mov	 ax, WORD PTR _shrib$[esp+12]

; 965  : 			pDphsettar->durtran = mlsh1 (pDph_t->arg1, pDph_t->arg2) + 1;

  0117a	0f bf 8b f8 14
	00 00		 movsx	 ecx, WORD PTR [ebx+5368]
  01181	0f bf d0	 movsx	 edx, ax
  01184	0f af ca	 imul	 ecx, edx
  01187	c1 f9 0e	 sar	 ecx, 14			; 0000000eH
  0118a	41		 inc	 ecx
  0118b	66 89 83 fa 14
	00 00		 mov	 WORD PTR [ebx+5370], ax
  01192	66 89 4e 06	 mov	 WORD PTR [esi+6], cx

; 966  : 		}
; 967  : 	}
; 968  : 	/* BACKWARD SMOOTH:  FN */
; 969  : 	else if (pDphsettar->par_type IS_NASAL_ZERO_FREQ)

  01196	e9 cb 03 00 00	 jmp	 $endbsmo$71662
$L71603:
  0119b	3c 01		 cmp	 al, 1
  0119d	75 38		 jne	 SHORT $L71634

; 970  : 	{
; 971  : 		pDphsettar->durtran = 0;
; 972  : 		/* Nasalization cue: place zero between F1 and FP */
; 973  : 		if (((feanex & FNASAL) IS_PLUS)
; 974  : 			&& ((feacur & FNASAL) IS_MINUS))

  0119f	8a 44 24 20	 mov	 al, BYTE PTR _feanex$[esp+12]
  011a3	66 c7 46 06 00
	00		 mov	 WORD PTR [esi+6], 0
  011a9	a8 80		 test	 al, -128		; ffffff80H
  011ab	0f 84 b5 03 00
	00		 je	 $endbsmo$71662
  011b1	f6 44 24 1c 80	 test	 BYTE PTR _feacur$[esp+12], -128 ; ffffff80H
  011b6	0f 85 aa 03 00
	00		 jne	 $endbsmo$71662

; 975  : 		{
; 976  : 			pDphsettar->bouval = NASAL_ZERO_BOUNDARY;
; 977  : 			pDphsettar->durtran = NF80MS;
; 978  : 			if (pDphsettar->phonex == EN)

  011bc	66 83 7e 0a 24	 cmp	 WORD PTR [esi+10], 36	; 00000024H
  011c1	66 c7 06 72 01	 mov	 WORD PTR [esi], 370	; 00000172H
  011c6	66 c7 46 06 0d
	00		 mov	 WORD PTR [esi+6], 13	; 0000000dH
  011cc	0f 85 94 03 00
	00		 jne	 $endbsmo$71662

; 979  : 				pDphsettar->durtran = NF130MS;
; 980  : 		}
; 981  : 	}
; 982  : 	/* BACKWARD SMOOTH:  B1, B2, B3 */
; 983  : 	else if (pDphsettar->par_type IS_FORM_BW)

  011d2	e9 89 03 00 00	 jmp	 $L72036
$L71634:
  011d7	3c 04		 cmp	 al, 4
  011d9	0f 85 2e 01 00
	00		 jne	 $L71638

; 984  : 	{
; 985  : 		pDphsettar->durtran = NF40MS;
; 986  : 		if ((feacur & FVOICD) IS_PLUS)

  011df	8a 44 24 1c	 mov	 al, BYTE PTR _feacur$[esp+12]
  011e3	b1 02		 mov	 cl, 2
  011e5	84 c1		 test	 al, cl
  011e7	66 c7 46 06 06
	00		 mov	 WORD PTR [esi+6], 6
  011ed	bd 08 00 00 00	 mov	 ebp, 8
  011f2	74 38		 je	 SHORT $L71639

; 987  : 		{
; 988  : 			/* Glottis opens early before -voice C, widen B1 */
; 989  : 			if (pDphsettar->np == &PB1)

  011f4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  011f7	8d 93 b4 00 00
	00		 lea	 edx, DWORD PTR [ebx+180]
  011fd	3b c2		 cmp	 eax, edx
  011ff	75 31		 jne	 SHORT $L71643

; 990  : 			{
; 991  : 				if ((feanex & FVOICD) IS_MINUS)

  01201	84 4c 24 20	 test	 BYTE PTR _feanex$[esp+12], cl
  01205	75 2b		 jne	 SHORT $L71643

; 992  : 				{
; 993  : 					pDphsettar->durtran = NF50MS;

  01207	66 89 6e 06	 mov	 WORD PTR [esi+6], bp

; 994  : 					/* More increase for low vowels (F1 high) */
; 995  : 					pDphsettar->bouval = pDphsettar->np->tarend + (PF1.tarcur >> 3);

  0120b	66 8b 4b 24	 mov	 cx, WORD PTR [ebx+36]
  0120f	66 c1 f9 03	 sar	 cx, 3
  01213	66 03 48 1a	 add	 cx, WORD PTR [eax+26]
  01217	66 89 0e	 mov	 WORD PTR [esi], cx

; 996  : 					/* Effect is greater for a female voice */
; 997  : 					if (pDph_t->malfem == FEMALE)

  0121a	66 83 bb e4 14
	00 00 00	 cmp	 WORD PTR [ebx+5348], 0
  01222	75 0e		 jne	 SHORT $L71643

; 998  : 					{
; 999  : 						pDphsettar->durtran = NF100MS;

  01224	66 c7 46 06 10
	00		 mov	 WORD PTR [esi+6], 16	; 00000010H

; 1000 : 					}
; 1001 : 				}
; 1002 : 			}
; 1003 : 		}
; 1004 : 		else

  0122a	eb 06		 jmp	 SHORT $L71643
$L71639:

; 1005 : 		{
; 1006 : 			pDphsettar->durtran = NF20MS;

  0122c	66 c7 46 06 03
	00		 mov	 WORD PTR [esi+6], 3
$L71643:

; 1007 : 		}
; 1008 : 		/* Treat boundary with silence */
; 1009 : 		/* OUT ??? */
; 1010 : 		if (pDphsettar->phonex == SIL)

  01232	66 83 7e 0a 00	 cmp	 WORD PTR [esi+10], 0
  01237	75 2c		 jne	 SHORT $L71644

; 1011 : 		{
; 1012 : 			pDphsettar->bouval = pDphsettar->np->tarend + ((&PB3 - pDphsettar->np) * 50);

  01239	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0123c	8b cb		 mov	 ecx, ebx
  0123e	2b cf		 sub	 ecx, edi
  01240	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  01245	81 c1 fc 00 00
	00		 add	 ecx, 252		; 000000fcH
  0124b	f7 e9		 imul	 ecx
  0124d	c1 fa 03	 sar	 edx, 3
  01250	8b c2		 mov	 eax, edx
  01252	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  01255	03 d0		 add	 edx, eax
  01257	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  0125a	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  0125d	d1 e1		 shl	 ecx, 1
  0125f	66 03 4f 1a	 add	 cx, WORD PTR [edi+26]

; 1013 : 			pDphsettar->durtran = NF50MS;
; 1014 : 		}
; 1015 : 		else if (pDphsettar->phcur == SIL)

  01263	eb 31		 jmp	 SHORT $L72037
$L71644:
  01265	66 83 7e 18 00	 cmp	 WORD PTR [esi+24], 0
  0126a	75 31		 jne	 SHORT $L71646

; 1016 : 		{
; 1017 : 			pDphsettar->bouval = pDphsettar->np->tarnex + ((&PB3 - pDphsettar->np) * 50);

  0126c	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0126f	8b cb		 mov	 ecx, ebx
  01271	2b cf		 sub	 ecx, edi
  01273	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  01278	81 c1 fc 00 00
	00		 add	 ecx, 252		; 000000fcH
  0127e	f7 e9		 imul	 ecx
  01280	c1 fa 03	 sar	 edx, 3
  01283	8b c2		 mov	 eax, edx
  01285	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  01288	03 d0		 add	 edx, eax
  0128a	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  0128d	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  01290	d1 e1		 shl	 ecx, 1
  01292	66 03 4f 16	 add	 cx, WORD PTR [edi+22]
$L72037:
  01296	66 89 0e	 mov	 WORD PTR [esi], cx

; 1018 : 			pDphsettar->durtran = NF50MS;

  01299	66 89 6e 06	 mov	 WORD PTR [esi+6], bp
$L71646:

; 1019 : 		}
; 1020 : 		/* BW1 widen, to nasalize transition into next nasal */
; 1021 : 		if ((feanex & FNASAL) IS_PLUS)

  0129d	f6 44 24 20 80	 test	 BYTE PTR _feanex$[esp+12], -128 ; ffffff80H
  012a2	74 53		 je	 SHORT $L71650

; 1022 : 		{
; 1023 : 			pDphsettar->bouval = pDphsettar->np->tarend;

  012a4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 1024 : 			/* Except F2 of [n], which is wider before a non-front vowel */
; 1025 : 			if ((pDphsettar->np == &PB2) && ((pDphsettar->phonex == N) || (pDphsettar->phonex == EN))
; 1026 : 				&& (endtyp[pDphsettar->phcur] != 1))

  012a7	8d 93 d8 00 00
	00		 lea	 edx, DWORD PTR [ebx+216]
  012ad	3b c2		 cmp	 eax, edx
  012af	66 8b 48 1a	 mov	 cx, WORD PTR [eax+26]
  012b3	66 89 0e	 mov	 WORD PTR [esi], cx
  012b6	75 2b		 jne	 SHORT $L71648
  012b8	66 8b 56 0a	 mov	 dx, WORD PTR [esi+10]
  012bc	66 83 fa 20	 cmp	 dx, 32			; 00000020H
  012c0	74 06		 je	 SHORT $L71649
  012c2	66 83 fa 24	 cmp	 dx, 36			; 00000024H
  012c6	75 1b		 jne	 SHORT $L71648
$L71649:
  012c8	0f bf 56 18	 movsx	 edx, WORD PTR [esi+24]
  012cc	66 83 3c 55 00
	00 00 00 01	 cmp	 WORD PTR _endtyp[edx*2], 1
  012d5	74 0c		 je	 SHORT $L71648

; 1027 : 			{
; 1028 : 				pDphsettar->bouval += 60;

  012d7	83 c1 3c	 add	 ecx, 60			; 0000003cH

; 1029 : 				pDphsettar->durtran = NF60MS;

  012da	66 c7 46 06 09
	00		 mov	 WORD PTR [esi+6], 9
  012e0	66 89 0e	 mov	 WORD PTR [esi], cx
$L71648:

; 1030 : 			}
; 1031 : 			if (pDphsettar->np == &PB1)

  012e3	8d 8b b4 00 00
	00		 lea	 ecx, DWORD PTR [ebx+180]
  012e9	3b c1		 cmp	 eax, ecx
  012eb	75 0a		 jne	 SHORT $L71650

; 1032 : 			{
; 1033 : 				pDphsettar->durtran = NF100MS;
; 1034 : 				pDphsettar->bouval += 100;

  012ed	66 83 06 64	 add	 WORD PTR [esi], 100	; 00000064H
  012f1	66 c7 46 06 10
	00		 mov	 WORD PTR [esi+6], 16	; 00000010H
$L71650:

; 1035 : 			}
; 1036 : 		}
; 1037 : 		/* Nasals have constant bandwidths at target values */
; 1038 : 		if ((feacur & FNASAL) IS_PLUS)

  012f7	f6 44 24 1c 80	 test	 BYTE PTR _feacur$[esp+12], -128 ; ffffff80H
  012fc	0f 84 64 02 00
	00		 je	 $endbsmo$71662

; 1039 : 		{
; 1040 : 			pDphsettar->durtran = 0;

  01302	66 c7 46 06 00
	00		 mov	 WORD PTR [esi+6], 0

; 1041 : 			//debugfackward (" Nasal has const. par val", pDphsettar->np);
; 1042 : 		}
; 1043 : 	}
; 1044 : 	/* BACKWARD SMOOTH:  AV, AP, A2, A3, A4, A5, A6, AB */
; 1045 : 	else if ((pDphsettar->par_type IS_PARALLEL_FORM_AMP)

  01308	e9 59 02 00 00	 jmp	 $endbsmo$71662
$L71638:

; 1046 : 			 || (pDphsettar->par_type IS_AV_OR_AH))

  0130d	33 ff		 xor	 edi, edi
  0130f	3c 02		 cmp	 al, 2
  01311	74 08		 je	 SHORT $L71654
  01313	84 c0		 test	 al, al
  01315	0f 85 4b 02 00
	00		 jne	 $endbsmo$71662
$L71654:

; 1047 : 	{
; 1048 : 		/* See if onset, i.e. source intensity increasing */
; 1049 : 		temp = pDphsettar->np->tarnex - 10;

  0131b	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  0131e	66 8b 45 16	 mov	 ax, WORD PTR [ebp+22]
  01322	66 2d 0a 00	 sub	 ax, 10			; 0000000aH

; 1050 : 		if (pDphsettar->bouval < temp)

  01326	66 39 06	 cmp	 WORD PTR [esi], ax
  01329	7d 0f		 jge	 SHORT $L71656

; 1051 : 		{
; 1052 : 			pDphsettar->bouval = temp;
; 1053 : 			/* Onset of an init fricative or /h/ is very gradual */
; 1054 : 			if (pDphsettar->phcur == SIL)

  0132b	66 39 7e 18	 cmp	 WORD PTR [esi+24], di
  0132f	66 89 06	 mov	 WORD PTR [esi], ax
  01332	75 06		 jne	 SHORT $L71656

; 1055 : 			{
; 1056 : 				pDphsettar->durtran = NF70MS;

  01334	66 c7 46 06 0b
	00		 mov	 WORD PTR [esi+6], 11	; 0000000bH
$L71656:

; 1057 : 			}
; 1058 : 			//debugfackward (" Onset", pDphsettar->np);
; 1059 : 		}
; 1060 : 		/* Voicing is special:  onset is abrupt, except if a voiced fric */
; 1061 : 		if ((pDphsettar->np == &PAV) && (pDphsettar->bouval < pDphsettar->np->tarnex)
; 1062 : 			&& (pDphsettar->phcur != V) && (pDphsettar->phcur != DH)
; 1063 : 			&& (pDphsettar->phcur != JH) && (pDphsettar->phcur != ZH) && (pDphsettar->phcur != Z))

  0133a	8b 4c 24 1c	 mov	 ecx, DWORD PTR _feacur$[esp+12]
  0133e	8d 83 20 01 00
	00		 lea	 eax, DWORD PTR [ebx+288]
  01344	3b e8		 cmp	 ebp, eax
  01346	75 5d		 jne	 SHORT $L71658
  01348	66 8b 16	 mov	 dx, WORD PTR [esi]
  0134b	66 3b 55 16	 cmp	 dx, WORD PTR [ebp+22]
  0134f	7d 54		 jge	 SHORT $L71658
  01351	66 8b 46 18	 mov	 ax, WORD PTR [esi+24]
  01355	66 3d 26 00	 cmp	 ax, 38			; 00000026H
  01359	74 4a		 je	 SHORT $L71658
  0135b	66 3d 28 00	 cmp	 ax, 40			; 00000028H
  0135f	74 44		 je	 SHORT $L71658
  01361	66 3d 37 00	 cmp	 ax, 55			; 00000037H
  01365	74 3e		 je	 SHORT $L71658
  01367	66 3d 2c 00	 cmp	 ax, 44			; 0000002cH
  0136b	74 38		 je	 SHORT $L71658
  0136d	66 3d 2a 00	 cmp	 ax, 42			; 0000002aH
  01371	74 32		 je	 SHORT $L71658

; 1064 : 		{
; 1065 : 			pDphsettar->durtran = 0;
; 1066 : 			//debugfackward (" Make next onset abrupt", pDphsettar->np);
; 1067 : 			/* Voicebar dies out in a voiced plosive */
; 1068 : 			if (((feacur & FPLOSV) IS_PLUS) || (pDphsettar->phcur == CH))

  01373	f6 c1 40	 test	 cl, 64			; 00000040H
  01376	66 89 7e 06	 mov	 WORD PTR [esi+6], di
  0137a	75 06		 jne	 SHORT $L71659
  0137c	66 3d 36 00	 cmp	 ax, 54			; 00000036H
  01380	75 23		 jne	 SHORT $L71658
$L71659:

; 1069 : 			{
; 1070 : 				if ((feacur & FVOICD) IS_PLUS)

  01382	f6 c1 02	 test	 cl, 2
  01385	74 16		 je	 SHORT $L71660

; 1071 : 				{
; 1072 : 					pDphsettar->bouval = pDphsettar->np->tarend - 3;

  01387	66 8b 45 1a	 mov	 ax, WORD PTR [ebp+26]

; 1073 : 					pDphsettar->durtran = NF45MS;

  0138b	66 c7 46 06 07
	00		 mov	 WORD PTR [esi+6], 7
  01391	66 2d 03 00	 sub	 ax, 3
  01395	66 89 06	 mov	 WORD PTR [esi], ax

; 1074 : 					//debugfackward (" Voicebar dies out", pDphsettar->np);
; 1075 : 				}
; 1076 : 				/* Do not allow prevoicing in a voiceless plosive */
; 1077 : 				else

  01398	e9 c9 01 00 00	 jmp	 $endbsmo$71662
$L71660:

; 1078 : 				{
; 1079 : 					pDphsettar->bouval = 0;

  0139d	66 89 3e	 mov	 WORD PTR [esi], di

; 1080 : 				}
; 1081 : 				goto endbsmo;

  013a0	e9 c1 01 00 00	 jmp	 $endbsmo$71662
$L71658:

; 1082 : 			}
; 1083 : 		}
; 1084 : 		/* If next nasal, & curr phone is voiced, set AV const */
; 1085 : 		if (((feanex & FNASAL) IS_PLUS)
; 1086 : 			&& ((feacur & FVOICD) IS_PLUS))

  013a5	8a 54 24 20	 mov	 dl, BYTE PTR _feanex$[esp+12]
  013a9	f6 c2 80	 test	 dl, -128		; ffffff80H
  013ac	74 09		 je	 SHORT $L71663
  013ae	f6 c1 02	 test	 cl, 2
  013b1	74 04		 je	 SHORT $L71663

; 1087 : 		{
; 1088 : 			pDphsettar->durtran = 0;

  013b3	66 89 7e 06	 mov	 WORD PTR [esi+6], di
$L71663:

; 1089 : 			//debugforward (" AV const in voiced to  nasal", pDphsettar->np);
; 1090 : 		}
; 1091 : 		/* If curr phone nasal, and next is voiced non-obst, AV const */
; 1092 : 		if ((feacur & FNASAL) IS_PLUS)

  013b7	8b 7c 24 24	 mov	 edi, DWORD PTR _strucnex$[esp+12]
  013bb	8b c1		 mov	 eax, ecx
  013bd	25 80 00 00 00	 and	 eax, 128		; 00000080H
  013c2	66 85 c0	 test	 ax, ax
  013c5	89 44 24 18	 mov	 DWORD PTR 12+[esp+12], eax
  013c9	74 23		 je	 SHORT $L71666

; 1093 : 		{
; 1094 : 			if (((feanex & FVOICD) IS_PLUS)
; 1095 : 				&& ((feanex & FOBST) IS_MINUS)
; 1096 : 				&& ((strucnex & FDUMMY_VOWEL) IS_MINUS))

  013cb	f6 c2 02	 test	 dl, 2
  013ce	74 18		 je	 SHORT $L71665
  013d0	f6 c2 20	 test	 dl, 32			; 00000020H
  013d3	75 13		 jne	 SHORT $L71665
  013d5	8b cf		 mov	 ecx, edi
  013d7	81 e1 00 08 00
	00		 and	 ecx, 2048		; 00000800H
  013dd	66 85 c9	 test	 cx, cx
  013e0	75 06		 jne	 SHORT $L71665

; 1097 : 			{
; 1098 : 				pDphsettar->durtran = 0;

  013e2	66 89 4e 06	 mov	 WORD PTR [esi+6], cx

; 1099 : 				//debugfackward (" Make murmur const AV", pDphsettar->np);
; 1100 : 			}
; 1101 : 			else

  013e6	eb 06		 jmp	 SHORT $L71666
$L71665:

; 1102 : 			{
; 1103 : 				pDphsettar->durtran = NF40MS;

  013e8	66 c7 46 06 06
	00		 mov	 WORD PTR [esi+6], 6
$L71666:

; 1104 : 			}
; 1105 : 		}
; 1106 : 		/* See if offset, i.e. source intensity decreasing */
; 1107 : 		temp = pDphsettar->np->tarend - 10;

  013ee	66 8b 45 1a	 mov	 ax, WORD PTR [ebp+26]

; 1108 : 		/* Plosive burst does not get attenuated during offset */
; 1109 : 		if (pDphsettar->phcur >= P)

  013f2	66 8b 4e 18	 mov	 cx, WORD PTR [esi+24]
  013f6	66 2d 0a 00	 sub	 ax, 10			; 0000000aH
  013fa	66 83 f9 2d	 cmp	 cx, 45			; 0000002dH
  013fe	7c 10		 jl	 SHORT $L71668

; 1110 : 		{
; 1111 : 			pDphsettar->durtran = NF15MS;
; 1112 : 			if (pDphsettar->phcur < CH)

  01400	66 83 f9 36	 cmp	 cx, 54			; 00000036H
  01404	66 c7 46 06 02
	00		 mov	 WORD PTR [esi+6], 2
  0140a	7d 04		 jge	 SHORT $L71668

; 1113 : 			{
; 1114 : 				temp = pDphsettar->np->tarend;

  0140c	66 8b 45 1a	 mov	 ax, WORD PTR [ebp+26]
$L71668:

; 1115 : 			}
; 1116 : 		}
; 1117 : 		if (pDphsettar->bouval < temp)

  01410	66 39 06	 cmp	 WORD PTR [esi], ax
  01413	7d 0c		 jge	 SHORT $L71669

; 1118 : 		{							   /* Or does it ??? */
; 1119 : 			pDphsettar->bouval = temp - 3;

  01415	8d 50 fd	 lea	 edx, DWORD PTR [eax-3]

; 1120 : 			pDphsettar->durtran = NF20MS;

  01418	66 c7 46 06 03
	00		 mov	 WORD PTR [esi+6], 3
  0141e	66 89 16	 mov	 WORD PTR [esi], dx
$L71669:

; 1121 : 		}
; 1122 : 		/* Voicing amp falls gradually at end of phrase */
; 1123 : 		/* (Source sudden offset, or next seg is a dummy vowel) */
; 1124 : 		if (pDphsettar->np == &PAV)

  01421	8d 93 20 01 00
	00		 lea	 edx, DWORD PTR [ebx+288]
  01427	3b ea		 cmp	 ebp, edx
  01429	75 4f		 jne	 SHORT $L71673

; 1125 : 		{
; 1126 : 			if ((pDphsettar->bouval < temp) || ((temp > 0)
; 1127 : 												&& (pDphsettar->np == &PAV) && ((strucnex & FDUMMY_VOWEL) IS_PLUS)))

  0142b	66 39 06	 cmp	 WORD PTR [esi], ax
  0142e	7c 2c		 jl	 SHORT $L71672
  01430	66 85 c0	 test	 ax, ax
  01433	7e 0d		 jle	 SHORT $L71671
  01435	8b d7		 mov	 edx, edi
  01437	81 e2 00 08 00
	00		 and	 edx, 2048		; 00000800H
  0143d	66 85 d2	 test	 dx, dx
  01440	75 1a		 jne	 SHORT $L71672
$L71671:

; 1134 : 				}
; 1135 : 			}
; 1136 : 			else if (pDphsettar->np == &PAP)

  01442	8d 83 44 01 00
	00		 lea	 eax, DWORD PTR [ebx+324]
  01448	3b e8		 cmp	 ebp, eax
  0144a	75 2e		 jne	 SHORT $L71673

; 1137 : 				pDphsettar->bouval = PAP.tarend - 6;

  0144c	66 8b 93 5e 01
	00 00		 mov	 dx, WORD PTR [ebx+350]
  01453	66 83 ea 06	 sub	 dx, 6
  01457	66 89 16	 mov	 WORD PTR [esi], dx
  0145a	eb 1e		 jmp	 SHORT $L71673
$L71672:

; 1128 : 			{
; 1129 : 				pDphsettar->bouval = temp + 3;

  0145c	83 c0 03	 add	 eax, 3

; 1130 : 				if ((pDphsettar->phonex == SIL)
; 1131 : 					|| ((strucnex & FDUMMY_VOWEL) IS_PLUS))

  0145f	66 83 7e 0a 00	 cmp	 WORD PTR [esi+10], 0
  01464	66 89 06	 mov	 WORD PTR [esi], ax
  01467	74 0b		 je	 SHORT $L71674
  01469	81 e7 00 08 00
	00		 and	 edi, 2048		; 00000800H
  0146f	66 85 ff	 test	 di, di
  01472	74 06		 je	 SHORT $L71673
$L71674:

; 1132 : 				{
; 1133 : 					pDphsettar->durtran = NF75MS;

  01474	66 c7 46 06 0c
	00		 mov	 WORD PTR [esi+6], 12	; 0000000cH
$L71673:

; 1138 : 			//debugfackward (" Offset to noise", pDphsettar->np);
; 1139 : 		}
; 1140 : 		/* No smoothing of source amps if next segment has burst */
; 1141 : 		if ((pDphsettar->phonex >= P)
; 1142 : 			&& (((feacur & FNASAL) IS_MINUS) || (pDphsettar->np != &PAV)))

  0147a	66 8b 7e 0a	 mov	 di, WORD PTR [esi+10]
  0147e	66 83 ff 2d	 cmp	 di, 45			; 0000002dH
  01482	7c 18		 jl	 SHORT $L71677
  01484	66 83 7c 24 18
	00		 cmp	 WORD PTR 12+[esp+12], 0
  0148a	74 0a		 je	 SHORT $L71678
  0148c	8d 83 20 01 00
	00		 lea	 eax, DWORD PTR [ebx+288]
  01492	3b e8		 cmp	 ebp, eax
  01494	74 06		 je	 SHORT $L71677
$L71678:

; 1143 : 		{
; 1144 : 			pDphsettar->durtran = 0;

  01496	66 c7 46 06 00
	00		 mov	 WORD PTR [esi+6], 0
$L71677:

; 1145 : 			//debugfackward (" Stop closure next", pDphsettar->np);
; 1146 : 		}
; 1147 : 		/* Onset of a vowel from voiceless open vocal tract is breathy */
; 1148 : 		if (pDphsettar->np == &PAP)

  0149c	8d 83 44 01 00
	00		 lea	 eax, DWORD PTR [ebx+324]
  014a2	3b e8		 cmp	 ebp, eax
  014a4	75 50		 jne	 SHORT $L72034

; 1149 : 		{
; 1150 : 			if (
; 1151 : 			/* OUT                    (pDphsettar->phcur == SIL) ||                         END OUT */
; 1152 : 				   (pDphsettar->phcur == F) || (pDphsettar->phcur == TH)
; 1153 : 				   || (pDphsettar->phcur == S) || (pDphsettar->phcur == SH))

  014a6	66 83 f9 25	 cmp	 cx, 37			; 00000025H
  014aa	74 12		 je	 SHORT $L71681
  014ac	66 83 f9 27	 cmp	 cx, 39			; 00000027H
  014b0	74 0c		 je	 SHORT $L71681
  014b2	66 83 f9 29	 cmp	 cx, 41			; 00000029H
  014b6	74 06		 je	 SHORT $L71681
  014b8	66 83 f9 2b	 cmp	 cx, 43			; 0000002bH
  014bc	75 19		 jne	 SHORT $L72032
$L71681:

; 1154 : 			{
; 1155 : 				if (((feanex & FVOICD) IS_PLUS)
; 1156 : 					&& ((feanex & FOBST) IS_MINUS))

  014be	8b 44 24 20	 mov	 eax, DWORD PTR _feanex$[esp+12]
  014c2	a8 02		 test	 al, 2
  014c4	74 15		 je	 SHORT $L71682
  014c6	a8 20		 test	 al, 32			; 00000020H
  014c8	75 11		 jne	 SHORT $L71682

; 1157 : 				{
; 1158 : 					pDphsettar->bouval = 52;

  014ca	66 c7 06 34 00	 mov	 WORD PTR [esi], 52	; 00000034H

; 1159 : 					pDphsettar->durtran = NF40MS;

  014cf	66 c7 46 06 06
	00		 mov	 WORD PTR [esi+6], 6
  014d5	eb 04		 jmp	 SHORT $L71682
$L72032:
  014d7	8b 44 24 20	 mov	 eax, DWORD PTR _feanex$[esp+12]
$L71682:

; 1160 : 				}
; 1161 : 			}
; 1162 : 			/* Offset of a vowel into silence is breathy */
; 1163 : 			if (((feacur & FSYLL) IS_PLUS)
; 1164 : 				&& (pDphsettar->phonex == SIL))

  014db	8b 54 24 1c	 mov	 edx, DWORD PTR _feacur$[esp+12]
  014df	f6 c2 01	 test	 dl, 1
  014e2	74 1a		 je	 SHORT $L71683
  014e4	66 85 ff	 test	 di, di
  014e7	75 15		 jne	 SHORT $L71683

; 1165 : 			{
; 1166 : 				pDphsettar->bouval = 52;

  014e9	66 c7 06 34 00	 mov	 WORD PTR [esi], 52	; 00000034H

; 1167 : 				pDphsettar->durtran = NF130MS;

  014ee	66 c7 46 06 14
	00		 mov	 WORD PTR [esi+6], 20	; 00000014H
  014f4	eb 08		 jmp	 SHORT $L71683
$L72034:
  014f6	8b 44 24 20	 mov	 eax, DWORD PTR _feanex$[esp+12]
  014fa	8b 54 24 1c	 mov	 edx, DWORD PTR _feacur$[esp+12]
$L71683:

; 1168 : 			}
; 1169 : 		}
; 1170 : 		/* BACKWARD SMOOTH:  TLT */
; 1171 : 
; 1172 : 		/* Tilt parameter jumps to target values near stops and silence */
; 1173 : 		if (pDphsettar->np == &PTILT)

  014fe	8d bb 40 02 00
	00		 lea	 edi, DWORD PTR [ebx+576]
  01504	3b ef		 cmp	 ebp, edi
  01506	75 5e		 jne	 SHORT $endbsmo$71662

; 1174 : 		{
; 1175 : 			pDphsettar->durtran = NF25MS;
; 1176 : 			if (pDphsettar->phonex == SIL)

  01508	66 8b 7e 0a	 mov	 di, WORD PTR [esi+10]
  0150c	66 c7 46 06 04
	00		 mov	 WORD PTR [esi+6], 4
  01512	66 85 ff	 test	 di, di
  01515	75 07		 jne	 SHORT $L71685

; 1177 : 			{
; 1178 : 				pDphsettar->bouval = pDphsettar->np->tarend;

  01517	66 8b 6d 1a	 mov	 bp, WORD PTR [ebp+26]
  0151b	66 89 2e	 mov	 WORD PTR [esi], bp
$L71685:

; 1179 : 			}
; 1180 : 			if (pDphsettar->phcur == SIL)

  0151e	66 85 c9	 test	 cx, cx
  01521	75 0a		 jne	 SHORT $L71686

; 1181 : 			{
; 1182 : 				pDphsettar->bouval = pDphsettar->np->tarnex;

  01523	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  01526	66 8b 49 16	 mov	 cx, WORD PTR [ecx+22]
  0152a	66 89 0e	 mov	 WORD PTR [esi], cx
$L71686:

; 1183 : 			}
; 1184 : 			if (((feanex & FSTOP) IS_PLUS)
; 1185 : 				|| ((feacur & FSTOP) IS_PLUS))

  0152d	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  01532	66 85 c0	 test	 ax, ax
  01535	75 0c		 jne	 SHORT $L71688
  01537	8b c2		 mov	 eax, edx
  01539	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  0153e	66 85 c0	 test	 ax, ax
  01541	74 06		 je	 SHORT $L71687
$L71688:

; 1186 : 			{
; 1187 : 				pDphsettar->durtran = 0;

  01543	66 c7 46 06 00
	00		 mov	 WORD PTR [esi+6], 0
$L71687:

; 1188 : 			}
; 1189 : 			/* Long breathy offset into silence */
; 1190 : 			if (((feacur & FVOICD) IS_PLUS)
; 1191 : 				&& ((feacur & FNASAL) IS_MINUS))

  01549	f6 c2 02	 test	 dl, 2
  0154c	74 18		 je	 SHORT $endbsmo$71662
  0154e	66 83 7c 24 18
	00		 cmp	 WORD PTR 12+[esp+12], 0
  01554	75 10		 jne	 SHORT $endbsmo$71662

; 1192 : 			{
; 1193 : 				if (pDphsettar->phonex == SIL)

  01556	66 85 ff	 test	 di, di
  01559	75 0b		 jne	 SHORT $endbsmo$71662

; 1194 : 				{
; 1195 : 					pDphsettar->bouval = 15;

  0155b	66 c7 06 0f 00	 mov	 WORD PTR [esi], 15	; 0000000fH
$L72036:

; 1196 : 					pDphsettar->durtran = NF130MS;

  01560	66 c7 46 06 14
	00		 mov	 WORD PTR [esi+6], 20	; 00000014H
$endbsmo$71662:

; 1197 : 				}
; 1198 : 			}
; 1199 : 		}
; 1200 : 	}
; 1201 : 	/* Truncate back transition so as not to exceed 20 frames */
; 1202 :   endbsmo:
; 1203 : 	if (pDphsettar->durtran > NF130MS)

  01566	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0156b	66 39 46 06	 cmp	 WORD PTR [esi+6], ax
  0156f	7e 04		 jle	 SHORT $L71691

; 1204 : 		pDphsettar->durtran = NF130MS;

  01571	66 89 46 06	 mov	 WORD PTR [esi+6], ax
$L71691:

; 1205 : 	/* Truncate backward tran so as not to exceed dur of phone */
; 1206 : 	if (pDphsettar->durtran > pDph_t->durfon)

  01575	66 8b 83 e0 14
	00 00		 mov	 ax, WORD PTR [ebx+5344]
  0157c	66 39 46 06	 cmp	 WORD PTR [esi+6], ax
  01580	7e 04		 jle	 SHORT $L71692

; 1207 : 		pDphsettar->durtran = pDph_t->durfon;

  01582	66 89 46 06	 mov	 WORD PTR [esi+6], ax
$L71692:

; 1208 : 	pDphsettar->np->tbacktr = pDph_t->durfon - pDphsettar->durtran;

  01586	66 8b 8b e0 14
	00 00		 mov	 cx, WORD PTR [ebx+5344]
  0158d	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  01590	66 2b 4e 06	 sub	 cx, WORD PTR [esi+6]
  01594	66 89 4a 10	 mov	 WORD PTR [edx+16], cx

; 1209 : 	/* No parameter can take on negative values */
; 1210 : 	if (pDphsettar->bouval < 0)

  01598	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  0159c	7d 05		 jge	 SHORT $L71693

; 1211 : 		pDphsettar->bouval = 0;

  0159e	66 c7 06 00 00	 mov	 WORD PTR [esi], 0
$L71693:
  015a3	5f		 pop	 edi
  015a4	5e		 pop	 esi
  015a5	5d		 pop	 ebp
  015a6	5b		 pop	 ebx

; 1212 : }

  015a7	c3		 ret	 0
_back_smooth_rules ENDP
_TEXT	ENDS
EXTRN	_mstofr:NEAR
EXTRN	_burdr:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_fealas$ = 12
_feacur$ = 16
_feanex$ = 20
_struclm2$ = 24
_struccur$ = 28
_special_rules PROC NEAR

; 1241 : 	short                   bdur, vot; /* MVP made as a local variable */
; 1242 : 	short                   closure_dur;	/* MVP made as a local variable */
; 1243 : 	
; 1244 : 
; 1245 : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  015b0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  015b4	53		 push	 ebx
  015b5	55		 push	 ebp
  015b6	56		 push	 esi
  015b7	57		 push	 edi
  015b8	8b 78 18	 mov	 edi, DWORD PTR [eax+24]

; 1246 : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 1247 : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;
; 1248 : 
; 1249 : 	/* SPECIAL RULE 1: Burst duration for plosives and affricates             */
; 1250 : 
; 1251 : 	bdur = burdr[pDphsettar->phcur];   /* Look up inher. burst dur in msec in table */
; 1252 : 
; 1253 : 	if ((feacur & FBURST) IS_PLUS)

  015bb	8b 5c 24 1c	 mov	 ebx, DWORD PTR _feacur$[esp+12]
  015bf	8b b7 d0 2b 00
	00		 mov	 esi, DWORD PTR [edi+11216]
  015c5	0f bf 4e 18	 movsx	 ecx, WORD PTR [esi+24]
  015c9	66 8b 04 4d 00
	00 00 00	 mov	 ax, WORD PTR _burdr[ecx*2]
  015d1	8b cb		 mov	 ecx, ebx
  015d3	81 e1 00 08 00
	00		 and	 ecx, 2048		; 00000800H
  015d9	66 85 c9	 test	 cx, cx
  015dc	89 4c 24 14	 mov	 DWORD PTR 8+[esp+12], ecx
  015e0	0f 84 ce 00 00
	00		 je	 $L71732

; 1254 : 	{
; 1255 : 		bdur = mstofr (bdur);		   /* Convert to frames         */

  015e6	0f bf d0	 movsx	 edx, ax
  015e9	52		 push	 edx
  015ea	e8 00 00 00 00	 call	 _mstofr

; 1256 : 
; 1257 : 		/* Don't release burst in homorganic plosiv-nasal & plos-plos sequence */
; 1258 : 		/* bats 878 EAB 4/2/99*/
; 1259 : 
; 1260 : 
; 1261 : /* Dennis had a rule that said in homorganic (meaning
; 1262 : in this case the same place of articulation) nasal plosives
; 1263 : and plosive plosive one should not release the burst of the 
; 1264 : initial plosive. This is incorrect place because a nasal
; 1265 : doesn't have a place of articulation so it can never match 
; 1266 : plus the homorganic I don't believe really means exact same 
; 1267 : place of articulation. A plosive followed by a nasal will 
; 1268 : not be realeased-period. Secondly, a plosive that has 
; 1269 : similiar place of artculation should follow the rule.
; 1270 : i=(i.e an aveloar or a dental are equivalent)
; 1271 : 	So, I added new masks to group places into "homorganic
; 1272 : groupings"
; 1273 : 
; 1274 : */
; 1275 : 
; 1276 : 		if ((feanex & (FNASAL | FPLOSV)) IS_PLUS)

  015ef	8a 4c 24 24	 mov	 cl, BYTE PTR _feanex$[esp+16]
  015f3	83 c4 04	 add	 esp, 4
  015f6	f6 c1 c0	 test	 cl, -64			; ffffffc0H
  015f9	74 47		 je	 SHORT $L71722

; 1277 : 		{
; 1278 : 			//EAB Don't release a plosive followed by a nasal period
; 1279 : 			// The former comment is not quite correct becaue the place of articulation
; 1280 : 			//between a nasal and a plosive can't be the same becuase the nasal's
; 1281 : 			// doesn't have a place of articulation 2/26/99
; 1282 : 			if((feacur & FPLOSV ) IS_PLUS)

  015fb	f6 c3 40	 test	 bl, 64			; 00000040H
  015fe	74 02		 je	 SHORT $L71719

; 1283 : 				bdur=0;

  01600	33 c0		 xor	 eax, eax
$L71719:

; 1284 : 			if ((place[pDphsettar->phcur] | MASKFRONT )== (place[pDphsettar->phonex] | MASKFRONT ))

  01602	0f bf 4e 18	 movsx	 ecx, WORD PTR [esi+24]
  01606	0f bf 56 0a	 movsx	 edx, WORD PTR [esi+10]
  0160a	66 8b 0c 4d 00
	00 00 00	 mov	 cx, WORD PTR _place[ecx*2]
  01612	66 8b 14 55 00
	00 00 00	 mov	 dx, WORD PTR _place[edx*2]
  0161a	8b e9		 mov	 ebp, ecx
  0161c	8b da		 mov	 ebx, edx
  0161e	83 cd 0f	 or	 ebp, 15			; 0000000fH
  01621	83 cb 0f	 or	 ebx, 15			; 0000000fH
  01624	66 3b eb	 cmp	 bp, bx
  01627	75 08		 jne	 SHORT $L71720

; 1285 : 			{		/* yes they're both done up front */
; 1286 : 				bdur = 0;
; 1287 : 			}
; 1288 : 			else if ((place[pDphsettar->phcur] )== (place[pDphsettar->phonex] ))

  01629	8b 5c 24 1c	 mov	 ebx, DWORD PTR _feacur$[esp+12]
  0162d	33 c0		 xor	 eax, eax
  0162f	eb 2e		 jmp	 SHORT $L71726
$L71720:
  01631	66 3b ca	 cmp	 cx, dx
  01634	75 08		 jne	 SHORT $L72043

; 1289 : 			{		
; 1290 : 				bdur = 0;
; 1291 : 			}
; 1292 : 
; 1293 : 		}
; 1294 : 
; 1295 : 	
; 1296 : 
; 1297 : 
; 1298 : 		if (bdur > 1)

  01636	8b 5c 24 1c	 mov	 ebx, DWORD PTR _feacur$[esp+12]
  0163a	33 c0		 xor	 eax, eax
  0163c	eb 21		 jmp	 SHORT $L71726
$L72043:
  0163e	8b 5c 24 1c	 mov	 ebx, DWORD PTR _feacur$[esp+12]
$L71722:
  01642	66 3d 01 00	 cmp	 ax, 1
  01646	7e 17		 jle	 SHORT $L71726

; 1299 : 		{
; 1300 : 			if (((feacur & FPLOSV) IS_PLUS)
; 1301 : 				&& ((feanex & FOBST) IS_PLUS))

  01648	f6 c3 40	 test	 bl, 64			; 00000040H
  0164b	74 07		 je	 SHORT $L71724
  0164d	f6 44 24 20 20	 test	 BYTE PTR _feanex$[esp+12], 32 ; 00000020H

; 1302 : 			{
; 1303 : 				bdur--;				   /* Shorten burst before obst by 6 ms */
; 1304 : 			}
; 1305 : 			else if (pDph_t->durfon < NF50MS)

  01652	75 0a		 jne	 SHORT $L72047
$L71724:
  01654	66 83 bf e0 14
	00 00 08	 cmp	 WORD PTR [edi+5344], 8
  0165c	7d 01		 jge	 SHORT $L71726
$L72047:

; 1306 : 			{
; 1307 : 				bdur--;				   /* Shorten burst if closure short */

  0165e	48		 dec	 eax
$L71726:

; 1308 : 			}
; 1309 : 		}
; 1310 : 
; 1311 : 		closure_dur = pDph_t->durfon - bdur;

  0165f	66 8b 8f e0 14
	00 00		 mov	 cx, WORD PTR [edi+5344]
  01666	66 2b c8	 sub	 cx, ax

; 1312 : 
; 1313 : 		if ((pDphsettar->phcur == CH) || (pDphsettar->phcur == JH))

  01669	66 8b 46 18	 mov	 ax, WORD PTR [esi+24]
  0166d	66 3d 36 00	 cmp	 ax, 54			; 00000036H
  01671	74 06		 je	 SHORT $L71728
  01673	66 3d 37 00	 cmp	 ax, 55			; 00000037H
  01677	75 0b		 jne	 SHORT $L71729
$L71728:

; 1314 : 		{
; 1315 : 			if (closure_dur > NF80MS)

  01679	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  0167d	7e 05		 jle	 SHORT $L71729

; 1316 : 				closure_dur = NF80MS;

  0167f	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
$L71729:

; 1317 : 		}
; 1318 : 		for (pDphsettar->np = &PA2; pDphsettar->np <= &PAB; pDphsettar->np++)

  01684	8d 97 68 01 00
	00		 lea	 edx, DWORD PTR [edi+360]
  0168a	8d 87 1c 02 00
	00		 lea	 eax, DWORD PTR [edi+540]
  01690	3b d0		 cmp	 edx, eax
  01692	89 56 10	 mov	 DWORD PTR [esi+16], edx
  01695	77 1d		 ja	 SHORT $L71732
  01697	33 d2		 xor	 edx, edx
$L71730:

; 1319 : 		{							   /* All fric gains to */
; 1320 : 			pDphsettar->np->tspesh = closure_dur;	/* zero during closur */

  01699	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  0169c	66 89 4d 12	 mov	 WORD PTR [ebp+18], cx

; 1321 : 			pDphsettar->np->pspesh = 0;

  016a0	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  016a3	66 89 55 14	 mov	 WORD PTR [ebp+20], dx
  016a7	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  016aa	83 c5 24	 add	 ebp, 36			; 00000024H
  016ad	3b e8		 cmp	 ebp, eax
  016af	89 6e 10	 mov	 DWORD PTR [esi+16], ebp
  016b2	76 e5		 jbe	 SHORT $L71730
$L71732:

; 1322 : 		}
; 1323 : 	}
; 1324 : 
; 1325 : 		/*    Special hack to give /th,dh/ a weak burst */
; 1326 : 		// EAB  1/26/99 Migrate to others??
; 1327 : 		if ((pDphsettar->phcur == TH) || (pDphsettar->phcur == DH)) 

  016b4	66 8b 46 18	 mov	 ax, WORD PTR [esi+24]
  016b8	66 3d 27 00	 cmp	 ax, 39			; 00000027H
  016bc	74 06		 je	 SHORT $L71734
  016be	66 3d 28 00	 cmp	 ax, 40			; 00000028H
  016c2	75 40		 jne	 SHORT $L71737
$L71734:

; 1328 : 		{
; 1329 : 			for (pDphsettar->np = &PA6; pDphsettar->np <= &PAB; pDphsettar->np++) 

  016c4	8d 8f f8 01 00
	00		 lea	 ecx, DWORD PTR [edi+504]
  016ca	8d 87 1c 02 00
	00		 lea	 eax, DWORD PTR [edi+540]
  016d0	3b c8		 cmp	 ecx, eax
  016d2	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  016d5	77 2d		 ja	 SHORT $L71737

; 1330 : 			{		/* All fric gains to */
; 1331 : 				pDphsettar->np->tspesh = pDph_t->durfon - 2;		/* zero during closur*/

  016d7	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
$L71735:
  016dc	66 8b 97 e0 14
	00 00		 mov	 dx, WORD PTR [edi+5344]
  016e3	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  016e6	66 83 ea 02	 sub	 dx, 2
  016ea	66 89 55 12	 mov	 WORD PTR [ebp+18], dx

; 1332 : 				pDphsettar->np->pspesh = 30;

  016ee	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  016f1	66 89 4a 14	 mov	 WORD PTR [edx+20], cx
  016f5	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  016f8	83 c5 24	 add	 ebp, 36			; 00000024H
  016fb	8b d5		 mov	 edx, ebp
  016fd	89 6e 10	 mov	 DWORD PTR [esi+16], ebp
  01700	3b d0		 cmp	 edx, eax
  01702	76 d8		 jbe	 SHORT $L71735
$L71737:

; 1333 : 			}
; 1334 :         }
; 1335 : 
; 1336 : 	
; 1337 : 	/* SPECIAL RULE 2: Voice onset time for aspirated plosives */
; 1338 : 
; 1339 : 	vot = 0;
; 1340 : 	if ((((fealas & FPLOSV) IS_PLUS)
; 1341 : 		 && ((fealas & FVOICD) IS_MINUS)
; 1342 : 		 && ((feacur & FSONOR) IS_PLUS ))) 

  01704	8a 44 24 18	 mov	 al, BYTE PTR _fealas$[esp+12]
  01708	a8 40		 test	 al, 64			; 00000040H
  0170a	0f 84 31 01 00
	00		 je	 $L71738
  01710	a8 02		 test	 al, 2
  01712	0f 85 29 01 00
	00		 jne	 $L71738
  01718	f6 c3 10	 test	 bl, 16			; 00000010H
  0171b	0f 84 20 01 00
	00		 je	 $L71738

; 1343 : 	{
; 1344 : 		PAP.pspesh = 57-5;			   /* Amplitude of aspiration in dB     */

  01721	66 c7 87 58 01
	00 00 34 00	 mov	 WORD PTR [edi+344], 52	; 00000034H

; 1345 : 		if (begtyp[pDphsettar->phonex] != 1)

  0172a	0f bf 46 0a	 movsx	 eax, WORD PTR [esi+10]
  0172e	66 83 3c 45 00
	00 00 00 01	 cmp	 WORD PTR _begtyp[eax*2], 1
  01737	74 09		 je	 SHORT $L71739

; 1346 : 		{
; 1347 : 			PAP.pspesh = 61-6;		   /* Stronger asp before +back */

  01739	66 c7 87 58 01
	00 00 37 00	 mov	 WORD PTR [edi+344], 55	; 00000037H
$L71739:

; 1348 : 		}
; 1349 : 		PAV.pspesh = 0;				   /* Amplitude of voicing during aspir */
; 1350 : 
; 1351 : 
; 1352 : 		vot = NF40MS;				   /* Asp dur for /p,t,k/ before stressed sonor */
; 1353 : 		if ((struccur & FSTRESS_1) IS_MINUS)

  01742	8b 6c 24 28	 mov	 ebp, DWORD PTR _struccur$[esp+12]
  01746	66 c7 87 34 01
	00 00 00 00	 mov	 WORD PTR [edi+308], 0
  0174f	83 e5 01	 and	 ebp, 1
  01752	b8 06 00 00 00	 mov	 eax, 6
  01757	66 85 ed	 test	 bp, bp
  0175a	75 0d		 jne	 SHORT $L71740

; 1354 : 		{
; 1355 : 			vot = NF25MS;			   /* Vot shorter if vowel not stressed */
; 1356 : 			PAP.pspesh -= 3;

  0175c	66 83 87 58 01
	00 00 fd	 add	 WORD PTR [edi+344], -3	; fffffffdH
  01764	b8 04 00 00 00	 mov	 eax, 4
$L71740:

; 1357 : 		}
; 1358 : 		if (((feacur & FSONCON) IS_PLUS) || (pDphsettar->phcur == RR))

  01769	8b cb		 mov	 ecx, ebx
  0176b	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  01771	66 85 c9	 test	 cx, cx
  01774	75 07		 jne	 SHORT $L71742
  01776	66 83 7e 18 0f	 cmp	 WORD PTR [esi+24], 15	; 0000000fH
  0177b	75 08		 jne	 SHORT $L71741
$L71742:

; 1359 : 		{
; 1360 : 			PAP.pspesh += 3;		   /* Aspiration stronger in sonor cons */

  0177d	66 83 87 58 01
	00 00 03	 add	 WORD PTR [edi+344], 3
$L71741:

; 1361 : 		}
; 1362 : 
; 1363 : 		/* eab 2/6/976 Found code that was causing after Murhty port. Vlaue of pholm2
; 1364 : 		was not being retained- substituted global variables that already exsist
; 1365 : 		after release the old and I think vestigal variables need to be removed
; 1366 : 		this problem affect all languages but in fact the code didn't exist in German
; 1367 : 		at all but was needed don't know is struclm2 is working either*/
; 1368 : 
; 1369 : 		if ( featb[pDph_t->allophons[pDph_t->nphone -2]] == (FOBST+FCONSON ))          

  01785	0f bf 97 a4 23
	00 00		 movsx	 edx, WORD PTR [edi+9124]
  0178c	0f bf 8c 57 c2
	03 00 00	 movsx	 ecx, WORD PTR [edi+edx*2+962]
  01794	66 81 3c 4d 00
	00 00 00 20 01	 cmp	 WORD PTR _featb[ecx*2], 288 ; 00000120H
  0179e	75 16		 jne	 SHORT $L71743

; 1370 : 		{
; 1371 : 			if ((struclm2 & FBOUNDARY) IS_MINUS )

  017a0	8b 54 24 24	 mov	 edx, DWORD PTR _struclm2$[esp+12]
  017a4	81 e2 e0 01 00
	00		 and	 edx, 480		; 000001e0H
  017aa	66 85 d2	 test	 dx, dx
  017ad	75 0f		 jne	 SHORT $L71746

; 1372 : 			{
; 1373 : 				vot = NF15MS;	   

  017af	b8 02 00 00 00	 mov	 eax, 2

; 1374 : 			}
; 1375 : 		}
; 1376 : 		else if (((feacur & FSYLL) IS_MINUS))

  017b4	eb 08		 jmp	 SHORT $L71746
$L71743:
  017b6	f6 c3 01	 test	 bl, 1
  017b9	75 03		 jne	 SHORT $L71746

; 1377 : 		{
; 1378 : 			vot += NF20MS;			   /* Vot longer in a sonorant consonant */

  017bb	83 c0 03	 add	 eax, 3
$L71746:

; 1379 : 		}
; 1380 : 		if (vot >= pDph_t->durfon)

  017be	66 8b 8f e0 14
	00 00		 mov	 cx, WORD PTR [edi+5344]
  017c5	66 3b c1	 cmp	 ax, cx
  017c8	7c 03		 jl	 SHORT $L71747

; 1381 : 		{
; 1382 : 			vot = pDph_t->durfon - 1;

  017ca	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
$L71747:

; 1383 : 			
; 1384 : 		}
; 1385 : 		/* Vot cannot exceed 1/2 duration of a stressed vowel */
; 1386 : 		if ((vot > (pDph_t->durfon >> 1))
; 1387 : 			&& ((feacur & FSYLL) IS_PLUS)
; 1388 : 			&& ((struccur & FSTRESS_1) IS_PLUS))

  017cd	66 8b d1	 mov	 dx, cx
  017d0	66 d1 fa	 sar	 dx, 1
  017d3	66 3b c2	 cmp	 ax, dx
  017d6	7e 0c		 jle	 SHORT $L71748
  017d8	f6 c3 01	 test	 bl, 1
  017db	74 07		 je	 SHORT $L71748
  017dd	66 85 ed	 test	 bp, bp
  017e0	74 02		 je	 SHORT $L71748

; 1389 : 		{
; 1390 : 			vot = pDph_t->durfon >> 1;

  017e2	8b c2		 mov	 eax, edx
$L71748:

; 1391 : 		}
; 1392 : 		/* A dummy vowel is used to release a voiceless plosive into silence */
; 1393 : 		if ((struccur & FDUMMY_VOWEL) IS_PLUS)

  017e4	8b 54 24 28	 mov	 edx, DWORD PTR _struccur$[esp+12]
  017e8	81 e2 00 08 00
	00		 and	 edx, 2048		; 00000800H
  017ee	66 85 d2	 test	 dx, dx
  017f1	74 0a		 je	 SHORT $L71749

; 1394 : 		{
; 1395 : 			vot = pDph_t->durfon;
; 1396 : 			PAP.pspesh -= 3;

  017f3	66 83 87 58 01
	00 00 fd	 add	 WORD PTR [edi+344], -3	; fffffffdH
  017fb	8b c1		 mov	 eax, ecx
$L71749:

; 1397 : 		}
; 1398 : 		/* eab in fast mode we simply when to model a much reduced faster
; 1399 : 		release--no time to build up large pressures*/
; 1400 : 
; 1401 : #ifdef FASTTYPING_MODE
; 1402 : 		if(phTTS->bInTypingMode == TRUE || pKsd_t->sprate >300)
; 1403 : 		{
; 1404 : 			
; 1405 : 			vot=vot>>2;
; 1406 : 			if(vot == 0)
; 1407 : 				vot=1;
; 1408 : 		
; 1409 : 
; 1410 : 		PAV.pspesh += 20;
; 1411 : 		PAP.pspesh -=5;
; 1412 : 		}
; 1413 : #endif
; 1414 : 		PAV.tspesh = vot;
; 1415 : 		PAP.tspesh = vot;/* have aspiration continue into vowel*/
; 1416 : 
; 1417 : 		/* Widen 1st and 2nd formant bws when glottis open for aspir */
; 1418 : 		PB1.tspesh = vot;
; 1419 : 		PB2.tspesh = vot;
; 1420 : 		PB1.pspesh = PB1.tarcur + 250 +250;
; 1421 : 		PB2.pspesh = PB2.tarcur + (70 -20);

  017fd	66 8b 8f d8 00
	00 00		 mov	 cx, WORD PTR [edi+216]
  01804	66 89 87 32 01
	00 00		 mov	 WORD PTR [edi+306], ax
  0180b	66 89 87 56 01
	00 00		 mov	 WORD PTR [edi+342], ax
  01812	66 89 87 c6 00
	00 00		 mov	 WORD PTR [edi+198], ax
  01819	66 89 87 ea 00
	00 00		 mov	 WORD PTR [edi+234], ax
  01820	66 8b 87 b4 00
	00 00		 mov	 ax, WORD PTR [edi+180]
  01827	66 05 f4 01	 add	 ax, 500			; 000001f4H
  0182b	66 83 c1 32	 add	 cx, 50			; 00000032H
  0182f	66 89 87 c8 00
	00 00		 mov	 WORD PTR [edi+200], ax
  01836	8a 44 24 18	 mov	 al, BYTE PTR _fealas$[esp+12]
  0183a	66 89 8f ec 00
	00 00		 mov	 WORD PTR [edi+236], cx
$L71738:

; 1422 : 	}
; 1423 : 	/* SPECIAL RULE 3: Create realistic voicebar, avoid pops and clicks */
; 1424 : 	/* Amp of voicebar set here, AV target in table invalid */
; 1425 : 	/* Set AV=0 for last 12.8 ms, let AV die out, thus avoid click */
; 1426 : 	/* Set to under 250 to signal voicebar */
; 1427 :   
; 1428 : 	/* Problem: spectrum has too much F4 if f2,3 are high, as in [i] */
; 1429 : 	if (((feacur & FBURST) IS_PLUS)
; 1430 : 		&& ((feacur & FVOICD) IS_PLUS)
; 1431 : 		&& ((fealas & FVOICD) IS_PLUS)
; 1432 : 		&& ((feanex & FVOICD) IS_MINUS)		/* Voicebar only if next -V */
; 1433 : 		&& (pDphsettar->phcur != TX))

  01841	66 83 7c 24 14
	00		 cmp	 WORD PTR 8+[esp+12], 0
  01847	74 62		 je	 SHORT $L71750
  01849	f6 c3 02	 test	 bl, 2
  0184c	74 5d		 je	 SHORT $L71750
  0184e	a8 02		 test	 al, 2
  01850	74 59		 je	 SHORT $L71750
  01852	f6 44 24 20 02	 test	 BYTE PTR _feanex$[esp+12], 2
  01857	75 52		 jne	 SHORT $L71750
  01859	66 83 7e 18 34	 cmp	 WORD PTR [esi+24], 52	; 00000034H
  0185e	74 4b		 je	 SHORT $L71750

; 1434 : 	{
; 1435 : 		PAV.tspesh = pDph_t->durfon - NF15MS;

  01860	66 8b 87 e0 14
	00 00		 mov	 ax, WORD PTR [edi+5344]

; 1436 : 		PB1.tspesh = pDph_t->durfon;
; 1437 : 		PB2.tspesh = pDph_t->durfon;
; 1438 : 		PB3.tspesh = pDph_t->durfon;
; 1439 : 		PAV.pspesh = 10;			   /* Large since low-pass TILT attenuates it 

  01867	66 c7 87 34 01
	00 00 0a 00	 mov	 WORD PTR [edi+308], 10	; 0000000aH
  01870	66 89 87 c6 00
	00 00		 mov	 WORD PTR [edi+198], ax
  01877	66 89 87 ea 00
	00 00		 mov	 WORD PTR [edi+234], ax
  0187e	8d 50 fe	 lea	 edx, DWORD PTR [eax-2]
  01881	66 89 87 0e 01
	00 00		 mov	 WORD PTR [edi+270], ax

; 1440 : 							eab voicebars can be trouble and are not really perceptual*/
; 1441 : 		PB1.pspesh = 1000;

  01888	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  0188d	66 89 97 32 01
	00 00		 mov	 WORD PTR [edi+306], dx
  01894	66 89 87 c8 00
	00 00		 mov	 WORD PTR [edi+200], ax

; 1442 : 		PB2.pspesh = 1000;

  0189b	66 89 87 ec 00
	00 00		 mov	 WORD PTR [edi+236], ax

; 1443 : 		PB3.pspesh = 1500;

  018a2	66 c7 87 10 01
	00 00 dc 05	 mov	 WORD PTR [edi+272], 1500 ; 000005dcH
$L71750:
  018ab	5f		 pop	 edi
  018ac	5e		 pop	 esi
  018ad	5d		 pop	 ebp
  018ae	5b		 pop	 ebx

; 1444 : 	}
; 1445 : }

  018af	c3		 ret	 0
_special_rules ENDP
_TEXT	ENDS
EXTRN	_plocu:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_nfonobst$ = 12
_nfonsonor$ = 16
_initfinso$ = 20
_nfonvowel$ = 24
_fonobst$ = -24
_fonsonor$ = -16
_fonvowel$ = -12
_typso$ = -28
_f2backaffil$ = -4
_curval$ = -20
_prcnt$ = 16
_setloc	PROC NEAR

; 70   : 	/* Automatic variables */
; 71   : 	short                   fonobst, fonsonor, fonvowel, typob, typso, f2backaffil, curval, tarvowel;
; 72   : 	short                   sontyx, ploc, locus, prcnt, delta_freq;
; 73   : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  018b0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  018b4	83 ec 1c	 sub	 esp, 28			; 0000001cH
  018b7	53		 push	 ebx
  018b8	55		 push	 ebp
  018b9	56		 push	 esi
  018ba	8b 70 18	 mov	 esi, DWORD PTR [eax+24]

; 74   : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 75   : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;
; 76   : 
; 77   : 	/* Convert phoneme pointers into phoneme names */
; 78   : 	fonobst = get_phone (pDph_t, nfonobst);

  018bd	66 8b 44 24 30	 mov	 ax, WORD PTR _nfonobst$[esp+36]
  018c2	33 ed		 xor	 ebp, ebp
  018c4	57		 push	 edi
  018c5	8b be d0 2b 00
	00		 mov	 edi, DWORD PTR [esi+11216]
  018cb	66 3b c5	 cmp	 ax, bp
  018ce	7c 1a		 jl	 SHORT $L72049
  018d0	66 3b 86 e2 14
	00 00		 cmp	 ax, WORD PTR [esi+5346]
  018d7	7d 11		 jge	 SHORT $L72049
  018d9	0f bf c8	 movsx	 ecx, ax
  018dc	66 8b 84 4e c6
	03 00 00	 mov	 ax, WORD PTR [esi+ecx*2+966]
  018e4	89 44 24 14	 mov	 DWORD PTR _fonobst$[esp+44], eax
  018e8	eb 06		 jmp	 SHORT $L72050
$L72049:
  018ea	89 6c 24 14	 mov	 DWORD PTR _fonobst$[esp+44], ebp
  018ee	8b c5		 mov	 eax, ebp
$L72050:

; 79   : 	fonsonor = get_phone (pDph_t, nfonsonor);

  018f0	8b 54 24 38	 mov	 edx, DWORD PTR _nfonsonor$[esp+40]
  018f4	66 3b d5	 cmp	 dx, bp
  018f7	7c 1a		 jl	 SHORT $L72051
  018f9	66 3b 96 e2 14
	00 00		 cmp	 dx, WORD PTR [esi+5346]
  01900	7d 11		 jge	 SHORT $L72051
  01902	0f bf ca	 movsx	 ecx, dx
  01905	66 8b 8c 4e c6
	03 00 00	 mov	 cx, WORD PTR [esi+ecx*2+966]
  0190d	89 4c 24 1c	 mov	 DWORD PTR _fonsonor$[esp+44], ecx
  01911	eb 06		 jmp	 SHORT $L72052
$L72051:
  01913	89 6c 24 1c	 mov	 DWORD PTR _fonsonor$[esp+44], ebp
  01917	8b cd		 mov	 ecx, ebp
$L72052:

; 80   : 	fonvowel = get_phone (pDph_t, nfonvowel);

  01919	8b 5c 24 40	 mov	 ebx, DWORD PTR _nfonvowel$[esp+40]
  0191d	66 3b dd	 cmp	 bx, bp
  01920	7c 1b		 jl	 SHORT $L72053
  01922	66 3b 9e e2 14
	00 00		 cmp	 bx, WORD PTR [esi+5346]
  01929	7d 12		 jge	 SHORT $L72053
  0192b	0f bf db	 movsx	 ebx, bx
  0192e	66 8b 9c 5e c6
	03 00 00	 mov	 bx, WORD PTR [esi+ebx*2+966]
  01936	66 89 5c 24 20	 mov	 WORD PTR _fonvowel$[esp+44], bx
  0193b	eb 04		 jmp	 SHORT $L72054
$L72053:
  0193d	89 6c 24 20	 mov	 DWORD PTR _fonvowel$[esp+44], ebp
$L72054:

; 81   : 	/* Use values at beginning of the sonorant */
; 82   : 	if (initfinso == 'i')

  01941	8a 5c 24 3c	 mov	 bl, BYTE PTR _initfinso$[esp+40]

; 83   : 	{
; 84   : 		typob = endtyp[fonobst];

  01945	0f bf e8	 movsx	 ebp, ax
  01948	80 fb 69	 cmp	 bl, 105			; 00000069H
  0194b	8d 44 2d 00	 lea	 eax, DWORD PTR [ebp+ebp]
  0194f	89 44 24 24	 mov	 DWORD PTR -8+[esp+44], eax
  01953	75 15		 jne	 SHORT $L71781
  01955	66 8b 80 00 00
	00 00		 mov	 ax, WORD PTR _endtyp[eax]

; 85   : 		typso = begtyp[fonsonor];

  0195c	0f bf d9	 movsx	 ebx, cx
  0195f	d1 e3		 shl	 ebx, 1
  01961	66 8b 8b 00 00
	00 00		 mov	 cx, WORD PTR _begtyp[ebx]

; 86   : 	}
; 87   : 	else

  01968	eb 13		 jmp	 SHORT $L72056
$L71781:

; 88   : 	{								   /* Or at the end of the sonorant */
; 89   : 		typob = begtyp[fonobst];

  0196a	66 8b 80 00 00
	00 00		 mov	 ax, WORD PTR _begtyp[eax]

; 90   : 		typso = endtyp[fonsonor];

  01971	0f bf d9	 movsx	 ebx, cx
  01974	d1 e3		 shl	 ebx, 1
  01976	66 8b 8b 00 00
	00 00		 mov	 cx, WORD PTR _endtyp[ebx]
$L72056:
  0197d	66 89 4c 24 10	 mov	 WORD PTR _typso$[esp+44], cx

; 91   : 	}
; 92   : 
; 93   : 	if ((pDphsettar->np > &PF3) || (typob != OBSTRUENT) || (typso == OBSTRUENT))

  01982	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  01985	39 4f 10	 cmp	 DWORD PTR [edi+16], ecx
  01988	0f 87 45 02 00
	00		 ja	 $L71784
  0198e	66 3d 04 00	 cmp	 ax, 4
  01992	0f 85 3b 02 00
	00		 jne	 $L71784
  01998	66 39 44 24 10	 cmp	 WORD PTR _typso$[esp+44], ax
  0199d	0f 84 30 02 00
	00		 je	 $L71784

; 96   : 	}
; 97   : 	if (initfinso == 'i')

  019a3	8a 44 24 3c	 mov	 al, BYTE PTR _initfinso$[esp+40]
  019a7	3c 69		 cmp	 al, 105			; 00000069H

; 98   : 	{
; 99   : 		f2backaffil = place[fonsonor] & F2BACKI;

  019a9	8a 83 00 00 00
	00		 mov	 al, BYTE PTR _place[ebx]
  019af	75 14		 jne	 SHORT $L71785

; 100  : 		curval = getbegtar (phTTS, nfonsonor);

  019b1	8b 4c 24 30	 mov	 ecx, DWORD PTR _phTTS$[esp+40]
  019b5	83 e0 40	 and	 eax, 64			; 00000040H
  019b8	52		 push	 edx
  019b9	51		 push	 ecx
  019ba	89 44 24 30	 mov	 DWORD PTR _f2backaffil$[esp+52], eax
  019be	e8 00 00 00 00	 call	 _getbegtar

; 101  : 	}
; 102  : 	else

  019c3	eb 14		 jmp	 SHORT $L72057
$L71785:

; 103  : 	{								   /* Or at the end of the sonorant */
; 104  : 		f2backaffil = place[fonsonor] & F2BACKF;
; 105  : 		curval = getendtar (phTTS, nfonsonor);

  019c5	8b 4c 24 30	 mov	 ecx, DWORD PTR _phTTS$[esp+40]
  019c9	25 80 00 00 00	 and	 eax, 128		; 00000080H
  019ce	52		 push	 edx
  019cf	51		 push	 ecx
  019d0	89 44 24 30	 mov	 DWORD PTR _f2backaffil$[esp+52], eax
  019d4	e8 00 00 00 00	 call	 _getendtar
$L72057:
  019d9	89 44 24 20	 mov	 DWORD PTR _curval$[esp+52], eax

; 106  : 	}
; 107  : 	sontyx = typso;

  019dd	8b 44 24 18	 mov	 eax, DWORD PTR _typso$[esp+52]
  019e1	83 c4 08	 add	 esp, 8

; 108  : #ifdef ENGLISH
; 109  : 	if (typso == ROUNDED_SONOR_CONS)   /* If sonorant is rounded conson, */

  019e4	66 3d 05 00	 cmp	 ax, 5
  019e8	75 05		 jne	 SHORT $L71787

; 110  : 		sontyx = BACK_ROUNDED_VOWEL;   /* use C locus for rounded vowel */

  019ea	b8 03 00 00 00	 mov	 eax, 3
$L71787:

; 111  : #endif
; 112  : #ifdef GERMAN
; 113  : 	if (typso == ROUNDED_SONOR_CONS)
; 114  : 	{								   /* If sonorant is rounded conson, */
; 115  : 		/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 116  : 		/* use BACK_VOWEL instead of BACK_ROUNDED_VOWEL           
; 117  : 		
; 118  : 
; 119  : 		/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 120  : 		sontyx = BACK_VOWEL;		   /* use locus for back vowel %%%%%%% */
; 121  : 	}
; 122  : 	/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 123  : 	/* 'low' class is fourth entry in plocu              */
; 124  : 	/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 125  : 	if (typso == LOW_VOWEL)
; 126  : 	{								   /* If sonorant is low vowel */
; 127  : 		sontyx = 2;					   /* use back instead */
; 128  : 	}
; 129  : 	/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 130  : 	/* Pointer into locus data comes from one of 4 tables for        */
; 131  : 	/* front-unrounded, back, front-rounded, low vowels.     */
; 132  : 	/* sontyx now equals 1, 2, 3, or 4                   */
; 133  : 	/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 134  : #endif
; 135  : 
; 136  : 	/* Pointer into locus data comes from one of 3 tables for front, back, */
; 137  : 	/* and rounded vowels, sontyx now equals 1,2, or 3 */
; 138  : 	ploc = plocu[(fonobst + (SIZTARTAB * (sontyx - 1)))];

  019ef	0f bf c0	 movsx	 eax, ax
  019f2	8d 14 c0	 lea	 edx, DWORD PTR [eax+eax*8]
  019f5	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  019f8	8d 4c 45 00	 lea	 ecx, DWORD PTR [ebp+eax*2]
  019fc	03 c1		 add	 eax, ecx
  019fe	66 8b 2c 45 8e
	ff ff ff	 mov	 bp, WORD PTR _plocu[eax*2-114]

; 139  : 	if (ploc == 0)					   /* Pointer to locus, zero means */

  01a06	66 85 ed	 test	 bp, bp

; 140  : 		return (0);					   /* no locus, use default calc  */

  01a09	0f 84 c4 01 00
	00		 je	 $L71784

; 141  : 	ploc = ploc + (3 * (pDphsettar->np - &PF1));	/* Table has 3 entries/formant  */

  01a0f	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  01a12	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  01a17	2b ce		 sub	 ecx, esi
  01a19	83 e9 24	 sub	 ecx, 36			; 00000024H
  01a1c	f7 e9		 imul	 ecx
  01a1e	c1 fa 03	 sar	 edx, 3
  01a21	8b c2		 mov	 eax, edx
  01a23	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  01a26	03 d0		 add	 edx, eax
  01a28	8d 0c 2a	 lea	 ecx, DWORD PTR [edx+ebp]
  01a2b	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]

; 142  : 	locus = pDph_t->p_locus[ploc];	   /* First entry is locus freq   */

  01a2e	8b 8e e8 14 00
	00		 mov	 ecx, DWORD PTR [esi+5352]
  01a34	0f bf c0	 movsx	 eax, ax
  01a37	66 8b 2c 41	 mov	 bp, WORD PTR [ecx+eax*2]

; 143  : 	prcnt = pDph_t->p_locus[ploc + 1]; /* Second entry is % toward V  */

  01a3b	66 8b 54 41 02	 mov	 dx, WORD PTR [ecx+eax*2+2]

; 144  : 	pDphsettar->durtran = mstofr (pDph_t->p_locus[ploc + 2]);	/* 3rd is tran dur in msec  */

  01a40	0f bf 44 41 04	 movsx	 eax, WORD PTR [ecx+eax*2+4]
  01a45	50		 push	 eax
  01a46	66 89 54 24 3c	 mov	 WORD PTR _prcnt$[esp+44], dx
  01a4b	e8 00 00 00 00	 call	 _mstofr
  01a50	83 c4 04	 add	 esp, 4

; 145  : /*#ifdef ENGLISH 1/3/97 eab I think this should apply generally*/
; 146  : 	/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 147  : 	/* take transition reduction out for german DECtalk      */
; 148  : 	/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
; 149  : 	/* Reduce F2 and F3 transition in a sonor conson adj to nonpalatal obst */
; 150  : 	if ((typso == ROUNDED_SONOR_CONS) && (pDphsettar->np > &PF1)
; 151  : 		&& ((place[fonobst] & (FPALATL | FDENTAL)) IS_MINUS))

  01a53	66 83 7c 24 10
	05		 cmp	 WORD PTR _typso$[esp+44], 5
  01a59	66 89 47 06	 mov	 WORD PTR [edi+6], ax
  01a5d	75 28		 jne	 SHORT $L72055
  01a5f	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  01a62	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  01a65	3b d1		 cmp	 edx, ecx
  01a67	76 1e		 jbe	 SHORT $L72055
  01a69	8b 54 24 24	 mov	 edx, DWORD PTR -8+[esp+44]
  01a6d	f6 82 00 00 00
	00 06		 test	 BYTE PTR _place[edx], 6
  01a74	75 11		 jne	 SHORT $L72055

; 152  : 	{
; 153  : 		prcnt = (prcnt >> 1) + 50;

  01a76	66 8b 4c 24 38	 mov	 cx, WORD PTR _prcnt$[esp+40]
  01a7b	66 d1 f9	 sar	 cx, 1
  01a7e	83 c1 32	 add	 ecx, 50			; 00000032H
  01a81	89 4c 24 38	 mov	 DWORD PTR _prcnt$[esp+40], ecx
  01a85	eb 04		 jmp	 SHORT $L71789
$L72055:
  01a87	8b 4c 24 38	 mov	 ecx, DWORD PTR _prcnt$[esp+40]
$L71789:

; 154  : 	} 
; 155  : 	
; 156  : 	/* @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ */
; 157  : /*#endif*/
; 158  : 	/* Ditto for vowel/sonor with F2 assoc with back cavity, e.g. [iy] */
; 159  : 	if ((f2backaffil IS_PLUS) && (pDphsettar->np == &PF2))

  01a8b	66 83 7c 24 28
	00		 cmp	 WORD PTR _f2backaffil$[esp+44], 0
  01a91	74 27		 je	 SHORT $L71790
  01a93	8d 56 48	 lea	 edx, DWORD PTR [esi+72]
  01a96	39 57 10	 cmp	 DWORD PTR [edi+16], edx
  01a99	75 1f		 jne	 SHORT $L71790

; 160  : 	{
; 161  : 		prcnt += (25 - (prcnt >> 2));  /* Reduce trans extent by 1/4 */

  01a9b	66 c1 f9 02	 sar	 cx, 2
  01a9f	ba 19 00 00 00	 mov	 edx, 25			; 00000019H
  01aa4	2b d1		 sub	 edx, ecx
  01aa6	8b 4c 24 38	 mov	 ecx, DWORD PTR _prcnt$[esp+40]

; 162  : 		pDphsettar->durtran = (pDphsettar->durtran >> 1) + 2;	/* And shorten tran dur */

  01aaa	66 d1 f8	 sar	 ax, 1
  01aad	03 ca		 add	 ecx, edx
  01aaf	83 c0 02	 add	 eax, 2
  01ab2	89 4c 24 38	 mov	 DWORD PTR _prcnt$[esp+40], ecx
  01ab6	66 89 47 06	 mov	 WORD PTR [edi+6], ax
$L71790:

; 163  : 	}
; 164  : 	/* Let bouval = locus + ((prcnt * (curval-locus)) / 100); */
; 165  : 	/* Old approximation (no divides):                       */
; 166  : 	/* delta_freq = (prcnt * (curval-locus)) >> 7;            */
; 167  : 	/* bouval = locus + delta_freq + (delta_freq >> 2);    */
; 168  : 	/* End of old approximation                              */
; 169  : 	pDph_t->arg1 = prcnt;
; 170  : #ifdef ENGLISH_UK
; 171  : 	
; 172  : 	/*eab 11/19/97  first cut just for ch but probably should be for all plos*/
; 173  : 	if (initfinso != 'i' && fonobst == 54)
; 174  : 	{
; 175  : 		pDph_t->arg1 = prcnt+40;
; 176  : 		if(pDph_t->arg1 >100 )
; 177  : 			pDph_t->arg1=100;
; 178  : 	}
; 179  : #endif
; 180  : 
; 181  : 	pDph_t->arg2 = curval - locus;

  01aba	8b 44 24 18	 mov	 eax, DWORD PTR _curval$[esp+44]
  01abe	66 89 8e f8 14
	00 00		 mov	 WORD PTR [esi+5368], cx
  01ac5	2b c5		 sub	 eax, ebp

; 182  : 	pDph_t->arg3 = 100;

  01ac7	66 c7 86 fc 14
	00 00 64 00	 mov	 WORD PTR [esi+5372], 100 ; 00000064H
  01ad0	0f bf d1	 movsx	 edx, cx

; 183  : 	delta_freq = muldv (pDph_t->arg1, pDph_t->arg2, pDph_t->arg3);
; 184  : 	pDphsettar->bouval = locus + delta_freq;

  01ad3	0f bf c8	 movsx	 ecx, ax
  01ad6	0f af ca	 imul	 ecx, edx
  01ad9	66 89 86 fa 14
	00 00		 mov	 WORD PTR [esi+5370], ax
  01ae0	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  01ae5	89 54 24 28	 mov	 DWORD PTR -4+[esp+44], edx
  01ae9	f7 e9		 imul	 ecx
  01aeb	c1 fa 05	 sar	 edx, 5
  01aee	8b c2		 mov	 eax, edx
  01af0	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  01af3	03 d0		 add	 edx, eax
  01af5	03 d5		 add	 edx, ebp
  01af7	66 89 17	 mov	 WORD PTR [edi], dx

; 185  : 
; 186  : #ifdef   DEBUG_TARGETS
; 187  : 	printf ("locus %d delta_freq %d \n", locus, delta_freq);
; 188  : 	printf ("pDphsettar->bouval %d \n", pDphsettar->bouval);
; 189  : #endif
; 190  : 	/* V-V coarticulation across an obst consonant: */
; 191  : 	if (((featb[fonsonor] & FVOWEL) IS_PLUS)
; 192  : 		&& ((featb[fonvowel] & FVOWEL) IS_PLUS)
; 193  : 		&& (pDphsettar->np == &PF2))

  01afa	8a 83 00 00 00
	00		 mov	 al, BYTE PTR _featb[ebx]
  01b00	a8 04		 test	 al, 4
  01b02	0f 84 bf 00 00
	00		 je	 $L71791
  01b08	0f bf 4c 24 20	 movsx	 ecx, WORD PTR _fonvowel$[esp+44]
  01b0d	f6 04 4d 00 00
	00 00 04	 test	 BYTE PTR _featb[ecx*2], 4
  01b15	0f 84 ac 00 00
	00		 je	 $L71791
  01b1b	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  01b1e	8d 56 48	 lea	 edx, DWORD PTR [esi+72]
  01b21	3b c2		 cmp	 eax, edx
  01b23	0f 85 9e 00 00
	00		 jne	 $L71791

; 194  : 	{
; 195  : 		/* Find target values for both vowels */
; 196  : 		if (initfinso == 'i')

  01b29	80 7c 24 3c 69	 cmp	 BYTE PTR _initfinso$[esp+40], 105 ; 00000069H
  01b2e	75 11		 jne	 SHORT $L71792

; 197  : 		{
; 198  : 			tarvowel = getendtar (phTTS, nfonvowel);

  01b30	8b 44 24 40	 mov	 eax, DWORD PTR _nfonvowel$[esp+40]
  01b34	8b 4c 24 30	 mov	 ecx, DWORD PTR _phTTS$[esp+40]
  01b38	50		 push	 eax
  01b39	51		 push	 ecx
  01b3a	e8 00 00 00 00	 call	 _getendtar

; 199  : 		}
; 200  : 		else

  01b3f	eb 0f		 jmp	 SHORT $L72058
$L71792:

; 201  : 		{
; 202  : 			tarvowel = getbegtar (phTTS, nfonvowel);

  01b41	8b 54 24 40	 mov	 edx, DWORD PTR _nfonvowel$[esp+40]
  01b45	8b 44 24 30	 mov	 eax, DWORD PTR _phTTS$[esp+40]
  01b49	52		 push	 edx
  01b4a	50		 push	 eax
  01b4b	e8 00 00 00 00	 call	 _getbegtar
$L72058:

; 203  : 		}
; 204  : 		/* Set vvbouval, the offset to boundary value due to the remote vowel */
; 205  : 		vv_coartic_across_c (pDph_t, fonvowel, tarvowel, fonsonor, curval,
; 206  : 							 fonobst, pDph_t->allodurs[nfonobst]);

  01b50	0f bf 4c 24 3c	 movsx	 ecx, WORD PTR _nfonobst$[esp+48]
  01b55	8b 5c 24 20	 mov	 ebx, DWORD PTR _curval$[esp+52]
  01b59	83 c4 08	 add	 esp, 8
  01b5c	66 8b 94 4e 78
	0d 00 00	 mov	 dx, WORD PTR [esi+ecx*2+3448]
  01b64	8b 4c 24 14	 mov	 ecx, DWORD PTR _fonobst$[esp+44]
  01b68	52		 push	 edx
  01b69	8b 54 24 20	 mov	 edx, DWORD PTR _fonsonor$[esp+48]
  01b6d	51		 push	 ecx
  01b6e	53		 push	 ebx
  01b6f	52		 push	 edx
  01b70	50		 push	 eax
  01b71	8b 44 24 34	 mov	 eax, DWORD PTR _fonvowel$[esp+64]
  01b75	50		 push	 eax
  01b76	56		 push	 esi
  01b77	e8 00 00 00 00	 call	 _vv_coartic_across_c

; 207  : 		/* Now recompute boundary value taking into account this offset */
; 208  : 		curval += pDphsettar->vvbouval;

  01b7c	66 8b 4f 04	 mov	 cx, WORD PTR [edi+4]

; 209  : 		pDph_t->arg1 = prcnt;

  01b80	66 8b 54 24 54	 mov	 dx, WORD PTR _prcnt$[esp+68]
  01b85	03 d9		 add	 ebx, ecx
  01b87	66 89 96 f8 14
	00 00		 mov	 WORD PTR [esi+5368], dx

; 210  : 		pDph_t->arg2 = curval - locus;

  01b8e	8b c3		 mov	 eax, ebx

; 211  : 		pDph_t->arg3 = 100;

  01b90	66 c7 86 fc 14
	00 00 64 00	 mov	 WORD PTR [esi+5372], 100 ; 00000064H
  01b99	2b c5		 sub	 eax, ebp
  01b9b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 212  : 		delta_freq = muldv (pDph_t->arg1, pDph_t->arg2, pDph_t->arg3);
; 213  : 		pDphsettar->bouval = locus + delta_freq;
; 214  : 		pDphsettar->bouval -= pDphsettar->vvbouval;		/* pDphsettar->vvbouval will be added in phdraw */

  01b9e	0f bf c8	 movsx	 ecx, ax
  01ba1	0f af 4c 24 28	 imul	 ecx, DWORD PTR -4+[esp+44]
  01ba6	66 89 86 fa 14
	00 00		 mov	 WORD PTR [esi+5370], ax
  01bad	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  01bb2	f7 e9		 imul	 ecx
  01bb4	c1 fa 05	 sar	 edx, 5
  01bb7	8b c2		 mov	 eax, edx
  01bb9	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  01bbc	03 d0		 add	 edx, eax
  01bbe	66 2b 57 04	 sub	 dx, WORD PTR [edi+4]
  01bc2	03 d5		 add	 edx, ebp
  01bc4	66 89 17	 mov	 WORD PTR [edi], dx
$L71791:
  01bc7	5f		 pop	 edi
  01bc8	5e		 pop	 esi
  01bc9	5d		 pop	 ebp

; 215  : 	}
; 216  : 
; 217  : #ifdef DEBUG_TARGETS
; 218  : 	printf ("\t\t\t      (vtar = %4d  locus[%d] = %4d Hz  prcnt = %3d)\n",
; 219  : 			curval, ploc, locus, pDph_t->p_locus[ploc + 1]);
; 220  : #endif
; 221  : 
; 222  : 	return (1);						   /* Indicate success */

  01bca	66 b8 01 00	 mov	 ax, 1
  01bce	5b		 pop	 ebx

; 223  : }

  01bcf	83 c4 1c	 add	 esp, 28			; 0000001cH
  01bd2	c3		 ret	 0
$L71784:
  01bd3	5f		 pop	 edi
  01bd4	5e		 pop	 esi
  01bd5	5d		 pop	 ebp

; 94   : 	{
; 95   : 		return (0);					   /* Not obstruent-sonorant tran, as assumed */

  01bd6	66 33 c0	 xor	 ax, ax
  01bd9	5b		 pop	 ebx

; 223  : }

  01bda	83 c4 1c	 add	 esp, 28			; 0000001cH
  01bdd	c3		 ret	 0
_setloc	ENDP
_pDph_t$ = 8
_remotetar$ = 16
_currenttar$ = 24
_dur_cons$ = 32
_vv_coartic_across_c PROC NEAR

; 253  : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;

  01be0	8b 54 24 04	 mov	 edx, DWORD PTR _pDph_t$[esp-4]

; 254  : 
; 255  : 	if (dur_cons > NF100MS)

  01be4	8b 4c 24 1c	 mov	 ecx, DWORD PTR _dur_cons$[esp-4]
  01be8	56		 push	 esi
  01be9	66 83 f9 10	 cmp	 cx, 16			; 00000010H
  01bed	8b b2 d0 2b 00
	00		 mov	 esi, DWORD PTR [edx+11216]
  01bf3	7e 0c		 jle	 SHORT $L71810

; 256  : 	{
; 257  : 		pDphsettar->vvbouval = 0;

  01bf5	33 c0		 xor	 eax, eax
  01bf7	66 89 46 04	 mov	 WORD PTR [esi+4], ax

; 258  : 		pDphsettar->vvdurtran = 0;

  01bfb	66 89 46 08	 mov	 WORD PTR [esi+8], ax
  01bff	5e		 pop	 esi

; 266  : 	}
; 267  : 
; 268  : #ifdef DEBUG_TARGETS
; 269  : 	printf ("\t -> BV=%d TC=%d\n", pDphsettar->vvbouval, pDphsettar->vvdurtran);
; 270  : #endif
; 271  : }

  01c00	c3		 ret	 0
$L71810:

; 259  : 	}
; 260  : 	else
; 261  : 	{
; 262  : 		pDph_t->arg1 = (remotetar - currenttar) * (NF100MS - dur_cons);

  01c01	8b 44 24 10	 mov	 eax, DWORD PTR _remotetar$[esp]
  01c05	57		 push	 edi
  01c06	8b 7c 24 1c	 mov	 edi, DWORD PTR _currenttar$[esp+4]

; 263  : 		pDph_t->arg2 = 460;			   /* 45% of pDph_t->arg1, also divided by 16 frames */

  01c0a	66 c7 82 fa 14
	00 00 cc 01	 mov	 WORD PTR [edx+5370], 460 ; 000001ccH
  01c13	2b c7		 sub	 eax, edi
  01c15	bf 10 00 00 00	 mov	 edi, 16			; 00000010H
  01c1a	2b f9		 sub	 edi, ecx
  01c1c	0f af c7	 imul	 eax, edi
  01c1f	66 89 82 f8 14
	00 00		 mov	 WORD PTR [edx+5368], ax
  01c26	5f		 pop	 edi

; 264  : 		pDphsettar->vvbouval = mlsh1 (pDph_t->arg1, pDph_t->arg2);

  01c27	0f bf d0	 movsx	 edx, ax

; 265  : 		pDphsettar->vvdurtran = NF80MS - (dur_cons >> 2);

  01c2a	66 c1 f9 02	 sar	 cx, 2
  01c2e	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  01c31	c1 e0 03	 shl	 eax, 3
  01c34	2b c2		 sub	 eax, edx
  01c36	ba 0d 00 00 00	 mov	 edx, 13			; 0000000dH
  01c3b	2b d1		 sub	 edx, ecx
  01c3d	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  01c40	66 89 56 08	 mov	 WORD PTR [esi+8], dx
  01c44	c1 e0 02	 shl	 eax, 2
  01c47	c1 f8 0e	 sar	 eax, 14			; 0000000eH
  01c4a	66 89 46 04	 mov	 WORD PTR [esi+4], ax
  01c4e	5e		 pop	 esi

; 266  : 	}
; 267  : 
; 268  : #ifdef DEBUG_TARGETS
; 269  : 	printf ("\t -> BV=%d TC=%d\n", pDphsettar->vvbouval, pDphsettar->vvdurtran);
; 270  : #endif
; 271  : }

  01c4f	c3		 ret	 0
_vv_coartic_across_c ENDP
_phTTS$ = 8
_nfone$ = 12
_getbegtar PROC NEAR

; 868  : 	short                   temp, temp1;
; 869  : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  01c50	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  01c54	53		 push	 ebx
  01c55	55		 push	 ebp

; 870  : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 871  : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;
; 872  : 
; 873  : 	temp = gettar (phTTS, nfone);

  01c56	8b 6c 24 10	 mov	 ebp, DWORD PTR _nfone$[esp+4]
  01c5a	56		 push	 esi
  01c5b	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  01c5e	57		 push	 edi
  01c5f	55		 push	 ebp
  01c60	8b 9e d0 2b 00
	00		 mov	 ebx, DWORD PTR [esi+11216]
  01c66	50		 push	 eax
  01c67	e8 00 00 00 00	 call	 _gettar
  01c6c	83 c4 08	 add	 esp, 8

; 874  : 	if (temp < -1)

  01c6f	66 3d ff ff	 cmp	 ax, -1
  01c73	7d 28		 jge	 SHORT $L71881

; 875  : 	{                                                                  /* If next seg diphthong, */
; 876  : 		temp = pDph_t->p_diph[-temp];  /* use diph first value  */

  01c75	8b 8e ec 14 00
	00		 mov	 ecx, DWORD PTR [esi+5356]
  01c7b	0f bf c0	 movsx	 eax, ax
  01c7e	d1 e0		 shl	 eax, 1
  01c80	2b c8		 sub	 ecx, eax

; 877  : 		/* Special coarticulation rules to change (vowel) target */
; 878  : 		if (pDphsettar->par_type IS_FORM_FREQ)

  01c82	8a 43 14	 mov	 al, BYTE PTR [ebx+20]
  01c85	3c 03		 cmp	 al, 3
  01c87	66 8b 39	 mov	 di, WORD PTR [ecx]
  01c8a	75 0e		 jne	 SHORT $L72061

; 879  : 		{
; 880  : 			temp1 = special_coartic (pDph_t, nfone, 0);

  01c8c	6a 00		 push	 0
  01c8e	55		 push	 ebp
  01c8f	56		 push	 esi
  01c90	e8 00 00 00 00	 call	 _special_coartic
  01c95	83 c4 0c	 add	 esp, 12			; 0000000cH

; 881  : 			temp += temp1;

  01c98	03 f8		 add	 edi, eax
$L72061:

; 882  : 		}
; 883  : 	}
; 884  : 	return (temp);

  01c9a	66 8b c7	 mov	 ax, di
$L71881:
  01c9d	5f		 pop	 edi
  01c9e	5e		 pop	 esi
  01c9f	5d		 pop	 ebp
  01ca0	5b		 pop	 ebx

; 885  : }

  01ca1	c3		 ret	 0
_getbegtar ENDP
_pDph_t$ = 8
_nfon$ = 12
_diphpos$ = 16
_temp$ = 8
_special_coartic PROC NEAR

; 329  : 	/* Note: Gen coartic of 5% with adjacent segs elsewhere, so stuff here is big */
; 330  : 	/* This routine is only called if the current segment is diph (i.e. a vowel) */
; 331  : 
; 332  : 	short                   temp, fonnex, foncur, fonlas;
; 333  : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;
; 334  : 
; 335  : 	temp = 0;
; 336  : 	foncur = get_phone(pDph_t, nfon);

  01cb0	66 8b 44 24 08	 mov	 ax, WORD PTR _nfon$[esp-4]
  01cb5	53		 push	 ebx
  01cb6	55		 push	 ebp
  01cb7	56		 push	 esi
  01cb8	57		 push	 edi
  01cb9	8b 7c 24 14	 mov	 edi, DWORD PTR _pDph_t$[esp+12]
  01cbd	66 85 c0	 test	 ax, ax
  01cc0	8b 97 d0 2b 00
	00		 mov	 edx, DWORD PTR [edi+11216]
  01cc6	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _temp$[esp+12], 0
  01cce	7c 16		 jl	 SHORT $L72064
  01cd0	66 3b 87 e2 14
	00 00		 cmp	 ax, WORD PTR [edi+5346]
  01cd7	7d 0d		 jge	 SHORT $L72064
  01cd9	0f bf c8	 movsx	 ecx, ax
  01cdc	66 8b 8c 4f c6
	03 00 00	 mov	 cx, WORD PTR [edi+ecx*2+966]
  01ce4	eb 02		 jmp	 SHORT $L72065
$L72064:
  01ce6	33 c9		 xor	 ecx, ecx
$L72065:

; 337  : 	fonnex = get_phone(pDph_t, nfon + 1);

  01ce8	0f bf e8	 movsx	 ebp, ax
  01ceb	8d 45 01	 lea	 eax, DWORD PTR [ebp+1]
  01cee	85 c0		 test	 eax, eax
  01cf0	7c 15		 jl	 SHORT $L72066
  01cf2	0f bf b7 e2 14
	00 00		 movsx	 esi, WORD PTR [edi+5346]
  01cf9	3b c6		 cmp	 eax, esi
  01cfb	7d 0a		 jge	 SHORT $L72066
  01cfd	66 8b 9c 6f c8
	03 00 00	 mov	 bx, WORD PTR [edi+ebp*2+968]
  01d05	eb 02		 jmp	 SHORT $L72067
$L72066:
  01d07	33 db		 xor	 ebx, ebx
$L72067:

; 338  : 	fonlas = get_phone(pDph_t, nfon - 1);

  01d09	8d 45 ff	 lea	 eax, DWORD PTR [ebp-1]
  01d0c	85 c0		 test	 eax, eax
  01d0e	7c 15		 jl	 SHORT $L72068
  01d10	0f bf b7 e2 14
	00 00		 movsx	 esi, WORD PTR [edi+5346]
  01d17	3b c6		 cmp	 eax, esi
  01d19	7d 0a		 jge	 SHORT $L72068
  01d1b	66 8b b4 6f c4
	03 00 00	 mov	 si, WORD PTR [edi+ebp*2+964]
  01d23	eb 02		 jmp	 SHORT $L72069
$L72068:
  01d25	33 f6		 xor	 esi, esi
$L72069:

; 339  : 
; 340  : 	/* F3 target of selected vowels */
; 341  : 	if (pDphsettar->np == &PF3)

  01d27	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  01d2a	8d 57 6c	 lea	 edx, DWORD PTR [edi+108]
  01d2d	3b c2		 cmp	 eax, edx
  01d2f	75 3f		 jne	 SHORT $L71452

; 342  : 	{
; 343  : 		if (((featb[foncur] & FVOWEL) IS_PLUS) && (foncur != RR))

  01d31	0f bf d1	 movsx	 edx, cx
  01d34	f6 04 55 00 00
	00 00 04	 test	 BYTE PTR _featb[edx*2], 4
  01d3c	74 32		 je	 SHORT $L71452
  01d3e	66 83 f9 0f	 cmp	 cx, 15			; 0000000fH
  01d42	74 2c		 je	 SHORT $L71452

; 344  : 		{
; 345  : 			if (((fonlas == W) || (fonlas == R) || (fonlas == RX))
; 346  : 				|| ((fonnex == W) || (fonnex == R) || (fonnex == RX)))

  01d44	66 83 fe 18	 cmp	 si, 24			; 00000018H
  01d48	74 1e		 je	 SHORT $L71454
  01d4a	66 83 fe 1a	 cmp	 si, 26			; 0000001aH
  01d4e	74 18		 je	 SHORT $L71454
  01d50	66 83 fe 1d	 cmp	 si, 29			; 0000001dH
  01d54	74 12		 je	 SHORT $L71454
  01d56	66 83 fb 18	 cmp	 bx, 24			; 00000018H
  01d5a	74 0c		 je	 SHORT $L71454
  01d5c	66 83 fb 1a	 cmp	 bx, 26			; 0000001aH
  01d60	74 06		 je	 SHORT $L71454
  01d62	66 83 fb 1d	 cmp	 bx, 29			; 0000001dH
  01d66	75 08		 jne	 SHORT $L71452
$L71454:

; 347  : 			{
; 348  : 				temp = -150;

  01d68	c7 44 24 14 6a
	ff ff ff	 mov	 DWORD PTR _temp$[esp+12], -150 ; ffffff6aH
$L71452:

; 349  : 			}
; 350  : 		}
; 351  : 	}
; 352  : 	/* F2 target of selected vowels */
; 353  : 	if (pDphsettar->np == &PF2)

  01d70	8d 57 48	 lea	 edx, DWORD PTR [edi+72]
  01d73	3b c2		 cmp	 eax, edx
  01d75	0f 85 3d 01 00
	00		 jne	 $L72072

; 354  : 	{
; 355  : 		/* Front vowel F2 target lowered before [LX] */
; 356  : 		if (fonnex == LX)

  01d7b	66 8b 54 24 1c	 mov	 dx, WORD PTR _diphpos$[esp+12]
  01d80	66 83 fb 1e	 cmp	 bx, 30			; 0000001eH
  01d84	75 4e		 jne	 SHORT $L71462

; 357  : 		{
; 358  : 			if (((foncur >= IY) && (foncur <= AE)) || (foncur == IX))

  01d86	66 83 f9 01	 cmp	 cx, 1
  01d8a	7c 06		 jl	 SHORT $L71459
  01d8c	66 83 f9 05	 cmp	 cx, 5
  01d90	7e 06		 jle	 SHORT $L71458
$L71459:
  01d92	66 83 f9 12	 cmp	 cx, 18			; 00000012H
  01d96	75 08		 jne	 SHORT $L71457
$L71458:

; 359  : 			{
; 360  : 				temp = -150;

  01d98	c7 44 24 14 6a
	ff ff ff	 mov	 DWORD PTR _temp$[esp+12], -150 ; ffffff6aH
$L71457:

; 361  : 			}
; 362  : 			if (((foncur == AY) || (foncur == OY))
; 363  : 				&& (diphpos == 1))

  01da0	66 83 f9 07	 cmp	 cx, 7
  01da4	74 06		 je	 SHORT $L71461
  01da6	66 83 f9 0c	 cmp	 cx, 12			; 0000000cH
  01daa	75 0e		 jne	 SHORT $L71460
$L71461:
  01dac	66 83 fa 01	 cmp	 dx, 1
  01db0	75 08		 jne	 SHORT $L71460

; 364  : 			{
; 365  : 				temp = -250;

  01db2	c7 44 24 14 06
	ff ff ff	 mov	 DWORD PTR _temp$[esp+12], -250 ; ffffff06H
$L71460:

; 366  : 			}
; 367  : 			if (((foncur == AY) || (foncur == OY))
; 368  : 				&& (diphpos > 1))

  01dba	66 83 f9 07	 cmp	 cx, 7
  01dbe	74 06		 je	 SHORT $L71463
  01dc0	66 83 f9 0c	 cmp	 cx, 12			; 0000000cH
  01dc4	75 0e		 jne	 SHORT $L71462
$L71463:
  01dc6	66 83 fa 01	 cmp	 dx, 1
  01dca	7e 08		 jle	 SHORT $L71462

; 369  : 			{
; 370  : 				temp = -350;

  01dcc	c7 44 24 14 a2
	fe ff ff	 mov	 DWORD PTR _temp$[esp+12], -350 ; fffffea2H
$L71462:

; 371  : 
; 372  : 			}
; 373  : 		}
; 374  : 		/* Front vowel F2 target lowered after [W], [L] (DO ALSO FOR F3 of [W] */
; 375  : 		if ((fonlas == W) || (fonlas == LL) || (fonlas == LX))

  01dd4	66 83 fe 18	 cmp	 si, 24			; 00000018H
  01dd8	74 0c		 je	 SHORT $L71465
  01dda	66 83 fe 1b	 cmp	 si, 27			; 0000001bH
  01dde	74 06		 je	 SHORT $L71465
  01de0	66 83 fe 1e	 cmp	 si, 30			; 0000001eH
  01de4	75 1a		 jne	 SHORT $L71466
$L71465:

; 376  : 		{
; 377  : 			if (((foncur >= IY) && (foncur <= AE)) || (foncur == IX))

  01de6	66 83 f9 01	 cmp	 cx, 1
  01dea	7c 06		 jl	 SHORT $L71468
  01dec	66 83 f9 05	 cmp	 cx, 5
  01df0	7e 06		 jle	 SHORT $L71467
$L71468:
  01df2	66 83 f9 12	 cmp	 cx, 18			; 00000012H
  01df6	75 08		 jne	 SHORT $L71466
$L71467:

; 378  : 			{
; 379  : 				temp = -150;		   /* las and nex effects not cumulative */

  01df8	c7 44 24 14 6a
	ff ff ff	 mov	 DWORD PTR _temp$[esp+12], -150 ; ffffff6aH
$L71466:

; 380  : 			}
; 381  : 		}
; 382  : 		/* [UW] F2 target raised adjacent to an alveolar */
; 383  : 		if (foncur == UW)

  01e00	66 83 f9 0e	 cmp	 cx, 14			; 0000000eH
  01e04	b0 08		 mov	 al, 8
  01e06	75 16		 jne	 SHORT $L72070

; 384  : 		{
; 385  : 			if ((place[fonlas] & FALVEL) IS_PLUS)

  01e08	0f bf f6	 movsx	 esi, si
  01e0b	84 04 75 00 00
	00 00		 test	 BYTE PTR _place[esi*2], al
  01e12	74 15		 je	 SHORT $L71472

; 386  : 			{
; 387  : 				temp = 200;

  01e14	c7 44 24 14 c8
	00 00 00	 mov	 DWORD PTR _temp$[esp+12], 200 ; 000000c8H

; 388  : 			}
; 389  : 		}
; 390  : 		if ((foncur == UW)
; 391  : 			|| ((foncur == YU) && (diphpos > 0)))

  01e1c	eb 0b		 jmp	 SHORT $L71472
$L72070:
  01e1e	66 83 f9 10	 cmp	 cx, 16			; 00000010H
  01e22	75 19		 jne	 SHORT $L71473
  01e24	66 85 d2	 test	 dx, dx
  01e27	7e 14		 jle	 SHORT $L71473
$L71472:

; 392  : 		{
; 393  : 			if ((place[fonnex] & FALVEL) IS_PLUS)

  01e29	0f bf f3	 movsx	 esi, bx
  01e2c	84 04 75 00 00
	00 00		 test	 BYTE PTR _place[esi*2], al
  01e33	74 08		 je	 SHORT $L71473

; 394  : 			{
; 395  : 				temp += 200;

  01e35	81 44 24 14 c8
	00 00 00	 add	 DWORD PTR _temp$[esp+12], 200 ; 000000c8H
$L71473:

; 396  : 			}
; 397  : 		}
; 398  : 		/* Effects are greater for unstressed vowels */
; 399  : 		if ((pDph_t->allofeats[nfon] & FSTRESS) IS_MINUS)

  01e3d	8b 84 af 34 06
	00 00		 mov	 eax, DWORD PTR [edi+ebp*4+1588]
  01e44	a8 03		 test	 al, 3
  01e46	75 2f		 jne	 SHORT $L71474

; 400  : 		{
; 401  : 			temp += (temp >> 1);

  01e48	66 8b 44 24 14	 mov	 ax, WORD PTR _temp$[esp+12]
  01e4d	8b 74 24 14	 mov	 esi, DWORD PTR _temp$[esp+12]
  01e51	66 d1 f8	 sar	 ax, 1
  01e54	03 f0		 add	 esi, eax

; 402  : 
; 403  : 			/* Unstressed YU has a fronted U part */
; 404  : 			if ((foncur == YU) && (diphpos > 0))

  01e56	66 83 f9 10	 cmp	 cx, 16			; 00000010H
  01e5a	89 74 24 14	 mov	 DWORD PTR _temp$[esp+12], esi
  01e5e	75 2d		 jne	 SHORT $L72073
  01e60	66 85 d2	 test	 dx, dx
  01e63	7e 28		 jle	 SHORT $L72073
  01e65	5f		 pop	 edi

; 405  : 			{
; 406  : 				temp = 400;

  01e66	c7 44 24 10 90
	01 00 00	 mov	 DWORD PTR _temp$[esp+8], 400 ; 00000190H

; 419  : 	}
; 420  : 
; 421  : 	return (temp);

  01e6e	66 8b 44 24 10	 mov	 ax, WORD PTR _temp$[esp+8]
  01e73	5e		 pop	 esi
  01e74	5d		 pop	 ebp
  01e75	5b		 pop	 ebx

; 422  : }

  01e76	c3		 ret	 0
$L71474:

; 407  : 			}
; 408  : 		}
; 409  : 		/* Reduce effects for phrase-final stressed vowels */
; 410  : 		else if ((pDph_t->allofeats[nfon] & FBOUNDARY) >= FVPNEXT)

  01e77	25 e0 01 00 00	 and	 eax, 480		; 000001e0H
  01e7c	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  01e81	72 0a		 jb	 SHORT $L72073

; 411  : 		{
; 412  : 			temp = temp >> 1;

  01e83	66 8b 44 24 14	 mov	 ax, WORD PTR _temp$[esp+12]
  01e88	66 d1 f8	 sar	 ax, 1
  01e8b	eb 05		 jmp	 SHORT $L71477
$L72073:
  01e8d	66 8b 44 24 14	 mov	 ax, WORD PTR _temp$[esp+12]
$L71477:

; 413  : 		}
; 414  : 		/* Maximum change should not be excessive */
; 415  : 		if (temp > 400)

  01e92	66 3d 90 01	 cmp	 ax, 400			; 00000190H
  01e96	7e 12		 jle	 SHORT $L71478
  01e98	5f		 pop	 edi

; 416  : 			temp = 400;

  01e99	c7 44 24 10 90
	01 00 00	 mov	 DWORD PTR _temp$[esp+8], 400 ; 00000190H

; 419  : 	}
; 420  : 
; 421  : 	return (temp);

  01ea1	66 8b 44 24 10	 mov	 ax, WORD PTR _temp$[esp+8]
  01ea6	5e		 pop	 esi
  01ea7	5d		 pop	 ebp
  01ea8	5b		 pop	 ebx

; 422  : }

  01ea9	c3		 ret	 0
$L71478:

; 417  : 		if (temp < -400)

  01eaa	66 3d 70 fe	 cmp	 ax, -400		; fffffe70H
  01eae	7d 0d		 jge	 SHORT $L71479

; 418  : 			temp = -400;

  01eb0	c7 44 24 14 70
	fe ff ff	 mov	 DWORD PTR _temp$[esp+12], -400 ; fffffe70H
$L72072:

; 419  : 	}
; 420  : 
; 421  : 	return (temp);

  01eb8	66 8b 44 24 14	 mov	 ax, WORD PTR _temp$[esp+12]
$L71479:
  01ebd	5f		 pop	 edi
  01ebe	5e		 pop	 esi
  01ebf	5d		 pop	 ebp
  01ec0	5b		 pop	 ebx

; 422  : }

  01ec1	c3		 ret	 0
_special_coartic ENDP
_phTTS$ = 8
_nfone$ = 12
_getendtar PROC NEAR

; 906  : 	short                   temp, temp1;
; 907  : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  01ed0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  01ed4	53		 push	 ebx
  01ed5	55		 push	 ebp

; 908  : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 909  : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;
; 910  : 
; 911  : 	temp = gettar (phTTS, nfone);

  01ed6	8b 6c 24 10	 mov	 ebp, DWORD PTR _nfone$[esp+4]
  01eda	56		 push	 esi
  01edb	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  01ede	57		 push	 edi
  01edf	55		 push	 ebp
  01ee0	8b 9e d0 2b 00
	00		 mov	 ebx, DWORD PTR [esi+11216]
  01ee6	50		 push	 eax
  01ee7	e8 00 00 00 00	 call	 _gettar
  01eec	83 c4 08	 add	 esp, 8

; 912  : 	if (temp < -1)

  01eef	66 3d ff ff	 cmp	 ax, -1
  01ef3	7d 3d		 jge	 SHORT $L71896

; 913  : 	{
; 914  : 		temp = -temp;                              /* Vowel tar is diphth */
; 915  : 		while (pDph_t->p_diph[temp] != -1)

  01ef5	8b 8e ec 14 00
	00		 mov	 ecx, DWORD PTR [esi+5356]
  01efb	f7 d8		 neg	 eax
  01efd	0f bf d0	 movsx	 edx, ax
  01f00	66 83 3c 51 ff	 cmp	 WORD PTR [ecx+edx*2], -1
  01f05	74 0b		 je	 SHORT $L71895
$L71894:

; 916  : 		{
; 917  : 			temp++;

  01f07	40		 inc	 eax
  01f08	0f bf d0	 movsx	 edx, ax
  01f0b	66 83 3c 51 ff	 cmp	 WORD PTR [ecx+edx*2], -1
  01f10	75 f5		 jne	 SHORT $L71894
$L71895:

; 918  : 		}
; 919  : 		temp = pDph_t->p_diph[temp - 1];        /* Last val of diph */

  01f12	0f bf c0	 movsx	 eax, ax
  01f15	66 8b 7c 41 fe	 mov	 di, WORD PTR [ecx+eax*2-2]

; 920  : 		/* Special coarticulation rules to change (vowel) target */
; 921  : 		if (pDphsettar->par_type IS_FORM_FREQ)

  01f1a	8a 43 14	 mov	 al, BYTE PTR [ebx+20]
  01f1d	3c 03		 cmp	 al, 3
  01f1f	75 0e		 jne	 SHORT $L72083

; 922  : 		{
; 923  : 			temp1 = special_coartic (pDph_t, nfone, 1);

  01f21	6a 01		 push	 1
  01f23	55		 push	 ebp
  01f24	56		 push	 esi
  01f25	e8 00 00 00 00	 call	 _special_coartic
  01f2a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 924  : 			temp += temp1;

  01f2d	03 f8		 add	 edi, eax
$L72083:

; 925  : 		}
; 926  : 	}
; 927  : 	return (temp);

  01f2f	66 8b c7	 mov	 ax, di
$L71896:
  01f32	5f		 pop	 edi
  01f33	5e		 pop	 esi
  01f34	5d		 pop	 ebp
  01f35	5b		 pop	 ebx

; 928  : }

  01f36	c3		 ret	 0
_getendtar ENDP
_pDph_t$ = 8
_pdip$ = 12
_inhdr_frames$ = 16
_shrink$ = 20
_ppsNdips$ = 28
_dip_pos$ = -12
_dipsw$ = -16
_oldvalue$ = 28
_newvalue$ = 8
_oldtime$ = -8
_make_dip PROC NEAR

; 955  : {

  01f40	83 ec 10	 sub	 esp, 16			; 00000010H
  01f43	53		 push	 ebx
  01f44	55		 push	 ebp

; 956  : 	short                   temp, dip_pos;
; 957  : 
; 958  : 	/* MVP :List of variables made local                      */
; 959  : 	short                   dipsw;
; 960  : 	short                   oldvalue, newvalue, oldtime, newtime;
; 961  : 
; 962  : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;
; 963  : 
; 964  : 	pDphsettar->np->ndip = *ppsNdips;  /* Start of diph info for this par in dipspec[] */

  01f45	8b 6c 24 30	 mov	 ebp, DWORD PTR _ppsNdips$[esp+20]
  01f49	56		 push	 esi
  01f4a	8b 74 24 20	 mov	 esi, DWORD PTR _pDph_t$[esp+24]
  01f4e	57		 push	 edi
  01f4f	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  01f52	8b be d0 2b 00
	00		 mov	 edi, DWORD PTR [esi+11216]

; 965  : 
; 966  : 	oldvalue = pDph_t->p_diph[pdip];   /* cccc Initial value of first straight line */

  01f58	0f bf 54 24 28	 movsx	 edx, WORD PTR _pdip$[esp+28]
  01f5d	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  01f60	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  01f63	8b 86 ec 14 00
	00		 mov	 eax, DWORD PTR [esi+5356]
  01f69	66 8b 1c 50	 mov	 bx, WORD PTR [eax+edx*2]

; 967  : 
; 968  : 	/* Formant frequency coarticulation rules */
; 969  : 	if (pDphsettar->par_type IS_FORM_FREQ)

  01f6d	8a 47 14	 mov	 al, BYTE PTR [edi+20]
  01f70	3c 03		 cmp	 al, 3
  01f72	89 5c 24 38	 mov	 DWORD PTR _oldvalue$[esp+28], ebx
  01f76	75 51		 jne	 SHORT $L71918

; 970  : 	{
; 971  : 		/* General rule: prev. phone changes init. vowel tar toward phlas */
; 972  : 		pDphsettar->gencoartic = N10PRCNT;
; 973  : 		if ((struccur & FSTRESS) IS_MINUS)
; 974  : 		{
; 975  : 			/* Increased coarticulation, especially F2, if unstressed */
; 976  : 			/* OUT         gencoartic = N15PRCNT; if (pDphsettar->np == &PF2) { gencoartic = N25PRCNT; } END OUT */
; 977  : 		}
; 978  : 		pDph_t->arg1 = pDphsettar->np->tarlas - oldvalue;

  01f78	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  01f7b	66 c7 47 0c 66
	06		 mov	 WORD PTR [edi+12], 1638	; 00000666H

; 979  : 		pDph_t->arg2 = pDphsettar->gencoartic;
; 980  : 		oldvalue += mlsh1 (pDph_t->arg1, pDph_t->arg2);
; 981  : 		/* Special rule: (see subroutine) */
; 982  : 		dip_pos = 0;
; 983  : 		oldvalue += special_coartic (pDph_t, pDph_t->nphone, dip_pos);

  01f81	6a 00		 push	 0
  01f83	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _dip_pos$[esp+36], 0
  01f8b	66 8b 51 18	 mov	 dx, WORD PTR [ecx+24]
  01f8f	66 2b d3	 sub	 dx, bx
  01f92	66 89 96 f8 14
	00 00		 mov	 WORD PTR [esi+5368], dx
  01f99	66 8b 47 0c	 mov	 ax, WORD PTR [edi+12]
  01f9d	66 89 86 fa 14
	00 00		 mov	 WORD PTR [esi+5370], ax
  01fa4	0f bf c0	 movsx	 eax, ax
  01fa7	0f bf ca	 movsx	 ecx, dx
  01faa	0f af c1	 imul	 eax, ecx
  01fad	66 8b 96 a4 23
	00 00		 mov	 dx, WORD PTR [esi+9124]
  01fb4	c1 f8 0e	 sar	 eax, 14			; 0000000eH
  01fb7	52		 push	 edx
  01fb8	56		 push	 esi
  01fb9	03 d8		 add	 ebx, eax
  01fbb	e8 00 00 00 00	 call	 _special_coartic
  01fc0	83 c4 0c	 add	 esp, 12			; 0000000cH
  01fc3	03 d8		 add	 ebx, eax
  01fc5	89 5c 24 38	 mov	 DWORD PTR _oldvalue$[esp+28], ebx
$L71918:

; 984  : 
; 985  : #ifdef DEBUG_targetS
; 986  : 		printf (
; 987  : 				   " tarbeg=%4d  (from 10%% tarlas=%4d, 90%% tarbeg=%d)\n",
; 988  : 				   oldvalue, pDphsettar->np->tarlas, pDph_t->p_diph[pdip]);
; 989  : #endif
; 990  : 	}
; 991  : 	pDphsettar->np->tarcur = oldvalue;

  01fc9	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  01fcc	66 89 18	 mov	 WORD PTR [eax], bx

; 992  : 
; 993  : 	/* Current value of time */
; 994  : 	oldtime = 0;

  01fcf	33 c0		 xor	 eax, eax
  01fd1	89 44 24 18	 mov	 DWORD PTR _oldtime$[esp+32], eax

; 995  : 
; 996  : 	/* Process each <value,time> of diph definition */
; 997  : 	dipsw = 0;

  01fd5	89 44 24 10	 mov	 DWORD PTR _dipsw$[esp+32], eax
  01fd9	eb 04		 jmp	 SHORT $L71920
$L72088:
  01fdb	8b 5c 24 38	 mov	 ebx, DWORD PTR _oldvalue$[esp+28]
$L71920:

; 998  : 	do
; 999  : 	{
; 1000 : 		if (dipsw == 0)

  01fdf	66 83 7c 24 10
	00		 cmp	 WORD PTR _dipsw$[esp+32], 0
  01fe5	75 1a		 jne	 SHORT $L71923

; 1001 : 		{
; 1002 : 			newvalue = oldvalue;
; 1003 : 			dipsw++;
; 1004 : 			pdip++;

  01fe7	8b 44 24 28	 mov	 eax, DWORD PTR _pdip$[esp+28]
  01feb	89 5c 24 24	 mov	 DWORD PTR _newvalue$[esp+28], ebx
  01fef	40		 inc	 eax
  01ff0	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _dipsw$[esp+32], 1
  01ff8	89 44 24 28	 mov	 DWORD PTR _pdip$[esp+28], eax

; 1005 : 		}
; 1006 : 		else

  01ffc	e9 81 00 00 00	 jmp	 $L71925
$L71923:

; 1007 : 		{
; 1008 : 			newvalue = pDph_t->p_diph[pdip++];

  02001	8b 44 24 28	 mov	 eax, DWORD PTR _pdip$[esp+28]
  02005	8b 96 ec 14 00
	00		 mov	 edx, DWORD PTR [esi+5356]
  0200b	0f bf c8	 movsx	 ecx, ax
  0200e	40		 inc	 eax
  0200f	66 8b 0c 4a	 mov	 cx, WORD PTR [edx+ecx*2]
  02013	89 44 24 28	 mov	 DWORD PTR _pdip$[esp+28], eax

; 1009 : 
; 1010 : 			/* Formant frequency coarticulation rules */
; 1011 : 			if (pDphsettar->par_type IS_FORM_FREQ)

  02017	8a 47 14	 mov	 al, BYTE PTR [edi+20]
  0201a	66 89 4c 24 24	 mov	 WORD PTR _newvalue$[esp+28], cx
  0201f	3c 03		 cmp	 al, 3
  02021	75 5f		 jne	 SHORT $L71925

; 1012 : 			{
; 1013 : 				/* General rule: next phone changes vowel tar toward phnex */
; 1014 : 				if (pDphsettar->np->tarnex > 0)

  02023	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  02026	66 8b 42 16	 mov	 ax, WORD PTR [edx+22]
  0202a	66 85 c0	 test	 ax, ax
  0202d	7e 2e		 jle	 SHORT $L71926

; 1015 : 				{
; 1016 : 					pDph_t->arg1 = pDphsettar->np->tarnex - newvalue;

  0202f	8b 4c 24 24	 mov	 ecx, DWORD PTR _newvalue$[esp+28]
  02033	2b c1		 sub	 eax, ecx
  02035	66 89 86 f8 14
	00 00		 mov	 WORD PTR [esi+5368], ax

; 1017 : 					pDph_t->arg2 = pDphsettar->gencoartic;

  0203c	66 8b 47 0c	 mov	 ax, WORD PTR [edi+12]

; 1018 : 					newvalue += mlsh1 (pDph_t->arg1, pDph_t->arg2);

  02040	0f bf 96 f8 14
	00 00		 movsx	 edx, WORD PTR [esi+5368]
  02047	66 89 86 fa 14
	00 00		 mov	 WORD PTR [esi+5370], ax
  0204e	0f bf c0	 movsx	 eax, ax
  02051	0f af c2	 imul	 eax, edx
  02054	c1 f8 0e	 sar	 eax, 14			; 0000000eH
  02057	03 c8		 add	 ecx, eax
  02059	89 4c 24 24	 mov	 DWORD PTR _newvalue$[esp+28], ecx
$L71926:

; 1019 : 				}
; 1020 : 				/* Special rule: (see subroutine) */
; 1021 : 				newvalue += special_coartic (pDph_t, pDph_t->nphone, ++dip_pos);

  0205d	8b 44 24 14	 mov	 eax, DWORD PTR _dip_pos$[esp+32]
  02061	40		 inc	 eax
  02062	89 44 24 14	 mov	 DWORD PTR _dip_pos$[esp+32], eax
  02066	50		 push	 eax
  02067	66 8b 86 a4 23
	00 00		 mov	 ax, WORD PTR [esi+9124]
  0206e	50		 push	 eax
  0206f	56		 push	 esi
  02070	e8 00 00 00 00	 call	 _special_coartic
  02075	8b 4c 24 30	 mov	 ecx, DWORD PTR _newvalue$[esp+40]
  02079	83 c4 0c	 add	 esp, 12			; 0000000cH
  0207c	03 c8		 add	 ecx, eax
  0207e	89 4c 24 24	 mov	 DWORD PTR _newvalue$[esp+28], ecx
$L71925:

; 1022 : 
; 1023 : #ifdef DEBUG_targetS
; 1024 : 				printf (
; 1025 : 						   "%d diph tarend=%4d   (from 10%% tarnex=%4d, 90%% tarend=%d)\n",
; 1026 : 						   (pDphsettar->np - &PF1), newvalue, pDphsettar->np->tarnex, pDph_t->p_diph[pdip - 1]);
; 1027 : #endif
; 1028 : 			}
; 1029 : 		}
; 1030 : #ifdef ENGLISH
; 1031 : 		if (NSAMP_FRAME == 128)
; 1032 : 			newtime = pDph_t->p_diph[pdip] >> 1;    /* eab ccc for 1/2 samp */
; 1033 : 		else
; 1034 : #endif
; 1035 : 			newtime = pDph_t->p_diph[pdip];

  02082	0f bf 44 24 28	 movsx	 eax, WORD PTR _pdip$[esp+28]
  02087	8b 8e ec 14 00
	00		 mov	 ecx, DWORD PTR [esi+5356]
  0208d	d1 e0		 shl	 eax, 1
  0208f	89 44 24 1c	 mov	 DWORD PTR -4+[esp+32], eax
  02093	66 8b 0c 08	 mov	 cx, WORD PTR [eax+ecx]

; 1036 : 		if (newtime != -1)

  02097	66 83 f9 ff	 cmp	 cx, -1
  0209b	74 1c		 je	 SHORT $L71929

; 1037 : 		{
; 1038 : 			/* Adjust newtime as f(shrink), i.e. make tran dur semi-invariant */
; 1039 : 			newtime = shrdur (pDph_t, newtime, inhdr_frames, shrink);

  0209d	8b 54 24 30	 mov	 edx, DWORD PTR _shrink$[esp+28]
  020a1	8b 44 24 2c	 mov	 eax, DWORD PTR _inhdr_frames$[esp+28]
  020a5	52		 push	 edx
  020a6	50		 push	 eax
  020a7	51		 push	 ecx
  020a8	56		 push	 esi
  020a9	e8 00 00 00 00	 call	 _shrdur
  020ae	8b d8		 mov	 ebx, eax

; 1040 : 		}
; 1041 : 		else

  020b0	8b 44 24 2c	 mov	 eax, DWORD PTR -4+[esp+48]
  020b4	83 c4 10	 add	 esp, 16			; 00000010H
  020b7	eb 07		 jmp	 SHORT $L71930
$L71929:

; 1042 : 		{
; 1043 : 			/* Desired time is end of segment */
; 1044 : 			newtime = pDph_t->durfon;

  020b9	66 8b 9e e0 14
	00 00		 mov	 bx, WORD PTR [esi+5344]
$L71930:

; 1045 : 		}
; 1046 : 		*(*ppsNdips)++ = newtime;

  020c0	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  020c3	66 89 19	 mov	 WORD PTR [ecx], bx
  020c6	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  020c9	83 c1 02	 add	 ecx, 2
  020cc	89 4d 00	 mov	 DWORD PTR [ebp], ecx
  020cf	8b d1		 mov	 edx, ecx

; 1047 : 
; 1048 : 		/* Compute increment/frame during transition */
; 1049 : 		temp = newtime - oldtime;

  020d1	8b cb		 mov	 ecx, ebx
  020d3	2b 4c 24 18	 sub	 ecx, DWORD PTR _oldtime$[esp+32]

; 1050 : 		if (temp == 0)

  020d7	66 85 c9	 test	 cx, cx
  020da	75 05		 jne	 SHORT $L71931

; 1051 : 		{
; 1052 : 			*(*ppsNdips) = 0;

  020dc	66 89 0a	 mov	 WORD PTR [edx], cx

; 1053 : 		}
; 1054 : 		else

  020df	eb 63		 jmp	 SHORT $L71932
$L71931:

; 1055 : 		{
; 1056 : 			/* No divide if possible (for speed) */
; 1057 : 			pDph_t->arg2 = (newvalue - oldvalue) << 3;

  020e1	8b 44 24 24	 mov	 eax, DWORD PTR _newvalue$[esp+28]
  020e5	8b 54 24 38	 mov	 edx, DWORD PTR _oldvalue$[esp+28]
  020e9	2b c2		 sub	 eax, edx
  020eb	c1 e0 03	 shl	 eax, 3

; 1058 : 			if (temp < 50)

  020ee	66 83 f9 32	 cmp	 cx, 50			; 00000032H
  020f2	66 89 86 fa 14
	00 00		 mov	 WORD PTR [esi+5370], ax
  020f9	7d 2a		 jge	 SHORT $L71933

; 1059 : 			{
; 1060 : 				pDph_t->arg1 = divtab[temp];

  020fb	0f bf d1	 movsx	 edx, cx

; 1061 : 				*(*ppsNdips) = mlsh1 (pDph_t->arg1, pDph_t->arg2);

  020fe	0f bf 8e fa 14
	00 00		 movsx	 ecx, WORD PTR [esi+5370]
  02105	66 8b 04 55 00
	00 00 00	 mov	 ax, WORD PTR _divtab[edx*2]
  0210d	0f bf d0	 movsx	 edx, ax
  02110	0f af ca	 imul	 ecx, edx
  02113	66 89 86 f8 14
	00 00		 mov	 WORD PTR [esi+5368], ax
  0211a	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0211d	c1 f9 0e	 sar	 ecx, 14			; 0000000eH
  02120	66 89 08	 mov	 WORD PTR [eax], cx

; 1062 : 			}
; 1063 : 			else

  02123	eb 0f		 jmp	 SHORT $L71934
$L71933:

; 1064 : 			{
; 1065 : 				*(*ppsNdips) = pDph_t->arg2 / temp;

  02125	0f bf c0	 movsx	 eax, ax
  02128	0f bf c9	 movsx	 ecx, cx
  0212b	99		 cdq
  0212c	f7 f9		 idiv	 ecx
  0212e	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  02131	66 89 02	 mov	 WORD PTR [edx], ax
$L71934:

; 1066 : 			}
; 1067 : 			oldvalue = newvalue;

  02134	8b 44 24 24	 mov	 eax, DWORD PTR _newvalue$[esp+28]

; 1068 : 			oldtime = newtime;

  02138	89 5c 24 18	 mov	 DWORD PTR _oldtime$[esp+32], ebx
  0213c	89 44 24 38	 mov	 DWORD PTR _oldvalue$[esp+28], eax
  02140	8b 44 24 1c	 mov	 eax, DWORD PTR -4+[esp+32]
$L71932:

; 1069 : 		}
; 1070 : 		(*ppsNdips)++;

  02144	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]

; 1071 : 
; 1072 : 	}
; 1073 : 	while (pDph_t->p_diph[pdip++] != -1);

  02147	8b 5c 24 28	 mov	 ebx, DWORD PTR _pdip$[esp+28]
  0214b	83 c1 02	 add	 ecx, 2
  0214e	43		 inc	 ebx
  0214f	89 4d 00	 mov	 DWORD PTR [ebp], ecx
  02152	8b 8e ec 14 00
	00		 mov	 ecx, DWORD PTR [esi+5356]
  02158	89 5c 24 28	 mov	 DWORD PTR _pdip$[esp+28], ebx
  0215c	66 83 3c 08 ff	 cmp	 WORD PTR [eax+ecx], -1
  02161	0f 85 74 fe ff
	ff		 jne	 $L72088

; 1074 : 
; 1075 : 	/* Set final value of diph tran, first increment and duration in frames */
; 1076 : 	pDphsettar->np->tarend = newvalue; /* Code more transparent: use getendtar() */

  02167	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  0216a	66 8b 44 24 24	 mov	 ax, WORD PTR _newvalue$[esp+28]
  0216f	66 89 42 1a	 mov	 WORD PTR [edx+26], ax

; 1077 : 	pDphsettar->np->durlin = *pDphsettar->np->ndip++;

  02173	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  02176	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  02179	66 8b 11	 mov	 dx, WORD PTR [ecx]
  0217c	b9 02 00 00 00	 mov	 ecx, 2
  02181	66 89 50 02	 mov	 WORD PTR [eax+2], dx
  02185	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  02188	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0218b	03 d1		 add	 edx, ecx
  0218d	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 1078 : 	pDphsettar->np->deldip = *pDphsettar->np->ndip++;

  02190	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  02193	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  02196	66 8b 12	 mov	 dx, WORD PTR [edx]
  02199	66 89 50 04	 mov	 WORD PTR [eax+4], dx
  0219d	8b 7f 10	 mov	 edi, DWORD PTR [edi+16]
  021a0	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  021a3	03 c1		 add	 eax, ecx
  021a5	89 47 1c	 mov	 DWORD PTR [edi+28], eax
  021a8	5f		 pop	 edi
  021a9	5e		 pop	 esi
  021aa	5d		 pop	 ebp
  021ab	5b		 pop	 ebx

; 1079 : }

  021ac	83 c4 10	 add	 esp, 16			; 00000010H
  021af	c3		 ret	 0
_make_dip ENDP
_pDph_t$ = 8
_durin$ = 12
_inhdr_frames$ = 16
_shrink$ = 20
_shrdur	PROC NEAR

; 301  : 	short halfinhdr, halfmaxdur, foldswitch, localinhdr;
; 302  : 	PDPHSETTAR_ST pDphsettar = pDph_t->pSTphsettar;
; 303  : 
; 304  : 	/* Convert from ms to number of frames * 64 */
; 305  : 	durin = (durin * 10) + 5;

  021b0	8b 44 24 08	 mov	 eax, DWORD PTR _durin$[esp-4]
  021b4	53		 push	 ebx

; 306  : 	localinhdr = inhdr_frames * NSAMP_FRAME;
; 307  : 	halfinhdr = inhdr_frames * NSAMP_FRAME >> 1;

  021b5	8b 5c 24 10	 mov	 ebx, DWORD PTR _inhdr_frames$[esp]
  021b9	55		 push	 ebp
  021ba	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  021bd	56		 push	 esi

; 308  : 	pDph_t->arg1 = halfinhdr;

  021be	8b 74 24 10	 mov	 esi, DWORD PTR _pDph_t$[esp+8]
  021c2	57		 push	 edi
  021c3	8d 54 00 05	 lea	 edx, DWORD PTR [eax+eax+5]

; 309  : 	pDph_t->arg2 = shrink;
; 310  : 	halfmaxdur = mlsh1 (pDph_t->arg1, pDph_t->arg2);
; 311  : 
; 312  : 	/* Fold durin over about halfinhdr */
; 313  : 	foldswitch = 0;

  021c7	33 ed		 xor	 ebp, ebp
  021c9	0f bf c3	 movsx	 eax, bx
  021cc	8d 0c c0	 lea	 ecx, DWORD PTR [eax+eax*8]
  021cf	c1 e1 03	 shl	 ecx, 3
  021d2	2b c8		 sub	 ecx, eax
  021d4	8b c1		 mov	 eax, ecx
  021d6	66 8b 4c 24 20	 mov	 cx, WORD PTR _shrink$[esp+12]
  021db	d1 f8		 sar	 eax, 1
  021dd	66 89 8e fa 14
	00 00		 mov	 WORD PTR [esi+5370], cx
  021e4	66 89 86 f8 14
	00 00		 mov	 WORD PTR [esi+5368], ax
  021eb	0f bf f9	 movsx	 edi, cx
  021ee	0f bf c8	 movsx	 ecx, ax
  021f1	0f af cf	 imul	 ecx, edi
  021f4	c1 f9 0e	 sar	 ecx, 14			; 0000000eH

; 314  : 	if (durin > halfinhdr)

  021f7	66 3b d0	 cmp	 dx, ax
  021fa	7e 13		 jle	 SHORT $L71826
  021fc	8d 2c db	 lea	 ebp, DWORD PTR [ebx+ebx*8]
  021ff	c1 e5 03	 shl	 ebp, 3
  02202	2b eb		 sub	 ebp, ebx
  02204	8b dd		 mov	 ebx, ebp

; 315  : 	{
; 316  : 		durin = localinhdr - durin;
; 317  : 		foldswitch = 1;

  02206	bd 01 00 00 00	 mov	 ebp, 1
  0220b	2b da		 sub	 ebx, edx
  0220d	8b d3		 mov	 edx, ebx
$L71826:

; 318  : 	}
; 319  : 	/* Turn time around (measure from middle of inhdur */
; 320  : 	durin = halfinhdr - durin;
; 321  : 
; 322  : 	/* Shrink this time by less than full requested shrinkage */
; 323  : 	pDph_t->arg2 = ((unsigned) shrink + FRAC_ONE) >> 1;

  0220f	81 c7 00 40 00
	00		 add	 edi, 16384		; 00004000H
  02215	2b c2		 sub	 eax, edx
  02217	d1 ef		 shr	 edi, 1

; 324  : 	pDph_t->arg1 = durin;

  02219	66 89 86 f8 14
	00 00		 mov	 WORD PTR [esi+5368], ax
  02220	66 89 be fa 14
	00 00		 mov	 WORD PTR [esi+5370], di

; 325  : 	durin = mlsh1 (pDph_t->arg1, pDph_t->arg2);

  02227	0f bf c0	 movsx	 eax, ax
  0222a	0f bf d7	 movsx	 edx, di
  0222d	0f af c2	 imul	 eax, edx
  02230	c1 f8 0e	 sar	 eax, 14			; 0000000eH

; 326  : 
; 327  : 	/* See that this time does not exceed halfmaxdur */
; 328  : 	if (durin > halfmaxdur)

  02233	66 3b c1	 cmp	 ax, cx
  02236	7e 02		 jle	 SHORT $L71828

; 329  : 		durin = halfmaxdur;

  02238	8b c1		 mov	 eax, ecx
$L71828:

; 330  : 
; 331  : 	/* Convert back to true time */
; 332  : 	durin = halfmaxdur - durin;

  0223a	8b d1		 mov	 edx, ecx
  0223c	5f		 pop	 edi
  0223d	2b d0		 sub	 edx, eax
  0223f	5e		 pop	 esi

; 333  : 	if (foldswitch == 1)

  02240	66 83 fd 01	 cmp	 bp, 1
  02244	5d		 pop	 ebp
  02245	5b		 pop	 ebx
  02246	75 09		 jne	 SHORT $L71829

; 334  : 		durin = halfmaxdur + halfmaxdur - durin;

  02248	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  0224b	8b c8		 mov	 ecx, eax
  0224d	2b ca		 sub	 ecx, edx
  0224f	8b d1		 mov	 edx, ecx
$L71829:

; 335  : 
; 336  : 	/* Minimum value is one */
; 337  : 	if (durin < NSAMP_FRAME)

  02251	66 83 fa 47	 cmp	 dx, 71			; 00000047H
  02255	7d 05		 jge	 SHORT $L71830

; 338  : 		durin = NSAMP_FRAME;

  02257	ba 47 00 00 00	 mov	 edx, 71			; 00000047H
$L71830:

; 339  : 
; 340  : 	return (durin >> 6);

  0225c	0f bf c2	 movsx	 eax, dx
  0225f	c1 f8 06	 sar	 eax, 6

; 341  : }

  02262	c3		 ret	 0
_shrdur	ENDP
_TEXT	ENDS
EXTRN	_inhdr:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_psInhdr_frames$ = 12
_psShrink$ = 16
_psShrif$ = 20
_psShrib$ = 24
_psPholas$ = 28
_psFealas$ = 32
_psFeacur$ = 36
_psFeanex$ = 40
_psStruclm2$ = 44
_psStruclas$ = 48
_psStruccur$ = 52
_psStrucnex$ = 56
_ppsNdips$ = 60
_psPhonp2$ = 64
_init_variables PROC NEAR

; 1241 : {

  02270	53		 push	 ebx
  02271	55		 push	 ebp

; 1242 : 	PDPH_T                  pDph_t = phTTS->pPHThreadData;

  02272	8b 6c 24 0c	 mov	 ebp, DWORD PTR _phTTS$[esp+4]
  02276	56		 push	 esi
  02277	57		 push	 edi
  02278	8b 75 18	 mov	 esi, DWORD PTR [ebp+24]

; 1243 : 	PKSD_T                  pKsd_t = phTTS->pKernelShareData;
; 1244 : 	PDPHSETTAR_ST           pDphsettar = pDph_t->pSTphsettar;
; 1245 : 
; 1246 : 	if (pDph_t->nphone == 0)

  0227b	66 8b 86 a4 23
	00 00		 mov	 ax, WORD PTR [esi+9124]
  02282	8b be d0 2b 00
	00		 mov	 edi, DWORD PTR [esi+11216]
  02288	66 85 c0	 test	 ax, ax
  0228b	75 52		 jne	 SHORT $L71969

; 1247 : 	{
; 1248 : 		*psStruclm2 = 0;

  0228d	8b 44 24 38	 mov	 eax, DWORD PTR _psStruclm2$[esp+12]

; 1249 : 		*psPholas = SIL;

  02291	8b 4c 24 28	 mov	 ecx, DWORD PTR _psPholas$[esp+12]
  02295	66 c7 00 00 00	 mov	 WORD PTR [eax], 0
  0229a	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0

; 1250 : 		if (pDphsettar->initsw == 0)

  0229f	66 83 7f 0e 00	 cmp	 WORD PTR [edi+14], 0
  022a4	75 72		 jne	 SHORT $L71974

; 1251 : 		{
; 1252 : 			pDphsettar->initsw++;
; 1253 : 			for (pDphsettar->np = &PF1; pDphsettar->np <= &PTILT; pDphsettar->np++)

  022a6	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
  022a9	8d 9e 40 02 00
	00		 lea	 ebx, DWORD PTR [esi+576]
  022af	3b c3		 cmp	 eax, ebx
  022b1	66 c7 47 0e 01
	00		 mov	 WORD PTR [edi+14], 1
  022b7	89 47 10	 mov	 DWORD PTR [edi+16], eax
  022ba	77 5c		 ja	 SHORT $L71974
$L71971:

; 1254 : 			{
; 1255 : 				pDphsettar->np->tarend = getbegtar (phTTS, 0);

  022bc	6a 00		 push	 0
  022be	55		 push	 ebp
  022bf	e8 00 00 00 00	 call	 _getbegtar
  022c4	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  022c7	83 c4 08	 add	 esp, 8
  022ca	66 89 42 1a	 mov	 WORD PTR [edx+26], ax
  022ce	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  022d1	83 c1 24	 add	 ecx, 36			; 00000024H
  022d4	8b c1		 mov	 eax, ecx
  022d6	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  022d9	3b c3		 cmp	 eax, ebx
  022db	76 df		 jbe	 SHORT $L71971

; 1256 : 			}
; 1257 : 		}
; 1258 : 	}
; 1259 : 	else

  022dd	eb 39		 jmp	 SHORT $L71974
$L71969:

; 1260 : 	{
; 1261 : 		if (pDph_t->nphone > 1)

  022df	66 3d 01 00	 cmp	 ax, 1
  022e3	7e 12		 jle	 SHORT $L71975

; 1262 : 			*psStruclm2 = pDph_t->allofeats[pDph_t->nphone - 2];

  022e5	8b 54 24 38	 mov	 edx, DWORD PTR _psStruclm2$[esp+12]
  022e9	0f bf c0	 movsx	 eax, ax
  022ec	66 8b 8c 86 2c
	06 00 00	 mov	 cx, WORD PTR [esi+eax*4+1580]
  022f4	66 89 0a	 mov	 WORD PTR [edx], cx
$L71975:

; 1263 : 		*psPholas = pDphsettar->phcur;

  022f7	8b 4c 24 28	 mov	 ecx, DWORD PTR _psPholas$[esp+12]
  022fb	66 8b 47 18	 mov	 ax, WORD PTR [edi+24]
  022ff	66 89 01	 mov	 WORD PTR [ecx], ax

; 1264 : 		*psStruclas = pDph_t->allofeats[pDph_t->nphone - 1];

  02302	8b 4c 24 3c	 mov	 ecx, DWORD PTR _psStruclas$[esp+12]
  02306	0f bf 96 a4 23
	00 00		 movsx	 edx, WORD PTR [esi+9124]
  0230d	66 8b 84 96 30
	06 00 00	 mov	 ax, WORD PTR [esi+edx*4+1584]
  02315	66 89 01	 mov	 WORD PTR [ecx], ax
$L71974:

; 1265 : 	}
; 1266 : 	/* Begin normal initialization of variables for new phoneme */
; 1267 : 
; 1268 : 	pDphsettar->phcur = pDph_t->allophons[pDph_t->nphone];

  02318	0f bf 96 a4 23
	00 00		 movsx	 edx, WORD PTR [esi+9124]
  0231f	66 8b 84 56 c6
	03 00 00	 mov	 ax, WORD PTR [esi+edx*2+966]
  02327	66 89 47 18	 mov	 WORD PTR [edi+24], ax

; 1269 : 	*psStruccur = pDph_t->allofeats[pDph_t->nphone];

  0232b	8b 44 24 40	 mov	 eax, DWORD PTR _psStruccur$[esp+12]
  0232f	0f bf 8e a4 23
	00 00		 movsx	 ecx, WORD PTR [esi+9124]
  02336	66 8b 94 8e 34
	06 00 00	 mov	 dx, WORD PTR [esi+ecx*4+1588]
  0233e	66 89 10	 mov	 WORD PTR [eax], dx

; 1270 : 
; 1271 : 	if (pDph_t->nphone < (pDph_t->nallotot - 1))

  02341	0f bf 8e e2 14
	00 00		 movsx	 ecx, WORD PTR [esi+5346]
  02348	0f bf 86 a4 23
	00 00		 movsx	 eax, WORD PTR [esi+9124]
  0234f	49		 dec	 ecx
  02350	3b c1		 cmp	 eax, ecx
  02352	7d 24		 jge	 SHORT $L71976

; 1272 : 	{
; 1273 : 		pDphsettar->phonex = pDph_t->allophons[pDph_t->nphone + 1];

  02354	66 8b 94 46 c8
	03 00 00	 mov	 dx, WORD PTR [esi+eax*2+968]
  0235c	66 89 57 0a	 mov	 WORD PTR [edi+10], dx

; 1274 : 		*psStrucnex = pDph_t->allofeats[pDph_t->nphone + 1];

  02360	8b 54 24 44	 mov	 edx, DWORD PTR _psStrucnex$[esp+12]
  02364	0f bf 86 a4 23
	00 00		 movsx	 eax, WORD PTR [esi+9124]
  0236b	66 8b 8c 86 38
	06 00 00	 mov	 cx, WORD PTR [esi+eax*4+1592]
  02373	66 89 0a	 mov	 WORD PTR [edx], cx

; 1275 : 	}
; 1276 : 	else

  02376	eb 0f		 jmp	 SHORT $L71977
$L71976:

; 1277 : 	{
; 1278 : 		pDphsettar->phonex = SIL;
; 1279 : 		*psStrucnex = 0;

  02378	8b 44 24 44	 mov	 eax, DWORD PTR _psStrucnex$[esp+12]
  0237c	66 c7 47 0a 00
	00		 mov	 WORD PTR [edi+10], 0
  02382	66 c7 00 00 00	 mov	 WORD PTR [eax], 0
$L71977:

; 1280 : 	}
; 1281 : 	/* MVP:The below if..else is invalid as the value of phonp2 is never used */
; 1282 : 	/* Hence, the code is commented out(#ifdef IF_ED_OUT_CODE ) */
; 1283 :    /* back in, phonp2 is used in german */
; 1284 :    if (pDph_t->nphone < (pDph_t->nallotot - 2))

  02387	0f bf 8e e2 14
	00 00		 movsx	 ecx, WORD PTR [esi+5346]
  0238e	0f bf 86 a4 23
	00 00		 movsx	 eax, WORD PTR [esi+9124]
  02395	83 e9 02	 sub	 ecx, 2
  02398	3b c1		 cmp	 eax, ecx
  0239a	7d 11		 jge	 SHORT $L71978

; 1285 :    {
; 1286 :       *psPhonp2 = pDph_t->allophons[pDph_t->nphone + 2];

  0239c	66 8b 94 46 ca
	03 00 00	 mov	 dx, WORD PTR [esi+eax*2+970]
  023a4	8b 44 24 4c	 mov	 eax, DWORD PTR _psPhonp2$[esp+12]
  023a8	66 89 10	 mov	 WORD PTR [eax], dx

; 1287 :    }
; 1288 :    else

  023ab	eb 09		 jmp	 SHORT $L71979
$L71978:

; 1289 :    {
; 1290 :       *psPhonp2 = SIL;

  023ad	8b 4c 24 4c	 mov	 ecx, DWORD PTR _psPhonp2$[esp+12]
  023b1	66 c7 01 00 00	 mov	 WORD PTR [ecx], 0
$L71979:

; 1291 :    }
; 1292 : 
; 1293 : 	*ppsNdips = &(pDph_t->dipspec[1]); /* Initialize pointer to diph info for phone */

  023b6	8b 44 24 48	 mov	 eax, DWORD PTR _ppsNdips$[esp+12]

; 1294 : 
; 1295 : 	/* Precompute often-used variables */
; 1296 : 
; 1297 : 	*psFealas = featb[*psPholas];

  023ba	8b 4c 24 28	 mov	 ecx, DWORD PTR _psPholas$[esp+12]
  023be	8d 96 4a 23 00
	00		 lea	 edx, DWORD PTR [esi+9034]

; 1298 : 	*psFeacur = featb[pDphsettar->phcur];

  023c4	8b 5c 24 30	 mov	 ebx, DWORD PTR _psFeacur$[esp+12]
  023c8	89 10		 mov	 DWORD PTR [eax], edx
  023ca	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  023cd	8b 4c 24 2c	 mov	 ecx, DWORD PTR _psFealas$[esp+12]
  023d1	66 8b 04 55 00
	00 00 00	 mov	 ax, WORD PTR _featb[edx*2]
  023d9	66 89 01	 mov	 WORD PTR [ecx], ax
  023dc	0f bf 57 18	 movsx	 edx, WORD PTR [edi+24]
  023e0	66 8b 04 55 00
	00 00 00	 mov	 ax, WORD PTR _featb[edx*2]
  023e8	66 89 03	 mov	 WORD PTR [ebx], ax

; 1299 : 	*psFeanex = featb[pDphsettar->phonex];

  023eb	8b 44 24 34	 mov	 eax, DWORD PTR _psFeanex$[esp+12]
  023ef	0f bf 4f 0a	 movsx	 ecx, WORD PTR [edi+10]
  023f3	66 8b 14 4d 00
	00 00 00	 mov	 dx, WORD PTR _featb[ecx*2]
  023fb	66 89 10	 mov	 WORD PTR [eax], dx

; 1300 : 
; 1301 : 	*psInhdr_frames = mstofr (inhdr[pDphsettar->phcur]);    /* Inherent dur in frames */

  023fe	0f bf 4f 18	 movsx	 ecx, WORD PTR [edi+24]
  02402	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR _inhdr[ecx*2]
  0240a	52		 push	 edx
  0240b	e8 00 00 00 00	 call	 _mstofr
  02410	8b 6c 24 1c	 mov	 ebp, DWORD PTR _psInhdr_frames$[esp+16]
  02414	83 c4 04	 add	 esp, 4
  02417	66 89 45 00	 mov	 WORD PTR [ebp], ax

; 1302 : 
; 1303 : 	/* Transition durs are shorter if phone dur is short rel to inherent dur */
; 1304 : 	/* Compute change in duration rel. to inherent dur if a sonorant */
; 1305 : 	if (((*psFeacur & FOBST) IS_MINUS) && (pDphsettar->phcur != SIL))

  0241b	8a 0b		 mov	 cl, BYTE PTR [ebx]
  0241d	f6 c1 20	 test	 cl, 32			; 00000020H
  02420	75 74		 jne	 SHORT $L72097
  02422	33 db		 xor	 ebx, ebx
  02424	66 39 5f 18	 cmp	 WORD PTR [edi+24], bx
  02428	74 6e		 je	 SHORT $L71980

; 1306 : 	{
; 1307 : 		/* Shrink,shrif,shrib only apply to sonorants */
; 1308 : 		if (pDph_t->durfon < (*psInhdr_frames << 1))

  0242a	66 8b 8e e0 14
	00 00		 mov	 cx, WORD PTR [esi+5344]
  02431	0f bf c0	 movsx	 eax, ax
  02434	0f bf d1	 movsx	 edx, cx
  02437	d1 e0		 shl	 eax, 1
  02439	3b d0		 cmp	 edx, eax
  0243b	7d 2f		 jge	 SHORT $L71981

; 1309 : 		{                                                          /* durfon can't exceed 2*inhd */
; 1310 : 			pDph_t->arg1 = FRAC_ONE;

  0243d	66 c7 86 f8 14
	00 00 00 40	 mov	 WORD PTR [esi+5368], 16384 ; 00004000H

; 1311 : 			pDph_t->arg2 = pDph_t->durfon;

  02446	66 89 8e fa 14
	00 00		 mov	 WORD PTR [esi+5370], cx

; 1312 : 			pDph_t->arg3 = *psInhdr_frames;

  0244d	66 8b 4d 00	 mov	 cx, WORD PTR [ebp]

; 1313 : 			*psShrink = muldv (pDph_t->arg1, pDph_t->arg2, pDph_t->arg3);   /* = FRAC_ONE, i.e. 16384 if no */

  02451	8b c2		 mov	 eax, edx
  02453	66 89 8e fc 14
	00 00		 mov	 WORD PTR [esi+5372], cx
  0245a	c1 e0 0e	 shl	 eax, 14			; 0000000eH
  0245d	0f bf c9	 movsx	 ecx, cx
  02460	99		 cdq
  02461	f7 f9		 idiv	 ecx
  02463	8b 4c 24 1c	 mov	 ecx, DWORD PTR _psShrink$[esp+12]
  02467	66 89 01	 mov	 WORD PTR [ecx], ax

; 1314 : 		}
; 1315 : 		else

  0246a	eb 09		 jmp	 SHORT $L71982
$L71981:

; 1316 : 		{
; 1317 : 			*psShrink = FRAC_ONE + (FRAC_ONE - 1);  /* IS THIS AN ERROR ??? */

  0246c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _psShrink$[esp+12]
  02470	66 c7 01 ff 7f	 mov	 WORD PTR [ecx], 32767	; 00007fffH
$L71982:

; 1318 : 		}
; 1319 : 		/* Shrinkage factor for formant transitions inside sonorants */
; 1320 : 		*psShrif = (*psShrink >> 1) + FRAC_HALF;

  02475	66 8b 11	 mov	 dx, WORD PTR [ecx]
  02478	8b 4c 24 20	 mov	 ecx, DWORD PTR _psShrif$[esp+12]
  0247c	66 d1 fa	 sar	 dx, 1
  0247f	8d 82 00 20 00
	00		 lea	 eax, DWORD PTR [edx+8192]

; 1321 : 		/* Ditto for backward transition, which is slightly (15%) faster */
; 1322 : 		*psShrib = *psShrif - 1600;

  02485	8b 54 24 24	 mov	 edx, DWORD PTR _psShrib$[esp+12]
  02489	66 89 01	 mov	 WORD PTR [ecx], ax
  0248c	05 c0 f9 ff ff	 add	 eax, -1600		; fffff9c0H
  02491	66 89 02	 mov	 WORD PTR [edx], ax
  02494	eb 02		 jmp	 SHORT $L71980
$L72097:
  02496	33 db		 xor	 ebx, ebx
$L71980:

; 1323 : 	}
; 1324 : 	PAV.tspesh = 0;                                    /* Default case: set 'end time' of special  */

  02498	66 89 9e 32 01
	00 00		 mov	 WORD PTR [esi+306], bx

; 1325 : 	PAP.tspesh = 0;                                    /* constant override of computed parameter */

  0249f	66 89 9e 56 01
	00 00		 mov	 WORD PTR [esi+342], bx

; 1326 : 	PF1.tspesh = 0;

  024a6	66 89 5e 36	 mov	 WORD PTR [esi+54], bx

; 1327 : 	PB1.tspesh = 0;                                    /* value to zero, i.e. no special override */

  024aa	66 89 9e c6 00
	00 00		 mov	 WORD PTR [esi+198], bx

; 1328 : 	PB2.tspesh = 0;                                    /* for this phone.                          */

  024b1	66 89 9e ea 00
	00 00		 mov	 WORD PTR [esi+234], bx

; 1329 : 	PB3.tspesh = 0;

  024b8	66 89 9e 0e 01
	00 00		 mov	 WORD PTR [esi+270], bx

; 1330 : 	PA2.tspesh = 0;

  024bf	66 89 9e 7a 01
	00 00		 mov	 WORD PTR [esi+378], bx

; 1331 : 	PA3.tspesh = 0;                                    /* If rules below set to non-zero, substitute */

  024c6	66 89 9e 9e 01
	00 00		 mov	 WORD PTR [esi+414], bx

; 1332 : 	PA4.tspesh = 0;                                    /* pspesh for computed value over time       */

  024cd	66 89 9e c2 01
	00 00		 mov	 WORD PTR [esi+450], bx

; 1333 : 	PA5.tspesh = 0;                                    /* interval from beginning of phone (done   */

  024d4	66 89 9e e6 01
	00 00		 mov	 WORD PTR [esi+486], bx

; 1334 : 	PA6.tspesh = 0;                                    /* in PH_DRAW.C                      */

  024db	66 89 9e 0a 02
	00 00		 mov	 WORD PTR [esi+522], bx

; 1335 : 	PAB.tspesh = 0;

  024e2	66 89 9e 2e 02
	00 00		 mov	 WORD PTR [esi+558], bx

; 1336 : 	PTILT.tspesh = 0;

  024e9	66 89 9e 52 02
	00 00		 mov	 WORD PTR [esi+594], bx
  024f0	5f		 pop	 edi
  024f1	5e		 pop	 esi
  024f2	5d		 pop	 ebp
  024f3	5b		 pop	 ebx

; 1337 : 
; 1338 : }

  024f4	c3		 ret	 0
_init_variables ENDP
_TEXT	ENDS
END
