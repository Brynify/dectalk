	TITLE	D:\work\product\dapi\src\Lts\lsa_task.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_verbs
_DATA	SEGMENT
_verbs	DB	'are', 00H
	ORG $+1
	ORG $+3
	DD	066H
	DD	06H
	DD	01aH
	DD	00H
	DD	00H
	DD	0820020H
	DB	'had', 00H
	ORG $+1
	ORG $+3
	DD	01cH
	DD	066H
	DD	04H
	DD	030H
	DD	00H
	DD	0820100H
	DB	'is', 00H
	ORG $+2
	ORG $+3
	DD	066H
	DD	02H
	DD	02aH
	DD	00H
	DD	00H
	DD	0820020H
	DB	'was', 00H
	ORG $+1
	ORG $+3
	DD	018H
	DD	066H
	DD	011H
	DD	02aH
	DD	00H
	DD	0820020H
	DB	'were', 00H
	ORG $+3
	DD	018H
	DD	066H
	DD	0fH
	DD	00H
	DD	00H
	DD	0820020H
	DB	'will', 00H
	ORG $+3
	DD	018H
	DD	066H
	DD	02H
	DD	01eH
	DD	00H
	DD	0820408H
_DATA	ENDS
PUBLIC	_ls_task_main
PUBLIC	_ls_task_readword
PUBLIC	_ls_task_do_right_punct
PUBLIC	_ls_task_spell_word
PUBLIC	_ls_task_read_next_word
PUBLIC	_ls_task_set_what_state
PUBLIC	_ls_task_find_end_of_word
PUBLIC	_ls_task_spell_mode
PUBLIC	_ls_task_minidic_search
PUBLIC	_ls_task_math_mode
PUBLIC	_ls_task_dictionary_search
PUBLIC	_ls_task_strip_left_punctuation
PUBLIC	_ls_task_strip_right_punctuation
PUBLIC	_ls_task_spell_all_punct
PUBLIC	_ls_task_dictionary_after_punct
PUBLIC	_ls_task_spell_vs_speak
PUBLIC	_ls_task_single_letter_spell_rules
PUBLIC	_ls_task_remove_case
PUBLIC	_ls_task_Dr_St_process
PUBLIC	_ls_task_set_sign_flag
PUBLIC	_ls_task_currency_processing
PUBLIC	_ls_task_date_processing
PUBLIC	_ls_task_frac_processing
PUBLIC	_ls_task_plain_number_processing
PUBLIC	_ls_task_part_number
PUBLIC	_ls_task_process_word
EXTRN	_ls_util_is_name:NEAR
EXTRN	_ls_rule_phone_free:NEAR
EXTRN	__chkstk:NEAR
EXTRN	_ls_util_read_item:NEAR
EXTRN	__imp__printf:NEAR
EXTRN	_ls_util_dump_cword:NEAR
_DATA	SEGMENT
$SG72266 DB	'LTS debug switch description:', 0aH, 00H
	ORG $+1
$SG72267 DB	'4001 -- Incoming data string  4002 -- Dictionary HIT/MIS'
	DB	'S (0) for miss', 0aH, 00H
$SG72268 DB	'4004 -- Suffix stripping HIT  4008 -- Display MISS word,'
	DB	' not speaking', 0aH, 00H
	ORG $+1
$SG72269 DB	'4010 -- Dict. search trace    4020 -- Homograph rule HIT'
	DB	0aH, 00H
	ORG $+2
$SG72270 DB	'4040 -- Form class array dump 4080 -- ACNA name type', 0aH
	DB	00H
	ORG $+2
$SG72271 DB	'4100 -- log form class        4200 -- dump data before w'
	DB	'rite_pipe', 0aH, 00H
	ORG $+1
$SG72272 DB	'4400 -- Spell it rule HIT     4800 -- drain data before '
	DB	'write_pipe', 0aH, 00H
$SG72274 DB	'LTS Input:', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = -5656
_rlp$ = -5660
_elp$ = -5636
_lp1$ = -5644
_pKsd_t$ = -5640
_pLts_t$ = -5648
_pnode$ = -4608
_origword$ = -5632
_namef$ = -5652
_ls_task_main PROC NEAR

; 221  : {

  00000	b8 1c 16 00 00	 mov	 eax, 5660		; 0000161cH
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	53		 push	 ebx

; 222  : 	/* of special words.*/ 
; 223  : 	int     done, array_i=0;
; 224  : 	LETTER  *llp;
; 225  : 	LETTER  *rlp;
; 226  : 	LETTER  *elp;
; 227  : 	LETTER  *lp1;
; 228  : 	PHONE   *pp; 
; 229  : 	PKSD_T  pKsd_t;
; 230  : 	PLTS_T  pLts_t;
; 231  : 	PHONE   pnode[NPNODE];                  /* Phoneme pool.                */
; 232  : 	/* MGS 6/16/97 BATS #387 Added to allow case to reach ls_task_process_word */
; 233  : 	LETTER	origword[NGWORD];	
; 234  : 	
; 235  : 	int namef=0; 							/* this flag seems useless */ 
; 236  : 	
; 237  : 	/* printf("this is the start of lts\n"); */
; 238  : 	
; 239  : 		
; 240  : 	pKsd_t = phTTS->pKernelShareData;

  0000b	8b 9c 24 24 16
	00 00		 mov	 ebx, DWORD PTR _phTTS$[esp+5660]
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00017	57		 push	 edi

; 241  : 	pLts_t = phTTS->pLTSThreadData;	

  00018	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  0001b	33 f6		 xor	 esi, esi

; 242  : 	pLts_t->isnumabr=0;
; 243  : 
; 244  :     pLts_t->pflp = 0;   
; 245  : #ifdef MSDOS
; 246  : 	pKsd_t->lang_curr = LANG_none; 
; 247  : #endif
; 248  : #ifdef SPANISH
; 249  :     pLts_t->got_quote = 0;
; 250  : #endif  
; 251  :     memset(&(pLts_t->nitem),0,sizeof(ITEM));

  0001d	33 c9		 xor	 ecx, ecx
  0001f	89 44 24 24	 mov	 DWORD PTR _pKsd_t$[esp+5676], eax
  00023	8d 97 0a 09 00
	00		 lea	 edx, DWORD PTR [edi+2314]
  00029	89 b7 fc 08 00
	00		 mov	 DWORD PTR [edi+2300], esi
  0002f	89 b7 04 04 00
	00		 mov	 DWORD PTR [edi+1028], esi

; 252  :     memset(&(pLts_t->citem),0,sizeof(ITEM));

  00035	33 c0		 xor	 eax, eax
  00037	89 0a		 mov	 DWORD PTR [edx], ecx
  00039	89 74 24 18	 mov	 DWORD PTR _namef$[esp+5676], esi
  0003d	89 7c 24 1c	 mov	 DWORD PTR _pLts_t$[esp+5676], edi

; 253  : 	
; 254  : 	pp = &pnode[0];                         		/* Pool of PHONE nodes. */

  00041	8d ac 24 2c 04
	00 00		 lea	 ebp, DWORD PTR _pnode$[esp+5676]
  00048	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0004b	66 89 4a 08	 mov	 WORD PTR [edx+8], cx
  0004f	8d 8f 00 09 00
	00		 lea	 ecx, DWORD PTR [edi+2304]
  00055	89 87 00 09 00
	00		 mov	 DWORD PTR [edi+2304], eax
  0005b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0005e	66 89 41 08	 mov	 WORD PTR [ecx+8], ax
$L72260:

; 255  : 	
; 256  : 	while (pp < &pnode[NPNODE])         			/* free all the phonemes */
; 257  : 	{
; 258  : 		ls_rule_phone_free(pLts_t,pp);

  00062	55		 push	 ebp
  00063	57		 push	 edi
  00064	e8 00 00 00 00	 call	 _ls_rule_phone_free

; 259  : 		++pp;

  00069	83 c5 24	 add	 ebp, 36			; 00000024H
  0006c	8d 94 24 34 16
	00 00		 lea	 edx, DWORD PTR _pnode$[esp+10292]
  00073	83 c4 08	 add	 esp, 8
  00076	3b ea		 cmp	 ebp, edx
  00078	72 e8		 jb	 SHORT $L72260

; 260  : 	}
; 261  : 	
; 262  : 	pLts_t->wstate = UNK_WH;                        /* Start of sentence.   */
; 263  : 	pLts_t->lphone = WBOUND;                        /* Out of band.         */
; 264  : 	ls_util_read_item(phTTS);	

  0007a	53		 push	 ebx
  0007b	66 89 b7 c4 08
	00 00		 mov	 WORD PTR [edi+2244], si
  00082	66 c7 87 36 04
	00 00 6f 00	 mov	 WORD PTR [edi+1078], 111 ; 0000006fH
  0008b	e8 00 00 00 00	 call	 _ls_util_read_item

; 265  : 	ls_task_readword(phTTS,&(pLts_t->cword[0]));	

  00090	8d 87 14 09 00
	00		 lea	 eax, DWORD PTR [edi+2324]
  00096	50		 push	 eax
  00097	53		 push	 ebx
  00098	e8 00 00 00 00	 call	 _ls_task_readword

; 338  : 			{
; 339  : 				namef=0;
; 340  : 				/*clear pron name even if we did it with the dic*/
; 341  : 				pKsd_t->pronflag &= (~PRON_ACNA_NAME);

  0009d	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__printf
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a6	89 b7 bc 08 00
	00		 mov	 DWORD PTR [edi+2236], esi
  000ac	c7 87 c0 08 00
	00 ff ff ff ff	 mov	 DWORD PTR [edi+2240], -1
$L72263:
  000b6	8b 74 24 24	 mov	 esi, DWORD PTR _pKsd_t$[esp+5676]
  000ba	66 81 be 78 04
	00 00 ff 4f	 cmp	 WORD PTR [esi+1144], 20479 ; 00004fffH
  000c3	75 3d		 jne	 SHORT $L72265
  000c5	68 00 00 00 00	 push	 OFFSET FLAT:$SG72266
  000ca	ff d5		 call	 ebp
  000cc	68 00 00 00 00	 push	 OFFSET FLAT:$SG72267
  000d1	ff d5		 call	 ebp
  000d3	68 00 00 00 00	 push	 OFFSET FLAT:$SG72268
  000d8	ff d5		 call	 ebp
  000da	68 00 00 00 00	 push	 OFFSET FLAT:$SG72269
  000df	ff d5		 call	 ebp
  000e1	68 00 00 00 00	 push	 OFFSET FLAT:$SG72270
  000e6	ff d5		 call	 ebp
  000e8	68 00 00 00 00	 push	 OFFSET FLAT:$SG72271
  000ed	ff d5		 call	 ebp
  000ef	68 00 00 00 00	 push	 OFFSET FLAT:$SG72272
  000f4	ff d5		 call	 ebp
  000f6	83 c4 1c	 add	 esp, 28			; 0000001cH
  000f9	66 c7 86 78 04
	00 00 00 00	 mov	 WORD PTR [esi+1144], 0
$L72265:
  00102	66 8b 86 78 04
	00 00		 mov	 ax, WORD PTR [esi+1144]
  00109	f6 c4 40	 test	 ah, 64			; 00000040H
  0010c	74 18		 je	 SHORT $L72273

; 266  : 	pLts_t->fc_index = 0;
; 267  : 	pLts_t->old_fc_index = -1;
; 268  : 	/*
; 269  : 	 * Top of the word processing main loop.
; 270  : 	 * Called with a word in "cword" and the delimiter in
; 271  : 	 * "pLts_t->citem". Look at the word, and update the "which" state
; 272  : 	 * if this is the first word in a sentence. Allow the
; 273  : 	 * "W" to be in either case. Don't get fooled by
; 274  : 	 * strippable punctuation.
; 275  : 	 */
; 276  : 
; 277  : 	while (1)
; 278  : 	{
; 279  : 
; 280  : 		/* ET 6/9/1998: BATS #691
; 281  : 		copied from ...\dapi\src\CMD\cm_pars.c to get the debug win to come up */
; 282  : #if defined (WIN32) && defined (PRINTFDEBUG)
; 283  : 		/* open debug window for window environement */
; 284  : 		if (/*(windbg_flag == 0) && ET 6/9/1998*/(pKsd_t->debug_switch != 0 || pKsd_t->logflag != 0))
; 285  : 		{
; 286  : 			WINstart_thread();
; 287  : 		/*	windbg_flag = 1;	ET 6/9/1998: not defined in ls_task. */ 
; 288  : 		}
; 289  : #endif
; 290  : 
; 291  : 		/* display debug switch manual once */
; 292  : 		if (pKsd_t->debug_switch == 0x4fff)
; 293  : 		{
; 294  : 			printf("LTS debug switch description:\n");
; 295  : 			printf("4001 -- Incoming data string  4002 -- Dictionary HIT/MISS (0) for miss\n");
; 296  : 			printf("4004 -- Suffix stripping HIT  4008 -- Display MISS word, not speaking\n");
; 297  : 			printf("4010 -- Dict. search trace    4020 -- Homograph rule HIT\n");
; 298  : 			printf("4040 -- Form class array dump 4080 -- ACNA name type\n");
; 299  : 			printf("4100 -- log form class        4200 -- dump data before write_pipe\n");
; 300  : 			printf("4400 -- Spell it rule HIT     4800 -- drain data before write_pipe\n");
; 301  : 						
; 302  : 			/* reset to 0 again */
; 303  : 			pKsd_t->debug_switch = 0;
; 304  : 		}
; 305  : 	
; 306  : 		/* debug switch */
; 307  : 		if (DT_DBG(LTS_DBG,0x001))

  0010e	a8 01		 test	 al, 1
  00110	74 14		 je	 SHORT $L72273

; 308  : 		{
; 309  : 			ls_util_dump_cword (pLts_t->cword, "LTS Input:");

  00112	8d 87 14 09 00
	00		 lea	 eax, DWORD PTR [edi+2324]
  00118	68 00 00 00 00	 push	 OFFSET FLAT:$SG72274
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 _ls_util_dump_cword
  00123	83 c4 08	 add	 esp, 8
$L72273:

; 310  : 		}
; 311  : #ifdef DUMP_WORD
; 312  : 		ls_util_dump_cword (pLts_t->cword, "ltsinput:");
; 313  : #endif
; 314  : 		done=KEEP_SEARCHING;
; 315  : 		/* 
; 316  : 		 *...tek block here to make sure PH has something to do and that
; 317  : 		 *	we don't hog the CPU.. 
; 318  : 		 */
; 319  : #ifdef MSDOS
; 320  : 		block(NULL_FP);
; 321  : #endif    
; 322  : 		/* 
; 323  : 		 * xxxx eab WE added code to allow for double abreviations such as
; 324  : 		 *	4 sq. ft. but we need to block these abbreviations in normal
; 325  : 		 *	contexts so things like in and ha don't come out as hectors
; 326  : 		 *	and inches. so The 2nd abrreviation checker (nabtab)
; 327  : 		 *	is blocked unless the first time after a look ahead from
; 328  : 		 *	a number hit in the first case using the pLts_t->isnumabr being
; 329  : 		 *	set
; 330  : 		 */
; 331  : 
; 332  : 		if(pLts_t->isnumabr)

  00126	8b 87 fc 08 00
	00		 mov	 eax, DWORD PTR [edi+2300]
  0012c	33 c9		 xor	 ecx, ecx
  0012e	3b c1		 cmp	 eax, ecx
  00130	74 07		 je	 SHORT $L72275

; 333  : 			pLts_t->isnumabr--;

  00132	48		 dec	 eax
  00133	89 87 fc 08 00
	00		 mov	 DWORD PTR [edi+2300], eax
$L72275:

; 334  : 
; 335  : 		if( (pKsd_t->pronflag & PRON_ACNA_NAME) !=0)

  00139	8b 86 0c 02 00
	00		 mov	 eax, DWORD PTR [esi+524]
  0013f	a8 04		 test	 al, 4
  00141	74 1b		 je	 SHORT $L72276

; 336  : 		{
; 337  : 			if(namef == 1)

  00143	83 7c 24 18 01	 cmp	 DWORD PTR _namef$[esp+5676], 1
  00148	75 0e		 jne	 SHORT $L72277

; 338  : 			{
; 339  : 				namef=0;
; 340  : 				/*clear pron name even if we did it with the dic*/
; 341  : 				pKsd_t->pronflag &= (~PRON_ACNA_NAME);

  0014a	24 fb		 and	 al, -5			; fffffffbH
  0014c	89 4c 24 18	 mov	 DWORD PTR _namef$[esp+5676], ecx
  00150	89 86 0c 02 00
	00		 mov	 DWORD PTR [esi+524], eax

; 342  : 			}
; 343  : 			else

  00156	eb 0a		 jmp	 SHORT $L72279
$L72277:

; 344  : 			{
; 345  : 				namef++;

  00158	ff 44 24 18	 inc	 DWORD PTR _namef$[esp+5676]

; 346  : 			}
; 347  : 		}
; 348  : 		else

  0015c	eb 04		 jmp	 SHORT $L72279
$L72276:

; 349  : 		{
; 350  : 			namef=0;

  0015e	89 4c 24 18	 mov	 DWORD PTR _namef$[esp+5676], ecx
$L72279:

; 351  : 		}
; 352  : 	
; 353  : 		/* find out if one of the what words are at the beginning of the clause */
; 354  : 		done=ls_task_set_what_state(phTTS,pLts_t);

  00162	57		 push	 edi
  00163	53		 push	 ebx
  00164	e8 00 00 00 00	 call	 _ls_task_set_what_state
  00169	83 c4 08	 add	 esp, 8

; 355  : 
; 356  : 		if (!done)

  0016c	85 c0		 test	 eax, eax
  0016e	0f 85 5e 02 00
	00		 jne	 $L72304

; 357  : 		{
; 358  : 			/* find the end of the word */
; 359  : 			llp = &(pLts_t->cword[0]);

  00174	8d b7 14 09 00
	00		 lea	 esi, DWORD PTR [edi+2324]

; 360  : 			ls_task_find_end_of_word(llp,&rlp,&elp);

  0017a	8d 4c 24 28	 lea	 ecx, DWORD PTR _elp$[esp+5676]
  0017e	8d 54 24 10	 lea	 edx, DWORD PTR _rlp$[esp+5676]
  00182	8b c6		 mov	 eax, esi
  00184	51		 push	 ecx
  00185	52		 push	 edx
  00186	50		 push	 eax
  00187	89 44 24 20	 mov	 DWORD PTR _llp$[esp+5688], eax
  0018b	e8 00 00 00 00	 call	 _ls_task_find_end_of_word

; 361  : #ifdef LS1DEBUG
; 362  : 			printf("after find end of word ");
; 363  : 			printf("left=%u  right=%u\n",llp,rlp);
; 364  : #endif
; 365  : 			/*
; 366  : 			 * Bow out quickly on null words.
; 367  : 			 * These happen when you type something like
; 368  : 			 * "[ax] there.". The schwa gets copied right into
; 369  : 			 * the output, and the current word is null.
; 370  : 			 */
; 371  : 			if (llp == rlp) 

  00190	8b 44 24 20	 mov	 eax, DWORD PTR _llp$[esp+5688]
  00194	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rlp$[esp+5688]
  00198	83 c4 0c	 add	 esp, 12			; 0000000cH
  0019b	3b c1		 cmp	 eax, ecx
  0019d	75 2c		 jne	 SHORT $L72985

; 372  : 			{
; 373  : 				ls_task_do_right_punct(phTTS,MISS);

  0019f	6a 00		 push	 0
  001a1	53		 push	 ebx
  001a2	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 374  : 				ls_task_readword(phTTS,&(pLts_t->cword[0]));

  001a7	56		 push	 esi
  001a8	53		 push	 ebx
  001a9	e8 00 00 00 00	 call	 _ls_task_readword

; 375  : 				// add 1 to isnumabr to restore the value from before the null word
; 376  : 				// another fix for 43 sq. ft. with multiple index marks
; 377  : 				if (pLts_t->isnumabr)

  001ae	8b 87 fc 08 00
	00		 mov	 eax, DWORD PTR [edi+2300]
  001b4	83 c4 10	 add	 esp, 16			; 00000010H
  001b7	85 c0		 test	 eax, eax
  001b9	0f 84 f7 fe ff
	ff		 je	 $L72263

; 378  : 				{
; 379  : 					pLts_t->isnumabr++;

  001bf	40		 inc	 eax
  001c0	89 87 fc 08 00
	00		 mov	 DWORD PTR [edi+2300], eax

; 380  : 				}
; 381  : 				continue;

  001c6	e9 eb fe ff ff	 jmp	 $L72263
$L72985:

; 382  : 			}
; 383  : 		}
; 384  : 		if (!done)
; 385  : 			done=ls_task_spell_mode(phTTS,llp,rlp);

  001cb	51		 push	 ecx
  001cc	50		 push	 eax
  001cd	53		 push	 ebx
  001ce	e8 00 00 00 00	 call	 _ls_task_spell_mode
  001d3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 386  : 		if (!done)

  001d6	85 c0		 test	 eax, eax
  001d8	0f 85 f4 01 00
	00		 jne	 $L72304

; 387  : 			done=ls_task_minidic_search(phTTS,llp,rlp); 

  001de	8b 44 24 10	 mov	 eax, DWORD PTR _rlp$[esp+5676]
  001e2	8b 4c 24 14	 mov	 ecx, DWORD PTR _llp$[esp+5676]
  001e6	50		 push	 eax
  001e7	51		 push	 ecx
  001e8	53		 push	 ebx
  001e9	e8 00 00 00 00	 call	 _ls_task_minidic_search
  001ee	83 c4 0c	 add	 esp, 12			; 0000000cH

; 388  : 		if (!done)

  001f1	85 c0		 test	 eax, eax
  001f3	0f 85 d9 01 00
	00		 jne	 $L72304

; 389  : 			done=ls_task_math_mode(pKsd_t,llp,rlp);

  001f9	8b 54 24 10	 mov	 edx, DWORD PTR _rlp$[esp+5676]
  001fd	8b 44 24 14	 mov	 eax, DWORD PTR _llp$[esp+5676]
  00201	8b 4c 24 24	 mov	 ecx, DWORD PTR _pKsd_t$[esp+5676]
  00205	52		 push	 edx
  00206	50		 push	 eax
  00207	51		 push	 ecx
  00208	e8 00 00 00 00	 call	 _ls_task_math_mode
  0020d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 390  : 		if (!done)

  00210	85 c0		 test	 eax, eax
  00212	0f 85 ba 01 00
	00		 jne	 $L72304

; 391  : 			done=ls_task_dictionary_search(phTTS,llp,rlp);

  00218	8b 54 24 10	 mov	 edx, DWORD PTR _rlp$[esp+5676]
  0021c	8b 44 24 14	 mov	 eax, DWORD PTR _llp$[esp+5676]
  00220	52		 push	 edx
  00221	50		 push	 eax
  00222	53		 push	 ebx
  00223	e8 00 00 00 00	 call	 _ls_task_dictionary_search
  00228	83 c4 0c	 add	 esp, 12			; 0000000cH

; 392  : 
; 393  : #if 0 //comment out for now breaks in Windows CE mfg 03/21/2000
; 394  : 		if (!done)
; 395  : 		{
; 396  : 		
; 397  : 			done=ls_task_dictionary_search(phTTS,llp,rlp);
; 398  : 			//eab 10/5/99 if we messed with prefix fix up pointers 
; 399  : 			if (done <0)
; 400  : 			{
; 401  : 				while(done <0)
; 402  : 				{
; 403  : 					rlp --;
; 404  : 					done++;
; 405  : 				}
; 406  : #ifdef _DEBUG 
; 407  : #ifndef UNDER_CE
; 408  : 			printf("hit it \n");
; 409  : #endif
; 410  : #endif
; 411  : 			//eab what if prefix-looks like another prefix imim should be ok
; 412  : 			done=ls_task_dictionary_search(phTTS,llp,rlp);
; 413  : 			}
; 414  : 			
; 415  : 		}
; 416  : #endif //
; 417  : 
; 418  : 		if (!done)

  0022b	85 c0		 test	 eax, eax
  0022d	0f 85 9f 01 00
	00		 jne	 $L72304

; 419  : 			ls_task_strip_left_punctuation(pLts_t,&llp,rlp);        

  00233	8b 4c 24 10	 mov	 ecx, DWORD PTR _rlp$[esp+5676]
  00237	8d 54 24 14	 lea	 edx, DWORD PTR _llp$[esp+5676]
  0023b	51		 push	 ecx
  0023c	52		 push	 edx
  0023d	57		 push	 edi
  0023e	e8 00 00 00 00	 call	 _ls_task_strip_left_punctuation

; 420  : 
; 421  : 		if (!done)
; 422  : 			ls_task_strip_right_punctuation(pLts_t,llp,&rlp);

  00243	8b 4c 24 20	 mov	 ecx, DWORD PTR _llp$[esp+5688]
  00247	8d 44 24 1c	 lea	 eax, DWORD PTR _rlp$[esp+5688]
  0024b	50		 push	 eax
  0024c	51		 push	 ecx
  0024d	57		 push	 edi
  0024e	e8 00 00 00 00	 call	 _ls_task_strip_right_punctuation

; 423  : 
; 424  : 		if (!done)
; 425  : 			done=ls_task_spell_all_punct(phTTS,llp,rlp,&(pLts_t->cword[0]),elp);

  00253	8b 54 24 40	 mov	 edx, DWORD PTR _elp$[esp+5700]
  00257	8b 44 24 28	 mov	 eax, DWORD PTR _rlp$[esp+5700]
  0025b	8b 4c 24 2c	 mov	 ecx, DWORD PTR _llp$[esp+5700]
  0025f	52		 push	 edx
  00260	56		 push	 esi
  00261	50		 push	 eax
  00262	51		 push	 ecx
  00263	53		 push	 ebx
  00264	e8 00 00 00 00	 call	 _ls_task_spell_all_punct
  00269	83 c4 2c	 add	 esp, 44			; 0000002cH

; 426  : 	
; 427  : 		if (!done)

  0026c	85 c0		 test	 eax, eax
  0026e	0f 85 5e 01 00
	00		 jne	 $L72304

; 428  : 			done=ls_task_dictionary_after_punct(phTTS,llp,&rlp);

  00274	8b 44 24 14	 mov	 eax, DWORD PTR _llp$[esp+5676]
  00278	8d 54 24 10	 lea	 edx, DWORD PTR _rlp$[esp+5676]
  0027c	52		 push	 edx
  0027d	50		 push	 eax
  0027e	53		 push	 ebx
  0027f	e8 00 00 00 00	 call	 _ls_task_dictionary_after_punct
  00284	83 c4 0c	 add	 esp, 12			; 0000000cH

; 429  : 
; 430  : 		if (!done)

  00287	85 c0		 test	 eax, eax
  00289	0f 85 43 01 00
	00		 jne	 $L72304

; 431  : 			done=ls_task_spell_vs_speak(phTTS,llp,rlp);

  0028f	8b 4c 24 10	 mov	 ecx, DWORD PTR _rlp$[esp+5676]
  00293	8b 54 24 14	 mov	 edx, DWORD PTR _llp$[esp+5676]
  00297	51		 push	 ecx
  00298	52		 push	 edx
  00299	53		 push	 ebx
  0029a	e8 00 00 00 00	 call	 _ls_task_spell_vs_speak
  0029f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 432  : 
; 433  : 		if (!done)

  002a2	85 c0		 test	 eax, eax
  002a4	0f 85 28 01 00
	00		 jne	 $L72304

; 434  : 			done=ls_task_single_letter_spell_rules(phTTS,llp,rlp);	           

  002aa	8b 44 24 10	 mov	 eax, DWORD PTR _rlp$[esp+5676]
  002ae	8b 4c 24 14	 mov	 ecx, DWORD PTR _llp$[esp+5676]
  002b2	50		 push	 eax
  002b3	51		 push	 ecx
  002b4	53		 push	 ebx
  002b5	e8 00 00 00 00	 call	 _ls_task_single_letter_spell_rules
  002ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 435  : 		/*
; 436  : 		 * We are getting ready to feed this
; 437  : 		 * thing to the default processing rules. The
; 438  : 		 * first step is to fold out case distinctions and
; 439  : 		 * diacritical marks. We used to rescan the dictionary
; 440  : 		 * if anything changed; we don't do it anymore because
; 441  : 		 * the dictionary lookup was made more clever, and
; 442  : 		 * understands case distinctions.
; 443  : 		 */
; 444  : 		if (!done)

  002bd	85 c0		 test	 eax, eax
  002bf	0f 85 0d 01 00
	00		 jne	 $L72304

; 445  : 			ls_util_is_name(phTTS,llp,rlp);

  002c5	8b 54 24 10	 mov	 edx, DWORD PTR _rlp$[esp+5676]
  002c9	8b 44 24 14	 mov	 eax, DWORD PTR _llp$[esp+5676]
  002cd	52		 push	 edx
  002ce	50		 push	 eax
  002cf	53		 push	 ebx
  002d0	e8 00 00 00 00	 call	 _ls_util_is_name

; 446  : 		/* MGS 6/16/97 BATS #387  added to keep oroginal word */
; 447  : 		if (!done)
; 448  : 			memcpy(&origword,&(pLts_t->cword),sizeof(origword));
; 449  : 		if (!done)
; 450  : 			ls_task_remove_case(llp,rlp);

  002d5	8b 54 24 20	 mov	 edx, DWORD PTR _llp$[esp+5688]
  002d9	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  002de	8d 7c 24 38	 lea	 edi, DWORD PTR _origword$[esp+5688]
  002e2	f3 a5		 rep movsd
  002e4	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rlp$[esp+5688]
  002e8	51		 push	 ecx
  002e9	52		 push	 edx
  002ea	e8 00 00 00 00	 call	 _ls_task_remove_case

; 451  : 
; 452  : #ifdef ENGLISH
; 453  : 		if (!done)
; 454  :             done=ls_task_Dr_St_process(phTTS,llp,rlp);

  002ef	8b 44 24 24	 mov	 eax, DWORD PTR _rlp$[esp+5696]
  002f3	8b 4c 24 28	 mov	 ecx, DWORD PTR _llp$[esp+5696]
  002f7	50		 push	 eax
  002f8	51		 push	 ecx
  002f9	53		 push	 ebx
  002fa	e8 00 00 00 00	 call	 _ls_task_Dr_St_process
  002ff	83 c4 20	 add	 esp, 32			; 00000020H

; 455  : #endif
; 456  : 		if (!done)

  00302	85 c0		 test	 eax, eax
  00304	0f 85 c4 00 00
	00		 jne	 $L72992

; 457  : 			done=ls_task_set_sign_flag(phTTS,llp,rlp,&lp1);

  0030a	8b 44 24 10	 mov	 eax, DWORD PTR _rlp$[esp+5676]
  0030e	8b 4c 24 14	 mov	 ecx, DWORD PTR _llp$[esp+5676]
  00312	8d 54 24 20	 lea	 edx, DWORD PTR _lp1$[esp+5676]
  00316	52		 push	 edx
  00317	50		 push	 eax
  00318	51		 push	 ecx
  00319	53		 push	 ebx
  0031a	e8 00 00 00 00	 call	 _ls_task_set_sign_flag
  0031f	83 c4 10	 add	 esp, 16			; 00000010H

; 458  : 
; 459  : 		if (!done)

  00322	85 c0		 test	 eax, eax
  00324	0f 85 a4 00 00
	00		 jne	 $L72992

; 460  : 			done=ls_task_currency_processing(phTTS,lp1,rlp);

  0032a	8b 54 24 10	 mov	 edx, DWORD PTR _rlp$[esp+5676]
  0032e	8b 44 24 20	 mov	 eax, DWORD PTR _lp1$[esp+5676]
  00332	52		 push	 edx
  00333	50		 push	 eax
  00334	53		 push	 ebx
  00335	e8 00 00 00 00	 call	 _ls_task_currency_processing
  0033a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 461  : 
; 462  : 		if (!done)

  0033d	85 c0		 test	 eax, eax
  0033f	0f 85 89 00 00
	00		 jne	 $L72992

; 463  : 			done=ls_task_date_processing(phTTS,llp,rlp);

  00345	8b 4c 24 10	 mov	 ecx, DWORD PTR _rlp$[esp+5676]
  00349	8b 54 24 14	 mov	 edx, DWORD PTR _llp$[esp+5676]
  0034d	51		 push	 ecx
  0034e	52		 push	 edx
  0034f	53		 push	 ebx
  00350	e8 00 00 00 00	 call	 _ls_task_date_processing
  00355	83 c4 0c	 add	 esp, 12			; 0000000cH

; 464  : 
; 465  : 		if (!done)

  00358	85 c0		 test	 eax, eax
  0035a	75 72		 jne	 SHORT $L72992

; 466  : 			done=ls_task_frac_processing(phTTS,lp1,rlp);

  0035c	8b 44 24 10	 mov	 eax, DWORD PTR _rlp$[esp+5676]
  00360	8b 4c 24 20	 mov	 ecx, DWORD PTR _lp1$[esp+5676]
  00364	50		 push	 eax
  00365	51		 push	 ecx
  00366	53		 push	 ebx
  00367	e8 00 00 00 00	 call	 _ls_task_frac_processing
  0036c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 467  : 
; 468  : 		if (!done)

  0036f	85 c0		 test	 eax, eax
  00371	75 5b		 jne	 SHORT $L72992

; 469  : 			done=ls_task_plain_number_processing(phTTS,llp,rlp,lp1);

  00373	8b 54 24 20	 mov	 edx, DWORD PTR _lp1$[esp+5676]
  00377	8b 44 24 10	 mov	 eax, DWORD PTR _rlp$[esp+5676]
  0037b	8b 4c 24 14	 mov	 ecx, DWORD PTR _llp$[esp+5676]
  0037f	52		 push	 edx
  00380	50		 push	 eax
  00381	51		 push	 ecx
  00382	53		 push	 ebx
  00383	e8 00 00 00 00	 call	 _ls_task_plain_number_processing
  00388	83 c4 10	 add	 esp, 16			; 00000010H

; 470  : 
; 471  : 		/*
; 472  : 		 * Well, all of the fancy heuristics have
; 473  : 		 * failed. Either this is just an ordinary word, or it
; 474  : 		 * is garbage. This first scan looks for things that might
; 475  : 		 * actually be part numbers, and runs the standard part
; 476  : 		 * number rules.
; 477  : 		 */
; 478  : 
; 479  : 		/* MGS 6/16/97 BATS #387  added to restore oroginal word */
; 480  : 		if (!done)

  0038b	85 c0		 test	 eax, eax
  0038d	75 3f		 jne	 SHORT $L72992

; 481  : 			memcpy(&(pLts_t->cword),&origword,sizeof(origword));

  0038f	8b 54 24 1c	 mov	 edx, DWORD PTR _pLts_t$[esp+5676]
  00393	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00398	8d 74 24 2c	 lea	 esi, DWORD PTR _origword$[esp+5676]
  0039c	8d ba 14 09 00
	00		 lea	 edi, DWORD PTR [edx+2324]
  003a2	f3 a5		 rep movsd

; 482  : 
; 483  : 		if (!done)
; 484  : 			done=ls_task_part_number(phTTS,llp,rlp);

  003a4	8b 44 24 10	 mov	 eax, DWORD PTR _rlp$[esp+5676]
  003a8	8b 4c 24 14	 mov	 ecx, DWORD PTR _llp$[esp+5676]
  003ac	50		 push	 eax
  003ad	51		 push	 ecx
  003ae	53		 push	 ebx
  003af	e8 00 00 00 00	 call	 _ls_task_part_number
  003b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 485  : 	
; 486  : 		
; 487  : 		if (!done)

  003b7	85 c0		 test	 eax, eax
  003b9	75 13		 jne	 SHORT $L72992

; 488  : 			done=ls_task_process_word(phTTS,llp,rlp);

  003bb	8b 54 24 10	 mov	 edx, DWORD PTR _rlp$[esp+5676]
  003bf	8b 44 24 14	 mov	 eax, DWORD PTR _llp$[esp+5676]
  003c3	52		 push	 edx
  003c4	50		 push	 eax
  003c5	53		 push	 ebx
  003c6	e8 00 00 00 00	 call	 _ls_task_process_word
  003cb	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72992:
  003ce	8b 7c 24 1c	 mov	 edi, DWORD PTR _pLts_t$[esp+5676]
$L72304:

; 489  : 
; 490  : 		switch (done)
; 491  : 		{

  003d2	48		 dec	 eax
  003d3	0f 84 dd fc ff
	ff		 je	 $L72263
  003d9	48		 dec	 eax
  003da	74 15		 je	 SHORT $L72310
  003dc	48		 dec	 eax
  003dd	0f 85 d3 fc ff
	ff		 jne	 $L72263

; 496  : 				break;
; 497  : 			case FINISHED_WORD:
; 498  : 				ls_task_read_next_word(phTTS);

  003e3	53		 push	 ebx
  003e4	e8 00 00 00 00	 call	 _ls_task_read_next_word
  003e9	83 c4 04	 add	 esp, 4

; 499  : 				break;

  003ec	e9 c5 fc ff ff	 jmp	 $L72263
$L72310:

; 492  : 			case LS_TASK_LOOP:
; 493  : 				continue;
; 494  : 			case SPELL_WORD:
; 495  : 				ls_task_spell_word(phTTS,llp,rlp);

  003f1	8b 4c 24 10	 mov	 ecx, DWORD PTR _rlp$[esp+5676]
  003f5	8b 54 24 14	 mov	 edx, DWORD PTR _llp$[esp+5676]
  003f9	51		 push	 ecx
  003fa	52		 push	 edx
  003fb	53		 push	 ebx
  003fc	e8 00 00 00 00	 call	 _ls_task_spell_word
  00401	83 c4 0c	 add	 esp, 12			; 0000000cH
  00404	e9 ad fc ff ff	 jmp	 $L72263
_ls_task_main ENDP
_TEXT	ENDS
PUBLIC	_ls_task_parse_number
EXTRN	_ls_char_feat:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_np$ = 20
_pLts_t$ = 8
_pKsd_t$ = -4
_ls_task_parse_number PROC NEAR

; 528  : {

  00410	51		 push	 ecx

; 529  : 	LETTER  *tlp1;
; 530  : 	LETTER  *tlp2;
; 531  : 	int     ncbs;   
; 532  : 	int break_flag;
; 533  : 	PLTS_T  pLts_t;
; 534  : 	PKSD_T  pKsd_t;
; 535  : 
; 536  : 	pLts_t = phTTS->pLTSThreadData;

  00411	8b 44 24 08	 mov	 eax, DWORD PTR _phTTS$[esp]
  00415	53		 push	 ebx
  00416	55		 push	 ebp

; 537  : 	pKsd_t = phTTS->pKernelShareData;   
; 538  : 
; 539  : 	np->n_ilp = NULL;                       /* Null scan.           */
; 540  : 	np->n_flp = NULL;
; 541  : 	np->n_elp = NULL;
; 542  : 	tlp1 = llp;

  00417	8b 6c 24 14	 mov	 ebp, DWORD PTR _llp$[esp+8]
  0041b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0041e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00421	56		 push	 esi
  00422	8b 74 24 20	 mov	 esi, DWORD PTR _np$[esp+12]
  00426	57		 push	 edi

; 543  : 	if (tlp1 != rlp
; 544  : 	&& (tlp1->l_ch == 0xBC                  /* 1/4                  */
; 545  : 	||  tlp1->l_ch == 0xBD                  /* 1/2                  */
; 546  : 	||  IS_DIGIT(tlp1->l_ch))) 

  00427	8b 7c 24 20	 mov	 edi, DWORD PTR _rlp$[esp+16]
  0042b	33 c0		 xor	 eax, eax
  0042d	3b ef		 cmp	 ebp, edi
  0042f	89 06		 mov	 DWORD PTR [esi], eax
  00431	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00434	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00437	89 4c 24 18	 mov	 DWORD PTR _pLts_t$[esp+16], ecx
  0043b	89 54 24 10	 mov	 DWORD PTR _pKsd_t$[esp+20], edx
  0043f	8b c5		 mov	 eax, ebp
  00441	0f 84 73 01 00
	00		 je	 $L72320
  00447	66 8b 4d 00	 mov	 cx, WORD PTR [ebp]
  0044b	b3 10		 mov	 bl, 16			; 00000010H
  0044d	66 81 f9 bc 00	 cmp	 cx, 188			; 000000bcH
  00452	74 16		 je	 SHORT $L72331
  00454	66 81 f9 bd 00	 cmp	 cx, 189			; 000000bdH
  00459	74 0f		 je	 SHORT $L72331
  0045b	0f bf c9	 movsx	 ecx, cx
  0045e	84 99 00 00 00
	00		 test	 BYTE PTR _ls_char_feat[ecx], bl
  00464	0f 84 b9 00 00
	00		 je	 $L72330
$L72331:

; 547  : 	{
; 548  : 		np->n_ilp = tlp1;

  0046a	89 2e		 mov	 DWORD PTR [esi], ebp
$L72333:

; 550  : 		{
; 551  : 			/* 1/2 and 1/4.                                 */
; 552  : 			if (tlp1->l_ch==0xBC || tlp1->l_ch==0xBD) 

  0046c	66 8b 08	 mov	 cx, WORD PTR [eax]
  0046f	66 81 f9 bc 00	 cmp	 cx, 188			; 000000bcH
  00474	0f 84 94 00 00
	00		 je	 $L72336
  0047a	66 81 f9 bd 00	 cmp	 cx, 189			; 000000bdH
  0047f	0f 84 89 00 00
	00		 je	 $L72336

; 556  : 				return (tlp1);
; 557  : 			}
; 558  : 			/* Comma (period if this is MODE_EUROPE).       */
; 559  : 			if (tlp1->l_ch == pLts_t->schar) 

  00485	8b 54 24 18	 mov	 edx, DWORD PTR _pLts_t$[esp+16]
  00489	66 8b 92 ee 08
	00 00		 mov	 dx, WORD PTR [edx+2286]
  00490	66 3b ca	 cmp	 cx, dx
  00493	75 5e		 jne	 SHORT $L72337

; 560  : 			{
; 561  : 				tlp2 = tlp1;

  00495	8b c8		 mov	 ecx, eax

; 562  : 				ncbs = 3;
; 563  : 				break_flag = 0;
; 564  : 				while (ncbs-- && tlp2!=llp) 

  00497	be 02 00 00 00	 mov	 esi, 2
$L72339:
  0049c	3b cd		 cmp	 ecx, ebp
  0049e	74 19		 je	 SHORT $L72343

; 565  : 				{
; 566  : 					--tlp2;

  004a0	83 e9 08	 sub	 ecx, 8

; 567  : 					if (tlp2->l_ch == pLts_t->schar)

  004a3	66 39 11	 cmp	 WORD PTR [ecx], dx
  004a6	74 72		 je	 SHORT $L72334
  004a8	8b de		 mov	 ebx, esi
  004aa	4e		 dec	 esi
  004ab	85 db		 test	 ebx, ebx
  004ad	75 ed		 jne	 SHORT $L72339

; 568  :                     {						
; 569  : 						break_flag = 1;
; 570  : 						break;
; 571  : 				    }
; 572  : 				}    
; 573  : 				if (break_flag)
; 574  : 				   break;
; 575  : 				if (tlp2!=llp && (tlp2-1)->l_ch!=pLts_t->schar)

  004af	3b cd		 cmp	 ecx, ebp
  004b1	74 06		 je	 SHORT $L72343
  004b3	66 39 51 f8	 cmp	 WORD PTR [ecx-8], dx
  004b7	75 61		 jne	 SHORT $L72334
$L72343:

; 549  : 		while (tlp1 != rlp) 

  004b9	8d 70 08	 lea	 esi, DWORD PTR [eax+8]

; 576  : 					break;
; 577  : 				tlp2 = tlp1+1;
; 578  : 				ncbs = 3;
; 579  : 				while (ncbs--) 

  004bc	ba 02 00 00 00	 mov	 edx, 2
  004c1	8b ce		 mov	 ecx, esi
$L72345:

; 580  : 				{
; 581  : 					if (tlp2==rlp || !IS_DIGIT(tlp2->l_ch))

  004c3	3b cf		 cmp	 ecx, edi
  004c5	74 53		 je	 SHORT $L72334
  004c7	0f bf 19	 movsx	 ebx, WORD PTR [ecx]
  004ca	f6 83 00 00 00
	00 10		 test	 BYTE PTR _ls_char_feat[ebx], 16 ; 00000010H
  004d1	74 47		 je	 SHORT $L72334

; 582  : 					{
; 583  : 					   break_flag = 1;
; 584  : 					   break;
; 585  : 					}	
; 586  : 					++tlp2;

  004d3	83 c1 08	 add	 ecx, 8
  004d6	8b da		 mov	 ebx, edx
  004d8	4a		 dec	 edx
  004d9	85 db		 test	 ebx, ebx
  004db	75 e6		 jne	 SHORT $L72345

; 587  : 				}
; 588  : 				
; 589  : 				if (break_flag)
; 590  : 				   break;
; 591  : 				   
; 592  : 				/*
; 593  : 				 * The normal DECtalk code does not
; 594  : 				 * make this check; instead, it implemented
; 595  : 				 * the exact rules of the DECtalk I. Peter
; 596  : 				 * Stevens at Kurzweil thought that this extra
; 597  : 				 * check was appropriate, and I tend to
; 598  : 				 * agree with him. We should probably make
; 599  : 				 * this change in all DECtalk code.
; 600  : 				 */
; 601  : 				/* Note from EAB-I have looked at this and 
; 602  : 				 * can't figure out how it makes the dectalk
; 603  : 				 * do anything different, but for chicken 
; 604  : 				 * soup reasons I'm leaving it in. 
; 605  : 				 */     
; 606  : 
; 607  : 				if (tlp2!=rlp && IS_DIGIT(tlp2->l_ch))

  004dd	3b cf		 cmp	 ecx, edi
  004df	74 0c		 je	 SHORT $L72350
  004e1	0f bf 09	 movsx	 ecx, WORD PTR [ecx]
  004e4	f6 81 00 00 00
	00 10		 test	 BYTE PTR _ls_char_feat[ecx], 16 ; 00000010H
  004eb	75 2d		 jne	 SHORT $L72334
$L72350:

; 608  : 					break;
; 609  : 				++tlp1;

  004ed	8b c6		 mov	 eax, esi

; 610  : 				continue;

  004ef	b3 10		 mov	 bl, 16			; 00000010H
  004f1	eb 0e		 jmp	 SHORT $L73011
$L72337:

; 611  : 			}
; 612  : 			if (IS_DIGIT(tlp1->l_ch)) 

  004f3	0f bf d1	 movsx	 edx, cx
  004f6	84 9a 00 00 00
	00		 test	 BYTE PTR _ls_char_feat[edx], bl
  004fc	74 1c		 je	 SHORT $L72334

; 613  : 			{
; 614  : 				++tlp1;

  004fe	83 c0 08	 add	 eax, 8
$L73011:

; 549  : 		while (tlp1 != rlp) 

  00501	3b c7		 cmp	 eax, edi
  00503	74 15		 je	 SHORT $L72334
  00505	8b 74 24 24	 mov	 esi, DWORD PTR _np$[esp+16]
  00509	e9 5e ff ff ff	 jmp	 $L72333
$L72336:

; 553  : 			{
; 554  : 				++tlp1;

  0050e	83 c0 08	 add	 eax, 8
  00511	5f		 pop	 edi

; 555  : 				np->n_irp = tlp1;

  00512	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00515	5e		 pop	 esi
  00516	5d		 pop	 ebp
  00517	5b		 pop	 ebx

; 642  : 		}
; 643  : 	}
; 644  : 	return (tlp1);
; 645  : }

  00518	59		 pop	 ecx
  00519	c3		 ret	 0
$L72334:

; 615  : 				continue;
; 616  : 			}
; 617  : 			break;
; 618  : 		}
; 619  : 		np->n_irp = tlp1;

  0051a	8b 74 24 24	 mov	 esi, DWORD PTR _np$[esp+16]
  0051e	b3 10		 mov	 bl, 16			; 00000010H
  00520	89 46 04	 mov	 DWORD PTR [esi+4], eax
$L72330:

; 620  : 	}
; 621  : 	if (tlp1!=rlp && tlp1->l_ch==pLts_t->fchar) 

  00523	3b c7		 cmp	 eax, edi
  00525	0f 84 8f 00 00
	00		 je	 $L72320
  0052b	8b 54 24 18	 mov	 edx, DWORD PTR _pLts_t$[esp+16]
  0052f	66 8b 08	 mov	 cx, WORD PTR [eax]
  00532	66 3b 8a ec 08
	00 00		 cmp	 cx, WORD PTR [edx+2284]
  00539	75 1f		 jne	 SHORT $L72352

; 622  : 	{   /* Fraction             */
; 623  : 		np->n_flp = tlp1;

  0053b	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 624  : 		++tlp1;

  0053e	83 c0 08	 add	 eax, 8

; 625  : 		while (tlp1!=rlp && IS_DIGIT(tlp1->l_ch))

  00541	3b c7		 cmp	 eax, edi
  00543	74 12		 je	 SHORT $L72355
$L72354:
  00545	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00548	84 99 00 00 00
	00		 test	 BYTE PTR _ls_char_feat[ecx], bl
  0054e	74 07		 je	 SHORT $L72355

; 626  : 			++tlp1;

  00550	83 c0 08	 add	 eax, 8
  00553	3b c7		 cmp	 eax, edi
  00555	75 ee		 jne	 SHORT $L72354
$L72355:

; 627  : 		np->n_frp = tlp1;

  00557	89 46 0c	 mov	 DWORD PTR [esi+12], eax
$L72352:

; 628  : 	}
; 629  : 	if (tlp1!=rlp && tlp1->l_ch=='e' && (pKsd_t->modeflag & MODE_MATH)) 

  0055a	3b c7		 cmp	 eax, edi
  0055c	74 5c		 je	 SHORT $L72320
  0055e	66 83 38 65	 cmp	 WORD PTR [eax], 101	; 00000065H
  00562	75 56		 jne	 SHORT $L72320
  00564	8b 54 24 10	 mov	 edx, DWORD PTR _pKsd_t$[esp+20]
  00568	f6 82 00 02 00
	00 04		 test	 BYTE PTR [edx+512], 4
  0056f	74 49		 je	 SHORT $L72320

; 630  : 	{        /* Exponant.            */
; 631  : 		tlp2 = tlp1;

  00571	8b d0		 mov	 edx, eax

; 632  : 		++tlp1;

  00573	83 c0 08	 add	 eax, 8

; 633  : 		if ( tlp1!=rlp && (tlp1->l_ch=='+' || tlp1->l_ch=='-'))

  00576	3b c7		 cmp	 eax, edi
  00578	74 40		 je	 SHORT $L72320
  0057a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0057d	66 83 f9 2b	 cmp	 cx, 43			; 0000002bH
  00581	74 06		 je	 SHORT $L72358
  00583	66 83 f9 2d	 cmp	 cx, 45			; 0000002dH
  00587	75 03		 jne	 SHORT $L72357
$L72358:

; 634  : 			++tlp1;

  00589	83 c0 08	 add	 eax, 8
$L72357:

; 635  : 		if (tlp1!=rlp && IS_DIGIT(tlp1->l_ch)) 

  0058c	3b c7		 cmp	 eax, edi
  0058e	74 2a		 je	 SHORT $L72320
  00590	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00593	84 99 00 00 00
	00		 test	 BYTE PTR _ls_char_feat[ecx], bl
  00599	74 1f		 je	 SHORT $L72320

; 636  : 		{
; 637  : 			np->n_elp = tlp2;
; 638  : 			++tlp1;

  0059b	83 c0 08	 add	 eax, 8
  0059e	89 56 10	 mov	 DWORD PTR [esi+16], edx

; 639  : 			while (tlp1!=rlp && IS_DIGIT(tlp1->l_ch))

  005a1	3b c7		 cmp	 eax, edi
  005a3	74 12		 je	 SHORT $L72362
$L72361:
  005a5	0f bf 10	 movsx	 edx, WORD PTR [eax]
  005a8	84 9a 00 00 00
	00		 test	 BYTE PTR _ls_char_feat[edx], bl
  005ae	74 07		 je	 SHORT $L72362

; 640  : 				++tlp1;

  005b0	83 c0 08	 add	 eax, 8
  005b3	3b c7		 cmp	 eax, edi
  005b5	75 ee		 jne	 SHORT $L72361
$L72362:

; 641  : 			np->n_erp = tlp1;

  005b7	89 46 14	 mov	 DWORD PTR [esi+20], eax
$L72320:
  005ba	5f		 pop	 edi
  005bb	5e		 pop	 esi
  005bc	5d		 pop	 ebp
  005bd	5b		 pop	 ebx

; 642  : 		}
; 643  : 	}
; 644  : 	return (tlp1);
; 645  : }

  005be	59		 pop	 ecx
  005bf	c3		 ret	 0
_ls_task_parse_number ENDP
_TEXT	ENDS
PUBLIC	_ls_task_wlookup
EXTRN	_ls_lower:BYTE
_TEXT	SEGMENT
_pLts_t$ = 8
_word$ = 12
_table$ = 16
_ls_task_wlookup PROC NEAR

; 672  : 	LETTER  *lp;
; 673  : 	/* GL 03/20/1998, BATS#633  use "unsigned char" instead of "char" */
; 674  : 	unsigned char  	*cp;
; 675  : 	unsigned char  	*tp;
; 676  : 	int   	c;
; 677  : 	int   	len;
; 678  : 
; 679  : 	tp = &table[0];                 /* Start at the start.  */
; 680  : 	while ((len = *tp++) != 0) 

  005c0	8b 44 24 0c	 mov	 eax, DWORD PTR _table$[esp-4]
  005c4	33 c9		 xor	 ecx, ecx
  005c6	53		 push	 ebx
  005c7	55		 push	 ebp
  005c8	8a 08		 mov	 cl, BYTE PTR [eax]
  005ca	56		 push	 esi
  005cb	8b e9		 mov	 ebp, ecx
  005cd	57		 push	 edi
  005ce	85 ed		 test	 ebp, ebp
  005d0	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  005d3	74 52		 je	 SHORT $L72377

; 681  : 	{            					/* 0 => end of table.   */
; 682  : 		lp = &word[0];              
; 683  : 		cp = tp;                    /* Start of text.       */
; 684  : 		for (;;) 
; 685  : 		{
; 686  : 			c = ls_lower[lp->l_ch]; /* Fold case.           */

  005d5	8b 54 24 18	 mov	 edx, DWORD PTR _word$[esp+12]
  005d9	0f bf 02	 movsx	 eax, WORD PTR [edx]
  005dc	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _ls_lower[eax]
  005e2	88 44 24 1c	 mov	 BYTE PTR 16+[esp+12], al
  005e6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
$L72376:
  005eb	8b 54 24 18	 mov	 edx, DWORD PTR _word$[esp+12]

; 687  : 			if (c != *cp++)         /* Lose.                */

  005ef	33 db		 xor	 ebx, ebx
  005f1	8a 1f		 mov	 bl, BYTE PTR [edi]
  005f3	8b c8		 mov	 ecx, eax
  005f5	3b cb		 cmp	 ecx, ebx
  005f7	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  005fa	75 1e		 jne	 SHORT $L73027
$L72379:

; 688  : 				break;
; 689  : 			if (c == EOS)           /* Win.                 */

  005fc	85 c9		 test	 ecx, ecx
  005fe	74 2e		 je	 SHORT $L73028
  00600	0f bf 4a 08	 movsx	 ecx, WORD PTR [edx+8]

; 700  :             }
; 701  : 			++lp;   

  00604	83 c2 08	 add	 edx, 8
  00607	33 db		 xor	 ebx, ebx
  00609	8a 99 00 00 00
	00		 mov	 bl, BYTE PTR _ls_lower[ecx]
  0060f	8b cb		 mov	 ecx, ebx
  00611	33 db		 xor	 ebx, ebx
  00613	8a 1e		 mov	 bl, BYTE PTR [esi]
  00615	46		 inc	 esi
  00616	3b cb		 cmp	 ecx, ebx
  00618	74 e2		 je	 SHORT $L72379
$L73027:

; 702  : 		}
; 703  : 		tp += len;                  /* Next.                */

  0061a	03 fd		 add	 edi, ebp
  0061c	33 d2		 xor	 edx, edx
  0061e	8a 17		 mov	 dl, BYTE PTR [edi]
  00620	47		 inc	 edi
  00621	8b ea		 mov	 ebp, edx
  00623	85 ed		 test	 ebp, ebp
  00625	75 c4		 jne	 SHORT $L72376
$L72377:
  00627	5f		 pop	 edi
  00628	5e		 pop	 esi
  00629	5d		 pop	 ebp

; 704  : 	}
; 705  : 	return (NULL);

  0062a	33 c0		 xor	 eax, eax
  0062c	5b		 pop	 ebx

; 706  : }

  0062d	c3		 ret	 0
$L73028:

; 690  :             {
; 691  : #ifdef ENGLISH
; 692  :                  /* set form class for "to" */
; 693  :                  if (ls_lower[(&word[0])->l_ch] == 't') pLts_t->fc_struct[pLts_t->fc_index] = FC_TO | FC_PREP | FC_FUNC;

  0062e	8a 44 24 1c	 mov	 al, BYTE PTR 16+[esp+12]
  00632	3c 74		 cmp	 al, 116			; 00000074H
  00634	8b 44 24 14	 mov	 eax, DWORD PTR _pLts_t$[esp+12]
  00638	75 11		 jne	 SHORT $L72383
  0063a	8b 88 bc 08 00
	00		 mov	 ecx, DWORD PTR [eax+2236]
  00640	c7 84 88 bc 04
	00 00 00 10 81
	00		 mov	 DWORD PTR [eax+ecx*4+1212], 8458240 ; 00811000H
$L72383:

; 694  :                  /* set form class for "and" */
; 695  :                  if (ls_lower[(&word[0])->l_ch] == 'a') pLts_t->fc_struct[pLts_t->fc_index] = FC_CONJ | FC_VERB | FC_FUNC;

  0064b	8b 4c 24 18	 mov	 ecx, DWORD PTR _word$[esp+12]
  0064f	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00652	80 ba 00 00 00
	00 61		 cmp	 BYTE PTR _ls_lower[edx], 97 ; 00000061H
  00659	75 11		 jne	 SHORT $L72384
  0065b	8b 90 bc 08 00
	00		 mov	 edx, DWORD PTR [eax+2236]
  00661	c7 84 90 bc 04
	00 00 40 00 82
	00		 mov	 DWORD PTR [eax+edx*4+1212], 8519744 ; 00820040H
$L72384:

; 696  :                  /* set form class for "for" */
; 697  :                  if (ls_lower[(&word[0])->l_ch] == 'f') pLts_t->fc_struct[pLts_t->fc_index] = FC_ADV | FC_PREP | FC_NEG;

  0066c	0f bf 09	 movsx	 ecx, WORD PTR [ecx]
  0066f	80 b9 00 00 00
	00 66		 cmp	 BYTE PTR _ls_lower[ecx], 102 ; 00000066H
  00676	75 11		 jne	 SHORT $L72385
  00678	8b 90 bc 08 00
	00		 mov	 edx, DWORD PTR [eax+2236]
  0067e	c7 84 90 bc 04
	00 00 02 10 08
	00		 mov	 DWORD PTR [eax+edx*4+1212], 528386 ; 00081002H
$L72385:

; 698  : #endif
; 699  :                  return (cp);    	/* Return phonemes.     */

  00689	8b c6		 mov	 eax, esi
  0068b	5f		 pop	 edi
  0068c	5e		 pop	 esi
  0068d	5d		 pop	 ebp
  0068e	5b		 pop	 ebx

; 706  : }

  0068f	c3		 ret	 0
_ls_task_wlookup ENDP
_TEXT	ENDS
PUBLIC	_ls_task_lookahead
EXTRN	_ls_util_is_index:NEAR
_TEXT	SEGMENT
_pLts_t$ = 8
_ls_task_lookahead PROC NEAR

; 729  : {

  00690	56		 push	 esi

; 730  :     LETTER	*elp;
; 731  : 
; 732  : 	if (ls_util_is_index(&(pLts_t->citem)) == FALSE)	/* Duck if no index     */

  00691	8b 74 24 08	 mov	 esi, DWORD PTR _pLts_t$[esp]
  00695	8d 86 00 09 00
	00		 lea	 eax, DWORD PTR [esi+2304]
  0069b	50		 push	 eax
  0069c	e8 00 00 00 00	 call	 _ls_util_is_index
  006a1	83 c4 04	 add	 esp, 4
  006a4	85 c0		 test	 eax, eax
  006a6	74 19		 je	 SHORT $L72394

; 733  : 		return;
; 734  : 	elp = &(pLts_t->cword[0]);                        	/* Find end of word,    */
; 735  : 	while ((elp+1)->l_ch != EOS)

  006a8	66 83 be 1c 09
	00 00 00	 cmp	 WORD PTR [esi+2332], 0
  006b0	8d 86 1c 09 00
	00		 lea	 eax, DWORD PTR [esi+2332]
  006b6	74 09		 je	 SHORT $L72394
$L72393:

; 736  : 	{
; 737  : 		++elp;

  006b8	83 c0 08	 add	 eax, 8
  006bb	66 83 38 00	 cmp	 WORD PTR [eax], 0
  006bf	75 f7		 jne	 SHORT $L72393
$L72394:
  006c1	5e		 pop	 esi

; 738  : 	}
; 739  : }

  006c2	c3		 ret	 0
_ls_task_lookahead ENDP
_TEXT	ENDS
EXTRN	_ls_suff_print_fc:NEAR
EXTRN	_ls_util_send_phone:NEAR
EXTRN	_ls_util_write_pipe:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_flag$ = 12
_buf$ = 8
_ls_task_do_right_punct PROC NEAR

; 763  : {

  006d0	53		 push	 ebx
  006d1	56		 push	 esi
  006d2	57		 push	 edi

; 764  : 	int   c;
; 765  : 	short   buf[1];
; 766  : 	PLTS_T  pLts_t;
; 767  : 	PKSD_T  pKsd_t;
; 768  : 
; 769  : 	pLts_t = phTTS->pLTSThreadData;

  006d3	8b 7c 24 10	 mov	 edi, DWORD PTR _phTTS$[esp+8]
  006d7	8b 77 10	 mov	 esi, DWORD PTR [edi+16]

; 770  : 	pKsd_t = phTTS->pKernelShareData;

  006da	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]

; 771  : 
; 772  : 	if ((pLts_t->citem.i_word[0]&PFONT) != (PFASCII<<PSFONT))

  006dd	66 8b 86 02 09
	00 00		 mov	 ax, WORD PTR [esi+2306]
  006e4	8b c8		 mov	 ecx, eax
  006e6	81 e1 00 1f 00
	00		 and	 ecx, 7936		; 00001f00H
  006ec	66 85 c9	 test	 cx, cx
  006ef	0f 85 f0 01 00
	00		 jne	 $L72410

; 773  : 		return;
; 774  : 	c = pLts_t->citem.i_word[0] & PVALUE;
; 775  : 	if (flag==ABBREV && (c==CR || c==LF)) 

  006f5	8b 4c 24 14	 mov	 ecx, DWORD PTR _flag$[esp+8]
  006f9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006fe	83 f9 02	 cmp	 ecx, 2
  00701	75 4e		 jne	 SHORT $L72405
  00703	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  00706	74 05		 je	 SHORT $L72406
  00708	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0070b	75 44		 jne	 SHORT $L72405
$L72406:

; 776  : 	{
; 777  : 		ls_util_send_phone(phTTS,PERIOD);

  0070d	6a 74		 push	 116			; 00000074H
  0070f	57		 push	 edi
  00710	e8 00 00 00 00	 call	 _ls_util_send_phone

; 778  : 		pLts_t->wstate = UNK_WH;

  00715	66 c7 86 c4 08
	00 00 00 00	 mov	 WORD PTR [esi+2244], 0

; 779  : 
; 780  : /* GL 11/06/1997 add switch 4100. form class log can be used by any language */
; 781  : //#ifdef ENGLISH		
; 782  : 		if((pKsd_t->logflag& LOG_FORM_TYPES) || DT_DBG(LTS_DBG,0x100))

  0071e	8a 83 04 02 00
	00		 mov	 al, BYTE PTR [ebx+516]
  00724	83 c4 08	 add	 esp, 8
  00727	a8 08		 test	 al, 8
  00729	75 19		 jne	 SHORT $L72408
  0072b	66 8b 9b 78 04
	00 00		 mov	 bx, WORD PTR [ebx+1144]
  00732	f6 c7 40	 test	 bh, 64			; 00000040H
  00735	0f 84 aa 01 00
	00		 je	 $L72410
  0073b	f6 c7 01	 test	 bh, 1
  0073e	0f 84 a1 01 00
	00		 je	 $L72410
$L72408:

; 783  : 			ls_suff_print_fc(phTTS);

  00744	57		 push	 edi
  00745	e8 00 00 00 00	 call	 _ls_suff_print_fc

; 884  : 			ls_util_read_item(phTTS);

  0074a	83 c4 04	 add	 esp, 4
  0074d	5f		 pop	 edi
  0074e	5e		 pop	 esi
  0074f	5b		 pop	 ebx

; 885  : 			break;
; 886  : 	}
; 887  : }

  00750	c3		 ret	 0
$L72405:

; 784  : //#endif
; 785  : 		return;
; 786  : 	}
; 787  : 	switch (c) 
; 788  : 	{

  00751	83 c0 f7	 add	 eax, -9			; fffffff7H
  00754	3d 97 00 00 00	 cmp	 eax, 151		; 00000097H
  00759	0f 87 86 01 00
	00		 ja	 $L72410
  0075f	33 d2		 xor	 edx, edx
  00761	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $L73039[eax]
  00767	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L73040[edx*4]
$L72413:

; 789  : 		case '.':
; 790  : #ifdef GERMAN
; 791  : 			/* GL 03/23/1998, BATS#613 remove the extra pulse for German ordinal number */
; 792  : 			if (ls_util_is_dot(pLts_t) && pLts_t->isnumabr == 3)
; 793  : 				;
; 794  : 			else
; 795  : 			ls_util_send_phone(phTTS,PERIOD);
; 796  : #else
; 797  : 			ls_util_send_phone(phTTS,PERIOD);

  0076e	6a 74		 push	 116			; 00000074H
  00770	57		 push	 edi
  00771	e8 00 00 00 00	 call	 _ls_util_send_phone

; 798  : #endif
; 799  : /* GL 11/06/1997 add switch 4100. form class log can be used by any language */
; 800  : //#ifdef ENGLISH			
; 801  : 			if((pKsd_t->logflag & LOG_FORM_TYPES) || DT_DBG(LTS_DBG,0x100))

  00776	8a 83 04 02 00
	00		 mov	 al, BYTE PTR [ebx+516]
  0077c	83 c4 08	 add	 esp, 8
  0077f	a8 08		 test	 al, 8
  00781	75 47		 jne	 SHORT $L72415
  00783	66 8b 9b 78 04
	00 00		 mov	 bx, WORD PTR [ebx+1144]
  0078a	f6 c7 40	 test	 bh, 64			; 00000040H
  0078d	74 44		 je	 SHORT $L72414
  0078f	f6 c7 01	 test	 bh, 1
  00792	74 3f		 je	 SHORT $L72414

; 802  : 				ls_suff_print_fc(phTTS);
; 803  : //#endif				
; 804  : 			ls_util_read_item(phTTS);
; 805  : 			pLts_t->wstate = UNK_WH;
; 806  : 			break;

  00794	eb 34		 jmp	 SHORT $L72415
$L72416:

; 807  : 
; 808  : 		case '?':
; 809  : 			if (pLts_t->wstate == IS_WH)    			/* Ignore the "?" if at */

  00796	66 83 be c4 08
	00 00 01	 cmp	 WORD PTR [esi+2244], 1
  0079e	75 04		 jne	 SHORT $L72417

; 810  : 			{
; 811  : #ifdef LS1DEBUG
; 812  : 				printf("Changing question mark to period! \n");
; 813  : #endif
; 814  : 				ls_util_send_phone(phTTS,PERIOD);       /* the end of a "Wh..." */

  007a0	6a 74		 push	 116			; 00000074H

; 815  : 			}
; 816  : 			else                            			/* style sentence.      */

  007a2	eb 02		 jmp	 SHORT $L73037
$L72417:

; 817  : 			{
; 818  : 				ls_util_send_phone(phTTS,QUEST);

  007a4	6a 75		 push	 117			; 00000075H
$L73037:
  007a6	57		 push	 edi
  007a7	e8 00 00 00 00	 call	 _ls_util_send_phone

; 819  : 			}
; 820  : /* GL 11/06/1997 add switch 4100. form class log can be used by any language */
; 821  : //#ifdef ENGLISH
; 822  : 		    if((pKsd_t->logflag& LOG_FORM_TYPES) || DT_DBG(LTS_DBG,0x100))

  007ac	8a 83 04 02 00
	00		 mov	 al, BYTE PTR [ebx+516]
  007b2	83 c4 08	 add	 esp, 8
  007b5	a8 08		 test	 al, 8
  007b7	75 11		 jne	 SHORT $L72415
  007b9	66 8b 9b 78 04
	00 00		 mov	 bx, WORD PTR [ebx+1144]
  007c0	f6 c7 40	 test	 bh, 64			; 00000040H
  007c3	74 0e		 je	 SHORT $L72414
  007c5	f6 c7 01	 test	 bh, 1
  007c8	74 09		 je	 SHORT $L72414
$L72415:

; 823  : 				ls_suff_print_fc(phTTS);

  007ca	57		 push	 edi
  007cb	e8 00 00 00 00	 call	 _ls_suff_print_fc
  007d0	83 c4 04	 add	 esp, 4
$L72414:

; 824  : //#endif
; 825  : 			ls_util_read_item(phTTS);

  007d3	57		 push	 edi
  007d4	e8 00 00 00 00	 call	 _ls_util_read_item
  007d9	83 c4 04	 add	 esp, 4

; 826  : 			pLts_t->wstate = UNK_WH;

  007dc	66 c7 86 c4 08
	00 00 00 00	 mov	 WORD PTR [esi+2244], 0
  007e5	5f		 pop	 edi
  007e6	5e		 pop	 esi
  007e7	5b		 pop	 ebx

; 885  : 			break;
; 886  : 	}
; 887  : }

  007e8	c3		 ret	 0
$L72421:

; 827  : 			break;
; 828  : 
; 829  : 		case '!':
; 830  : 			ls_util_send_phone(phTTS,EXCLAIM);

  007e9	6a 76		 push	 118			; 00000076H
  007eb	57		 push	 edi
  007ec	e8 00 00 00 00	 call	 _ls_util_send_phone

; 831  : 
; 832  : 			ls_util_read_item(phTTS);

  007f1	57		 push	 edi
  007f2	e8 00 00 00 00	 call	 _ls_util_read_item

; 833  : /* GL 11/06/1997 add switch 4100. form class log can be used by any language */
; 834  : //#ifdef ENGLISH			
; 835  : 		    if((pKsd_t->logflag& LOG_FORM_TYPES) || DT_DBG(LTS_DBG,0x100))

  007f7	8a 83 04 02 00
	00		 mov	 al, BYTE PTR [ebx+516]
  007fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00800	a8 08		 test	 al, 8
  00802	75 11		 jne	 SHORT $L72423
  00804	66 8b 9b 78 04
	00 00		 mov	 bx, WORD PTR [ebx+1144]
  0080b	f6 c7 40	 test	 bh, 64			; 00000040H
  0080e	74 0e		 je	 SHORT $L72422
  00810	f6 c7 01	 test	 bh, 1
  00813	74 09		 je	 SHORT $L72422
$L72423:

; 836  : 				ls_suff_print_fc(phTTS);

  00815	57		 push	 edi
  00816	e8 00 00 00 00	 call	 _ls_suff_print_fc
  0081b	83 c4 04	 add	 esp, 4
$L72422:

; 837  : //#endif				
; 838  : 			pLts_t->wstate = UNK_WH;

  0081e	66 c7 86 c4 08
	00 00 00 00	 mov	 WORD PTR [esi+2244], 0
  00827	5f		 pop	 edi
  00828	5e		 pop	 esi
  00829	5b		 pop	 ebx

; 885  : 			break;
; 886  : 	}
; 887  : }

  0082a	c3		 ret	 0
$L72424:

; 839  : 			break;
; 840  : 
; 841  : 		case VT:
; 842  : 		    /* Vertical tab, flush  */
; 843  : 		    /*
; 844  : 			   GL 01/31/1996, need to initialize the form class state for
; 845  : 			   control-k(VT)
; 846  : 			*/
; 847  : /* GL 11/06/1997 add switch 4100. form class log can be used by any language */
; 848  : //#ifdef ENGLISH			
; 849  : 			if((pKsd_t->logflag& LOG_FORM_TYPES) || DT_DBG(LTS_DBG,0x100))

  0082b	f6 83 04 02 00
	00 08		 test	 BYTE PTR [ebx+516], 8
  00832	75 11		 jne	 SHORT $L72426
  00834	66 8b 83 78 04
	00 00		 mov	 ax, WORD PTR [ebx+1144]
  0083b	f6 c4 40	 test	 ah, 64			; 00000040H
  0083e	74 0e		 je	 SHORT $L72425
  00840	f6 c4 01	 test	 ah, 1
  00843	74 09		 je	 SHORT $L72425
$L72426:

; 850  : 				ls_suff_print_fc(phTTS);

  00845	57		 push	 edi
  00846	e8 00 00 00 00	 call	 _ls_suff_print_fc
  0084b	83 c4 04	 add	 esp, 4
$L72425:

; 851  : //#endif				
; 852  : 			pLts_t->fc_index = 0;

  0084e	33 c0		 xor	 eax, eax

; 853  : 			pLts_t->old_fc_index = -1;
; 854  : 			pLts_t->fc_struct[0] = 0;
; 855  : 			pLts_t->fc_struct[1] = 0;
; 856  : 
; 857  : 			buf[0] = BREATH_BREAK;
; 858  : 			ls_util_write_pipe(pKsd_t,&buf[0],1);

  00850	6a 01		 push	 1
  00852	89 86 bc 08 00
	00		 mov	 DWORD PTR [esi+2236], eax
  00858	89 86 bc 04 00
	00		 mov	 DWORD PTR [esi+1212], eax
  0085e	89 86 c0 04 00
	00		 mov	 DWORD PTR [esi+1216], eax
  00864	8d 44 24 14	 lea	 eax, DWORD PTR _buf$[esp+12]
  00868	50		 push	 eax
  00869	c7 86 c0 08 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+2240], -1
  00873	53		 push	 ebx
  00874	66 c7 44 24 1c
	0b 1f		 mov	 WORD PTR _buf$[esp+20], 7947 ; 00001f0bH
  0087b	e8 00 00 00 00	 call	 _ls_util_write_pipe

; 859  : 			ls_util_read_item(phTTS);

  00880	57		 push	 edi
  00881	e8 00 00 00 00	 call	 _ls_util_read_item
  00886	83 c4 10	 add	 esp, 16			; 00000010H
  00889	5f		 pop	 edi
  0088a	5e		 pop	 esi
  0088b	5b		 pop	 ebx

; 885  : 			break;
; 886  : 	}
; 887  : }

  0088c	c3		 ret	 0
$L72427:

; 860  : 			break;
; 861  : 
; 862  : 		case ',':
; 863  : 		case ':':
; 864  : 		case ';':
; 865  : 		case HT:                                /* Tab, longish pause   */
; 866  : 
; 867  : 			pLts_t->fc_index = 1;
; 868  : 			pLts_t->old_fc_index = -1;
; 869  : 			pLts_t->fc_struct[0] = 0;

  0088d	33 c0		 xor	 eax, eax

; 870  : 			pLts_t->fc_struct[1] = 0;
; 871  : 			ls_util_send_phone(phTTS,COMMA);

  0088f	6a 73		 push	 115			; 00000073H
  00891	57		 push	 edi
  00892	c7 86 bc 08 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+2236], 1
  0089c	c7 86 c0 08 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+2240], -1
  008a6	89 86 bc 04 00
	00		 mov	 DWORD PTR [esi+1212], eax
  008ac	89 86 c0 04 00
	00		 mov	 DWORD PTR [esi+1216], eax
  008b2	e8 00 00 00 00	 call	 _ls_util_send_phone

; 872  : 			ls_util_read_item(phTTS);

  008b7	57		 push	 edi
  008b8	e8 00 00 00 00	 call	 _ls_util_read_item
  008bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  008c0	5f		 pop	 edi
  008c1	5e		 pop	 esi
  008c2	5b		 pop	 ebx

; 885  : 			break;
; 886  : 	}
; 887  : }

  008c3	c3		 ret	 0
$L72428:

; 873  : 			break;
; 874  : 
; 875  : 		case ' ':                               /* ASCII SP             */
; 876  : 		case 0xA0:                              /* Multinational SP     */
; 877  : 		case LF:                                /* Linefeed             */
; 878  : 		case FF:                                /* Formfeed             */
; 879  : 		case CR:                                /* Carriage return.     */
; 880  : 			if ((pKsd_t->modeflag&MODE_SPELL)!=0)

  008c4	f6 83 00 02 00
	00 10		 test	 BYTE PTR [ebx+512], 16	; 00000010H
  008cb	74 04		 je	 SHORT $L72429

; 881  : 				ls_util_send_phone(phTTS,COMMA);       /* Make longer pause if */

  008cd	6a 73		 push	 115			; 00000073H

; 882  : 			else                            /* forced spelling.     */

  008cf	eb 02		 jmp	 SHORT $L73038
$L72429:

; 883  : 				ls_util_send_phone(phTTS,WBOUND);

  008d1	6a 6f		 push	 111			; 0000006fH
$L73038:
  008d3	57		 push	 edi
  008d4	e8 00 00 00 00	 call	 _ls_util_send_phone
  008d9	83 c4 08	 add	 esp, 8

; 884  : 			ls_util_read_item(phTTS);

  008dc	57		 push	 edi
  008dd	e8 00 00 00 00	 call	 _ls_util_read_item
  008e2	83 c4 04	 add	 esp, 4
$L72410:
  008e5	5f		 pop	 edi
  008e6	5e		 pop	 esi
  008e7	5b		 pop	 ebx

; 885  : 			break;
; 886  : 	}
; 887  : }

  008e8	c3		 ret	 0
  008e9	8d 49 00	 npad	 3
$L73040:
  008ec	00 00 00 00	 DD	 $L72427
  008f0	00 00 00 00	 DD	 $L72428
  008f4	00 00 00 00	 DD	 $L72424
  008f8	00 00 00 00	 DD	 $L72421
  008fc	00 00 00 00	 DD	 $L72413
  00900	00 00 00 00	 DD	 $L72416
  00904	00 00 00 00	 DD	 $L72410
$L73039:
  00908	00		 DB	 0
  00909	01		 DB	 1
  0090a	02		 DB	 2
  0090b	01		 DB	 1
  0090c	01		 DB	 1
  0090d	06		 DB	 6
  0090e	06		 DB	 6
  0090f	06		 DB	 6
  00910	06		 DB	 6
  00911	06		 DB	 6
  00912	06		 DB	 6
  00913	06		 DB	 6
  00914	06		 DB	 6
  00915	06		 DB	 6
  00916	06		 DB	 6
  00917	06		 DB	 6
  00918	06		 DB	 6
  00919	06		 DB	 6
  0091a	06		 DB	 6
  0091b	06		 DB	 6
  0091c	06		 DB	 6
  0091d	06		 DB	 6
  0091e	06		 DB	 6
  0091f	01		 DB	 1
  00920	03		 DB	 3
  00921	06		 DB	 6
  00922	06		 DB	 6
  00923	06		 DB	 6
  00924	06		 DB	 6
  00925	06		 DB	 6
  00926	06		 DB	 6
  00927	06		 DB	 6
  00928	06		 DB	 6
  00929	06		 DB	 6
  0092a	06		 DB	 6
  0092b	00		 DB	 0
  0092c	06		 DB	 6
  0092d	04		 DB	 4
  0092e	06		 DB	 6
  0092f	06		 DB	 6
  00930	06		 DB	 6
  00931	06		 DB	 6
  00932	06		 DB	 6
  00933	06		 DB	 6
  00934	06		 DB	 6
  00935	06		 DB	 6
  00936	06		 DB	 6
  00937	06		 DB	 6
  00938	06		 DB	 6
  00939	00		 DB	 0
  0093a	00		 DB	 0
  0093b	06		 DB	 6
  0093c	06		 DB	 6
  0093d	06		 DB	 6
  0093e	05		 DB	 5
  0093f	06		 DB	 6
  00940	06		 DB	 6
  00941	06		 DB	 6
  00942	06		 DB	 6
  00943	06		 DB	 6
  00944	06		 DB	 6
  00945	06		 DB	 6
  00946	06		 DB	 6
  00947	06		 DB	 6
  00948	06		 DB	 6
  00949	06		 DB	 6
  0094a	06		 DB	 6
  0094b	06		 DB	 6
  0094c	06		 DB	 6
  0094d	06		 DB	 6
  0094e	06		 DB	 6
  0094f	06		 DB	 6
  00950	06		 DB	 6
  00951	06		 DB	 6
  00952	06		 DB	 6
  00953	06		 DB	 6
  00954	06		 DB	 6
  00955	06		 DB	 6
  00956	06		 DB	 6
  00957	06		 DB	 6
  00958	06		 DB	 6
  00959	06		 DB	 6
  0095a	06		 DB	 6
  0095b	06		 DB	 6
  0095c	06		 DB	 6
  0095d	06		 DB	 6
  0095e	06		 DB	 6
  0095f	06		 DB	 6
  00960	06		 DB	 6
  00961	06		 DB	 6
  00962	06		 DB	 6
  00963	06		 DB	 6
  00964	06		 DB	 6
  00965	06		 DB	 6
  00966	06		 DB	 6
  00967	06		 DB	 6
  00968	06		 DB	 6
  00969	06		 DB	 6
  0096a	06		 DB	 6
  0096b	06		 DB	 6
  0096c	06		 DB	 6
  0096d	06		 DB	 6
  0096e	06		 DB	 6
  0096f	06		 DB	 6
  00970	06		 DB	 6
  00971	06		 DB	 6
  00972	06		 DB	 6
  00973	06		 DB	 6
  00974	06		 DB	 6
  00975	06		 DB	 6
  00976	06		 DB	 6
  00977	06		 DB	 6
  00978	06		 DB	 6
  00979	06		 DB	 6
  0097a	06		 DB	 6
  0097b	06		 DB	 6
  0097c	06		 DB	 6
  0097d	06		 DB	 6
  0097e	06		 DB	 6
  0097f	06		 DB	 6
  00980	06		 DB	 6
  00981	06		 DB	 6
  00982	06		 DB	 6
  00983	06		 DB	 6
  00984	06		 DB	 6
  00985	06		 DB	 6
  00986	06		 DB	 6
  00987	06		 DB	 6
  00988	06		 DB	 6
  00989	06		 DB	 6
  0098a	06		 DB	 6
  0098b	06		 DB	 6
  0098c	06		 DB	 6
  0098d	06		 DB	 6
  0098e	06		 DB	 6
  0098f	06		 DB	 6
  00990	06		 DB	 6
  00991	06		 DB	 6
  00992	06		 DB	 6
  00993	06		 DB	 6
  00994	06		 DB	 6
  00995	06		 DB	 6
  00996	06		 DB	 6
  00997	06		 DB	 6
  00998	06		 DB	 6
  00999	06		 DB	 6
  0099a	06		 DB	 6
  0099b	06		 DB	 6
  0099c	06		 DB	 6
  0099d	06		 DB	 6
  0099e	06		 DB	 6
  0099f	01		 DB	 1
_ls_task_do_right_punct ENDP
_TEXT	ENDS
EXTRN	_ls_util_write_item:NEAR
EXTRN	_ls_util_is_white:NEAR
EXTRN	_ls_util_is_might:NEAR
EXTRN	_lsctype:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_word$ = 12
_ksf$ = 8
_pLts_t$ = -4
_ls_task_readword PROC NEAR

; 918  : {

  009a0	51		 push	 ecx
  009a1	53		 push	 ebx
  009a2	55		 push	 ebp
  009a3	56		 push	 esi
  009a4	57		 push	 edi

; 919  : 	LETTER        *lp1;
; 920  : 	LETTER        *lp2;
; 921  : 	int   ksf=0;
; 922  : 	int   t;
; 923  : 	int   c=0;
; 924  : 	PLTS_T  pLts_t;
; 925  : 	PKSD_T  pKsd_t;
; 926  : 
; 927  : 	pLts_t = phTTS->pLTSThreadData;

  009a5	8b 7c 24 18	 mov	 edi, DWORD PTR _phTTS$[esp+16]
  009a9	33 ed		 xor	 ebp, ebp
  009ab	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  009ae	89 44 24 10	 mov	 DWORD PTR _pLts_t$[esp+20], eax

; 928  : 	pKsd_t = phTTS->pKernelShareData;   
; 929  : 	
; 930  : /*
; 931  :  *  start with no flags for this word ...
; 932  :  */
; 933  : 	while (ls_util_is_white(&(pLts_t->citem)) != FALSE) 

  009b2	8d b0 00 09 00
	00		 lea	 esi, DWORD PTR [eax+2304]
  009b8	56		 push	 esi
  009b9	e8 00 00 00 00	 call	 _ls_util_is_white
  009be	83 c4 04	 add	 esp, 4
  009c1	85 c0		 test	 eax, eax
  009c3	74 39		 je	 SHORT $L72445
$L72444:

; 934  : 	{      /* Skip spaces.         */
; 935  : 		ls_util_read_item(phTTS);

  009c5	57		 push	 edi
  009c6	e8 00 00 00 00	 call	 _ls_util_read_item

; 936  : 		while (ls_util_is_index(&(pLts_t->citem)) != FALSE) 

  009cb	56		 push	 esi
  009cc	e8 00 00 00 00	 call	 _ls_util_is_index
  009d1	83 c4 08	 add	 esp, 8
  009d4	85 c0		 test	 eax, eax
  009d6	74 19		 je	 SHORT $L72448
$L72447:

; 937  : 		{
; 938  : 			ls_util_write_item(phTTS);

  009d8	57		 push	 edi
  009d9	e8 00 00 00 00	 call	 _ls_util_write_item

; 939  : 			ls_util_read_item(phTTS);

  009de	57		 push	 edi
  009df	e8 00 00 00 00	 call	 _ls_util_read_item
  009e4	56		 push	 esi
  009e5	e8 00 00 00 00	 call	 _ls_util_is_index
  009ea	83 c4 0c	 add	 esp, 12			; 0000000cH
  009ed	85 c0		 test	 eax, eax
  009ef	75 e7		 jne	 SHORT $L72447
$L72448:

; 928  : 	pKsd_t = phTTS->pKernelShareData;   
; 929  : 	
; 930  : /*
; 931  :  *  start with no flags for this word ...
; 932  :  */
; 933  : 	while (ls_util_is_white(&(pLts_t->citem)) != FALSE) 

  009f1	56		 push	 esi
  009f2	e8 00 00 00 00	 call	 _ls_util_is_white
  009f7	83 c4 04	 add	 esp, 4
  009fa	85 c0		 test	 eax, eax
  009fc	75 c7		 jne	 SHORT $L72444
$L72445:

; 940  : 		}
; 941  : 	}
; 942  : 	lp1 = &word[0];                         /* Current location     */

  009fe	8b 74 24 1c	 mov	 esi, DWORD PTR _word$[esp+16]

; 943  : 	lp2 = &word[0];                         /* Rightmost location   */
; 944  : 	ksf = FALSE;                            /* Nothing kept         */

  00a02	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _ksf$[esp+16], 0
  00a0a	8b de		 mov	 ebx, esi
$L72450:

; 945  :         
; 946  : /* JDB: simple fix to avoid the goto's that used to be here */
; 947  : /* loop: */
; 948  :   while (1) 
; 949  :   { 
; 950  : 		if (ls_util_is_index(&(pLts_t->citem)) != FALSE)

  00a0c	8b 44 24 10	 mov	 eax, DWORD PTR _pLts_t$[esp+20]
  00a10	05 00 09 00 00	 add	 eax, 2304		; 00000900H
  00a15	50		 push	 eax
  00a16	e8 00 00 00 00	 call	 _ls_util_is_index
  00a1b	83 c4 04	 add	 esp, 4
  00a1e	85 c0		 test	 eax, eax
  00a20	74 1a		 je	 SHORT $L72452

; 951  : 		{         
; 952  : 			/* Index markers.       */
; 953  : 			if (lp1 == &word[0])            /* Flush through if at  */

  00a22	3b 74 24 1c	 cmp	 esi, DWORD PTR _word$[esp+16]
  00a26	75 09		 jne	 SHORT $L72453

; 954  : 			{
; 955  : 				ls_util_write_item(phTTS);  /* left edge of word.   */

  00a28	57		 push	 edi
  00a29	e8 00 00 00 00	 call	 _ls_util_write_item
  00a2e	83 c4 04	 add	 esp, 4
$L72453:

; 956  : 			}
; 957  : 
; 958  : 
; 959  : 			ls_util_read_item(phTTS); /* read next item */ 

  00a31	57		 push	 edi
  00a32	e8 00 00 00 00	 call	 _ls_util_read_item
  00a37	83 c4 04	 add	 esp, 4

; 960  : 			/* an item is a character with a bunch of other info about it */
; 961  : 			continue; /* goto loop; */

  00a3a	eb d0		 jmp	 SHORT $L72450
$L72452:

; 962  : 
; 963  : 		}
; 964  : 
; 965  : 		t = PHONEME;
; 966  : 		if ((pLts_t->citem.i_word[0]&PFONT) == (PFASCII<<PSFONT)) 

  00a3c	8b 54 24 10	 mov	 edx, DWORD PTR _pLts_t$[esp+20]
  00a40	b9 05 00 00 00	 mov	 ecx, 5
  00a45	66 8b 82 02 09
	00 00		 mov	 ax, WORD PTR [edx+2306]
  00a4c	8b d0		 mov	 edx, eax
  00a4e	81 e2 00 1f 00
	00		 and	 edx, 7936		; 00001f00H
  00a54	66 85 d2	 test	 dx, dx
  00a57	75 3a		 jne	 SHORT $L72456

; 967  : 		{
; 968  : 			c = pLts_t->citem.i_word[0] & PVALUE;

  00a59	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00a5e	8b e8		 mov	 ebp, eax

; 969  : 			t = lsctype[c] & TYPE;

  00a60	8a 0c 6d 00 00
	00 00		 mov	 cl, BYTE PTR _lsctype[ebp*2]
  00a67	83 e1 0f	 and	 ecx, 15			; 0000000fH

; 970  : 			if (t == IGNORE) 

  00a6a	75 0b		 jne	 SHORT $L72455

; 971  : 			{   
; 972  : 				/* These two are easy.  */
; 973  : 				ls_util_read_item(phTTS);

  00a6c	57		 push	 edi
  00a6d	e8 00 00 00 00	 call	 _ls_util_read_item
  00a72	83 c4 04	 add	 esp, 4

; 974  : 				continue; /* goto loop; */

  00a75	eb 95		 jmp	 SHORT $L72450
$L72455:

; 975  : 			}
; 976  : 			if (t == BACKUP) 

  00a77	83 f9 01	 cmp	 ecx, 1
  00a7a	75 17		 jne	 SHORT $L72456

; 977  : 			{
; 978  : 				if (lp1 != &word[0])

  00a7c	3b 74 24 1c	 cmp	 esi, DWORD PTR _word$[esp+16]
  00a80	74 03		 je	 SHORT $L72457

; 979  : 					--lp1;           

  00a82	83 ee 08	 sub	 esi, 8
$L72457:

; 980  : 				ls_util_read_item(phTTS);

  00a85	57		 push	 edi
  00a86	e8 00 00 00 00	 call	 _ls_util_read_item
  00a8b	83 c4 04	 add	 esp, 4

; 981  : 				continue; /* goto loop; */

  00a8e	e9 79 ff ff ff	 jmp	 $L72450
$L72456:

; 982  : 			}
; 983  : 		}
; 984  : 		
; 985  : 		if (lp1 < lp2) 

  00a93	3b f3		 cmp	 esi, ebx
  00a95	73 2c		 jae	 SHORT $L72458

; 986  : 		{                        /* Overstrike.          */
; 987  : 
; 988  : 			if (t==MIGHT || t==ALWAYS)

  00a97	83 f9 03	 cmp	 ecx, 3
  00a9a	74 09		 je	 SHORT $L72460
  00a9c	83 f9 04	 cmp	 ecx, 4
  00a9f	0f 85 bf 00 00
	00		 jne	 $L72459
$L72460:

; 989  : 			{
; 990  : 				if ((lsctype[c]&II) == 0)

  00aa5	f6 04 6d 00 00
	00 00 10	 test	 BYTE PTR _lsctype[ebp*2], 16 ; 00000010H
  00aad	75 03		 jne	 SHORT $L72461

; 991  : 					lp1->l_ch = c;

  00aaf	66 89 2e	 mov	 WORD PTR [esi], bp
$L72461:

; 992  : 				++lp1;
; 993  : 				ls_util_read_item(phTTS);

  00ab2	57		 push	 edi
  00ab3	83 c6 08	 add	 esi, 8
  00ab6	e8 00 00 00 00	 call	 _ls_util_read_item
  00abb	83 c4 04	 add	 esp, 4

; 994  : 				continue; /* goto loop;*/

  00abe	e9 49 ff ff ff	 jmp	 $L72450
$L72458:

; 995  : 			}
; 996  : 		} 
; 997  : 		else
; 998  : 		{
; 999  :  
; 1000 : 			if (lp1 == &word[0])

  00ac3	3b 74 24 1c	 cmp	 esi, DWORD PTR _word$[esp+16]
  00ac7	75 59		 jne	 SHORT $L72463

; 1001 : 			{           /* Initial position.    */
; 1002 : 				if (t == PHONEME) 

  00ac9	83 f9 05	 cmp	 ecx, 5
  00acc	75 1c		 jne	 SHORT $L72464

; 1003 : 				{
; 1004 : 					ls_util_write_item(phTTS);

  00ace	57		 push	 edi
  00acf	e8 00 00 00 00	 call	 _ls_util_write_item

; 1005 : 					ls_util_read_item(phTTS);

  00ad4	57		 push	 edi
  00ad5	e8 00 00 00 00	 call	 _ls_util_read_item
  00ada	83 c4 08	 add	 esp, 8

; 1006 : 					ksf = TRUE;             /* Kept something       */

  00add	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _ksf$[esp+16], 1

; 1007 : 					continue; /* goto loop; */

  00ae5	e9 22 ff ff ff	 jmp	 $L72450
$L72464:

; 1008 : 				}
; 1009 : 
; 1010 : 				if (t==ALWAYS || (t==MIGHT && ksf==FALSE)) 

  00aea	83 f9 04	 cmp	 ecx, 4
  00aed	74 0d		 je	 SHORT $L72466
  00aef	83 f9 03	 cmp	 ecx, 3
  00af2	75 70		 jne	 SHORT $L72459
  00af4	8b 44 24 18	 mov	 eax, DWORD PTR _ksf$[esp+16]
  00af8	85 c0		 test	 eax, eax
  00afa	75 68		 jne	 SHORT $L72459
$L72466:

; 1011 : 				{
; 1012 : 
; 1013 : 					lp1->l_ch = c;

  00afc	66 89 2e	 mov	 WORD PTR [esi], bp

; 1014 : 					lp1->l_ip = NULL;

  00aff	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1015 : 					++lp1;
; 1016 : 					++lp2;
; 1017 : 					ls_util_read_item(phTTS);

  00b06	57		 push	 edi
  00b07	83 c6 08	 add	 esi, 8
  00b0a	83 c3 08	 add	 ebx, 8
  00b0d	e8 00 00 00 00	 call	 _ls_util_read_item
  00b12	83 c4 04	 add	 esp, 4

; 1018 : 					ksf = TRUE;             /* Kept something.      */

  00b15	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _ksf$[esp+16], 1

; 1019 : 					continue; /* goto loop; */

  00b1d	e9 ea fe ff ff	 jmp	 $L72450
$L72463:

; 1020 : 				}
; 1021 : 			}
; 1022 : 			else 
; 1023 : 			{
; 1024 : 				if (t==ALWAYS || (t==MIGHT && ls_util_is_might(phTTS)!=FALSE)) 

  00b22	83 f9 04	 cmp	 ecx, 4
  00b25	74 12		 je	 SHORT $L72470
  00b27	83 f9 03	 cmp	 ecx, 3
  00b2a	75 38		 jne	 SHORT $L72459
  00b2c	57		 push	 edi
  00b2d	e8 00 00 00 00	 call	 _ls_util_is_might
  00b32	83 c4 04	 add	 esp, 4
  00b35	85 c0		 test	 eax, eax
  00b37	74 2b		 je	 SHORT $L72459
$L72470:

; 1025 : 				{
; 1026 : 					if (lp1 < &word[NGWORD-1]) 

  00b39	8b 44 24 1c	 mov	 eax, DWORD PTR _word$[esp+16]
  00b3d	05 f8 03 00 00	 add	 eax, 1016		; 000003f8H
  00b42	3b f0		 cmp	 esi, eax
  00b44	73 10		 jae	 SHORT $L72471

; 1027 : 					{
; 1028 : 						lp1->l_ch = c;

  00b46	66 89 2e	 mov	 WORD PTR [esi], bp

; 1029 : 						lp1->l_ip = NULL;

  00b49	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1030 : 						++lp1;

  00b50	83 c6 08	 add	 esi, 8

; 1031 : 						++lp2;

  00b53	83 c3 08	 add	 ebx, 8
$L72471:

; 1032 : 					}
; 1033 : 					ls_util_read_item(phTTS);

  00b56	57		 push	 edi
  00b57	e8 00 00 00 00	 call	 _ls_util_read_item
  00b5c	83 c4 04	 add	 esp, 4
  00b5f	e9 a8 fe ff ff	 jmp	 $L72450
$L72459:

; 1034 : 					continue; /* goto loop; */
; 1035 : 				}
; 1036 : 			}
; 1037 : 		}
; 1038 : 		break;
; 1039 : 	}
; 1040 : 
; 1041 : 	lp1->l_ch = EOS;

  00b64	66 c7 06 00 00	 mov	 WORD PTR [esi], 0

; 1042 : 	lp1->l_ip = NULL; 

  00b69	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00b70	5f		 pop	 edi
  00b71	5e		 pop	 esi
  00b72	5d		 pop	 ebp
  00b73	5b		 pop	 ebx

; 1043 : 
; 1044 : 	
; 1045 : }

  00b74	59		 pop	 ecx
  00b75	c3		 ret	 0
_ls_task_readword ENDP
_TEXT	ENDS
EXTRN	_ls_spel_spell:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_spell_word PROC NEAR

; 1066 : 
; 1067 : 	int     speed;
; 1068 : 	PLTS_T pLts_t;
; 1069 : 	
; 1070 : 	pLts_t=phTTS->pLTSThreadData;
; 1071 : 
; 1072 : #ifdef LS1DEBUG
; 1073 : 			printf(" gok spell\n");
; 1074 : #endif
; 1075 : 		   
; 1076 : 		   
; 1077 : 	speed = FAST;/* always fast now ls_spel_spell_speed(llp, rlp);*/
; 1078 : 	pLts_t->fc_struct[pLts_t->fc_index] = FC_NOUN;
; 1079 : 	ls_spel_spell(phTTS,llp, rlp);

  00b80	8b 4c 24 0c	 mov	 ecx, DWORD PTR _rlp$[esp-4]
  00b84	8b 54 24 08	 mov	 edx, DWORD PTR _llp$[esp-4]
  00b88	56		 push	 esi
  00b89	57		 push	 edi
  00b8a	8b 7c 24 0c	 mov	 edi, DWORD PTR _phTTS$[esp+4]
  00b8e	51		 push	 ecx
  00b8f	52		 push	 edx
  00b90	57		 push	 edi
  00b91	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00b94	8b 86 bc 08 00
	00		 mov	 eax, DWORD PTR [esi+2236]
  00b9a	c7 84 86 bc 04
	00 00 00 04 00
	00		 mov	 DWORD PTR [esi+eax*4+1212], 1024 ; 00000400H
  00ba5	e8 00 00 00 00	 call	 _ls_spel_spell

; 1080 : 	if (speed!=FAST && rlp!=llp+1 && pLts_t->rbphone==WBOUND)
; 1081 : 		pLts_t->rbphone = COMMA;        
; 1082 : 	/* BATS 490 MGS 10/08/1997 fix for A. B. C. problem ??? */
; 1083 : 	if (pLts_t->rbphone==PERIOD)

  00baa	8b 86 20 11 00
	00		 mov	 eax, DWORD PTR [esi+4384]
  00bb0	83 c4 0c	 add	 esp, 12			; 0000000cH
  00bb3	83 f8 74	 cmp	 eax, 116		; 00000074H
  00bb6	75 0b		 jne	 SHORT $L72484

; 1084 : 	{
; 1085 : 		ls_util_send_phone(phTTS,PERIOD);

  00bb8	6a 74		 push	 116			; 00000074H
  00bba	57		 push	 edi
  00bbb	e8 00 00 00 00	 call	 _ls_util_send_phone
  00bc0	83 c4 08	 add	 esp, 8
$L72484:

; 1086 : 	}
; 1087 : 	ls_task_read_next_word(phTTS);

  00bc3	57		 push	 edi
  00bc4	e8 00 00 00 00	 call	 _ls_task_read_next_word
  00bc9	83 c4 04	 add	 esp, 4
  00bcc	5f		 pop	 edi
  00bcd	5e		 pop	 esi

; 1088 : }

  00bce	c3		 ret	 0
_ls_task_spell_word ENDP
_phTTS$ = 8
_ls_task_read_next_word PROC NEAR

; 1106 : {

  00bd0	53		 push	 ebx
  00bd1	56		 push	 esi

; 1107 : 	PLTS_T pLts_t;
; 1108 : 	
; 1109 : 	pLts_t=phTTS->pLTSThreadData;

  00bd2	8b 74 24 0c	 mov	 esi, DWORD PTR _phTTS$[esp+4]
  00bd6	57		 push	 edi
  00bd7	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]

; 1110 : #ifdef LS1DEBUG
; 1111 : 	printf(" got to out\n");
; 1112 : #endif
; 1113 : 	if (pLts_t->rbphone!=WBOUND && ls_util_is_white(&(pLts_t->citem))!=FALSE) 

  00bda	83 bb 20 11 00
	00 6f		 cmp	 DWORD PTR [ebx+4384], 111 ; 0000006fH
  00be1	74 66		 je	 SHORT $L72492
  00be3	8d bb 00 09 00
	00		 lea	 edi, DWORD PTR [ebx+2304]
  00be9	57		 push	 edi
  00bea	e8 00 00 00 00	 call	 _ls_util_is_white
  00bef	83 c4 04	 add	 esp, 4
  00bf2	85 c0		 test	 eax, eax
  00bf4	74 53		 je	 SHORT $L72492

; 1114 : 	{
; 1115 : 		ls_util_send_phone(phTTS,pLts_t->rbphone);

  00bf6	8b 83 20 11 00
	00		 mov	 eax, DWORD PTR [ebx+4384]
  00bfc	50		 push	 eax
  00bfd	56		 push	 esi
  00bfe	e8 00 00 00 00	 call	 _ls_util_send_phone

; 1116 : 		while (ls_util_is_white(&(pLts_t->citem)) != FALSE) 

  00c03	57		 push	 edi
  00c04	e8 00 00 00 00	 call	 _ls_util_is_white
  00c09	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c0c	85 c0		 test	 eax, eax
  00c0e	74 39		 je	 SHORT $L72492
$L72491:

; 1117 : 		{
; 1118 : 			ls_util_read_item(phTTS);

  00c10	56		 push	 esi
  00c11	e8 00 00 00 00	 call	 _ls_util_read_item

; 1119 : 			while (ls_util_is_index(&pLts_t->citem) != FALSE) 

  00c16	57		 push	 edi
  00c17	e8 00 00 00 00	 call	 _ls_util_is_index
  00c1c	83 c4 08	 add	 esp, 8
  00c1f	85 c0		 test	 eax, eax
  00c21	74 19		 je	 SHORT $L72495
$L72494:

; 1120 : 			{
; 1121 : 				ls_util_write_item(phTTS);

  00c23	56		 push	 esi
  00c24	e8 00 00 00 00	 call	 _ls_util_write_item

; 1122 : 				ls_util_read_item(phTTS);

  00c29	56		 push	 esi
  00c2a	e8 00 00 00 00	 call	 _ls_util_read_item
  00c2f	57		 push	 edi
  00c30	e8 00 00 00 00	 call	 _ls_util_is_index
  00c35	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c38	85 c0		 test	 eax, eax
  00c3a	75 e7		 jne	 SHORT $L72494
$L72495:

; 1116 : 		while (ls_util_is_white(&(pLts_t->citem)) != FALSE) 

  00c3c	57		 push	 edi
  00c3d	e8 00 00 00 00	 call	 _ls_util_is_white
  00c42	83 c4 04	 add	 esp, 4
  00c45	85 c0		 test	 eax, eax
  00c47	75 c7		 jne	 SHORT $L72491
$L72492:

; 1123 : 			}
; 1124 : 		}
; 1125 : 	}
; 1126 : 	ls_task_do_right_punct(phTTS,MISS);

  00c49	6a 00		 push	 0
  00c4b	56		 push	 esi
  00c4c	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 1127 : 	ls_task_readword(phTTS,&(pLts_t->cword[0]));

  00c51	81 c3 14 09 00
	00		 add	 ebx, 2324		; 00000914H
  00c57	53		 push	 ebx
  00c58	56		 push	 esi
  00c59	e8 00 00 00 00	 call	 _ls_task_readword
  00c5e	83 c4 10	 add	 esp, 16			; 00000010H
  00c61	5f		 pop	 edi
  00c62	5e		 pop	 esi
  00c63	5b		 pop	 ebx

; 1128 : }

  00c64	c3		 ret	 0
_ls_task_read_next_word ENDP
_TEXT	ENDS
PUBLIC	_ls_task_lookup_first_verbs
EXTRN	_whdic:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_pLts_t$ = 12
_ls_task_set_what_state PROC NEAR

; 1150 : {

  00c70	56		 push	 esi

; 1151 : 	LETTER *llp;
; 1152 : #ifdef LS1DEBUG
; 1153 : 		printf("entering ls_task_set_what_state\n");
; 1154 : #endif
; 1155 : 	if (pLts_t->wstate==UNK_WH && pLts_t->cword[0].l_ch!=EOS)

  00c71	8b 74 24 0c	 mov	 esi, DWORD PTR _pLts_t$[esp]
  00c75	33 c9		 xor	 ecx, ecx
  00c77	66 39 8e c4 08
	00 00		 cmp	 WORD PTR [esi+2244], cx
  00c7e	0f 85 8a 00 00
	00		 jne	 $L72502
  00c84	66 39 8e 14 09
	00 00		 cmp	 WORD PTR [esi+2324], cx
  00c8b	8d 86 14 09 00
	00		 lea	 eax, DWORD PTR [esi+2324]
  00c91	74 7b		 je	 SHORT $L72502

; 1156 : 	{
; 1157 : 		pLts_t->fc_index = 1;

  00c93	c7 86 bc 08 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+2236], 1

; 1158 : 		pLts_t->old_fc_index = -1;

  00c9d	c7 86 c0 08 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+2240], -1

; 1159 : 		pLts_t->fc_struct[0] = 0;

  00ca7	89 8e bc 04 00
	00		 mov	 DWORD PTR [esi+1212], ecx

; 1160 : 		pLts_t->fc_struct[1] = 0;

  00cad	89 8e c0 04 00
	00		 mov	 DWORD PTR [esi+1216], ecx

; 1161 : 		pLts_t->wstate = NOT_WH;

  00cb3	66 c7 86 c4 08
	00 00 02 00	 mov	 WORD PTR [esi+2244], 2

; 1162 : 		llp = &(pLts_t->cword[0]);
; 1163 : 		while ((lsctype[llp->l_ch]&LS) != 0)

  00cbc	0f bf 10	 movsx	 edx, WORD PTR [eax]
  00cbf	b1 40		 mov	 cl, 64			; 00000040H
  00cc1	84 0c 55 00 00
	00 00		 test	 BYTE PTR _lsctype[edx*2], cl
  00cc8	74 10		 je	 SHORT $L72505
$L72504:
  00cca	0f bf 50 08	 movsx	 edx, WORD PTR [eax+8]

; 1164 : 			++llp;                                              

  00cce	83 c0 08	 add	 eax, 8
  00cd1	84 0c 55 00 00
	00 00		 test	 BYTE PTR _lsctype[edx*2], cl
  00cd8	75 f0		 jne	 SHORT $L72504
$L72505:

; 1165 : 
; 1166 : #if defined (ENGLISH) || defined (GERMAN)
; 1167 : 		if ( (ls_task_wlookup(pLts_t, llp,&whdic[0])) != NULL)

  00cda	68 00 00 00 00	 push	 OFFSET FLAT:_whdic
  00cdf	50		 push	 eax
  00ce0	56		 push	 esi
  00ce1	e8 00 00 00 00	 call	 _ls_task_wlookup
  00ce6	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ce9	85 c0		 test	 eax, eax
  00ceb	74 09		 je	 SHORT $L72507

; 1168 : 		{
; 1169 : 			pLts_t->wstate = IS_WH;

  00ced	66 c7 86 c4 08
	00 00 01 00	 mov	 WORD PTR [esi+2244], 1
$L72507:

; 1170 : 		}        
; 1171 : #ifdef ENGLISH
; 1172 : /* MGS 8/20/97 hack for stressing first words in the sentence for kerzweil */
; 1173 : 		//eab 1/1199 Modify the stress to a secondary stress which is more appropriate.
; 1174 : 		if (ls_task_lookup_first_verbs(phTTS))

  00cf6	8b 44 24 08	 mov	 eax, DWORD PTR _phTTS$[esp]
  00cfa	50		 push	 eax
  00cfb	e8 00 00 00 00	 call	 _ls_task_lookup_first_verbs
  00d00	83 c4 04	 add	 esp, 4
  00d03	85 c0		 test	 eax, eax
  00d05	74 2b		 je	 SHORT $L72510

; 1175 : 			return(FINISHED_WORD);

  00d07	b8 03 00 00 00	 mov	 eax, 3
  00d0c	5e		 pop	 esi

; 1208 : }

  00d0d	c3		 ret	 0
$L72502:

; 1176 : #endif
; 1177 : #endif
; 1178 : #ifdef SPANISH
; 1179 : 	  	if ((ls_task_wlookup(pLts_t, llp, &spwhword[0])) != NULL)
; 1180 : 			{
; 1181 : 				/*we need to look at potential legal combinations of wh
; 1182 : 					question introducers so if first word is an introducer
; 1183 : 					then firstnum !=0 and wstate is rest to UNK_wh indicating
; 1184 : 					beginning of sentence*/
; 1185 : /* 		   sendlist(cp);*/
; 1186 : 			pLts_t->wstate = IS_WH;
; 1187 : /*			goto out; */
; 1188 : 			}
; 1189 : 	  	else if (ls_task_wlookup(pLts_t, llp, &spwhword[0]) != NULL)
; 1190 : 			{
; 1191 : 			pLts_t->wstate = UNK_WH;			
; 1192 : 						/*pretend start of sentence*/
; 1193 : 						/*becuase got an intro word*/
; 1194 : 			}
; 1195 : 
; 1196 : #endif
; 1197 : 		
; 1198 : 	}   /*  if (pLts_t->wstate==UNK_WH && cword[0].l_ch!=EOS) */
; 1199 : 	else
; 1200 : 	{
; 1201 : 		if((pLts_t->cword[0].l_ch!=SIL ) && pLts_t->fc_index != sizeof(pLts_t->fc_struct)/4)

  00d0e	66 39 8e 14 09
	00 00		 cmp	 WORD PTR [esi+2324], cx
  00d15	74 1b		 je	 SHORT $L72510
  00d17	8b 86 bc 08 00
	00		 mov	 eax, DWORD PTR [esi+2236]
  00d1d	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00d22	74 0e		 je	 SHORT $L72510

; 1202 : 		{
; 1203 : 			pLts_t->fc_index += 1;

  00d24	40		 inc	 eax
  00d25	89 86 bc 08 00
	00		 mov	 DWORD PTR [esi+2236], eax

; 1204 : 			pLts_t->fc_struct[pLts_t->fc_index] = 0;

  00d2b	89 8c 86 bc 04
	00 00		 mov	 DWORD PTR [esi+eax*4+1212], ecx
$L72510:

; 1205 : 		}
; 1206 : 	}   /*  if (pLts_t->wstate==UNK_WH && cword[0].l_ch!=EOS) */
; 1207 : 	return(KEEP_SEARCHING);

  00d32	33 c0		 xor	 eax, eax
  00d34	5e		 pop	 esi

; 1208 : }

  00d35	c3		 ret	 0
_ls_task_set_what_state ENDP
_llp$ = 8
_rlp$ = 12
_elp$ = 16
_ls_task_find_end_of_word PROC NEAR

; 1231 : #ifdef LS1DEBUG
; 1232 : 		printf("entering ls_task_find_end_of_word\n");
; 1233 : #endif
; 1234 : 	(*elp) = llp;

  00d40	8b 44 24 0c	 mov	 eax, DWORD PTR _elp$[esp-4]
  00d44	8b 4c 24 04	 mov	 ecx, DWORD PTR _llp$[esp-4]
  00d48	89 08		 mov	 DWORD PTR [eax], ecx

; 1235 : 	while ((*elp)->l_ch != EOS) /* find the end of the word ?? */

  00d4a	66 83 39 00	 cmp	 WORD PTR [ecx], 0
  00d4e	74 16		 je	 SHORT $L73060
$L72519:

; 1236 : 	{
; 1237 : #ifdef LS1DEBUG
; 1238 : 			printf(" %02x %c \n",(*elp)->l_ch,(*elp)->l_ch);
; 1239 : #endif   
; 1240 : 		
; 1241 : 		++(*elp);               

  00d50	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d52	83 c1 08	 add	 ecx, 8
  00d55	89 08		 mov	 DWORD PTR [eax], ecx
  00d57	66 83 39 00	 cmp	 WORD PTR [ecx], 0
  00d5b	75 f3		 jne	 SHORT $L72519

; 1242 : 	}
; 1243 : #ifdef LS1DEBUG
; 1244 : 		printf (" %02x %c \n",(*elp)->l_ch,(*elp)->l_ch);
; 1245 : #endif
; 1246 : 	
; 1247 : 	(*rlp) = (*elp);

  00d5d	8b c1		 mov	 eax, ecx
  00d5f	8b 4c 24 08	 mov	 ecx, DWORD PTR _rlp$[esp-4]
  00d63	89 01		 mov	 DWORD PTR [ecx], eax

; 1248 : 	
; 1249 : #ifdef LS1DEBUG
; 1250 : 		printf("found the end of word ");
; 1251 : 		printf("left=%u  right=%u\n",llp,*rlp);
; 1252 : #endif    
; 1253 : 
; 1254 : }

  00d65	c3		 ret	 0
$L73060:

; 1242 : 	}
; 1243 : #ifdef LS1DEBUG
; 1244 : 		printf (" %02x %c \n",(*elp)->l_ch,(*elp)->l_ch);
; 1245 : #endif
; 1246 : 	
; 1247 : 	(*rlp) = (*elp);

  00d66	8b 10		 mov	 edx, DWORD PTR [eax]
  00d68	8b 44 24 08	 mov	 eax, DWORD PTR _rlp$[esp-4]
  00d6c	89 10		 mov	 DWORD PTR [eax], edx

; 1248 : 	
; 1249 : #ifdef LS1DEBUG
; 1250 : 		printf("found the end of word ");
; 1251 : 		printf("left=%u  right=%u\n",llp,*rlp);
; 1252 : #endif    
; 1253 : 
; 1254 : }

  00d6e	c3		 ret	 0
_ls_task_find_end_of_word ENDP
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_spell_mode PROC NEAR

; 1280 : {

  00d70	56		 push	 esi

; 1281 : 	/*
; 1282 : 	 * Word spelling.
; 1283 : 	 * A new feature for AT&T - IS.
; 1284 : 	 * Spell the word using the fast spelling speed.
; 1285 : 	 * These is some special code in "ls_task_do_right_punct" that
; 1286 : 	 * helps out word spelling, by speaking " "
; 1287 : 	 * (between words) as COMMA.
; 1288 : 	 */  
; 1289 : 	PLTS_T  pLts_t;
; 1290 : 	PKSD_T  pKsd_t;
; 1291 : 
; 1292 : 	pLts_t = phTTS->pLTSThreadData;

  00d71	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  00d75	57		 push	 edi

; 1293 : 	pKsd_t = phTTS->pKernelShareData;   
; 1294 : 
; 1295 : #ifdef LS1DEBUG
; 1296 : 		printf("entering ls_task_spell_mode\n");
; 1297 : #endif
; 1298 : 	if ((pKsd_t->modeflag&MODE_SPELL)!=0) 

  00d76	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00d79	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00d7c	f6 80 00 02 00
	00 10		 test	 BYTE PTR [eax+512], 16	; 00000010H
  00d83	74 30		 je	 SHORT $L72530

; 1299 : 	{
; 1300 : 
; 1301 : #ifdef LS1DEBUG
; 1302 : 		printf(" mode spell spell\n");
; 1303 : #endif
; 1304 : 
; 1305 : 		ls_spel_spell(phTTS,llp, rlp);

  00d85	8b 4c 24 14	 mov	 ecx, DWORD PTR _rlp$[esp+4]
  00d89	8b 54 24 10	 mov	 edx, DWORD PTR _llp$[esp+4]
  00d8d	51		 push	 ecx
  00d8e	52		 push	 edx
  00d8f	56		 push	 esi
  00d90	e8 00 00 00 00	 call	 _ls_spel_spell

; 1306 : 		ls_task_do_right_punct(phTTS,MISS);

  00d95	6a 00		 push	 0
  00d97	56		 push	 esi
  00d98	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 1307 : 		ls_task_readword(phTTS,&(pLts_t->cword[0]));

  00d9d	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  00da3	57		 push	 edi
  00da4	56		 push	 esi
  00da5	e8 00 00 00 00	 call	 _ls_task_readword
  00daa	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1308 : 
; 1309 : 		return(LS_TASK_LOOP);

  00dad	b8 01 00 00 00	 mov	 eax, 1
  00db2	5f		 pop	 edi
  00db3	5e		 pop	 esi

; 1312 : }

  00db4	c3		 ret	 0
$L72530:
  00db5	5f		 pop	 edi

; 1310 : 	}                  
; 1311 : 	return(KEEP_SEARCHING);

  00db6	33 c0		 xor	 eax, eax
  00db8	5e		 pop	 esi

; 1312 : }

  00db9	c3		 ret	 0
_ls_task_spell_mode ENDP
_TEXT	ENDS
EXTRN	_sdic:BYTE
EXTRN	_ls_util_send_phone_list:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_ls_task_minidic_search PROC NEAR

; 1340 : #if (defined ENGLISH) || (defined SPANISH)
; 1341 : 	char    *cp;
; 1342 : 	PLTS_T  pLts_t;
; 1343 : 	PKSD_T  pKsd_t;
; 1344 : 
; 1345 : 	pLts_t = phTTS->pLTSThreadData;
; 1346 : 	pKsd_t = phTTS->pKernelShareData;   
; 1347 : #ifdef LS1DEBUG
; 1348 : 		printf("entering ls_task_minidic_search\n");
; 1349 : #endif
; 1350 : 	if ( (cp = (char *)ls_task_wlookup(pLts_t, llp,&sdic[0])) != NULL)

  00dc0	8b 44 24 08	 mov	 eax, DWORD PTR _llp$[esp-4]
  00dc4	56		 push	 esi
  00dc5	57		 push	 edi
  00dc6	8b 7c 24 0c	 mov	 edi, DWORD PTR _phTTS$[esp+4]
  00dca	68 00 00 00 00	 push	 OFFSET FLAT:_sdic
  00dcf	50		 push	 eax
  00dd0	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00dd3	56		 push	 esi
  00dd4	e8 00 00 00 00	 call	 _ls_task_wlookup
  00dd9	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ddc	85 c0		 test	 eax, eax
  00dde	74 23		 je	 SHORT $L72543

; 1351 : 	{       /*eab mini dictionary lookup */
; 1352 : 		ls_util_send_phone_list(phTTS,cp);

  00de0	50		 push	 eax
  00de1	57		 push	 edi
  00de2	e8 00 00 00 00	 call	 _ls_util_send_phone_list
  00de7	83 c4 08	 add	 esp, 8

; 1353 : 		pLts_t->lbphone=WBOUND;

  00dea	b8 6f 00 00 00	 mov	 eax, 111		; 0000006fH
  00def	89 86 1c 11 00
	00		 mov	 DWORD PTR [esi+4380], eax

; 1354 : 		pLts_t->rbphone=WBOUND;

  00df5	89 86 20 11 00
	00		 mov	 DWORD PTR [esi+4384], eax
  00dfb	5f		 pop	 edi

; 1355 : 		return(FINISHED_WORD);

  00dfc	b8 03 00 00 00	 mov	 eax, 3
  00e01	5e		 pop	 esi

; 1359 : }

  00e02	c3		 ret	 0
$L72543:
  00e03	5f		 pop	 edi

; 1356 : 	}
; 1357 : #endif
; 1358 : 	return(KEEP_SEARCHING);

  00e04	33 c0		 xor	 eax, eax
  00e06	5e		 pop	 esi

; 1359 : }

  00e07	c3		 ret	 0
_ls_task_minidic_search ENDP
_TEXT	ENDS
EXTRN	_ls_math_do_math:NEAR
_TEXT	SEGMENT
_pKsd_t$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_math_mode PROC NEAR

; 1386 : 	if (llp+1==rlp && (pKsd_t->modeflag & MODE_MATH))   

  00e10	8b 4c 24 08	 mov	 ecx, DWORD PTR _llp$[esp-4]
  00e14	8b 54 24 0c	 mov	 edx, DWORD PTR _rlp$[esp-4]
  00e18	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00e1b	3b c2		 cmp	 eax, edx
  00e1d	75 23		 jne	 SHORT $L72553
  00e1f	8b 44 24 04	 mov	 eax, DWORD PTR _pKsd_t$[esp-4]
  00e23	f6 80 00 02 00
	00 04		 test	 BYTE PTR [eax+512], 4
  00e2a	74 16		 je	 SHORT $L72553

; 1387 : 	{
; 1388 : 		if (ls_math_do_math(pKsd_t,(unsigned char )llp->l_ch)!=FALSE)

  00e2c	8a 09		 mov	 cl, BYTE PTR [ecx]
  00e2e	51		 push	 ecx
  00e2f	50		 push	 eax
  00e30	e8 00 00 00 00	 call	 _ls_math_do_math
  00e35	83 c4 08	 add	 esp, 8
  00e38	85 c0		 test	 eax, eax
  00e3a	74 06		 je	 SHORT $L72553

; 1389 : 			return(FINISHED_WORD);

  00e3c	b8 03 00 00 00	 mov	 eax, 3

; 1392 : }

  00e41	c3		 ret	 0
$L72553:

; 1390 : 	}
; 1391 : 	return(KEEP_SEARCHING);

  00e42	33 c0		 xor	 eax, eax

; 1392 : }

  00e44	c3		 ret	 0
_ls_task_math_mode ENDP
_TEXT	ENDS
EXTRN	_ls_util_lookup:NEAR
EXTRN	_ls_util_is_dot:NEAR
EXTRN	_nabtab:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_dictionary_search PROC NEAR

; 1419 : 	int flag,i,count;
; 1420 : 	int context;
; 1421 : 	char    *cp;
; 1422 : 	PLTS_T pLts_t;
; 1423 : 	
; 1424 : 	pLts_t = phTTS->pLTSThreadData;
; 1425 : 
; 1426 : #ifdef LS1DEBUG
; 1427 : 		printf("entering ls_task_dictionary_search\n");
; 1428 : #endif
; 1429 : 
; 1430 : 	/*
; 1431 : 	 * Before you do *anything*, look up the word
; 1432 : 	 * in the dictionaries. This gives the client the ability
; 1433 : 	 * to override almost any built in rules (the only rules that
; 1434 : 	 * must be used are the word framing rules). There are
; 1435 : 	 * two big cases. If the word is at least 2 characters long,
; 1436 : 	 * and the last character is a ".", then look up the root
; 1437 : 	 * with the "." stripped (this is the "Gov.." case). There
; 1438 : 	 * is no additional processing. Else check if the next
; 1439 : 	 * character is a "."; if there is an abbreviation hit then
; 1440 : 	 * the "." has to be eaten.
; 1441 : 	 */
; 1442 : 
; 1443 : 	/* 
; 1444 : 	 * The dictionary uses the fact that it never gets passed a word
; 1445 : 	 *	with a space at the bigging to store items that are to be spelled
; 1446 : 	 *	in the spell routine but don't want to hit here such as numbers.
; 1447 : 	 *	with numbers it does a ls_task_lookahead to see if the next item is in
; 1448 : 	 *	nabtab
; 1449 : 	 */
; 1450 : 
; 1451 : #ifdef LS1DEBUG
; 1452 : 	printf("%c %02x -- %c %02x\n",llp->l_ch,llp->l_ch,(llp+1)->l_ch,(llp+1)->l_ch);
; 1453 : #endif
; 1454 : 
; 1455 : 	if (rlp>=llp+2 && (rlp-1)->l_ch=='.')

  00e50	8b 44 24 0c	 mov	 eax, DWORD PTR _rlp$[esp-4]
  00e54	53		 push	 ebx
  00e55	55		 push	 ebp
  00e56	8b 6c 24 10	 mov	 ebp, DWORD PTR _llp$[esp+4]
  00e5a	56		 push	 esi
  00e5b	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  00e5f	8d 4d 10	 lea	 ecx, DWORD PTR [ebp+16]
  00e62	57		 push	 edi
  00e63	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00e66	3b c1		 cmp	 eax, ecx
  00e68	72 24		 jb	 SHORT $L72567
  00e6a	83 c0 f8	 add	 eax, -8			; fffffff8H
  00e6d	66 83 38 2e	 cmp	 WORD PTR [eax], 46	; 0000002eH
  00e71	75 1b		 jne	 SHORT $L72567

; 1456 : 	{
; 1457 : 		if ((flag=ls_util_lookup(phTTS,llp, rlp-1, FABBREV)) != MISS)

  00e73	6a 01		 push	 1
  00e75	50		 push	 eax
  00e76	55		 push	 ebp
  00e77	56		 push	 esi
  00e78	e8 00 00 00 00	 call	 _ls_util_lookup
  00e7d	83 c4 10	 add	 esp, 16			; 00000010H
  00e80	85 c0		 test	 eax, eax
  00e82	0f 84 cc 00 00
	00		 je	 $L72578

; 1458 : 		{
; 1459 : 			ls_task_do_right_punct(phTTS,flag);

  00e88	50		 push	 eax

; 1460 : 			ls_task_readword(phTTS,&(pLts_t->cword[0]));
; 1461 : 			return(LS_TASK_LOOP);

  00e89	e9 a6 00 00 00	 jmp	 $L73069
$L72567:

; 1462 : 		}
; 1463 : 	}
; 1464 : 	else
; 1465 : 	{
; 1466 : 		context = FIRST;
; 1467 : 		if (ls_util_is_dot(pLts_t) != FALSE)

  00e8e	57		 push	 edi
  00e8f	33 db		 xor	 ebx, ebx
  00e91	e8 00 00 00 00	 call	 _ls_util_is_dot
  00e96	83 c4 04	 add	 esp, 4
  00e99	85 c0		 test	 eax, eax
  00e9b	74 05		 je	 SHORT $L72570

; 1468 : 		{
; 1469 : 			context = FABBREV;

  00e9d	bb 01 00 00 00	 mov	 ebx, 1
$L72570:

; 1470 : 		}
; 1471 : 		/* xxxx eab 9/94 added to take care of 5 sq. ft. double
; 1472 : 			abbrev in context*/
; 1473 : 		/* Change 7/11/96 to fix 5 sq. ft. problem by removing pLts_t->isnumab.  GL */
; 1474 : 		/* GL 11/21/1996, set the handling approach based on the language */
; 1475 : 		/* GL 02/25/1997, restore pLts_t->isnumabr back  */  
; 1476 : #ifdef ENGLISH
; 1477 : 		if(pLts_t->isnumabr && context == FABBREV &&
; 1478 : 			(cp=(char *)ls_task_wlookup (pLts_t, &(pLts_t->cword[0]), &nabtab[0])) != NULL)

  00ea2	8b 87 fc 08 00
	00		 mov	 eax, DWORD PTR [edi+2300]
  00ea8	85 c0		 test	 eax, eax
  00eaa	74 63		 je	 SHORT $L72573
  00eac	83 fb 01	 cmp	 ebx, 1
  00eaf	75 5e		 jne	 SHORT $L72573
  00eb1	8d af 14 09 00
	00		 lea	 ebp, DWORD PTR [edi+2324]
  00eb7	68 00 00 00 00	 push	 OFFSET FLAT:_nabtab
  00ebc	55		 push	 ebp
  00ebd	57		 push	 edi
  00ebe	e8 00 00 00 00	 call	 _ls_task_wlookup
  00ec3	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ec6	85 c0		 test	 eax, eax
  00ec8	74 41		 je	 SHORT $L73068

; 1479 : #endif
; 1480 : #ifdef SPANISH
; 1481 : 		/* GL 10/05/1998, Handle Spanish number abbreviation like German */
; 1482 : 		/* if(pLts_t->isnumabr && context == FABBREV && */
; 1483 : 		if(pLts_t->isnumabr &&
; 1484 : 			(cp=(char *)ls_task_wlookup (pLts_t, &(pLts_t->cword[0]), &nabtab[0])) != NULL)
; 1485 : #endif
; 1486 : #ifdef GERMAN
; 1487 : 		if(pLts_t->isnumabr &&
; 1488 : 			(cp=(char *)ls_task_wlookup (pLts_t, &(pLts_t->cword[0]), &nabtab[0])) != NULL)
; 1489 : #endif
; 1490 : 		{
; 1491 : 			if(pLts_t->pflag != FALSE)      /* Pick right form.     */

  00eca	8b 8f 24 11 00
	00		 mov	 ecx, DWORD PTR [edi+4388]
  00ed0	85 c9		 test	 ecx, ecx
  00ed2	74 0e		 je	 SHORT $L72577

; 1492 : 			{
; 1493 : 				while (*cp++ != SIL);

  00ed4	8a 10		 mov	 dl, BYTE PTR [eax]
  00ed6	40		 inc	 eax
  00ed7	84 d2		 test	 dl, dl
  00ed9	74 07		 je	 SHORT $L72577
$L72576:
  00edb	8a 08		 mov	 cl, BYTE PTR [eax]
  00edd	40		 inc	 eax
  00ede	84 c9		 test	 cl, cl
  00ee0	75 f9		 jne	 SHORT $L72576
$L72577:

; 1494 : 			}
; 1495 : 			ls_util_send_phone_list(phTTS,cp);  /* Send abbreviation.    */

  00ee2	50		 push	 eax
  00ee3	56		 push	 esi
  00ee4	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 1496 : 			ls_util_read_item(phTTS);             /* Eat up the ".".      */

  00ee9	56		 push	 esi
  00eea	e8 00 00 00 00	 call	 _ls_util_read_item

; 1497 : 			ls_task_do_right_punct(phTTS,MISS);

  00eef	6a 00		 push	 0
  00ef1	56		 push	 esi
  00ef2	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 1498 : 			ls_task_readword(phTTS,&(pLts_t->cword[0]));    /* Advance, continue.   */

  00ef7	55		 push	 ebp
  00ef8	56		 push	 esi
  00ef9	e8 00 00 00 00	 call	 _ls_task_readword
  00efe	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1499 : 			return(LS_TASK_LOOP);

  00f01	b8 01 00 00 00	 mov	 eax, 1
  00f06	5f		 pop	 edi
  00f07	5e		 pop	 esi
  00f08	5d		 pop	 ebp
  00f09	5b		 pop	 ebx

; 1556 : }

  00f0a	c3		 ret	 0
$L73068:

; 1499 : 			return(LS_TASK_LOOP);

  00f0b	8b 6c 24 18	 mov	 ebp, DWORD PTR _llp$[esp+12]
$L72573:

; 1500 : 		}
; 1501 : 		
; 1502 : 		if ((flag=ls_util_lookup(phTTS,llp, rlp, context)) != MISS)

  00f0f	8b 54 24 1c	 mov	 edx, DWORD PTR _rlp$[esp+12]
  00f13	53		 push	 ebx
  00f14	52		 push	 edx
  00f15	55		 push	 ebp
  00f16	56		 push	 esi
  00f17	e8 00 00 00 00	 call	 _ls_util_lookup
  00f1c	8b d8		 mov	 ebx, eax
  00f1e	83 c4 10	 add	 esp, 16			; 00000010H
  00f21	85 db		 test	 ebx, ebx
  00f23	74 2f		 je	 SHORT $L72578

; 1503 : 		{
; 1504 : 			if (flag == ABBREV)     /* Need to gobble up    */

  00f25	83 fb 02	 cmp	 ebx, 2
  00f28	75 09		 jne	 SHORT $L72579

; 1505 : 				ls_util_read_item(phTTS);                     /* the "." here.        */

  00f2a	56		 push	 esi
  00f2b	e8 00 00 00 00	 call	 _ls_util_read_item
  00f30	83 c4 04	 add	 esp, 4
$L72579:

; 1506 : 			ls_task_do_right_punct(phTTS,flag);

  00f33	53		 push	 ebx
$L73069:
  00f34	56		 push	 esi
  00f35	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 1507 : 
; 1508 : 			ls_task_readword(phTTS,&(pLts_t->cword[0]));

  00f3a	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  00f40	57		 push	 edi
  00f41	56		 push	 esi
  00f42	e8 00 00 00 00	 call	 _ls_task_readword
  00f47	83 c4 10	 add	 esp, 16			; 00000010H

; 1509 : 
; 1510 : 			return(LS_TASK_LOOP);

  00f4a	b8 01 00 00 00	 mov	 eax, 1
  00f4f	5f		 pop	 edi
  00f50	5e		 pop	 esi
  00f51	5d		 pop	 ebp
  00f52	5b		 pop	 ebx

; 1556 : }

  00f53	c3		 ret	 0
$L72578:
  00f54	5f		 pop	 edi
  00f55	5e		 pop	 esi
  00f56	5d		 pop	 ebp

; 1511 : 		}
; 1512 : 	}
; 1513 : 	/*eab 1/5/99 temporary code for ce to reduce dictionary
; 1514 : 	will get more eligant with the re-write*/
; 1515 : 
; 1516 : 	/* this is fir a class of imxxx words */
; 1517 : #ifdef nevermore	
; 1518 : 	if( (   (llp->l_ch,llp->l_ch == 'i')&& 
; 1519 : 		(llp+1)->l_ch == 'm')&&
; 1520 : 		(  (llp+2)->l_ch == 'p'||
; 1521 : 		(llp+2)->l_ch == 'b' )
; 1522 : 		)
; 1523 : 	{
; 1524 : 		ls_util_send_phone(phTTS,IX);
; 1525 : 		ls_util_send_phone(phTTS,M);
; 1526 : 		for(i=0;i<NGWORD;i++)
; 1527 : 		{
; 1528 : 			pLts_t->cword[i] = pLts_t->cword[i+2];
; 1529 : 		}
; 1530 : 		return(-2);
; 1531 : 	}
; 1532 : #endif
; 1533 : 
; 1534 : 		/*eab 1/5/99 temporary code for ce to reduce dictionary
; 1535 : 	will get more eligant with the re-write*/
; 1536 : #ifdef WORK_IN_PROGRESS
; 1537 : 
; 1538 : 	if ( (cp = (char *)ls_task_prelookup(pLts_t, llp, &count,&predic[0])) != NULL)
; 1539 : 	{       /*eab mini dictionary lookup */
; 1540 : 		ls_util_send_phone_list(phTTS,cp);
; 1541 : 		pLts_t->lbphone = WBOUND;
; 1542 : 		// pLts_t->rbphone = WBOUND;
; 1543 : 		// ls_util_send_phone(phTTS,IX);
; 1544 : 		// ls_util_send_phone(phTTS,N);
; 1545 : 		for(i=0; i<NGWORD; i++)
; 1546 : 		{
; 1547 : 			pLts_t->cword[i] = pLts_t->cword[i+count];
; 1548 : 			if(pLts_t->cword[i+2]. l_ch == '0')
; 1549 : 				break;
; 1550 : 		}
; 1551 : 		return(-count);
; 1552 : 	}
; 1553 : #endif 
; 1554 : 
; 1555 : 	return(KEEP_SEARCHING);

  00f57	33 c0		 xor	 eax, eax
  00f59	5b		 pop	 ebx

; 1556 : }

  00f5a	c3		 ret	 0
_ls_task_dictionary_search ENDP
_pLts_t$ = 8
_llp$ = 12
_ls_task_strip_left_punctuation PROC NEAR

; 1578 : 	/*
; 1579 : 	 * Pull off all left and
; 1580 : 	 * right enclosing punctuation. We only pull one
; 1581 : 	 * layer, so ((a)) gets spelled (it seems like the right
; 1582 : 	 * thing). Keep track of any required pauses. Also watch
; 1583 : 	 * for things like "I went (last year?) to the show".
; 1584 : 	 * Shuffle the "?" to the right spot. We don't shuffle the
; 1585 : 	 * ".", because it might be part of an abbreviation,
; 1586 : 	 * and abbreviations are more common than imbedded
; 1587 : 	 * periods.
; 1588 : 	 */
; 1589 : #ifdef LS1DEBUG
; 1590 : 		printf("entering ls_task_strip_left_punctuation\n");
; 1591 : #endif
; 1592 : 	 pLts_t->lflag  = 0;                             /* Clear all flags.     */

  00f60	8b 4c 24 04	 mov	 ecx, DWORD PTR _pLts_t$[esp-4]

; 1593 : 
; 1594 : #ifdef LS1DEBUG
; 1595 : 	printf("before punctuation stripping ");
; 1596 : 	printf("left=%u  right=%u\n",(*llp),rlp);
; 1597 : #endif
; 1598 : 	pLts_t->lbphone = WBOUND;

  00f64	b8 6f 00 00 00	 mov	 eax, 111		; 0000006fH
  00f69	89 81 1c 11 00
	00		 mov	 DWORD PTR [ecx+4380], eax

; 1599 : 	pLts_t->rbphone = WBOUND;

  00f6f	89 81 20 11 00
	00		 mov	 DWORD PTR [ecx+4384], eax

; 1600 : 	/* Change this "while" to an "if" to strip only 1 layer.        */
; 1601 : 	while ((lsctype[(*llp)->l_ch]&LS) != 0)

  00f75	8b 44 24 08	 mov	 eax, DWORD PTR _llp$[esp-4]
  00f79	c7 81 f8 08 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+2296], 0
  00f83	8b 10		 mov	 edx, DWORD PTR [eax]
  00f85	0f bf 12	 movsx	 edx, WORD PTR [edx]
  00f88	f6 04 55 00 00
	00 00 40	 test	 BYTE PTR _lsctype[edx*2], 64 ; 00000040H
  00f90	74 3c		 je	 SHORT $L72589
$L72588:

; 1602 : 	{                    
; 1603 : #ifdef LS1DEBUG
; 1604 : 			printf("in left stripping loop %c\n",(*llp)->l_ch);
; 1605 : #endif
; 1606 : 		pLts_t->lflag |= LSTRIP;

  00f92	8b 91 f8 08 00
	00		 mov	 edx, DWORD PTR [ecx+2296]
  00f98	83 ca 01	 or	 edx, 1
  00f9b	89 91 f8 08 00
	00		 mov	 DWORD PTR [ecx+2296], edx

; 1607 : 		if ((lsctype[(*llp)->l_ch]&FB) != 0)

  00fa1	8b 10		 mov	 edx, DWORD PTR [eax]
  00fa3	0f bf 12	 movsx	 edx, WORD PTR [edx]
  00fa6	f6 04 55 01 00
	00 00 01	 test	 BYTE PTR _lsctype[edx*2+1], 1
  00fae	74 0a		 je	 SHORT $L72590

; 1608 : 		{
; 1609 : 			pLts_t->lbphone = COMMA;

  00fb0	c7 81 1c 11 00
	00 73 00 00 00	 mov	 DWORD PTR [ecx+4380], 115 ; 00000073H
$L72590:

; 1610 : 		}
; 1611 : 		++(*llp);

  00fba	8b 10		 mov	 edx, DWORD PTR [eax]
  00fbc	83 c2 08	 add	 edx, 8
  00fbf	89 10		 mov	 DWORD PTR [eax], edx
  00fc1	0f bf 12	 movsx	 edx, WORD PTR [edx]
  00fc4	f6 04 55 00 00
	00 00 40	 test	 BYTE PTR _lsctype[edx*2], 64 ; 00000040H
  00fcc	75 c4		 jne	 SHORT $L72588
$L72589:

; 1612 : 	}
; 1613 : }           

  00fce	c3		 ret	 0
_ls_task_strip_left_punctuation ENDP
_pLts_t$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_strip_right_punctuation PROC NEAR

; 1635 : #ifdef LS1DEBUG
; 1636 : 		printf("entering ls_task_strip_right_punctuation\n");
; 1637 : #endif
; 1638 : 	/* Change this "while" to an "if" to strip only 1 layer.        */
; 1639 : 	while ((*rlp)!=llp && (lsctype[((*rlp)-1)->l_ch]&RS)!=0) 

  00fd0	8b 44 24 0c	 mov	 eax, DWORD PTR _rlp$[esp-4]
  00fd4	55		 push	 ebp
  00fd5	56		 push	 esi
  00fd6	57		 push	 edi
  00fd7	8b 10		 mov	 edx, DWORD PTR [eax]
  00fd9	8b 7c 24 14	 mov	 edi, DWORD PTR _llp$[esp+8]
  00fdd	3b d7		 cmp	 edx, edi
  00fdf	0f 84 8f 00 00
	00		 je	 $L72600
  00fe5	8b 4c 24 10	 mov	 ecx, DWORD PTR _pLts_t$[esp+8]
  00fe9	bd 73 00 00 00	 mov	 ebp, 115		; 00000073H
$L72599:
  00fee	0f bf 52 f8	 movsx	 edx, WORD PTR [edx-8]
  00ff2	f6 04 55 00 00
	00 00 80	 test	 BYTE PTR _lsctype[edx*2], 128 ; 00000080H
  00ffa	74 78		 je	 SHORT $L72600

; 1640 : 	{
; 1641 : #ifdef LS1DEBUG
; 1642 : 			printf("in right stripping loop %c\n",llp->l_ch);
; 1643 : #endif
; 1644 : 		pLts_t->lflag |= RSTRIP;

  00ffc	8b b1 f8 08 00
	00		 mov	 esi, DWORD PTR [ecx+2296]
  01002	83 ce 02	 or	 esi, 2
  01005	89 b1 f8 08 00
	00		 mov	 DWORD PTR [ecx+2296], esi

; 1645 : 		--(*rlp);

  0100b	8b 10		 mov	 edx, DWORD PTR [eax]
  0100d	83 c2 f8	 add	 edx, -8			; fffffff8H
  01010	89 10		 mov	 DWORD PTR [eax], edx

; 1646 : 		if ((lsctype[(*rlp)->l_ch]&FB) != 0)

  01012	0f bf 12	 movsx	 edx, WORD PTR [edx]
  01015	f6 04 55 01 00
	00 00 01	 test	 BYTE PTR _lsctype[edx*2+1], 1
  0101d	74 06		 je	 SHORT $L72601

; 1647 : 		{
; 1648 : 			pLts_t->rbphone = COMMA;

  0101f	89 a9 20 11 00
	00		 mov	 DWORD PTR [ecx+4384], ebp
$L72601:

; 1649 : 		}
; 1650 : 		if ((*rlp) > llp+1) 

  01025	8b 10		 mov	 edx, DWORD PTR [eax]
  01027	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
  0102a	3b d6		 cmp	 edx, esi
  0102c	76 3c		 jbe	 SHORT $L72604

; 1651 : 		{
; 1652 : 			switch (((*rlp)-1)->l_ch) 
; 1653 : 			{

  0102e	0f bf 52 f8	 movsx	 edx, WORD PTR [edx-8]
  01032	8d 72 df	 lea	 esi, DWORD PTR [edx-33]
  01035	83 fe 1e	 cmp	 esi, 30			; 0000001eH
  01038	77 30		 ja	 SHORT $L72604
  0103a	33 d2		 xor	 edx, edx
  0103c	8a 96 00 00 00
	00		 mov	 dl, BYTE PTR $L73076[esi]
  01042	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L73077[edx*4]
$L72607:

; 1654 : 			case '?':
; 1655 : 				pLts_t->rbphone = QUEST;

  01049	c7 81 20 11 00
	00 75 00 00 00	 mov	 DWORD PTR [ecx+4384], 117 ; 00000075H

; 1656 : 				--(*rlp);
; 1657 : 				break;

  01053	eb 12		 jmp	 SHORT $L73075
$L72608:

; 1658 : 
; 1659 : 			case '!':
; 1660 : 				pLts_t->rbphone = EXCLAIM;

  01055	c7 81 20 11 00
	00 76 00 00 00	 mov	 DWORD PTR [ecx+4384], 118 ; 00000076H

; 1661 : 				--(*rlp);
; 1662 : 				break;

  0105f	eb 06		 jmp	 SHORT $L73075
$L72609:

; 1663 : 
; 1664 : 			case ',':
; 1665 : 			case ':':
; 1666 : 			case ';':
; 1667 : 				pLts_t->rbphone = COMMA;

  01061	89 a9 20 11 00
	00		 mov	 DWORD PTR [ecx+4384], ebp
$L73075:

; 1668 : 				--(*rlp);

  01067	83 00 f8	 add	 DWORD PTR [eax], -8	; fffffff8H
$L72604:
  0106a	8b 10		 mov	 edx, DWORD PTR [eax]
  0106c	3b d7		 cmp	 edx, edi
  0106e	0f 85 7a ff ff
	ff		 jne	 $L72599
$L72600:
  01074	5f		 pop	 edi
  01075	5e		 pop	 esi
  01076	5d		 pop	 ebp

; 1669 : 				break;
; 1670 : 			}
; 1671 : 		}
; 1672 : 	}
; 1673 : }

  01077	c3		 ret	 0
$L73077:
  01078	00 00 00 00	 DD	 $L72608
  0107c	00 00 00 00	 DD	 $L72609
  01080	00 00 00 00	 DD	 $L72607
  01084	00 00 00 00	 DD	 $L72604
$L73076:
  01088	00		 DB	 0
  01089	03		 DB	 3
  0108a	03		 DB	 3
  0108b	03		 DB	 3
  0108c	03		 DB	 3
  0108d	03		 DB	 3
  0108e	03		 DB	 3
  0108f	03		 DB	 3
  01090	03		 DB	 3
  01091	03		 DB	 3
  01092	03		 DB	 3
  01093	01		 DB	 1
  01094	03		 DB	 3
  01095	03		 DB	 3
  01096	03		 DB	 3
  01097	03		 DB	 3
  01098	03		 DB	 3
  01099	03		 DB	 3
  0109a	03		 DB	 3
  0109b	03		 DB	 3
  0109c	03		 DB	 3
  0109d	03		 DB	 3
  0109e	03		 DB	 3
  0109f	03		 DB	 3
  010a0	03		 DB	 3
  010a1	01		 DB	 1
  010a2	01		 DB	 1
  010a3	03		 DB	 3
  010a4	03		 DB	 3
  010a5	03		 DB	 3
  010a6	02		 DB	 2
_ls_task_strip_right_punctuation ENDP
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_lp1$ = 20
_lp2$ = 24
_ls_task_spell_all_punct PROC NEAR

; 1701 : 	PLTS_T pLts_t;
; 1702 : 	pLts_t = phTTS->pLTSThreadData;
; 1703 : #ifdef LS1DEBUG
; 1704 : 		printf("entering ls_task_spell_all_punct\n");
; 1705 : #endif
; 1706 : 	if (llp == rlp) 

  010b0	8b 44 24 08	 mov	 eax, DWORD PTR _llp$[esp-4]
  010b4	8b 4c 24 0c	 mov	 ecx, DWORD PTR _rlp$[esp-4]
  010b8	56		 push	 esi
  010b9	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  010bd	57		 push	 edi
  010be	3b c1		 cmp	 eax, ecx
  010c0	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  010c3	75 30		 jne	 SHORT $L72622

; 1707 : 	{                       /* Null word            */
; 1708 : 		ls_spel_spell(phTTS,lp1, lp2);  /* Always slowly.       */

  010c5	8b 4c 24 1c	 mov	 ecx, DWORD PTR _lp2$[esp+4]
  010c9	8b 54 24 18	 mov	 edx, DWORD PTR _lp1$[esp+4]
  010cd	51		 push	 ecx
  010ce	52		 push	 edx
  010cf	56		 push	 esi
  010d0	e8 00 00 00 00	 call	 _ls_spel_spell

; 1709 : #ifdef LS1DEBUG
; 1710 : 			printf("null word spell\n");
; 1711 : #endif
; 1712 : 
; 1713 : 		ls_task_do_right_punct(phTTS,MISS);

  010d5	6a 00		 push	 0
  010d7	56		 push	 esi
  010d8	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 1714 : 		ls_task_readword(phTTS,&(pLts_t->cword[0]));

  010dd	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  010e3	57		 push	 edi
  010e4	56		 push	 esi
  010e5	e8 00 00 00 00	 call	 _ls_task_readword
  010ea	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1715 : 
; 1716 : 		return(LS_TASK_LOOP);

  010ed	b8 01 00 00 00	 mov	 eax, 1
  010f2	5f		 pop	 edi
  010f3	5e		 pop	 esi

; 1733 : }

  010f4	c3		 ret	 0
$L72622:

; 1717 : 	}
; 1718 : 	/*
; 1719 : 	 * Deal with any side effects of the
; 1720 : 	 * stripped left hand end punctuation marks.
; 1721 : 	 * They will never be looked at again.
; 1722 : 	 */
; 1723 : 
; 1724 : 	if (pLts_t->lbphone != WBOUND)

  010f5	8b 87 1c 11 00
	00		 mov	 eax, DWORD PTR [edi+4380]
  010fb	83 f8 6f	 cmp	 eax, 111		; 0000006fH
  010fe	74 0a		 je	 SHORT $L72623

; 1725 : 		ls_util_send_phone(phTTS,pLts_t->lbphone);

  01100	50		 push	 eax
  01101	56		 push	 esi
  01102	e8 00 00 00 00	 call	 _ls_util_send_phone
  01107	83 c4 08	 add	 esp, 8
$L72623:
  0110a	5f		 pop	 edi

; 1726 : 
; 1727 : #ifdef LS1DEBUG
; 1728 : 	printf("after punctuation stripping ");
; 1729 : 	printf("left=%u  right=%u\n",llp,rlp);
; 1730 : #endif
; 1731 : 
; 1732 : 	return(KEEP_SEARCHING);

  0110b	33 c0		 xor	 eax, eax
  0110d	5e		 pop	 esi

; 1733 : }

  0110e	c3		 ret	 0
_ls_task_spell_all_punct ENDP
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_context$ = 8
_ls_task_dictionary_after_punct PROC NEAR

; 1760 : {

  01110	53		 push	 ebx
  01111	55		 push	 ebp
  01112	56		 push	 esi
  01113	57		 push	 edi

; 1761 : 	int context;
; 1762 : 	int flag;
; 1763 : 	LETTER *lp1;
; 1764 : 	PLTS_T pLts_t;
; 1765 : 	pLts_t = phTTS->pLTSThreadData;

  01114	8b 7c 24 14	 mov	 edi, DWORD PTR _phTTS$[esp+12]

; 1766 : #ifdef LS1DEBUG
; 1767 : 		printf("entering ls_task_dictionary_after_punct\n");
; 1768 : #endif
; 1769 : 	
; 1770 : 	/*
; 1771 : 	 * If the above code stripped off a
; 1772 : 	 * punctuation mark, give the dictionary another try
; 1773 : 	 * at it. Duck out through the common exit if we get a
; 1774 : 	 * hit at this level. We also understand how to deal
; 1775 : 	 * with an abbreviation contexts that are hidden
; 1776 : 	 * by right end strippable punctuation.
; 1777 : 	 */
; 1778 : 
; 1779 : 	context = FIRST;
; 1780 : 	if (((pLts_t->lflag)&RSTRIP) != 0) 

  01118	8b 6c 24 1c	 mov	 ebp, DWORD PTR _rlp$[esp+12]
  0111c	8b 5c 24 18	 mov	 ebx, DWORD PTR _llp$[esp+12]
  01120	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _context$[esp+12], 0
  01128	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  0112b	f6 86 f8 08 00
	00 02		 test	 BYTE PTR [esi+2296], 2
  01132	74 4f		 je	 SHORT $L72635

; 1781 : 	{
; 1782 : 		lp1 = (*rlp)-1;

  01134	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  01137	83 e8 08	 sub	 eax, 8

; 1783 : 		if (llp!=lp1 && lp1->l_ch=='.') 

  0113a	3b d8		 cmp	 ebx, eax
  0113c	74 5a		 je	 SHORT $L72640
  0113e	66 83 38 2e	 cmp	 WORD PTR [eax], 46	; 0000002eH
  01142	75 54		 jne	 SHORT $L72640

; 1784 : 		{
; 1785 : 			if ((flag=ls_util_lookup(phTTS,llp, lp1, FABBREV)) != MISS) 

  01144	6a 01		 push	 1
  01146	50		 push	 eax
  01147	53		 push	 ebx
  01148	57		 push	 edi
  01149	e8 00 00 00 00	 call	 _ls_util_lookup
  0114e	83 c4 10	 add	 esp, 16			; 00000010H
  01151	85 c0		 test	 eax, eax
  01153	74 19		 je	 SHORT $L72637

; 1786 : 			{
; 1787 : 				if (flag != ABBREV)

  01155	83 f8 02	 cmp	 eax, 2
  01158	74 0a		 je	 SHORT $L72638

; 1788 : 					pLts_t->rbphone = PERIOD;

  0115a	c7 86 20 11 00
	00 74 00 00 00	 mov	 DWORD PTR [esi+4384], 116 ; 00000074H
$L72638:
  01164	5f		 pop	 edi
  01165	5e		 pop	 esi
  01166	5d		 pop	 ebp

; 1789 : 				return(FINISHED_WORD);

  01167	b8 03 00 00 00	 mov	 eax, 3
  0116c	5b		 pop	 ebx

; 1808 : } 

  0116d	c3		 ret	 0
$L72637:

; 1790 : 			}
; 1791 : 			pLts_t->rbphone = PERIOD;       /* Very strong.         */

  0116e	c7 86 20 11 00
	00 74 00 00 00	 mov	 DWORD PTR [esi+4384], 116 ; 00000074H

; 1792 : 			--(*rlp);

  01178	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  0117b	83 c0 f8	 add	 eax, -8			; fffffff8H
  0117e	89 45 00	 mov	 DWORD PTR [ebp], eax

; 1793 : 		}
; 1794 : 	} 
; 1795 : 	else 

  01181	eb 15		 jmp	 SHORT $L72640
$L72635:

; 1796 : 	{
; 1797 : 		if (ls_util_is_dot(pLts_t) != FALSE)            /* "(Gov. Smith)"       */

  01183	56		 push	 esi
  01184	e8 00 00 00 00	 call	 _ls_util_is_dot
  01189	83 c4 04	 add	 esp, 4
  0118c	85 c0		 test	 eax, eax
  0118e	74 08		 je	 SHORT $L72640

; 1798 : 			context = FABBREV;

  01190	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _context$[esp+12], 1
$L72640:

; 1799 : 	}
; 1800 : 	if (((pLts_t->lflag)&(LSTRIP|RSTRIP)) != 0
; 1801 : 		&& (flag=ls_util_lookup(phTTS,llp, (*rlp), context)) != MISS) 

  01198	f6 86 f8 08 00
	00 03		 test	 BYTE PTR [esi+2296], 3
  0119f	74 2f		 je	 SHORT $L72641
  011a1	8b 44 24 14	 mov	 eax, DWORD PTR _context$[esp+12]
  011a5	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  011a8	50		 push	 eax
  011a9	51		 push	 ecx
  011aa	53		 push	 ebx
  011ab	57		 push	 edi
  011ac	e8 00 00 00 00	 call	 _ls_util_lookup
  011b1	83 c4 10	 add	 esp, 16			; 00000010H
  011b4	85 c0		 test	 eax, eax
  011b6	74 18		 je	 SHORT $L72641

; 1802 : 	{
; 1803 : 		if (flag == ABBREV)             /* Eat the "."          */

  011b8	83 f8 02	 cmp	 eax, 2
  011bb	75 09		 jne	 SHORT $L72642

; 1804 : 			ls_util_read_item(phTTS);

  011bd	57		 push	 edi
  011be	e8 00 00 00 00	 call	 _ls_util_read_item
  011c3	83 c4 04	 add	 esp, 4
$L72642:
  011c6	5f		 pop	 edi
  011c7	5e		 pop	 esi
  011c8	5d		 pop	 ebp

; 1805 : 		return(FINISHED_WORD);

  011c9	b8 03 00 00 00	 mov	 eax, 3
  011ce	5b		 pop	 ebx

; 1808 : } 

  011cf	c3		 ret	 0
$L72641:
  011d0	5f		 pop	 edi
  011d1	5e		 pop	 esi
  011d2	5d		 pop	 ebp

; 1806 : 	}
; 1807 : 	return(KEEP_SEARCHING);

  011d3	33 c0		 xor	 eax, eax
  011d5	5b		 pop	 ebx

; 1808 : } 

  011d6	c3		 ret	 0
_ls_task_dictionary_after_punct ENDP
_TEXT	ENDS
EXTRN	_ls_spel_say_it:NEAR
EXTRN	__imp__fprintf:NEAR
_DATA	SEGMENT
	ORG $+1
$SG72654 DB	0aH, 'SPELL IT (HIT)', 00H
$SG72655 DB	0aH, 'SPELL IT (HIT)', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_spell_vs_speak PROC NEAR

; 1834 : {   

  011e0	53		 push	 ebx

; 1835 : /*
; 1836 :  *  run through the new speak/spell rule tables ...
; 1837 :  */
; 1838 : 	PKSD_T	pKsd_t;
; 1839 : 	pKsd_t = phTTS->pKernelShareData;   
; 1840 : 
; 1841 : 
; 1842 : 
; 1843 : #ifdef LS1DEBUG
; 1844 : 	printf("entering ls_task_spell_vs_speak\n");
; 1845 : 	printf("ls_spel_say_it ");
; 1846 : 	printf("left=%u  right=%u\n",llp,rlp);
; 1847 : #endif
; 1848 : 
; 1849 : 	if(ls_spel_say_it(llp,rlp) == FALSE)

  011e1	8b 5c 24 10	 mov	 ebx, DWORD PTR _rlp$[esp]
  011e5	55		 push	 ebp
  011e6	8b 6c 24 10	 mov	 ebp, DWORD PTR _llp$[esp+4]
  011ea	56		 push	 esi
  011eb	57		 push	 edi
  011ec	8b 7c 24 14	 mov	 edi, DWORD PTR _phTTS$[esp+12]
  011f0	53		 push	 ebx
  011f1	55		 push	 ebp
  011f2	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  011f5	e8 00 00 00 00	 call	 _ls_spel_say_it
  011fa	83 c4 08	 add	 esp, 8
  011fd	85 c0		 test	 eax, eax
  011ff	75 4d		 jne	 SHORT $L72651

; 1850 : 	{
; 1851 : #ifdef LS1DEBUG
; 1852 : 			printf("ls_spel_say_it spell\n");
; 1853 : #endif
; 1854 : 				/* debug switch */
; 1855 : 		if (DT_DBG(LTS_DBG,0x400))

  01201	66 8b 86 78 04
	00 00		 mov	 ax, WORD PTR [esi+1144]
  01208	f6 c4 40	 test	 ah, 64			; 00000040H
  0120b	74 2c		 je	 SHORT $L72652
  0120d	f6 c4 04	 test	 ah, 4
  01210	74 27		 je	 SHORT $L72652

; 1856 : 			{
; 1857 : #ifndef MSDOS
; 1858 : 				if (pKsd_t->dbglog)			/*mfg 05/13/98 added debug support*/

  01212	8b b6 7c 04 00
	00		 mov	 esi, DWORD PTR [esi+1148]
  01218	85 f6		 test	 esi, esi
  0121a	74 0f		 je	 SHORT $L72653

; 1859 : 					fprintf(pKsd_t->dbglog,"\nSPELL IT (HIT)");

  0121c	68 00 00 00 00	 push	 OFFSET FLAT:$SG72654
  01221	56		 push	 esi
  01222	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  01228	83 c4 08	 add	 esp, 8
$L72653:

; 1860 : #endif     
; 1861 : 				printf("\nSPELL IT (HIT)");

  0122b	68 00 00 00 00	 push	 OFFSET FLAT:$SG72655
  01230	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  01236	83 c4 04	 add	 esp, 4
$L72652:

; 1862 : 			}
; 1863 : 
; 1864 : 
; 1865 : 		ls_spel_spell(phTTS,llp,rlp);

  01239	53		 push	 ebx
  0123a	55		 push	 ebp
  0123b	57		 push	 edi
  0123c	e8 00 00 00 00	 call	 _ls_spel_spell
  01241	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1866 : 		return(FINISHED_WORD);

  01244	b8 03 00 00 00	 mov	 eax, 3
  01249	5f		 pop	 edi
  0124a	5e		 pop	 esi
  0124b	5d		 pop	 ebp
  0124c	5b		 pop	 ebx

; 1869 : }

  0124d	c3		 ret	 0
$L72651:
  0124e	5f		 pop	 edi
  0124f	5e		 pop	 esi
  01250	5d		 pop	 ebp

; 1867 : 	}                         
; 1868 : 	return(KEEP_SEARCHING);

  01251	33 c0		 xor	 eax, eax
  01253	5b		 pop	 ebx

; 1869 : }

  01254	c3		 ret	 0
_ls_task_spell_vs_speak ENDP
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_pLts_t$ = -4
_ls_task_single_letter_spell_rules PROC NEAR

; 1894 : {

  01260	51		 push	 ecx

; 1895 : 	int c;
; 1896 : 	LETTER *lp1;
; 1897 : 	int flag;
; 1898 : 	PLTS_T pLts_t;
; 1899 : 	pLts_t = phTTS->pLTSThreadData;

  01261	8b 44 24 08	 mov	 eax, DWORD PTR _phTTS$[esp]
  01265	53		 push	 ebx
  01266	55		 push	 ebp

; 1900 : 
; 1901 : #ifdef LS1DEBUG
; 1902 : 	printf("entering ls_task_single_letter_spell_rules");
; 1903 : 	printf("left=%u  right=%u\n",llp,rlp);
; 1904 : #endif 
; 1905 : 
; 1906 : 	/*
; 1907 : 	 * There are a small set of rules that must be
; 1908 : 	 * run before case distinctions and diacritical marks
; 1909 : 	 * are lost. Single character words are usually spelled,
; 1910 : 	 * but there are some important exceptions. Sequences of
; 1911 : 	 * upper case letters separated by periods (I.B.M.)
; 1912 : 	 * are processed by a fast spelling rule.
; 1913 : 	 */
; 1914 : 	if (llp+1 == rlp)

  01267	8b 6c 24 18	 mov	 ebp, DWORD PTR _rlp$[esp+8]
  0126b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0126e	56		 push	 esi
  0126f	8b 74 24 18	 mov	 esi, DWORD PTR _llp$[esp+12]
  01273	57		 push	 edi
  01274	89 4c 24 10	 mov	 DWORD PTR _pLts_t$[esp+20], ecx
  01278	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
  0127b	3b fd		 cmp	 edi, ebp
  0127d	0f 85 3d 01 00
	00		 jne	 $L72667

; 1915 : 	{
; 1916 : 		c = llp->l_ch;

  01283	0f bf 3e	 movsx	 edi, WORD PTR [esi]

; 1917 : 
; 1918 : 		/*
; 1919 : 		 * Any upper case letter that does not have
; 1920 : 		 * any stripped punctuation, and is followed by a
; 1921 : 		 * period, is taken to be someones initial. The
; 1922 : 		 * period goes away, and the word is spelled.
; 1923 : 		 *
; 1924 : 		 * If you want to make this rule go away you
; 1925 : 		 * can safely just delete the following "if" and
; 1926 : 		 * it's corresponding body.
; 1927 : 		 */
; 1928 : 
; 1929 : 		if (IS_UPPER(c) 
; 1930 : 		&& ((pLts_t->lflag)&(LSTRIP|RSTRIP))==0 && ls_util_is_dot(pLts_t)!=FALSE)

  01286	8b d7		 mov	 edx, edi
  01288	bb 03 00 00 00	 mov	 ebx, 3
  0128d	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  01293	f6 82 00 00 00
	00 02		 test	 BYTE PTR _ls_char_feat[edx], 2
  0129a	74 3f		 je	 SHORT $L72668
  0129c	84 99 f8 08 00
	00		 test	 BYTE PTR [ecx+2296], bl
  012a2	75 37		 jne	 SHORT $L72668
  012a4	51		 push	 ecx
  012a5	e8 00 00 00 00	 call	 _ls_util_is_dot
  012aa	83 c4 04	 add	 esp, 4
  012ad	85 c0		 test	 eax, eax
  012af	74 26		 je	 SHORT $L73089

; 1931 : 		{
; 1932 : 			/* BATS 460 MGS 10/08/1997 Fixed A. B. C. problem losing periods */
; 1933 : 			pLts_t->rbphone=PERIOD;

  012b1	8b 44 24 10	 mov	 eax, DWORD PTR _pLts_t$[esp+20]

; 1934 : 			ls_util_read_item(phTTS);

  012b5	8b 4c 24 18	 mov	 ecx, DWORD PTR _phTTS$[esp+16]
  012b9	51		 push	 ecx
  012ba	c7 80 20 11 00
	00 74 00 00 00	 mov	 DWORD PTR [eax+4384], 116 ; 00000074H
  012c4	e8 00 00 00 00	 call	 _ls_util_read_item
  012c9	83 c4 04	 add	 esp, 4

; 1935 : #ifdef LS1DEBUG
; 1936 : 			printf(" spell cap letter \n");
; 1937 : #endif
; 1938 : 
; 1939 : 			return(SPELL_WORD);

  012cc	b8 02 00 00 00	 mov	 eax, 2
  012d1	5f		 pop	 edi
  012d2	5e		 pop	 esi
  012d3	5d		 pop	 ebp
  012d4	5b		 pop	 ebx

; 2071 : }           

  012d5	59		 pop	 ecx
  012d6	c3		 ret	 0
$L73089:

; 1935 : #ifdef LS1DEBUG
; 1936 : 			printf(" spell cap letter \n");
; 1937 : #endif
; 1938 : 
; 1939 : 			return(SPELL_WORD);

  012d7	8b 4c 24 10	 mov	 ecx, DWORD PTR _pLts_t$[esp+20]
$L72668:

; 1940 : 		}                                         
; 1941 : 
; 1942 : #ifdef ENGLISH
; 1943 : 		/*
; 1944 : 		 * I    => [`A].        Note stress.
; 1945 : 		 * "I"  => ['A].        This is consistant with
; 1946 : 		 * (I)  => ['A].        the spelling entry.
; 1947 : 		 */
; 1948 : 
; 1949 : 		if (c=='i' || c=='I')

  012db	83 ff 69	 cmp	 edi, 105		; 00000069H
  012de	0f 84 a5 00 00
	00		 je	 $L72670
  012e4	83 ff 49	 cmp	 edi, 73			; 00000049H
  012e7	0f 84 9c 00 00
	00		 je	 $L72670

; 1958 : 		}
; 1959 : 
; 1960 : 		/*
; 1961 : 		 * The single character word "a" has two
; 1962 : 		 * different pronounciations. The default one, from
; 1963 : 		 * the spelling entry in the dictionary, is ['e]. The
; 1964 : 		 * exception (actually the most common case) is [x].
; 1965 : 		 * Use [x] if no stripping, and the "a" is not sitting
; 1966 : 		 * against a punctuation mark ("a box." vs "box a.").
; 1967 : 		 */
; 1968 :         /*
; 1969 :            GL 9/10/1996, add checking isnumabr to fix "4.4 a" problem
; 1970 : 		   GL 8/14/1997, for BATS#441 only pLts_t->isnumabr is 0  or 1 "a" will be "AX"
; 1971 :          */
; 1972 : 		if ((c=='a' || c=='A') && (pLts_t->isnumabr == 0 || pLts_t->isnumabr == 1)
; 1973 : 			&& ((pLts_t->lflag)&(LSTRIP|RSTRIP))==0 && ls_util_is_white(&(pLts_t->citem))==TRUE)

  012ed	83 ff 61	 cmp	 edi, 97			; 00000061H
  012f0	74 05		 je	 SHORT $L72674
  012f2	83 ff 41	 cmp	 edi, 65			; 00000041H
  012f5	75 5f		 jne	 SHORT $L72673
$L72674:
  012f7	8b 81 fc 08 00
	00		 mov	 eax, DWORD PTR [ecx+2300]
  012fd	85 c0		 test	 eax, eax
  012ff	74 05		 je	 SHORT $L72675
  01301	83 f8 01	 cmp	 eax, 1
  01304	75 50		 jne	 SHORT $L72673
$L72675:
  01306	84 99 f8 08 00
	00		 test	 BYTE PTR [ecx+2296], bl
  0130c	75 48		 jne	 SHORT $L72673
  0130e	81 c1 00 09 00
	00		 add	 ecx, 2304		; 00000900H
  01314	51		 push	 ecx
  01315	e8 00 00 00 00	 call	 _ls_util_is_white
  0131a	83 c4 04	 add	 esp, 4
  0131d	83 f8 01	 cmp	 eax, 1
  01320	75 34		 jne	 SHORT $L72673

; 1974 : 		{
; 1975 : 			pLts_t->fc_struct[pLts_t->fc_index] = FC_ART;

  01322	8b 44 24 10	 mov	 eax, DWORD PTR _pLts_t$[esp+20]

; 1976 : 			ls_util_send_phone(phTTS,SPECIALWORD);	

  01326	8b 74 24 18	 mov	 esi, DWORD PTR _phTTS$[esp+16]
  0132a	6a 78		 push	 120			; 00000078H
  0132c	56		 push	 esi
  0132d	8b 90 bc 08 00
	00		 mov	 edx, DWORD PTR [eax+2236]
  01333	c7 84 90 bc 04
	00 00 04 00 00
	00		 mov	 DWORD PTR [eax+edx*4+1212], 4
  0133e	e8 00 00 00 00	 call	 _ls_util_send_phone

; 1977 : 			ls_util_send_phone(phTTS,AX);			

  01343	6a 11		 push	 17			; 00000011H
  01345	56		 push	 esi
  01346	e8 00 00 00 00	 call	 _ls_util_send_phone
  0134b	83 c4 10	 add	 esp, 16			; 00000010H

; 1978 : #ifdef LS1DEBUG
; 1979 : 			printf(" a to ah code \n");
; 1980 : #endif
; 1981 : 			return(FINISHED_WORD);

  0134e	8b c3		 mov	 eax, ebx
  01350	5f		 pop	 edi
  01351	5e		 pop	 esi
  01352	5d		 pop	 ebp
  01353	5b		 pop	 ebx

; 2071 : }           

  01354	59		 pop	 ecx
  01355	c3		 ret	 0
$L72673:

; 1982 : 		}
; 1983 : #endif
; 1984 : #ifdef SPANISH
; 1985 : 		/*igrega or i code*/
; 1986 : 		if ((c=='y' || c=='Y')
; 1987 : 		&& ((pLts_t->lflag)&(LSTRIP|RSTRIP))==0 && ls_util_is_white(&(pLts_t->citem))!=FALSE)
; 1988 : 		{
; 1989 : 			pLts_t->fc_struct[pLts_t->fc_index] = FC_CONJ;
; 1990 : 			ls_util_send_phone(phTTS,E_I);
; 1991 : #ifdef LS1DEBUG
; 1992 : 			printf(" iggre to i  code \n");
; 1993 : #endif
; 1994 : 
; 1995 : 			return(FINISHED_WORD);
; 1996 : 		}
; 1997 : 
; 1998 : #endif		
; 1999 : 		/*
; 2000 : 		 * Most other single letter words get
; 2001 : 		 * spelled. Watch out for single character numbers
; 2002 : 		 * (the digits, and the 1/4 and 1/2 DEC supplimental
; 2003 : 		 * characters) which must go through the number
; 2004 : 		 * processing heuristics.
; 2005 : 		 */
; 2006 : 		if (c!=0xBC && c!=0xBD && !IS_DIGIT(llp->l_ch))

  01356	81 ff bc 00 00
	00		 cmp	 edi, 188		; 000000bcH
  0135c	0f 84 05 01 00
	00		 je	 $L72685
  01362	81 ff bd 00 00
	00		 cmp	 edi, 189		; 000000bdH
  01368	0f 84 f9 00 00
	00		 je	 $L72685
  0136e	0f bf 06	 movsx	 eax, WORD PTR [esi]
  01371	f6 80 00 00 00
	00 10		 test	 BYTE PTR _ls_char_feat[eax], 16 ; 00000010H
  01378	0f 85 e9 00 00
	00		 jne	 $L72685
  0137e	5f		 pop	 edi
  0137f	5e		 pop	 esi
  01380	5d		 pop	 ebp

; 2007 : 		{
; 2008 : #ifdef LS1DEBUG
; 2009 : 			printf("single letter spell\n");
; 2010 : #endif
; 2011 : 
; 2012 : 			return(SPELL_WORD);

  01381	b8 02 00 00 00	 mov	 eax, 2
  01386	5b		 pop	 ebx

; 2071 : }           

  01387	59		 pop	 ecx
  01388	c3		 ret	 0
$L72670:

; 1950 : 		{
; 1951 : 			if (((pLts_t->lflag)&(LSTRIP|RSTRIP)) != 0)

  01389	84 99 f8 08 00
	00		 test	 BYTE PTR [ecx+2296], bl
  0138f	74 09		 je	 SHORT $L72671

; 1952 : 				ls_util_send_phone(phTTS,S1);

  01391	8b 4c 24 18	 mov	 ecx, DWORD PTR _phTTS$[esp+16]
  01395	6a 67		 push	 103			; 00000067H
  01397	51		 push	 ecx

; 1953 : 			else            

  01398	eb 07		 jmp	 SHORT $L73094
$L72671:

; 1954 : 				ls_util_send_phone(phTTS,S2);

  0139a	8b 54 24 18	 mov	 edx, DWORD PTR _phTTS$[esp+16]
  0139e	6a 66		 push	 102			; 00000066H
  013a0	52		 push	 edx
$L73094:
  013a1	e8 00 00 00 00	 call	 _ls_util_send_phone

; 1955 : 
; 1956 : 			ls_util_send_phone(phTTS,AY);			

  013a6	8b 44 24 20	 mov	 eax, DWORD PTR _phTTS$[esp+24]
  013aa	83 c4 08	 add	 esp, 8
  013ad	6a 07		 push	 7
  013af	50		 push	 eax
  013b0	e8 00 00 00 00	 call	 _ls_util_send_phone
  013b5	83 c4 08	 add	 esp, 8

; 1957 : 			return(FINISHED_WORD);

  013b8	8b c3		 mov	 eax, ebx
  013ba	5f		 pop	 edi
  013bb	5e		 pop	 esi
  013bc	5d		 pop	 ebp
  013bd	5b		 pop	 ebx

; 2071 : }           

  013be	59		 pop	 ecx
  013bf	c3		 ret	 0
$L72667:

; 2013 : 		}
; 2014 : 	}
; 2015 : 	else
; 2016 : 	{
; 2017 : 		flag = FALSE;                   /* Start validation.    */

  013c0	33 db		 xor	 ebx, ebx

; 2018 : 		lp1  = llp;
; 2019 : 		while (lp1 != rlp) 

  013c2	3b f5		 cmp	 esi, ebp
  013c4	8b c6		 mov	 eax, esi
  013c6	74 6d		 je	 SHORT $L72688
$L72679:

; 2020 : 		{
; 2021 : 			if (flag == FALSE) 

  013c8	85 db		 test	 ebx, ebx
  013ca	75 18		 jne	 SHORT $L72681

; 2022 : 			{    /* FALSE => even.       */
; 2023 : 
; 2024 : 				/*
; 2025 : 				 * On a standard DECtalk all of
; 2026 : 				 * the characters in an "I.B.M." thing
; 2027 : 				 * must be in upper case. On the special
; 2028 : 				 * Kurzweil DECtalk any letter will do.
; 2029 : 				 * A letter is defined here as vowel
; 2030 : 				 * or consonant.
; 2031 : 				 */
; 2032 : 				
; 2033 : 				if (!(IS_UPPER(lp1->l_ch)))

  013cc	8a 10		 mov	 dl, BYTE PTR [eax]
  013ce	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  013d4	f6 82 00 00 00
	00 02		 test	 BYTE PTR _ls_char_feat[edx], 2
  013db	74 18		 je	 SHORT $L73085

; 2034 : 					break;
; 2035 : 				flag = TRUE;

  013dd	bb 01 00 00 00	 mov	 ebx, 1

; 2036 : 			} 
; 2037 : 			else 

  013e2	eb 08		 jmp	 SHORT $L72683
$L72681:

; 2038 : 			{                /* TRUE => odd.         */
; 2039 : 				if (lp1->l_ch != '.')

  013e4	66 83 38 2e	 cmp	 WORD PTR [eax], 46	; 0000002eH
  013e8	75 0b		 jne	 SHORT $L73085

; 2040 : 					break;
; 2041 : 				flag = FALSE;

  013ea	33 db		 xor	 ebx, ebx
$L72683:

; 2042 : 			}
; 2043 : 			++lp1;

  013ec	83 c0 08	 add	 eax, 8
  013ef	3b c5		 cmp	 eax, ebp
  013f1	75 d5		 jne	 SHORT $L72679

; 2044 : 		}
; 2045 : 		if (lp1 == rlp) 

  013f3	eb 04		 jmp	 SHORT $L73088
$L73085:
  013f5	3b c5		 cmp	 eax, ebp
  013f7	75 6e		 jne	 SHORT $L72685
$L73088:

; 2046 : 		{               /* Ate it all.          */
; 2047 : 			lp1 = llp;
; 2048 : 			while (lp1 != rlp) 

  013f9	3b f5		 cmp	 esi, ebp
  013fb	74 38		 je	 SHORT $L72688
$L72687:

; 2049 : 			{
; 2050 : #ifdef LS1DEBUG
; 2051 : 				printf("ate it all spell\n");
; 2052 : #endif
; 2053 : 
; 2054 : 				ls_spel_spell(phTTS,lp1, lp1+1);

  013fd	8b 44 24 18	 mov	 eax, DWORD PTR _phTTS$[esp+16]
  01401	57		 push	 edi
  01402	56		 push	 esi
  01403	50		 push	 eax
  01404	e8 00 00 00 00	 call	 _ls_spel_spell

; 2055 : 				++lp1;

  01409	83 c6 08	 add	 esi, 8
  0140c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0140f	83 c7 08	 add	 edi, 8

; 2056 : 				if (lp1 != rlp) 

  01412	3b f5		 cmp	 esi, ebp
  01414	74 1b		 je	 SHORT $L73091

; 2057 : 				{
; 2058 : 					++lp1;

  01416	83 c6 08	 add	 esi, 8
  01419	83 c7 08	 add	 edi, 8

; 2059 : 				}
; 2060 : 				if (lp1 != rlp)

  0141c	3b f5		 cmp	 esi, ebp
  0141e	74 11		 je	 SHORT $L73091

; 2061 : 					ls_util_send_phone(phTTS,WBOUND);

  01420	8b 4c 24 18	 mov	 ecx, DWORD PTR _phTTS$[esp+16]
  01424	6a 6f		 push	 111			; 0000006fH
  01426	51		 push	 ecx
  01427	e8 00 00 00 00	 call	 _ls_util_send_phone
  0142c	83 c4 08	 add	 esp, 8
  0142f	eb cc		 jmp	 SHORT $L72687
$L73091:

; 2046 : 		{               /* Ate it all.          */
; 2047 : 			lp1 = llp;
; 2048 : 			while (lp1 != rlp) 

  01431	8b 4c 24 10	 mov	 ecx, DWORD PTR _pLts_t$[esp+20]
$L72688:

; 2062 : 			}
; 2063 : 			if (flag != FALSE       /* Last a letter.       */
; 2064 : 			&& ((pLts_t->lflag)&RSTRIP) == 0  /* and no right strip   */
; 2065 : 			&& ls_util_is_dot(pLts_t) != FALSE)    /* and sitting on "."   */

  01435	85 db		 test	 ebx, ebx
  01437	74 23		 je	 SHORT $L72691
  01439	f6 81 f8 08 00
	00 02		 test	 BYTE PTR [ecx+2296], 2
  01440	75 1a		 jne	 SHORT $L72691
  01442	51		 push	 ecx
  01443	e8 00 00 00 00	 call	 _ls_util_is_dot
  01448	83 c4 04	 add	 esp, 4
  0144b	85 c0		 test	 eax, eax
  0144d	74 0d		 je	 SHORT $L72691

; 2066 : 				ls_util_read_item(phTTS);     /* eat up the ".".      */

  0144f	8b 54 24 18	 mov	 edx, DWORD PTR _phTTS$[esp+16]
  01453	52		 push	 edx
  01454	e8 00 00 00 00	 call	 _ls_util_read_item
  01459	83 c4 04	 add	 esp, 4
$L72691:
  0145c	5f		 pop	 edi
  0145d	5e		 pop	 esi
  0145e	5d		 pop	 ebp

; 2067 : 			return(FINISHED_WORD);

  0145f	b8 03 00 00 00	 mov	 eax, 3
  01464	5b		 pop	 ebx

; 2071 : }           

  01465	59		 pop	 ecx
  01466	c3		 ret	 0
$L72685:
  01467	5f		 pop	 edi
  01468	5e		 pop	 esi
  01469	5d		 pop	 ebp

; 2068 : 		}
; 2069 : 	}
; 2070 : 	return(KEEP_SEARCHING);

  0146a	33 c0		 xor	 eax, eax
  0146c	5b		 pop	 ebx

; 2071 : }           

  0146d	59		 pop	 ecx
  0146e	c3		 ret	 0
_ls_task_single_letter_spell_rules ENDP
_llp$ = 8
_rlp$ = 12
_ls_task_remove_case PROC NEAR

; 2097 : 	while (llp != rlp) 

  01470	8b 44 24 04	 mov	 eax, DWORD PTR _llp$[esp-4]
  01474	8b 4c 24 08	 mov	 ecx, DWORD PTR _rlp$[esp-4]
  01478	3b c1		 cmp	 eax, ecx
  0147a	74 16		 je	 SHORT $L72699
$L72698:

; 2098 : 	{
; 2099 : 		llp->l_ch = ls_lower[llp->l_ch];

  0147c	0f bf 10	 movsx	 edx, WORD PTR [eax]

; 2100 : 		++llp;

  0147f	83 c0 08	 add	 eax, 8
  01482	66 0f b6 92 00
	00 00 00	 movzx	 dx, BYTE PTR _ls_lower[edx]
  0148a	66 89 50 f8	 mov	 WORD PTR [eax-8], dx
  0148e	3b c1		 cmp	 eax, ecx
  01490	75 ea		 jne	 SHORT $L72698
$L72699:

; 2101 : 	}
; 2102 : }

  01492	c3		 ret	 0
_ls_task_remove_case ENDP
_TEXT	ENDS
EXTRN	_pstreet:BYTE
EXTRN	_psaint:BYTE
EXTRN	_pdoctor:BYTE
EXTRN	_pdrive:BYTE
EXTRN	_ls_util_copyword:NEAR
_TEXT	SEGMENT
_rlp$ = 16
_phTTS$ = 8
_llp$ = 12
_ls_task_Dr_St_process PROC NEAR

; 2129 : #ifdef ENGLISH
; 2130 : 	int     c1;
; 2131 : 	int     c2;
; 2132 : 	PLTS_T pLts_t;
; 2133 : 	pLts_t = phTTS->pLTSThreadData;

  014a0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]

; 2134 : 
; 2135 : 	/*
; 2136 : 	 * Watch for "Dr." and "St.". Look ahead to
; 2137 : 	 * determine the correct pronounciation, then move
; 2138 : 	 * the ls_task_lookahead into the working word. The two line
; 2139 : 	 * "if" at the start implements rules similar in spirit
; 2140 : 	 * to the code in the first dictionary scan, that has
; 2141 : 	 * do decide if this is an abbreviation context.
; 2142 : 	 */
; 2143 : 
; 2144 : #ifdef LS1DEBUG
; 2145 : 	printf("dr. st. processing ");
; 2146 : 	printf("left=%u  right=%u\n",llp,rlp);
; 2147 : #endif
; 2148 : 				
; 2149 : 	if ((llp+3==rlp && (llp+2)->l_ch=='.')
; 2150 : 	||  (llp+2==rlp && ((pLts_t->lflag)&RSTRIP)==0 && ls_util_is_dot(pLts_t)!=FALSE)) 

  014a4	8b 4c 24 0c	 mov	 ecx, DWORD PTR _rlp$[esp-4]
  014a8	53		 push	 ebx
  014a9	55		 push	 ebp
  014aa	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]
  014ad	56		 push	 esi
  014ae	8b 74 24 14	 mov	 esi, DWORD PTR _llp$[esp+8]
  014b2	57		 push	 edi
  014b3	8d 56 18	 lea	 edx, DWORD PTR [esi+24]
  014b6	3b d1		 cmp	 edx, ecx
  014b8	75 0a		 jne	 SHORT $L72712
  014ba	66 83 7e 10 2e	 cmp	 WORD PTR [esi+16], 46	; 0000002eH
  014bf	8d 6e 10	 lea	 ebp, DWORD PTR [esi+16]
  014c2	74 21		 je	 SHORT $L72711
$L72712:
  014c4	8d 6e 10	 lea	 ebp, DWORD PTR [esi+16]
  014c7	3b e9		 cmp	 ebp, ecx
  014c9	75 2b		 jne	 SHORT $L72713
  014cb	f6 83 f8 08 00
	00 02		 test	 BYTE PTR [ebx+2296], 2
  014d2	75 22		 jne	 SHORT $L72713
  014d4	53		 push	 ebx
  014d5	e8 00 00 00 00	 call	 _ls_util_is_dot
  014da	83 c4 04	 add	 esp, 4
  014dd	85 c0		 test	 eax, eax
  014df	74 15		 je	 SHORT $L72713
  014e1	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rlp$[esp+12]
$L72711:

; 2151 : 	{
; 2152 : 		c1 = (llp+0)->l_ch;

  014e5	0f bf 3e	 movsx	 edi, WORD PTR [esi]

; 2153 : 		c2 = (llp+1)->l_ch;

  014e8	0f bf 46 08	 movsx	 eax, WORD PTR [esi+8]

; 2154 : 		if ((c1=='s' && c2=='t') || (c1=='d' && c2=='r')) 

  014ec	83 ff 73	 cmp	 edi, 115		; 00000073H
  014ef	75 0c		 jne	 SHORT $L72715
  014f1	83 f8 74	 cmp	 eax, 116		; 00000074H
  014f4	74 11		 je	 SHORT $L72714
$L72713:
  014f6	5f		 pop	 edi
  014f7	5e		 pop	 esi
  014f8	5d		 pop	 ebp

; 2192 : 		}
; 2193 : 	}   
; 2194 : 	return(KEEP_SEARCHING);

  014f9	33 c0		 xor	 eax, eax
  014fb	5b		 pop	 ebx

; 2195 : #endif /* end of #ifdef ENGLISH */
; 2196 : }

  014fc	c3		 ret	 0
$L72715:

; 2154 : 		if ((c1=='s' && c2=='t') || (c1=='d' && c2=='r')) 

  014fd	83 ff 64	 cmp	 edi, 100		; 00000064H
  01500	75 f4		 jne	 SHORT $L72713
  01502	83 f8 72	 cmp	 eax, 114		; 00000072H
  01505	75 ef		 jne	 SHORT $L72713
$L72714:

; 2155 : 		{
; 2156 : 			if (llp+2 == rlp)       /* Gobble up the "."    */

  01507	3b e9		 cmp	 ebp, ecx
  01509	75 0d		 jne	 SHORT $L72716

; 2157 : 				ls_util_read_item(phTTS);     /* after abbreviation.  */

  0150b	8b 44 24 14	 mov	 eax, DWORD PTR _phTTS$[esp+12]
  0150f	50		 push	 eax
  01510	e8 00 00 00 00	 call	 _ls_util_read_item
  01515	83 c4 04	 add	 esp, 4
$L72716:

; 2158 : 			ls_task_lookahead(pLts_t);

  01518	53		 push	 ebx
  01519	e8 00 00 00 00	 call	 _ls_task_lookahead

; 2159 : 			if (ls_util_is_white(&(pLts_t->citem)) != FALSE) 

  0151e	8d 8b 00 09 00
	00		 lea	 ecx, DWORD PTR [ebx+2304]
  01524	51		 push	 ecx
  01525	e8 00 00 00 00	 call	 _ls_util_is_white
  0152a	83 c4 08	 add	 esp, 8
  0152d	85 c0		 test	 eax, eax
  0152f	0f 84 bf 00 00
	00		 je	 $L72717

; 2160 : 			{
; 2161 : 				ls_task_readword(phTTS,&(pLts_t->nword[0]));

  01535	8b 74 24 14	 mov	 esi, DWORD PTR _phTTS$[esp+12]
  01539	8d ab 14 0d 00
	00		 lea	 ebp, DWORD PTR [ebx+3348]
  0153f	55		 push	 ebp
  01540	56		 push	 esi
  01541	e8 00 00 00 00	 call	 _ls_task_readword

; 2162 : 				if ((lsctype[pLts_t->nword[0].l_ch]&UU) != 0)

  01546	66 8b 45 00	 mov	 ax, WORD PTR [ebp]
  0154a	83 c4 08	 add	 esp, 8
  0154d	0f bf d0	 movsx	 edx, ax
  01550	f6 04 55 00 00
	00 00 20	 test	 BYTE PTR _lsctype[edx*2], 32 ; 00000020H
  01558	74 40		 je	 SHORT $L72718

; 2163 : 				{
; 2164 : 					/* GL 02/25/1997  fix St. Dr. back to back problem */ 
; 2165 : 					if ((pLts_t->nword[0].l_ch=='D' &&
; 2166 : 					     pLts_t->nword[1].l_ch=='r' &&
; 2167 : 					     pLts_t->nword[2].l_ch==0) ||
; 2168 : 					     (pLts_t->nword[0].l_ch=='S' &&
; 2169 : 					      pLts_t->nword[1].l_ch=='t' &&
; 2170 : 					      pLts_t->nword[2].l_ch==0))

  0155a	66 3d 44 00	 cmp	 ax, 68			; 00000044H
  0155e	75 14		 jne	 SHORT $L72721
  01560	66 83 bb 1c 0d
	00 00 72	 cmp	 WORD PTR [ebx+3356], 114 ; 00000072H
  01568	75 0a		 jne	 SHORT $L72721
  0156a	66 83 bb 24 0d
	00 00 00	 cmp	 WORD PTR [ebx+3364], 0
  01572	74 1a		 je	 SHORT $L72720
$L72721:
  01574	66 3d 53 00	 cmp	 ax, 83			; 00000053H
  01578	75 29		 jne	 SHORT $L72719
  0157a	66 83 bb 1c 0d
	00 00 74	 cmp	 WORD PTR [ebx+3356], 116 ; 00000074H
  01582	75 1f		 jne	 SHORT $L72719
  01584	66 83 bb 24 0d
	00 00 00	 cmp	 WORD PTR [ebx+3364], 0
  0158c	75 15		 jne	 SHORT $L72719
$L72720:

; 2171 : 					ls_util_send_phone_list(phTTS,c1=='s' ? pstreet : pdrive);

  0158e	83 ff 73	 cmp	 edi, 115		; 00000073H
  01591	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pstreet
  01596	74 2b		 je	 SHORT $L73101

; 2172 : 					else

  01598	eb 24		 jmp	 SHORT $L73106
$L72718:

; 2173 : 					ls_util_send_phone_list(phTTS,c1=='s' ? psaint : pdoctor);
; 2174 : 				}
; 2175 : 				else
; 2176 : 				{
; 2177 : 					/* GL 03/03/1997  it is doctor or saint if is the first word of sentenct */
; 2178 : 					if (pLts_t->fc_index == 1)

  0159a	83 bb bc 08 00
	00 01		 cmp	 DWORD PTR [ebx+2236], 1
  015a1	75 11		 jne	 SHORT $L72724
$L72719:

; 2179 : 						ls_util_send_phone_list(phTTS,c1=='s' ? psaint : pdoctor);

  015a3	83 ff 73	 cmp	 edi, 115		; 00000073H
  015a6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_psaint
  015ab	74 16		 je	 SHORT $L73101
  015ad	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pdoctor

; 2180 : 					else

  015b2	eb 0f		 jmp	 SHORT $L73101
$L72724:

; 2181 : 						ls_util_send_phone_list(phTTS,c1=='s' ? pstreet : pdrive);

  015b4	83 ff 73	 cmp	 edi, 115		; 00000073H
  015b7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pstreet
  015bc	74 05		 je	 SHORT $L73101
$L73106:
  015be	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pdrive
$L73101:
  015c3	50		 push	 eax
  015c4	56		 push	 esi
  015c5	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2182 : 				}
; 2183 : 
; 2184 : 				ls_util_send_phone(phTTS,pLts_t->rbphone);

  015ca	8b 83 20 11 00
	00		 mov	 eax, DWORD PTR [ebx+4384]
  015d0	83 c4 08	 add	 esp, 8
  015d3	50		 push	 eax
  015d4	56		 push	 esi
  015d5	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2185 : 				ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));

  015da	81 c3 14 09 00
	00		 add	 ebx, 2324		; 00000914H
  015e0	55		 push	 ebp
  015e1	53		 push	 ebx
  015e2	e8 00 00 00 00	 call	 _ls_util_copyword
  015e7	83 c4 10	 add	 esp, 16			; 00000010H

; 2186 : 
; 2187 : 				return(LS_TASK_LOOP);

  015ea	b8 01 00 00 00	 mov	 eax, 1
  015ef	5f		 pop	 edi
  015f0	5e		 pop	 esi
  015f1	5d		 pop	 ebp
  015f2	5b		 pop	 ebx

; 2195 : #endif /* end of #ifdef ENGLISH */
; 2196 : }

  015f3	c3		 ret	 0
$L72717:

; 2188 : 			}
; 2189 : 			ls_util_send_phone_list(phTTS,c1=='s' ? pstreet : pdrive);

  015f4	83 ff 73	 cmp	 edi, 115		; 00000073H
  015f7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pstreet
  015fc	74 05		 je	 SHORT $L73109
  015fe	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pdrive
$L73109:
  01603	8b 4c 24 14	 mov	 ecx, DWORD PTR _phTTS$[esp+12]
  01607	50		 push	 eax
  01608	51		 push	 ecx
  01609	e8 00 00 00 00	 call	 _ls_util_send_phone_list
  0160e	83 c4 08	 add	 esp, 8

; 2190 : 
; 2191 : 			return(FINISHED_WORD);

  01611	b8 03 00 00 00	 mov	 eax, 3
  01616	5f		 pop	 edi
  01617	5e		 pop	 esi
  01618	5d		 pop	 ebp
  01619	5b		 pop	 ebx

; 2195 : #endif /* end of #ifdef ENGLISH */
; 2196 : }

  0161a	c3		 ret	 0
_ls_task_Dr_St_process ENDP
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_lp1$ = 20
_ls_task_set_sign_flag PROC NEAR

; 2226 : 	PKSD_T  pKsd_t;
; 2227 : 	PLTS_T  pLts_t;
; 2228 : 		
; 2229 : 	pKsd_t = phTTS->pKernelShareData;

  01620	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]

; 2230 : 	pLts_t = phTTS->pLTSThreadData;	
; 2231 : 
; 2232 : #ifdef LS1DEBUG       
; 2233 : 	printf("entering ls_task_set_sign_flag\n");
; 2234 : 	printf("beginnning number processing   ");
; 2235 : 	printf("left=%u  right=%u\n",llp,rlp);
; 2236 : #endif
; 2237 : 							  
; 2238 : 	/*
; 2239 : 	 * This is the top of number processing. The first
; 2240 : 	 * step is to decide how "." and "," will be interpreted.
; 2241 : 	 * This is controlled by a mode flag (MODE_EUROPE) if
; 2242 : 	 * the unit is running at level 2. Then pull off any signs,
; 2243 : 	 * and revert to spelling if this makes the whole word
; 2244 : 	 * go away.
; 2245 : 	 */
; 2246 : 	/* pLts_t->fc_struct[pLts_t->fc_index] = FC_ADJ;xxx marks more than numbers here*/
; 2247 : 
; 2248 : 	/*eab 8/94 numbers form class needs to be marked*/
; 2249 : 	pLts_t->fchar = '.';                            /* Pick the right one.  */
; 2250 : 	pLts_t->schar = ',';

  01624	ba 2c 00 00 00	 mov	 edx, 44			; 0000002cH
  01629	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0162c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0162f	66 c7 80 ec 08
	00 00 2e 00	 mov	 WORD PTR [eax+2284], 46	; 0000002eH
  01638	66 89 90 ee 08
	00 00		 mov	 WORD PTR [eax+2286], dx

; 2251 :     if ((pKsd_t->modeflag&MODE_EUROPE)!=0) {

  0163f	f6 81 00 02 00
	00 08		 test	 BYTE PTR [ecx+512], 8
  01646	74 10		 je	 SHORT $L72737

; 2252 : 		pLts_t->fchar = ',';

  01648	66 89 90 ec 08
	00 00		 mov	 WORD PTR [eax+2284], dx

; 2253 : 		pLts_t->schar = '.';

  0164f	66 c7 80 ee 08
	00 00 2e 00	 mov	 WORD PTR [eax+2286], 46	; 0000002eH
$L72737:

; 2254 : 	}
; 2255 : 	/* GL 11/07/1996, change to fix Spanish Decimal number */
; 2256 : 	/* SPANISH use the "." and "," just as MODE_EUROPE for both Latin and Spanish */
; 2257 : #if defined (SPANISH) || defined (GERMAN)
; 2258 : 		pLts_t->fchar = ',';
; 2259 : 		pLts_t->schar = '.';
; 2260 : #endif
; 2261 : 	
; 2262 : 	pLts_t->sign = 0;
; 2263 : 	(*lp1)  = llp;

  01658	8b 4c 24 10	 mov	 ecx, DWORD PTR _lp1$[esp-4]
  0165c	8b 54 24 08	 mov	 edx, DWORD PTR _llp$[esp-4]
  01660	c7 80 18 11 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+4376], 0
  0166a	89 11		 mov	 DWORD PTR [ecx], edx

; 2264 : 	if ((*lp1)->l_ch == '-'                     /* Signs.               */
; 2265 : 	||  (*lp1)->l_ch == '+'
; 2266 : 	||  (*lp1)->l_ch == 0xA7                    /* Section mark.        */
; 2267 : 	||  (*lp1)->l_ch == 0xB1                    /* Plus-minus.          */
; 2268 : 	||  (*lp1)->l_ch == 0xB6)          			/* Item.                */

  0166c	66 8b 12	 mov	 dx, WORD PTR [edx]
  0166f	66 83 fa 2d	 cmp	 dx, 45			; 0000002dH
  01673	74 1b		 je	 SHORT $L72739
  01675	66 83 fa 2b	 cmp	 dx, 43			; 0000002bH
  01679	74 15		 je	 SHORT $L72739
  0167b	66 81 fa a7 00	 cmp	 dx, 167			; 000000a7H
  01680	74 0e		 je	 SHORT $L72739
  01682	66 81 fa b1 00	 cmp	 dx, 177			; 000000b1H
  01687	74 07		 je	 SHORT $L72739
  01689	66 81 fa b6 00	 cmp	 dx, 182			; 000000b6H
  0168e	75 20		 jne	 SHORT $L72740
$L72739:

; 2269 : 		{               
; 2270 : 		pLts_t->sign = (*lp1)->l_ch;

  01690	0f bf d2	 movsx	 edx, dx
  01693	89 90 18 11 00
	00		 mov	 DWORD PTR [eax+4376], edx

; 2271 : 		++(*lp1);

  01699	8b 11		 mov	 edx, DWORD PTR [ecx]

; 2272 : #ifdef LS1DEBUG
; 2273 : 		printf("num processing sign found\n");
; 2274 : #endif
; 2275 : 		if ((*lp1) == rlp)

  0169b	8b 44 24 0c	 mov	 eax, DWORD PTR _rlp$[esp-4]
  0169f	83 c2 08	 add	 edx, 8
  016a2	89 11		 mov	 DWORD PTR [ecx], edx
  016a4	8b ca		 mov	 ecx, edx
  016a6	3b c8		 cmp	 ecx, eax
  016a8	75 06		 jne	 SHORT $L72740

; 2276 : 		{
; 2277 : #ifdef LS1DEBUG
; 2278 : 			printf(" spell from num processing\n");
; 2279 : #endif
; 2280 : 			return(SPELL_WORD);

  016aa	b8 02 00 00 00	 mov	 eax, 2

; 2284 : }

  016af	c3		 ret	 0
$L72740:

; 2281 : 		}
; 2282 : 	}                          
; 2283 : 	return(KEEP_SEARCHING);

  016b0	33 c0		 xor	 eax, eax

; 2284 : }

  016b2	c3		 ret	 0
_ls_task_set_sign_flag ENDP
_TEXT	ENDS
EXTRN	_ppence:BYTE
EXTRN	_pcent:BYTE
EXTRN	_ppound:BYTE
EXTRN	_pdollar:BYTE
EXTRN	_pand:BYTE
EXTRN	_ls_proc_do_sign:NEAR
EXTRN	_ls_proc_do_number:NEAR
EXTRN	_nwdtab:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_num$ = -24
_type$ = 12
_flag$ = 8
_cp$ = -28
_ls_task_currency_processing PROC NEAR

; 2309 : {   

  016c0	83 ec 1c	 sub	 esp, 28			; 0000001cH
  016c3	53		 push	 ebx

; 2310 : 	NUM     num;
; 2311 : 	LETTER *lp2;
; 2312 : 	int     type;
; 2313 : 	int     flag;
; 2314 : 	char    *cp;
; 2315 : 	PLTS_T pLts_t;
; 2316 : 	
; 2317 : 	pLts_t = phTTS->pLTSThreadData;
; 2318 : 	
; 2319 : #ifdef LS1DEBUG
; 2320 : 		printf("entering ls_task_currency_processing\n");
; 2321 : #endif
; 2322 : 	/*
; 2323 : 	 * If the first character in the remaining string
; 2324 : 	 * is a currency symbol (both the USA/Canada and the
; 2325 : 	 * United Kingdom versions are accepted) this is a signal
; 2326 : 	 * to begin running the money rules.
; 2327 : 	 */
; 2328 : 
; 2329 : #ifdef LS1DEBUG
; 2330 : 	printf("currency rules ");
; 2331 : 	printf("left=%u  right=%u\n",llp,rlp);
; 2332 : #endif
; 2333 : 	if (llp->l_ch=='$' || llp->l_ch==0xA3) 

  016c4	8b 5c 24 28	 mov	 ebx, DWORD PTR _llp$[esp+28]
  016c8	55		 push	 ebp
  016c9	56		 push	 esi
  016ca	66 8b 03	 mov	 ax, WORD PTR [ebx]
  016cd	57		 push	 edi
  016ce	8b 7c 24 30	 mov	 edi, DWORD PTR _phTTS$[esp+40]
  016d2	66 3d 24 00	 cmp	 ax, 36			; 00000024H
  016d6	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  016d9	74 10		 je	 SHORT $L72755
  016db	66 3d a3 00	 cmp	 ax, 163			; 000000a3H
  016df	74 0a		 je	 SHORT $L72755
  016e1	5f		 pop	 edi
  016e2	5e		 pop	 esi
  016e3	5d		 pop	 ebp

; 2569 : 		}
; 2570 : 		return(FINISHED_WORD);
; 2571 : 	}
; 2572 : 	return(KEEP_SEARCHING);

  016e4	33 c0		 xor	 eax, eax
  016e6	5b		 pop	 ebx

; 2573 : }

  016e7	83 c4 1c	 add	 esp, 28			; 0000001cH
  016ea	c3		 ret	 0
$L72755:

; 2334 : 	{
; 2335 : 		type = llp->l_ch;
; 2336 : 		if (++llp == rlp)               /* Lone currency mark.  */

  016eb	8b 6c 24 38	 mov	 ebp, DWORD PTR _rlp$[esp+40]
  016ef	83 c3 08	 add	 ebx, 8
  016f2	0f bf c0	 movsx	 eax, ax
  016f5	3b dd		 cmp	 ebx, ebp
  016f7	89 44 24 34	 mov	 DWORD PTR _type$[esp+40], eax

; 2337 : 		{
; 2338 : #ifdef LS1DEBUG
; 2339 : 			printf("currency mark spell \n");
; 2340 : #endif
; 2341 : 
; 2342 : 			return(SPELL_WORD);

  016fb	0f 84 2f 03 00
	00		 je	 $L72763

; 2343 : 		}
; 2344 : 		if (llp->l_ch == '-'            /* Signs.               */
; 2345 : 		||  llp->l_ch == '+'
; 2346 : 		||  llp->l_ch == 0xB1) 

  01701	66 8b 03	 mov	 ax, WORD PTR [ebx]
  01704	66 3d 2d 00	 cmp	 ax, 45			; 0000002dH
  01708	74 0c		 je	 SHORT $L72758
  0170a	66 3d 2b 00	 cmp	 ax, 43			; 0000002bH
  0170e	74 06		 je	 SHORT $L72758
  01710	66 3d b1 00	 cmp	 ax, 177			; 000000b1H
  01714	75 22		 jne	 SHORT $L72760
$L72758:

; 2347 : 		{        						/* Plus-minus.          */
; 2348 : 
; 2349 : 			if (pLts_t->sign != 0)

  01716	8b 8e 18 11 00
	00		 mov	 ecx, DWORD PTR [esi+4376]
  0171c	85 c9		 test	 ecx, ecx

; 2350 : 			{
; 2351 : #ifdef LS1DEBUG
; 2352 : 			printf("sign spell \n");
; 2353 : #endif
; 2354 : 
; 2355 : 				return(SPELL_WORD);

  0171e	0f 85 0c 03 00
	00		 jne	 $L72763

; 2356 : 			}
; 2357 : 
; 2358 : 			pLts_t->sign = llp->l_ch;

  01724	0f bf c8	 movsx	 ecx, ax

; 2359 : 			if (++llp == rlp)       /* "$+"                 */

  01727	83 c3 08	 add	 ebx, 8
  0172a	89 8e 18 11 00
	00		 mov	 DWORD PTR [esi+4376], ecx
  01730	3b dd		 cmp	 ebx, ebp

; 2360 : 			{
; 2361 : #ifdef LS1DEBUG
; 2362 : 			printf(" spell from num sign proc \n");
; 2363 : #endif
; 2364 : 
; 2365 : 				return(SPELL_WORD);

  01732	0f 84 f8 02 00
	00		 je	 $L72763
$L72760:

; 2366 : 			}
; 2367 : 		}
; 2368 : 
; 2369 : 		lp2 = ls_task_parse_number(phTTS,llp, rlp, &num);

  01738	8d 54 24 14	 lea	 edx, DWORD PTR _num$[esp+44]
  0173c	52		 push	 edx
  0173d	55		 push	 ebp
  0173e	53		 push	 ebx
  0173f	57		 push	 edi
  01740	e8 00 00 00 00	 call	 _ls_task_parse_number

; 2370 : 		if (num.n_elp!=NULL || lp2!=rlp)

  01745	8b 4c 24 34	 mov	 ecx, DWORD PTR _num$[esp+76]
  01749	83 c4 10	 add	 esp, 16			; 00000010H
  0174c	85 c9		 test	 ecx, ecx
  0174e	0f 85 dc 02 00
	00		 jne	 $L72763
  01754	3b c5		 cmp	 eax, ebp
  01756	0f 85 d4 02 00
	00		 jne	 $L72763

; 2377 : 		}
; 2378 : 
; 2379 : 		/*
; 2380 : 		 * You need to look ahead to see if the
; 2381 : 		 * next word is one of the special words like
; 2382 : 		 * "million" that alters where the word "dollar" or
; 2383 : 		 * or "pound" is spoken.
; 2384 : 		 */
; 2385 : 
; 2386 : 		flag = FALSE;                   /* No ls_task_lookahead.        */
; 2387 : 		ls_task_lookahead(pLts_t);

  0175c	56		 push	 esi
  0175d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR _flag$[esp+44], 0
  01765	e8 00 00 00 00	 call	 _ls_task_lookahead

; 2388 : 		if (ls_util_is_white(&(pLts_t->citem)) != FALSE) 

  0176a	8d 86 00 09 00
	00		 lea	 eax, DWORD PTR [esi+2304]
  01770	50		 push	 eax
  01771	e8 00 00 00 00	 call	 _ls_util_is_white
  01776	83 c4 08	 add	 esp, 8
  01779	85 c0		 test	 eax, eax
  0177b	0f 84 af 00 00
	00		 je	 $L72765

; 2389 : 		{
; 2390 : 			flag = TRUE;            /* Did ls_task_lookahead.       */
; 2391 : 			ls_task_readword(phTTS,&(pLts_t->nword[0]));

  01781	8d ae 14 0d 00
	00		 lea	 ebp, DWORD PTR [esi+3348]
  01787	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR _flag$[esp+40], 1
  0178f	55		 push	 ebp
  01790	57		 push	 edi
  01791	e8 00 00 00 00	 call	 _ls_task_readword

; 2392 : 			cp = ls_task_wlookup(pLts_t, &(pLts_t->nword[0]), &nwdtab[0]);

  01796	68 00 00 00 00	 push	 OFFSET FLAT:_nwdtab
  0179b	55		 push	 ebp
  0179c	56		 push	 esi
  0179d	e8 00 00 00 00	 call	 _ls_task_wlookup
  017a2	83 c4 14	 add	 esp, 20			; 00000014H
  017a5	89 44 24 10	 mov	 DWORD PTR _cp$[esp+44], eax

; 2393 : 			if (cp != FALSE) 

  017a9	85 c0		 test	 eax, eax
  017ab	74 7f		 je	 SHORT $L73121

; 2394 : 			{
; 2395 : 				ls_proc_do_sign(phTTS,pLts_t->sign);

  017ad	8b 8e 18 11 00
	00		 mov	 ecx, DWORD PTR [esi+4376]
  017b3	51		 push	 ecx
  017b4	57		 push	 edi
  017b5	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 2396 : 				pLts_t->pflag=ls_proc_do_number(phTTS,llp, rlp, FALSE);

  017ba	8b 54 24 40	 mov	 edx, DWORD PTR _rlp$[esp+48]
  017be	6a 00		 push	 0
  017c0	52		 push	 edx
  017c1	53		 push	 ebx
  017c2	57		 push	 edi
  017c3	e8 00 00 00 00	 call	 _ls_proc_do_number
  017c8	89 86 24 11 00
	00		 mov	 DWORD PTR [esi+4388], eax

; 2397 : 				ls_util_send_phone(phTTS,pLts_t->rbphone);

  017ce	8b 86 20 11 00
	00		 mov	 eax, DWORD PTR [esi+4384]
  017d4	50		 push	 eax
  017d5	57		 push	 edi
  017d6	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2398 : 				ls_util_send_phone_list(phTTS,cp);

  017db	8b 4c 24 30	 mov	 ecx, DWORD PTR _cp$[esp+76]
  017df	51		 push	 ecx
  017e0	57		 push	 edi
  017e1	e8 00 00 00 00	 call	 _ls_util_send_phone_list
  017e6	83 c4 28	 add	 esp, 40			; 00000028H

; 2399 : 				llp = &(pLts_t->nword[0]);
; 2400 : 				while (llp->l_ch != EOS)

  017e9	66 83 7d 00 00	 cmp	 WORD PTR [ebp], 0
  017ee	74 0a		 je	 SHORT $L72768
$L72767:

; 2401 : 					++llp;

  017f0	83 c5 08	 add	 ebp, 8
  017f3	66 83 7d 00 00	 cmp	 WORD PTR [ebp], 0
  017f8	75 f6		 jne	 SHORT $L72767
$L72768:

; 2402 : 
; 2403 : #ifdef SPANISH
; 2404 : 				/* GL 11/16/1998, BATS#721 fix number with currency sign */
; 2405 : 				ls_util_send_phone(phTTS,WBOUND);
; 2406 : 				ls_util_send_phone(phTTS,E_D);
; 2407 : //				ls_util_send_phone(phTTS,S1);
; 2408 : 				ls_util_send_phone(phTTS,E_E);
; 2409 : #endif
; 2410 : 
; 2411 : 				ls_util_send_phone_list(phTTS,type=='$' ? pdollar : ppound);

  017fa	8b 44 24 34	 mov	 eax, DWORD PTR _type$[esp+40]
  017fe	83 f8 24	 cmp	 eax, 36			; 00000024H
  01801	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pdollar
  01806	74 05		 je	 SHORT $L73113
  01808	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_ppound
$L73113:
  0180d	50		 push	 eax
  0180e	57		 push	 edi
  0180f	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2412 : 
; 2413 : /* 
; 2414 :  * JDB: this looks like it is only for ENGLISH_US, so for now it's
; 2415 :  *  conditional
; 2416 :  */				
; 2417 : #ifdef ENGLISH_US
; 2418 : 				ls_util_send_phone(phTTS,Z);

  01814	6a 2a		 push	 42			; 0000002aH
  01816	57		 push	 edi
  01817	e8 00 00 00 00	 call	 _ls_util_send_phone
  0181c	83 c4 10	 add	 esp, 16			; 00000010H

; 2419 : #endif
; 2420 : #ifdef ENGLISH_UK
; 2421 : 				ls_util_send_phone(phTTS,Z);
; 2422 : #endif
; 2423 : /* GL 02/14/1997, add pural for Spanish */
; 2424 : #ifdef SPANISH
; 2425 : 				/* GL 11/16/1998, BATS#721 fix number with currency sign */
; 2426 : 				ls_util_send_phone(phTTS,E_E);
; 2427 : 				ls_util_send_phone(phTTS,E_S);
; 2428 : #endif
; 2429 : 				return(FINISHED_WORD);

  0181f	b8 03 00 00 00	 mov	 eax, 3
  01824	5f		 pop	 edi
  01825	5e		 pop	 esi
  01826	5d		 pop	 ebp
  01827	5b		 pop	 ebx

; 2573 : }

  01828	83 c4 1c	 add	 esp, 28			; 0000001cH
  0182b	c3		 ret	 0
$L73121:

; 2402 : 
; 2403 : #ifdef SPANISH
; 2404 : 				/* GL 11/16/1998, BATS#721 fix number with currency sign */
; 2405 : 				ls_util_send_phone(phTTS,WBOUND);
; 2406 : 				ls_util_send_phone(phTTS,E_D);
; 2407 : //				ls_util_send_phone(phTTS,S1);
; 2408 : 				ls_util_send_phone(phTTS,E_E);
; 2409 : #endif
; 2410 : 
; 2411 : 				ls_util_send_phone_list(phTTS,type=='$' ? pdollar : ppound);

  0182c	8b 6c 24 38	 mov	 ebp, DWORD PTR _rlp$[esp+40]
$L72765:

; 2430 : 			}
; 2431 : 		}
; 2432 : 
; 2433 : 		/*
; 2434 : 		 * $3      Three dollars.
; 2435 : 		 * $3.00   Three dollars.
; 2436 : 		 * $3.24   Three dollars and twenty four cents.
; 2437 : 		 * $3.240  Three point two four zero dollars.
; 2438 : 		 */
; 2439 : 
; 2440 : 		ls_proc_do_sign(phTTS,pLts_t->sign);

  01830	8b 96 18 11 00
	00		 mov	 edx, DWORD PTR [esi+4376]
  01836	52		 push	 edx
  01837	57		 push	 edi
  01838	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 2441 : 
; 2442 : 		if (num.n_flp==NULL || (num.n_frp-num.n_flp)==3)        

  0183d	8b 4c 24 24	 mov	 ecx, DWORD PTR _num$[esp+60]
  01841	83 c4 08	 add	 esp, 8
  01844	85 c9		 test	 ecx, ecx
  01846	0f 84 92 00 00
	00		 je	 $L72771
  0184c	8b 44 24 20	 mov	 eax, DWORD PTR _num$[esp+56]
  01850	2b c1		 sub	 eax, ecx
  01852	24 f8		 and	 al, -8			; fffffff8H
  01854	83 f8 18	 cmp	 eax, 24			; 00000018H
  01857	0f 84 81 00 00
	00		 je	 $L72771

; 2539 : 			}
; 2540 : 			return(FINISHED_WORD);
; 2541 : 		}
; 2542 : #if defined (SPANISH) || defined (GERMAN)
; 2543 : 		/* GL 02/15/1997, set to -1 to force Spanish say "1" as un  */
; 2544 : 		/* GL 02/17/1997, set to -1 to force German say "1" as ein  */
; 2545 : 		pLts_t->pflag = -1;
; 2546 : #endif
; 2547 : 		pLts_t->pflag = ls_proc_do_number(phTTS,llp, rlp, FALSE);

  0185d	6a 00		 push	 0
  0185f	55		 push	 ebp
  01860	53		 push	 ebx
  01861	57		 push	 edi
  01862	e8 00 00 00 00	 call	 _ls_proc_do_number
  01867	89 86 24 11 00
	00		 mov	 DWORD PTR [esi+4388], eax

; 2548 : 		ls_util_send_phone_list(phTTS,type=='$' ? pdollar : ppound);

  0186d	8b 44 24 44	 mov	 eax, DWORD PTR _type$[esp+56]
  01871	83 c4 10	 add	 esp, 16			; 00000010H
  01874	83 f8 24	 cmp	 eax, 36			; 00000024H
  01877	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pdollar
  0187c	74 05		 je	 SHORT $L73117
  0187e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_ppound
$L73117:
  01883	50		 push	 eax
  01884	57		 push	 edi
  01885	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2549 : 
; 2550 : /* JDB: again, ENGLISH plurals made conditional... */						
; 2551 : #ifdef ENGLISH_US
; 2552 : 		if (pLts_t->pflag != FALSE)

  0188a	8b 86 24 11 00
	00		 mov	 eax, DWORD PTR [esi+4388]
  01890	83 c4 08	 add	 esp, 8
  01893	85 c0		 test	 eax, eax
  01895	74 0b		 je	 SHORT $L72785

; 2553 : 			ls_util_send_phone(phTTS,Z);

  01897	6a 2a		 push	 42			; 0000002aH
  01899	57		 push	 edi
  0189a	e8 00 00 00 00	 call	 _ls_util_send_phone
  0189f	83 c4 08	 add	 esp, 8
$L72785:

; 2554 : #endif
; 2555 : #ifdef ENGLISH_UK
; 2556 : 		if (pLts_t->pflag != FALSE)
; 2557 : 			ls_util_send_phone(phTTS,Z);
; 2558 : #endif
; 2559 : /* GL 02/14/1997, add pural for Spanish */
; 2560 : #ifdef SPANISH
; 2561 : 		if (pLts_t->pflag != FALSE)
; 2562 : 			ls_util_send_phone(phTTS,E_S);
; 2563 : #endif
; 2564 : 		if (flag != FALSE) 

  018a2	8b 44 24 30	 mov	 eax, DWORD PTR _flag$[esp+40]
  018a6	85 c0		 test	 eax, eax
  018a8	0f 84 c3 00 00
	00		 je	 $L72784
$L72779:

; 2565 : 		{
; 2566 : 			ls_util_send_phone(phTTS,pLts_t->rbphone);

  018ae	8b 8e 20 11 00
	00		 mov	 ecx, DWORD PTR [esi+4384]
  018b4	51		 push	 ecx
  018b5	57		 push	 edi
  018b6	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2567 : 			ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));

  018bb	8d 96 14 0d 00
	00		 lea	 edx, DWORD PTR [esi+3348]
  018c1	81 c6 14 09 00
	00		 add	 esi, 2324		; 00000914H
  018c7	52		 push	 edx
  018c8	56		 push	 esi
  018c9	e8 00 00 00 00	 call	 _ls_util_copyword
  018ce	83 c4 10	 add	 esp, 16			; 00000010H

; 2568 : 			return(LS_TASK_LOOP);

  018d1	b8 01 00 00 00	 mov	 eax, 1
  018d6	5f		 pop	 edi
  018d7	5e		 pop	 esi
  018d8	5d		 pop	 ebp
  018d9	5b		 pop	 ebx

; 2573 : }

  018da	83 c4 1c	 add	 esp, 28			; 0000001cH
  018dd	c3		 ret	 0
$L72771:

; 2443 : 		{
; 2444 : 			if (num.n_ilp != NULL) 

  018de	8b 44 24 14	 mov	 eax, DWORD PTR _num$[esp+44]
  018e2	bb 30 00 00 00	 mov	 ebx, 48			; 00000030H
  018e7	85 c0		 test	 eax, eax
  018e9	0f 84 a1 00 00
	00		 je	 $L72773

; 2445 : 			{
; 2446 : 
; 2447 : #if defined (SPANISH) || defined (GERMAN)
; 2448 : 				/* GL 02/15/1997, set to -1 to force Spanish say "1" as un  */
; 2449 : 				/* GL 02/17/1997, set to -1 to force German say "1" as ein  */
; 2450 : 				pLts_t->pflag = -1;
; 2451 : #endif
; 2452 : 				pLts_t->pflag = ls_proc_do_number(phTTS,num.n_ilp, num.n_irp, FALSE);

  018ef	8b 4c 24 18	 mov	 ecx, DWORD PTR _num$[esp+48]
  018f3	6a 00		 push	 0
  018f5	51		 push	 ecx
  018f6	50		 push	 eax
  018f7	57		 push	 edi
  018f8	e8 00 00 00 00	 call	 _ls_proc_do_number
  018fd	89 86 24 11 00
	00		 mov	 DWORD PTR [esi+4388], eax

; 2453 : 
; 2454 : 				ls_util_send_phone_list(phTTS,type=='$' ? pdollar : ppound);

  01903	8b 44 24 44	 mov	 eax, DWORD PTR _type$[esp+56]
  01907	83 c4 10	 add	 esp, 16			; 00000010H
  0190a	83 f8 24	 cmp	 eax, 36			; 00000024H
  0190d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_pdollar
  01912	74 05		 je	 SHORT $L73115
  01914	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_ppound
$L73115:
  01919	50		 push	 eax
  0191a	57		 push	 edi
  0191b	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2455 : 
; 2456 : /* 
; 2457 :  * JDB: this is more plural stuff that doesn't seem to happen
; 2458 :  * in the spanish- make it conditional
; 2459 :  */
; 2460 : #ifdef ENGLISH_US
; 2461 : 				if (pLts_t->pflag != FALSE)

  01920	8b 86 24 11 00
	00		 mov	 eax, DWORD PTR [esi+4388]
  01926	83 c4 08	 add	 esp, 8
  01929	85 c0		 test	 eax, eax
  0192b	74 0b		 je	 SHORT $L72774

; 2462 : 					ls_util_send_phone(phTTS,Z);

  0192d	6a 2a		 push	 42			; 0000002aH
  0192f	57		 push	 edi
  01930	e8 00 00 00 00	 call	 _ls_util_send_phone
  01935	83 c4 08	 add	 esp, 8
$L72774:

; 2463 : #endif			
; 2464 : #ifdef ENGLISH_UK
; 2465 : 				if (pLts_t->pflag != FALSE)
; 2466 : 					ls_util_send_phone(phTTS,Z);
; 2467 : #endif							
; 2468 : /* GL 02/14/1997, add pural for Spanish */
; 2469 : #ifdef SPANISH
; 2470 : 				if (pLts_t->pflag != FALSE)
; 2471 : 				{
; 2472 : 					/* GL 11/16/1998, BATS#721 fix number with currency sign */
; 2473 : 					ls_util_send_phone(phTTS,E_E);
; 2474 : 				    ls_util_send_phone(phTTS,E_S);
; 2475 : 				}
; 2476 : #endif
; 2477 : 				if (num.n_flp == NULL) 

  01938	8b 44 24 1c	 mov	 eax, DWORD PTR _num$[esp+52]
  0193c	85 c0		 test	 eax, eax
  0193e	75 19		 jne	 SHORT $L72776

; 2478 : 				{
; 2479 : 					if (flag == FALSE)

  01940	8b 44 24 30	 mov	 eax, DWORD PTR _flag$[esp+40]
  01944	85 c0		 test	 eax, eax
  01946	0f 85 b4 00 00
	00		 jne	 $L72777
  0194c	5f		 pop	 edi
  0194d	5e		 pop	 esi
  0194e	5d		 pop	 ebp

; 2480 : 						return(FINISHED_WORD);

  0194f	b8 03 00 00 00	 mov	 eax, 3
  01954	5b		 pop	 ebx

; 2573 : }

  01955	83 c4 1c	 add	 esp, 28			; 0000001cH
  01958	c3		 ret	 0
$L72776:

; 2481 : 					ls_util_send_phone(phTTS,pLts_t->rbphone);
; 2482 : 
; 2483 : 					ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));
; 2484 : 
; 2485 : 					return(LS_TASK_LOOP);
; 2486 : 				}
; 2487 : 				if ((num.n_flp+1)->l_ch == '0'
; 2488 : 				&&  (num.n_flp+2)->l_ch == '0') 

  01959	66 39 58 08	 cmp	 WORD PTR [eax+8], bx
  0195d	75 1f		 jne	 SHORT $L72778
  0195f	66 39 58 10	 cmp	 WORD PTR [eax+16], bx
  01963	75 19		 jne	 SHORT $L72778

; 2489 : 				{
; 2490 : 
; 2491 : 					if (flag == FALSE)

  01965	8b 44 24 30	 mov	 eax, DWORD PTR _flag$[esp+40]
  01969	85 c0		 test	 eax, eax
  0196b	0f 85 3d ff ff
	ff		 jne	 $L72779
$L72784:
  01971	5f		 pop	 edi
  01972	5e		 pop	 esi
  01973	5d		 pop	 ebp

; 2492 : 						return(FINISHED_WORD);

  01974	b8 03 00 00 00	 mov	 eax, 3
  01979	5b		 pop	 ebx

; 2573 : }

  0197a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0197d	c3		 ret	 0
$L72778:

; 2493 : 					ls_util_send_phone(phTTS,pLts_t->rbphone);
; 2494 : 
; 2495 : 					ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));
; 2496 : 					return(LS_TASK_LOOP);
; 2497 : 				}
; 2498 : #ifndef ENGLISH_UK
; 2499 : 				ls_util_send_phone_list(phTTS,pand);

  0197e	68 00 00 00 00	 push	 OFFSET FLAT:_pand
  01983	57		 push	 edi
  01984	e8 00 00 00 00	 call	 _ls_util_send_phone_list
  01989	8b 4c 24 24	 mov	 ecx, DWORD PTR _num$[esp+60]
  0198d	83 c4 08	 add	 esp, 8
$L72773:

; 2500 : #endif
; 2501 : 			}
; 2502 : 			lp2 = num.n_flp + 1;    /* Just after the "."   */
; 2503 : 			if (lp2->l_ch == '0')

  01990	66 39 59 08	 cmp	 WORD PTR [ecx+8], bx
  01994	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  01997	75 03		 jne	 SHORT $L72780

; 2504 : 				++lp2;

  01999	83 c0 08	 add	 eax, 8
$L72780:

; 2505 : 
; 2506 : #if defined (SPANISH) || defined (GERMAN)
; 2507 : 				/* GL 02/15/1997, set to -1 to force Spanish say "1" as un  */
; 2508 : 				/* GL 02/17/1997, set to -1 to force German say "1" as ein  */
; 2509 : 				pLts_t->pflag = -1;
; 2510 : #endif
; 2511 : 			pLts_t->pflag = ls_proc_do_number(phTTS,lp2, num.n_frp, FALSE);

  0199c	8b 4c 24 20	 mov	 ecx, DWORD PTR _num$[esp+56]
  019a0	6a 00		 push	 0
  019a2	51		 push	 ecx
  019a3	50		 push	 eax
  019a4	57		 push	 edi
  019a5	e8 00 00 00 00	 call	 _ls_proc_do_number

; 2512 : 			ls_util_send_phone(phTTS,WBOUND);

  019aa	6a 6f		 push	 111			; 0000006fH
  019ac	57		 push	 edi
  019ad	89 86 24 11 00
	00		 mov	 DWORD PTR [esi+4388], eax
  019b3	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2513 : 			if (type == '$') 

  019b8	8b 44 24 4c	 mov	 eax, DWORD PTR _type$[esp+64]
  019bc	83 c4 18	 add	 esp, 24			; 00000018H
  019bf	83 f8 24	 cmp	 eax, 36			; 00000024H
  019c2	75 22		 jne	 SHORT $L72781

; 2514 : 			{
; 2515 : 				ls_util_send_phone_list(phTTS,pcent);

  019c4	68 00 00 00 00	 push	 OFFSET FLAT:_pcent
  019c9	57		 push	 edi
  019ca	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2516 : 				
; 2517 : /* JDB: again, ENGLISH plurals made conditional... */				
; 2518 : #ifdef ENGLISH_US
; 2519 : 				if (pLts_t->pflag != FALSE)

  019cf	8b 86 24 11 00
	00		 mov	 eax, DWORD PTR [esi+4388]
  019d5	83 c4 08	 add	 esp, 8
  019d8	85 c0		 test	 eax, eax
  019da	74 18		 je	 SHORT $L72783

; 2520 : 					ls_util_send_phone(phTTS,S);

  019dc	6a 29		 push	 41			; 00000029H
  019de	57		 push	 edi
  019df	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2521 : #endif					
; 2522 : #ifdef ENGLISH_UK
; 2523 : 				if (pLts_t->pflag != FALSE)
; 2524 : 					ls_util_send_phone(phTTS,S);
; 2525 : #endif					
; 2526 : /* GL 02/14/1997, add pural for Spanish */
; 2527 : #ifdef SPANISH
; 2528 : 				if (pLts_t->pflag != FALSE)
; 2529 : 					ls_util_send_phone(phTTS,E_S);
; 2530 : #endif
; 2531 : 			} 
; 2532 : 			else

  019e4	eb 0b		 jmp	 SHORT $L73123
$L72781:

; 2533 : 				ls_util_send_phone_list(phTTS,ppence);

  019e6	68 00 00 00 00	 push	 OFFSET FLAT:_ppence
  019eb	57		 push	 edi
  019ec	e8 00 00 00 00	 call	 _ls_util_send_phone_list
$L73123:
  019f1	83 c4 08	 add	 esp, 8
$L72783:

; 2534 : 			if (flag != FALSE) 

  019f4	8b 44 24 30	 mov	 eax, DWORD PTR _flag$[esp+40]
  019f8	85 c0		 test	 eax, eax
  019fa	0f 84 71 ff ff
	ff		 je	 $L72784
$L72777:

; 2535 : 			{
; 2536 : 				ls_util_send_phone(phTTS,pLts_t->rbphone);

  01a00	8b 96 20 11 00
	00		 mov	 edx, DWORD PTR [esi+4384]
  01a06	52		 push	 edx
  01a07	57		 push	 edi
  01a08	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2537 : 				ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));

  01a0d	8d 86 14 0d 00
	00		 lea	 eax, DWORD PTR [esi+3348]
  01a13	81 c6 14 09 00
	00		 add	 esi, 2324		; 00000914H
  01a19	50		 push	 eax
  01a1a	56		 push	 esi
  01a1b	e8 00 00 00 00	 call	 _ls_util_copyword
  01a20	83 c4 10	 add	 esp, 16			; 00000010H

; 2538 : 				return(LS_TASK_LOOP);

  01a23	b8 01 00 00 00	 mov	 eax, 1
  01a28	5f		 pop	 edi
  01a29	5e		 pop	 esi
  01a2a	5d		 pop	 ebp
  01a2b	5b		 pop	 ebx

; 2573 : }

  01a2c	83 c4 1c	 add	 esp, 28			; 0000001cH
  01a2f	c3		 ret	 0
$L72763:
  01a30	5f		 pop	 edi
  01a31	5e		 pop	 esi
  01a32	5d		 pop	 ebp

; 2371 : 		{
; 2372 : #ifdef LS1DEBUG
; 2373 : 			printf("ls_task_parse_number spell \n");
; 2374 : #endif
; 2375 : 
; 2376 : 			return(SPELL_WORD);

  01a33	b8 02 00 00 00	 mov	 eax, 2
  01a38	5b		 pop	 ebx

; 2573 : }

  01a39	83 c4 1c	 add	 esp, 28			; 0000001cH
  01a3c	c3		 ret	 0
_ls_task_currency_processing ENDP
_TEXT	ENDS
EXTRN	_ls_proc_do_date:NEAR
EXTRN	_ls_proc_is_date:NEAR
EXTRN	_ls_proc_do_time:NEAR
EXTRN	_ls_proc_is_am_pm:NEAR
EXTRN	_ls_proc_is_time:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_date_processing PROC NEAR

; 2598 : {  

  01a40	53		 push	 ebx

; 2599 : 	LETTER *lp1;
; 2600 : 	PLTS_T pLts_t;
; 2601 : 	
; 2602 : 	pLts_t = phTTS->pLTSThreadData;

  01a41	8b 5c 24 08	 mov	 ebx, DWORD PTR _phTTS$[esp]
  01a45	55		 push	 ebp
  01a46	56		 push	 esi
  01a47	57		 push	 edi
  01a48	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]

; 2603 : 	/*
; 2604 : 	 * Dates and times are handled by special
; 2605 : 	 * validation and speaking routines. Times are a little
; 2606 : 	 * bit special, because of "AM" and "PM" processing.
; 2607 : 	 * Fractions are special too, but less special then a
; 2608 : 	 * date or a time, because signs are legal.
; 2609 : 	 */
; 2610 : 
; 2611 : #ifdef LS1DEBUG
; 2612 : 	printf("date time processing ");
; 2613 : 	printf("left=%u  right=%u\n",llp,rlp);
; 2614 : #endif
; 2615 : 
; 2616 : 	if (pLts_t->sign == 0) 

  01a4b	8b 87 18 11 00
	00		 mov	 eax, DWORD PTR [edi+4376]
  01a51	85 c0		 test	 eax, eax
  01a53	0f 85 e7 00 00
	00		 jne	 $L72798

; 2617 : 	{
; 2618 : 		if (ls_proc_is_date(llp, rlp) != FALSE) 

  01a59	8b 74 24 1c	 mov	 esi, DWORD PTR _rlp$[esp+12]
  01a5d	8b 6c 24 18	 mov	 ebp, DWORD PTR _llp$[esp+12]
  01a61	56		 push	 esi
  01a62	55		 push	 ebp
  01a63	e8 00 00 00 00	 call	 _ls_proc_is_date
  01a68	83 c4 08	 add	 esp, 8
  01a6b	85 c0		 test	 eax, eax

; 2619 : 		{
; 2620 : 			ls_proc_do_date(phTTS,llp, rlp);

  01a6d	56		 push	 esi
  01a6e	55		 push	 ebp
  01a6f	74 13		 je	 SHORT $L72797
  01a71	53		 push	 ebx
  01a72	e8 00 00 00 00	 call	 _ls_proc_do_date
  01a77	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2621 : 			return(FINISHED_WORD);

  01a7a	b8 03 00 00 00	 mov	 eax, 3
  01a7f	5f		 pop	 edi
  01a80	5e		 pop	 esi
  01a81	5d		 pop	 ebp
  01a82	5b		 pop	 ebx

; 2657 : }

  01a83	c3		 ret	 0
$L72797:

; 2622 : 		} 
; 2623 : 		
; 2624 : 		if (ls_proc_is_time(pLts_t,llp, rlp) != FALSE) 

  01a84	57		 push	 edi
  01a85	e8 00 00 00 00	 call	 _ls_proc_is_time
  01a8a	83 c4 0c	 add	 esp, 12			; 0000000cH
  01a8d	85 c0		 test	 eax, eax
  01a8f	0f 84 ab 00 00
	00		 je	 $L72798

; 2625 : 		{
; 2626 : 			ls_proc_do_time(phTTS,llp, rlp);

  01a95	56		 push	 esi
  01a96	55		 push	 ebp
  01a97	53		 push	 ebx
  01a98	e8 00 00 00 00	 call	 _ls_proc_do_time

; 2627 : 			ls_task_lookahead(pLts_t);

  01a9d	57		 push	 edi
  01a9e	e8 00 00 00 00	 call	 _ls_task_lookahead

; 2628 : 			if (ls_util_is_white(&(pLts_t->citem)) == FALSE)

  01aa3	8d 87 00 09 00
	00		 lea	 eax, DWORD PTR [edi+2304]
  01aa9	50		 push	 eax
  01aaa	e8 00 00 00 00	 call	 _ls_util_is_white
  01aaf	83 c4 14	 add	 esp, 20			; 00000014H
  01ab2	85 c0		 test	 eax, eax
  01ab4	75 0a		 jne	 SHORT $L72799
  01ab6	5f		 pop	 edi
  01ab7	5e		 pop	 esi
  01ab8	5d		 pop	 ebp

; 2629 : 				return(FINISHED_WORD);

  01ab9	b8 03 00 00 00	 mov	 eax, 3
  01abe	5b		 pop	 ebx

; 2657 : }

  01abf	c3		 ret	 0
$L72799:

; 2630 : 			ls_util_send_phone(phTTS,pLts_t->rbphone);

  01ac0	8b 8f 20 11 00
	00		 mov	 ecx, DWORD PTR [edi+4384]
  01ac6	51		 push	 ecx
  01ac7	53		 push	 ebx
  01ac8	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2631 : 
; 2632 : 			ls_task_readword(phTTS,&(pLts_t->nword[0]));

  01acd	8d af 14 0d 00
	00		 lea	 ebp, DWORD PTR [edi+3348]
  01ad3	55		 push	 ebp
  01ad4	53		 push	 ebx
  01ad5	e8 00 00 00 00	 call	 _ls_task_readword

; 2633 : 
; 2634 : 			lp1 = &(pLts_t->nword[0]);

  01ada	8b f5		 mov	 esi, ebp
  01adc	83 c4 10	 add	 esp, 16			; 00000010H

; 2635 : 			while (lp1->l_ch != EOS)

  01adf	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  01ae3	74 09		 je	 SHORT $L72802
$L72801:

; 2636 : 				++lp1;       

  01ae5	83 c6 08	 add	 esi, 8
  01ae8	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  01aec	75 f7		 jne	 SHORT $L72801
$L72802:

; 2637 : 				
; 2638 : /* GL 02/13/1997, support am, pm for spanish as well since sometime they do use */
; 2639 : //#if defined (ENGLISH) || defined (GERMAN)	
; 2640 : 			if (ls_proc_is_am_pm(&(pLts_t->nword[0]), lp1) != FALSE)

  01aee	56		 push	 esi
  01aef	55		 push	 ebp
  01af0	e8 00 00 00 00	 call	 _ls_proc_is_am_pm
  01af5	83 c4 08	 add	 esp, 8
  01af8	85 c0		 test	 eax, eax
  01afa	74 2a		 je	 SHORT $L72803

; 2641 : 			{
; 2642 : #ifdef LS1DEBUG
; 2643 : 			printf("ls_proc_is_am_pm spell\n");
; 2644 : #endif
; 2645 : 				ls_spel_spell(phTTS,&(pLts_t->nword[0]), lp1);

  01afc	56		 push	 esi
  01afd	55		 push	 ebp
  01afe	53		 push	 ebx
  01aff	e8 00 00 00 00	 call	 _ls_spel_spell

; 2646 : 				ls_task_do_right_punct(phTTS,MISS);

  01b04	6a 00		 push	 0
  01b06	53		 push	 ebx
  01b07	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 2647 : 				ls_task_readword(phTTS,&(pLts_t->cword[0]));

  01b0c	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  01b12	57		 push	 edi
  01b13	53		 push	 ebx
  01b14	e8 00 00 00 00	 call	 _ls_task_readword
  01b19	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2648 : 
; 2649 : 				return(LS_TASK_LOOP);

  01b1c	b8 01 00 00 00	 mov	 eax, 1
  01b21	5f		 pop	 edi
  01b22	5e		 pop	 esi
  01b23	5d		 pop	 ebp
  01b24	5b		 pop	 ebx

; 2657 : }

  01b25	c3		 ret	 0
$L72803:

; 2650 : 			} 
; 2651 : //#endif			
; 2652 : 			ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));

  01b26	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  01b2c	55		 push	 ebp
  01b2d	57		 push	 edi
  01b2e	e8 00 00 00 00	 call	 _ls_util_copyword
  01b33	83 c4 08	 add	 esp, 8

; 2653 : 			return(LS_TASK_LOOP);

  01b36	b8 01 00 00 00	 mov	 eax, 1
  01b3b	5f		 pop	 edi
  01b3c	5e		 pop	 esi
  01b3d	5d		 pop	 ebp
  01b3e	5b		 pop	 ebx

; 2657 : }

  01b3f	c3		 ret	 0
$L72798:
  01b40	5f		 pop	 edi
  01b41	5e		 pop	 esi
  01b42	5d		 pop	 ebp

; 2654 : 		}
; 2655 : 	}
; 2656 : 	return(KEEP_SEARCHING);

  01b43	33 c0		 xor	 eax, eax
  01b45	5b		 pop	 ebx

; 2657 : }

  01b46	c3		 ret	 0
_ls_task_date_processing ENDP
_TEXT	ENDS
EXTRN	_ls_proc_is_frac:NEAR
EXTRN	_ls_proc_do_frac:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_frac_processing PROC NEAR

; 2682 : {

  01b50	53		 push	 ebx

; 2683 : 	PLTS_T pLts_t;
; 2684 : 	pLts_t = phTTS->pLTSThreadData;
; 2685 : #ifdef LS1DEBUG
; 2686 : 		printf("entering ls_task_frac_processing\n");
; 2687 : #endif             
; 2688 : 
; 2689 : /* GL 10/03/96  include fraction processing for Spanish */
; 2690 : #if defined (ENGLISH) || defined (SPANISH)	
; 2691 : 	if (ls_proc_is_frac(llp, rlp) != FALSE) 

  01b51	8b 5c 24 10	 mov	 ebx, DWORD PTR _rlp$[esp]
  01b55	55		 push	 ebp
  01b56	8b 6c 24 10	 mov	 ebp, DWORD PTR _llp$[esp+4]
  01b5a	56		 push	 esi
  01b5b	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  01b5f	57		 push	 edi
  01b60	53		 push	 ebx
  01b61	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  01b64	55		 push	 ebp
  01b65	e8 00 00 00 00	 call	 _ls_proc_is_frac
  01b6a	83 c4 08	 add	 esp, 8
  01b6d	85 c0		 test	 eax, eax
  01b6f	74 22		 je	 SHORT $L72812

; 2692 : 	{
; 2693 : 		ls_proc_do_sign(phTTS,pLts_t->sign);

  01b71	8b 87 18 11 00
	00		 mov	 eax, DWORD PTR [edi+4376]
  01b77	50		 push	 eax
  01b78	56		 push	 esi
  01b79	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 2694 : 
; 2695 : 		ls_proc_do_frac(phTTS,llp, rlp);

  01b7e	53		 push	 ebx
  01b7f	55		 push	 ebp
  01b80	56		 push	 esi
  01b81	e8 00 00 00 00	 call	 _ls_proc_do_frac
  01b86	83 c4 14	 add	 esp, 20			; 00000014H

; 2696 : 		return(FINISHED_WORD);

  01b89	b8 03 00 00 00	 mov	 eax, 3
  01b8e	5f		 pop	 edi
  01b8f	5e		 pop	 esi
  01b90	5d		 pop	 ebp
  01b91	5b		 pop	 ebx

; 2700 : }

  01b92	c3		 ret	 0
$L72812:
  01b93	5f		 pop	 edi
  01b94	5e		 pop	 esi
  01b95	5d		 pop	 ebp

; 2697 : 	}            
; 2698 : #endif	
; 2699 : 	return(KEEP_SEARCHING);

  01b96	33 c0		 xor	 eax, eax
  01b98	5b		 pop	 ebx

; 2700 : }

  01b99	c3		 ret	 0
_ls_task_frac_processing ENDP
_TEXT	ENDS
EXTRN	_pdegree:BYTE
EXTRN	_ppercent:BYTE
EXTRN	_ls_util_pluralize:NEAR
EXTRN	_ls_proc_do_4_digits:NEAR
EXTRN	_ls_util_is_year:NEAR
EXTRN	_ls_util_is_ordinal:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_lp1$ = 20
_num$ = -24
_ls_task_plain_number_processing PROC NEAR

; 2740 : 	LETTER  *lp2;
; 2741 : 	int     c;
; 2742 : 	NUM     num;
; 2743 : 	char    *cp;
; 2744 : 	PLTS_T pLts_t;
; 2745 : 	pLts_t = phTTS->pLTSThreadData;
; 2746 : 
; 2747 : 	 /* Kurz. now wants it to be symetrical with negative numbers
; 2748 : 	 EAB-4-11-89*/
; 2749 : #ifdef LS1DEBUG
; 2750 : 	printf("entering ls_task_plain_number_processing\n");
; 2751 : 	printf("number procesing ");
; 2752 : 	printf("left=%u  right=%u\n",llp,rlp);
; 2753 : #endif
; 2754 : /*ls_util_dump_llp_rlp(llp,rlp,"input number is:");*/	
; 2755 : 	if (lp1->l_ch == '.'                    /* As in ".5".          */
; 2756 : 	||  lp1->l_ch == 0xBC                   /* 1/4                  */
; 2757 : 	||  lp1->l_ch == 0xBD                   /* 1/2                  */
; 2758 : 	||  IS_DIGIT(lp1->l_ch))        		/* ls_proc_digit() */

  01ba0	8b 4c 24 10	 mov	 ecx, DWORD PTR _lp1$[esp-4]
  01ba4	83 ec 18	 sub	 esp, 24			; 00000018H
  01ba7	66 8b 01	 mov	 ax, WORD PTR [ecx]
  01baa	53		 push	 ebx
  01bab	55		 push	 ebp
  01bac	56		 push	 esi
  01bad	8b 74 24 28	 mov	 esi, DWORD PTR _phTTS$[esp+32]
  01bb1	57		 push	 edi
  01bb2	66 3d 2e 00	 cmp	 ax, 46			; 0000002eH
  01bb6	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  01bb9	74 1c		 je	 SHORT $L72828
  01bbb	66 3d bc 00	 cmp	 ax, 188			; 000000bcH
  01bbf	74 16		 je	 SHORT $L72828
  01bc1	66 3d bd 00	 cmp	 ax, 189			; 000000bdH
  01bc5	74 10		 je	 SHORT $L72828
  01bc7	0f bf c0	 movsx	 eax, ax
  01bca	f6 80 00 00 00
	00 10		 test	 BYTE PTR _ls_char_feat[eax], 16 ; 00000010H
  01bd1	0f 84 10 03 00
	00		 je	 $L72850
$L72828:

; 2759 : 	{
; 2760 : 		/* GL 9/10/1996, borrow pLts_t->isnumabr to set up the number indication */
; 2761 : 		pLts_t->isnumabr = 3;
; 2762 : 		lp2 = ls_task_parse_number(phTTS,lp1, rlp, &num);

  01bd7	8b 6c 24 34	 mov	 ebp, DWORD PTR _rlp$[esp+36]
  01bdb	8d 54 24 10	 lea	 edx, DWORD PTR _num$[esp+40]
  01bdf	52		 push	 edx
  01be0	55		 push	 ebp
  01be1	51		 push	 ecx
  01be2	56		 push	 esi
  01be3	c7 87 fc 08 00
	00 03 00 00 00	 mov	 DWORD PTR [edi+2300], 3
  01bed	e8 00 00 00 00	 call	 _ls_task_parse_number
  01bf2	8b d8		 mov	 ebx, eax
  01bf4	83 c4 10	 add	 esp, 16			; 00000010H

; 2763 : 		if (lp2 == rlp)

  01bf7	3b dd		 cmp	 ebx, ebp
  01bf9	0f 85 5b 01 00
	00		 jne	 $L72829

; 2764 : 		{           
; 2765 : 			/* All digits.          */
; 2766 : 			pLts_t->fc_struct[pLts_t->fc_index] = FC_ADJ;

  01bff	8b 87 bc 08 00
	00		 mov	 eax, DWORD PTR [edi+2236]
  01c05	c7 84 87 bc 04
	00 00 01 00 00
	00		 mov	 DWORD PTR [edi+eax*4+1212], 1

; 2767 : 
; 2768 : 			/*eab 8/94 numbers form class needs to be marked xxx*/
; 2769 : 
; 2770 : 			if (pLts_t->sign==0 && ls_util_is_year(llp, rlp)!=FALSE)

  01c10	8b 87 18 11 00
	00		 mov	 eax, DWORD PTR [edi+4376]
  01c16	85 c0		 test	 eax, eax
  01c18	75 28		 jne	 SHORT $L72830
  01c1a	8b 5c 24 30	 mov	 ebx, DWORD PTR _llp$[esp+36]
  01c1e	55		 push	 ebp
  01c1f	53		 push	 ebx
  01c20	e8 00 00 00 00	 call	 _ls_util_is_year
  01c25	83 c4 08	 add	 esp, 8
  01c28	85 c0		 test	 eax, eax
  01c2a	74 16		 je	 SHORT $L72830

; 2771 : 			{
; 2772 : /* GL 11/15/1996, only English need to take special care of 4 digits year */
; 2773 : #ifdef ENGLISH
; 2774 : 				ls_proc_do_4_digits(phTTS,llp);

  01c2c	53		 push	 ebx
  01c2d	56		 push	 esi
  01c2e	e8 00 00 00 00	 call	 _ls_proc_do_4_digits
  01c33	83 c4 08	 add	 esp, 8

; 2775 : #endif
; 2776 : #ifdef GERMAN
; 2777 : 				/* GL 02/13/1997  use 4 digits form for German years */
; 2778 : 				/* GL 04/10/1998  BATS#651 1000-1099, 2000+ pronunce the same way */
; 2779 : 				if ((lp1->l_ch != '1') || ((lp1->l_ch == '1') & ((lp1+1)->l_ch == '0')))
; 2780 : 					pLts_t->pflag = ls_proc_do_number(phTTS,lp1, rlp, ls_util_is_dot(pLts_t));
; 2781 : 				else
; 2782 : 					ls_proc_do_4_digits(phTTS,llp);
; 2783 : #endif
; 2784 : #ifdef SPANISH
; 2785 : 				pLts_t->pflag = ls_proc_do_number(phTTS,lp1, rlp, FALSE);
; 2786 : #endif
; 2787 : 				pLts_t->pflag = TRUE;   /* 1984 is plural.      */

  01c36	c7 87 24 11 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+4388], 1

; 2788 : 			}
; 2789 : 			else

  01c40	eb 24		 jmp	 SHORT $L72831
$L72830:

; 2790 : 			{
; 2791 : 				ls_proc_do_sign(phTTS,pLts_t->sign);

  01c42	8b 8f 18 11 00
	00		 mov	 ecx, DWORD PTR [edi+4376]
  01c48	51		 push	 ecx
  01c49	56		 push	 esi
  01c4a	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 2792 : #ifdef GERMAN
; 2793 : 				/* German use ending period to send ordial number */
; 2794 :                 pLts_t->pflag = ls_proc_do_number(phTTS,lp1, rlp, ls_util_is_dot(pLts_t));
; 2795 : #endif
; 2796 : #if defined (ENGLISH) || defined (SPANISH)
; 2797 : 				pLts_t->pflag = ls_proc_do_number(phTTS,lp1, rlp, FALSE);

  01c4f	8b 54 24 40	 mov	 edx, DWORD PTR _lp1$[esp+44]
  01c53	6a 00		 push	 0
  01c55	55		 push	 ebp
  01c56	52		 push	 edx
  01c57	56		 push	 esi
  01c58	e8 00 00 00 00	 call	 _ls_proc_do_number
  01c5d	83 c4 18	 add	 esp, 24			; 00000018H
  01c60	89 87 24 11 00
	00		 mov	 DWORD PTR [edi+4388], eax
$L72831:

; 2798 : #endif
; 2799 : 			}
; 2800 : 			
; 2801 : 			ls_task_lookahead(pLts_t);            			/* Watch for "ft."      */

  01c66	57		 push	 edi
  01c67	e8 00 00 00 00	 call	 _ls_task_lookahead

; 2802 : 
; 2803 : 			if (ls_util_is_white(&(pLts_t->citem)) == FALSE)

  01c6c	8d 87 00 09 00
	00		 lea	 eax, DWORD PTR [edi+2304]
  01c72	50		 push	 eax
  01c73	e8 00 00 00 00	 call	 _ls_util_is_white
  01c78	83 c4 08	 add	 esp, 8
  01c7b	85 c0		 test	 eax, eax

; 2804 : 			{
; 2805 : 				return(FINISHED_WORD);

  01c7d	0f 84 87 01 00
	00		 je	 $L73137

; 2806 : 			}
; 2807 : 			ls_util_send_phone(phTTS,pLts_t->rbphone);

  01c83	8b 8f 20 11 00
	00		 mov	 ecx, DWORD PTR [edi+4384]
  01c89	51		 push	 ecx
  01c8a	56		 push	 esi
  01c8b	e8 00 00 00 00	 call	 _ls_util_send_phone

; 2808 : 
; 2809 : 			ls_task_readword(phTTS,&(pLts_t->nword[0]));    /* Read next word.      */

  01c90	8d af 14 0d 00
	00		 lea	 ebp, DWORD PTR [edi+3348]
  01c96	55		 push	 ebp
  01c97	56		 push	 esi
  01c98	e8 00 00 00 00	 call	 _ls_task_readword

; 2810 : 
; 2811 : 			lp1 = &(pLts_t->nword[0]);

  01c9d	8b dd		 mov	 ebx, ebp
  01c9f	83 c4 10	 add	 esp, 16			; 00000010H

; 2812 : 			while (lp1->l_ch != EOS)

  01ca2	66 83 3b 00	 cmp	 WORD PTR [ebx], 0
  01ca6	74 09		 je	 SHORT $L72835
$L72834:

; 2813 : 				++lp1;

  01ca8	83 c3 08	 add	 ebx, 8
  01cab	66 83 3b 00	 cmp	 WORD PTR [ebx], 0
  01caf	75 f7		 jne	 SHORT $L72834
$L72835:

; 2814 : #if defined (ENGLISH) || defined (GERMAN)
; 2815 : 			if (ls_proc_is_am_pm(&(pLts_t->nword[0]), lp1) != FALSE) 

  01cb1	53		 push	 ebx
  01cb2	55		 push	 ebp
  01cb3	e8 00 00 00 00	 call	 _ls_proc_is_am_pm
  01cb8	83 c4 08	 add	 esp, 8
  01cbb	85 c0		 test	 eax, eax
  01cbd	74 0a		 je	 SHORT $L72836

; 2816 : 			{
; 2817 : #ifdef LS1DEBUG
; 2818 : 			printf("iasmpm spell\n");
; 2819 : #endif
; 2820 : 
; 2821 : 				ls_spel_spell(phTTS,&(pLts_t->nword[0]), lp1);

  01cbf	53		 push	 ebx
  01cc0	55		 push	 ebp
  01cc1	56		 push	 esi
  01cc2	e8 00 00 00 00	 call	 _ls_spel_spell

; 2822 : 				ls_task_do_right_punct(phTTS,MISS);
; 2823 : 				ls_task_readword(phTTS,&(pLts_t->cword[0]));
; 2824 : 
; 2825 : 				return(LS_TASK_LOOP);

  01cc7	eb 4f		 jmp	 SHORT $L73138
$L72836:

; 2826 : 			}
; 2827 : #endif
; 2828 : 
; 2829 : 			if (ls_util_is_dot(pLts_t) == FALSE    /* Check if special.    */
; 2830 : 			|| (cp=ls_task_wlookup (pLts_t, &(pLts_t->nword[0]), &nabtab[0]) ) == NULL)

  01cc9	57		 push	 edi
  01cca	e8 00 00 00 00	 call	 _ls_util_is_dot
  01ccf	83 c4 04	 add	 esp, 4
  01cd2	85 c0		 test	 eax, eax
  01cd4	74 67		 je	 SHORT $L72839
  01cd6	68 00 00 00 00	 push	 OFFSET FLAT:_nabtab
  01cdb	55		 push	 ebp
  01cdc	57		 push	 edi
  01cdd	e8 00 00 00 00	 call	 _ls_task_wlookup
  01ce2	83 c4 0c	 add	 esp, 12			; 0000000cH
  01ce5	85 c0		 test	 eax, eax
  01ce7	74 54		 je	 SHORT $L72839

; 2834 : 			}
; 2835 : 			pLts_t->isnumabr=3;
; 2836 : 
; 2837 : 			if (pLts_t->pflag != FALSE)

  01ce9	8b 8f 24 11 00
	00		 mov	 ecx, DWORD PTR [edi+4388]
  01cef	c7 87 fc 08 00
	00 03 00 00 00	 mov	 DWORD PTR [edi+2300], 3
  01cf9	85 c9		 test	 ecx, ecx
  01cfb	74 0e		 je	 SHORT $L72843

; 2838 : 			{   /* Pick right form.     */
; 2839 : 				while (*cp++ != SIL)

  01cfd	8a 10		 mov	 dl, BYTE PTR [eax]
  01cff	40		 inc	 eax
  01d00	84 d2		 test	 dl, dl
  01d02	74 07		 je	 SHORT $L72843
$L72842:
  01d04	8a 08		 mov	 cl, BYTE PTR [eax]
  01d06	40		 inc	 eax
  01d07	84 c9		 test	 cl, cl
  01d09	75 f9		 jne	 SHORT $L72842
$L72843:

; 2840 : 					;
; 2841 : 			}
; 2842 : 			ls_util_send_phone_list(phTTS,cp);           	/* Send abbreviation.   */

  01d0b	50		 push	 eax
  01d0c	56		 push	 esi
  01d0d	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2843 : 
; 2844 : 			ls_util_read_item(phTTS);             			/* Eat up the ".".      */

  01d12	56		 push	 esi
  01d13	e8 00 00 00 00	 call	 _ls_util_read_item
$L73138:

; 2845 : 			ls_task_do_right_punct(phTTS,MISS);

  01d18	6a 00		 push	 0
  01d1a	56		 push	 esi
  01d1b	e8 00 00 00 00	 call	 _ls_task_do_right_punct

; 2846 : 			ls_task_readword(phTTS,&(pLts_t->cword[0]));    /* Advance, continue.   */

  01d20	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  01d26	57		 push	 edi
  01d27	56		 push	 esi
  01d28	e8 00 00 00 00	 call	 _ls_task_readword
  01d2d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2847 : 
; 2848 : 			return(LS_TASK_LOOP);

  01d30	b8 01 00 00 00	 mov	 eax, 1
  01d35	5f		 pop	 edi
  01d36	5e		 pop	 esi
  01d37	5d		 pop	 ebp
  01d38	5b		 pop	 ebx

; 2934 : }

  01d39	83 c4 18	 add	 esp, 24			; 00000018H
  01d3c	c3		 ret	 0
$L72839:

; 2831 : 			{
; 2832 : 				ls_util_copyword(&(pLts_t->cword[0]), &(pLts_t->nword[0]));

  01d3d	81 c7 14 09 00
	00		 add	 edi, 2324		; 00000914H
  01d43	55		 push	 ebp
  01d44	57		 push	 edi
  01d45	e8 00 00 00 00	 call	 _ls_util_copyword
  01d4a	83 c4 08	 add	 esp, 8

; 2833 : 				return(LS_TASK_LOOP);

  01d4d	b8 01 00 00 00	 mov	 eax, 1
  01d52	5f		 pop	 edi
  01d53	5e		 pop	 esi
  01d54	5d		 pop	 ebp
  01d55	5b		 pop	 ebx

; 2934 : }

  01d56	83 c4 18	 add	 esp, 24			; 00000018H
  01d59	c3		 ret	 0
$L72829:

; 2849 : 		}
; 2850 : 
; 2851 : 		/*
; 2852 : 		 * Deal with plural numbers, like
; 2853 : 		 * "60s" and "60's". The last phoneme of
; 2854 : 		 * the number is hidden in "pLts_t->lphone", which is
; 2855 : 		 * looked at by the standard pluralizing
; 2856 : 		 * code in "ls7.c". Also deal with cents,
; 2857 : 		 * percents, and degrees.
; 2858 : 		 */
; 2859 :                          
; 2860 : /* JDB:  Spanish doesn't use this section! */                        
; 2861 : #ifdef ENGLISH
; 2862 : 		if (lp2+2 == rlp) 

  01d5a	8d 53 10	 lea	 edx, DWORD PTR [ebx+16]
  01d5d	3b d5		 cmp	 edx, ebp
  01d5f	75 6c		 jne	 SHORT $L72844

; 2863 : 		{             
; 2864 : 			/* 2 after the digits.  */
; 2865 : 			/* Plurals, like "60's".                        */
; 2866 : 			if (lp2->l_ch=='\'' && (lp2+1)->l_ch=='s') 

  01d61	66 83 3b 27	 cmp	 WORD PTR [ebx], 39	; 00000027H
  01d65	75 1e		 jne	 SHORT $L72845
  01d67	66 83 7b 08 73	 cmp	 WORD PTR [ebx+8], 115	; 00000073H
  01d6c	75 17		 jne	 SHORT $L72845

; 2867 : 			{
; 2868 : 				ls_proc_do_sign(phTTS,pLts_t->sign);

  01d6e	8b 87 18 11 00
	00		 mov	 eax, DWORD PTR [edi+4376]
  01d74	50		 push	 eax
  01d75	56		 push	 esi
  01d76	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 2869 : 
; 2870 : 				pLts_t->pflag=ls_proc_do_number(phTTS,lp1, lp2, FALSE);

  01d7b	8b 4c 24 40	 mov	 ecx, DWORD PTR _lp1$[esp+44]
  01d7f	6a 00		 push	 0
  01d81	53		 push	 ebx
  01d82	51		 push	 ecx

; 2871 : 				ls_util_pluralize(phTTS);
; 2872 : 				return(FINISHED_WORD);

  01d83	eb 70		 jmp	 SHORT $L73136
$L72845:

; 2873 : 			}               
; 2874 : #endif		 
; 2875 : /* JDB: end of dependent section */
; 2876 : 			
; 2877 : 			/* Ordinals, like "1st", "2nd", "3rd".          */
; 2878 : 			if (pLts_t->sign==0 && ls_util_is_ordinal(phTTS,&num)!=FALSE) 

  01d85	8b 87 18 11 00
	00		 mov	 eax, DWORD PTR [edi+4376]
  01d8b	85 c0		 test	 eax, eax
  01d8d	0f 85 54 01 00
	00		 jne	 $L72850
  01d93	8d 54 24 10	 lea	 edx, DWORD PTR _num$[esp+40]
  01d97	52		 push	 edx
  01d98	56		 push	 esi
  01d99	e8 00 00 00 00	 call	 _ls_util_is_ordinal
  01d9e	83 c4 08	 add	 esp, 8
  01da1	85 c0		 test	 eax, eax
  01da3	0f 84 3e 01 00
	00		 je	 $L72850

; 2879 : 			{
; 2880 : 				pLts_t->pflag=ls_proc_do_number(phTTS,llp, lp2, TRUE);

  01da9	8b 44 24 30	 mov	 eax, DWORD PTR _llp$[esp+36]
  01dad	6a 01		 push	 1
  01daf	53		 push	 ebx
  01db0	50		 push	 eax
  01db1	56		 push	 esi
  01db2	e8 00 00 00 00	 call	 _ls_proc_do_number
  01db7	83 c4 10	 add	 esp, 16			; 00000010H
  01dba	89 87 24 11 00
	00		 mov	 DWORD PTR [edi+4388], eax

; 2881 : 				return(FINISHED_WORD);

  01dc0	b8 03 00 00 00	 mov	 eax, 3
  01dc5	5f		 pop	 edi
  01dc6	5e		 pop	 esi
  01dc7	5d		 pop	 ebp
  01dc8	5b		 pop	 ebx

; 2934 : }

  01dc9	83 c4 18	 add	 esp, 24			; 00000018H
  01dcc	c3		 ret	 0
$L72844:

; 2882 : 			}
; 2883 : 
; 2884 : /* JDB:  Spanish doesn't use this section! */                        
; 2885 : #ifdef ENGLISH			
; 2886 : 		}
; 2887 : 		else
; 2888 : #endif		
; 2889 : 		if (lp2+1 == rlp) 

  01dcd	8d 4b 08	 lea	 ecx, DWORD PTR [ebx+8]
  01dd0	3b cd		 cmp	 ecx, ebp
  01dd2	0f 85 0f 01 00
	00		 jne	 $L72850

; 2890 : 		{      
; 2891 : 			/* 1 after the digits.  */
; 2892 : 			/* Plurals, like "60s". */
; 2893 : 			if ((c=lp2->l_ch) == 's') 

  01dd8	0f bf 2b	 movsx	 ebp, WORD PTR [ebx]
  01ddb	83 fd 73	 cmp	 ebp, 115		; 00000073H
  01dde	75 37		 jne	 SHORT $L72849

; 2894 : 			{           
; 2895 : 				ls_proc_do_sign(phTTS,pLts_t->sign);

  01de0	8b 97 18 11 00
	00		 mov	 edx, DWORD PTR [edi+4376]
  01de6	52		 push	 edx
  01de7	56		 push	 esi
  01de8	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 2896 : 				pLts_t->pflag=ls_proc_do_number(phTTS,lp1, lp2, FALSE);

  01ded	8b 44 24 40	 mov	 eax, DWORD PTR _lp1$[esp+44]
  01df1	6a 00		 push	 0
  01df3	53		 push	 ebx
  01df4	50		 push	 eax
$L73136:
  01df5	56		 push	 esi
  01df6	e8 00 00 00 00	 call	 _ls_proc_do_number

; 2897 : 				ls_util_pluralize(phTTS);

  01dfb	56		 push	 esi
  01dfc	89 87 24 11 00
	00		 mov	 DWORD PTR [edi+4388], eax
  01e02	e8 00 00 00 00	 call	 _ls_util_pluralize
  01e07	83 c4 1c	 add	 esp, 28			; 0000001cH
$L73137:
  01e0a	5f		 pop	 edi
  01e0b	5e		 pop	 esi
  01e0c	5d		 pop	 ebp

; 2898 : 				return(FINISHED_WORD);

  01e0d	b8 03 00 00 00	 mov	 eax, 3
  01e12	5b		 pop	 ebx

; 2934 : }

  01e13	83 c4 18	 add	 esp, 24			; 00000018H
  01e16	c3		 ret	 0
$L72849:

; 2899 : 			}
; 2900 : 			/* "10%", "10 cents", "10 degrees". */
; 2901 : 			if (c=='%' || c==0xA2 || c==0xB0) 

  01e17	83 fd 25	 cmp	 ebp, 37			; 00000025H
  01e1a	74 14		 je	 SHORT $L72851
  01e1c	81 fd a2 00 00
	00		 cmp	 ebp, 162		; 000000a2H
  01e22	74 0c		 je	 SHORT $L72851
  01e24	81 fd b0 00 00
	00		 cmp	 ebp, 176		; 000000b0H
  01e2a	0f 85 b7 00 00
	00		 jne	 $L72850
$L72851:

; 2902 : 			{
; 2903 : 				ls_proc_do_sign(phTTS,pLts_t->sign);

  01e30	8b 8f 18 11 00
	00		 mov	 ecx, DWORD PTR [edi+4376]
  01e36	51		 push	 ecx
  01e37	56		 push	 esi
  01e38	e8 00 00 00 00	 call	 _ls_proc_do_sign

; 2904 : 				pLts_t->pflag = ls_proc_do_number(phTTS,lp1, lp2, FALSE);

  01e3d	8b 54 24 40	 mov	 edx, DWORD PTR _lp1$[esp+44]
  01e41	6a 00		 push	 0
  01e43	53		 push	 ebx
  01e44	52		 push	 edx
  01e45	56		 push	 esi
  01e46	e8 00 00 00 00	 call	 _ls_proc_do_number
  01e4b	83 c4 18	 add	 esp, 24			; 00000018H

; 2905 : 				if (c == '%')

  01e4e	83 fd 25	 cmp	 ebp, 37			; 00000025H
  01e51	89 87 24 11 00
	00		 mov	 DWORD PTR [edi+4388], eax
  01e57	75 1b		 jne	 SHORT $L72852

; 2906 : 					ls_util_send_phone_list(phTTS,ppercent);

  01e59	68 00 00 00 00	 push	 OFFSET FLAT:_ppercent
  01e5e	56		 push	 esi
  01e5f	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2925 : 							ls_util_send_phone(phTTS,Z);

  01e64	83 c4 08	 add	 esp, 8

; 2926 : #endif							
; 2927 : 					}
; 2928 : 				}
; 2929 : 				return(FINISHED_WORD);

  01e67	b8 03 00 00 00	 mov	 eax, 3
  01e6c	5f		 pop	 edi
  01e6d	5e		 pop	 esi
  01e6e	5d		 pop	 ebp
  01e6f	5b		 pop	 ebx

; 2934 : }

  01e70	83 c4 18	 add	 esp, 24			; 00000018H
  01e73	c3		 ret	 0
$L72852:

; 2907 : 				else 
; 2908 : 				{
; 2909 : 					ls_util_send_phone(phTTS,WBOUND);

  01e74	6a 6f		 push	 111			; 0000006fH
  01e76	56		 push	 esi
  01e77	e8 00 00 00 00	 call	 _ls_util_send_phone
  01e7c	83 c4 08	 add	 esp, 8

; 2910 : 					if (c == 0xA2) 

  01e7f	81 fd a2 00 00
	00		 cmp	 ebp, 162		; 000000a2H
  01e85	75 30		 jne	 SHORT $L72854

; 2911 : 					{
; 2912 : 						ls_util_send_phone_list(phTTS,pcent);        

  01e87	68 00 00 00 00	 push	 OFFSET FLAT:_pcent
  01e8c	56		 push	 esi
  01e8d	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2913 : /* JDB: again, English plurals made conditional... */							
; 2914 : #ifdef ENGLISH						
; 2915 : 						if (pLts_t->pflag != FALSE)

  01e92	8b 87 24 11 00
	00		 mov	 eax, DWORD PTR [edi+4388]
  01e98	83 c4 08	 add	 esp, 8
  01e9b	85 c0		 test	 eax, eax
  01e9d	74 3b		 je	 SHORT $L72857

; 2916 : 							ls_util_send_phone(phTTS,S);

  01e9f	6a 29		 push	 41			; 00000029H

; 2925 : 							ls_util_send_phone(phTTS,Z);

  01ea1	56		 push	 esi
  01ea2	e8 00 00 00 00	 call	 _ls_util_send_phone
  01ea7	83 c4 08	 add	 esp, 8

; 2926 : #endif							
; 2927 : 					}
; 2928 : 				}
; 2929 : 				return(FINISHED_WORD);

  01eaa	b8 03 00 00 00	 mov	 eax, 3
  01eaf	5f		 pop	 edi
  01eb0	5e		 pop	 esi
  01eb1	5d		 pop	 ebp
  01eb2	5b		 pop	 ebx

; 2934 : }

  01eb3	83 c4 18	 add	 esp, 24			; 00000018H
  01eb6	c3		 ret	 0
$L72854:

; 2917 : #endif							
; 2918 : 					} 
; 2919 : 					else 
; 2920 : 					{
; 2921 : 						ls_util_send_phone_list(phTTS,pdegree);

  01eb7	68 00 00 00 00	 push	 OFFSET FLAT:_pdegree
  01ebc	56		 push	 esi
  01ebd	e8 00 00 00 00	 call	 _ls_util_send_phone_list

; 2922 : /* JDB: again, English plurals made conditional... */				
; 2923 : #ifdef ENGLISH						
; 2924 : 						if (pLts_t->pflag != FALSE)

  01ec2	8b 87 24 11 00
	00		 mov	 eax, DWORD PTR [edi+4388]
  01ec8	83 c4 08	 add	 esp, 8
  01ecb	85 c0		 test	 eax, eax
  01ecd	74 0b		 je	 SHORT $L72857

; 2925 : 							ls_util_send_phone(phTTS,Z);

  01ecf	6a 2a		 push	 42			; 0000002aH
  01ed1	56		 push	 esi
  01ed2	e8 00 00 00 00	 call	 _ls_util_send_phone
  01ed7	83 c4 08	 add	 esp, 8
$L72857:
  01eda	5f		 pop	 edi
  01edb	5e		 pop	 esi
  01edc	5d		 pop	 ebp

; 2926 : #endif							
; 2927 : 					}
; 2928 : 				}
; 2929 : 				return(FINISHED_WORD);

  01edd	b8 03 00 00 00	 mov	 eax, 3
  01ee2	5b		 pop	 ebx

; 2934 : }

  01ee3	83 c4 18	 add	 esp, 24			; 00000018H
  01ee6	c3		 ret	 0
$L72850:
  01ee7	5f		 pop	 edi
  01ee8	5e		 pop	 esi
  01ee9	5d		 pop	 ebp

; 2930 : 			}
; 2931 : 		}
; 2932 : 	}
; 2933 : 	return(KEEP_SEARCHING);

  01eea	33 c0		 xor	 eax, eax
  01eec	5b		 pop	 ebx

; 2934 : }

  01eed	83 c4 18	 add	 esp, 24			; 00000018H
  01ef0	c3		 ret	 0
_ls_task_plain_number_processing ENDP
_TEXT	ENDS
EXTRN	_ls_proc_do_part_number:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_ls_task_part_number PROC NEAR

; 2959 : {              

  01f00	55		 push	 ebp

; 2960 : 	int c;
; 2961 : 	LETTER *lp1;
; 2962 : 	PLTS_T pLts_t;
; 2963 : 	pLts_t = phTTS->pLTSThreadData;

  01f01	8b 6c 24 08	 mov	 ebp, DWORD PTR _phTTS$[esp]
  01f05	56		 push	 esi

; 2964 : 
; 2965 : #ifdef LS1DEBUG
; 2966 : 	printf("entering ls_task_part_number\n");
; 2967 : 	printf("no more heuristics ");
; 2968 : 	printf("left=%u  right=%u\n",llp,rlp);
; 2969 : #endif        
; 2970 : 	lp1=llp;
; 2971 : 	while (lp1 != rlp) 

  01f06	8b 74 24 14	 mov	 esi, DWORD PTR _rlp$[esp+4]
  01f0a	8b 55 10	 mov	 edx, DWORD PTR [ebp+16]
  01f0d	57		 push	 edi
  01f0e	8b 7c 24 14	 mov	 edi, DWORD PTR _llp$[esp+8]
  01f12	3b fe		 cmp	 edi, esi
  01f14	8b cf		 mov	 ecx, edi
  01f16	74 46		 je	 SHORT $L72870
$L72869:

; 2972 : 	{
; 2973 : 		c = lp1->l_ch;

  01f18	0f bf 01	 movsx	 eax, WORD PTR [ecx]

; 2974 : 		if (c=='/' || (c>='0' && c<='9'))

  01f1b	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  01f1e	74 29		 je	 SHORT $L72872
  01f20	83 f8 30	 cmp	 eax, 48			; 00000030H
  01f23	7c 05		 jl	 SHORT $L72871
  01f25	83 f8 39	 cmp	 eax, 57			; 00000039H
  01f28	7e 1f		 jle	 SHORT $L72872
$L72871:

; 2977 : 		}
; 2978 : 		else if (c == '\'')

  01f2a	83 f8 27	 cmp	 eax, 39			; 00000027H
  01f2d	75 0a		 jne	 SHORT $L72874

; 2979 : 		{
; 2980 : 			pLts_t->lflag |= SQUOTE;

  01f2f	8b 82 f8 08 00
	00		 mov	 eax, DWORD PTR [edx+2296]
  01f35	0c 08		 or	 al, 8

; 2981 : 		}
; 2982 : 		else if (c!='-' && !(IS_ALPHA(c)))

  01f37	eb 18		 jmp	 SHORT $L73143
$L72874:
  01f39	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  01f3c	74 19		 je	 SHORT $L72876
  01f3e	f6 80 00 00 00
	00 03		 test	 BYTE PTR _ls_char_feat[eax], 3
  01f45	74 27		 je	 SHORT $L73141
  01f47	eb 0e		 jmp	 SHORT $L72876
$L72872:

; 2975 : 		{
; 2976 : 			pLts_t->lflag |= DIGSLSH;

  01f49	8b 82 f8 08 00
	00		 mov	 eax, DWORD PTR [edx+2296]
  01f4f	0c 04		 or	 al, 4
$L73143:
  01f51	89 82 f8 08 00
	00		 mov	 DWORD PTR [edx+2296], eax
$L72876:

; 2983 : 		{
; 2984 : #ifdef LS1DEBUG
; 2985 : 			printf(" drop through spell %c  \n",c);
; 2986 : #endif
; 2987 : 
; 2988 : 			return(SPELL_WORD);
; 2989 : 		}
; 2990 : 		++lp1;

  01f57	83 c1 08	 add	 ecx, 8
  01f5a	3b ce		 cmp	 ecx, esi
  01f5c	75 ba		 jne	 SHORT $L72869
$L72870:

; 2991 : 	}
; 2992 : 	if (((pLts_t->lflag)&DIGSLSH) != 0) 

  01f5e	8b 92 f8 08 00
	00		 mov	 edx, DWORD PTR [edx+2296]
  01f64	f6 c2 04	 test	 dl, 4
  01f67	74 22		 je	 SHORT $L72877

; 2993 : 	{             /* Parts have digits or */
; 2994 : 		if (((pLts_t->lflag)&SQUOTE) != 0)        /* slashes, and do not  */

  01f69	f6 c2 08	 test	 dl, 8
  01f6c	74 09		 je	 SHORT $L72878
$L73141:
  01f6e	5f		 pop	 edi
  01f6f	5e		 pop	 esi

; 2995 : 		{
; 2996 : #ifdef LS1DEBUG
; 2997 : 			printf(" punt spell \n");
; 2998 : #endif
; 2999 : 			return(SPELL_WORD);

  01f70	b8 02 00 00 00	 mov	 eax, 2
  01f75	5d		 pop	 ebp

; 3005 : }

  01f76	c3		 ret	 0
$L72878:

; 3000 : 		}
; 3001 : 		ls_proc_do_part_number(phTTS,llp, rlp);

  01f77	56		 push	 esi
  01f78	57		 push	 edi
  01f79	55		 push	 ebp
  01f7a	e8 00 00 00 00	 call	 _ls_proc_do_part_number
  01f7f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3002 : 		return(FINISHED_WORD);

  01f82	b8 03 00 00 00	 mov	 eax, 3
  01f87	5f		 pop	 edi
  01f88	5e		 pop	 esi
  01f89	5d		 pop	 ebp

; 3005 : }

  01f8a	c3		 ret	 0
$L72877:
  01f8b	5f		 pop	 edi
  01f8c	5e		 pop	 esi

; 3003 : 	}
; 3004 : 	return(KEEP_SEARCHING);                           

  01f8d	33 c0		 xor	 eax, eax
  01f8f	5d		 pop	 ebp

; 3005 : }

  01f90	c3		 ret	 0
_ls_task_part_number ENDP
_TEXT	ENDS
EXTRN	_ls_rule_do_lts:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_llp$ = 12
_rlp$ = 16
_firsttim$ = 12
_ls_task_process_word PROC NEAR

; 3033 : 	volatile int    firsttim;
; 3034 : 	LETTER *lp1;
; 3035 : 	LETTER *lp2;
; 3036 : 	int     type;
; 3037 : 	int     c;
; 3038 : 	PLTS_T pLts_t;
; 3039 : 	pLts_t = phTTS->pLTSThreadData;
; 3040 : 	
; 3041 : 	/*
; 3042 : 	 * The second scan checks that each
; 3043 : 	 * chunk of of the word (which may be the whole word,
; 3044 : 	 * or a bit of a compound word) contains a vowel, and a
; 3045 : 	 * consonant except for some special cases. If you get
; 3046 : 	 * to the end without a fail, run the thing through
; 3047 : 	 * the letter to sound rules.
; 3048 : 	 */
; 3049 : #ifdef LS1DEBUG
; 3050 : 	printf("entering ls_task_process_word ");
; 3051 : 	printf("left=%u  right=%u\n",llp,rlp);
; 3052 : #endif
; 3053 : 
; 3054 : 	lp1 = llp;
; 3055 : 	firsttim=1;                             
; 3056 : 
; 3057 : 	while (lp1 != rlp)

  01fa0	8b 54 24 0c	 mov	 edx, DWORD PTR _rlp$[esp-4]
  01fa4	53		 push	 ebx
  01fa5	55		 push	 ebp
  01fa6	56		 push	 esi
  01fa7	8b 74 24 14	 mov	 esi, DWORD PTR _llp$[esp+8]
  01fab	57		 push	 edi
  01fac	8b 7c 24 14	 mov	 edi, DWORD PTR _phTTS$[esp+12]
  01fb0	3b f2		 cmp	 esi, edx
  01fb2	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _firsttim$[esp+12], 1
  01fba	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]
  01fbd	0f 84 b1 00 00
	00		 je	 $L73153
  01fc3	eb 04		 jmp	 SHORT $L72893
$L73157:
  01fc5	8b 54 24 1c	 mov	 edx, DWORD PTR _rlp$[esp+12]
$L72893:

; 3058 : 	{
; 3059 : 		lp2 = lp1;
; 3060 : 		pLts_t->lflag &= ~(HNONY|HCONS|HVOWEL);

  01fc9	8b 83 f8 08 00
	00		 mov	 eax, DWORD PTR [ebx+2296]
  01fcf	8b ee		 mov	 ebp, esi
  01fd1	24 4f		 and	 al, 79			; 0000004fH
  01fd3	89 83 f8 08 00
	00		 mov	 DWORD PTR [ebx+2296], eax
$L72896:

; 3061 : 		while (lp1!=rlp && (c=lp1->l_ch)!='-')

  01fd9	0f bf 0e	 movsx	 ecx, WORD PTR [esi]
  01fdc	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  01fdf	74 4f		 je	 SHORT $L72897

; 3062 : 		{
; 3063 : 			type = lsctype[c];

  01fe1	33 c0		 xor	 eax, eax
  01fe3	66 8b 04 4d 00
	00 00 00	 mov	 ax, WORD PTR _lsctype[ecx*2]

; 3064 : 			if ((type&C) != 0)

  01feb	f6 c4 04	 test	 ah, 4
  01fee	74 0a		 je	 SHORT $L72898

; 3065 : 				pLts_t->lflag |= HNONY|HCONS;

  01ff0	8b 83 f8 08 00
	00		 mov	 eax, DWORD PTR [ebx+2296]
  01ff6	0c a0		 or	 al, -96			; ffffffa0H

; 3066 : 			else 

  01ff8	eb 29		 jmp	 SHORT $L73159
$L72898:

; 3067 : 			{
; 3068 : 				/* 1/2/1997 GL, use OO (defined in ls_defs.h" for vowel checking */
; 3069 : 				if ((type&OO) != 0)

  01ffa	f6 c4 02	 test	 ah, 2
  01ffd	74 0a		 je	 SHORT $L72900

; 3070 : 					pLts_t->lflag |= HNONY|HVOWEL;

  01fff	8b 83 f8 08 00
	00		 mov	 eax, DWORD PTR [ebx+2296]
  02005	0c 90		 or	 al, -112		; ffffff90H

; 3071 : 				else 

  02007	eb 1a		 jmp	 SHORT $L73159
$L72900:

; 3072 : 				{
; 3073 : 					/* MG 11/04/1997 BATS#509 add 'Y for checking */  
; 3074 : 					if (c == 'y' || c == 'Y') 

  02009	83 f9 79	 cmp	 ecx, 121		; 00000079H
  0200c	74 05		 je	 SHORT $L72903
  0200e	83 f9 59	 cmp	 ecx, 89			; 00000059H
  02011	75 16		 jne	 SHORT $L72905
$L72903:

; 3075 : 					{           
; 3076 : /* JDB: language dependent */
; 3077 : #ifdef ENGLISH_US					
; 3078 : 						if (lp1 == lp2)
; 3079 : 							pLts_t->lflag |= HCONS;

  02013	8b 83 f8 08 00
	00		 mov	 eax, DWORD PTR [ebx+2296]
  02019	3b f5		 cmp	 esi, ebp
  0201b	75 04		 jne	 SHORT $L72904
  0201d	0c 20		 or	 al, 32			; 00000020H

; 3080 : 						else

  0201f	eb 02		 jmp	 SHORT $L73159
$L72904:

; 3081 : 							pLts_t->lflag |= HVOWEL;

  02021	0c 10		 or	 al, 16			; 00000010H
$L73159:
  02023	89 83 f8 08 00
	00		 mov	 DWORD PTR [ebx+2296], eax
$L72905:

; 3082 : #endif
; 3083 : #ifdef ENGLISH_UK
; 3084 : 						if (lp1 == lp2)
; 3085 : 							pLts_t->lflag |= HCONS;
; 3086 : 						else
; 3087 : 							pLts_t->lflag |= HVOWEL;
; 3088 : #endif
; 3089 : 
; 3090 : #ifdef SPANISH
; 3091 :                         pLts_t->lflag |= (HNONY | HCONS);							
; 3092 : #endif                        
; 3093 : 					}
; 3094 : 				}
; 3095 : 			}
; 3096 : 			++lp1;

  02029	83 c6 08	 add	 esi, 8
  0202c	3b f2		 cmp	 esi, edx
  0202e	75 a9		 jne	 SHORT $L72896
$L72897:

; 3097 : 		}
; 3098 : 
; 3099 : 		pLts_t->tlflag=pLts_t->lflag;

  02030	8b 83 f8 08 00
	00		 mov	 eax, DWORD PTR [ebx+2296]

; 3100 : 
; 3101 : #ifdef LS1DEBUG
; 3102 : 		printf("b2a %c %c %d\n",lp2->l_ch,lp1->l_ch, lp1->l_ch);
; 3103 : 		printf("looking \n");
; 3104 : 
; 3105 : #endif
; 3106 : 		/* ttlp1=lp1;   */
; 3107 : 		/* if(lp1->l_ch == '-') */ /* this is a bug */
; 3108 : 			/* ttlp1--;  */
; 3109 : 		if (ls_util_lookup(phTTS,lp2, lp1, FIRST) != MISS)

  02036	6a 00		 push	 0
  02038	56		 push	 esi
  02039	55		 push	 ebp
  0203a	57		 push	 edi
  0203b	89 83 14 11 00
	00		 mov	 DWORD PTR [ebx+4372], eax
  02041	e8 00 00 00 00	 call	 _ls_util_lookup
  02046	83 c4 10	 add	 esp, 16			; 00000010H
  02049	85 c0		 test	 eax, eax
  0204b	74 35		 je	 SHORT $L72906

; 3110 : 		{
; 3111 : #ifdef LS1DEBUG
; 3112 : 
; 3113 : 			printf("got a hit");
; 3114 : #endif
; 3115 : 			if(firsttim == 1)

  0204d	83 7c 24 18 01	 cmp	 DWORD PTR _firsttim$[esp+12], 1
  02052	75 2a		 jne	 SHORT $L72907

; 3116 : 			{
; 3117 : 				lp1++;
; 3118 : #ifdef LS1DEBUG
; 3119 : printf("sending hypen");
; 3120 : #endif
; 3121 : 				ls_util_send_phone(phTTS, HYPHEN );

  02054	6a 6e		 push	 110			; 0000006eH
  02056	57		 push	 edi
  02057	83 c6 08	 add	 esi, 8
  0205a	e8 00 00 00 00	 call	 _ls_util_send_phone
  0205f	83 c4 08	 add	 esp, 8

; 3122 : 				lp2=lp1;
; 3123 : 				llp=lp1;
; 3124 : 				firsttim=0;

  02062	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _firsttim$[esp+12], 0
$L72923:
  0206a	3b 74 24 1c	 cmp	 esi, DWORD PTR _rlp$[esp+12]
  0206e	0f 85 51 ff ff
	ff		 jne	 $L73157
$L73153:
  02074	5f		 pop	 edi
  02075	5e		 pop	 esi
  02076	5d		 pop	 ebp

; 3218 : 		}
; 3219 : 	}
; 3220 : 	return(FINISHED_WORD);

  02077	b8 03 00 00 00	 mov	 eax, 3
  0207c	5b		 pop	 ebx

; 3221 : }

  0207d	c3		 ret	 0
$L72907:

; 3125 : 				continue;
; 3126 : 			}
; 3127 : 			lp2=lp1;

  0207e	8b ee		 mov	 ebp, esi

; 3128 : 			llp=lp1;
; 3129 : 		}
; 3130 : 		else

  02080	eb 62		 jmp	 SHORT $L72915
$L72906:

; 3131 : 		{ 
; 3132 : 			/* MGS 6/13/97 BATS #389 changed so single letters get spelled */
; 3133 : 			if( ((pLts_t->tlflag)&HVOWEL) != 0  && (lp2+1 != lp1))

  02082	f6 83 14 11 00
	00 10		 test	 BYTE PTR [ebx+4372], 16	; 00000010H
  02089	74 59		 je	 SHORT $L72915
  0208b	8d 4d 08	 lea	 ecx, DWORD PTR [ebp+8]
  0208e	3b ce		 cmp	 ecx, esi
  02090	74 52		 je	 SHORT $L72915

; 3134 : 			{
; 3135 : #ifdef LS1DEBUG
; 3136 : 				printf("doing lts1 ");
; 3137 : 				printf("left=%u  right=%u\n",lp2,lp1);
; 3138 : #endif
; 3139 : #ifdef DUMP_WORD
; 3140 : 				//printf("doing lts1\n");
; 3141 : #endif
; 3142 : 
; 3143 : 				/* MGS 6/16/97 BATS #387 Added becasue rule engine needs lower case characters */
; 3144 : 				ls_task_remove_case(lp2,lp1);

  02092	56		 push	 esi
  02093	55		 push	 ebp
  02094	e8 00 00 00 00	 call	 _ls_task_remove_case

; 3145 : 
; 3146 : 				ls_rule_do_lts(phTTS,lp2, lp1);

  02099	56		 push	 esi
  0209a	55		 push	 ebp
  0209b	57		 push	 edi
  0209c	e8 00 00 00 00	 call	 _ls_rule_do_lts
  020a1	83 c4 14	 add	 esp, 20			; 00000014H

; 3147 : 
; 3148 : #ifdef DUMP_WORD
; 3149 : 				//printf("done lts1\n");
; 3150 : #endif
; 3151 : #ifdef LS1DEBUG
; 3152 : 
; 3153 : 				printf("done lts1 ");
; 3154 : 				printf("left=%u  right=%u\n",lp2,lp1);
; 3155 : #endif
; 3156 : 				if (lp1 != rlp)

  020a4	8b 44 24 1c	 mov	 eax, DWORD PTR _rlp$[esp+12]
  020a8	3b f0		 cmp	 esi, eax

; 3157 : 				{               /* Inter-chunk gap.     */
; 3158 : 					lp2 = lp1;

  020aa	8b ee		 mov	 ebp, esi

; 3147 : 
; 3148 : #ifdef DUMP_WORD
; 3149 : 				//printf("done lts1\n");
; 3150 : #endif
; 3151 : #ifdef LS1DEBUG
; 3152 : 
; 3153 : 				printf("done lts1 ");
; 3154 : 				printf("left=%u  right=%u\n",lp2,lp1);
; 3155 : #endif
; 3156 : 				if (lp1 != rlp)

  020ac	74 36		 je	 SHORT $L72915
$L72912:

; 3159 : 					while (lp1!=rlp && lp1->l_ch=='-')

  020ae	66 83 3e 2d	 cmp	 WORD PTR [esi], 45	; 0000002dH
  020b2	75 07		 jne	 SHORT $L72913

; 3160 : 						++lp1;

  020b4	83 c6 08	 add	 esi, 8
  020b7	3b f0		 cmp	 esi, eax
  020b9	75 f3		 jne	 SHORT $L72912
$L72913:

; 3161 : 					llp=lp1; 
; 3162 : 					/* GL 03/04/1997  Who add this one? it is a bug */
; 3163 : 					/* it will force lp2_1  never equal to lp1 */
; 3164 : 					/*lp2=lp1;*/
; 3165 : 					ls_util_send_phone(phTTS,lp2+1==lp1 ? HYPHEN : COMMA);

  020bb	8d 7d 08	 lea	 edi, DWORD PTR [ebp+8]
  020be	8b 44 24 14	 mov	 eax, DWORD PTR _phTTS$[esp+12]
  020c2	8b d7		 mov	 edx, edi
  020c4	2b d6		 sub	 edx, esi
  020c6	f7 da		 neg	 edx
  020c8	1b d2		 sbb	 edx, edx
  020ca	83 e2 05	 and	 edx, 5
  020cd	83 c2 6e	 add	 edx, 110		; 0000006eH
  020d0	52		 push	 edx
  020d1	50		 push	 eax
  020d2	e8 00 00 00 00	 call	 _ls_util_send_phone
  020d7	83 c4 08	 add	 esp, 8

; 3166 : 					/* MGS 6/13/97 BATS #389 added for f-a-r wont say ef a dash r */
; 3167 : 					if (lp2+1==lp1)

  020da	3b fe		 cmp	 edi, esi
  020dc	75 02		 jne	 SHORT $L73156

; 3168 : 						lp2++;

  020de	8b ef		 mov	 ebp, edi
$L73156:

; 3169 : 				}
; 3170 : 				else

  020e0	8b 7c 24 14	 mov	 edi, DWORD PTR _phTTS$[esp+12]
$L72915:

; 3171 : 				{
; 3172 : 					llp=lp1;
; 3173 : 					lp2=lp1;
; 3174 : 				}
; 3175 : #ifdef LS1DEBUG
; 3176 : 				printf("done lts1 333");
; 3177 : 				printf("left=%u  right=%u\n",llp,rlp);
; 3178 : #endif
; 3179 : 			}
; 3180 : 		}
; 3181 : 		firsttim=0;   
; 3182 : 		if (lp2!=lp1)

  020e4	3b ee		 cmp	 ebp, esi
  020e6	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _firsttim$[esp+12], 0
  020ee	74 3c		 je	 SHORT $L72919

; 3183 : 		{
; 3184 : 			if (((pLts_t->lflag)&HNONY) == 0)         /* Spell if all "y".    */

  020f0	f6 83 f8 08 00
	00 80		 test	 BYTE PTR [ebx+2296], -128 ; ffffff80H
  020f7	75 0b		 jne	 SHORT $L72917

; 3185 : 			{
; 3186 : #ifdef LS1DEBUG
; 3187 : 				printf(" spell all y \n");
; 3188 : #endif
; 3189 : 				ls_spel_spell(phTTS,lp2,lp1);

  020f9	56		 push	 esi
  020fa	55		 push	 ebp
  020fb	57		 push	 edi
  020fc	e8 00 00 00 00	 call	 _ls_spel_spell
  02101	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72917:

; 3190 : 				/* return(SPELL_WORD); */
; 3191 : 			}
; 3192 : 			if (((pLts_t->lflag)&HVOWEL) == 0)        /* Spell if no vowels.  */

  02104	f6 83 f8 08 00
	00 10		 test	 BYTE PTR [ebx+2296], 16	; 00000010H
  0210b	75 0b		 jne	 SHORT $L72918

; 3193 : 			{
; 3194 : #ifdef LS1DEBUG
; 3195 : 				printf("spell no vowel  \n");
; 3196 : #endif
; 3197 : 				ls_spel_spell(phTTS,lp2,lp1);

  0210d	56		 push	 esi
  0210e	55		 push	 ebp
  0210f	57		 push	 edi
  02110	e8 00 00 00 00	 call	 _ls_spel_spell
  02115	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72918:

; 3198 : 				/* return(SPELL_WORD); */
; 3199 : 			}
; 3200 : 			if (((pLts_t->lflag)&HCONS) == 0)

  02118	f6 83 f8 08 00
	00 20		 test	 BYTE PTR [ebx+2296], 32	; 00000020H
  0211f	75 0b		 jne	 SHORT $L72919

; 3201 : 			{       /* If no consonant, the */
; 3202 : 				/* if (lp2+1 != lp1)
; 3203 : 				{ */
; 3204 : #ifdef LS1DEBUG
; 3205 : 					printf(" spell no cons. \n");
; 3206 : #endif
; 3207 : 					ls_spel_spell(phTTS,lp2,lp1);

  02121	56		 push	 esi
  02122	55		 push	 ebp
  02123	57		 push	 edi
  02124	e8 00 00 00 00	 call	 _ls_spel_spell
  02129	83 c4 0c	 add	 esp, 12			; 0000000cH
$L72919:

; 3208 : 					/* return(SPELL_WORD); */   /* are legal.*/         
; 3209 : 			/*  } */
; 3210 : 
; 3211 : 			}
; 3212 : 		}
; 3213 : 		if (lp1 != rlp)

  0212c	8b 44 24 1c	 mov	 eax, DWORD PTR _rlp$[esp+12]
  02130	3b f0		 cmp	 esi, eax
  02132	0f 84 3c ff ff
	ff		 je	 $L73153

; 3214 : 		{               /* Hit "-", allow long  */
; 3215 : 			pLts_t->lflag |= HHYPHEN;       /* blocks of "---".     */

  02138	83 8b f8 08 00
	00 40		 or	 DWORD PTR [ebx+2296], 64 ; 00000040H
$L72922:

; 3216 : 			while (lp1!=rlp && lp1->l_ch=='-')

  0213f	66 83 3e 2d	 cmp	 WORD PTR [esi], 45	; 0000002dH
  02143	0f 85 21 ff ff
	ff		 jne	 $L72923

; 3217 : 				++lp1;

  02149	83 c6 08	 add	 esi, 8
  0214c	3b f0		 cmp	 esi, eax
  0214e	0f 84 20 ff ff
	ff		 je	 $L73153

; 3216 : 			while (lp1!=rlp && lp1->l_ch=='-')

  02154	eb e9		 jmp	 SHORT $L72922
_ls_task_process_word ENDP
_phTTS$ = 8
_pLts_t$ = -4
_ls_task_lookup_first_verbs PROC NEAR

; 3254 : {

  02160	51		 push	 ecx

; 3255 : 	PLTS_T pLts_t;
; 3256 : 	PKSD_T pKsd_t;
; 3257 : 	LETTER *llp, *rlp, *elp;
; 3258 : 	int j,i;
; 3259 : 	pKsd_t = phTTS->pKernelShareData;
; 3260 : 	pLts_t = phTTS->pLTSThreadData;

  02161	8b 44 24 08	 mov	 eax, DWORD PTR _phTTS$[esp]
  02165	53		 push	 ebx
  02166	55		 push	 ebp
  02167	56		 push	 esi
  02168	8b 68 10	 mov	 ebp, DWORD PTR [eax+16]
  0216b	57		 push	 edi
  0216c	89 6c 24 10	 mov	 DWORD PTR _pLts_t$[esp+20], ebp

; 3261 : 	llp = &(pLts_t->cword[0]);

  02170	81 c5 14 09 00
	00		 add	 ebp, 2324		; 00000914H

; 3262 : 	
; 3263 : #if 0
; 3264 : 	for (i=0;i<6;i++)
; 3265 : 	{
; 3266 : 		WINprintf("%d %s %c%c %c%c %c%c %c%c %c%c\n",i,verbs[i].word,
; 3267 : 			pKsd_t->arpabet[(verbs[i].phone[0])<<1],pKsd_t->arpabet[((verbs[i].phone[0])<<1)+1],
; 3268 : 			pKsd_t->arpabet[(verbs[i].phone[1])<<1],pKsd_t->arpabet[((verbs[i].phone[1])<<1)+1],
; 3269 : 			pKsd_t->arpabet[(verbs[i].phone[2])<<1],pKsd_t->arpabet[((verbs[i].phone[2])<<1)+1],
; 3270 : 			pKsd_t->arpabet[(verbs[i].phone[3])<<1],pKsd_t->arpabet[((verbs[i].phone[3])<<1)+1],
; 3271 : 			pKsd_t->arpabet[(verbs[i].phone[4])<<1],pKsd_t->arpabet[((verbs[i].phone[4])<<1)+1]);
; 3272 : 	}
; 3273 : #endif
; 3274 : 	for (i=0;i<6;i++)

  02176	33 ff		 xor	 edi, edi
  02178	33 f6		 xor	 esi, esi
$L72940:

; 3275 : 	{
; 3276 : 		j=0;
; 3277 : 		elp=llp;
; 3278 : 		while (elp->l_ch !=EOS)

  0217a	66 8b 45 00	 mov	 ax, WORD PTR [ebp]
  0217e	33 d2		 xor	 edx, edx
  02180	66 85 c0	 test	 ax, ax
  02183	8b cd		 mov	 ecx, ebp
  02185	74 24		 je	 SHORT $L73164
$L72944:

; 3279 : 		{
; 3280 : 			if (verbs[i].word[j]!=ls_lower[elp->l_ch])

  02187	0f bf c0	 movsx	 eax, ax
  0218a	33 db		 xor	 ebx, ebx
  0218c	8a 98 00 00 00
	00		 mov	 bl, BYTE PTR _ls_lower[eax]
  02192	0f be 84 16 00
	00 00 00	 movsx	 eax, BYTE PTR _verbs[esi+edx]
  0219a	3b c3		 cmp	 eax, ebx
  0219c	75 0d		 jne	 SHORT $L73164
  0219e	66 8b 41 08	 mov	 ax, WORD PTR [ecx+8]

; 3281 : 			{
; 3282 : 				break;
; 3283 : 			}
; 3284 : 			j++;
; 3285 : 			elp++;

  021a2	83 c1 08	 add	 ecx, 8
  021a5	42		 inc	 edx
  021a6	66 85 c0	 test	 ax, ax
  021a9	75 dc		 jne	 SHORT $L72944
$L73164:

; 3286 : 		}
; 3287 : 		if (verbs[i].word[j]==ls_lower[elp->l_ch] && verbs[i].word[j]==0)

  021ab	0f bf 09	 movsx	 ecx, WORD PTR [ecx]
  021ae	8a 94 16 00 00
	00 00		 mov	 dl, BYTE PTR _verbs[esi+edx]
  021b5	33 c0		 xor	 eax, eax
  021b7	8a 81 00 00 00
	00		 mov	 al, BYTE PTR _ls_lower[ecx]
  021bd	0f be ca	 movsx	 ecx, dl
  021c0	3b c8		 cmp	 ecx, eax
  021c2	75 04		 jne	 SHORT $L72941
  021c4	84 d2		 test	 dl, dl
  021c6	74 14		 je	 SHORT $L73165
$L72941:

; 3262 : 	
; 3263 : #if 0
; 3264 : 	for (i=0;i<6;i++)
; 3265 : 	{
; 3266 : 		WINprintf("%d %s %c%c %c%c %c%c %c%c %c%c\n",i,verbs[i].word,
; 3267 : 			pKsd_t->arpabet[(verbs[i].phone[0])<<1],pKsd_t->arpabet[((verbs[i].phone[0])<<1)+1],
; 3268 : 			pKsd_t->arpabet[(verbs[i].phone[1])<<1],pKsd_t->arpabet[((verbs[i].phone[1])<<1)+1],
; 3269 : 			pKsd_t->arpabet[(verbs[i].phone[2])<<1],pKsd_t->arpabet[((verbs[i].phone[2])<<1)+1],
; 3270 : 			pKsd_t->arpabet[(verbs[i].phone[3])<<1],pKsd_t->arpabet[((verbs[i].phone[3])<<1)+1],
; 3271 : 			pKsd_t->arpabet[(verbs[i].phone[4])<<1],pKsd_t->arpabet[((verbs[i].phone[4])<<1)+1]);
; 3272 : 	}
; 3273 : #endif
; 3274 : 	for (i=0;i<6;i++)

  021c8	83 c6 20	 add	 esi, 32			; 00000020H
  021cb	47		 inc	 edi
  021cc	81 fe c0 00 00
	00		 cmp	 esi, 192		; 000000c0H
  021d2	7c a6		 jl	 SHORT $L72940
  021d4	5f		 pop	 edi
  021d5	5e		 pop	 esi
  021d6	5d		 pop	 ebp

; 3299 : 		}
; 3300 : 	}
; 3301 : 	return(KEEP_SEARCHING);

  021d7	33 c0		 xor	 eax, eax
  021d9	5b		 pop	 ebx

; 3302 : }

  021da	59		 pop	 ecx
  021db	c3		 ret	 0
$L73165:

; 3288 : 		{
; 3289 : 			pLts_t->fc_struct[1] = verbs[i].fc;

  021dc	8b 5c 24 10	 mov	 ebx, DWORD PTR _pLts_t$[esp+20]
  021e0	8b cf		 mov	 ecx, edi
  021e2	c1 e1 05	 shl	 ecx, 5

; 3290 : 			j=0;
; 3291 : 			while (verbs[i].phone[j]!=SIL)

  021e5	c1 e7 05	 shl	 edi, 5
  021e8	8b 91 1c 00 00
	00		 mov	 edx, DWORD PTR _verbs[ecx+28]
  021ee	89 93 c0 04 00
	00		 mov	 DWORD PTR [ebx+1216], edx
  021f4	8b 87 08 00 00
	00		 mov	 eax, DWORD PTR _verbs[edi+8]
  021fa	85 c0		 test	 eax, eax
  021fc	74 1e		 je	 SHORT $L72950
  021fe	8b 7c 24 18	 mov	 edi, DWORD PTR _phTTS$[esp+16]
  02202	8d b1 08 00 00
	00		 lea	 esi, DWORD PTR _verbs[ecx+8]
$L72949:

; 3292 : 			{
; 3293 : 				ls_util_send_phone(phTTS,verbs[i].phone[j]);

  02208	50		 push	 eax
  02209	57		 push	 edi
  0220a	e8 00 00 00 00	 call	 _ls_util_send_phone
  0220f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 3294 : 				j++;

  02212	83 c6 04	 add	 esi, 4
  02215	83 c4 08	 add	 esp, 8
  02218	85 c0		 test	 eax, eax
  0221a	75 ec		 jne	 SHORT $L72949
$L72950:

; 3295 : 			}		
; 3296 : 			pLts_t->lbphone=WBOUND;

  0221c	b8 6f 00 00 00	 mov	 eax, 111		; 0000006fH
  02221	5f		 pop	 edi
  02222	5e		 pop	 esi
  02223	89 83 1c 11 00
	00		 mov	 DWORD PTR [ebx+4380], eax

; 3297 : 			pLts_t->rbphone=WBOUND;

  02229	89 83 20 11 00
	00		 mov	 DWORD PTR [ebx+4384], eax
  0222f	5d		 pop	 ebp

; 3298 : 			return(FINISHED_WORD);

  02230	b8 03 00 00 00	 mov	 eax, 3
  02235	5b		 pop	 ebx

; 3302 : }

  02236	59		 pop	 ecx
  02237	c3		 ret	 0
_ls_task_lookup_first_verbs ENDP
_TEXT	ENDS
PUBLIC	_ls_task_prelookup
_TEXT	SEGMENT
_word$ = 12
_count$ = 16
_table$ = 20
_len$ = 20
_ls_task_prelookup PROC NEAR

; 3328 : {

  02240	53		 push	 ebx
  02241	55		 push	 ebp

; 3329 : 	LETTER  *lp;
; 3330 : 	/* GL 03/20/1998, BATS#633  use "unsigned char" instead of "char" */
; 3331 : 	char  	*cp;
; 3332 : 	char  	*tp;
; 3333 : 	int   	c;
; 3334 : 	int   	len;
; 3335 : 
; 3336 : 
; 3337 : 	tp = &table[0];                 /* Start at the start.  */
; 3338 : 	while ((len = *tp++) != 0) 

  02242	8b 6c 24 18	 mov	 ebp, DWORD PTR _table$[esp+4]
  02246	56		 push	 esi
  02247	57		 push	 edi
  02248	0f be 45 00	 movsx	 eax, BYTE PTR [ebp]
  0224c	45		 inc	 ebp
  0224d	89 44 24 20	 mov	 DWORD PTR _len$[esp+12], eax
  02251	85 c0		 test	 eax, eax
  02253	74 46		 je	 SHORT $L72967
  02255	8b 7c 24 1c	 mov	 edi, DWORD PTR _count$[esp+12]
$L72966:

; 3339 : 	{            					/* 0 => end of table.   */
; 3340 : 		lp = &word[0];              

  02259	8b 74 24 18	 mov	 esi, DWORD PTR _word$[esp+12]

; 3341 : 		*count=0;

  0225d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 3342 : 		cp = tp;                    /* Start of text.       */

  02263	8b cd		 mov	 ecx, ebp
$L72969:

; 3343 : 		for (;;) 
; 3344 : 		{
; 3345 : 			c = ls_lower[lp->l_ch]; /* Fold case.           */
; 3346 : 		if (*cp == EOS || *cp < 0 )           /* Win.                 */

  02265	8a 01		 mov	 al, BYTE PTR [ecx]
  02267	84 c0		 test	 al, al
  02269	74 37		 je	 SHORT $L73175
  0226b	7c 35		 jl	 SHORT $L73175

; 3355 :             }
; 3356 : 			if (c != *cp++)         /* Lose.                */

  0226d	0f bf 16	 movsx	 edx, WORD PTR [esi]
  02270	33 db		 xor	 ebx, ebx
  02272	41		 inc	 ecx
  02273	8a 9a 00 00 00
	00		 mov	 bl, BYTE PTR _ls_lower[edx]
  02279	0f be c0	 movsx	 eax, al
  0227c	3b d8		 cmp	 ebx, eax
  0227e	75 0a		 jne	 SHORT $L73176

; 3357 : 			{
; 3358 : 				break;
; 3359 : 			}
; 3360 : 
; 3361 : 			++lp;   
; 3362 : 			*count +=1;

  02280	8b 07		 mov	 eax, DWORD PTR [edi]
  02282	83 c6 08	 add	 esi, 8
  02285	40		 inc	 eax
  02286	89 07		 mov	 DWORD PTR [edi], eax

; 3363 : 		}

  02288	eb db		 jmp	 SHORT $L72969
$L73176:

; 3364 : 		tp += len;                  /* Next.                */

  0228a	03 6c 24 20	 add	 ebp, DWORD PTR _len$[esp+12]
  0228e	0f be 45 00	 movsx	 eax, BYTE PTR [ebp]
  02292	45		 inc	 ebp
  02293	89 44 24 20	 mov	 DWORD PTR _len$[esp+12], eax
  02297	85 c0		 test	 eax, eax
  02299	75 be		 jne	 SHORT $L72966
$L72967:
  0229b	5f		 pop	 edi
  0229c	5e		 pop	 esi
  0229d	5d		 pop	 ebp

; 3365 : 	}
; 3366 : 	return (NULL);

  0229e	33 c0		 xor	 eax, eax
  022a0	5b		 pop	 ebx

; 3367 : }

  022a1	c3		 ret	 0
$L73175:

; 3347 :             {
; 3348 : 			if(*cp != EOS)

  022a2	8a 01		 mov	 al, BYTE PTR [ecx]
  022a4	84 c0		 test	 al, al
  022a6	74 0a		 je	 SHORT $L72973

; 3349 : 			{
; 3350 : 				//modify replacement count and move to EOS
; 3351 : 				*count += *cp++;

  022a8	8b 37		 mov	 esi, DWORD PTR [edi]
  022aa	0f be d0	 movsx	 edx, al
  022ad	03 f2		 add	 esi, edx
  022af	41		 inc	 ecx
  022b0	89 37		 mov	 DWORD PTR [edi], esi
$L72973:
  022b2	5f		 pop	 edi
  022b3	5e		 pop	 esi
  022b4	5d		 pop	 ebp

; 3352 : 			}
; 3353 : 			//bump pointer past the EOS char
; 3354 :                  return (++cp);    	/* Return phonemes.     */

  022b5	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  022b8	5b		 pop	 ebx

; 3367 : }

  022b9	c3		 ret	 0
_ls_task_prelookup ENDP
_TEXT	ENDS
END
