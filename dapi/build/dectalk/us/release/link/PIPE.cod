	TITLE	D:\work\product\dapi\src\nt\PIPE.C
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_create_pipe
EXTRN	__imp__free:NEAR
EXTRN	__imp__malloc:NEAR
EXTRN	__imp__InitializeCriticalSection@4:NEAR
EXTRN	__imp__DeleteCriticalSection@4:NEAR
EXTRN	__imp__CreateEventA@16:NEAR
EXTRN	__imp__CloseHandle@4:NEAR
_TEXT	SEGMENT
_uiType$ = 8
_uiPipeLength$ = 12
_create_pipe PROC NEAR

; 169  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 170  :   LPPIPE_T pPipe;
; 171  :   void * pBuffer;
; 172  : 
; 173  :   /********************************************************************/
; 174  :   /*  Allocate the pipe structure and the pipe memory.                */
; 175  :   /********************************************************************/
; 176  : 
; 177  :   pPipe = (LPPIPE_T) malloc( sizeof( PIPE_T ));

  00002	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__malloc
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	6a 3c		 push	 60			; 0000003cH
  0000c	ff d5		 call	 ebp
  0000e	8b f0		 mov	 esi, eax
  00010	83 c4 04	 add	 esp, 4

; 178  : 
; 179  :   if ( pPipe == NULL )

  00013	85 f6		 test	 esi, esi

; 180  :     return( NULL );

  00015	0f 84 fe 00 00
	00		 je	 $L69205

; 181  : 
; 182  :   /********************************************************************/
; 183  :   /*  Allocate the pipe queue.                                        */
; 184  :   /********************************************************************/
; 185  : 
; 186  :   switch ( uiType )
; 187  :   {

  0001b	8b 44 24 14	 mov	 eax, DWORD PTR _uiType$[esp+12]
  0001f	83 f8 06	 cmp	 eax, 6
  00022	0f 87 f1 00 00
	00		 ja	 $L69205
  00028	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L69620[eax*4]
$L69184:

; 188  :   case BYTE_PIPE:
; 189  : 
; 190  :     pBuffer =
; 191  :       ( BYTE_T * )malloc( uiPipeLength * sizeof(BYTE_T));

  0002f	8b 5c 24 18	 mov	 ebx, DWORD PTR _uiPipeLength$[esp+12]
  00033	53		 push	 ebx

; 192  : 
; 193  :     break;

  00034	eb 40		 jmp	 SHORT $L69617
$L69187:

; 194  : 
; 195  :   case WORD_PIPE:
; 196  : 
; 197  :     pBuffer =
; 198  :       ( WORD_T * )malloc( uiPipeLength * sizeof(WORD_T));

  00036	8b 5c 24 18	 mov	 ebx, DWORD PTR _uiPipeLength$[esp+12]
  0003a	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  0003d	50		 push	 eax

; 199  : 
; 200  :     break;

  0003e	eb 36		 jmp	 SHORT $L69617
$L69190:

; 201  : 
; 202  :   case DWORD_PIPE:
; 203  : 
; 204  :     pBuffer =
; 205  :       ( DWORD_T * )malloc( uiPipeLength * sizeof(DWORD_T));

  00040	8b 5c 24 18	 mov	 ebx, DWORD PTR _uiPipeLength$[esp+12]
  00044	8d 0c 9d 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4]
  0004b	51		 push	 ecx

; 206  : 
; 207  :     break;

  0004c	eb 28		 jmp	 SHORT $L69617
$L69196:

; 208  : 
; 209  :   case QWORD_PIPE:
; 210  : 
; 211  :     pBuffer =
; 212  :       ( QWORD_T * )malloc( uiPipeLength * sizeof(QWORD_T));
; 213  : 
; 214  :     break;
; 215  : 
; 216  :   case FLOAT_PIPE:
; 217  : 
; 218  :     pBuffer = ( float * )malloc( uiPipeLength * sizeof(float));

  0004e	8b 5c 24 18	 mov	 ebx, DWORD PTR _uiPipeLength$[esp+12]
  00052	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  00059	50		 push	 eax

; 219  : 
; 220  :     break;

  0005a	eb 1a		 jmp	 SHORT $L69617
$L69199:

; 221  : 
; 222  :   case DOUBLE_PIPE:
; 223  : 
; 224  :     pBuffer = ( double * )malloc( uiPipeLength * sizeof(double));

  0005c	8b 5c 24 18	 mov	 ebx, DWORD PTR _uiPipeLength$[esp+12]
  00060	8d 0c dd 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*8]
  00067	51		 push	 ecx

; 225  : 
; 226  :     break;

  00068	eb 0c		 jmp	 SHORT $L69617
$L69193:

; 227  : 
; 228  :   case VOID_PTR_PIPE:
; 229  : 
; 230  :     pBuffer = ( void * )malloc( uiPipeLength * sizeof(void *));

  0006a	8b 5c 24 18	 mov	 ebx, DWORD PTR _uiPipeLength$[esp+12]
  0006e	8d 14 9d 00 00
	00 00		 lea	 edx, DWORD PTR [ebx*4]
  00075	52		 push	 edx
$L69617:
  00076	ff d5		 call	 ebp
  00078	8b f8		 mov	 edi, eax
  0007a	83 c4 04	 add	 esp, 4

; 231  : 
; 232  :     break;
; 233  : 
; 234  :   default:
; 235  : 
; 236  :     return( NULL );
; 237  : 
; 238  :     break;
; 239  :   }
; 240  : 
; 241  :   if ( pBuffer == NULL )

  0007d	85 ff		 test	 edi, edi
  0007f	75 11		 jne	 SHORT $L69208

; 242  :   {
; 243  :     free( pPipe );

  00081	56		 push	 esi
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free

; 312  : #endif
; 313  : #if defined (__osf__) || defined (__linux__)
; 314  : 	OP_DestroyMutex( pPipe->pcsPipe );
; 315  : #endif
; 316  :     free( pPipe );

  00088	83 c4 04	 add	 esp, 4
  0008b	33 c0		 xor	 eax, eax
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5d		 pop	 ebp
  00090	5b		 pop	 ebx

; 349  : }

  00091	c3		 ret	 0
$L69208:

; 244  :     return( NULL );
; 245  :   }
; 246  : 
; 247  :   /********************************************************************/
; 248  :   /*  Allocate the pipe critical section object.                      */
; 249  :   /********************************************************************/
; 250  : 
; 251  : /* TQL 05/21/1997  change this for OSF build */
; 252  : /* GL 06/04/1997  for BATS#381 should use WIN32 instead of MSDEV */
; 253  : #ifdef WIN32
; 254  :   pPipe->pcsPipe =
; 255  :     ( LPCRITICAL_SECTION )malloc( sizeof( CRITICAL_SECTION ));

  00092	6a 18		 push	 24			; 00000018H
  00094	ff d5		 call	 ebp

; 256  : #endif
; 257  : #if defined (__osf__) || defined (__linux__)
; 258  :   pPipe->pcsPipe = OP_CreateMutex();
; 259  : #endif
; 260  : 
; 261  :   if ( pPipe->pcsPipe == NULL )

  00096	33 ed		 xor	 ebp, ebp
  00098	83 c4 04	 add	 esp, 4
  0009b	3b c5		 cmp	 eax, ebp
  0009d	89 46 34	 mov	 DWORD PTR [esi+52], eax
  000a0	75 16		 jne	 SHORT $L69213

; 262  :   {
; 263  :     free( pBuffer );

  000a2	57		 push	 edi
  000a3	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
  000a9	ff d7		 call	 edi

; 264  :     free( pPipe );

  000ab	56		 push	 esi
  000ac	ff d7		 call	 edi
  000ae	83 c4 08	 add	 esp, 8
  000b1	33 c0		 xor	 eax, eax
  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi
  000b5	5d		 pop	 ebp
  000b6	5b		 pop	 ebx

; 349  : }

  000b7	c3		 ret	 0
$L69213:

; 265  :     return( NULL );
; 266  :   }
; 267  : 
; 268  :   /********************************************************************/
; 269  :   /*  Initialize the pipe critical section object.                    */
; 270  :   /********************************************************************/
; 271  : 
; 272  : /* TQL 05/21/1997  change this for OSF build */
; 273  : /* GL 06/04/1997  for BATS#381 should be used in WIN32 instead of osf */
; 274  : #ifdef WIN32
; 275  :   InitializeCriticalSection( pPipe->pcsPipe );

  000b8	50		 push	 eax
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 276  : #endif
; 277  : 
; 278  :   /********************************************************************/
; 279  :   /*  Initialize the pipe structure.                                  */
; 280  :   /********************************************************************/
; 281  : 
; 282  :   pPipe->usGuard1 = GUARD1;
; 283  :   pPipe->usGuard2 = GUARD2;
; 284  :   pPipe->pStart = pBuffer;
; 285  :   pPipe->pInput = pBuffer;
; 286  :   pPipe->pOutput = pBuffer;
; 287  :   pPipe->uiInputPosition = 0;
; 288  :   pPipe->uiOutputPosition = 0;
; 289  :   pPipe->uiLength = uiPipeLength;
; 290  :   pPipe->uiCount = 0;
; 291  :   pPipe->uiType = uiType;

  000bf	8b 44 24 14	 mov	 eax, DWORD PTR _uiType$[esp+12]

; 292  :   pPipe->uiState = PIPE_NORMAL;
; 293  : 
; 294  :   /********************************************************************/
; 295  :   /*  Initialize the pipe Not Empty Event.                            */
; 296  :   /********************************************************************/
; 297  : 
; 298  : /* TQL 05/21/1997  change this for OSF build */
; 299  : #ifdef WIN32
; 300  :   pPipe->hNotEmptyEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

  000c3	55		 push	 ebp
  000c4	55		 push	 ebp
  000c5	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  000c8	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CreateEventA@16
  000ce	6a 01		 push	 1
  000d0	55		 push	 ebp
  000d1	66 c7 06 ad 8b	 mov	 WORD PTR [esi], 35757	; 00008badH
  000d6	66 c7 46 38 0d
	f0		 mov	 WORD PTR [esi+56], 61453 ; 0000f00dH
  000dc	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  000df	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  000e2	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  000e5	89 6e 10	 mov	 DWORD PTR [esi+16], ebp
  000e8	89 6e 14	 mov	 DWORD PTR [esi+20], ebp
  000eb	89 6e 1c	 mov	 DWORD PTR [esi+28], ebp
  000ee	89 46 20	 mov	 DWORD PTR [esi+32], eax
  000f1	89 6e 24	 mov	 DWORD PTR [esi+36], ebp
  000f4	ff d3		 call	 ebx

; 301  : #endif
; 302  : #if defined (__osf__) || defined (__linux__)
; 303  :   pPipe->hNotEmptyEvent = OP_CreateEvent( TRUE, FALSE );
; 304  : #endif
; 305  : 
; 306  :   if ( pPipe->hNotEmptyEvent == NULL )

  000f6	3b c5		 cmp	 eax, ebp
  000f8	89 46 28	 mov	 DWORD PTR [esi+40], eax
  000fb	75 23		 jne	 SHORT $L69218

; 307  :   {
; 308  :     free( pBuffer );

  000fd	57		 push	 edi
  000fe	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
  00104	ff d7		 call	 edi

; 309  : /* TQL 05/21/1997  change this for OSF build */
; 310  : #ifdef WIN32
; 311  :     DeleteCriticalSection( pPipe->pcsPipe );

  00106	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00109	83 c4 04	 add	 esp, 4
  0010c	51		 push	 ecx
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 312  : #endif
; 313  : #if defined (__osf__) || defined (__linux__)
; 314  : 	OP_DestroyMutex( pPipe->pcsPipe );
; 315  : #endif
; 316  :     free( pPipe );

  00113	56		 push	 esi
  00114	ff d7		 call	 edi
  00116	83 c4 04	 add	 esp, 4
$L69205:
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5d		 pop	 ebp
  0011c	33 c0		 xor	 eax, eax
  0011e	5b		 pop	 ebx

; 349  : }

  0011f	c3		 ret	 0
$L69218:

; 317  :     return( NULL );
; 318  :   }
; 319  : 
; 320  :   /********************************************************************/
; 321  :   /*  Initialize the pipe Not Full Event.                             */
; 322  :   /********************************************************************/
; 323  : 
; 324  : /* TQL 05/21/1997  change this for OSF build */
; 325  : #ifdef WIN32
; 326  :   pPipe->hNotFullEvent = CreateEvent( NULL, TRUE, TRUE, NULL );

  00120	55		 push	 ebp
  00121	6a 01		 push	 1
  00123	6a 01		 push	 1
  00125	55		 push	 ebp
  00126	ff d3		 call	 ebx

; 327  : #endif
; 328  : #if defined (__osf__) || defined (__linux__)
; 329  :   pPipe->hNotFullEvent = OP_CreateEvent( TRUE, TRUE );
; 330  : #endif
; 331  : 
; 332  :   if ( pPipe->hNotFullEvent == NULL )

  00128	3b c5		 cmp	 eax, ebp
  0012a	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0012d	75 2d		 jne	 SHORT $L69223

; 333  :   {
; 334  :     free( pBuffer );

  0012f	57		 push	 edi
  00130	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
  00136	ff d7		 call	 edi

; 335  : /* TQL 05/21/1997  change this for OSF build */
; 336  : #ifdef WIN32
; 337  :     DeleteCriticalSection( pPipe->pcsPipe );

  00138	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  0013b	83 c4 04	 add	 esp, 4
  0013e	52		 push	 edx
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 338  :     CloseHandle( pPipe->hNotEmptyEvent );

  00145	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00148	50		 push	 eax
  00149	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  0014f	56		 push	 esi
  00150	ff d7		 call	 edi
  00152	83 c4 04	 add	 esp, 4
  00155	33 c0		 xor	 eax, eax
  00157	5f		 pop	 edi
  00158	5e		 pop	 esi
  00159	5d		 pop	 ebp
  0015a	5b		 pop	 ebx

; 349  : }

  0015b	c3		 ret	 0
$L69223:

; 339  : #endif
; 340  : #if defined (__osf__) || defined (__linux__)
; 341  :     OP_DestroyMutex( pPipe->pcsPipe );
; 342  :     OP_DestroyEvent( pPipe->hNotEmptyEvent );
; 343  : #endif
; 344  :     free( pPipe );
; 345  :     return( NULL );
; 346  :   }
; 347  : 
; 348  :   return( pPipe );

  0015c	8b c6		 mov	 eax, esi
  0015e	5f		 pop	 edi
  0015f	5e		 pop	 esi
  00160	5d		 pop	 ebp
  00161	5b		 pop	 ebx

; 349  : }

  00162	c3		 ret	 0
  00163	90		 npad	 1
$L69620:
  00164	00 00 00 00	 DD	 $L69184
  00168	00 00 00 00	 DD	 $L69187
  0016c	00 00 00 00	 DD	 $L69190
  00170	00 00 00 00	 DD	 $L69193
  00174	00 00 00 00	 DD	 $L69196
  00178	00 00 00 00	 DD	 $L69199
  0017c	00 00 00 00	 DD	 $L69193
_create_pipe ENDP
_TEXT	ENDS
PUBLIC	_write_pipe
EXTRN	__fltused:NEAR
EXTRN	__imp__EnterCriticalSection@4:NEAR
EXTRN	__imp__LeaveCriticalSection@4:NEAR
EXTRN	__imp__SetEvent@4:NEAR
EXTRN	__imp__ResetEvent@4:NEAR
EXTRN	__imp__WaitForSingleObject@8:NEAR
_TEXT	SEGMENT
_pPipe$ = 8
_pItems$ = 12
_uiNumberToWrite$ = 16
_write_pipe PROC NEAR

; 383  : {

  00180	53		 push	 ebx

; 384  :   UINT i;
; 385  :   UINT uiRemaining;
; 386  :   /* check the pipe guards.. */
; 387  : #ifndef __linux__
; 388  :   assert ( ( pPipe->usGuard1 == GUARD1) 
; 389  : 	  &&( pPipe->usGuard2 == GUARD2) );
; 390  : #endif
; 391  : 
; 392  : 
; 393  :   /********************************************************************/
; 394  :   /*  Block if the pipe resource is busy.                             */
; 395  :   /********************************************************************/
; 396  : 
; 397  : /* TQL 05/21/1997  change this for OSF build */
; 398  : #ifdef WIN32
; 399  :   EnterCriticalSection( pPipe->pcsPipe );

  00181	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__EnterCriticalSection@4
  00187	55		 push	 ebp
  00188	56		 push	 esi
  00189	8b 74 24 10	 mov	 esi, DWORD PTR _pPipe$[esp+8]
  0018d	57		 push	 edi
  0018e	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00191	50		 push	 eax
  00192	ff d3		 call	 ebx

; 400  : #endif
; 401  : #if defined (__osf__) || defined (__linux__)
; 402  :   OP_LockMutex( pPipe->pcsPipe );
; 403  : #endif
; 404  : 
; 405  : 
; 406  :   /********************************************************************/
; 407  :   /*  If there's not enough room for the items then block.            */
; 408  :   /*  write_pipe must own pPipe->uiCount during the compare in case   */
; 409  :   /*  multiple threads are trying to write the pipe at the same time. */
; 410  :   /********************************************************************/
; 411  : 
; 412  :   while ( pPipe->uiCount + uiNumberToWrite >= pPipe->uiLength )

  00194	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00197	8b 4c 24 1c	 mov	 ecx, DWORD PTR _uiNumberToWrite$[esp+12]
  0019b	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0019e	03 d1		 add	 edx, ecx
  001a0	3b d0		 cmp	 edx, eax
  001a2	72 3c		 jb	 SHORT $L69237

; 413  :   {
; 414  : /* TQL 05/21/1997  change this for OSF build */
; 415  : #ifdef WIN32
; 416  :     ResetEvent( pPipe->hNotFullEvent );
; 417  : 
; 418  :     LeaveCriticalSection( pPipe->pcsPipe );
; 419  : 
; 420  :     WaitForSingleObject( pPipe->hNotFullEvent, INFINITE );

  001a4	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__ResetEvent@4
  001aa	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WaitForSingleObject@8
$L69236:
  001b0	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  001b3	50		 push	 eax
  001b4	ff d5		 call	 ebp
  001b6	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  001b9	51		 push	 ecx
  001ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  001c0	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  001c3	6a ff		 push	 -1
  001c5	52		 push	 edx
  001c6	ff d7		 call	 edi

; 421  : 
; 422  :     EnterCriticalSection( pPipe->pcsPipe );

  001c8	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  001cb	50		 push	 eax
  001cc	ff d3		 call	 ebx
  001ce	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  001d1	8b 54 24 1c	 mov	 edx, DWORD PTR _uiNumberToWrite$[esp+12]
  001d5	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  001d8	03 ca		 add	 ecx, edx
  001da	3b c8		 cmp	 ecx, eax
  001dc	73 d2		 jae	 SHORT $L69236

; 400  : #endif
; 401  : #if defined (__osf__) || defined (__linux__)
; 402  :   OP_LockMutex( pPipe->pcsPipe );
; 403  : #endif
; 404  : 
; 405  : 
; 406  :   /********************************************************************/
; 407  :   /*  If there's not enough room for the items then block.            */
; 408  :   /*  write_pipe must own pPipe->uiCount during the compare in case   */
; 409  :   /*  multiple threads are trying to write the pipe at the same time. */
; 410  :   /********************************************************************/
; 411  : 
; 412  :   while ( pPipe->uiCount + uiNumberToWrite >= pPipe->uiLength )

  001de	8b ca		 mov	 ecx, edx
$L69237:

; 423  : #endif
; 424  : 
; 425  : #if defined (__osf__) || defined (__linux__)
; 426  : 	OP_ResetEvent( pPipe->hNotFullEvent );
; 427  : 
; 428  :     OP_UnlockMutex( pPipe->pcsPipe );
; 429  : 
; 430  :     OP_WaitForEvent( pPipe->hNotFullEvent, OP_INFINITE );
; 431  : 
; 432  :     OP_LockMutex( pPipe->pcsPipe );
; 433  : #endif
; 434  : 
; 435  :   }
; 436  : 
; 437  :   /********************************************************************/
; 438  :   /*  There is enough space in the pipe.                              */
; 439  :   /*  Test to see if the data will wrap around the circular queue.    */
; 440  :   /********************************************************************/
; 441  : 
; 442  :   if ( pPipe->uiInputPosition + uiNumberToWrite > pPipe->uiLength )

  001e0	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  001e3	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  001e6	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]
  001e9	3b f8		 cmp	 edi, eax
  001eb	0f 86 f5 02 00
	00		 jbe	 $L69238

; 443  :   {
; 444  :     /******************************************************************/
; 445  :     /*  The data will wrap around the circular queue.                 */
; 446  :     /******************************************************************/
; 447  : 
; 448  :     uiRemaining = pPipe->uiLength - pPipe->uiInputPosition;

  001f1	2b c2		 sub	 eax, edx
  001f3	8b d0		 mov	 edx, eax

; 449  : 
; 450  :     switch ( pPipe->uiType )
; 451  :     {

  001f5	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  001f8	83 f8 06	 cmp	 eax, 6
  001fb	0f 87 95 02 00
	00		 ja	 $L69320
  00201	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L69682[eax*4]
$L69243:

; 452  :     case BYTE_PIPE:
; 453  : 
; 454  :       for ( i = 0; i < uiRemaining; i++ )

  00208	85 d2		 test	 edx, edx
  0020a	76 1b		 jbe	 SHORT $L69672
  0020c	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  00210	8b fa		 mov	 edi, edx
$L69244:

; 455  :        *((BYTE_T *)pPipe->pInput)++ = *((BYTE_T *)pItems)++;

  00212	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  00215	8a 18		 mov	 bl, BYTE PTR [eax]
  00217	88 5d 00	 mov	 BYTE PTR [ebp], bl
  0021a	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0021d	43		 inc	 ebx
  0021e	40		 inc	 eax
  0021f	4f		 dec	 edi
  00220	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00223	75 ed		 jne	 SHORT $L69244

; 452  :     case BYTE_PIPE:
; 453  : 
; 454  :       for ( i = 0; i < uiRemaining; i++ )

  00225	eb 04		 jmp	 SHORT $L69246
$L69672:
  00227	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
$L69246:

; 456  : 
; 457  :       pPipe->pInput = pPipe->pStart;

  0022b	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]

; 458  : 
; 459  :       for ( i = uiRemaining; i < uiNumberToWrite; i++ )

  0022e	3b d1		 cmp	 edx, ecx
  00230	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00233	73 75		 jae	 SHORT $L69328
  00235	8b e9		 mov	 ebp, ecx
  00237	2b ea		 sub	 ebp, edx
$L69249:

; 460  :        *((BYTE_T *)pPipe->pInput)++ = *((BYTE_T *)pItems)++;

  00239	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0023c	8a 18		 mov	 bl, BYTE PTR [eax]
  0023e	88 1f		 mov	 BYTE PTR [edi], bl
  00240	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00243	47		 inc	 edi
  00244	40		 inc	 eax
  00245	4d		 dec	 ebp
  00246	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00249	75 ee		 jne	 SHORT $L69249

; 545  : 
; 546  :       break;
; 547  :     }
; 548  : 
; 549  :     /******************************************************************/
; 550  :     /*  Update the input position in a circular fashion.              */
; 551  :     /******************************************************************/
; 552  : 
; 553  :     pPipe->uiInputPosition = uiNumberToWrite - uiRemaining;

  0024b	8b c1		 mov	 eax, ecx
  0024d	2b c2		 sub	 eax, edx

; 554  :   }
; 555  :   else

  0024f	e9 fa 03 00 00	 jmp	 $L69681
$L69254:

; 461  : 
; 462  :       break;
; 463  : 
; 464  :     case WORD_PIPE:
; 465  : 
; 466  :       for ( i = 0; i < uiRemaining; i++ )

  00254	85 d2		 test	 edx, edx
  00256	bb 02 00 00 00	 mov	 ebx, 2
  0025b	76 23		 jbe	 SHORT $L69673
  0025d	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  00261	8b fa		 mov	 edi, edx
$L69255:

; 467  :        *((WORD_T *)pPipe->pInput)++ = *((WORD_T *)pItems)++;

  00263	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00266	66 8b 28	 mov	 bp, WORD PTR [eax]
  00269	66 89 2b	 mov	 WORD PTR [ebx], bp
  0026c	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  0026f	bb 02 00 00 00	 mov	 ebx, 2
  00274	03 eb		 add	 ebp, ebx
  00276	03 c3		 add	 eax, ebx
  00278	4f		 dec	 edi
  00279	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  0027c	75 e5		 jne	 SHORT $L69255

; 461  : 
; 462  :       break;
; 463  : 
; 464  :     case WORD_PIPE:
; 465  : 
; 466  :       for ( i = 0; i < uiRemaining; i++ )

  0027e	eb 04		 jmp	 SHORT $L69257
$L69673:
  00280	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
$L69257:

; 468  : 
; 469  :       pPipe->pInput = pPipe->pStart;

  00284	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]

; 470  : 
; 471  :       for ( i = uiRemaining; i < uiNumberToWrite; i++ )

  00287	3b d1		 cmp	 edx, ecx
  00289	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0028c	73 1c		 jae	 SHORT $L69328

; 468  : 
; 469  :       pPipe->pInput = pPipe->pStart;

  0028e	2b ca		 sub	 ecx, edx
$L69260:

; 472  :        *((WORD_T *)pPipe->pInput)++ = *((WORD_T *)pItems)++;

  00290	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00293	66 8b 28	 mov	 bp, WORD PTR [eax]
  00296	03 c3		 add	 eax, ebx
  00298	66 89 2f	 mov	 WORD PTR [edi], bp
  0029b	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0029e	03 fb		 add	 edi, ebx
  002a0	49		 dec	 ecx
  002a1	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  002a4	75 ea		 jne	 SHORT $L69260
$L69680:

; 533  : 
; 534  :       break;

  002a6	8b 4c 24 1c	 mov	 ecx, DWORD PTR _uiNumberToWrite$[esp+12]
$L69328:

; 545  : 
; 546  :       break;
; 547  :     }
; 548  : 
; 549  :     /******************************************************************/
; 550  :     /*  Update the input position in a circular fashion.              */
; 551  :     /******************************************************************/
; 552  : 
; 553  :     pPipe->uiInputPosition = uiNumberToWrite - uiRemaining;

  002aa	8b c1		 mov	 eax, ecx
  002ac	2b c2		 sub	 eax, edx

; 554  :   }
; 555  :   else

  002ae	e9 9b 03 00 00	 jmp	 $L69681
$L69265:

; 473  : 
; 474  :       break;
; 475  : 
; 476  :     case DWORD_PIPE:
; 477  : 
; 478  :       for ( i = 0; i < uiRemaining; i++ )

  002b3	85 d2		 test	 edx, edx
  002b5	b9 04 00 00 00	 mov	 ecx, 4
  002ba	76 1c		 jbe	 SHORT $L69674
  002bc	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  002c0	8b fa		 mov	 edi, edx
$L69266:

; 479  :        *((DWORD_T *)pPipe->pInput)++ = *((DWORD_T *)pItems)++;

  002c2	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  002c5	8b 28		 mov	 ebp, DWORD PTR [eax]
  002c7	03 c1		 add	 eax, ecx
  002c9	89 2b		 mov	 DWORD PTR [ebx], ebp
  002cb	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  002ce	03 d9		 add	 ebx, ecx
  002d0	4f		 dec	 edi
  002d1	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  002d4	75 ec		 jne	 SHORT $L69266

; 473  : 
; 474  :       break;
; 475  : 
; 476  :     case DWORD_PIPE:
; 477  : 
; 478  :       for ( i = 0; i < uiRemaining; i++ )

  002d6	eb 04		 jmp	 SHORT $L69268
$L69674:
  002d8	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
$L69268:

; 480  : 
; 481  :       pPipe->pInput = pPipe->pStart;

  002dc	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  002df	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 482  : 
; 483  :       for ( i = uiRemaining; i < uiNumberToWrite; i++ )

  002e2	8b 7c 24 1c	 mov	 edi, DWORD PTR _uiNumberToWrite$[esp+12]
  002e6	3b d7		 cmp	 edx, edi
  002e8	73 bc		 jae	 SHORT $L69680

; 480  : 
; 481  :       pPipe->pInput = pPipe->pStart;

  002ea	2b fa		 sub	 edi, edx
$L69271:

; 484  :        *((DWORD_T *)pPipe->pInput)++ = *((DWORD_T *)pItems)++;

  002ec	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  002ef	8b 28		 mov	 ebp, DWORD PTR [eax]
  002f1	03 c1		 add	 eax, ecx
  002f3	89 2b		 mov	 DWORD PTR [ebx], ebp
  002f5	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  002f8	03 d9		 add	 ebx, ecx
  002fa	4f		 dec	 edi
  002fb	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  002fe	75 ec		 jne	 SHORT $L69271

; 533  : 
; 534  :       break;

  00300	8b 4c 24 1c	 mov	 ecx, DWORD PTR _uiNumberToWrite$[esp+12]

; 545  : 
; 546  :       break;
; 547  :     }
; 548  : 
; 549  :     /******************************************************************/
; 550  :     /*  Update the input position in a circular fashion.              */
; 551  :     /******************************************************************/
; 552  : 
; 553  :     pPipe->uiInputPosition = uiNumberToWrite - uiRemaining;

  00304	8b c1		 mov	 eax, ecx
  00306	2b c2		 sub	 eax, edx

; 554  :   }
; 555  :   else

  00308	e9 41 03 00 00	 jmp	 $L69681
$L69276:

; 485  : 
; 486  :       break;
; 487  : 
; 488  :     case QWORD_PIPE:
; 489  : 
; 490  :       for ( i = 0; i < uiRemaining; i++ )

  0030d	85 d2		 test	 edx, edx
  0030f	b9 04 00 00 00	 mov	 ecx, 4
  00314	76 1c		 jbe	 SHORT $L69675
  00316	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  0031a	8b fa		 mov	 edi, edx
$L69277:

; 491  :        *((QWORD_T *)pPipe->pInput)++ = *((QWORD_T *)pItems)++;

  0031c	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0031f	8b 28		 mov	 ebp, DWORD PTR [eax]
  00321	03 c1		 add	 eax, ecx
  00323	89 2b		 mov	 DWORD PTR [ebx], ebp
  00325	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00328	03 d9		 add	 ebx, ecx
  0032a	4f		 dec	 edi
  0032b	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  0032e	75 ec		 jne	 SHORT $L69277

; 485  : 
; 486  :       break;
; 487  : 
; 488  :     case QWORD_PIPE:
; 489  : 
; 490  :       for ( i = 0; i < uiRemaining; i++ )

  00330	eb 04		 jmp	 SHORT $L69279
$L69675:
  00332	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
$L69279:

; 492  : 
; 493  :       pPipe->pInput = pPipe->pStart;

  00336	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00339	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 494  : 
; 495  :       for ( i = uiRemaining; i < uiNumberToWrite; i++ )

  0033c	8b 7c 24 1c	 mov	 edi, DWORD PTR _uiNumberToWrite$[esp+12]
  00340	3b d7		 cmp	 edx, edi
  00342	0f 83 5e ff ff
	ff		 jae	 $L69680
  00348	8b ef		 mov	 ebp, edi
  0034a	2b ea		 sub	 ebp, edx
$L69282:

; 496  :        *((QWORD_T *)pPipe->pInput)++ = *((QWORD_T *)pItems)++;

  0034c	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0034f	8b 18		 mov	 ebx, DWORD PTR [eax]
  00351	03 c1		 add	 eax, ecx
  00353	89 1f		 mov	 DWORD PTR [edi], ebx
  00355	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00358	03 f9		 add	 edi, ecx
  0035a	4d		 dec	 ebp
  0035b	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0035e	75 ec		 jne	 SHORT $L69282

; 533  : 
; 534  :       break;

  00360	8b 4c 24 1c	 mov	 ecx, DWORD PTR _uiNumberToWrite$[esp+12]

; 545  : 
; 546  :       break;
; 547  :     }
; 548  : 
; 549  :     /******************************************************************/
; 550  :     /*  Update the input position in a circular fashion.              */
; 551  :     /******************************************************************/
; 552  : 
; 553  :     pPipe->uiInputPosition = uiNumberToWrite - uiRemaining;

  00364	8b c1		 mov	 eax, ecx
  00366	2b c2		 sub	 eax, edx

; 554  :   }
; 555  :   else

  00368	e9 e1 02 00 00	 jmp	 $L69681
$L69287:

; 497  : 
; 498  :       break;
; 499  : 
; 500  :     case FLOAT_PIPE:
; 501  : 
; 502  :       for ( i = 0; i < uiRemaining; i++ )

  0036d	85 d2		 test	 edx, edx
  0036f	b9 04 00 00 00	 mov	 ecx, 4
  00374	76 1c		 jbe	 SHORT $L69676
  00376	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  0037a	8b fa		 mov	 edi, edx
$L69288:

; 503  :        *((float *)pPipe->pInput)++ = *((float *)pItems)++;

  0037c	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0037f	8b 28		 mov	 ebp, DWORD PTR [eax]
  00381	03 c1		 add	 eax, ecx
  00383	89 2b		 mov	 DWORD PTR [ebx], ebp
  00385	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00388	03 d9		 add	 ebx, ecx
  0038a	4f		 dec	 edi
  0038b	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  0038e	75 ec		 jne	 SHORT $L69288

; 497  : 
; 498  :       break;
; 499  : 
; 500  :     case FLOAT_PIPE:
; 501  : 
; 502  :       for ( i = 0; i < uiRemaining; i++ )

  00390	eb 04		 jmp	 SHORT $L69290
$L69676:
  00392	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
$L69290:

; 504  : 
; 505  :       pPipe->pInput = pPipe->pStart;

  00396	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00399	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 506  : 
; 507  :       for ( i = uiRemaining; i < uiNumberToWrite; i++ )

  0039c	8b 7c 24 1c	 mov	 edi, DWORD PTR _uiNumberToWrite$[esp+12]
  003a0	3b d7		 cmp	 edx, edi
  003a2	0f 83 fe fe ff
	ff		 jae	 $L69680
  003a8	8b df		 mov	 ebx, edi
  003aa	2b da		 sub	 ebx, edx
$L69293:

; 508  :        *((float *)pPipe->pInput)++ = *((float *)pItems)++;

  003ac	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  003af	8b 28		 mov	 ebp, DWORD PTR [eax]
  003b1	03 c1		 add	 eax, ecx
  003b3	89 2f		 mov	 DWORD PTR [edi], ebp
  003b5	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  003b8	03 f9		 add	 edi, ecx
  003ba	4b		 dec	 ebx
  003bb	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  003be	75 ec		 jne	 SHORT $L69293

; 533  : 
; 534  :       break;

  003c0	8b 4c 24 1c	 mov	 ecx, DWORD PTR _uiNumberToWrite$[esp+12]

; 545  : 
; 546  :       break;
; 547  :     }
; 548  : 
; 549  :     /******************************************************************/
; 550  :     /*  Update the input position in a circular fashion.              */
; 551  :     /******************************************************************/
; 552  : 
; 553  :     pPipe->uiInputPosition = uiNumberToWrite - uiRemaining;

  003c4	8b c1		 mov	 eax, ecx
  003c6	2b c2		 sub	 eax, edx

; 554  :   }
; 555  :   else

  003c8	e9 81 02 00 00	 jmp	 $L69681
$L69298:

; 509  : 
; 510  :       break;
; 511  : 
; 512  :     case DOUBLE_PIPE:
; 513  : 
; 514  :       for ( i = 0; i < uiRemaining; i++ )

  003cd	85 d2		 test	 edx, edx
  003cf	bb 08 00 00 00	 mov	 ebx, 8
  003d4	76 27		 jbe	 SHORT $L69677
  003d6	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  003da	8b fa		 mov	 edi, edx
$L69299:

; 515  :        *((double *)pPipe->pInput)++ = *((double *)pItems)++;

  003dc	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  003df	8b 28		 mov	 ebp, DWORD PTR [eax]
  003e1	89 2b		 mov	 DWORD PTR [ebx], ebp
  003e3	8b 68 04	 mov	 ebp, DWORD PTR [eax+4]
  003e6	89 6b 04	 mov	 DWORD PTR [ebx+4], ebp
  003e9	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  003ec	bb 08 00 00 00	 mov	 ebx, 8
  003f1	03 eb		 add	 ebp, ebx
  003f3	03 c3		 add	 eax, ebx
  003f5	4f		 dec	 edi
  003f6	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  003f9	75 e1		 jne	 SHORT $L69299

; 509  : 
; 510  :       break;
; 511  : 
; 512  :     case DOUBLE_PIPE:
; 513  : 
; 514  :       for ( i = 0; i < uiRemaining; i++ )

  003fb	eb 04		 jmp	 SHORT $L69301
$L69677:
  003fd	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
$L69301:

; 516  : 
; 517  :       pPipe->pInput = pPipe->pStart;

  00401	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]

; 518  : 
; 519  :       for ( i = uiRemaining; i < uiNumberToWrite; i++ )

  00404	3b d1		 cmp	 edx, ecx
  00406	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00409	0f 83 9b fe ff
	ff		 jae	 $L69328

; 516  : 
; 517  :       pPipe->pInput = pPipe->pStart;

  0040f	2b ca		 sub	 ecx, edx
$L69304:

; 520  :        *((double *)pPipe->pInput)++ = *((double *)pItems)++;

  00411	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00414	8b 28		 mov	 ebp, DWORD PTR [eax]
  00416	89 2f		 mov	 DWORD PTR [edi], ebp
  00418	8b 68 04	 mov	 ebp, DWORD PTR [eax+4]
  0041b	03 c3		 add	 eax, ebx
  0041d	89 6f 04	 mov	 DWORD PTR [edi+4], ebp
  00420	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00423	03 fb		 add	 edi, ebx
  00425	49		 dec	 ecx
  00426	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00429	75 e6		 jne	 SHORT $L69304

; 533  : 
; 534  :       break;

  0042b	8b 4c 24 1c	 mov	 ecx, DWORD PTR _uiNumberToWrite$[esp+12]

; 545  : 
; 546  :       break;
; 547  :     }
; 548  : 
; 549  :     /******************************************************************/
; 550  :     /*  Update the input position in a circular fashion.              */
; 551  :     /******************************************************************/
; 552  : 
; 553  :     pPipe->uiInputPosition = uiNumberToWrite - uiRemaining;

  0042f	8b c1		 mov	 eax, ecx
  00431	2b c2		 sub	 eax, edx

; 554  :   }
; 555  :   else

  00433	e9 16 02 00 00	 jmp	 $L69681
$L69309:

; 521  : 
; 522  :       break;
; 523  : 
; 524  :     case VOID_PTR_PIPE:
; 525  : 
; 526  :       for ( i = 0; i < uiRemaining; i++ )

  00438	85 d2		 test	 edx, edx
  0043a	b9 04 00 00 00	 mov	 ecx, 4
  0043f	76 1c		 jbe	 SHORT $L69678
  00441	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  00445	8b fa		 mov	 edi, edx
$L69310:

; 527  :        *((void **)pPipe->pInput)++ = *((void **)pItems)++;

  00447	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0044a	8b 28		 mov	 ebp, DWORD PTR [eax]
  0044c	03 c1		 add	 eax, ecx
  0044e	89 2b		 mov	 DWORD PTR [ebx], ebp
  00450	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00453	03 d9		 add	 ebx, ecx
  00455	4f		 dec	 edi
  00456	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00459	75 ec		 jne	 SHORT $L69310

; 521  : 
; 522  :       break;
; 523  : 
; 524  :     case VOID_PTR_PIPE:
; 525  : 
; 526  :       for ( i = 0; i < uiRemaining; i++ )

  0045b	eb 04		 jmp	 SHORT $L69312
$L69678:
  0045d	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
$L69312:

; 528  : 
; 529  :       pPipe->pInput = pPipe->pStart;

  00461	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00464	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 530  : 
; 531  :       for ( i = uiRemaining; i < uiNumberToWrite; i++ )

  00467	8b 7c 24 1c	 mov	 edi, DWORD PTR _uiNumberToWrite$[esp+12]
  0046b	3b d7		 cmp	 edx, edi
  0046d	0f 83 33 fe ff
	ff		 jae	 $L69680

; 528  : 
; 529  :       pPipe->pInput = pPipe->pStart;

  00473	2b fa		 sub	 edi, edx
$L69315:

; 532  :        *((void **)pPipe->pInput)++ = *((void **)pItems)++;

  00475	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00478	8b 28		 mov	 ebp, DWORD PTR [eax]
  0047a	03 c1		 add	 eax, ecx
  0047c	89 2b		 mov	 DWORD PTR [ebx], ebp
  0047e	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00481	03 d9		 add	 ebx, ecx
  00483	4f		 dec	 edi
  00484	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00487	75 ec		 jne	 SHORT $L69315

; 533  : 
; 534  :       break;

  00489	8b 4c 24 1c	 mov	 ecx, DWORD PTR _uiNumberToWrite$[esp+12]

; 545  : 
; 546  :       break;
; 547  :     }
; 548  : 
; 549  :     /******************************************************************/
; 550  :     /*  Update the input position in a circular fashion.              */
; 551  :     /******************************************************************/
; 552  : 
; 553  :     pPipe->uiInputPosition = uiNumberToWrite - uiRemaining;

  0048d	8b c1		 mov	 eax, ecx
  0048f	2b c2		 sub	 eax, edx

; 554  :   }
; 555  :   else

  00491	e9 b8 01 00 00	 jmp	 $L69681
$L69320:

; 535  : 
; 536  :     default:
; 537  : 
; 538  :       for ( i = 0; i < uiRemaining; i++ )

  00496	85 d2		 test	 edx, edx
  00498	76 1b		 jbe	 SHORT $L69679
  0049a	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  0049e	8b fa		 mov	 edi, edx
$L69321:

; 539  :        *((BYTE_T *)pPipe->pInput)++ = *((BYTE_T *)pItems)++;

  004a0	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  004a3	8a 18		 mov	 bl, BYTE PTR [eax]
  004a5	88 5d 00	 mov	 BYTE PTR [ebp], bl
  004a8	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  004ab	43		 inc	 ebx
  004ac	40		 inc	 eax
  004ad	4f		 dec	 edi
  004ae	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  004b1	75 ed		 jne	 SHORT $L69321

; 535  : 
; 536  :     default:
; 537  : 
; 538  :       for ( i = 0; i < uiRemaining; i++ )

  004b3	eb 04		 jmp	 SHORT $L69323
$L69679:
  004b5	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
$L69323:

; 540  : 
; 541  :       pPipe->pInput = pPipe->pStart;

  004b9	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]

; 542  : 
; 543  :       for ( i = uiRemaining; i < uiNumberToWrite; i++ )

  004bc	3b d1		 cmp	 edx, ecx
  004be	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  004c1	0f 83 e3 fd ff
	ff		 jae	 $L69328
  004c7	8b e9		 mov	 ebp, ecx
  004c9	2b ea		 sub	 ebp, edx
$L69326:

; 544  :        *((BYTE_T *)pPipe->pInput)++ = *((BYTE_T *)pItems)++;

  004cb	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  004ce	8a 18		 mov	 bl, BYTE PTR [eax]
  004d0	88 1f		 mov	 BYTE PTR [edi], bl
  004d2	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  004d5	47		 inc	 edi
  004d6	40		 inc	 eax
  004d7	4d		 dec	 ebp
  004d8	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  004db	75 ee		 jne	 SHORT $L69326

; 545  : 
; 546  :       break;
; 547  :     }
; 548  : 
; 549  :     /******************************************************************/
; 550  :     /*  Update the input position in a circular fashion.              */
; 551  :     /******************************************************************/
; 552  : 
; 553  :     pPipe->uiInputPosition = uiNumberToWrite - uiRemaining;

  004dd	8b c1		 mov	 eax, ecx
  004df	2b c2		 sub	 eax, edx

; 554  :   }
; 555  :   else

  004e1	e9 68 01 00 00	 jmp	 $L69681
$L69238:

; 556  :   {
; 557  :     /******************************************************************/
; 558  :     /*  The data will NOT wrap around the circular queue.             */
; 559  :     /******************************************************************/
; 560  : 
; 561  :     switch ( pPipe->uiType )
; 562  :     {

  004e6	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  004e9	83 f8 06	 cmp	 eax, 6
  004ec	0f 87 3b 01 00
	00		 ja	 $L69378
  004f2	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L69683[eax*4]
$L69336:

; 563  :     case BYTE_PIPE:
; 564  : 
; 565  :       for ( i = 0; i < uiNumberToWrite; i++ )

  004f9	85 c9		 test	 ecx, ecx
  004fb	0f 86 48 01 00
	00		 jbe	 $L69381
  00501	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  00505	8b f9		 mov	 edi, ecx
$L69337:

; 566  :        *((BYTE_T *)pPipe->pInput)++ = *((BYTE_T *)pItems)++;

  00507	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0050a	8a 18		 mov	 bl, BYTE PTR [eax]
  0050c	88 1a		 mov	 BYTE PTR [edx], bl
  0050e	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  00511	45		 inc	 ebp
  00512	40		 inc	 eax
  00513	4f		 dec	 edi
  00514	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  00517	75 ee		 jne	 SHORT $L69337

; 567  : 
; 568  :       break;

  00519	e9 2b 01 00 00	 jmp	 $L69381
$L69342:

; 569  : 
; 570  :     case WORD_PIPE:
; 571  : 
; 572  :       for ( i = 0; i < uiNumberToWrite; i++ )

  0051e	85 c9		 test	 ecx, ecx
  00520	0f 86 23 01 00
	00		 jbe	 $L69381
  00526	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  0052a	8b d1		 mov	 edx, ecx
  0052c	bf 02 00 00 00	 mov	 edi, 2
$L69343:

; 573  :        *((WORD_T *)pPipe->pInput)++ = *((WORD_T *)pItems)++;

  00531	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00534	66 8b 28	 mov	 bp, WORD PTR [eax]
  00537	03 c7		 add	 eax, edi
  00539	66 89 2b	 mov	 WORD PTR [ebx], bp
  0053c	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0053f	03 df		 add	 ebx, edi
  00541	4a		 dec	 edx
  00542	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00545	75 ea		 jne	 SHORT $L69343

; 574  : 
; 575  :       break;

  00547	e9 fd 00 00 00	 jmp	 $L69381
$L69348:

; 576  : 
; 577  :     case DWORD_PIPE:
; 578  : 
; 579  :       for ( i = 0; i < uiNumberToWrite; i++ )

  0054c	85 c9		 test	 ecx, ecx
  0054e	0f 86 f5 00 00
	00		 jbe	 $L69381
  00554	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  00558	8b d1		 mov	 edx, ecx
  0055a	b9 04 00 00 00	 mov	 ecx, 4
$L69349:

; 580  :        *((DWORD_T *)pPipe->pInput)++ = *((DWORD_T *)pItems)++;

  0055f	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00562	8b 18		 mov	 ebx, DWORD PTR [eax]
  00564	03 c1		 add	 eax, ecx
  00566	89 1f		 mov	 DWORD PTR [edi], ebx
  00568	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  0056b	03 e9		 add	 ebp, ecx
  0056d	4a		 dec	 edx
  0056e	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  00571	75 ec		 jne	 SHORT $L69349

; 581  : 
; 582  :       break;

  00573	8b 4c 24 1c	 mov	 ecx, DWORD PTR _uiNumberToWrite$[esp+12]
  00577	e9 cd 00 00 00	 jmp	 $L69381
$L69354:

; 583  : 
; 584  :     case QWORD_PIPE:
; 585  : 
; 586  :       for ( i = 0; i < uiNumberToWrite; i++ )

  0057c	85 c9		 test	 ecx, ecx
  0057e	0f 86 c5 00 00
	00		 jbe	 $L69381
  00584	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  00588	8b d1		 mov	 edx, ecx
  0058a	b9 04 00 00 00	 mov	 ecx, 4
$L69355:

; 587  :        *((QWORD_T *)pPipe->pInput)++ = *((QWORD_T *)pItems)++;

  0058f	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00592	8b 18		 mov	 ebx, DWORD PTR [eax]
  00594	03 c1		 add	 eax, ecx
  00596	89 1f		 mov	 DWORD PTR [edi], ebx
  00598	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  0059b	03 e9		 add	 ebp, ecx
  0059d	4a		 dec	 edx
  0059e	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  005a1	75 ec		 jne	 SHORT $L69355

; 588  : 
; 589  :       break;

  005a3	8b 4c 24 1c	 mov	 ecx, DWORD PTR _uiNumberToWrite$[esp+12]
  005a7	e9 9d 00 00 00	 jmp	 $L69381
$L69360:

; 590  : 
; 591  :     case FLOAT_PIPE:
; 592  : 
; 593  :       for ( i = 0; i < uiNumberToWrite; i++ )

  005ac	85 c9		 test	 ecx, ecx
  005ae	0f 86 95 00 00
	00		 jbe	 $L69381
  005b4	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  005b8	8b d1		 mov	 edx, ecx
  005ba	b9 04 00 00 00	 mov	 ecx, 4
$L69361:

; 594  :        *((float *)pPipe->pInput)++ = *((float *)pItems)++;

  005bf	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  005c2	8b 18		 mov	 ebx, DWORD PTR [eax]
  005c4	03 c1		 add	 eax, ecx
  005c6	89 1f		 mov	 DWORD PTR [edi], ebx
  005c8	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  005cb	03 e9		 add	 ebp, ecx
  005cd	4a		 dec	 edx
  005ce	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  005d1	75 ec		 jne	 SHORT $L69361

; 595  : 
; 596  :       break;

  005d3	8b 4c 24 1c	 mov	 ecx, DWORD PTR _uiNumberToWrite$[esp+12]
  005d7	eb 70		 jmp	 SHORT $L69381
$L69366:

; 597  : 
; 598  :     case DOUBLE_PIPE:
; 599  : 
; 600  :       for ( i = 0; i < uiNumberToWrite; i++ )

  005d9	85 c9		 test	 ecx, ecx
  005db	76 6c		 jbe	 SHORT $L69381
  005dd	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  005e1	8b d1		 mov	 edx, ecx
  005e3	bf 08 00 00 00	 mov	 edi, 8
$L69367:

; 601  :        *((double *)pPipe->pInput)++ = *((double *)pItems)++;

  005e8	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  005eb	8b 28		 mov	 ebp, DWORD PTR [eax]
  005ed	89 2b		 mov	 DWORD PTR [ebx], ebp
  005ef	8b 68 04	 mov	 ebp, DWORD PTR [eax+4]
  005f2	03 c7		 add	 eax, edi
  005f4	89 6b 04	 mov	 DWORD PTR [ebx+4], ebp
  005f7	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  005fa	03 df		 add	 ebx, edi
  005fc	4a		 dec	 edx
  005fd	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00600	75 e6		 jne	 SHORT $L69367

; 602  : 
; 603  :       break;

  00602	eb 45		 jmp	 SHORT $L69381
$L69372:

; 604  : 
; 605  :     case VOID_PTR_PIPE:
; 606  : 
; 607  :       for ( i = 0; i < uiNumberToWrite; i++ )

  00604	85 c9		 test	 ecx, ecx
  00606	76 41		 jbe	 SHORT $L69381
  00608	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  0060c	8b d1		 mov	 edx, ecx
  0060e	b9 04 00 00 00	 mov	 ecx, 4
$L69373:

; 608  :        *((void **)pPipe->pInput)++ = *((void **)pItems)++;

  00613	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00616	8b 18		 mov	 ebx, DWORD PTR [eax]
  00618	03 c1		 add	 eax, ecx
  0061a	89 1f		 mov	 DWORD PTR [edi], ebx
  0061c	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  0061f	03 e9		 add	 ebp, ecx
  00621	4a		 dec	 edx
  00622	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  00625	75 ec		 jne	 SHORT $L69373

; 609  : 
; 610  :       break;

  00627	8b 4c 24 1c	 mov	 ecx, DWORD PTR _uiNumberToWrite$[esp+12]
  0062b	eb 1c		 jmp	 SHORT $L69381
$L69378:

; 611  : 
; 612  :     default:
; 613  : 
; 614  :       for ( i = 0; i < uiNumberToWrite; i++ )

  0062d	85 c9		 test	 ecx, ecx
  0062f	76 18		 jbe	 SHORT $L69381
  00631	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  00635	8b f9		 mov	 edi, ecx
$L69379:

; 615  :        *((BYTE_T *)pPipe->pInput)++ = *((BYTE_T *)pItems)++;

  00637	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0063a	8a 18		 mov	 bl, BYTE PTR [eax]
  0063c	88 1a		 mov	 BYTE PTR [edx], bl
  0063e	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  00641	45		 inc	 ebp
  00642	40		 inc	 eax
  00643	4f		 dec	 edi
  00644	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  00647	75 ee		 jne	 SHORT $L69379
$L69381:

; 616  : 
; 617  :       break;
; 618  :     }
; 619  : 
; 620  :     /******************************************************************/
; 621  :     /*  Update the input position.                                    */
; 622  :     /******************************************************************/
; 623  : 
; 624  :     pPipe->uiInputPosition += uiNumberToWrite;

  00649	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0064c	03 c1		 add	 eax, ecx
$L69681:

; 625  :   }
; 626  : 
; 627  :   /********************************************************************/
; 628  :   /*  Update the count of items in the pipe.                          */
; 629  :   /********************************************************************/
; 630  : 
; 631  :   pPipe->uiCount += uiNumberToWrite;

  0064e	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00651	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 632  : 
; 633  :   /********************************************************************/
; 634  :   /*  Set the pipe not empty condition.                               */
; 635  :   /********************************************************************/
; 636  : 
; 637  : /* TQL 05/21/1997  change this for OSF build */
; 638  : #ifdef WIN32
; 639  :   SetEvent( pPipe->hNotEmptyEvent );

  00654	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00657	03 d1		 add	 edx, ecx
  00659	50		 push	 eax
  0065a	89 56 1c	 mov	 DWORD PTR [esi+28], edx
  0065d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 640  : #endif
; 641  : #if defined (__osf__) || defined (__linux__)
; 642  :   OP_SetEvent( pPipe->hNotEmptyEvent );
; 643  : #endif
; 644  : 
; 645  :   /******************************************************************/
; 646  :   /*  Free the pipe resource.                                       */
; 647  :   /******************************************************************/
; 648  : 
; 649  : /* TQL 05/21/1997  change this for OSF build */
; 650  : #ifdef WIN32
; 651  :   LeaveCriticalSection( pPipe->pcsPipe );

  00663	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00666	51		 push	 ecx
  00667	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0066d	5f		 pop	 edi
  0066e	5e		 pop	 esi
  0066f	5d		 pop	 ebp
  00670	5b		 pop	 ebx

; 652  : #endif
; 653  : #if defined (__osf__) || defined (__linux__)
; 654  :   OP_UnlockMutex( pPipe->pcsPipe );
; 655  : #endif
; 656  : 
; 657  :   return;
; 658  : }

  00671	c3		 ret	 0
  00672	8b ff		 npad	 2
$L69682:
  00674	00 00 00 00	 DD	 $L69243
  00678	00 00 00 00	 DD	 $L69254
  0067c	00 00 00 00	 DD	 $L69265
  00680	00 00 00 00	 DD	 $L69276
  00684	00 00 00 00	 DD	 $L69287
  00688	00 00 00 00	 DD	 $L69298
  0068c	00 00 00 00	 DD	 $L69309
$L69683:
  00690	00 00 00 00	 DD	 $L69336
  00694	00 00 00 00	 DD	 $L69342
  00698	00 00 00 00	 DD	 $L69348
  0069c	00 00 00 00	 DD	 $L69354
  006a0	00 00 00 00	 DD	 $L69360
  006a4	00 00 00 00	 DD	 $L69366
  006a8	00 00 00 00	 DD	 $L69372
_write_pipe ENDP
_TEXT	ENDS
PUBLIC	_read_pipe
EXTRN	__imp___endthreadex:NEAR
_TEXT	SEGMENT
_pPipe$ = 8
_pItems$ = 12
_uiNumberToRead$ = 16
_read_pipe PROC NEAR

; 691  : {

  006b0	53		 push	 ebx
  006b1	55		 push	 ebp
  006b2	56		 push	 esi

; 692  :   UINT i;
; 693  :   UINT uiRemaining;
; 694  : 	UINT temp;
; 695  :  /* check the pipe guards.. */
; 696  : 
; 697  : #ifndef __linux__ 
; 698  :   assert ( ( pPipe->usGuard1 == GUARD1) 
; 699  : 	  &&( pPipe->usGuard2 == GUARD2) );
; 700  : #endif
; 701  : 
; 702  :   /********************************************************************/
; 703  :   /*  Block if the pipe resource is busy.                             */
; 704  :   /********************************************************************/
; 705  : 
; 706  : /* TQL 05/21/1997  change this for OSF build */
; 707  : #ifdef WIN32
; 708  :   EnterCriticalSection( pPipe->pcsPipe );

  006b3	8b 74 24 10	 mov	 esi, DWORD PTR _pPipe$[esp+8]
  006b7	57		 push	 edi
  006b8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__EnterCriticalSection@4
  006be	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  006c1	50		 push	 eax
  006c2	ff d7		 call	 edi

; 709  : #endif
; 710  : #if defined (__osf__) || defined (__linux__)
; 711  :   OP_LockMutex( pPipe->pcsPipe );
; 712  : #endif
; 713  : 
; 714  : 
; 715  :   /********************************************************************/
; 716  :   /*  If there are not enough items in the pipe then block.           */
; 717  :   /*  read_pipe must own pPipe->uiCount during the compare in case    */
; 718  :   /*  multiple threads are trying to read the pipe at the same time.  */
; 719  :   /********************************************************************/
; 720  : 
; 721  : 	if (uiNumberToRead == READ_WORD_PIPE_PACKET)

  006c4	8b 44 24 1c	 mov	 eax, DWORD PTR _uiNumberToRead$[esp+12]
  006c8	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__ResetEvent@4
  006ce	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__WaitForSingleObject@8
  006d4	3d de c0 ed fe	 cmp	 eax, -17973026		; feedc0deH
  006d9	75 6c		 jne	 SHORT $L69687

; 722  : 	{
; 723  : 		// peek at the data in the pipe to see how many items to read
; 724  : 		if ((pPipe->uiLength - pPipe->uiOutputPosition)==0)

  006db	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  006de	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  006e1	2b c8		 sub	 ecx, eax
  006e3	75 08		 jne	 SHORT $L69396

; 725  : 		{
; 726  : 			temp=(((((short *)pPipe->pStart)[0]&0x6000) >> 13) +1);

  006e5	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  006e8	66 8b 02	 mov	 ax, WORD PTR [edx]

; 727  : 		}
; 728  : 		else

  006eb	eb 06		 jmp	 SHORT $L69745
$L69396:

; 729  : 		{
; 730  : 			temp=(((((short *)pPipe->pOutput)[0]&0x6000) >> 13) +1);

  006ed	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  006f0	66 8b 00	 mov	 ax, WORD PTR [eax]
$L69745:

; 731  : 		}
; 732  : 
; 733  : 		while ( pPipe->uiCount < temp)

  006f3	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  006f6	c1 f8 0d	 sar	 eax, 13			; 0000000dH
  006f9	83 e0 03	 and	 eax, 3
  006fc	40		 inc	 eax
  006fd	3b c8		 cmp	 ecx, eax
  006ff	73 7a		 jae	 SHORT $L69410
$L69401:

; 734  :   {
; 735  : /* TQL 05/21/1997  change this for OSF build */
; 736  : #ifdef WIN32
; 737  : 	ResetEvent( pPipe->hNotEmptyEvent );

  00701	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00704	51		 push	 ecx
  00705	ff d3		 call	 ebx

; 738  : 
; 739  :     LeaveCriticalSection( pPipe->pcsPipe );

  00707	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  0070a	52		 push	 edx
  0070b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 740  : 
; 741  :     WaitForSingleObject( pPipe->hNotEmptyEvent, INFINITE );

  00711	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00714	6a ff		 push	 -1
  00716	50		 push	 eax
  00717	ff d5		 call	 ebp

; 742  : 
; 743  :     EnterCriticalSection( pPipe->pcsPipe );

  00719	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  0071c	51		 push	 ecx
  0071d	ff d7		 call	 edi

; 744  : 
; 745  : 			if ((pPipe->uiLength - pPipe->uiOutputPosition)==0)

  0071f	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00722	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00725	2b d0		 sub	 edx, eax
  00727	75 08		 jne	 SHORT $L69403

; 746  : 			{
; 747  : 				temp=(((((short *)pPipe->pStart)[0]&0x6000) >> 13) +1);

  00729	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0072c	66 8b 00	 mov	 ax, WORD PTR [eax]

; 748  : 			}
; 749  : 			else

  0072f	eb 06		 jmp	 SHORT $L69746
$L69403:

; 750  : 			{
; 751  : 				temp=(((((short *)pPipe->pOutput)[0]&0x6000) >> 13) +1);

  00731	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00734	66 8b 01	 mov	 ax, WORD PTR [ecx]
$L69746:
  00737	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  0073a	c1 f8 0d	 sar	 eax, 13			; 0000000dH
  0073d	83 e0 03	 and	 eax, 3
  00740	40		 inc	 eax
  00741	3b c8		 cmp	 ecx, eax
  00743	72 bc		 jb	 SHORT $L69401

; 752  : 			}
; 753  : #endif
; 754  : 
; 755  : #if defined (__osf__) || defined (__linux__)
; 756  : 	OP_ResetEvent( pPipe->hNotEmptyEvent );
; 757  : 
; 758  : 	OP_UnlockMutex( pPipe->pcsPipe );
; 759  : 
; 760  : 	OP_WaitForEvent( pPipe->hNotEmptyEvent, OP_INFINITE );
; 761  : 
; 762  : 	OP_LockMutex( pPipe->pcsPipe );
; 763  : #endif
; 764  :   }
; 765  : 	}
; 766  : 	else

  00745	eb 34		 jmp	 SHORT $L69410
$L69687:

; 767  : 	{
; 768  : 		
; 769  : 		while ( pPipe->uiCount < uiNumberToRead )

  00747	8b 54 24 1c	 mov	 edx, DWORD PTR _uiNumberToRead$[esp+12]
  0074b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0074e	3b c2		 cmp	 eax, edx
  00750	73 29		 jae	 SHORT $L69410
$L69409:

; 770  : 		{
; 771  : 			/* TQL 05/21/1997  change this for OSF build */
; 772  : #ifdef WIN32
; 773  : 			ResetEvent( pPipe->hNotEmptyEvent );

  00752	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00755	50		 push	 eax
  00756	ff d3		 call	 ebx

; 774  : 			
; 775  : 			LeaveCriticalSection( pPipe->pcsPipe );

  00758	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  0075b	51		 push	 ecx
  0075c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 776  : 
; 777  : 			WaitForSingleObject( pPipe->hNotEmptyEvent, INFINITE );

  00762	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  00765	6a ff		 push	 -1
  00767	52		 push	 edx
  00768	ff d5		 call	 ebp

; 778  : 			
; 779  : 			EnterCriticalSection( pPipe->pcsPipe );

  0076a	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0076d	50		 push	 eax
  0076e	ff d7		 call	 edi
  00770	8b 4c 24 1c	 mov	 ecx, DWORD PTR _uiNumberToRead$[esp+12]
  00774	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00777	3b c1		 cmp	 eax, ecx
  00779	72 d7		 jb	 SHORT $L69409
$L69410:

; 780  : #endif
; 781  : 			
; 782  : #if defined (__osf__) || defined (__linux__)
; 783  : 			OP_ResetEvent( pPipe->hNotEmptyEvent );
; 784  : 			
; 785  : 			OP_UnlockMutex( pPipe->pcsPipe );
; 786  : 			
; 787  : 			OP_WaitForEvent( pPipe->hNotEmptyEvent, OP_INFINITE );
; 788  : 			
; 789  : 			OP_LockMutex( pPipe->pcsPipe );
; 790  : #endif
; 791  : 		}
; 792  : 	}
; 793  :   /********************************************************************/
; 794  :   /*  If the exit flag is set then terminate the thread.              */
; 795  :   /********************************************************************/
; 796  : 
; 797  :   switch ( pPipe->uiState )
; 798  :   {

  0077b	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0077e	48		 dec	 eax
  0077f	74 1a		 je	 SHORT $L69416
  00781	48		 dec	 eax
  00782	75 3c		 jne	 SHORT $L69412

; 827  : 
; 828  :     break;
; 829  : 
; 830  :   case PIPE_EXIT:
; 831  : 
; 832  : /* TQL 05/21/1997  change this for OSF build */
; 833  : #ifdef WIN32
; 834  :     LeaveCriticalSection( pPipe->pcsPipe );

  00784	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00787	52		 push	 edx
  00788	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 835  : #endif
; 836  : #if defined (__osf__) || defined (__linux__)
; 837  : 	OP_UnlockMutex( pPipe->pcsPipe );
; 838  : #endif
; 839  : 
; 840  :     /*MVP : Microsoft reocmmends to use _endthreadex for the proper recovery
; 841  :             of resources from the thread
; 842  :     */
; 843  : #ifdef OLD
; 844  :     ExitThread( 0 );
; 845  : #endif
; 846  : 
; 847  : /* GL 04/21/1997  change this for OSF build */
; 848  : #ifdef WIN32
; 849  : #ifndef LDS_BUILD
; 850  :     _endthreadex(0);

  0078e	6a 00		 push	 0
  00790	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___endthreadex
  00796	83 c4 04	 add	 esp, 4

; 851  : #endif
; 852  : #endif
; 853  : 
; 854  : #if defined (__osf__) || defined (__linux__)
; 855  : 	OP_ExitThread(0);
; 856  : 	OP_THREAD_RETURN;
; 857  : #endif
; 858  : 
; 859  :     break;

  00799	eb 25		 jmp	 SHORT $L69412
$L69416:

; 799  :   case PIPE_NORMAL:
; 800  : 
; 801  :     break;
; 802  : 
; 803  :   case PIPE_PAUSE:
; 804  : 
; 805  : /* TQL 05/21/1997  change this for OSF build */
; 806  : #ifdef WIN32
; 807  :     ResetEvent( pPipe->hNotPausedEvent );

  0079b	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0079e	50		 push	 eax
  0079f	ff d3		 call	 ebx

; 808  : 
; 809  :     LeaveCriticalSection( pPipe->pcsPipe );

  007a1	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  007a4	51		 push	 ecx
  007a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 810  : 
; 811  :     WaitForSingleObject( pPipe->hNotPausedEvent, INFINITE );

  007ab	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  007ae	6a ff		 push	 -1
  007b0	52		 push	 edx
  007b1	ff d5		 call	 ebp

; 812  : 
; 813  :     EnterCriticalSection( pPipe->pcsPipe );

  007b3	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  007b6	50		 push	 eax
  007b7	ff d7		 call	 edi

; 814  : #endif
; 815  : 
; 816  : #if defined (__osf__) || defined (__linux__)
; 817  :     OP_ResetEvent( pPipe->hNotPausedEvent );
; 818  : 
; 819  :     OP_UnlockMutex( pPipe->pcsPipe );
; 820  : 
; 821  :     OP_WaitForEvent( pPipe->hNotPausedEvent, OP_INFINITE );
; 822  : 
; 823  :     OP_LockMutex( pPipe->pcsPipe );
; 824  : #endif
; 825  : 
; 826  :     pPipe->uiState = PIPE_NORMAL;

  007b9	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
$L69412:

; 860  : 
; 861  :   default:
; 862  : 
; 863  :     break;
; 864  :   }
; 865  : 
; 866  :   /********************************************************************/
; 867  :   /*  There are enough items in the pipe.                             */
; 868  :   /*  Test to see if the read of the data wraps around the queue.     */
; 869  :   /********************************************************************/
; 870  : 
; 871  : 
; 872  : 	if (uiNumberToRead == READ_WORD_PIPE_PACKET)

  007c0	8b 7c 24 1c	 mov	 edi, DWORD PTR _uiNumberToRead$[esp+12]
  007c4	81 ff de c0 ed
	fe		 cmp	 edi, -17973026		; feedc0deH
  007ca	75 23		 jne	 SHORT $L69422

; 873  : 	{
; 874  : 		// peek at the pipe to figure out how many items to read
; 875  : 		if ((pPipe->uiLength - pPipe->uiOutputPosition)==0)

  007cc	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  007cf	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  007d2	2b c8		 sub	 ecx, eax
  007d4	75 08		 jne	 SHORT $L69420

; 876  : 		{
; 877  : 			uiNumberToRead=(((((short *)pPipe->pStart)[0]&0x6000) >> 13) +1);

  007d6	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  007d9	66 8b 3a	 mov	 di, WORD PTR [edx]

; 878  : 		}
; 879  : 		else

  007dc	eb 06		 jmp	 SHORT $L69747
$L69420:

; 880  : 		{
; 881  : 			uiNumberToRead=(((((short *)pPipe->pOutput)[0]&0x6000) >> 13) +1);

  007de	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  007e1	66 8b 38	 mov	 di, WORD PTR [eax]
$L69747:
  007e4	c1 ff 0d	 sar	 edi, 13			; 0000000dH
  007e7	83 e7 03	 and	 edi, 3
  007ea	47		 inc	 edi
  007eb	89 7c 24 1c	 mov	 DWORD PTR _uiNumberToRead$[esp+12], edi
$L69422:

; 882  : 		}
; 883  : 	}
; 884  : 	
; 885  :   if ( pPipe->uiOutputPosition + uiNumberToRead > pPipe->uiLength )

  007ef	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  007f2	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  007f5	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  007f8	3b ca		 cmp	 ecx, edx
  007fa	0f 86 e5 02 00
	00		 jbe	 $L69424

; 886  :   {
; 887  :     /******************************************************************/
; 888  :     /*  The read of the data will wrap around the circular queue.     */
; 889  :     /******************************************************************/
; 890  : 
; 891  :     uiRemaining = pPipe->uiLength - pPipe->uiOutputPosition;

  00800	2b d0		 sub	 edx, eax

; 892  : 
; 893  :     switch ( pPipe->uiType )
; 894  :     {

  00802	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00805	83 f8 06	 cmp	 eax, 6
  00808	0f 87 8a 02 00
	00		 ja	 $L69506
  0080e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L69749[eax*4]
$L69429:

; 895  :     case BYTE_PIPE:
; 896  : 
; 897  :       for ( i = 0; i < uiRemaining; i++ )

  00815	85 d2		 test	 edx, edx
  00817	76 1b		 jbe	 SHORT $L69737
  00819	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  0081d	8b ea		 mov	 ebp, edx
$L69430:

; 898  :         *((BYTE_T *)pItems)++ = *((BYTE_T *)pPipe->pOutput)++;

  0081f	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00822	40		 inc	 eax
  00823	8a 09		 mov	 cl, BYTE PTR [ecx]
  00825	88 48 ff	 mov	 BYTE PTR [eax-1], cl
  00828	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  0082b	43		 inc	 ebx
  0082c	4d		 dec	 ebp
  0082d	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00830	75 ed		 jne	 SHORT $L69430

; 895  :     case BYTE_PIPE:
; 896  : 
; 897  :       for ( i = 0; i < uiRemaining; i++ )

  00832	eb 04		 jmp	 SHORT $L69432
$L69737:
  00834	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
$L69432:

; 899  : 
; 900  :       pPipe->pOutput = pPipe->pStart;

  00838	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 901  : 
; 902  :       for ( i = uiRemaining; i < uiNumberToRead; i++ )

  0083b	3b d7		 cmp	 edx, edi
  0083d	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00840	0f 83 94 02 00
	00		 jae	 $L69514

; 899  : 
; 900  :       pPipe->pOutput = pPipe->pStart;

  00846	2b fa		 sub	 edi, edx
$L69435:

; 903  :         *((BYTE_T *)pItems)++ = *((BYTE_T *)pPipe->pOutput)++;

  00848	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0084b	40		 inc	 eax
  0084c	8a 09		 mov	 cl, BYTE PTR [ecx]
  0084e	88 48 ff	 mov	 BYTE PTR [eax-1], cl
  00851	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00854	43		 inc	 ebx
  00855	4f		 dec	 edi
  00856	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00859	75 ed		 jne	 SHORT $L69435

; 988  : 
; 989  :       break;
; 990  :     }
; 991  : 
; 992  :     /******************************************************************/
; 993  :     /*  Update the output position in a circular fashion.             */
; 994  :     /******************************************************************/
; 995  : 
; 996  :     pPipe->uiOutputPosition = uiNumberToRead - uiRemaining;

  0085b	8b 44 24 1c	 mov	 eax, DWORD PTR _uiNumberToRead$[esp+12]
  0085f	2b c2		 sub	 eax, edx

; 997  :   }
; 998  :   else

  00861	e9 e1 03 00 00	 jmp	 $L69748
$L69440:

; 904  : 
; 905  :       break;
; 906  : 
; 907  :     case WORD_PIPE:
; 908  : 
; 909  :       for ( i = 0; i < uiRemaining; i++ )

  00866	85 d2		 test	 edx, edx
  00868	bb 02 00 00 00	 mov	 ebx, 2
  0086d	76 1f		 jbe	 SHORT $L69738
  0086f	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  00873	8b ca		 mov	 ecx, edx
$L69441:

; 910  :         *((WORD_T *)pItems)++ = *((WORD_T *)pPipe->pOutput)++;

  00875	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  00878	66 8b 6d 00	 mov	 bp, WORD PTR [ebp]
  0087c	66 89 28	 mov	 WORD PTR [eax], bp
  0087f	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  00882	03 c3		 add	 eax, ebx
  00884	03 eb		 add	 ebp, ebx
  00886	49		 dec	 ecx
  00887	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  0088a	75 e9		 jne	 SHORT $L69441

; 904  : 
; 905  :       break;
; 906  : 
; 907  :     case WORD_PIPE:
; 908  : 
; 909  :       for ( i = 0; i < uiRemaining; i++ )

  0088c	eb 04		 jmp	 SHORT $L69443
$L69738:
  0088e	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
$L69443:

; 911  : 
; 912  :       pPipe->pOutput = pPipe->pStart;

  00892	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 913  : 
; 914  :       for ( i = uiRemaining; i < uiNumberToRead; i++ )

  00895	3b d7		 cmp	 edx, edi
  00897	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  0089a	0f 83 3a 02 00
	00		 jae	 $L69514

; 911  : 
; 912  :       pPipe->pOutput = pPipe->pStart;

  008a0	2b fa		 sub	 edi, edx
$L69446:

; 915  :         *((WORD_T *)pItems)++ = *((WORD_T *)pPipe->pOutput)++;

  008a2	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  008a5	66 8b 09	 mov	 cx, WORD PTR [ecx]
  008a8	66 89 08	 mov	 WORD PTR [eax], cx
  008ab	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  008ae	03 c3		 add	 eax, ebx
  008b0	03 eb		 add	 ebp, ebx
  008b2	4f		 dec	 edi
  008b3	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  008b6	75 ea		 jne	 SHORT $L69446

; 988  : 
; 989  :       break;
; 990  :     }
; 991  : 
; 992  :     /******************************************************************/
; 993  :     /*  Update the output position in a circular fashion.             */
; 994  :     /******************************************************************/
; 995  : 
; 996  :     pPipe->uiOutputPosition = uiNumberToRead - uiRemaining;

  008b8	8b 44 24 1c	 mov	 eax, DWORD PTR _uiNumberToRead$[esp+12]
  008bc	2b c2		 sub	 eax, edx

; 997  :   }
; 998  :   else

  008be	e9 84 03 00 00	 jmp	 $L69748
$L69451:

; 916  : 
; 917  :       break;
; 918  : 
; 919  :     case DWORD_PIPE:
; 920  : 
; 921  :       for ( i = 0; i < uiRemaining; i++ )

  008c3	85 d2		 test	 edx, edx
  008c5	b9 04 00 00 00	 mov	 ecx, 4
  008ca	76 1c		 jbe	 SHORT $L69739
  008cc	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  008d0	8b fa		 mov	 edi, edx
$L69452:

; 922  :         *((DWORD_T *)pItems)++ = *((DWORD_T *)pPipe->pOutput)++;

  008d2	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  008d5	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  008d7	89 18		 mov	 DWORD PTR [eax], ebx
  008d9	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  008dc	03 c1		 add	 eax, ecx
  008de	03 e9		 add	 ebp, ecx
  008e0	4f		 dec	 edi
  008e1	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  008e4	75 ec		 jne	 SHORT $L69452

; 916  : 
; 917  :       break;
; 918  : 
; 919  :     case DWORD_PIPE:
; 920  : 
; 921  :       for ( i = 0; i < uiRemaining; i++ )

  008e6	eb 04		 jmp	 SHORT $L69454
$L69739:
  008e8	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
$L69454:

; 923  : 
; 924  :       pPipe->pOutput = pPipe->pStart;

  008ec	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  008ef	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 925  : 
; 926  :       for ( i = uiRemaining; i < uiNumberToRead; i++ )

  008f2	8b 7c 24 1c	 mov	 edi, DWORD PTR _uiNumberToRead$[esp+12]
  008f6	3b d7		 cmp	 edx, edi
  008f8	0f 83 dc 01 00
	00		 jae	 $L69514

; 923  : 
; 924  :       pPipe->pOutput = pPipe->pStart;

  008fe	2b fa		 sub	 edi, edx
$L69457:

; 927  :         *((DWORD_T *)pItems)++ = *((DWORD_T *)pPipe->pOutput)++;

  00900	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00903	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  00905	89 18		 mov	 DWORD PTR [eax], ebx
  00907	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  0090a	03 c1		 add	 eax, ecx
  0090c	03 e9		 add	 ebp, ecx
  0090e	4f		 dec	 edi
  0090f	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  00912	75 ec		 jne	 SHORT $L69457

; 988  : 
; 989  :       break;
; 990  :     }
; 991  : 
; 992  :     /******************************************************************/
; 993  :     /*  Update the output position in a circular fashion.             */
; 994  :     /******************************************************************/
; 995  : 
; 996  :     pPipe->uiOutputPosition = uiNumberToRead - uiRemaining;

  00914	8b 44 24 1c	 mov	 eax, DWORD PTR _uiNumberToRead$[esp+12]
  00918	2b c2		 sub	 eax, edx

; 997  :   }
; 998  :   else

  0091a	e9 28 03 00 00	 jmp	 $L69748
$L69462:

; 928  : 
; 929  :       break;
; 930  : 
; 931  :     case QWORD_PIPE:
; 932  : 
; 933  :       for ( i = 0; i < uiRemaining; i++ )

  0091f	85 d2		 test	 edx, edx
  00921	b9 04 00 00 00	 mov	 ecx, 4
  00926	76 1c		 jbe	 SHORT $L69740
  00928	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  0092c	8b fa		 mov	 edi, edx
$L69463:

; 934  :         *((QWORD_T *)pItems)++ = *((QWORD_T *)pPipe->pOutput)++;

  0092e	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00931	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  00933	89 18		 mov	 DWORD PTR [eax], ebx
  00935	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  00938	03 c1		 add	 eax, ecx
  0093a	03 e9		 add	 ebp, ecx
  0093c	4f		 dec	 edi
  0093d	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  00940	75 ec		 jne	 SHORT $L69463

; 928  : 
; 929  :       break;
; 930  : 
; 931  :     case QWORD_PIPE:
; 932  : 
; 933  :       for ( i = 0; i < uiRemaining; i++ )

  00942	eb 04		 jmp	 SHORT $L69465
$L69740:
  00944	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
$L69465:

; 935  : 
; 936  :       pPipe->pOutput = pPipe->pStart;

  00948	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0094b	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 937  : 
; 938  :       for ( i = uiRemaining; i < uiNumberToRead; i++ )

  0094e	8b 7c 24 1c	 mov	 edi, DWORD PTR _uiNumberToRead$[esp+12]
  00952	3b d7		 cmp	 edx, edi
  00954	0f 83 80 01 00
	00		 jae	 $L69514

; 935  : 
; 936  :       pPipe->pOutput = pPipe->pStart;

  0095a	2b fa		 sub	 edi, edx
$L69468:

; 939  :         *((QWORD_T *)pItems)++ = *((QWORD_T *)pPipe->pOutput)++;

  0095c	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  0095f	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  00961	89 18		 mov	 DWORD PTR [eax], ebx
  00963	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  00966	03 c1		 add	 eax, ecx
  00968	03 e9		 add	 ebp, ecx
  0096a	4f		 dec	 edi
  0096b	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  0096e	75 ec		 jne	 SHORT $L69468

; 988  : 
; 989  :       break;
; 990  :     }
; 991  : 
; 992  :     /******************************************************************/
; 993  :     /*  Update the output position in a circular fashion.             */
; 994  :     /******************************************************************/
; 995  : 
; 996  :     pPipe->uiOutputPosition = uiNumberToRead - uiRemaining;

  00970	8b 44 24 1c	 mov	 eax, DWORD PTR _uiNumberToRead$[esp+12]
  00974	2b c2		 sub	 eax, edx

; 997  :   }
; 998  :   else

  00976	e9 cc 02 00 00	 jmp	 $L69748
$L69473:

; 940  : 
; 941  :       break;
; 942  : 
; 943  :     case FLOAT_PIPE:
; 944  : 
; 945  :       for ( i = 0; i < uiRemaining; i++ )

  0097b	85 d2		 test	 edx, edx
  0097d	b9 04 00 00 00	 mov	 ecx, 4
  00982	76 1c		 jbe	 SHORT $L69741
  00984	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  00988	8b fa		 mov	 edi, edx
$L69474:

; 946  :         *((float *)pItems)++ = *((float *)pPipe->pOutput)++;

  0098a	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  0098d	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  0098f	89 18		 mov	 DWORD PTR [eax], ebx
  00991	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  00994	03 c1		 add	 eax, ecx
  00996	03 e9		 add	 ebp, ecx
  00998	4f		 dec	 edi
  00999	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  0099c	75 ec		 jne	 SHORT $L69474

; 940  : 
; 941  :       break;
; 942  : 
; 943  :     case FLOAT_PIPE:
; 944  : 
; 945  :       for ( i = 0; i < uiRemaining; i++ )

  0099e	eb 04		 jmp	 SHORT $L69476
$L69741:
  009a0	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
$L69476:

; 947  : 
; 948  :       pPipe->pOutput = pPipe->pStart;

  009a4	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  009a7	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 949  : 
; 950  :       for ( i = uiRemaining; i < uiNumberToRead; i++ )

  009aa	8b 7c 24 1c	 mov	 edi, DWORD PTR _uiNumberToRead$[esp+12]
  009ae	3b d7		 cmp	 edx, edi
  009b0	0f 83 24 01 00
	00		 jae	 $L69514

; 947  : 
; 948  :       pPipe->pOutput = pPipe->pStart;

  009b6	2b fa		 sub	 edi, edx
$L69479:

; 951  :         *((float *)pItems)++ = *((float *)pPipe->pOutput)++;

  009b8	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  009bb	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  009bd	89 18		 mov	 DWORD PTR [eax], ebx
  009bf	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  009c2	03 c1		 add	 eax, ecx
  009c4	03 e9		 add	 ebp, ecx
  009c6	4f		 dec	 edi
  009c7	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  009ca	75 ec		 jne	 SHORT $L69479

; 988  : 
; 989  :       break;
; 990  :     }
; 991  : 
; 992  :     /******************************************************************/
; 993  :     /*  Update the output position in a circular fashion.             */
; 994  :     /******************************************************************/
; 995  : 
; 996  :     pPipe->uiOutputPosition = uiNumberToRead - uiRemaining;

  009cc	8b 44 24 1c	 mov	 eax, DWORD PTR _uiNumberToRead$[esp+12]
  009d0	2b c2		 sub	 eax, edx

; 997  :   }
; 998  :   else

  009d2	e9 70 02 00 00	 jmp	 $L69748
$L69484:

; 952  : 
; 953  :       break;
; 954  : 
; 955  :     case DOUBLE_PIPE:
; 956  : 
; 957  :       for ( i = 0; i < uiRemaining; i++ )

  009d7	85 d2		 test	 edx, edx
  009d9	bb 08 00 00 00	 mov	 ebx, 8
  009de	76 27		 jbe	 SHORT $L69742
  009e0	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  009e4	8b ca		 mov	 ecx, edx
$L69485:

; 958  :         *((double *)pItems)++ = *((double *)pPipe->pOutput)++;

  009e6	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  009e9	8b 2b		 mov	 ebp, DWORD PTR [ebx]
  009eb	89 28		 mov	 DWORD PTR [eax], ebp
  009ed	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  009f0	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  009f3	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  009f6	bb 08 00 00 00	 mov	 ebx, 8
  009fb	03 c3		 add	 eax, ebx
  009fd	03 eb		 add	 ebp, ebx
  009ff	49		 dec	 ecx
  00a00	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  00a03	75 e1		 jne	 SHORT $L69485

; 952  : 
; 953  :       break;
; 954  : 
; 955  :     case DOUBLE_PIPE:
; 956  : 
; 957  :       for ( i = 0; i < uiRemaining; i++ )

  00a05	eb 04		 jmp	 SHORT $L69487
$L69742:
  00a07	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
$L69487:

; 959  : 
; 960  :       pPipe->pOutput = pPipe->pStart;

  00a0b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 961  : 
; 962  :       for ( i = uiRemaining; i < uiNumberToRead; i++ )

  00a0e	3b d7		 cmp	 edx, edi
  00a10	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00a13	0f 83 c1 00 00
	00		 jae	 $L69514

; 959  : 
; 960  :       pPipe->pOutput = pPipe->pStart;

  00a19	2b fa		 sub	 edi, edx
$L69490:

; 963  :         *((double *)pItems)++ = *((double *)pPipe->pOutput)++;

  00a1b	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00a1e	8b 29		 mov	 ebp, DWORD PTR [ecx]
  00a20	89 28		 mov	 DWORD PTR [eax], ebp
  00a22	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00a25	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00a28	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  00a2b	03 c3		 add	 eax, ebx
  00a2d	03 eb		 add	 ebp, ebx
  00a2f	4f		 dec	 edi
  00a30	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  00a33	75 e6		 jne	 SHORT $L69490

; 988  : 
; 989  :       break;
; 990  :     }
; 991  : 
; 992  :     /******************************************************************/
; 993  :     /*  Update the output position in a circular fashion.             */
; 994  :     /******************************************************************/
; 995  : 
; 996  :     pPipe->uiOutputPosition = uiNumberToRead - uiRemaining;

  00a35	8b 44 24 1c	 mov	 eax, DWORD PTR _uiNumberToRead$[esp+12]
  00a39	2b c2		 sub	 eax, edx

; 997  :   }
; 998  :   else

  00a3b	e9 07 02 00 00	 jmp	 $L69748
$L69495:

; 964  : 
; 965  :       break;
; 966  : 
; 967  :     case VOID_PTR_PIPE:
; 968  : 
; 969  :       for ( i = 0; i < uiRemaining; i++ )

  00a40	85 d2		 test	 edx, edx
  00a42	b9 04 00 00 00	 mov	 ecx, 4
  00a47	76 1c		 jbe	 SHORT $L69743
  00a49	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  00a4d	8b fa		 mov	 edi, edx
$L69496:

; 970  :         *((void **)pItems)++ = *((void **)pPipe->pOutput)++;

  00a4f	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00a52	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  00a54	89 18		 mov	 DWORD PTR [eax], ebx
  00a56	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  00a59	03 c1		 add	 eax, ecx
  00a5b	03 e9		 add	 ebp, ecx
  00a5d	4f		 dec	 edi
  00a5e	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  00a61	75 ec		 jne	 SHORT $L69496

; 964  : 
; 965  :       break;
; 966  : 
; 967  :     case VOID_PTR_PIPE:
; 968  : 
; 969  :       for ( i = 0; i < uiRemaining; i++ )

  00a63	eb 04		 jmp	 SHORT $L69498
$L69743:
  00a65	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
$L69498:

; 971  : 
; 972  :       pPipe->pOutput = pPipe->pStart;

  00a69	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00a6c	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 973  : 
; 974  :       for ( i = uiRemaining; i < uiNumberToRead; i++ )

  00a6f	8b 7c 24 1c	 mov	 edi, DWORD PTR _uiNumberToRead$[esp+12]
  00a73	3b d7		 cmp	 edx, edi
  00a75	73 63		 jae	 SHORT $L69514

; 971  : 
; 972  :       pPipe->pOutput = pPipe->pStart;

  00a77	2b fa		 sub	 edi, edx
$L69501:

; 975  :         *((void **)pItems)++ = *((void **)pPipe->pOutput)++;

  00a79	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00a7c	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  00a7e	89 18		 mov	 DWORD PTR [eax], ebx
  00a80	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  00a83	03 c1		 add	 eax, ecx
  00a85	03 e9		 add	 ebp, ecx
  00a87	4f		 dec	 edi
  00a88	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  00a8b	75 ec		 jne	 SHORT $L69501

; 988  : 
; 989  :       break;
; 990  :     }
; 991  : 
; 992  :     /******************************************************************/
; 993  :     /*  Update the output position in a circular fashion.             */
; 994  :     /******************************************************************/
; 995  : 
; 996  :     pPipe->uiOutputPosition = uiNumberToRead - uiRemaining;

  00a8d	8b 44 24 1c	 mov	 eax, DWORD PTR _uiNumberToRead$[esp+12]
  00a91	2b c2		 sub	 eax, edx

; 997  :   }
; 998  :   else

  00a93	e9 af 01 00 00	 jmp	 $L69748
$L69506:

; 976  : 
; 977  :       break;
; 978  : 
; 979  :     default:
; 980  : 
; 981  :       for ( i = 0; i < uiRemaining; i++ )

  00a98	85 d2		 test	 edx, edx
  00a9a	76 1b		 jbe	 SHORT $L69744
  00a9c	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  00aa0	8b ea		 mov	 ebp, edx
$L69507:

; 982  :         *((BYTE_T *)pItems)++ = *((BYTE_T *)pPipe->pOutput)++;

  00aa2	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00aa5	40		 inc	 eax
  00aa6	8a 09		 mov	 cl, BYTE PTR [ecx]
  00aa8	88 48 ff	 mov	 BYTE PTR [eax-1], cl
  00aab	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00aae	43		 inc	 ebx
  00aaf	4d		 dec	 ebp
  00ab0	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00ab3	75 ed		 jne	 SHORT $L69507

; 976  : 
; 977  :       break;
; 978  : 
; 979  :     default:
; 980  : 
; 981  :       for ( i = 0; i < uiRemaining; i++ )

  00ab5	eb 04		 jmp	 SHORT $L69509
$L69744:
  00ab7	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
$L69509:

; 983  : 
; 984  :       pPipe->pOutput = pPipe->pStart;

  00abb	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 985  : 
; 986  :       for ( i = uiRemaining; i < uiNumberToRead; i++ )

  00abe	3b d7		 cmp	 edx, edi
  00ac0	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00ac3	73 15		 jae	 SHORT $L69514

; 983  : 
; 984  :       pPipe->pOutput = pPipe->pStart;

  00ac5	2b fa		 sub	 edi, edx
$L69512:

; 987  :         *((BYTE_T *)pItems)++ = *((BYTE_T *)pPipe->pOutput)++;

  00ac7	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00aca	40		 inc	 eax
  00acb	8a 09		 mov	 cl, BYTE PTR [ecx]
  00acd	88 48 ff	 mov	 BYTE PTR [eax-1], cl
  00ad0	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00ad3	43		 inc	 ebx
  00ad4	4f		 dec	 edi
  00ad5	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00ad8	75 ed		 jne	 SHORT $L69512
$L69514:

; 988  : 
; 989  :       break;
; 990  :     }
; 991  : 
; 992  :     /******************************************************************/
; 993  :     /*  Update the output position in a circular fashion.             */
; 994  :     /******************************************************************/
; 995  : 
; 996  :     pPipe->uiOutputPosition = uiNumberToRead - uiRemaining;

  00ada	8b 44 24 1c	 mov	 eax, DWORD PTR _uiNumberToRead$[esp+12]
  00ade	2b c2		 sub	 eax, edx

; 997  :   }
; 998  :   else

  00ae0	e9 62 01 00 00	 jmp	 $L69748
$L69424:

; 999  :   {
; 1000 :     /******************************************************************/
; 1001 :     /*  The read of the data will NOT wrap around the circular queue. */
; 1002 :     /******************************************************************/
; 1003 : 
; 1004 :     switch ( pPipe->uiType )
; 1005 :     {

  00ae5	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00ae8	83 f8 06	 cmp	 eax, 6
  00aeb	0f 87 34 01 00
	00		 ja	 $L69564
  00af1	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L69750[eax*4]
$L69522:

; 1006 :     case BYTE_PIPE:
; 1007 : 
; 1008 :       for ( i = 0; i < uiNumberToRead; i++ )

  00af8	85 ff		 test	 edi, edi
  00afa	0f 86 42 01 00
	00		 jbe	 $L69567
  00b00	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  00b04	8b cf		 mov	 ecx, edi
$L69523:

; 1009 :         *((BYTE_T *)pItems)++ = *((BYTE_T *)pPipe->pOutput)++;

  00b06	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00b09	40		 inc	 eax
  00b0a	8a 12		 mov	 dl, BYTE PTR [edx]
  00b0c	88 50 ff	 mov	 BYTE PTR [eax-1], dl
  00b0f	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00b12	43		 inc	 ebx
  00b13	49		 dec	 ecx
  00b14	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00b17	75 ed		 jne	 SHORT $L69523

; 1010 : 
; 1011 :       break;

  00b19	e9 24 01 00 00	 jmp	 $L69567
$L69528:

; 1012 : 
; 1013 :     case WORD_PIPE:
; 1014 : 
; 1015 :       for ( i = 0; i < uiNumberToRead; i++ )

  00b1e	85 ff		 test	 edi, edi
  00b20	0f 86 1c 01 00
	00		 jbe	 $L69567
  00b26	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  00b2a	8b cf		 mov	 ecx, edi
  00b2c	bb 02 00 00 00	 mov	 ebx, 2
$L69529:

; 1016 :         *((WORD_T *)pItems)++ = *((WORD_T *)pPipe->pOutput)++;

  00b31	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00b34	66 8b 12	 mov	 dx, WORD PTR [edx]
  00b37	66 89 10	 mov	 WORD PTR [eax], dx
  00b3a	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  00b3d	03 c3		 add	 eax, ebx
  00b3f	03 eb		 add	 ebp, ebx
  00b41	49		 dec	 ecx
  00b42	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  00b45	75 ea		 jne	 SHORT $L69529

; 1017 : 
; 1018 :       break;

  00b47	e9 f6 00 00 00	 jmp	 $L69567
$L69534:

; 1019 : 
; 1020 :     case DWORD_PIPE:
; 1021 : 
; 1022 :       for ( i = 0; i < uiNumberToRead; i++ )

  00b4c	85 ff		 test	 edi, edi
  00b4e	0f 86 ee 00 00
	00		 jbe	 $L69567
  00b54	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  00b58	b9 04 00 00 00	 mov	 ecx, 4
$L69535:

; 1023 :         *((DWORD_T *)pItems)++ = *((DWORD_T *)pPipe->pOutput)++;

  00b5d	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00b60	8b 12		 mov	 edx, DWORD PTR [edx]
  00b62	89 10		 mov	 DWORD PTR [eax], edx
  00b64	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00b67	03 c1		 add	 eax, ecx
  00b69	03 d9		 add	 ebx, ecx
  00b6b	4f		 dec	 edi
  00b6c	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00b6f	75 ec		 jne	 SHORT $L69535

; 1024 : 
; 1025 :       break;

  00b71	8b 7c 24 1c	 mov	 edi, DWORD PTR _uiNumberToRead$[esp+12]
  00b75	e9 c8 00 00 00	 jmp	 $L69567
$L69540:

; 1026 : 
; 1027 :     case QWORD_PIPE:
; 1028 : 
; 1029 :       for ( i = 0; i < uiNumberToRead; i++ )

  00b7a	85 ff		 test	 edi, edi
  00b7c	0f 86 c0 00 00
	00		 jbe	 $L69567
  00b82	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  00b86	b9 04 00 00 00	 mov	 ecx, 4
$L69541:

; 1030 :         *((QWORD_T *)pItems)++ = *((QWORD_T *)pPipe->pOutput)++;

  00b8b	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00b8e	8b 12		 mov	 edx, DWORD PTR [edx]
  00b90	89 10		 mov	 DWORD PTR [eax], edx
  00b92	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00b95	03 c1		 add	 eax, ecx
  00b97	03 d9		 add	 ebx, ecx
  00b99	4f		 dec	 edi
  00b9a	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00b9d	75 ec		 jne	 SHORT $L69541

; 1031 : 
; 1032 :       break;

  00b9f	8b 7c 24 1c	 mov	 edi, DWORD PTR _uiNumberToRead$[esp+12]
  00ba3	e9 9a 00 00 00	 jmp	 $L69567
$L69546:

; 1033 : 
; 1034 :     case FLOAT_PIPE:
; 1035 : 
; 1036 :       for ( i = 0; i < uiNumberToRead; i++ )

  00ba8	85 ff		 test	 edi, edi
  00baa	0f 86 92 00 00
	00		 jbe	 $L69567
  00bb0	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  00bb4	b9 04 00 00 00	 mov	 ecx, 4
$L69547:

; 1037 :         *((float *)pItems)++ = *((float *)pPipe->pOutput)++;

  00bb9	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00bbc	8b 12		 mov	 edx, DWORD PTR [edx]
  00bbe	89 10		 mov	 DWORD PTR [eax], edx
  00bc0	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00bc3	03 c1		 add	 eax, ecx
  00bc5	03 d9		 add	 ebx, ecx
  00bc7	4f		 dec	 edi
  00bc8	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00bcb	75 ec		 jne	 SHORT $L69547

; 1038 : 
; 1039 :       break;

  00bcd	8b 7c 24 1c	 mov	 edi, DWORD PTR _uiNumberToRead$[esp+12]
  00bd1	eb 6f		 jmp	 SHORT $L69567
$L69552:

; 1040 : 
; 1041 :     case DOUBLE_PIPE:
; 1042 : 
; 1043 :       for ( i = 0; i < uiNumberToRead; i++ )

  00bd3	85 ff		 test	 edi, edi
  00bd5	76 6b		 jbe	 SHORT $L69567
  00bd7	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  00bdb	8b cf		 mov	 ecx, edi
  00bdd	ba 08 00 00 00	 mov	 edx, 8
$L69553:

; 1044 :         *((double *)pItems)++ = *((double *)pPipe->pOutput)++;

  00be2	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00be5	8b 2b		 mov	 ebp, DWORD PTR [ebx]
  00be7	89 28		 mov	 DWORD PTR [eax], ebp
  00be9	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  00bec	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00bef	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  00bf2	03 c2		 add	 eax, edx
  00bf4	03 ea		 add	 ebp, edx
  00bf6	49		 dec	 ecx
  00bf7	89 6e 0c	 mov	 DWORD PTR [esi+12], ebp
  00bfa	75 e6		 jne	 SHORT $L69553

; 1045 : 
; 1046 :       break;

  00bfc	eb 44		 jmp	 SHORT $L69567
$L69558:

; 1047 : 
; 1048 :     case VOID_PTR_PIPE:
; 1049 : 
; 1050 :       for ( i = 0; i < uiNumberToRead; i++ )

  00bfe	85 ff		 test	 edi, edi
  00c00	76 40		 jbe	 SHORT $L69567
  00c02	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  00c06	b9 04 00 00 00	 mov	 ecx, 4
$L69559:

; 1051 :         *((void **)pItems)++ = *((void **)pPipe->pOutput)++;

  00c0b	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00c0e	8b 12		 mov	 edx, DWORD PTR [edx]
  00c10	89 10		 mov	 DWORD PTR [eax], edx
  00c12	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00c15	03 c1		 add	 eax, ecx
  00c17	03 d9		 add	 ebx, ecx
  00c19	4f		 dec	 edi
  00c1a	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00c1d	75 ec		 jne	 SHORT $L69559

; 1052 : 
; 1053 :       break;

  00c1f	8b 7c 24 1c	 mov	 edi, DWORD PTR _uiNumberToRead$[esp+12]
  00c23	eb 1d		 jmp	 SHORT $L69567
$L69564:

; 1054 : 
; 1055 :     default:
; 1056 : 
; 1057 :       for ( i = 0; i < uiNumberToRead; i++ )

  00c25	85 ff		 test	 edi, edi
  00c27	76 19		 jbe	 SHORT $L69567
  00c29	8b 44 24 18	 mov	 eax, DWORD PTR _pItems$[esp+12]
  00c2d	8b cf		 mov	 ecx, edi
$L69565:

; 1058 :         *((BYTE_T *)pItems)++ = *((BYTE_T *)pPipe->pOutput)++;

  00c2f	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00c32	40		 inc	 eax
  00c33	8a 12		 mov	 dl, BYTE PTR [edx]
  00c35	88 50 ff	 mov	 BYTE PTR [eax-1], dl
  00c38	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00c3b	43		 inc	 ebx
  00c3c	49		 dec	 ecx
  00c3d	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00c40	75 ed		 jne	 SHORT $L69565
$L69567:

; 1059 : 
; 1060 :       break;
; 1061 :     }
; 1062 : 
; 1063 :     /******************************************************************/
; 1064 :     /*  Update the output position.                                   */
; 1065 :     /******************************************************************/
; 1066 : 
; 1067 :     pPipe->uiOutputPosition += uiNumberToRead;

  00c42	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00c45	03 c7		 add	 eax, edi
$L69748:

; 1068 :   }
; 1069 : 
; 1070 :   /********************************************************************/
; 1071 :   /*  Update the count of items in the pipe.                          */
; 1072 :   /********************************************************************/
; 1073 : 
; 1074 :   pPipe->uiCount -= uiNumberToRead;

  00c47	8b 7e 1c	 mov	 edi, DWORD PTR [esi+28]

; 1075 : 
; 1076 :   /********************************************************************/
; 1077 :   /*  Set the pipe not full condition.                                */
; 1078 :   /********************************************************************/
; 1079 : 
; 1080 : /* TQL 05/21/1997  change this for OSF build */
; 1081 : #ifdef WIN32
; 1082 :   SetEvent( pPipe->hNotFullEvent );

  00c4a	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00c4d	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00c50	8b 44 24 1c	 mov	 eax, DWORD PTR _uiNumberToRead$[esp+12]
  00c54	2b f8		 sub	 edi, eax
  00c56	51		 push	 ecx
  00c57	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00c5a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 1083 : #endif
; 1084 : #if defined (__osf__) || defined (__linux__)
; 1085 :   OP_SetEvent( pPipe->hNotFullEvent );
; 1086 : #endif
; 1087 : 
; 1088 :   /******************************************************************/
; 1089 :   /*  Free the pipe resource.                                       */
; 1090 :   /******************************************************************/
; 1091 : 
; 1092 : /* TQL 05/21/1997  change this for OSF build */
; 1093 : #ifdef WIN32
; 1094 :   LeaveCriticalSection( pPipe->pcsPipe );

  00c60	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00c63	52		 push	 edx
  00c64	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00c6a	5f		 pop	 edi
  00c6b	5e		 pop	 esi
  00c6c	5d		 pop	 ebp
  00c6d	5b		 pop	 ebx

; 1095 : #endif
; 1096 : #if defined (__osf__) || defined (__linux__)
; 1097 :   OP_UnlockMutex( pPipe->pcsPipe );
; 1098 : #endif
; 1099 : 
; 1100 :   return;
; 1101 : }

  00c6e	c3		 ret	 0
  00c6f	90		 npad	 1
$L69749:
  00c70	00 00 00 00	 DD	 $L69429
  00c74	00 00 00 00	 DD	 $L69440
  00c78	00 00 00 00	 DD	 $L69451
  00c7c	00 00 00 00	 DD	 $L69462
  00c80	00 00 00 00	 DD	 $L69473
  00c84	00 00 00 00	 DD	 $L69484
  00c88	00 00 00 00	 DD	 $L69495
$L69750:
  00c8c	00 00 00 00	 DD	 $L69522
  00c90	00 00 00 00	 DD	 $L69528
  00c94	00 00 00 00	 DD	 $L69534
  00c98	00 00 00 00	 DD	 $L69540
  00c9c	00 00 00 00	 DD	 $L69546
  00ca0	00 00 00 00	 DD	 $L69552
  00ca4	00 00 00 00	 DD	 $L69558
_read_pipe ENDP
_TEXT	ENDS
PUBLIC	_pause_pipe
_TEXT	SEGMENT
_pPipe$ = 8
_pause_pipe PROC NEAR

; 1127 : {

  00cb0	56		 push	 esi

; 1128 :   /********************************************************************/
; 1129 :   /*  Block if the pipe resource is busy.                             */
; 1130 :   /********************************************************************/
; 1131 :  /* check the pipe guards.. */
; 1132 : 
; 1133 : #ifndef __linux__
; 1134 :   assert ( ( pPipe->usGuard1 == GUARD1) 
; 1135 : 	  &&( pPipe->usGuard2 == GUARD2) );
; 1136 : #endif
; 1137 : 
; 1138 : /* TQL 05/21/1997  change this for OSF build */
; 1139 : #ifdef WIN32
; 1140 :   EnterCriticalSection( pPipe->pcsPipe );

  00cb1	8b 74 24 08	 mov	 esi, DWORD PTR _pPipe$[esp]
  00cb5	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00cb8	50		 push	 eax
  00cb9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1141 : #endif
; 1142 : #if defined (__osf__) || defined (__linux__)
; 1143 :   OP_LockMutex( pPipe->pcsPipe );
; 1144 : #endif
; 1145 : 
; 1146 :   /********************************************************************/
; 1147 :   /*  Go into the paused state.                                       */
; 1148 :   /********************************************************************/
; 1149 : 
; 1150 : /* TQL 05/21/1997  change this for OSF build */
; 1151 : #ifdef WIN32
; 1152 :   ResetEvent( pPipe->hNotPausedEvent );

  00cbf	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00cc2	51		 push	 ecx
  00cc3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResetEvent@4

; 1153 : #endif
; 1154 : #if defined (__osf__) || defined (__linux__)
; 1155 :   OP_ResetEvent( pPipe->hNotPausedEvent );
; 1156 : #endif
; 1157 : 
; 1158 :   pPipe->uiState = PIPE_PAUSE;
; 1159 : 
; 1160 :   /********************************************************************/
; 1161 :   /*  Free the pipe resource.                                         */
; 1162 :   /********************************************************************/
; 1163 : 
; 1164 : /* TQL 05/21/1997  change this for OSF build */
; 1165 : #ifdef WIN32
; 1166 :   LeaveCriticalSection( pPipe->pcsPipe );

  00cc9	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00ccc	c7 46 24 01 00
	00 00		 mov	 DWORD PTR [esi+36], 1
  00cd3	52		 push	 edx
  00cd4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00cda	5e		 pop	 esi

; 1167 : #endif
; 1168 : #if defined (__osf__) || defined (__linux__)
; 1169 :   OP_UnlockMutex( pPipe->pcsPipe );
; 1170 : #endif
; 1171 : 
; 1172 :   return;
; 1173 : }

  00cdb	c3		 ret	 0
_pause_pipe ENDP
_TEXT	ENDS
PUBLIC	_resume_pipe
_TEXT	SEGMENT
_pPipe$ = 8
_resume_pipe PROC NEAR

; 1199 : {

  00ce0	56		 push	 esi

; 1200 : 
; 1201 :  /* check the pipe guards.. */
; 1202 : #ifndef __linux__
; 1203 :   assert ( ( pPipe->usGuard1 == GUARD1) 
; 1204 : 	  &&( pPipe->usGuard2 == GUARD2) );
; 1205 : #endif
; 1206 : 
; 1207 : 
; 1208 :   /********************************************************************/
; 1209 :   /*  Block if the pipe resource is busy.                             */
; 1210 :   /********************************************************************/
; 1211 : 
; 1212 : /* TQL 05/21/1997  change this for OSF build */
; 1213 : #ifdef WIN32
; 1214 :   EnterCriticalSection( pPipe->pcsPipe );

  00ce1	8b 74 24 08	 mov	 esi, DWORD PTR _pPipe$[esp]
  00ce5	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00ce8	50		 push	 eax
  00ce9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1215 : #endif
; 1216 : #if defined (__osf__) || defined (__linux__)
; 1217 :   OP_LockMutex( pPipe->pcsPipe );
; 1218 : #endif
; 1219 : 
; 1220 :   /********************************************************************/
; 1221 :   /*  Get out of the paused state.                                    */
; 1222 :   /********************************************************************/
; 1223 : 
; 1224 : /* TQL 05/21/1997  change this for OSF build */
; 1225 : #ifdef WIN32
; 1226 :   SetEvent( pPipe->hNotPausedEvent );

  00cef	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00cf2	51		 push	 ecx
  00cf3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 1227 : #endif
; 1228 : #if defined (__osf__) || defined (__linux__)
; 1229 :   OP_SetEvent( pPipe->hNotPausedEvent );
; 1230 : #endif
; 1231 : 
; 1232 :   /********************************************************************/
; 1233 :   /*  Free the pipe resource.                                         */
; 1234 :   /********************************************************************/
; 1235 : 
; 1236 : /* TQL 05/21/1997  change this for OSF build */
; 1237 : #ifdef WIN32
; 1238 :   LeaveCriticalSection( pPipe->pcsPipe );

  00cf9	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00cfc	52		 push	 edx
  00cfd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00d03	5e		 pop	 esi

; 1239 : #endif
; 1240 : #if defined (__osf__) || defined (__linux__)
; 1241 :   OP_UnlockMutex( pPipe->pcsPipe );
; 1242 : #endif
; 1243 : 
; 1244 :   return;
; 1245 : }

  00d04	c3		 ret	 0
_resume_pipe ENDP
_TEXT	ENDS
PUBLIC	_exit_pipe
_TEXT	SEGMENT
_pPipe$ = 8
_exit_pipe PROC NEAR

; 1272 : {

  00d10	56		 push	 esi

; 1273 : 
; 1274 :  /* check the pipe guards.. */
; 1275 : #ifndef __linux__ 
; 1276 :   assert ( ( pPipe->usGuard1 == GUARD1) 
; 1277 : 	  &&( pPipe->usGuard2 == GUARD2) );
; 1278 : #endif
; 1279 : 
; 1280 : 
; 1281 :   /********************************************************************/
; 1282 :   /*  Block if the pipe resource is busy.                             */
; 1283 :   /********************************************************************/
; 1284 : 
; 1285 : /* TQL 05/21/1997  change this for OSF build */
; 1286 : #ifdef WIN32
; 1287 :   EnterCriticalSection( pPipe->pcsPipe );

  00d11	8b 74 24 08	 mov	 esi, DWORD PTR _pPipe$[esp]
  00d15	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00d18	50		 push	 eax
  00d19	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1288 : #endif
; 1289 : #if defined (__osf__) || defined (__linux__)
; 1290 :   OP_LockMutex( pPipe->pcsPipe );
; 1291 : #endif
; 1292 : 
; 1293 :   /********************************************************************/
; 1294 :   /*  Setup for thread exit on the next call to function read_pipe(). */
; 1295 :   /********************************************************************/
; 1296 : 
; 1297 :   pPipe->uiState = PIPE_EXIT;
; 1298 : 
; 1299 :   /********************************************************************/
; 1300 :   /*  Free the pipe resource.                                         */
; 1301 :   /********************************************************************/
; 1302 : 
; 1303 : /* TQL 05/21/1997  change this for OSF build */
; 1304 : #ifdef WIN32
; 1305 :   LeaveCriticalSection( pPipe->pcsPipe );

  00d1f	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00d22	c7 46 24 02 00
	00 00		 mov	 DWORD PTR [esi+36], 2
  00d29	51		 push	 ecx
  00d2a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00d30	5e		 pop	 esi

; 1306 : #endif
; 1307 : #if defined (__osf__) || defined (__linux__)
; 1308 :   OP_UnlockMutex( pPipe->pcsPipe );
; 1309 : #endif
; 1310 : 
; 1311 :   return;
; 1312 : }

  00d31	c3		 ret	 0
_exit_pipe ENDP
_TEXT	ENDS
PUBLIC	_reset_pipe
_TEXT	SEGMENT
_pPipe$ = 8
_reset_pipe PROC NEAR

; 1339 : {

  00d40	56		 push	 esi

; 1340 : 
; 1341 : 
; 1342 :   /********************************************************************/
; 1343 :   /*  Block if the pipe resource is busy.                             */
; 1344 :   /********************************************************************/
; 1345 : 
; 1346 : /* TQL 05/21/1997  change this for OSF build */
; 1347 : #ifdef WIN32
; 1348 :   EnterCriticalSection( pPipe->pcsPipe );

  00d41	8b 74 24 08	 mov	 esi, DWORD PTR _pPipe$[esp]
  00d45	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00d48	50		 push	 eax
  00d49	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1349 : #endif
; 1350 : #if defined (__osf__) || defined (__linux__)
; 1351 :   OP_LockMutex( pPipe->pcsPipe );
; 1352 : #endif
; 1353 : 
; 1354 :   /********************************************************************/
; 1355 :   /*  Initialize the pipe queue parameters.                           */
; 1356 :   /********************************************************************/
; 1357 : 
; 1358 :   pPipe->pInput = pPipe->pStart;

  00d4f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 1359 :   pPipe->pOutput = pPipe->pStart;
; 1360 :   pPipe->uiInputPosition = 0;
; 1361 :   pPipe->uiOutputPosition = 0;
; 1362 : 
; 1363 :   /********************************************************************/
; 1364 :   /*  Initialize the pipe state semaphores.                           */
; 1365 :   /********************************************************************/
; 1366 : 
; 1367 : /* TQL 05/21/1997  change this for OSF build */
; 1368 : #ifdef WIN32
; 1369 :   ResetEvent( pPipe->hNotEmptyEvent );

  00d52	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00d55	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00d58	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00d5b	33 c0		 xor	 eax, eax
  00d5d	51		 push	 ecx
  00d5e	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00d61	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00d64	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResetEvent@4

; 1370 : 
; 1371 :   SetEvent( pPipe->hNotFullEvent );

  00d6a	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00d6d	52		 push	 edx
  00d6e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 1372 : #endif
; 1373 : 
; 1374 : #if defined (__osf__) || defined (__linux__)
; 1375 :   OP_ResetEvent( pPipe->hNotEmptyEvent );
; 1376 : 
; 1377 :   OP_SetEvent( pPipe->hNotFullEvent );
; 1378 : #endif
; 1379 : 
; 1380 :   /********************************************************************/
; 1381 :   /*  Free the pipe resource.                                         */
; 1382 :   /********************************************************************/
; 1383 : 
; 1384 : /* TQL 05/21/1997  change this for OSF build */
; 1385 : #ifdef WIN32
; 1386 :   LeaveCriticalSection( pPipe->pcsPipe );

  00d74	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00d77	50		 push	 eax
  00d78	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00d7e	5e		 pop	 esi

; 1387 : #endif
; 1388 : #if defined (__osf__) || defined (__linux__)
; 1389 :   OP_UnlockMutex( pPipe->pcsPipe );
; 1390 : #endif
; 1391 : 
; 1392 :   return;
; 1393 : }

  00d7f	c3		 ret	 0
_reset_pipe ENDP
_TEXT	ENDS
PUBLIC	_destroy_pipe
_TEXT	SEGMENT
_pPipe$ = 8
_destroy_pipe PROC NEAR

; 1419 : {

  00d80	56		 push	 esi

; 1420 :  /* check the pipe guards.. */
; 1421 : 
; 1422 : #ifndef __linux__ 
; 1423 :   assert ( ( pPipe->usGuard1 == GUARD1) 
; 1424 : 	  &&( pPipe->usGuard2 == GUARD2) );
; 1425 : #endif
; 1426 : 
; 1427 :   /********************************************************************/
; 1428 :   /*  Delete the critical section object.                             */
; 1429 :   /********************************************************************/
; 1430 : 
; 1431 : /* TQL 05/21/1997  change this for OSF build */
; 1432 : #ifdef WIN32
; 1433 :   DeleteCriticalSection( pPipe->pcsPipe );

  00d81	8b 74 24 08	 mov	 esi, DWORD PTR _pPipe$[esp]
  00d85	57		 push	 edi
  00d86	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00d89	50		 push	 eax
  00d8a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 1434 : #endif
; 1435 : #if defined (__osf__) || defined (__linux__)
; 1436 :   OP_DestroyMutex( pPipe->pcsPipe );
; 1437 : #endif
; 1438 : 
; 1439 :   /********************************************************************/
; 1440 :   /*  Free the pipe state semaphores.                                 */
; 1441 :   /********************************************************************/
; 1442 : 
; 1443 : /* TQL 05/21/1997  change this for OSF build */
; 1444 : #ifdef WIN32
; 1445 :   CloseHandle( pPipe->hNotEmptyEvent );

  00d90	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00d93	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CloseHandle@4
  00d99	51		 push	 ecx
  00d9a	ff d7		 call	 edi

; 1446 : 
; 1447 :   CloseHandle( pPipe->hNotFullEvent );

  00d9c	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00d9f	52		 push	 edx
  00da0	ff d7		 call	 edi

; 1448 : #endif
; 1449 : #if defined (__osf__) || defined (__linux__)
; 1450 :   OP_DestroyEvent( pPipe->hNotEmptyEvent );
; 1451 : 
; 1452 :   OP_DestroyEvent( pPipe->hNotFullEvent );
; 1453 : #endif
; 1454 : 
; 1455 :   /********************************************************************/
; 1456 :   /*  Deallocate the pipe memory and the pipe structure.              */
; 1457 :   /********************************************************************/
; 1458 : 
; 1459 : /* TQL 05/21/1997  change this for OSF build */
; 1460 : #ifdef WIN32
; 1461 :   free( pPipe->pcsPipe );

  00da2	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00da5	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
  00dab	50		 push	 eax
  00dac	ff d7		 call	 edi

; 1462 : #endif
; 1463 : 
; 1464 :   free( pPipe->pStart );

  00dae	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00db1	51		 push	 ecx
  00db2	ff d7		 call	 edi

; 1465 : 
; 1466 :   free( pPipe );

  00db4	56		 push	 esi
  00db5	ff d7		 call	 edi
  00db7	83 c4 0c	 add	 esp, 12			; 0000000cH
  00dba	5f		 pop	 edi
  00dbb	5e		 pop	 esi

; 1467 : 
; 1468 :   return;
; 1469 : }

  00dbc	c3		 ret	 0
_destroy_pipe ENDP
_TEXT	ENDS
PUBLIC	_pipe_count
_TEXT	SEGMENT
_pPipe$ = 8
_pipe_count PROC NEAR

; 1495 : {

  00dc0	56		 push	 esi

; 1496 :   UINT uiCount;
; 1497 : 
; 1498 :   /********************************************************************/
; 1499 :   /*  Block if the pipe resource is busy.                             */
; 1500 :   /********************************************************************/
; 1501 : 
; 1502 : /* TQL 05/21/1997  change this for OSF build */
; 1503 : #ifdef WIN32
; 1504 :   EnterCriticalSection( pPipe->pcsPipe );

  00dc1	8b 74 24 08	 mov	 esi, DWORD PTR _pPipe$[esp]
  00dc5	57		 push	 edi
  00dc6	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00dc9	50		 push	 eax
  00dca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1505 : #endif
; 1506 : #if defined (__osf__) || defined (__linux__)
; 1507 :   OP_LockMutex( pPipe->pcsPipe );
; 1508 : #endif
; 1509 : 
; 1510 :   /********************************************************************/
; 1511 :   /*  Get the number of items in the pipe.                            */
; 1512 :   /********************************************************************/
; 1513 : 
; 1514 :   uiCount = pPipe->uiCount;
; 1515 : 
; 1516 :   /********************************************************************/
; 1517 :   /*  Free the pipe resource.                                         */
; 1518 :   /********************************************************************/
; 1519 : 
; 1520 : /* TQL 05/21/1997  change this for OSF build */
; 1521 : #ifdef WIN32
; 1522 :   LeaveCriticalSection( pPipe->pcsPipe );

  00dd0	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00dd3	8b 7e 1c	 mov	 edi, DWORD PTR [esi+28]
  00dd6	51		 push	 ecx
  00dd7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1523 : #endif
; 1524 : #if defined (__osf__) || defined (__linux__)
; 1525 :   OP_UnlockMutex( pPipe->pcsPipe );
; 1526 : #endif
; 1527 : 
; 1528 :   return( uiCount );

  00ddd	8b c7		 mov	 eax, edi
  00ddf	5f		 pop	 edi
  00de0	5e		 pop	 esi

; 1529 : }

  00de1	c3		 ret	 0
_pipe_count ENDP
_TEXT	ENDS
PUBLIC	_LockPipe
_TEXT	SEGMENT
_pPipe$ = 8
_LockPipe PROC NEAR

; 1535 : 
; 1536 : 
; 1537 :   /********************************************************************/
; 1538 :   /*  Block if the pipe resource is busy.                             */
; 1539 :   /********************************************************************/
; 1540 : 
; 1541 :   EnterCriticalSection( pPipe->pcsPipe );

  00df0	8b 44 24 04	 mov	 eax, DWORD PTR _pPipe$[esp-4]
  00df4	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00df7	51		 push	 ecx
  00df8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1542 : 
; 1543 : }

  00dfe	c3		 ret	 0
_LockPipe ENDP
_TEXT	ENDS
PUBLIC	_UnlockPipe
_TEXT	SEGMENT
_pPipe$ = 8
_UnlockPipe PROC NEAR

; 1546 : 
; 1547 : 
; 1548 :   /********************************************************************/
; 1549 :   /*  Free the pipe resource.                             */
; 1550 :   /********************************************************************/
; 1551 : 
; 1552 :   LeaveCriticalSection( pPipe->pcsPipe );

  00e00	8b 44 24 04	 mov	 eax, DWORD PTR _pPipe$[esp-4]
  00e04	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00e07	51		 push	 ecx
  00e08	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1553 : 
; 1554 : }

  00e0e	c3		 ret	 0
_UnlockPipe ENDP
_TEXT	ENDS
PUBLIC	_SWFlushPipe
_TEXT	SEGMENT
_pPipe$ = 8
_SWFlushPipe PROC NEAR

; 1558 : {

  00e10	56		 push	 esi

; 1559 : 
; 1560 : 
; 1561 :   /********************************************************************/
; 1562 :   /*  Flush out the pipe                                              */
; 1563 :   /********************************************************************/
; 1564 : /* TQL 05/21/1997  change this for OSF build */
; 1565 : #ifdef WIN32
; 1566 :   EnterCriticalSection( pPipe->pcsPipe );

  00e11	8b 74 24 08	 mov	 esi, DWORD PTR _pPipe$[esp]
  00e15	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00e18	50		 push	 eax
  00e19	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1567 : #endif
; 1568 : #if defined (__osf__) || defined (__linux__)
; 1569 :   OP_LockMutex( pPipe->pcsPipe );
; 1570 : #endif
; 1571 : 
; 1572 :   // reinitialize..
; 1573 : 
; 1574 :   pPipe->pInput = pPipe->pStart;

  00e1f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 1575 :   pPipe->pOutput = pPipe->pStart;
; 1576 :   pPipe->uiInputPosition = 0;
; 1577 :   pPipe->uiOutputPosition = 0;
; 1578 :   pPipe->uiCount = 0;
; 1579 : 
; 1580 : /* TQL 05/21/1997  change this for OSF build */
; 1581 : #ifdef WIN32
; 1582 :   ResetEvent( pPipe->hNotEmptyEvent );

  00e22	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00e25	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00e28	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00e2b	33 c0		 xor	 eax, eax
  00e2d	51		 push	 ecx
  00e2e	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00e31	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00e34	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  00e37	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResetEvent@4

; 1583 :   SetEvent( pPipe->hNotFullEvent );

  00e3d	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00e40	52		 push	 edx
  00e41	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 1584 :   LeaveCriticalSection( pPipe->pcsPipe );

  00e47	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00e4a	50		 push	 eax
  00e4b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00e51	5e		 pop	 esi

; 1585 : #endif
; 1586 : #if defined (__osf__) || defined (__linux__)
; 1587 :   OP_ResetEvent( pPipe->hNotEmptyEvent );
; 1588 :   OP_SetEvent( pPipe->hNotFullEvent );
; 1589 :   OP_UnlockMutex( pPipe->pcsPipe );
; 1590 : #endif
; 1591 : 
; 1592 : }

  00e52	c3		 ret	 0
_SWFlushPipe ENDP
_TEXT	ENDS
END
