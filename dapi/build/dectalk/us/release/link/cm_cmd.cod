	TITLE	D:\work\product\dapi\src\Cmd\cm_cmd.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_cm_cmd_match_comm
PUBLIC	_cm_cmd_do_command
PUBLIC	_cm_cmd_build_param
PUBLIC	_cm_cmd_error_comm
EXTRN	_total_commands:DWORD
EXTRN	_command_table:BYTE
EXTRN	_cm_pars_proc_char:NEAR
EXTRN	_cm_pars_new_state:NEAR
EXTRN	_par_lower:BYTE
_DATA	SEGMENT
$SG71185 DB	'index', 00H
	ORG $+2
$SG71199 DB	'index', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_c$ = 12
_save_index$ = -8
_cm_cmd_match_comm PROC NEAR

; 96   : {   

  00000	83 ec 08	 sub	 esp, 8

; 97   : 	int     i;  
; 98   : 	int		temp;
; 99   : 	int     save_matches, save_index;
; 100  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 101  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;
; 102  : 
; 103  : #ifdef DEBUGPARS
; 104  : 	printf("CMD_PARS: cm_cmd_match_comm:\n");
; 105  : #endif
; 106  : 	save_matches = pCmd_t->total_matches;
; 107  : 	save_index = pCmd_t->cmd_index;
; 108  : 	pCmd_t->pString[0] = NULL; // mfg initialize to NULL BATS#628
; 109  : 
; 110  : 	/*
; 111  :  	 *  space are either delimitors or are tossed ...
; 112  :  	 */
; 113  : 
; 114  : 	if(c == ' ' || c == '\t' || c == '\r' || c == '\n')

  00003	8b 4c 24 10	 mov	 ecx, DWORD PTR _c$[esp+4]
  00007	53		 push	 ebx
  00008	55		 push	 ebp
  00009	8b 6c 24 14	 mov	 ebp, DWORD PTR _phTTS$[esp+12]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 5d 0c	 mov	 ebx, DWORD PTR [ebp+12]
  00012	33 ff		 xor	 edi, edi
  00014	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00017	8b b3 e4 02 00
	00		 mov	 esi, DWORD PTR [ebx+740]
  0001d	8b 93 e8 02 00
	00		 mov	 edx, DWORD PTR [ebx+744]
  00023	89 74 24 14	 mov	 DWORD PTR -4+[esp+24], esi
  00027	89 54 24 10	 mov	 DWORD PTR _save_index$[esp+24], edx
  0002b	89 bb 80 02 00
	00		 mov	 DWORD PTR [ebx+640], edi
  00031	0f 84 72 01 00
	00		 je	 $L71182
  00037	83 f9 09	 cmp	 ecx, 9
  0003a	0f 84 69 01 00
	00		 je	 $L71182
  00040	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  00043	0f 84 60 01 00
	00		 je	 $L71182
  00049	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0004c	0f 84 57 01 00
	00		 je	 $L71182

; 157  : #ifdef DEBUGPARS
; 158  : 		printf("CMD_PARS: cm_cmd_match_comm: Parse State Switch: STATE_COMMAND->STATE_TOSS\n");
; 159  : #endif
; 160  : 			}
; 161  : 		}
; 162  : 		return;
; 163  : 	}
; 164  : 	(pCmd_t->p_count) += 1;

  00052	8b 83 d4 02 00
	00		 mov	 eax, DWORD PTR [ebx+724]
  00058	40		 inc	 eax

; 165  : 
; 166  : 	/*
; 167  :  	 *  is this an exit to command mode ...
; 168  :  	 */
; 169  : 
; 170  : 	if(c == ']')

  00059	83 f9 5d	 cmp	 ecx, 93			; 0000005dH
  0005c	89 83 d4 02 00
	00		 mov	 DWORD PTR [ebx+724], eax
  00062	75 43		 jne	 SHORT $L71188

; 171  : 	{
; 172  : 		/* point 2 for commands single words */
; 173  : 		/* if it not an index command, force the buffer clause buffer to be cleared */
; 174  : 		/* by sending a 0x0fff to it*/
; 175  : #ifdef NEW_INDEXING
; 176  : //		printf("not index command 3\n");
; 177  : 	 	temp=pCmd_t->ParseChar;     

  00064	33 f6		 xor	 esi, esi

; 178  : 	 	pCmd_t->ParseChar=0x0fff;
; 179  : /*	0010	MGS		11/19/1998		BATS #812 fixed say-letter mode extra spaces */
; 180  : 		pCmd_t->letter_mode_flag=1;
; 181  : 		cm_pars_proc_char(phTTS,' ');

  00066	6a 20		 push	 32			; 00000020H
  00068	66 8b b3 1c 05
	00 00		 mov	 si, WORD PTR [ebx+1308]
  0006f	55		 push	 ebp
  00070	66 c7 83 1c 05
	00 00 ff 0f	 mov	 WORD PTR [ebx+1308], 4095 ; 00000fffH
  00079	66 c7 83 8c 57
	00 00 01 00	 mov	 WORD PTR [ebx+22412], 1
  00082	e8 00 00 00 00	 call	 _cm_pars_proc_char

; 182  : 		pCmd_t->letter_mode_flag=0;
; 183  : 	 	pCmd_t->ParseChar=temp;
; 184  : #endif
; 185  : 		cm_cmd_do_command(phTTS, STATE_NORMAL);

  00087	57		 push	 edi
  00088	55		 push	 ebp
  00089	66 89 bb 8c 57
	00 00		 mov	 WORD PTR [ebx+22412], di
  00090	66 89 b3 1c 05
	00 00		 mov	 WORD PTR [ebx+1308], si
  00097	e8 00 00 00 00	 call	 _cm_cmd_do_command
  0009c	83 c4 10	 add	 esp, 16			; 00000010H
  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi
  000a1	5d		 pop	 ebp
  000a2	5b		 pop	 ebx

; 256  : #ifdef DEBUGPARS
; 257  : 		printf("CMD_PARS: cm_cmd_match_comm: Parse State Switch: STATE_COMMAND->STATE_PARAM\n");
; 258  : #endif
; 259  : 		}
; 260  : 	}
; 261  : }

  000a3	83 c4 08	 add	 esp, 8
  000a6	c3		 ret	 0
$L71188:

; 186  : #ifdef DEBUGPARS
; 187  : 		printf("CMD_PARS: cm_cmd_match_comm: Parse State Switch: STATE_COMMAND->STATE_NORMAL\n");
; 188  : #endif
; 189  : 		return;
; 190  : 	}
; 191  : 
; 192  : 	/*
; 193  : 	 *  if were trying to match up things here ...
; 194  : 	 */
; 195  : 
; 196  : 	for(i = 0; i < total_commands; i++)

  000a7	39 3d 00 00 00
	00		 cmp	 DWORD PTR _total_commands, edi
  000ad	7e 67		 jle	 SHORT $L71191
  000af	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR 8+[esp+20], OFFSET FLAT:_command_table
$L71189:
  000b7	8b 83 e0 02 00
	00		 mov	 eax, DWORD PTR [ebx+736]
  000bd	8d 34 b8	 lea	 esi, DWORD PTR [eax+edi*4]

; 197  : 	{
; 198  : 		if(*(pCmd_t->cm +i) != 0xffff)                             

  000c0	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  000c3	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  000c8	74 2f		 je	 SHORT $L71190

; 199  : 		{
; 200  :             if(CT[i].c_name[*(pCmd_t->cm +i)] == par_lower[c])

  000ca	8b 54 24 1c	 mov	 edx, DWORD PTR 8+[esp+20]
  000ce	8b 12		 mov	 edx, DWORD PTR [edx]
  000d0	8a 14 02	 mov	 dl, BYTE PTR [edx+eax]
  000d3	3a 91 00 00 00
	00		 cmp	 dl, BYTE PTR _par_lower[ecx]
  000d9	75 0b		 jne	 SHORT $L71193

; 201  : 			{
; 202  : 				*(pCmd_t->cm +i) += 1;

  000db	40		 inc	 eax
  000dc	89 06		 mov	 DWORD PTR [esi], eax

; 203  : 				pCmd_t->cmd_index = i;

  000de	89 bb e8 02 00
	00		 mov	 DWORD PTR [ebx+744], edi

; 204  : 			}
; 205  : 			else

  000e4	eb 13		 jmp	 SHORT $L71190
$L71193:

; 206  : 			{
; 207  : 				pCmd_t->total_matches -= 1;

  000e6	8b 83 e4 02 00
	00		 mov	 eax, DWORD PTR [ebx+740]
  000ec	48		 dec	 eax
  000ed	89 83 e4 02 00
	00		 mov	 DWORD PTR [ebx+740], eax

; 208  : 				*(pCmd_t->cm +i) = 0xffff;

  000f3	c7 06 ff ff 00
	00		 mov	 DWORD PTR [esi], 65535	; 0000ffffH
$L71190:
  000f9	8b 54 24 1c	 mov	 edx, DWORD PTR 8+[esp+20]
  000fd	a1 00 00 00 00	 mov	 eax, DWORD PTR _total_commands
  00102	47		 inc	 edi
  00103	83 c2 14	 add	 edx, 20			; 00000014H
  00106	3b f8		 cmp	 edi, eax
  00108	89 54 24 1c	 mov	 DWORD PTR 8+[esp+20], edx
  0010c	7c a9		 jl	 SHORT $L71189
  0010e	8b 54 24 10	 mov	 edx, DWORD PTR _save_index$[esp+24]
  00112	8b 74 24 14	 mov	 esi, DWORD PTR -4+[esp+24]
$L71191:

; 209  : 			}
; 210  : 		}
; 211  : 	}
; 212  : 	if(pCmd_t->total_matches == 0)

  00116	8b 83 e4 02 00
	00		 mov	 eax, DWORD PTR [ebx+740]
  0011c	85 c0		 test	 eax, eax
  0011e	0f 85 fc 00 00
	00		 jne	 $L71187

; 213  : 	{
; 214  : 		if(save_matches != 1)

  00124	b8 01 00 00 00	 mov	 eax, 1
  00129	3b f0		 cmp	 esi, eax

; 215  : 		{
; 216  : 			/* send 0x0fff to the parser */
; 217  : 			
; 218  : #ifdef NEW_INDEXING
; 219  : //			printf("not index command 4\n");
; 220  : 		 	temp=pCmd_t->ParseChar; 
; 221  : 		 	pCmd_t->ParseChar=0x0fff;
; 222  : /*	0010	MGS		11/19/1998		BATS #812 fixed say-letter mode extra spaces */
; 223  : 			pCmd_t->letter_mode_flag=1;
; 224  : 	 		cm_pars_proc_char(phTTS,' ');
; 225  : 			pCmd_t->letter_mode_flag=0;
; 226  : 		 	pCmd_t->ParseChar=temp;
; 227  : #endif
; 228  : 			cm_cmd_error_comm(phTTS, CMD_bad_command);
; 229  : 			cm_pars_new_state(pCmd_t, STATE_TOSS);
; 230  : #ifdef DEBUGPARS
; 231  : 		printf("CMD_PARS: cm_cmd_match_comm: Parse State Switch: STATE_COMMAND->STATE_TOSS\n");
; 232  : #endif
; 233  : 		}
; 234  : 		else

  0012b	0f 85 ab 00 00
	00		 jne	 $L71351

; 235  : 		{
; 236  : 			pCmd_t->total_matches = save_matches;
; 237  : 			pCmd_t->cmd_index = save_index;    

  00131	89 93 e8 02 00
	00		 mov	 DWORD PTR [ebx+744], edx

; 238  : 			/* point 3 for index commands */
; 239  : 			/* if it not an index command, force the buffer clause buffer to be cleared */
; 240  : 			/* by sending a 0x0fff to it*/
; 241  : #ifdef NEW_INDEXING
; 242  : 			if (memcmp(CT[pCmd_t->cmd_index].c_name,"index",5)!=0)

  00137	8d 14 92	 lea	 edx, DWORD PTR [edx+edx*4]
  0013a	89 83 e4 02 00
	00		 mov	 DWORD PTR [ebx+740], eax
  00140	b9 05 00 00 00	 mov	 ecx, 5
  00145	8b 34 95 00 00
	00 00		 mov	 esi, DWORD PTR _command_table[edx*4]
  0014c	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:$SG71199
  00151	33 d2		 xor	 edx, edx
  00153	f3 a6		 repe cmpsb
  00155	74 34		 je	 SHORT $L71184
$L71352:

; 243  : 			{
; 244  : //				printf("not index command 5\n");
; 245  : 			 	temp=pCmd_t->ParseChar; 

  00157	33 f6		 xor	 esi, esi

; 246  : 			 	pCmd_t->ParseChar=0x0fff;
; 247  : /*	0010	MGS		11/19/1998		BATS #812 fixed say-letter mode extra spaces */
; 248  : 				pCmd_t->letter_mode_flag=1;
; 249  : 		 		cm_pars_proc_char(phTTS,' ');

  00159	6a 20		 push	 32			; 00000020H
  0015b	66 8b b3 1c 05
	00 00		 mov	 si, WORD PTR [ebx+1308]
  00162	55		 push	 ebp
  00163	66 c7 83 1c 05
	00 00 ff 0f	 mov	 WORD PTR [ebx+1308], 4095 ; 00000fffH
  0016c	66 89 83 8c 57
	00 00		 mov	 WORD PTR [ebx+22412], ax
  00173	e8 00 00 00 00	 call	 _cm_pars_proc_char
  00178	83 c4 08	 add	 esp, 8

; 250  : 				pCmd_t->letter_mode_flag=0;

  0017b	66 c7 83 8c 57
	00 00 00 00	 mov	 WORD PTR [ebx+22412], 0

; 251  : 			 	pCmd_t->ParseChar=temp;

  00184	66 89 b3 1c 05
	00 00		 mov	 WORD PTR [ebx+1308], si
$L71184:

; 252  : 			}			 	
; 253  : #endif
; 254  : 			cm_pars_new_state(pCmd_t, STATE_PARAM);

  0018b	6a 04		 push	 4
  0018d	53		 push	 ebx
  0018e	e8 00 00 00 00	 call	 _cm_pars_new_state

; 255  : 			cm_cmd_build_param(phTTS, c);

  00193	8b 44 24 28	 mov	 eax, DWORD PTR _c$[esp+28]
  00197	50		 push	 eax
  00198	55		 push	 ebp
  00199	e8 00 00 00 00	 call	 _cm_cmd_build_param
  0019e	83 c4 10	 add	 esp, 16			; 00000010H
  001a1	5f		 pop	 edi
  001a2	5e		 pop	 esi
  001a3	5d		 pop	 ebp
  001a4	5b		 pop	 ebx

; 256  : #ifdef DEBUGPARS
; 257  : 		printf("CMD_PARS: cm_cmd_match_comm: Parse State Switch: STATE_COMMAND->STATE_PARAM\n");
; 258  : #endif
; 259  : 		}
; 260  : 	}
; 261  : }

  001a5	83 c4 08	 add	 esp, 8
  001a8	c3		 ret	 0
$L71182:

; 115  : 	{
; 116  : 		if(pCmd_t->total_matches == 1)

  001a9	b8 01 00 00 00	 mov	 eax, 1
  001ae	3b f0		 cmp	 esi, eax
  001b0	75 22		 jne	 SHORT $L71183

; 117  : 		{
; 118  : 			/* point 1 for the index command */
; 119  : 			/* if it not an index command, force the buffer clause buffer to be cleared */
; 120  : 			/* by sending a 0x0fff to it*/     
; 121  : #ifdef NEW_INDEXING
; 122  : 			if (memcmp(CT[pCmd_t->cmd_index].c_name,"index",5)!=0)

  001b2	8b 93 e8 02 00
	00		 mov	 edx, DWORD PTR [ebx+744]
  001b8	b9 05 00 00 00	 mov	 ecx, 5
  001bd	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:$SG71185
  001c2	8d 14 92	 lea	 edx, DWORD PTR [edx+edx*4]
  001c5	8b 34 95 00 00
	00 00		 mov	 esi, DWORD PTR _command_table[edx*4]
  001cc	33 d2		 xor	 edx, edx
  001ce	f3 a6		 repe cmpsb
  001d0	74 b9		 je	 SHORT $L71184

; 123  : 			{   
; 124  : //				printf("not index command 1\n");
; 125  : 			 	temp=pCmd_t->ParseChar; 
; 126  : 			 	pCmd_t->ParseChar=0x0fff;
; 127  : /*	0010	MGS		11/19/1998		BATS #812 fixed say-letter mode extra spaces */
; 128  : 				pCmd_t->letter_mode_flag=1;
; 129  : 			 	cm_pars_proc_char(phTTS,' ');
; 130  : 				pCmd_t->letter_mode_flag=0;
; 131  : 			 	pCmd_t->ParseChar=temp;
; 132  : 			}			 	
; 133  : #endif
; 134  : 			cm_pars_new_state(pCmd_t, STATE_PARAM);
; 135  : 			cm_cmd_build_param(phTTS, c);
; 136  : #ifdef DEBUGPARS
; 137  : 		printf("CMD_PARS: cm_cmd_match_comm: Parse State Switch: STATE_COMMAND->STATE_PARAM\n");
; 138  : #endif
; 139  : 		}
; 140  : 		else 

  001d2	eb 83		 jmp	 SHORT $L71352
$L71183:

; 141  : 		{
; 142  : 			if(pCmd_t->p_count != 0)

  001d4	39 bb d4 02 00
	00		 cmp	 DWORD PTR [ebx+724], edi
  001da	74 44		 je	 SHORT $L71187
$L71351:

; 143  : 			{                       
; 144  : 				/* send 0x0fff to the parser */
; 145  : #ifdef NEW_INDEXING
; 146  : //				printf("not index command 2\n");
; 147  : 			 	temp=pCmd_t->ParseChar; 

  001dc	33 f6		 xor	 esi, esi

; 148  : 			 	pCmd_t->ParseChar=0x0fff;
; 149  : /*	0010	MGS		11/19/1998		BATS #812 fixed say-letter mode extra spaces */
; 150  : 				pCmd_t->letter_mode_flag=1;
; 151  : 		 		cm_pars_proc_char(phTTS,' ');

  001de	6a 20		 push	 32			; 00000020H
  001e0	66 8b b3 1c 05
	00 00		 mov	 si, WORD PTR [ebx+1308]
  001e7	55		 push	 ebp
  001e8	66 c7 83 1c 05
	00 00 ff 0f	 mov	 WORD PTR [ebx+1308], 4095 ; 00000fffH
  001f1	66 89 83 8c 57
	00 00		 mov	 WORD PTR [ebx+22412], ax
  001f8	e8 00 00 00 00	 call	 _cm_pars_proc_char

; 152  : 				pCmd_t->letter_mode_flag=0;
; 153  : 			 	pCmd_t->ParseChar=temp;
; 154  : #endif
; 155  : 				cm_cmd_error_comm(phTTS, CMD_bad_command);

  001fd	6a 03		 push	 3
  001ff	55		 push	 ebp
  00200	66 c7 83 8c 57
	00 00 00 00	 mov	 WORD PTR [ebx+22412], 0
  00209	66 89 b3 1c 05
	00 00		 mov	 WORD PTR [ebx+1308], si
  00210	e8 00 00 00 00	 call	 _cm_cmd_error_comm

; 156  : 				cm_pars_new_state(pCmd_t, STATE_TOSS);

  00215	6a 05		 push	 5
  00217	53		 push	 ebx
  00218	e8 00 00 00 00	 call	 _cm_pars_new_state
  0021d	83 c4 18	 add	 esp, 24			; 00000018H
$L71187:
  00220	5f		 pop	 edi
  00221	5e		 pop	 esi
  00222	5d		 pop	 ebp
  00223	5b		 pop	 ebx

; 256  : #ifdef DEBUGPARS
; 257  : 		printf("CMD_PARS: cm_cmd_match_comm: Parse State Switch: STATE_COMMAND->STATE_PARAM\n");
; 258  : #endif
; 259  : 		}
; 260  : 	}
; 261  : }

  00224	83 c4 08	 add	 esp, 8
  00227	c3		 ret	 0
_cm_cmd_match_comm ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_reset_comm
_TEXT	SEGMENT
_phTTS$ = 8
_new_state$ = 12
_cm_cmd_do_command PROC NEAR

; 279  : {

  00230	56		 push	 esi
  00231	57		 push	 edi

; 280  : 	int err_value;
; 281  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00232	8b 7c 24 0c	 mov	 edi, DWORD PTR _phTTS$[esp+4]
  00236	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]

; 282  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;
; 283  : 	
; 284  : #ifdef DEBUGPARS
; 285  : 	printf("CMD_PARS: cm_cmd_do_command:\n");
; 286  : #endif
; 287  : 	if(pCmd_t->total_matches == 1)

  00239	83 be e4 02 00
	00 01		 cmp	 DWORD PTR [esi+740], 1
  00240	75 4a		 jne	 SHORT $L71212

; 288  : 	{                                   
; 289  : 		err_value  = CT[pCmd_t->cmd_index].c_routine(phTTS);

  00242	8b 86 e8 02 00
	00		 mov	 eax, DWORD PTR [esi+744]
  00248	57		 push	 edi
  00249	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0024c	ff 14 85 10 00
	00 00		 call	 DWORD PTR _command_table[eax*4+16]
  00253	83 c4 04	 add	 esp, 4

; 290  : 		if(err_value == CMD_success)

  00256	85 c0		 test	 eax, eax
  00258	75 11		 jne	 SHORT $L71209

; 291  : 		{
; 292  : 			cm_cmd_reset_comm(pCmd_t, new_state);

  0025a	8b 4c 24 10	 mov	 ecx, DWORD PTR _new_state$[esp+4]
  0025e	51		 push	 ecx

; 327  : 	else
; 328  : 		cm_cmd_reset_comm(pCmd_t, STATE_TOSS);

  0025f	56		 push	 esi
  00260	e8 00 00 00 00	 call	 _cm_cmd_reset_comm
  00265	83 c4 08	 add	 esp, 8
  00268	5f		 pop	 edi
  00269	5e		 pop	 esi

; 329  : #ifdef DEBUGPARS
; 330  : 		printf("CMD_PARS: cm_cmd_do_command: Parse State Switch: STATE_?->STATE_TOSS\n");
; 331  : #endif
; 332  : }

  0026a	c3		 ret	 0
$L71209:

; 293  : #ifdef DEBUGPARS
; 294  : 		printf("CMD_PARS: cm_cmd_do_command: Parse State Switch: STATE_?->STATE_new?\n");
; 295  : #endif
; 296  : 			return;
; 297  : 		}
; 298  : 		else 
; 299  : 		{
; 300  : 			if(err_value == CMD_flushing)

  0026b	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0026e	75 19		 jne	 SHORT $L71211

; 301  : 			{
; 302  : 				cm_cmd_reset_comm(pCmd_t, STATE_NORMAL);

  00270	6a 00		 push	 0
  00272	56		 push	 esi
  00273	e8 00 00 00 00	 call	 _cm_cmd_reset_comm

; 303  : #ifdef DEBUGPARS
; 304  : 		printf("CMD_PARS: cm_cmd_do_command: Parse State Switch: STATE_?->STATE_NORMAL\n");
; 305  : #endif
; 306  : 				pCmd_t->esc_seq->type = 0;

  00278	8b 96 18 05 00
	00		 mov	 edx, DWORD PTR [esi+1304]
  0027e	83 c4 08	 add	 esp, 8
  00281	5f		 pop	 edi
  00282	66 c7 02 00 00	 mov	 WORD PTR [edx], 0
  00287	5e		 pop	 esi

; 329  : #ifdef DEBUGPARS
; 330  : 		printf("CMD_PARS: cm_cmd_do_command: Parse State Switch: STATE_?->STATE_TOSS\n");
; 331  : #endif
; 332  : }

  00288	c3		 ret	 0
$L71211:

; 307  : 				/* ...tek 11/6 this needs a return statement. */
; 308  : 				return;
; 309  : 				}
; 310  : 			else
; 311  : 			{
; 312  : 				cm_cmd_error_comm(phTTS, err_value);

  00289	50		 push	 eax

; 313  : 				if (pCmd_t->ParseChar == ']')
; 314  : 					cm_cmd_reset_comm(pCmd_t, STATE_NORMAL);
; 315  : 				else

  0028a	eb 02		 jmp	 SHORT $L71355
$L71212:

; 316  : 					cm_cmd_reset_comm(pCmd_t, STATE_TOSS);
; 317  : #ifdef DEBUGPARS
; 318  : 		printf("CMD_PARS: cm_cmd_do_command: Parse State Switch: STATE_?->STATE_TOSS\n");
; 319  : #endif
; 320  : 				return;
; 321  : 			}
; 322  : 		}
; 323  : 	}
; 324  : 	cm_cmd_error_comm(phTTS, CMD_bad_command);

  0028c	6a 03		 push	 3
$L71355:
  0028e	57		 push	 edi
  0028f	e8 00 00 00 00	 call	 _cm_cmd_error_comm
  00294	83 c4 08	 add	 esp, 8

; 325  : 	if (pCmd_t->ParseChar == ']')

  00297	66 83 be 1c 05
	00 00 5d	 cmp	 WORD PTR [esi+1308], 93	; 0000005dH
  0029f	75 0e		 jne	 SHORT $L71213

; 326  : 		cm_cmd_reset_comm(pCmd_t, STATE_NORMAL);

  002a1	6a 00		 push	 0

; 327  : 	else
; 328  : 		cm_cmd_reset_comm(pCmd_t, STATE_TOSS);

  002a3	56		 push	 esi
  002a4	e8 00 00 00 00	 call	 _cm_cmd_reset_comm
  002a9	83 c4 08	 add	 esp, 8
  002ac	5f		 pop	 edi
  002ad	5e		 pop	 esi

; 329  : #ifdef DEBUGPARS
; 330  : 		printf("CMD_PARS: cm_cmd_do_command: Parse State Switch: STATE_?->STATE_TOSS\n");
; 331  : #endif
; 332  : }

  002ae	c3		 ret	 0
$L71213:

; 327  : 	else
; 328  : 		cm_cmd_reset_comm(pCmd_t, STATE_TOSS);

  002af	6a 05		 push	 5
  002b1	56		 push	 esi
  002b2	e8 00 00 00 00	 call	 _cm_cmd_reset_comm
  002b7	83 c4 08	 add	 esp, 8
  002ba	5f		 pop	 edi
  002bb	5e		 pop	 esi

; 329  : #ifdef DEBUGPARS
; 330  : 		printf("CMD_PARS: cm_cmd_do_command: Parse State Switch: STATE_?->STATE_TOSS\n");
; 331  : #endif
; 332  : }

  002bc	c3		 ret	 0
_cm_cmd_do_command ENDP
_TEXT	ENDS
_DATA	SEGMENT
	ORG $+2
$SG71292 DB	'index', 00H
	ORG $+2
$SG71296 DB	'index', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_c$ = 12
_cm_cmd_build_param PROC NEAR

; 351  : {

  002c0	53		 push	 ebx
  002c1	55		 push	 ebp

; 352  : #ifdef DEBUGPARS
; 353  : 	int i,j;
; 354  : #endif
; 355  : 	int temp;
; 356  :    	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  002c2	8b 6c 24 0c	 mov	 ebp, DWORD PTR _phTTS$[esp+4]
  002c6	56		 push	 esi
  002c7	57		 push	 edi
  002c8	8b 5d 0c	 mov	 ebx, DWORD PTR [ebp+12]

; 357  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;
; 358  : 	/*
; 359  : 	 *  first, if we get here and there are no more parameters needed ...
; 360  : 	 */
; 361  : #ifdef DEBUGPARS
; 362  : 	/* printf("\nbuild_param;cmd_index=%d params[param_index]=%d",pCmd_t->cmd_index,pCmd_t->params[pCmd_t->param_index]);*/
; 363  :     /* printf("\nbuild_param;param_index=%d format_index=%d ",pCmd_t->param_index,pCmd_t->format_index);*/
; 364  :     /* printf(".");*/
; 365  : #endif
; 366  : 	/*
; 367  : 	 * FORMAT_PARAM contains the string which is found
; 368  :      * in the "format_index" entry in the command table.
; 369  :      */
; 370  : 	if (FORMAT_PARAM == 0)

  002cb	8b 83 e8 02 00
	00		 mov	 eax, DWORD PTR [ebx+744]
  002d1	8b 93 f4 04 00
	00		 mov	 edx, DWORD PTR [ebx+1268]
  002d7	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  002da	8b 0c 85 04 00
	00 00		 mov	 ecx, DWORD PTR _command_table[eax*4+4]
  002e1	8a 04 11	 mov	 al, BYTE PTR [ecx+edx]
  002e4	33 d2		 xor	 edx, edx
  002e6	3a c2		 cmp	 al, dl
  002e8	75 10		 jne	 SHORT $L71225
$L71242:

; 371  : 	{
; 372  : 		cm_cmd_do_command(phTTS, STATE_BRACKET);

  002ea	6a 01		 push	 1
  002ec	55		 push	 ebp
  002ed	e8 00 00 00 00	 call	 _cm_cmd_do_command
  002f2	83 c4 08	 add	 esp, 8
  002f5	5f		 pop	 edi
  002f6	5e		 pop	 esi
  002f7	5d		 pop	 ebp
  002f8	5b		 pop	 ebx

; 701  : #ifdef DEBUGPARS                                     
; 702  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_TOSS\n");
; 703  : #endif
; 704  : 			break;
; 705  : 	}       /* End switch (c) */
; 706  : }

  002f9	c3		 ret	 0
$L71225:

; 373  : #ifdef DEBUGPARS
; 374  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_BRACKET\n");
; 375  : #endif
; 376  : 		return;
; 377  : 	}
; 378  : 
; 379  : 	/*
; 380  : 	 *  allow continuous execution of some commands  ...
; 381  : 	 */
; 382  : 	if(FORMAT_PARAM == '*')

  002fa	3c 2a		 cmp	 al, 42			; 0000002aH
  002fc	8b 44 24 18	 mov	 eax, DWORD PTR _c$[esp+12]
  00300	75 53		 jne	 SHORT $L71226

; 383  : 	{
; 384  : 		if(c == ':')

  00302	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00305	75 10		 jne	 SHORT $L71227
$L71241:

; 385  : 		{
; 386  : 			cm_cmd_do_command(phTTS, STATE_COMMAND);

  00307	6a 02		 push	 2
  00309	55		 push	 ebp
  0030a	e8 00 00 00 00	 call	 _cm_cmd_do_command
  0030f	83 c4 08	 add	 esp, 8
  00312	5f		 pop	 edi
  00313	5e		 pop	 esi
  00314	5d		 pop	 ebp
  00315	5b		 pop	 ebx

; 701  : #ifdef DEBUGPARS                                     
; 702  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_TOSS\n");
; 703  : #endif
; 704  : 			break;
; 705  : 	}       /* End switch (c) */
; 706  : }

  00316	c3		 ret	 0
$L71227:

; 387  : #ifdef DEBUGPARS
; 388  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_COMMAND\n");
; 389  : #endif
; 390  : 			return;
; 391  : 		}
; 392  : 		if(c == ' ' || c == '\t' || c == '\r' || c == '\n')

  00317	83 f8 20	 cmp	 eax, 32			; 00000020H
  0031a	0f 84 a3 03 00
	00		 je	 $L71229
  00320	83 f8 09	 cmp	 eax, 9
  00323	0f 84 9a 03 00
	00		 je	 $L71229
  00329	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  0032c	0f 84 91 03 00
	00		 je	 $L71229
  00332	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00335	0f 84 88 03 00
	00		 je	 $L71229

; 393  : 		{
; 394  : 			cm_cmd_do_command(phTTS, STATE_KEEP);
; 395  : #ifdef DEBUGPARS
; 396  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_KEEP\n");
; 397  : #endif
; 398  : 			return;
; 399  : 		}
; 400  : 		if(c == ']')

  0033b	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  0033e	75 0f		 jne	 SHORT $L71230
$L71293:

; 401  : 		{
; 402  : 			cm_cmd_do_command(phTTS, STATE_NORMAL);

  00340	52		 push	 edx
  00341	55		 push	 ebp
  00342	e8 00 00 00 00	 call	 _cm_cmd_do_command
  00347	83 c4 08	 add	 esp, 8
  0034a	5f		 pop	 edi
  0034b	5e		 pop	 esi
  0034c	5d		 pop	 ebp
  0034d	5b		 pop	 ebx

; 701  : #ifdef DEBUGPARS                                     
; 702  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_TOSS\n");
; 703  : #endif
; 704  : 			break;
; 705  : 	}       /* End switch (c) */
; 706  : }

  0034e	c3		 ret	 0
$L71230:

; 403  : #ifdef DEBUGPARS
; 404  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_NORMAL\n");
; 405  : #endif
; 406  : 			return;
; 407  : 		}
; 408  : 		(pCmd_t->format_index) = 0;

  0034f	89 93 f4 04 00
	00		 mov	 DWORD PTR [ebx+1268], edx
$L71226:

; 409  : 	}
; 410  : 
; 411  : 	/*
; 412  :  	 *  on the first character for this paramater, init the value, or squeeze
; 413  :  	 *  out leading spaces or ...
; 414  :  	 */
; 415  : 
; 416  : 	if(pCmd_t->p_count == 0)

  00355	39 93 d4 02 00
	00		 cmp	 DWORD PTR [ebx+724], edx
  0035b	0f 85 a2 00 00
	00		 jne	 $L71245

; 417  : 	{
; 418  : 		CURR_PARAM = 0;

  00361	8b 8b d0 02 00
	00		 mov	 ecx, DWORD PTR [ebx+720]
  00367	89 14 8b	 mov	 DWORD PTR [ebx+ecx*4], edx

; 419  : 		CURR_DEFAULT = TRUE;

  0036a	8b 8b d0 02 00
	00		 mov	 ecx, DWORD PTR [ebx+720]
  00370	c7 84 8b a8 02
	00 00 01 00 00
	00		 mov	 DWORD PTR [ebx+ecx*4+680], 1

; 420  : 		
; 421  : 		if(pCmd_t->q_flag == 0 || FORMAT_PARAM != 'a')

  0037b	8b bb dc 02 00
	00		 mov	 edi, DWORD PTR [ebx+732]
  00381	3b fa		 cmp	 edi, edx
  00383	74 1c		 je	 SHORT $L71233
  00385	8b 8b e8 02 00
	00		 mov	 ecx, DWORD PTR [ebx+744]
  0038b	8b b3 f4 04 00
	00		 mov	 esi, DWORD PTR [ebx+1268]
  00391	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  00394	8b 0c 8d 04 00
	00 00		 mov	 ecx, DWORD PTR _command_table[ecx*4+4]
  0039b	80 3c 31 61	 cmp	 BYTE PTR [ecx+esi], 97	; 00000061H
  0039f	74 36		 je	 SHORT $L71235
$L71233:

; 422  : 		{
; 423  : 			switch(c)       
; 424  : 			{

  003a1	8d 70 f7	 lea	 esi, DWORD PTR [eax-9]
  003a4	83 fe 54	 cmp	 esi, 84			; 00000054H
  003a7	77 2e		 ja	 SHORT $L71235
  003a9	33 c9		 xor	 ecx, ecx
  003ab	8a 8e 00 00 00
	00		 mov	 cl, BYTE PTR $L71368[esi]
  003b1	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L71369[ecx*4]
$L71238:

; 425  : 				case ',':
; 426  : 					(pCmd_t->param_index) += 1;

  003b8	8b 8b d0 02 00
	00		 mov	 ecx, DWORD PTR [ebx+720]

; 427  : 					(pCmd_t->format_index) += 1;

  003be	8b 83 f4 04 00
	00		 mov	 eax, DWORD PTR [ebx+1268]
  003c4	41		 inc	 ecx
  003c5	40		 inc	 eax
  003c6	5f		 pop	 edi
  003c7	5e		 pop	 esi
  003c8	89 8b d0 02 00
	00		 mov	 DWORD PTR [ebx+720], ecx
  003ce	89 83 f4 04 00
	00		 mov	 DWORD PTR [ebx+1268], eax
  003d4	5d		 pop	 ebp
  003d5	5b		 pop	 ebx

; 701  : #ifdef DEBUGPARS                                     
; 702  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_TOSS\n");
; 703  : #endif
; 704  : 			break;
; 705  : 	}       /* End switch (c) */
; 706  : }

  003d6	c3		 ret	 0
$L71235:

; 428  : 					return;
; 429  : 
; 430  : 				case ' ':
; 431  : 				case '\t':
; 432  : 				case '\r':
; 433  : 				case '\n':
; 434  : 					return;
; 435  : 
; 436  : 				case ']':
; 437  : 					cm_cmd_do_command(phTTS, STATE_NORMAL);
; 438  : #ifdef DEBUGPARS
; 439  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_NORMAL\n");
; 440  : #endif
; 441  : 					return;
; 442  : 
; 443  : 				case ':':
; 444  : 					cm_cmd_do_command(phTTS, STATE_COMMAND);
; 445  : #ifdef DEBUGPARS
; 446  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_COMMAND\n");
; 447  : #endif
; 448  : 					return;
; 449  : 
; 450  : 				case '.':
; 451  : 					cm_cmd_do_command(phTTS, STATE_BRACKET);
; 452  : #ifdef DEBUGPARS
; 453  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_BRACKET\n");
; 454  : #endif
; 455  : 					return;
; 456  : 				};
; 457  : 			} /* End of if(pCmd_t->q_flag == 0 || FORMAT_PARAM != 'a') */
; 458  : 
; 459  : 		if(pCmd_t->q_flag == 0)

  003d7	3b fa		 cmp	 edi, edx
  003d9	75 28		 jne	 SHORT $L71245

; 460  : 		{
; 461  : 			switch(c)       
; 462  : 			{

  003db	83 f8 22	 cmp	 eax, 34			; 00000022H
  003de	74 14		 je	 SHORT $L71249
  003e0	83 f8 3c	 cmp	 eax, 60			; 0000003cH
  003e3	75 1e		 jne	 SHORT $L71245
  003e5	5f		 pop	 edi
  003e6	5e		 pop	 esi

; 463  : 				case '<':
; 464  : 					pCmd_t->q_flag = '>';

  003e7	c7 83 dc 02 00
	00 3e 00 00 00	 mov	 DWORD PTR [ebx+732], 62	; 0000003eH
  003f1	5d		 pop	 ebp
  003f2	5b		 pop	 ebx

; 701  : #ifdef DEBUGPARS                                     
; 702  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_TOSS\n");
; 703  : #endif
; 704  : 			break;
; 705  : 	}       /* End switch (c) */
; 706  : }

  003f3	c3		 ret	 0
$L71249:
  003f4	5f		 pop	 edi
  003f5	5e		 pop	 esi

; 465  : 					return;
; 466  : 
; 467  : 				case '\"':
; 468  : 					pCmd_t->q_flag = '\"';

  003f6	c7 83 dc 02 00
	00 22 00 00 00	 mov	 DWORD PTR [ebx+732], 34	; 00000022H
  00400	5d		 pop	 ebp
  00401	5b		 pop	 ebx

; 701  : #ifdef DEBUGPARS                                     
; 702  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_TOSS\n");
; 703  : #endif
; 704  : 			break;
; 705  : 	}       /* End switch (c) */
; 706  : }

  00402	c3		 ret	 0
$L71245:

; 469  : 					return;
; 470  : 				};
; 471  : 			}
; 472  : 		}
; 473  : 	/*
; 474  : 	 *  now accept the first character and parse it into the param array ...
; 475  : 	 */
; 476  : 
; 477  : 	(pCmd_t->p_count) += 1;

  00403	8b b3 d4 02 00
	00		 mov	 esi, DWORD PTR [ebx+724]

; 478  : #ifdef __linux__
; 479  : 	CURR_DEFAULT = FALSE;
; 480  : #else
; 481  : 	CURR_DEFAULT = false;

  00409	8b 8b d0 02 00
	00		 mov	 ecx, DWORD PTR [ebx+720]
  0040f	46		 inc	 esi
  00410	89 b3 d4 02 00
	00		 mov	 DWORD PTR [ebx+724], esi
  00416	89 94 8b a8 02
	00 00		 mov	 DWORD PTR [ebx+ecx*4+680], edx

; 482  : #endif
; 483  : 	switch (FORMAT_PARAM) 
; 484  : 	{

  0041d	8b 8b e8 02 00
	00		 mov	 ecx, DWORD PTR [ebx+744]
  00423	8b b3 f4 04 00
	00		 mov	 esi, DWORD PTR [ebx+1268]
  00429	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  0042c	8b 3c 8d 04 00
	00 00		 mov	 edi, DWORD PTR _command_table[ecx*4+4]
  00433	33 c9		 xor	 ecx, ecx
  00435	8a 0c 37	 mov	 cl, BYTE PTR [edi+esi]
  00438	8d 71 9f	 lea	 esi, DWORD PTR [ecx-97]
  0043b	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  0043e	0f 87 ba 01 00
	00		 ja	 $L71361
  00444	33 c9		 xor	 ecx, ecx
  00446	8a 8e 00 00 00
	00		 mov	 cl, BYTE PTR $L71370[esi]
  0044c	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L71371[ecx*4]
$L71254:

; 485  : 
; 486  : 		/*
; 487  : 		 *  binary conversion ...
; 488  : 		 */
; 489  : 
; 490  : 		case 'b':
; 491  : 			if(c == '0' || c == '1')

  00453	83 f8 30	 cmp	 eax, 48			; 00000030H
  00456	74 09		 je	 SHORT $L71256
  00458	83 f8 31	 cmp	 eax, 49			; 00000031H
  0045b	0f 85 9d 01 00
	00		 jne	 $L71361
$L71256:

; 492  : 			{
; 493  : 				CURR_PARAM = CURR_PARAM*2 + c - '0';

  00461	8b 93 d0 02 00
	00		 mov	 edx, DWORD PTR [ebx+720]
  00467	5f		 pop	 edi
  00468	5e		 pop	 esi
  00469	5d		 pop	 ebp
  0046a	8d 0c 93	 lea	 ecx, DWORD PTR [ebx+edx*4]
  0046d	5b		 pop	 ebx
  0046e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00470	8d 44 50 d0	 lea	 eax, DWORD PTR [eax+edx*2-48]
  00474	89 01		 mov	 DWORD PTR [ecx], eax

; 701  : #ifdef DEBUGPARS                                     
; 702  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_TOSS\n");
; 703  : #endif
; 704  : 			break;
; 705  : 	}       /* End switch (c) */
; 706  : }

  00476	c3		 ret	 0
$L71257:

; 494  : 				return;
; 495  : 			}
; 496  : 			break;
; 497  : 		/*
; 498  : 		 *  octal conversion ...
; 499  : 		 */
; 500  : 
; 501  : 		case 'o':
; 502  : 			if(c >= '0' && c <= '7')

  00477	83 f8 30	 cmp	 eax, 48			; 00000030H
  0047a	0f 82 7e 01 00
	00		 jb	 $L71361
  00480	83 f8 37	 cmp	 eax, 55			; 00000037H
  00483	0f 87 75 01 00
	00		 ja	 $L71361

; 503  : 			{
; 504  : 				CURR_PARAM = CURR_PARAM*8 + c - '0';

  00489	8b 8b d0 02 00
	00		 mov	 ecx, DWORD PTR [ebx+720]
  0048f	5f		 pop	 edi
  00490	5e		 pop	 esi
  00491	5d		 pop	 ebp
  00492	8b 14 8b	 mov	 edx, DWORD PTR [ebx+ecx*4]
  00495	8d 0c 8b	 lea	 ecx, DWORD PTR [ebx+ecx*4]
  00498	5b		 pop	 ebx
  00499	8d 44 d0 d0	 lea	 eax, DWORD PTR [eax+edx*8-48]
  0049d	89 01		 mov	 DWORD PTR [ecx], eax

; 701  : #ifdef DEBUGPARS                                     
; 702  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_TOSS\n");
; 703  : #endif
; 704  : 			break;
; 705  : 	}       /* End switch (c) */
; 706  : }

  0049f	c3		 ret	 0
$L71259:

; 505  : 				return;
; 506  : 			}
; 507  : 			break;
; 508  : 		/*
; 509  : 		 *  signed decimal conversion ...
; 510  : 		 */
; 511  : 
; 512  : 		case 'd':
; 513  : 			if(pCmd_t->p_count == 1 && c == '-')

  004a0	8b 8b d4 02 00
	00		 mov	 ecx, DWORD PTR [ebx+724]
  004a6	be 01 00 00 00	 mov	 esi, 1
  004ab	3b ce		 cmp	 ecx, esi
  004ad	75 10		 jne	 SHORT $L71260
  004af	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  004b2	75 0b		 jne	 SHORT $L71260

; 514  : 			{   
; 515  : 				/* 
; 516  : 				 * a minus is found; set pCmd_t->p_flag to TRUE to signal
; 517  : 				 * that the value of the phonemic info. should be negated. 
; 518  : 				 */
; 519  : 				pCmd_t->p_flag = TRUE;

  004b4	89 b3 d8 02 00
	00		 mov	 DWORD PTR [ebx+728], esi
  004ba	5f		 pop	 edi
  004bb	5e		 pop	 esi
  004bc	5d		 pop	 ebp
  004bd	5b		 pop	 ebx

; 701  : #ifdef DEBUGPARS                                     
; 702  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_TOSS\n");
; 703  : #endif
; 704  : 			break;
; 705  : 	}       /* End switch (c) */
; 706  : }

  004be	c3		 ret	 0
$L71260:

; 520  : 			}
; 521  : 			else 
; 522  : 			{
; 523  : 				if(c >= '0' &&  c <= '9')

  004bf	83 f8 30	 cmp	 eax, 48			; 00000030H
  004c2	0f 82 3b 01 00
	00		 jb	 $L71251
  004c8	83 f8 39	 cmp	 eax, 57			; 00000039H
  004cb	0f 87 32 01 00
	00		 ja	 $L71251

; 524  : 				{
; 525  : 					CURR_PARAM = CURR_PARAM*10 + c - '0';

  004d1	8b 8b d0 02 00
	00		 mov	 ecx, DWORD PTR [ebx+720]
  004d7	5f		 pop	 edi
  004d8	5e		 pop	 esi
  004d9	5d		 pop	 ebp
  004da	8b 14 8b	 mov	 edx, DWORD PTR [ebx+ecx*4]
  004dd	8d 0c 8b	 lea	 ecx, DWORD PTR [ebx+ecx*4]
  004e0	5b		 pop	 ebx
  004e1	8d 14 92	 lea	 edx, DWORD PTR [edx+edx*4]
  004e4	8d 44 50 d0	 lea	 eax, DWORD PTR [eax+edx*2-48]
  004e8	89 01		 mov	 DWORD PTR [ecx], eax

; 701  : #ifdef DEBUGPARS                                     
; 702  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_TOSS\n");
; 703  : #endif
; 704  : 			break;
; 705  : 	}       /* End switch (c) */
; 706  : }

  004ea	c3		 ret	 0
$L71264:

; 526  : 				}
; 527  : 				else
; 528  : 				{
; 529  : 					break;
; 530  : 				}      
; 531  : 			}
; 532  : 			return;                         
; 533  : 		/*
; 534  : 		 *  hex conversion ...
; 535  : 		 */
; 536  : 
; 537  : 		case 'h':
; 538  : 
; 539  : 			if(c >= '0' && c <= '9')

  004eb	83 f8 30	 cmp	 eax, 48			; 00000030H
  004ee	72 23		 jb	 SHORT $L71265
  004f0	83 f8 39	 cmp	 eax, 57			; 00000039H
  004f3	77 1e		 ja	 SHORT $L71265

; 540  : 			{
; 541  : 				CURR_PARAM = CURR_PARAM*16 + c - '0'; 

  004f5	8b 8b d0 02 00
	00		 mov	 ecx, DWORD PTR [ebx+720]
  004fb	5f		 pop	 edi
  004fc	5e		 pop	 esi
  004fd	5d		 pop	 ebp
  004fe	8b 14 8b	 mov	 edx, DWORD PTR [ebx+ecx*4]
  00501	8d 0c 8b	 lea	 ecx, DWORD PTR [ebx+ecx*4]
  00504	81 c2 fd ff ff
	0f		 add	 edx, 268435453		; 0ffffffdH
  0050a	5b		 pop	 ebx
  0050b	c1 e2 04	 shl	 edx, 4
  0050e	03 d0		 add	 edx, eax
  00510	89 11		 mov	 DWORD PTR [ecx], edx

; 701  : #ifdef DEBUGPARS                                     
; 702  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_TOSS\n");
; 703  : #endif
; 704  : 			break;
; 705  : 	}       /* End switch (c) */
; 706  : }

  00512	c3		 ret	 0
$L71265:

; 542  : 			}
; 543  : 			else
; 544  : 			{   
; 545  : 				/* Convert c to lowercase */
; 546  :                 c = par_lower[c];

  00513	33 c9		 xor	 ecx, ecx
  00515	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR _par_lower[eax]
  0051b	8b c1		 mov	 eax, ecx

; 547  : 				if(c >= 'a' && c <= 'f')

  0051d	83 f8 61	 cmp	 eax, 97			; 00000061H
  00520	0f 82 d8 00 00
	00		 jb	 $L71361
  00526	83 f8 66	 cmp	 eax, 102		; 00000066H
  00529	0f 87 cf 00 00
	00		 ja	 $L71361

; 548  : 				{
; 549  : 					CURR_PARAM = CURR_PARAM*16 + c - 'a' + 10;

  0052f	8b 93 d0 02 00
	00		 mov	 edx, DWORD PTR [ebx+720]
  00535	5f		 pop	 edi
  00536	5e		 pop	 esi
  00537	5d		 pop	 ebp
  00538	8d 0c 93	 lea	 ecx, DWORD PTR [ebx+edx*4]
  0053b	5b		 pop	 ebx
  0053c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0053e	c1 e2 04	 shl	 edx, 4
  00541	8d 44 02 a9	 lea	 eax, DWORD PTR [edx+eax-87]
  00545	89 01		 mov	 DWORD PTR [ecx], eax

; 701  : #ifdef DEBUGPARS                                     
; 702  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_TOSS\n");
; 703  : #endif
; 704  : 			break;
; 705  : 	}       /* End switch (c) */
; 706  : }

  00547	c3		 ret	 0
$L71269:

; 550  : 				}
; 551  : 				else
; 552  : 				{
; 553  : 					break;
; 554  : 				}
; 555  : 			}
; 556  : 			return;
; 557  : 		/*
; 558  : 		 *  ascii strings ... the param value is an index into the string buffer.
; 559  : 		 *  Delimitors are "" or <> or simple white space if no delimator is needed.
; 560  : 		 */
; 561  : 
; 562  : 		
; 563  : 		case 'a':			
; 564  : 			if (pCmd_t->p_count == 1)

  00548	8b 8b d4 02 00
	00		 mov	 ecx, DWORD PTR [ebx+724]
  0054e	be 01 00 00 00	 mov	 esi, 1
  00553	3b ce		 cmp	 ecx, esi
  00555	75 2d		 jne	 SHORT $L71270

; 565  : 			{
; 566  : 				pCmd_t->pString[pCmd_t->param_index] = &(pCmd_t->string_buff[pCmd_t->next_char]);                               

  00557	8b 8b f0 04 00
	00		 mov	 ecx, DWORD PTR [ebx+1264]
  0055d	8b bb d0 02 00
	00		 mov	 edi, DWORD PTR [ebx+720]
  00563	8d 8c 19 f0 02
	00 00		 lea	 ecx, DWORD PTR [ecx+ebx+752]
  0056a	89 8c bb 80 02
	00 00		 mov	 DWORD PTR [ebx+edi*4+640], ecx

; 567  : 				pCmd_t->string_buff[pCmd_t->next_char & STRING_MASK] = 0;

  00571	8b 8b f0 04 00
	00		 mov	 ecx, DWORD PTR [ebx+1264]
  00577	81 e1 ff 01 00
	00		 and	 ecx, 511		; 000001ffH
  0057d	88 94 19 f0 02
	00 00		 mov	 BYTE PTR [ecx+ebx+752], dl
$L71270:

; 568  : 			}
; 569  : 			if(pCmd_t->q_flag && c != pCmd_t->q_flag)

  00584	8b 8b dc 02 00
	00		 mov	 ecx, DWORD PTR [ebx+732]
  0058a	3b ca		 cmp	 ecx, edx
  0058c	74 3b		 je	 SHORT $L71363
  0058e	3b c1		 cmp	 eax, ecx
  00590	74 33		 je	 SHORT $L71271
$L71367:

; 570  : 			{
; 571  : 				pCmd_t->string_buff[pCmd_t->next_char++ & STRING_MASK] = c;

  00592	8b 8b f0 04 00
	00		 mov	 ecx, DWORD PTR [ebx+1264]
  00598	5f		 pop	 edi
  00599	81 e1 ff 01 00
	00		 and	 ecx, 511		; 000001ffH
  0059f	88 84 19 f0 02
	00 00		 mov	 BYTE PTR [ecx+ebx+752], al
  005a6	8b b3 f0 04 00
	00		 mov	 esi, DWORD PTR [ebx+1264]
  005ac	46		 inc	 esi
  005ad	8b c6		 mov	 eax, esi
  005af	89 b3 f0 04 00
	00		 mov	 DWORD PTR [ebx+1264], esi

; 572  : 				pCmd_t->string_buff[pCmd_t->next_char & STRING_MASK] = 0;

  005b5	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  005ba	5e		 pop	 esi
  005bb	5d		 pop	 ebp
  005bc	88 94 18 f0 02
	00 00		 mov	 BYTE PTR [eax+ebx+752], dl
  005c3	5b		 pop	 ebx

; 701  : #ifdef DEBUGPARS                                     
; 702  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_TOSS\n");
; 703  : #endif
; 704  : 			break;
; 705  : 	}       /* End switch (c) */
; 706  : }

  005c4	c3		 ret	 0
$L71271:

; 573  : 				return;
; 574  : 			}
; 575  : 			if ((pCmd_t->q_flag == 0) && (c != ' ') && (c != '\t') && (c != ']') && (c != ','))

  005c5	3b ca		 cmp	 ecx, edx
  005c7	75 18		 jne	 SHORT $L71365
$L71363:
  005c9	83 f8 20	 cmp	 eax, 32			; 00000020H
  005cc	74 0f		 je	 SHORT $L71272
  005ce	83 f8 09	 cmp	 eax, 9
  005d1	74 0a		 je	 SHORT $L71272
  005d3	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  005d6	74 05		 je	 SHORT $L71272
  005d8	83 f8 2c	 cmp	 eax, 44			; 0000002cH

; 576  : 			{
; 577  : 				pCmd_t->string_buff[pCmd_t->next_char++ & STRING_MASK] = c;
; 578  : 				pCmd_t->string_buff[pCmd_t->next_char & STRING_MASK] = 0;
; 579  : 				return;

  005db	75 b5		 jne	 SHORT $L71367
$L71272:

; 580  : 			}
; 581  : 			if(pCmd_t->q_flag)

  005dd	3b ca		 cmp	 ecx, edx
  005df	74 0b		 je	 SHORT $L71273
$L71365:
  005e1	5f		 pop	 edi
  005e2	5e		 pop	 esi

; 582  : 			{
; 583  : 				pCmd_t->q_flag = 0;

  005e3	89 93 dc 02 00
	00		 mov	 DWORD PTR [ebx+732], edx
  005e9	5d		 pop	 ebp
  005ea	5b		 pop	 ebx

; 701  : #ifdef DEBUGPARS                                     
; 702  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_TOSS\n");
; 703  : #endif
; 704  : 			break;
; 705  : 	}       /* End switch (c) */
; 706  : }

  005eb	c3		 ret	 0
$L71273:

; 584  : 				return;
; 585  : 			}
; 586  : 			if(c != ']')

  005ec	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  005ef	74 05		 je	 SHORT $L71274

; 587  : 			{
; 588  : 				c = ' ';

  005f1	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
$L71274:

; 589  : 			}
; 590  : 			pCmd_t->next_char += 1;

  005f6	ff 83 f0 04 00
	00		 inc	 DWORD PTR [ebx+1264]
  005fc	eb 05		 jmp	 SHORT $L71251
$L71361:
  005fe	be 01 00 00 00	 mov	 esi, 1
$L71251:

; 591  : 			break;
; 592  : 		}       /* End switch (FORMAT_PARAM) */
; 593  : 
; 594  : 	/*
; 595  : 	 *  now, pCmd_t->p_flag may be set to cause a negation, if so do it ...
; 596  : 	 */
; 597  : 
; 598  : 	if(pCmd_t->p_flag == TRUE)

  00603	39 b3 d8 02 00
	00		 cmp	 DWORD PTR [ebx+728], esi
  00609	75 10		 jne	 SHORT $L71275

; 599  : 	{
; 600  : 	    /* why we assign "sign" to a unsigned int ???  GL 4/3/1996 */
; 601  : 		CURR_PARAM = -CURR_PARAM;

  0060b	8b 8b d0 02 00
	00		 mov	 ecx, DWORD PTR [ebx+720]
  00611	8b 3c 8b	 mov	 edi, DWORD PTR [ebx+ecx*4]
  00614	8d 0c 8b	 lea	 ecx, DWORD PTR [ebx+ecx*4]
  00617	f7 df		 neg	 edi
  00619	89 39		 mov	 DWORD PTR [ecx], edi
$L71275:

; 602  :     }
; 603  : 	/*
; 604  : 	 *  if we have taken in something, bump the indexes and reset the
; 605  : 	 *  counts ...
; 606  : 	 */
; 607  : 
; 608  : 	if(pCmd_t->q_flag && (c == (unsigned int)pCmd_t->q_flag))

  0061b	8b 8b dc 02 00
	00		 mov	 ecx, DWORD PTR [ebx+732]
  00621	3b ca		 cmp	 ecx, edx
  00623	74 21		 je	 SHORT $L71277
  00625	3b c1		 cmp	 eax, ecx
  00627	75 1d		 jne	 SHORT $L71277

; 609  : 	{
; 610  : 		if(pCmd_t->p_count != 1)

  00629	39 b3 d4 02 00
	00		 cmp	 DWORD PTR [ebx+724], esi
  0062f	74 06		 je	 SHORT $L71278

; 611  : 		{
; 612  : 			(pCmd_t->param_index) += 1;

  00631	ff 83 d0 02 00
	00		 inc	 DWORD PTR [ebx+720]
$L71278:

; 613  : 		}
; 614  : 		cm_cmd_do_command(phTTS, STATE_BRACKET);

  00637	56		 push	 esi
  00638	55		 push	 ebp
  00639	e8 00 00 00 00	 call	 _cm_cmd_do_command
  0063e	83 c4 08	 add	 esp, 8
  00641	5f		 pop	 edi
  00642	5e		 pop	 esi
  00643	5d		 pop	 ebp
  00644	5b		 pop	 ebx

; 701  : #ifdef DEBUGPARS                                     
; 702  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_TOSS\n");
; 703  : #endif
; 704  : 			break;
; 705  : 	}       /* End switch (c) */
; 706  : }

  00645	c3		 ret	 0
$L71277:

; 615  : #ifdef DEBUGPARS
; 616  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_BRACKET\n");
; 617  : #endif
; 618  : 		return;
; 619  : 	}
; 620  : 
; 621  : 	if(pCmd_t->p_count != 1)

  00646	39 b3 d4 02 00
	00		 cmp	 DWORD PTR [ebx+724], esi
  0064c	74 1a		 je	 SHORT $L71279

; 622  : 	{
; 623  : 		(pCmd_t->format_index) += 1;

  0064e	8b bb f4 04 00
	00		 mov	 edi, DWORD PTR [ebx+1268]

; 624  : 		pCmd_t->param_index += 1;

  00654	8b 8b d0 02 00
	00		 mov	 ecx, DWORD PTR [ebx+720]
  0065a	47		 inc	 edi
  0065b	41		 inc	 ecx
  0065c	89 bb f4 04 00
	00		 mov	 DWORD PTR [ebx+1268], edi
  00662	89 8b d0 02 00
	00		 mov	 DWORD PTR [ebx+720], ecx
$L71279:

; 625  : 	}
; 626  : 	pCmd_t->p_count = 0;
; 627  : 	pCmd_t->p_flag = 0;
; 628  : 
; 629  : 
; 630  : 	/*
; 631  : 	 *  legal seperators are white space and commas ... note that leading
; 632  : 	 *  commas cause the pCmd_t->defaults to be preselected ...  white space is
; 633  : 	 *  allowed to start execution but comma implies another parameter ...
; 634  : 	 */
; 635  : 
; 636  : 
; 637  : 	switch (c)       
; 638  : 	{

  00668	83 c0 f7	 add	 eax, -9			; fffffff7H
  0066b	89 93 d4 02 00
	00		 mov	 DWORD PTR [ebx+724], edx
  00671	83 f8 54	 cmp	 eax, 84			; 00000054H
  00674	89 93 d8 02 00
	00		 mov	 DWORD PTR [ebx+728], edx
  0067a	0f 87 8f 00 00
	00		 ja	 $L71294
  00680	33 c9		 xor	 ecx, ecx
  00682	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR $L71372[eax]
  00688	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L71373[ecx*4]
$L71284:

; 639  : 		case ' ':
; 640  : 		case '\t':
; 641  :         case '\r':
; 642  : 		case '\n':
; 643  : 			if(FORMAT_PARAM == '\0')

  0068f	8b 83 e8 02 00
	00		 mov	 eax, DWORD PTR [ebx+744]
  00695	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00698	8b 0c 85 04 00
	00 00		 mov	 ecx, DWORD PTR _command_table[eax*4+4]
  0069f	8b 83 f4 04 00
	00		 mov	 eax, DWORD PTR [ebx+1268]
  006a5	8a 04 01	 mov	 al, BYTE PTR [ecx+eax]
  006a8	3a c2		 cmp	 al, dl
  006aa	75 0f		 jne	 SHORT $L71285

; 644  : 			{
; 645  : 				cm_cmd_do_command(phTTS, STATE_BRACKET);

  006ac	56		 push	 esi
  006ad	55		 push	 ebp
  006ae	e8 00 00 00 00	 call	 _cm_cmd_do_command
  006b3	83 c4 08	 add	 esp, 8
  006b6	5f		 pop	 edi
  006b7	5e		 pop	 esi
  006b8	5d		 pop	 ebp
  006b9	5b		 pop	 ebx

; 701  : #ifdef DEBUGPARS                                     
; 702  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_TOSS\n");
; 703  : #endif
; 704  : 			break;
; 705  : 	}       /* End switch (c) */
; 706  : }

  006ba	c3		 ret	 0
$L71285:

; 646  : #ifdef DEBUGPARS
; 647  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_BRACKET\n");
; 648  : #endif
; 649  : 			}
; 650  : 			else if(FORMAT_PARAM == '*')

  006bb	3c 2a		 cmp	 al, 42			; 0000002aH
  006bd	0f 85 a3 00 00
	00		 jne	 $L71281
$L71229:

; 651  : 			{
; 652  : 				cm_cmd_do_command(phTTS, STATE_KEEP);

  006c3	6a 06		 push	 6
  006c5	55		 push	 ebp
  006c6	e8 00 00 00 00	 call	 _cm_cmd_do_command
  006cb	83 c4 08	 add	 esp, 8
  006ce	5f		 pop	 edi
  006cf	5e		 pop	 esi
  006d0	5d		 pop	 ebp
  006d1	5b		 pop	 ebx

; 701  : #ifdef DEBUGPARS                                     
; 702  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_TOSS\n");
; 703  : #endif
; 704  : 			break;
; 705  : 	}       /* End switch (c) */
; 706  : }

  006d2	c3		 ret	 0
$L71288:

; 653  : #ifdef DEBUGPARS
; 654  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_KEEP\n");
; 655  : #endif
; 656  : 			}
; 657  : 			break;
; 658  : 
; 659  : 		case ',':
; 660  : 
; 661  : 			if(FORMAT_PARAM == '\0' || FORMAT_PARAM == '*')

  006d3	8b 83 e8 02 00
	00		 mov	 eax, DWORD PTR [ebx+744]
  006d9	8b b3 f4 04 00
	00		 mov	 esi, DWORD PTR [ebx+1268]
  006df	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  006e2	c1 e0 02	 shl	 eax, 2
  006e5	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _command_table[eax+4]
  006eb	8a 0c 31	 mov	 cl, BYTE PTR [ecx+esi]
  006ee	3a ca		 cmp	 cl, dl
  006f0	74 05		 je	 SHORT $L71290
  006f2	80 f9 2a	 cmp	 cl, 42			; 0000002aH
  006f5	75 6f		 jne	 SHORT $L71281
$L71290:

; 662  : 			{
; 663  : 				/* if this is an index command, it must be flushed now */
; 664  : #ifdef NEW_INDEXING
; 665  : 				if (memcmp(CT[pCmd_t->cmd_index].c_name,"index",5)==0)

  006f7	8b b0 00 00 00
	00		 mov	 esi, DWORD PTR _command_table[eax]
  006fd	b9 05 00 00 00	 mov	 ecx, 5
  00702	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:$SG71292
  00707	33 d2		 xor	 edx, edx
  00709	f3 a6		 repe cmpsb
  0070b	75 46		 jne	 SHORT $L71291

; 666  : 				{
; 667  : 				 	temp=pCmd_t->ParseChar; 
; 668  : 				 	pCmd_t->ParseChar=0x0fff;
; 669  : 			 		cm_pars_proc_char(phTTS,' ');
; 670  : 				 	pCmd_t->ParseChar=temp;
; 671  : 				}			 	
; 672  : #endif
; 673  : 				cm_cmd_error_comm(phTTS, CMD_bad_param);
; 674  : 				cm_pars_new_state(pCmd_t, STATE_TOSS);
; 675  : #ifdef DEBUGPARS
; 676  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_TOSS\n");
; 677  : #endif
; 678  : 			}
; 679  : 			break;

  0070d	eb 20		 jmp	 SHORT $L71366
$L71294:

; 680  : 
; 681  : 		case ']':
; 682  : 			cm_cmd_do_command(phTTS, STATE_NORMAL);
; 683  : #ifdef DEBUGPARS
; 684  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_NORMAL\n");
; 685  : #endif
; 686  : 			break;
; 687  : 
; 688  : 		default :
; 689  : #ifdef NEW_INDEXING
; 690  : 			/* if this is an index command, it must be flushed now */
; 691  : 			if (memcmp(CT[pCmd_t->cmd_index].c_name,"index",5)==0)

  0070f	8b 83 e8 02 00
	00		 mov	 eax, DWORD PTR [ebx+744]
  00715	b9 05 00 00 00	 mov	 ecx, 5
  0071a	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:$SG71296
  0071f	33 d2		 xor	 edx, edx
  00721	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00724	8b 34 85 00 00
	00 00		 mov	 esi, DWORD PTR _command_table[eax*4]
  0072b	f3 a6		 repe cmpsb
  0072d	75 24		 jne	 SHORT $L71291
$L71366:

; 692  : 			{
; 693  : 			 	temp=pCmd_t->ParseChar; 

  0072f	33 f6		 xor	 esi, esi

; 694  : 			 	pCmd_t->ParseChar=0x0fff;
; 695  : 		 		cm_pars_proc_char(phTTS,' ');

  00731	6a 20		 push	 32			; 00000020H
  00733	66 8b b3 1c 05
	00 00		 mov	 si, WORD PTR [ebx+1308]
  0073a	55		 push	 ebp
  0073b	66 c7 83 1c 05
	00 00 ff 0f	 mov	 WORD PTR [ebx+1308], 4095 ; 00000fffH
  00744	e8 00 00 00 00	 call	 _cm_pars_proc_char
  00749	83 c4 08	 add	 esp, 8

; 696  : 			 	pCmd_t->ParseChar=temp;

  0074c	66 89 b3 1c 05
	00 00		 mov	 WORD PTR [ebx+1308], si
$L71291:

; 697  : 			}			 	
; 698  : #endif
; 699  : 			cm_cmd_error_comm(phTTS, CMD_bad_param);

  00753	6a 04		 push	 4
  00755	55		 push	 ebp
  00756	e8 00 00 00 00	 call	 _cm_cmd_error_comm

; 700  : 			cm_pars_new_state(pCmd_t, STATE_TOSS);

  0075b	6a 05		 push	 5
  0075d	53		 push	 ebx
  0075e	e8 00 00 00 00	 call	 _cm_pars_new_state
  00763	83 c4 10	 add	 esp, 16			; 00000010H
$L71281:
  00766	5f		 pop	 edi
  00767	5e		 pop	 esi
  00768	5d		 pop	 ebp
  00769	5b		 pop	 ebx

; 701  : #ifdef DEBUGPARS                                     
; 702  : 		printf("CMD_PARS: cm_cmd_build_param: Parse State Switch: STATE_PARAM->STATE_TOSS\n");
; 703  : #endif
; 704  : 			break;
; 705  : 	}       /* End switch (c) */
; 706  : }

  0076a	c3		 ret	 0
  0076b	90		 npad	 1
$L71369:
  0076c	00 00 00 00	 DD	 $L71281
  00770	00 00 00 00	 DD	 $L71238
  00774	00 00 00 00	 DD	 $L71242
  00778	00 00 00 00	 DD	 $L71241
  0077c	00 00 00 00	 DD	 $L71293
  00780	00 00 00 00	 DD	 $L71235
$L71368:
  00784	00		 DB	 0
  00785	00		 DB	 0
  00786	05		 DB	 5
  00787	05		 DB	 5
  00788	00		 DB	 0
  00789	05		 DB	 5
  0078a	05		 DB	 5
  0078b	05		 DB	 5
  0078c	05		 DB	 5
  0078d	05		 DB	 5
  0078e	05		 DB	 5
  0078f	05		 DB	 5
  00790	05		 DB	 5
  00791	05		 DB	 5
  00792	05		 DB	 5
  00793	05		 DB	 5
  00794	05		 DB	 5
  00795	05		 DB	 5
  00796	05		 DB	 5
  00797	05		 DB	 5
  00798	05		 DB	 5
  00799	05		 DB	 5
  0079a	05		 DB	 5
  0079b	00		 DB	 0
  0079c	05		 DB	 5
  0079d	05		 DB	 5
  0079e	05		 DB	 5
  0079f	05		 DB	 5
  007a0	05		 DB	 5
  007a1	05		 DB	 5
  007a2	05		 DB	 5
  007a3	05		 DB	 5
  007a4	05		 DB	 5
  007a5	05		 DB	 5
  007a6	05		 DB	 5
  007a7	01		 DB	 1
  007a8	05		 DB	 5
  007a9	02		 DB	 2
  007aa	05		 DB	 5
  007ab	05		 DB	 5
  007ac	05		 DB	 5
  007ad	05		 DB	 5
  007ae	05		 DB	 5
  007af	05		 DB	 5
  007b0	05		 DB	 5
  007b1	05		 DB	 5
  007b2	05		 DB	 5
  007b3	05		 DB	 5
  007b4	05		 DB	 5
  007b5	03		 DB	 3
  007b6	05		 DB	 5
  007b7	05		 DB	 5
  007b8	05		 DB	 5
  007b9	05		 DB	 5
  007ba	05		 DB	 5
  007bb	05		 DB	 5
  007bc	05		 DB	 5
  007bd	05		 DB	 5
  007be	05		 DB	 5
  007bf	05		 DB	 5
  007c0	05		 DB	 5
  007c1	05		 DB	 5
  007c2	05		 DB	 5
  007c3	05		 DB	 5
  007c4	05		 DB	 5
  007c5	05		 DB	 5
  007c6	05		 DB	 5
  007c7	05		 DB	 5
  007c8	05		 DB	 5
  007c9	05		 DB	 5
  007ca	05		 DB	 5
  007cb	05		 DB	 5
  007cc	05		 DB	 5
  007cd	05		 DB	 5
  007ce	05		 DB	 5
  007cf	05		 DB	 5
  007d0	05		 DB	 5
  007d1	05		 DB	 5
  007d2	05		 DB	 5
  007d3	05		 DB	 5
  007d4	05		 DB	 5
  007d5	05		 DB	 5
  007d6	05		 DB	 5
  007d7	05		 DB	 5
  007d8	04		 DB	 4
  007d9	8d 49 00	 npad	 3
$L71371:
  007dc	00 00 00 00	 DD	 $L71269
  007e0	00 00 00 00	 DD	 $L71254
  007e4	00 00 00 00	 DD	 $L71259
  007e8	00 00 00 00	 DD	 $L71264
  007ec	00 00 00 00	 DD	 $L71257
  007f0	00 00 00 00	 DD	 $L71361
$L71370:
  007f4	00		 DB	 0
  007f5	01		 DB	 1
  007f6	05		 DB	 5
  007f7	02		 DB	 2
  007f8	05		 DB	 5
  007f9	05		 DB	 5
  007fa	05		 DB	 5
  007fb	03		 DB	 3
  007fc	05		 DB	 5
  007fd	05		 DB	 5
  007fe	05		 DB	 5
  007ff	05		 DB	 5
  00800	05		 DB	 5
  00801	05		 DB	 5
  00802	04		 DB	 4
  00803	90		 npad	 1
$L71373:
  00804	00 00 00 00	 DD	 $L71284
  00808	00 00 00 00	 DD	 $L71288
  0080c	00 00 00 00	 DD	 $L71293
  00810	00 00 00 00	 DD	 $L71294
$L71372:
  00814	00		 DB	 0
  00815	00		 DB	 0
  00816	03		 DB	 3
  00817	03		 DB	 3
  00818	00		 DB	 0
  00819	03		 DB	 3
  0081a	03		 DB	 3
  0081b	03		 DB	 3
  0081c	03		 DB	 3
  0081d	03		 DB	 3
  0081e	03		 DB	 3
  0081f	03		 DB	 3
  00820	03		 DB	 3
  00821	03		 DB	 3
  00822	03		 DB	 3
  00823	03		 DB	 3
  00824	03		 DB	 3
  00825	03		 DB	 3
  00826	03		 DB	 3
  00827	03		 DB	 3
  00828	03		 DB	 3
  00829	03		 DB	 3
  0082a	03		 DB	 3
  0082b	00		 DB	 0
  0082c	03		 DB	 3
  0082d	03		 DB	 3
  0082e	03		 DB	 3
  0082f	03		 DB	 3
  00830	03		 DB	 3
  00831	03		 DB	 3
  00832	03		 DB	 3
  00833	03		 DB	 3
  00834	03		 DB	 3
  00835	03		 DB	 3
  00836	03		 DB	 3
  00837	01		 DB	 1
  00838	03		 DB	 3
  00839	03		 DB	 3
  0083a	03		 DB	 3
  0083b	03		 DB	 3
  0083c	03		 DB	 3
  0083d	03		 DB	 3
  0083e	03		 DB	 3
  0083f	03		 DB	 3
  00840	03		 DB	 3
  00841	03		 DB	 3
  00842	03		 DB	 3
  00843	03		 DB	 3
  00844	03		 DB	 3
  00845	03		 DB	 3
  00846	03		 DB	 3
  00847	03		 DB	 3
  00848	03		 DB	 3
  00849	03		 DB	 3
  0084a	03		 DB	 3
  0084b	03		 DB	 3
  0084c	03		 DB	 3
  0084d	03		 DB	 3
  0084e	03		 DB	 3
  0084f	03		 DB	 3
  00850	03		 DB	 3
  00851	03		 DB	 3
  00852	03		 DB	 3
  00853	03		 DB	 3
  00854	03		 DB	 3
  00855	03		 DB	 3
  00856	03		 DB	 3
  00857	03		 DB	 3
  00858	03		 DB	 3
  00859	03		 DB	 3
  0085a	03		 DB	 3
  0085b	03		 DB	 3
  0085c	03		 DB	 3
  0085d	03		 DB	 3
  0085e	03		 DB	 3
  0085f	03		 DB	 3
  00860	03		 DB	 3
  00861	03		 DB	 3
  00862	03		 DB	 3
  00863	03		 DB	 3
  00864	03		 DB	 3
  00865	03		 DB	 3
  00866	03		 DB	 3
  00867	03		 DB	 3
  00868	02		 DB	 2
_cm_cmd_build_param ENDP
_pCmd_t$ = 8
_state$ = 12
_cm_cmd_reset_comm PROC NEAR

; 724  : 	int     i;
; 725  : 
; 726  : #ifdef DEBUGPARS
; 727  : 	printf("CMD_PARS: cm_cmd_reset_comm:\n");
; 728  : #endif
; 729  : 	if(state != STATE_KEEP)

  00870	8b 54 24 08	 mov	 edx, DWORD PTR _state$[esp-4]
  00874	53		 push	 ebx
  00875	33 db		 xor	 ebx, ebx
  00877	56		 push	 esi
  00878	8b 74 24 0c	 mov	 esi, DWORD PTR _pCmd_t$[esp+4]
  0087c	83 fa 06	 cmp	 edx, 6
  0087f	74 4b		 je	 SHORT $L71303
  00881	57		 push	 edi

; 730  : 	{
; 731  : 		for(i=0;i<NPARAM;i++)

  00882	8d be a8 02 00
	00		 lea	 edi, DWORD PTR [esi+680]

; 732  : 		{
; 733  : 			pCmd_t->defaults[i] = TRUE;

  00888	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0088d	b8 01 00 00 00	 mov	 eax, 1
  00892	f3 ab		 rep stosd

; 734  : 		}
; 735  : 		for(i=0; i<total_commands; i++)

  00894	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _total_commands
  0089a	33 c0		 xor	 eax, eax
  0089c	3b cb		 cmp	 ecx, ebx
  0089e	5f		 pop	 edi
  0089f	7e 15		 jle	 SHORT $L71309
$L71307:

; 736  : 		{
; 737  : 			*((pCmd_t->cm) + i) = 0;

  008a1	8b 8e e0 02 00
	00		 mov	 ecx, DWORD PTR [esi+736]
  008a7	40		 inc	 eax
  008a8	89 5c 81 fc	 mov	 DWORD PTR [ecx+eax*4-4], ebx
  008ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _total_commands
  008b2	3b c1		 cmp	 eax, ecx
  008b4	7c eb		 jl	 SHORT $L71307
$L71309:

; 738  : 		}
; 739  : 		pCmd_t->total_matches = total_commands;
; 740  : 		cm_pars_new_state(pCmd_t, state);

  008b6	52		 push	 edx
  008b7	56		 push	 esi
  008b8	89 8e e4 02 00
	00		 mov	 DWORD PTR [esi+740], ecx
  008be	e8 00 00 00 00	 call	 _cm_pars_new_state
  008c3	83 c4 08	 add	 esp, 8

; 741  : 		(pCmd_t->format_index) = 0;

  008c6	89 9e f4 04 00
	00		 mov	 DWORD PTR [esi+1268], ebx
$L71303:

; 742  : 	}
; 743  : 	pCmd_t->next_char = 0;

  008cc	89 9e f0 04 00
	00		 mov	 DWORD PTR [esi+1264], ebx

; 744  : 	pCmd_t->param_index = 0;

  008d2	89 9e d0 02 00
	00		 mov	 DWORD PTR [esi+720], ebx

; 745  : 	pCmd_t->p_flag = 0;

  008d8	89 9e d8 02 00
	00		 mov	 DWORD PTR [esi+728], ebx

; 746  : 	pCmd_t->q_flag = 0;

  008de	89 9e dc 02 00
	00		 mov	 DWORD PTR [esi+732], ebx

; 747  : 	pCmd_t->p_count = 0;

  008e4	89 9e d4 02 00
	00		 mov	 DWORD PTR [esi+724], ebx
  008ea	5e		 pop	 esi
  008eb	5b		 pop	 ebx

; 748  : }

  008ec	c3		 ret	 0
_cm_cmd_reset_comm ENDP
_TEXT	ENDS
EXTRN	_cm_cmd_sync:NEAR
EXTRN	_OpenLogFile:NEAR
EXTRN	_CloseLogFile:NEAR
EXTRN	_cm_util_dtpc_tones:NEAR
EXTRN	_cm_util_dtpc_tones_reset:NEAR
EXTRN	_cm_util_write_pipe:NEAR
EXTRN	__imp__fprintf:NEAR
EXTRN	_TextToSpeechErrorHandler:NEAR
_DATA	SEGMENT
	ORG $+2
$SG71332 DB	0aH, '[:error %Fs]', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_type$ = 12
_pipe_value$ = -8
_cm_cmd_error_comm PROC NEAR

; 766  : {

  008f0	83 ec 08	 sub	 esp, 8

; 767  : 	DT_PIPE_T pipe_value[3];
; 768  : 	char _far *es;
; 769  : #ifdef MSDOS
; 770  : 	SEQ     seq;
; 771  : #endif
; 772  :     PKSD_T pKsd_t = phTTS->pKernelShareData;
; 773  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 774  : 
; 775  : 
; 776  : 	es = (unsigned char _far *)pKsd_t->error_table[type];

  008f3	8b 4c 24 10	 mov	 ecx, DWORD PTR _type$[esp+4]
  008f7	53		 push	 ebx
  008f8	56		 push	 esi
  008f9	57		 push	 edi
  008fa	8b 7c 24 18	 mov	 edi, DWORD PTR _phTTS$[esp+16]
  008fe	8b 77 08	 mov	 esi, DWORD PTR [edi+8]

; 777  : 	switch(pCmd_t->error_mode)
; 778  : 	{

  00901	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  00904	8b 86 74 04 00
	00		 mov	 eax, DWORD PTR [esi+1140]
  0090a	8b 1c 88	 mov	 ebx, DWORD PTR [eax+ecx*4]
  0090d	8b 82 fc 04 00
	00		 mov	 eax, DWORD PTR [edx+1276]
  00913	83 f8 04	 cmp	 eax, 4
  00916	0f 87 38 01 00
	00		 ja	 $L71341
  0091c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L71385[eax*4]
$L71324:

; 779  : 		case    ERROR_ignore    :
; 780  : #ifndef MSDOS
; 781  : 			/* ETT 11/04/98 BATS#345 
; 782  : 				if we are not in [:log text on] and 
; 783  : 				the file is still open then close */
; 784  : 			if((pKsd_t->logflag & LOG_TEXT) != LOG_TEXT)

  00923	8b 86 04 02 00
	00		 mov	 eax, DWORD PTR [esi+516]
  00929	83 e0 01	 and	 eax, 1
  0092c	3c 01		 cmp	 al, 1

; 785  : 				if(phTTS->dwOutputState == STATE_OUTPUT_LOG_FILE)
; 786  : 					CloseLogFile(phTTS);		
; 787  : #endif
; 788  : 			break;

  0092e	e9 c9 00 00 00	 jmp	 $L71384
$L71327:

; 789  : 
; 790  : 		case    ERROR_text:
; 791  : #ifdef MSDOS
; 792  : 			WAIT_PRINT;
; 793  : 			/* 09/09/1996 SIK Changed %s to %Fs */
; 794  : 			/* GL 11/06/1997 for BATS#345 write to file for [:error text] command */
; 795  : 			printf("\n[:error %Fs]",es);
; 796  : 			SIGNAL_PRINT;
; 797  : #else   
; 798  : 		/* ETT: 11/04/98 BATS#345
; 799  : 			we need to check if we are in [:log text on]
; 800  : 			if we are not then open log file 
; 801  : 			then put output state back to use audio so we can still 
; 802  : 			hear. and don't close log.txt until
; 803  : 			[:log text off] or [:error *]
; 804  : 		*/
; 805  : 			if((pKsd_t->logflag & LOG_TEXT) != LOG_TEXT){	

  00933	8b 8e 04 02 00
	00		 mov	 ecx, DWORD PTR [esi+516]
  00939	83 e1 01	 and	 ecx, 1
  0093c	80 f9 01	 cmp	 cl, 1
  0093f	74 29		 je	 SHORT $L71330

; 806  : 				OpenLogFile(phTTS);

  00941	57		 push	 edi
  00942	e8 00 00 00 00	 call	 _OpenLogFile

; 807  : 				if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )

  00947	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  0094a	83 c4 04	 add	 esp, 4
  0094d	a9 00 00 00 80	 test	 eax, -2147483648	; 80000000H
  00952	75 0c		 jne	 SHORT $L71329

; 808  : 					phTTS->dwOutputState = STATE_OUTPUT_AUDIO;

  00954	c7 87 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+132], 0

; 809  : 				else

  0095e	eb 0a		 jmp	 SHORT $L71330
$L71329:

; 810  : 					phTTS->dwOutputState = STATE_OUTPUT_NULL;

  00960	c7 87 84 00 00
	00 04 00 00 00	 mov	 DWORD PTR [edi+132], 4
$L71330:

; 811  : 			}
; 812  : 			if (fprintf (phTTS->pLogFile,
; 813  : #ifdef __linux__
; 814  : 				 "\n[:error %s]", es) < 0)
; 815  : #else
; 816  : 				 "\n[:error %Fs]", es) < 0)

  0096a	8b 97 98 00 00
	00		 mov	 edx, DWORD PTR [edi+152]
  00970	53		 push	 ebx
  00971	68 00 00 00 00	 push	 OFFSET FLAT:$SG71332
  00976	52		 push	 edx
  00977	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0097d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00980	85 c0		 test	 eax, eax
  00982	0f 8d cc 00 00
	00		 jge	 $L71341

; 817  : #endif
; 818  : 			{
; 819  : 				TextToSpeechErrorHandler (phTTS,
; 820  : 										  ERROR_WRITING_FILE,
; 821  : 										  0L);

  00988	6a 00		 push	 0
  0098a	6a 05		 push	 5
  0098c	57		 push	 edi
  0098d	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  00992	83 c4 0c	 add	 esp, 12			; 0000000cH
  00995	5f		 pop	 edi
  00996	5e		 pop	 esi
  00997	5b		 pop	 ebx

; 856  : #endif
; 857  : 			break;
; 858  : 		};
; 859  : }

  00998	83 c4 08	 add	 esp, 8
  0099b	c3		 ret	 0
$L71333:

; 822  : 			} 
; 823  : #endif //MSDOS
; 824  : 			break;
; 825  :                   
; 826  : 		case    ERROR_speak:
; 827  : 			cm_cmd_sync(phTTS);

  0099c	57		 push	 edi
  0099d	e8 00 00 00 00	 call	 _cm_cmd_sync

; 828  : 			while(*es)

  009a2	8a 03		 mov	 al, BYTE PTR [ebx]
  009a4	83 c4 04	 add	 esp, 4
  009a7	84 c0		 test	 al, al
  009a9	74 27		 je	 SHORT $L71336
$L71335:

; 829  : 			{
; 830  : 				pipe_value[0] = (PFASCII<<PSFONT) + *es++;

  009ab	66 0f be c0	 movsx	 ax, al
  009af	66 89 44 24 0c	 mov	 WORD PTR _pipe_value$[esp+20], ax

; 831  :                                 cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,1);

  009b4	8b 96 d0 00 00
	00		 mov	 edx, DWORD PTR [esi+208]
  009ba	8d 4c 24 0c	 lea	 ecx, DWORD PTR _pipe_value$[esp+20]
  009be	6a 01		 push	 1
  009c0	51		 push	 ecx
  009c1	52		 push	 edx
  009c2	56		 push	 esi
  009c3	43		 inc	 ebx
  009c4	e8 00 00 00 00	 call	 _cm_util_write_pipe
  009c9	8a 03		 mov	 al, BYTE PTR [ebx]
  009cb	83 c4 10	 add	 esp, 16			; 00000010H
  009ce	84 c0		 test	 al, al
  009d0	75 d9		 jne	 SHORT $L71335
$L71336:

; 832  : 			}
; 833  : 			pipe_value[0] = (PFASCII<<PSFONT) + 0xb;

  009d2	66 c7 44 24 0c
	0b 00		 mov	 WORD PTR _pipe_value$[esp+20], 11 ; 0000000bH

; 834  :                         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,1);

  009d9	8b 8e d0 00 00
	00		 mov	 ecx, DWORD PTR [esi+208]
  009df	8d 44 24 0c	 lea	 eax, DWORD PTR _pipe_value$[esp+20]
  009e3	6a 01		 push	 1
  009e5	50		 push	 eax
  009e6	51		 push	 ecx
  009e7	56		 push	 esi
  009e8	e8 00 00 00 00	 call	 _cm_util_write_pipe

; 835  : #ifndef MSDOS
; 836  : 			/* ETT 11/04/98 BATS#345 
; 837  : 				if we are not in [:log text on] and 
; 838  : 				the file is still open then close */
; 839  : 			if((pKsd_t->logflag & LOG_TEXT) != LOG_TEXT)

  009ed	8b 96 04 02 00
	00		 mov	 edx, DWORD PTR [esi+516]
  009f3	83 c4 10	 add	 esp, 16			; 00000010H
  009f6	83 e2 01	 and	 edx, 1
  009f9	80 fa 01	 cmp	 dl, 1
$L71384:
  009fc	74 56		 je	 SHORT $L71341

; 840  : 				if(phTTS->dwOutputState == STATE_OUTPUT_LOG_FILE)

  009fe	83 bf 84 00 00
	00 03		 cmp	 DWORD PTR [edi+132], 3
  00a05	75 4d		 jne	 SHORT $L71341

; 855  : 					CloseLogFile(phTTS);		

  00a07	57		 push	 edi
  00a08	e8 00 00 00 00	 call	 _CloseLogFile
  00a0d	83 c4 04	 add	 esp, 4
  00a10	5f		 pop	 edi
  00a11	5e		 pop	 esi
  00a12	5b		 pop	 ebx

; 856  : #endif
; 857  : 			break;
; 858  : 		};
; 859  : }

  00a13	83 c4 08	 add	 esp, 8
  00a16	c3		 ret	 0
$L71339:

; 841  : 					CloseLogFile(phTTS);		
; 842  : #endif
; 843  : 			break;
; 844  : 
; 845  : 		case    ERROR_tone:
; 846  : 			cm_cmd_sync(phTTS);

  00a17	57		 push	 edi
  00a18	e8 00 00 00 00	 call	 _cm_cmd_sync

; 847  : 			cm_util_dtpc_tones(phTTS,0,697,100);

  00a1d	6a 64		 push	 100			; 00000064H
  00a1f	68 b9 02 00 00	 push	 697			; 000002b9H
  00a24	6a 00		 push	 0
  00a26	57		 push	 edi
  00a27	e8 00 00 00 00	 call	 _cm_util_dtpc_tones

; 848  : 			cm_util_dtpc_tones_reset(phTTS);

  00a2c	57		 push	 edi
  00a2d	e8 00 00 00 00	 call	 _cm_util_dtpc_tones_reset

; 849  : #ifndef MSDOS
; 850  : 			/* ETT 11/04/98 BATS#345 
; 851  : 				if we are not in [:log text on] and 
; 852  : 				the file is still open then close */
; 853  : 			if((pKsd_t->logflag & LOG_TEXT) != LOG_TEXT)

  00a32	8b 86 04 02 00
	00		 mov	 eax, DWORD PTR [esi+516]
  00a38	83 c4 18	 add	 esp, 24			; 00000018H
  00a3b	83 e0 01	 and	 eax, 1
  00a3e	3c 01		 cmp	 al, 1
  00a40	74 12		 je	 SHORT $L71341

; 854  : 				if(phTTS->dwOutputState == STATE_OUTPUT_LOG_FILE)

  00a42	83 bf 84 00 00
	00 03		 cmp	 DWORD PTR [edi+132], 3
  00a49	75 09		 jne	 SHORT $L71341

; 855  : 					CloseLogFile(phTTS);		

  00a4b	57		 push	 edi
  00a4c	e8 00 00 00 00	 call	 _CloseLogFile
  00a51	83 c4 04	 add	 esp, 4
$L71341:
  00a54	5f		 pop	 edi
  00a55	5e		 pop	 esi
  00a56	5b		 pop	 ebx

; 856  : #endif
; 857  : 			break;
; 858  : 		};
; 859  : }

  00a57	83 c4 08	 add	 esp, 8
  00a5a	c3		 ret	 0
  00a5b	90		 npad	 1
$L71385:
  00a5c	00 00 00 00	 DD	 $L71324
  00a60	00 00 00 00	 DD	 $L71327
  00a64	00 00 00 00	 DD	 $L71341
  00a68	00 00 00 00	 DD	 $L71333
  00a6c	00 00 00 00	 DD	 $L71339
_cm_cmd_error_comm ENDP
_TEXT	ENDS
END
