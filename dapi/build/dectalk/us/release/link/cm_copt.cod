	TITLE	D:\work\product\dapi\src\Cmd\cm_copt.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_total_commands
PUBLIC	_command_table
PUBLIC	_cm_cmd_rate
PUBLIC	_cm_cmd_name
PUBLIC	_cm_cmd_latin
PUBLIC	_cm_cmd_comma
PUBLIC	_cm_cmd_period
PUBLIC	_cm_cmd_volume
PUBLIC	_cm_cmd_mark
PUBLIC	_cm_cmd_error
PUBLIC	_cm_cmd_phoneme
PUBLIC	_cm_cmd_log
PUBLIC	_cm_cmd_mode
PUBLIC	_cm_cmd_punct
PUBLIC	_cm_cmd_skip
PUBLIC	_cm_cmd_pause
PUBLIC	_cm_cmd_resume
PUBLIC	_cm_cmd_sync
PUBLIC	_cm_cmd_dial
PUBLIC	_cm_cmd_tone
PUBLIC	_cm_cmd_define
PUBLIC	_cm_cmd_say
PUBLIC	_cm_cmd_pronounce
PUBLIC	_cm_cmd_stress
PUBLIC	_cm_cmd_debug
PUBLIC	_cm_cmd_gender
PUBLIC	_cm_cmd_setv
PUBLIC	_cm_cmd_loadv
PUBLIC	_cm_cmd_vs
PUBLIC	_phoneme_modes
PUBLIC	_log_options
PUBLIC	_say_options
PUBLIC	_error_options
PUBLIC	_flush_options
PUBLIC	_punct_options
PUBLIC	_skip_options
PUBLIC	_volume_options
PUBLIC	_lang_options
PUBLIC	_mode_options
PUBLIC	_pronounce_options
PUBLIC	_voice_names
PUBLIC	_index_options
PUBLIC	_gender_options
PUBLIC	_define_options
EXTRN	_cm_cmd_play:NEAR
_BSS	SEGMENT
$SG71324 DB	01H DUP (?)
	ALIGN	4

$SG71326 DB	01H DUP (?)
	ALIGN	4

$SG71328 DB	01H DUP (?)
	ALIGN	4

$SG71330 DB	01H DUP (?)
	ALIGN	4

$SG71332 DB	01H DUP (?)
	ALIGN	4

$SG71334 DB	01H DUP (?)
	ALIGN	4

$SG71336 DB	01H DUP (?)
	ALIGN	4

$SG71338 DB	01H DUP (?)
	ALIGN	4

$SG71340 DB	01H DUP (?)
	ALIGN	4

$SG71342 DB	01H DUP (?)
	ALIGN	4

$SG71376 DB	01H DUP (?)
	ALIGN	4

$SG71378 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_phoneme_modes DD FLAT:$SG71170
	DD	FLAT:$SG71171
	DD	FLAT:$SG71172
	DD	FLAT:$SG71173
	DD	FLAT:$SG71174
	DD	FLAT:$SG71175
	DD	00H
_log_options DD	FLAT:$SG71177
	DD	FLAT:$SG71178
	DD	FLAT:$SG71179
	DD	FLAT:$SG71180
	DD	FLAT:$SG71181
	DD	FLAT:$SG71182
	DD	FLAT:$SG71183
	DD	FLAT:$SG71184
	DD	FLAT:$SG71185
	DD	FLAT:$SG71186
	DD	00H
_say_options DD	FLAT:$SG71188
	DD	FLAT:$SG71189
	DD	FLAT:$SG71190
	DD	FLAT:$SG71191
	DD	FLAT:$SG71192
	DD	FLAT:$SG71193
	DD	00H
_error_options DD FLAT:$SG71195
	DD	FLAT:$SG71196
	DD	FLAT:$SG71197
	DD	FLAT:$SG71198
	DD	FLAT:$SG71199
	DD	00H
_flush_options DD FLAT:$SG71201
	DD	FLAT:$SG71202
	DD	FLAT:$SG71203
	DD	FLAT:$SG71204
	DD	FLAT:$SG71205
	DD	00H
_punct_options DD FLAT:$SG71207
	DD	FLAT:$SG71208
	DD	FLAT:$SG71209
	DD	FLAT:$SG71210
	DD	00H
_skip_options DD FLAT:$SG71212
	DD	FLAT:$SG71213
	DD	FLAT:$SG71214
	DD	FLAT:$SG71215
	DD	FLAT:$SG71216
	DD	FLAT:$SG71217
	DD	00H
_volume_options DD FLAT:$SG71219
	DD	FLAT:$SG71220
	DD	FLAT:$SG71221
	DD	FLAT:$SG71222
	DD	FLAT:$SG71223
	DD	FLAT:$SG71224
	DD	FLAT:$SG71225
	DD	FLAT:$SG71226
	DD	FLAT:$SG71227
	DD	FLAT:$SG71228
	DD	00H
_lang_options DD FLAT:$SG71230
	DD	FLAT:$SG71231
	DD	FLAT:$SG71232
	DD	FLAT:$SG71233
	DD	FLAT:$SG71234
	DD	FLAT:$SG71235
	DD	FLAT:$SG71236
	DD	FLAT:$SG71237
	DD	FLAT:$SG71238
	DD	FLAT:$SG71239
	DD	FLAT:$SG71240
	DD	FLAT:$SG71241
	DD	00H
_mode_options DD FLAT:$SG71243
	DD	FLAT:$SG71244
	DD	FLAT:$SG71245
	DD	FLAT:$SG71246
	DD	FLAT:$SG71247
	DD	FLAT:$SG71248
	DD	FLAT:$SG71249
	DD	FLAT:$SG71250
	DD	FLAT:$SG71251
	DD	FLAT:$SG71252
	DD	FLAT:$SG71253
	DD	FLAT:$SG71254
	DD	00H
_pronounce_options DD FLAT:$SG71256
	DD	FLAT:$SG71257
	DD	FLAT:$SG71258
	DD	00H
_voice_names DD	FLAT:$SG71260
	DD	FLAT:$SG71261
	DD	FLAT:$SG71262
	DD	FLAT:$SG71263
	DD	FLAT:$SG71264
	DD	FLAT:$SG71265
	DD	FLAT:$SG71266
	DD	FLAT:$SG71267
	DD	FLAT:$SG71268
	DD	FLAT:$SG71269
	DD	00H
_index_options DD FLAT:$SG71271
	DD	FLAT:$SG71272
	DD	FLAT:$SG71273
	DD	FLAT:$SG71274
	DD	FLAT:$SG71275
	DD	FLAT:$SG71276
	DD	FLAT:$SG71277
	DD	FLAT:$SG71278
	DD	00H
_gender_options DD FLAT:$SG71280
	DD	FLAT:$SG71281
	DD	FLAT:$SG71282
	DD	00H
_define_options DD FLAT:$SG71284
	DD	FLAT:$SG71285
	DD	FLAT:$SG71286
	DD	FLAT:$SG71287
	DD	FLAT:$SG71288
	DD	FLAT:$SG71289
	DD	FLAT:$SG71290
	DD	FLAT:$SG71291
	DD	FLAT:$SG71292
	DD	FLAT:$SG71293
	DD	FLAT:$SG71294
	DD	FLAT:$SG71295
	DD	FLAT:$SG71296
	DD	FLAT:$SG71297
	DD	FLAT:$SG71298
	DD	FLAT:$SG71299
	DD	FLAT:$SG71300
	DD	FLAT:$SG71301
	DD	FLAT:$SG71302
	DD	FLAT:$SG71303
	DD	FLAT:$SG71304
	DD	FLAT:$SG71305
	DD	FLAT:$SG71306
	DD	FLAT:$SG71307
	DD	FLAT:$SG71308
	DD	FLAT:$SG71309
	DD	FLAT:$SG71310
	DD	FLAT:$SG71311
	DD	FLAT:$SG71312
	DD	FLAT:$SG71313
	DD	FLAT:$SG71314
	DD	FLAT:$SG71315
	DD	FLAT:$SG71316
	DD	00H
_command_table DD FLAT:$SG71317
	DD	FLAT:$SG71318
	DD	01H
	DD	0c8H
	DD	FLAT:_cm_cmd_rate
	DD	FLAT:$SG71319
	DD	FLAT:$SG71320
	DD	01H
	DD	0800aH
	DD	FLAT:_cm_cmd_latin
	DD	FLAT:$SG71321
	DD	FLAT:$SG71322
	DD	01H
	DD	0c9H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71323
	DD	FLAT:$SG71324
	DD	00H
	DD	08000H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71325
	DD	FLAT:$SG71326
	DD	00H
	DD	08001H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71327
	DD	FLAT:$SG71328
	DD	00H
	DD	08002H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71329
	DD	FLAT:$SG71330
	DD	00H
	DD	08003H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71331
	DD	FLAT:$SG71332
	DD	00H
	DD	08004H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71333
	DD	FLAT:$SG71334
	DD	00H
	DD	08005H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71335
	DD	FLAT:$SG71336
	DD	00H
	DD	08006H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71337
	DD	FLAT:$SG71338
	DD	00H
	DD	08007H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71339
	DD	FLAT:$SG71340
	DD	00H
	DD	08008H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71341
	DD	FLAT:$SG71342
	DD	00H
	DD	08009H
	DD	FLAT:_cm_cmd_name
	DD	FLAT:$SG71343
	DD	FLAT:$SG71344
	DD	01H
	DD	0caH
	DD	FLAT:_cm_cmd_comma
	DD	FLAT:$SG71345
	DD	FLAT:$SG71346
	DD	01H
	DD	0caH
	DD	FLAT:_cm_cmd_comma
	DD	FLAT:$SG71347
	DD	FLAT:$SG71348
	DD	01H
	DD	0cbH
	DD	FLAT:_cm_cmd_period
	DD	FLAT:$SG71349
	DD	FLAT:$SG71350
	DD	01H
	DD	0cbH
	DD	FLAT:_cm_cmd_period
	DD	FLAT:$SG71351
	DD	FLAT:$SG71352
	DD	03H
	DD	064H
	DD	FLAT:_cm_cmd_volume
	DD	FLAT:$SG71353
	DD	FLAT:$SG71354
	DD	01H
	DD	00H
	DD	FLAT:_cm_cmd_vs
	DD	FLAT:$SG71355
	DD	FLAT:$SG71356
	DD	02H
	DD	014H
	DD	FLAT:_cm_cmd_mark
	DD	FLAT:$SG71357
	DD	FLAT:$SG71358
	DD	01H
	DD	012cH
	DD	FLAT:_cm_cmd_error
	DD	FLAT:$SG71359
	DD	FLAT:$SG71360
	DD	03H
	DD	0258H
	DD	FLAT:_cm_cmd_phoneme
	DD	FLAT:$SG71361
	DD	FLAT:$SG71362
	DD	02H
	DD	051H
	DD	FLAT:_cm_cmd_log
	DD	FLAT:$SG71363
	DD	FLAT:$SG71364
	DD	02H
	DD	050H
	DD	FLAT:_cm_cmd_mode
	DD	FLAT:$SG71365
	DD	FLAT:$SG71366
	DD	01H
	DD	052H
	DD	FLAT:_cm_cmd_say
	DD	FLAT:$SG71367
	DD	FLAT:$SG71368
	DD	01H
	DD	0ccH
	DD	FLAT:_cm_cmd_punct
	DD	FLAT:$SG71369
	DD	FLAT:$SG71370
	DD	01H
	DD	00H
	DD	FLAT:_cm_cmd_skip
	DD	FLAT:$SG71371
	DD	FLAT:$SG71372
	DD	01H
	DD	0cH
	DD	FLAT:_cm_cmd_pause
	DD	FLAT:$SG71373
	DD	FLAT:$SG71374
	DD	01H
	DD	00H
	DD	FLAT:_cm_cmd_play
	DD	FLAT:$SG71375
	DD	FLAT:$SG71376
	DD	00H
	DD	0dH
	DD	FLAT:_cm_cmd_resume
	DD	FLAT:$SG71377
	DD	FLAT:$SG71378
	DD	00H
	DD	0bH
	DD	FLAT:_cm_cmd_sync
	DD	FLAT:$SG71379
	DD	FLAT:$SG71380
	DD	01H
	DD	0190H
	DD	FLAT:_cm_cmd_dial
	DD	FLAT:$SG71381
	DD	FLAT:$SG71382
	DD	01H
	DD	0191H
	DD	FLAT:_cm_cmd_tone
	DD	FLAT:$SG71383
	DD	FLAT:$SG71384
	DD	02H
	DD	02bcH
	DD	FLAT:_cm_cmd_pronounce
	DD	FLAT:$SG71385
	DD	FLAT:$SG71386
	DD	01H
	DD	04b0H
	DD	FLAT:_cm_cmd_stress
	DD	FLAT:$SG71387
	DD	FLAT:$SG71388
	DD	02H
	DD	01f4H
	DD	FLAT:_cm_cmd_define
	DD	FLAT:$SG71389
	DD	FLAT:$SG71390
	DD	02H
	DD	01f4H
	DD	FLAT:_cm_cmd_define
	DD	FLAT:$SG71391
	DD	FLAT:$SG71392
	DD	01H
	DD	00H
	DD	FLAT:_cm_cmd_debug
	DD	FLAT:$SG71393
	DD	FLAT:$SG71394
	DD	01H
	DD	00H
	DD	FLAT:_cm_cmd_setv
	DD	FLAT:$SG71395
	DD	FLAT:$SG71396
	DD	01H
	DD	00H
	DD	FLAT:_cm_cmd_loadv
	DD	FLAT:$SG71397
	DD	FLAT:$SG71398
	DD	01H
	DD	00H
	DD	FLAT:_cm_cmd_gender
_total_commands DD 029H
$SG71170 DB	'asky', 00H
	ORG $+3
$SG71171 DB	'arpabet', 00H
$SG71172 DB	'speak', 00H
	ORG $+2
$SG71173 DB	'silent', 00H
	ORG $+1
$SG71174 DB	'off', 00H
$SG71175 DB	'on', 00H
	ORG $+1
$SG71177 DB	'text', 00H
	ORG $+3
$SG71178 DB	'phonemes', 00H
	ORG $+3
$SG71179 DB	'types', 00H
	ORG $+2
$SG71180 DB	'forms', 00H
	ORG $+2
$SG71181 DB	'syllables', 00H
	ORG $+2
$SG71182 DB	'outphon', 00H
$SG71183 DB	'dbglog', 00H
	ORG $+1
$SG71184 DB	'on', 00H
	ORG $+1
$SG71185 DB	'off', 00H
$SG71186 DB	'set', 00H
$SG71188 DB	'clause', 00H
	ORG $+1
$SG71189 DB	'word', 00H
	ORG $+3
$SG71190 DB	'letter', 00H
	ORG $+1
$SG71191 DB	'filtered_letter', 00H
$SG71192 DB	'line', 00H
	ORG $+3
$SG71193 DB	'syllable', 00H
	ORG $+3
$SG71195 DB	'ignore', 00H
	ORG $+1
$SG71196 DB	'text', 00H
	ORG $+3
$SG71197 DB	'escape', 00H
	ORG $+1
$SG71198 DB	'speak', 00H
	ORG $+2
$SG71199 DB	'tone', 00H
	ORG $+3
$SG71201 DB	'all', 00H
$SG71202 DB	'until', 00H
	ORG $+2
$SG71203 DB	'mask', 00H
	ORG $+3
$SG71204 DB	'after', 00H
	ORG $+2
$SG71205 DB	'speech', 00H
	ORG $+1
$SG71207 DB	'none', 00H
	ORG $+3
$SG71208 DB	'some', 00H
	ORG $+3
$SG71209 DB	'all', 00H
$SG71210 DB	'pass', 00H
	ORG $+3
$SG71212 DB	'none', 00H
	ORG $+3
$SG71213 DB	'email', 00H
	ORG $+2
$SG71214 DB	'punct', 00H
	ORG $+2
$SG71215 DB	'rule', 00H
	ORG $+3
$SG71216 DB	'all', 00H
$SG71217 DB	'cpg', 00H
$SG71219 DB	'set', 00H
$SG71220 DB	'up', 00H
	ORG $+1
$SG71221 DB	'down', 00H
	ORG $+3
$SG71222 DB	'lset', 00H
	ORG $+3
$SG71223 DB	'lup', 00H
$SG71224 DB	'ldown', 00H
	ORG $+2
$SG71225 DB	'rset', 00H
	ORG $+3
$SG71226 DB	'rup', 00H
$SG71227 DB	'rdown', 00H
	ORG $+2
$SG71228 DB	'sset', 00H
	ORG $+3
$SG71230 DB	'english', 00H
$SG71231 DB	'british', 00H
$SG71232 DB	'french', 00H
	ORG $+1
$SG71233 DB	'german', 00H
	ORG $+1
$SG71234 DB	'spanish', 00H
$SG71235 DB	'latin_amercian', 00H
	ORG $+1
$SG71236 DB	'us', 00H
	ORG $+1
$SG71237 DB	'uk', 00H
	ORG $+1
$SG71238 DB	'fr', 00H
	ORG $+1
$SG71239 DB	'gr', 00H
	ORG $+1
$SG71240 DB	'sp', 00H
	ORG $+1
$SG71241 DB	'la', 00H
	ORG $+1
$SG71243 DB	'math', 00H
	ORG $+3
$SG71244 DB	'europe', 00H
	ORG $+1
$SG71245 DB	'spell', 00H
	ORG $+2
$SG71246 DB	'name', 00H
	ORG $+3
$SG71247 DB	'homograph', 00H
	ORG $+2
$SG71248 DB	'citation', 00H
	ORG $+3
$SG71249 DB	'latin', 00H
	ORG $+2
$SG71250 DB	'table', 00H
	ORG $+2
$SG71251 DB	'email', 00H
	ORG $+2
$SG71252 DB	'on', 00H
	ORG $+1
$SG71253 DB	'off', 00H
$SG71254 DB	'set', 00H
$SG71256 DB	'alternate', 00H
	ORG $+2
$SG71257 DB	'name', 00H
	ORG $+3
$SG71258 DB	'primary', 00H
$SG71260 DB	'paul', 00H
	ORG $+3
$SG71261 DB	'betty', 00H
	ORG $+2
$SG71262 DB	'harry', 00H
	ORG $+2
$SG71263 DB	'frank', 00H
	ORG $+2
$SG71264 DB	'dennis', 00H
	ORG $+1
$SG71265 DB	'kit', 00H
$SG71266 DB	'ursula', 00H
	ORG $+1
$SG71267 DB	'rita', 00H
	ORG $+3
$SG71268 DB	'wendy', 00H
	ORG $+2
$SG71269 DB	'val', 00H
$SG71271 DB	'mark', 00H
	ORG $+3
$SG71272 DB	'reply', 00H
	ORG $+2
$SG71273 DB	'query', 00H
	ORG $+2
$SG71274 DB	'pause', 00H
	ORG $+2
$SG71275 DB	'bookmark', 00H
	ORG $+3
$SG71276 DB	'wordpos', 00H
$SG71277 DB	'start', 00H
	ORG $+2
$SG71278 DB	'stop', 00H
	ORG $+3
$SG71280 DB	'masculine', 00H
	ORG $+2
$SG71281 DB	'neuter', 00H
	ORG $+1
$SG71282 DB	'feminine', 00H
	ORG $+3
$SG71284 DB	'save', 00H
	ORG $+3
$SG71285 DB	'sx', 00H
	ORG $+1
$SG71286 DB	'sm', 00H
	ORG $+1
$SG71287 DB	'as', 00H
	ORG $+1
$SG71288 DB	'ap', 00H
	ORG $+1
$SG71289 DB	'pr', 00H
	ORG $+1
$SG71290 DB	'br', 00H
	ORG $+1
$SG71291 DB	'ri', 00H
	ORG $+1
$SG71292 DB	'nf', 00H
	ORG $+1
$SG71293 DB	'la', 00H
	ORG $+1
$SG71294 DB	'hs', 00H
	ORG $+1
$SG71295 DB	'f4', 00H
	ORG $+1
$SG71296 DB	'b4', 00H
	ORG $+1
$SG71297 DB	'f5', 00H
	ORG $+1
$SG71298 DB	'b5', 00H
	ORG $+1
$SG71299 DB	'f7', 00H
	ORG $+1
$SG71300 DB	'f8', 00H
	ORG $+1
$SG71301 DB	'gf', 00H
	ORG $+1
$SG71302 DB	'gh', 00H
	ORG $+1
$SG71303 DB	'gv', 00H
	ORG $+1
$SG71304 DB	'gn', 00H
	ORG $+1
$SG71305 DB	'g1', 00H
	ORG $+1
$SG71306 DB	'g2', 00H
	ORG $+1
$SG71307 DB	'g3', 00H
	ORG $+1
$SG71308 DB	'g4', 00H
	ORG $+1
$SG71309 DB	'g5', 00H
	ORG $+1
$SG71310 DB	'ft', 00H
	ORG $+1
$SG71311 DB	'bf', 00H
	ORG $+1
$SG71312 DB	'lx', 00H
	ORG $+1
$SG71313 DB	'qu', 00H
	ORG $+1
$SG71314 DB	'hr', 00H
	ORG $+1
$SG71315 DB	'sr', 00H
	ORG $+1
$SG71316 DB	'gs', 00H
	ORG $+1
$SG71317 DB	'rate', 00H
	ORG $+3
$SG71318 DB	'd', 00H
	ORG $+2
$SG71319 DB	'latin', 00H
	ORG $+2
$SG71320 DB	'd', 00H
	ORG $+2
$SG71321 DB	'name', 00H
	ORG $+3
$SG71322 DB	'a', 00H
	ORG $+2
$SG71323 DB	'np', 00H
	ORG $+1
$SG71325 DB	'nb', 00H
	ORG $+1
$SG71327 DB	'nh', 00H
	ORG $+1
$SG71329 DB	'nf', 00H
	ORG $+1
$SG71331 DB	'nd', 00H
	ORG $+1
$SG71333 DB	'nk', 00H
	ORG $+1
$SG71335 DB	'nu', 00H
	ORG $+1
$SG71337 DB	'nr', 00H
	ORG $+1
$SG71339 DB	'nw', 00H
	ORG $+1
$SG71341 DB	'nv', 00H
	ORG $+1
$SG71343 DB	'comma', 00H
	ORG $+2
$SG71344 DB	'd', 00H
	ORG $+2
$SG71345 DB	'cp', 00H
	ORG $+1
$SG71346 DB	'd', 00H
	ORG $+2
$SG71347 DB	'period', 00H
	ORG $+1
$SG71348 DB	'd', 00H
	ORG $+2
$SG71349 DB	'pp', 00H
	ORG $+1
$SG71350 DB	'd', 00H
	ORG $+2
$SG71351 DB	'volume', 00H
	ORG $+1
$SG71352 DB	'add', 00H
$SG71353 DB	'vs', 00H
	ORG $+1
$SG71354 DB	'd', 00H
	ORG $+2
$SG71355 DB	'index', 00H
	ORG $+2
$SG71356 DB	'add', 00H
$SG71357 DB	'error', 00H
	ORG $+2
$SG71358 DB	'a', 00H
	ORG $+2
$SG71359 DB	'phoneme', 00H
$SG71360 DB	'aaa', 00H
$SG71361 DB	'log', 00H
$SG71362 DB	'aa', 00H
	ORG $+1
$SG71363 DB	'mode', 00H
	ORG $+3
$SG71364 DB	'aa', 00H
	ORG $+1
$SG71365 DB	'say', 00H
$SG71366 DB	'a', 00H
	ORG $+2
$SG71367 DB	'punctuation', 00H
$SG71368 DB	'a', 00H
	ORG $+2
$SG71369 DB	'skip', 00H
	ORG $+3
$SG71370 DB	'a', 00H
	ORG $+2
$SG71371 DB	'pause', 00H
	ORG $+2
$SG71372 DB	'd', 00H
	ORG $+2
$SG71373 DB	'play', 00H
	ORG $+3
$SG71374 DB	'a', 00H
	ORG $+2
$SG71375 DB	'resume', 00H
	ORG $+1
$SG71377 DB	'sync', 00H
	ORG $+3
$SG71379 DB	'dial', 00H
	ORG $+3
$SG71380 DB	'a', 00H
	ORG $+2
$SG71381 DB	'tone', 00H
	ORG $+3
$SG71382 DB	'dd', 00H
	ORG $+1
$SG71383 DB	'pronounce', 00H
	ORG $+2
$SG71384 DB	'aa', 00H
	ORG $+1
$SG71385 DB	'pitch', 00H
	ORG $+2
$SG71386 DB	'd', 00H
	ORG $+2
$SG71387 DB	'define_voice', 00H
	ORG $+3
$SG71388 DB	'ad*', 00H
$SG71389 DB	'dv', 00H
	ORG $+1
$SG71390 DB	'ad*', 00H
$SG71391 DB	'debug', 00H
	ORG $+2
$SG71392 DB	'h', 00H
	ORG $+2
$SG71393 DB	'setv', 00H
	ORG $+3
$SG71394 DB	'd', 00H
	ORG $+2
$SG71395 DB	'loadv', 00H
	ORG $+2
$SG71396 DB	'd', 00H
	ORG $+2
$SG71397 DB	'gender', 00H
	ORG $+1
$SG71398 DB	'a', 00H
_DATA	ENDS
EXTRN	_cm_util_string_match:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_cm_cmd_phoneme PROC NEAR

; 181  : 	int     value, i;
; 182  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp
  00006	56		 push	 esi
  00007	8b 68 0c	 mov	 ebp, DWORD PTR [eax+12]

; 183  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;	

  0000a	8b 70 08	 mov	 esi, DWORD PTR [eax+8]

; 184  : 	for(i=0; i < (int)(pCmd_t->param_index); i++)

  0000d	33 db		 xor	 ebx, ebx
  0000f	57		 push	 edi
  00010	8b 85 d0 02 00
	00		 mov	 eax, DWORD PTR [ebp+720]
  00016	85 c0		 test	 eax, eax
  00018	7e 77		 jle	 SHORT $L71429

; 181  : 	int     value, i;
; 182  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  0001a	8d bd 80 02 00
	00		 lea	 edi, DWORD PTR [ebp+640]
$L71427:

; 185  : 	{
; 186  : 		value = cm_util_string_match(phoneme_modes,pCmd_t->pString[i]);

  00020	8b 07		 mov	 eax, DWORD PTR [edi]
  00022	50		 push	 eax
  00023	68 00 00 00 00	 push	 OFFSET FLAT:_phoneme_modes
  00028	e8 00 00 00 00	 call	 _cm_util_string_match
  0002d	83 c4 08	 add	 esp, 8

; 187  : 		if(value == NO_STRING_MATCH)

  00030	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00035	74 61		 je	 SHORT $L72018

; 190  : 		}
; 191  : 		switch(value)
; 192  : 		{         

  00037	83 f8 05	 cmp	 eax, 5
  0003a	77 66		 ja	 SHORT $L71441
  0003c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72021[eax*4]
$L71435:

; 193  : 			case 0:
; 194  : 				pKsd_t->phoneme_mode |= PHONEME_ASCKY; break;   /* ascky */

  00043	8b 86 10 02 00
	00		 mov	 eax, DWORD PTR [esi+528]
  00049	0c 02		 or	 al, 2
  0004b	eb 30		 jmp	 SHORT $L72020
$L71436:

; 195  : 				break;
; 196  : 			case 1: 
; 197  : 				pKsd_t->phoneme_mode &= (~PHONEME_ASCKY); break;/* arpa */

  0004d	8b 86 10 02 00
	00		 mov	 eax, DWORD PTR [esi+528]
  00053	24 fd		 and	 al, -3			; fffffffdH
  00055	eb 26		 jmp	 SHORT $L72020
$L71437:

; 198  : 				break;
; 199  : 			case 2:       
; 200  : 				pKsd_t->phoneme_mode |= PHONEME_SPEAK; break;   /* speak */ 

  00057	8b 86 10 02 00
	00		 mov	 eax, DWORD PTR [esi+528]
  0005d	0c 04		 or	 al, 4
  0005f	eb 1c		 jmp	 SHORT $L72020
$L71438:

; 201  : 				break;
; 202  : 			case 3:       
; 203  : 				pKsd_t->phoneme_mode &= (~PHONEME_SPEAK); break;/* silent */

  00061	8b 86 10 02 00
	00		 mov	 eax, DWORD PTR [esi+528]
  00067	24 fb		 and	 al, -5			; fffffffbH
  00069	eb 12		 jmp	 SHORT $L72020
$L71439:

; 204  : 				break;
; 205  : 			case 4:       
; 206  : 				pKsd_t->phoneme_mode |= PHONEME_OFF; break;     /* off */

  0006b	8b 86 10 02 00
	00		 mov	 eax, DWORD PTR [esi+528]
  00071	0c 01		 or	 al, 1
  00073	eb 08		 jmp	 SHORT $L72020
$L71440:

; 207  : 				break;
; 208  : 			case 5:       
; 209  : 				pKsd_t->phoneme_mode &= (~PHONEME_OFF); break;  /* on */

  00075	8b 86 10 02 00
	00		 mov	 eax, DWORD PTR [esi+528]
  0007b	24 fe		 and	 al, -2			; fffffffeH
$L72020:
  0007d	89 86 10 02 00
	00		 mov	 DWORD PTR [esi+528], eax
  00083	8b 85 d0 02 00
	00		 mov	 eax, DWORD PTR [ebp+720]
  00089	43		 inc	 ebx
  0008a	83 c7 04	 add	 edi, 4
  0008d	3b d8		 cmp	 ebx, eax
  0008f	7c 8f		 jl	 SHORT $L71427
$L71429:
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5d		 pop	 ebp

; 213  : 		}  /* Matches switch(value) */
; 214  : 	} /* Matches for(i=0; i < (int)param_index; i++) */
; 215  : 	return(CMD_success);

  00094	33 c0		 xor	 eax, eax
  00096	5b		 pop	 ebx

; 216  : }     

  00097	c3		 ret	 0
$L72018:
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5d		 pop	 ebp

; 188  : 		{
; 189  : 			return(CMD_bad_string);

  0009b	b8 01 00 00 00	 mov	 eax, 1
  000a0	5b		 pop	 ebx

; 216  : }     

  000a1	c3		 ret	 0
$L71441:
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5d		 pop	 ebp

; 210  : 				break;
; 211  : 			default:
; 212  : 				return(CMD_bad_param);    

  000a5	b8 04 00 00 00	 mov	 eax, 4
  000aa	5b		 pop	 ebx

; 216  : }     

  000ab	c3		 ret	 0
$L72021:
  000ac	00 00 00 00	 DD	 $L71435
  000b0	00 00 00 00	 DD	 $L71436
  000b4	00 00 00 00	 DD	 $L71437
  000b8	00 00 00 00	 DD	 $L71438
  000bc	00 00 00 00	 DD	 $L71439
  000c0	00 00 00 00	 DD	 $L71440
_cm_cmd_phoneme ENDP
_TEXT	ENDS
PUBLIC	_OpenLogFile
PUBLIC	_CloseLogFile
_TEXT	SEGMENT
_phTTS$ = 8
_pCmd_t$ = 8
_cm_cmd_log PROC NEAR

; 240  : {

  000d0	53		 push	 ebx

; 241  : 	int i, value;
; 242  : 
; 243  : #ifdef DEBUGPARS
; 244  : 	int	p, q;
; 245  : #endif
; 246  : 	unsigned int flag_mask;
; 247  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  000d1	8b 5c 24 08	 mov	 ebx, DWORD PTR _phTTS$[esp]
  000d5	55		 push	 ebp
  000d6	56		 push	 esi

; 248  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  000d7	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000da	8b 6b 08	 mov	 ebp, DWORD PTR [ebx+8]
  000dd	57		 push	 edi

; 249  : 	
; 250  : #ifndef MSDOS
; 251  : 	if(cm_cmd_sync(phTTS) == CMD_flushing)

  000de	53		 push	 ebx
  000df	89 44 24 18	 mov	 DWORD PTR _pCmd_t$[esp+16], eax
  000e3	e8 00 00 00 00	 call	 _cm_cmd_sync
  000e8	83 c4 04	 add	 esp, 4
  000eb	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  000ee	75 05		 jne	 SHORT $L71450
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	5d		 pop	 ebp
  000f3	5b		 pop	 ebx

; 387  : }

  000f4	c3		 ret	 0
$L71450:

; 252  : 	  return(CMD_flushing);
; 253  : #endif
; 254  : 	
; 255  : 	flag_mask = 0;
; 256  : 	for(i=0; i < (int)pCmd_t->param_index; i++)

  000f5	8b 4c 24 14	 mov	 ecx, DWORD PTR _pCmd_t$[esp+12]
  000f9	33 f6		 xor	 esi, esi
  000fb	33 ff		 xor	 edi, edi
  000fd	8b 81 d0 02 00
	00		 mov	 eax, DWORD PTR [ecx+720]
  00103	85 c0		 test	 eax, eax
  00105	0f 8e 04 01 00
	00		 jle	 $L71454
$L71452:

; 257  : 	{
; 258  : 		/*
; 259  : 		 * 3/6/96 SIK This command only takes 2 parameters:  TEXT, FORMS, PHONEME, TYPES, SYLLABLES, 
; 260  : 		 * OUTPHON followed by ON
; 261  : 		 * OFF or SET
; 262  : 		 */
; 263  : #ifdef DEBUGPARS
; 264  : 		for (p=0;log_options[p];p++)
; 265  : 		{
; 266  : 			putc('l');
; 267  : 			putc('o');
; 268  : 			putc('g');
; 269  : 			putc('=');
; 270  : 			for (q=0;log_options[p][q];q++)
; 271  : 			{
; 272  : 				putc(log_options[p][q]);
; 273  : 			}
; 274  : 			putc('\n');
; 275  : 			putc('\r');
; 276  : 		}
; 277  : #endif
; 278  : 			     
; 279  : 		value = cm_util_string_match(log_options,pCmd_t->pString[i]);

  0010b	8b 54 24 14	 mov	 edx, DWORD PTR _pCmd_t$[esp+12]
  0010f	8b 84 ba 80 02
	00 00		 mov	 eax, DWORD PTR [edx+edi*4+640]
  00116	50		 push	 eax
  00117	68 00 00 00 00	 push	 OFFSET FLAT:_log_options
  0011c	e8 00 00 00 00	 call	 _cm_util_string_match
  00121	83 c4 08	 add	 esp, 8

; 280  : 		if(value == NO_STRING_MATCH)

  00124	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00129	0f 84 e7 00 00
	00		 je	 $L72024

; 283  : 		}
; 284  : 		switch(i)
; 285  : 		{

  0012f	8b cf		 mov	 ecx, edi
  00131	83 e9 00	 sub	 ecx, 0
  00134	0f 84 97 00 00
	00		 je	 $L71460
  0013a	49		 dec	 ecx
  0013b	0f 85 df 00 00
	00		 jne	 $L71489

; 316  : 						break;
; 317  : 					default:
; 318  : 						return(CMD_bad_param);
; 319  : 				}
; 320  : 			break;
; 321  : 			case 1: /* Second parameter */
; 322  : 				switch(value)
; 323  : 				{ 

  00141	83 e8 07	 sub	 eax, 7
  00144	74 5e		 je	 SHORT $L71478
  00146	48		 dec	 eax
  00147	74 21		 je	 SHORT $L71482
  00149	48		 dec	 eax
  0014a	0f 85 d0 00 00
	00		 jne	 $L71489

; 370  : 
; 371  : 					case 9:                                /* set */
; 372  : #ifndef MSDOS
; 373  : 						if ( OpenLogFile(phTTS))

  00150	53		 push	 ebx
  00151	e8 00 00 00 00	 call	 _OpenLogFile
  00156	83 c4 04	 add	 esp, 4
  00159	85 c0		 test	 eax, eax
  0015b	74 06		 je	 SHORT $L71488

; 374  : #endif
; 375  : 								pKsd_t->logflag = flag_mask;

  0015d	89 b5 04 02 00
	00		 mov	 DWORD PTR [ebp+516], esi
$L71488:

; 376  : 						flag_mask = 0;

  00163	33 f6		 xor	 esi, esi

; 377  : 						break;

  00165	e9 94 00 00 00	 jmp	 $L71453
$L71482:

; 338  : #ifndef MSDOS
; 339  : 						}
; 340  : #endif
; 341  : 
; 342  : 						break;
; 343  : 
; 344  : 					case 8:	/* off */
; 345  : 
; 346  : #ifdef MSDOS	
; 347  : 						pKsd_t->logflag &= (~flag_mask);
; 348  : 						flag_mask = 0;
; 349  : #else
; 350  : 
; 351  : 						if ((flag_mask | LOG_DBGLOG) == LOG_DBGLOG)

  0016a	8b ce		 mov	 ecx, esi
  0016c	83 c9 40	 or	 ecx, 64			; 00000040H
  0016f	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00172	75 0d		 jne	 SHORT $L71483

; 352  : 						{  						
; 353  : 							CloseDbgLogFile(phTTS);

  00174	53		 push	 ebx
  00175	e8 00 00 00 00	 call	 _CloseDbgLogFile
  0017a	83 c4 04	 add	 esp, 4

; 354  : 							flag_mask = 0;

  0017d	33 f6		 xor	 esi, esi

; 355  : 						}
; 356  : 						else

  0017f	eb 7d		 jmp	 SHORT $L71453
$L71483:

; 357  : 						{
; 358  : 							if ( pKsd_t->logflag & (~flag_mask))

  00181	8b 85 04 02 00
	00		 mov	 eax, DWORD PTR [ebp+516]
  00187	f7 d6		 not	 esi
  00189	23 f0		 and	 esi, eax
  0018b	74 0a		 je	 SHORT $L71485

; 359  : 							{
; 360  : 								pKsd_t->logflag &= (~flag_mask);

  0018d	89 b5 04 02 00
	00		 mov	 DWORD PTR [ebp+516], esi

; 365  : 							}
; 366  : 							flag_mask = 0;

  00193	33 f6		 xor	 esi, esi

; 367  : 						}
; 368  : #endif
; 369  : 						break;

  00195	eb 67		 jmp	 SHORT $L71453
$L71485:

; 361  : 							}
; 362  : 							else
; 363  : 							{
; 364  : 							CloseLogFile(phTTS);

  00197	53		 push	 ebx
  00198	e8 00 00 00 00	 call	 _CloseLogFile
  0019d	83 c4 04	 add	 esp, 4

; 365  : 							}
; 366  : 							flag_mask = 0;

  001a0	33 f6		 xor	 esi, esi

; 367  : 						}
; 368  : #endif
; 369  : 						break;

  001a2	eb 5a		 jmp	 SHORT $L71453
$L71478:

; 324  : 					case 7: /* on */
; 325  : 
; 326  : #ifndef MSDOS			
; 327  : 						if ((flag_mask | LOG_DBGLOG) == LOG_DBGLOG)

  001a4	8b d6		 mov	 edx, esi

; 328  : 						{  						
; 329  : 							OpenDbgLogFile(phTTS);

  001a6	53		 push	 ebx
  001a7	83 ca 40	 or	 edx, 64			; 00000040H
  001aa	83 fa 40	 cmp	 edx, 64			; 00000040H
  001ad	75 0c		 jne	 SHORT $L71479
  001af	e8 00 00 00 00	 call	 _OpenDbgLogFile
  001b4	83 c4 04	 add	 esp, 4

; 330  : 							flag_mask = 0;

  001b7	33 f6		 xor	 esi, esi

; 331  : 						}
; 332  : 						else

  001b9	eb 43		 jmp	 SHORT $L71453
$L71479:

; 333  : 						{		
; 334  : 						if ( OpenLogFile(phTTS))

  001bb	e8 00 00 00 00	 call	 _OpenLogFile
  001c0	83 c4 04	 add	 esp, 4
  001c3	85 c0		 test	 eax, eax
  001c5	74 06		 je	 SHORT $L71481

; 335  : #endif
; 336  : 							pKsd_t->logflag |= flag_mask;

  001c7	09 b5 04 02 00
	00		 or	 DWORD PTR [ebp+516], esi
$L71481:

; 337  : 						flag_mask = 0;

  001cd	33 f6		 xor	 esi, esi

; 378  : 					default:
; 379  : 						return(CMD_bad_param);
; 380  : 				}
; 381  : 				break;

  001cf	eb 2d		 jmp	 SHORT $L71453
$L71460:

; 286  : 			case 0: /* First parameter */
; 287  : 				switch(value)
; 288  : 				{

  001d1	83 f8 06	 cmp	 eax, 6
  001d4	77 4a		 ja	 SHORT $L71489
  001d6	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72029[eax*4]
$L71465:

; 289  : 					case 0:                               /* text */
; 290  : 						flag_mask |= LOG_TEXT;

  001dd	83 ce 01	 or	 esi, 1

; 291  : 						break;

  001e0	eb 1c		 jmp	 SHORT $L71453
$L71466:

; 292  : 					case 1:                               /* phoneme */
; 293  : 
; 294  : 						flag_mask |= LOG_PHONEMES;

  001e2	83 ce 02	 or	 esi, 2

; 295  : 						break;

  001e5	eb 17		 jmp	 SHORT $L71453
$L71467:

; 296  : 
; 297  : 					case 2:                               /* name types */
; 298  : 
; 299  : 						flag_mask |= LOG_NAME_TYPES;

  001e7	83 ce 04	 or	 esi, 4

; 300  : 						break;

  001ea	eb 12		 jmp	 SHORT $L71453
$L71468:

; 301  : 
; 302  : 					case 3:                               /* word form classes */
; 303  : 
; 304  : 						flag_mask |= LOG_FORM_TYPES;

  001ec	83 ce 08	 or	 esi, 8

; 305  : 						break;

  001ef	eb 0d		 jmp	 SHORT $L71453
$L71469:

; 306  : 
; 307  : 					case 4:                               /* word syllable structure */
; 308  : 
; 309  : 						flag_mask |= LOG_SYLLABLES;

  001f1	83 ce 10	 or	 esi, 16			; 00000010H

; 310  : 						break;

  001f4	eb 08		 jmp	 SHORT $L71453
$L71470:

; 311  : 					case 5:                               /* word outphon structure */
; 312  : 						flag_mask |= LOG_OUTPHON;

  001f6	83 ce 20	 or	 esi, 32			; 00000020H

; 313  : 				   		break;

  001f9	eb 03		 jmp	 SHORT $L71453
$L71471:

; 314  : 					case 6:                               /* word dbglog structure */
; 315  : 						flag_mask |= LOG_DBGLOG;		  /*mfg*/

  001fb	83 ce 40	 or	 esi, 64			; 00000040H
$L71453:

; 252  : 	  return(CMD_flushing);
; 253  : #endif
; 254  : 	
; 255  : 	flag_mask = 0;
; 256  : 	for(i=0; i < (int)pCmd_t->param_index; i++)

  001fe	8b 44 24 14	 mov	 eax, DWORD PTR _pCmd_t$[esp+12]
  00202	47		 inc	 edi
  00203	3b b8 d0 02 00
	00		 cmp	 edi, DWORD PTR [eax+720]
  00209	0f 8c fc fe ff
	ff		 jl	 $L71452
$L71454:
  0020f	5f		 pop	 edi
  00210	5e		 pop	 esi
  00211	5d		 pop	 ebp

; 384  : 		}       /* switch(i) */
; 385  : 	}       /* for(i=0; i < param_index; i++) */
; 386  : 	return(CMD_success);

  00212	33 c0		 xor	 eax, eax
  00214	5b		 pop	 ebx

; 387  : }

  00215	c3		 ret	 0
$L72024:
  00216	5f		 pop	 edi
  00217	5e		 pop	 esi
  00218	5d		 pop	 ebp

; 281  : 		{
; 282  : 			return(CMD_bad_string);

  00219	b8 01 00 00 00	 mov	 eax, 1
  0021e	5b		 pop	 ebx

; 387  : }

  0021f	c3		 ret	 0
$L71489:
  00220	5f		 pop	 edi
  00221	5e		 pop	 esi
  00222	5d		 pop	 ebp

; 382  : 				default:
; 383  : 					return(CMD_bad_param);

  00223	b8 04 00 00 00	 mov	 eax, 4
  00228	5b		 pop	 ebx

; 387  : }

  00229	c3		 ret	 0
  0022a	8b ff		 npad	 2
$L72029:
  0022c	00 00 00 00	 DD	 $L71465
  00230	00 00 00 00	 DD	 $L71466
  00234	00 00 00 00	 DD	 $L71467
  00238	00 00 00 00	 DD	 $L71468
  0023c	00 00 00 00	 DD	 $L71469
  00240	00 00 00 00	 DD	 $L71470
  00244	00 00 00 00	 DD	 $L71471
_cm_cmd_log ENDP
_TEXT	ENDS
EXTRN	__imp__fopen:NEAR
_DATA	SEGMENT
	ORG $+2
$SG71497 DB	'w', 00H
	ORG $+2
$SG71498 DB	'dbglog.txt', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_OpenDbgLogFile PROC NEAR

; 406  : 
; 407  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00250	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00254	56		 push	 esi

; 408  : 
; 409  : 	if ((pKsd_t->dbglog = fopen("dbglog.txt","w"))==NULL)

  00255	68 00 00 00 00	 push	 OFFSET FLAT:$SG71497
  0025a	68 00 00 00 00	 push	 OFFSET FLAT:$SG71498
  0025f	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00262	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00268	83 c4 08	 add	 esp, 8
  0026b	33 c9		 xor	 ecx, ecx
  0026d	85 c0		 test	 eax, eax
  0026f	0f 95 c1	 setne	 cl
  00272	89 86 7c 04 00
	00		 mov	 DWORD PTR [esi+1148], eax
  00278	8b c1		 mov	 eax, ecx
  0027a	5e		 pop	 esi

; 410  : 		return(FALSE);
; 411  : 
; 412  : 	return( TRUE );
; 413  : 
; 414  : }

  0027b	c3		 ret	 0
_OpenDbgLogFile ENDP
_TEXT	ENDS
EXTRN	__imp__fclose:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_CloseDbgLogFile PROC NEAR

; 431  : 
; 432  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00280	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00284	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 433  : 	
; 434  : 	if(pKsd_t->dbglog)

  00287	8b 80 7c 04 00
	00		 mov	 eax, DWORD PTR [eax+1148]
  0028d	85 c0		 test	 eax, eax
  0028f	74 08		 je	 SHORT $L71503

; 435  : 	{
; 436  : 	fclose(pKsd_t->dbglog);

  00291	50		 push	 eax
  00292	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00298	59		 pop	 ecx
$L71503:

; 437  : 	}
; 438  : 
; 439  : }

  00299	c3		 ret	 0
_CloseDbgLogFile ENDP
_TEXT	ENDS
EXTRN	__imp__EnterCriticalSection@4:NEAR
EXTRN	__imp__LeaveCriticalSection@4:NEAR
EXTRN	_TextToSpeechErrorHandler:NEAR
_DATA	SEGMENT
	ORG $+1
$SG71511 DB	'w', 00H
	ORG $+2
$SG71512 DB	'log.txt', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_OpenLogFile PROC NEAR

; 461  : {

  002a0	56		 push	 esi

; 462  :   /*
; 463  :   LPTTS_HANDLE_T phTTS;                                 MVP MI 
; 464  : 
; 465  :   phTTS = TextToSpeechGetHandle();
; 466  :   */
; 467  : #ifdef WIN32
; 468  :   EnterCriticalSection( phTTS->pcsLogFile );

  002a1	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  002a5	8b 86 c4 00 00
	00		 mov	 eax, DWORD PTR [esi+196]
  002ab	50		 push	 eax
  002ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 469  : #endif
; 470  : 
; 471  : /* GL 04/21/1997  change this for OSF build */
; 472  : #if defined __osf__ || defined __linux__
; 473  :   /*ToggleLogfileMutex( MUTEX_RESERVE );*/
; 474  :   OP_LockMutex( phTTS->pcsLogFile );
; 475  : #endif
; 476  : 
; 477  :   /********************************************************************/
; 478  :   /*  If a file is already open, then don't try to open another one.  */
; 479  :   /********************************************************************/
; 480  : 
; 481  :   if ( phTTS->dwOutputState == STATE_OUTPUT_LOG_FILE )

  002b2	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  002b8	83 f8 03	 cmp	 eax, 3

; 482  :   {
; 483  : #ifdef WIN32
; 484  : 	LeaveCriticalSection( phTTS->pcsLogFile );
; 485  : #endif
; 486  : /* GL 04/21/1997  change this for OSF build */
; 487  : #if defined __osf__ || defined __linux__
; 488  :   /*ToggleLogfileMutex( MUTEX_RELEASE );*/
; 489  :     OP_UnlockMutex( phTTS->pcsLogFile );
; 490  : #endif
; 491  : 
; 492  : 	return( TRUE );

  002bb	74 68		 je	 SHORT $L72033

; 493  :   }
; 494  : 
; 495  :   /********************************************************************/
; 496  :   /*  If not in NULL output state or AUDIO Output state then return   */
; 497  :   /*  an error.                                                       */
; 498  :   /********************************************************************/
; 499  : 
; 500  :   if (( phTTS->dwOutputState != STATE_OUTPUT_AUDIO )
; 501  :    && ( phTTS->dwOutputState != STATE_OUTPUT_NULL ))

  002bd	85 c0		 test	 eax, eax
  002bf	74 16		 je	 SHORT $L71508
  002c1	83 f8 04	 cmp	 eax, 4
  002c4	74 11		 je	 SHORT $L71508

; 502  :   {
; 503  : #ifdef WIN32
; 504  : 	LeaveCriticalSection( phTTS->pcsLogFile );

  002c6	8b 96 c4 00 00
	00		 mov	 edx, DWORD PTR [esi+196]
  002cc	52		 push	 edx
  002cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 505  : #endif
; 506  : /* GL 04/21/1997  change this for OSF build */
; 507  : #if defined __osf__ || defined __linux__
; 508  :   /*ToggleLogfileMutex( MUTEX_RELEASE );*/
; 509  :     OP_UnlockMutex( phTTS->pcsLogFile );
; 510  : #endif
; 511  : 
; 512  : 	return( FALSE );

  002d3	33 c0		 xor	 eax, eax
  002d5	5e		 pop	 esi

; 551  : }

  002d6	c3		 ret	 0
$L71508:

; 513  :   }
; 514  : 
; 515  :   /********************************************************************/
; 516  :   /*  Open the log file.                                              */
; 517  :   /********************************************************************/
; 518  : 
; 519  :   if (( phTTS->pLogFile = fopen( "log.txt", "w" )) == NULL )

  002d7	68 00 00 00 00	 push	 OFFSET FLAT:$SG71511
  002dc	68 00 00 00 00	 push	 OFFSET FLAT:$SG71512
  002e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  002e7	83 c4 08	 add	 esp, 8
  002ea	89 86 98 00 00
	00		 mov	 DWORD PTR [esi+152], eax
  002f0	85 c0		 test	 eax, eax
  002f2	75 1e		 jne	 SHORT $L71510

; 520  :   {
; 521  : #ifdef WIN32
; 522  : 	LeaveCriticalSection( phTTS->pcsLogFile );

  002f4	8b 86 c4 00 00
	00		 mov	 eax, DWORD PTR [esi+196]
  002fa	50		 push	 eax
  002fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 523  : #endif
; 524  : /* GL 04/21/1997  change this for OSF build */
; 525  : #if defined __osf__ || defined __linux__
; 526  :   /*ToggleLogfileMutex( MUTEX_RELEASE );*/
; 527  :     OP_UnlockMutex( phTTS->pcsLogFile );
; 528  : #endif
; 529  : 
; 530  : 	TextToSpeechErrorHandler( phTTS,
; 531  : 				  ERROR_WRITING_FILE,
; 532  : 				  0L );

  00301	6a 00		 push	 0
  00303	6a 05		 push	 5
  00305	56		 push	 esi
  00306	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  0030b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 533  : 	return( FALSE );

  0030e	33 c0		 xor	 eax, eax
  00310	5e		 pop	 esi

; 551  : }

  00311	c3		 ret	 0
$L71510:

; 534  :   }
; 535  :   else
; 536  :   {
; 537  : 	cm_cmd_sync(phTTS);

  00312	56		 push	 esi
  00313	e8 00 00 00 00	 call	 _cm_cmd_sync
  00318	83 c4 04	 add	 esp, 4

; 538  : 
; 539  : 	phTTS->dwOutputState = STATE_OUTPUT_LOG_FILE;

  0031b	c7 86 84 00 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+132], 3
$L72033:

; 540  : #ifdef WIN32
; 541  : 	LeaveCriticalSection( phTTS->pcsLogFile );

  00325	8b 8e c4 00 00
	00		 mov	 ecx, DWORD PTR [esi+196]
  0032b	51		 push	 ecx
  0032c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 542  : #endif
; 543  : /* GL 04/21/1997  change this for OSF build */
; 544  : #if defined __osf__ || defined __linux__
; 545  :   /*ToggleLogfileMutex( MUTEX_RELEASE );*/
; 546  :     OP_UnlockMutex( phTTS->pcsLogFile );
; 547  : #endif
; 548  : 
; 549  :   }
; 550  :   return( TRUE );

  00332	b8 01 00 00 00	 mov	 eax, 1
  00337	5e		 pop	 esi

; 551  : }

  00338	c3		 ret	 0
_OpenLogFile ENDP
_phTTS$ = 8
_CloseLogFile PROC NEAR

; 570  : {

  00340	56		 push	 esi

; 571  :   PKSD_T pKsd_t = phTTS->pKernelShareData;

  00341	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  00345	57		 push	 edi

; 572  :   /*
; 573  :   LPTTS_HANDLE_T phTTS;                 MVP MI
; 574  : 
; 575  :   phTTS = TextToSpeechGetHandle();
; 576  :   */
; 577  : 
; 578  :   /********************************************************************/
; 579  :   /*  Wait for all data to complete before closing the log file.      */
; 580  :   /********************************************************************/
; 581  : 
; 582  :   cm_cmd_sync(phTTS);

  00346	56		 push	 esi
  00347	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0034a	e8 00 00 00 00	 call	 _cm_cmd_sync

; 583  : 
; 584  : #ifdef WIN32
; 585  :   EnterCriticalSection( phTTS->pcsLogFile );

  0034f	8b 86 c4 00 00
	00		 mov	 eax, DWORD PTR [esi+196]
  00355	83 c4 04	 add	 esp, 4
  00358	50		 push	 eax
  00359	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 586  :   _flushall;
; 587  : #endif
; 588  : /* GL 04/21/1997  change this for OSF build */
; 589  : #if defined __osf__ || defined __linux__
; 590  :   /*ToggleLogfileMutex( MUTEX_RESERVE );*/
; 591  :   OP_LockMutex( phTTS->pcsLogFile );
; 592  : #endif
; 593  : 
; 594  :   /********************************************************************/
; 595  :   /*  Exit if the log file is not open.                               */
; 596  :   /********************************************************************/
; 597  : 
; 598  :   if ( phTTS->dwOutputState != STATE_OUTPUT_LOG_FILE )

  0035f	83 be 84 00 00
	00 03		 cmp	 DWORD PTR [esi+132], 3
  00366	74 10		 je	 SHORT $L71518

; 599  :   {
; 600  : #ifdef WIN32
; 601  : 	LeaveCriticalSection( phTTS->pcsLogFile );

  00368	8b 8e c4 00 00
	00		 mov	 ecx, DWORD PTR [esi+196]
  0036e	51		 push	 ecx

; 643  : #ifdef WIN32
; 644  : 	LeaveCriticalSection( phTTS->pcsLogFile );

  0036f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00375	5f		 pop	 edi
  00376	5e		 pop	 esi

; 645  : #endif
; 646  : /* GL 04/21/1997  change this for OSF build */
; 647  : #if defined __osf__ || defined __linux__
; 648  :   /*ToggleLogfileMutex( MUTEX_RELEASE );*/
; 649  :     OP_UnlockMutex( phTTS->pcsLogFile );
; 650  : #endif
; 651  : 
; 652  :   }
; 653  :   return;
; 654  : }

  00377	c3		 ret	 0
$L71518:

; 602  : #endif
; 603  : /* GL 04/21/1997  change this for OSF build */
; 604  : #if defined __osf__ || defined __linux__
; 605  :   /*ToggleLogfileMutex( MUTEX_RELEASE );*/
; 606  :     OP_UnlockMutex( phTTS->pcsLogFile );
; 607  : #endif
; 608  : 
; 609  : 	return;
; 610  :   }
; 611  : 
; 612  :   /********************************************************************/
; 613  :   /*  Set the system output state to audio if it is enabled.          */
; 614  :   /********************************************************************/
; 615  : 
; 616  :   if (( phTTS->dwDeviceOptions & DO_NOT_USE_AUDIO_DEVICE ) == 0 )

  00378	8b 56 74	 mov	 edx, DWORD PTR [esi+116]

; 617  : 	phTTS->dwOutputState = STATE_OUTPUT_AUDIO;
; 618  :   else
; 619  : 	phTTS->dwOutputState = STATE_OUTPUT_NULL;
; 620  : 
; 621  :   /********************************************************************/
; 622  :   /*  Close the log file.                                             */
; 623  :   /********************************************************************/
; 624  : 
; 625  :   if ( fclose( phTTS->pLogFile ))

  0037b	8b 86 98 00 00
	00		 mov	 eax, DWORD PTR [esi+152]
  00381	c1 ea 1d	 shr	 edx, 29			; 0000001dH
  00384	83 e2 04	 and	 edx, 4
  00387	50		 push	 eax
  00388	89 96 84 00 00
	00		 mov	 DWORD PTR [esi+132], edx
  0038e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00394	83 c4 04	 add	 esp, 4
  00397	85 c0		 test	 eax, eax
  00399	74 1d		 je	 SHORT $L71521

; 626  :   {
; 627  : #ifdef WIN32
; 628  : 	LeaveCriticalSection( phTTS->pcsLogFile );

  0039b	8b 8e c4 00 00
	00		 mov	 ecx, DWORD PTR [esi+196]
  003a1	51		 push	 ecx
  003a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 629  : #endif
; 630  : /* GL 04/21/1997  change this for OSF build */
; 631  : #if defined __osf__ || defined __linux__
; 632  :   /*ToggleLogfileMutex( MUTEX_RELEASE );*/
; 633  :     OP_UnlockMutex( phTTS->pcsLogFile );
; 634  : #endif
; 635  : 
; 636  : 	TextToSpeechErrorHandler( phTTS,
; 637  : 				  ERROR_WRITING_FILE,
; 638  : 				  0L );

  003a8	6a 00		 push	 0
  003aa	6a 05		 push	 5
  003ac	56		 push	 esi
  003ad	e8 00 00 00 00	 call	 _TextToSpeechErrorHandler
  003b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  003b5	5f		 pop	 edi
  003b6	5e		 pop	 esi

; 645  : #endif
; 646  : /* GL 04/21/1997  change this for OSF build */
; 647  : #if defined __osf__ || defined __linux__
; 648  :   /*ToggleLogfileMutex( MUTEX_RELEASE );*/
; 649  :     OP_UnlockMutex( phTTS->pcsLogFile );
; 650  : #endif
; 651  : 
; 652  :   }
; 653  :   return;
; 654  : }

  003b7	c3		 ret	 0
$L71521:

; 639  :   }
; 640  :   else
; 641  :   {
; 642  : 	pKsd_t->logflag = 0;

  003b8	c7 87 04 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+516], 0

; 643  : #ifdef WIN32
; 644  : 	LeaveCriticalSection( phTTS->pcsLogFile );

  003c2	8b 96 c4 00 00
	00		 mov	 edx, DWORD PTR [esi+196]
  003c8	52		 push	 edx
  003c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  003cf	5f		 pop	 edi
  003d0	5e		 pop	 esi

; 645  : #endif
; 646  : /* GL 04/21/1997  change this for OSF build */
; 647  : #if defined __osf__ || defined __linux__
; 648  :   /*ToggleLogfileMutex( MUTEX_RELEASE );*/
; 649  :     OP_UnlockMutex( phTTS->pcsLogFile );
; 650  : #endif
; 651  : 
; 652  :   }
; 653  :   return;
; 654  : }

  003d1	c3		 ret	 0
_CloseLogFile ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_break
_TEXT	SEGMENT
_phTTS$ = 8
_cm_cmd_break PROC NEAR

; 675  : 	int     i,value;
; 676  : 	unsigned int flag_mask;
; 677  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  003e0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  003e4	53		 push	 ebx
  003e5	55		 push	 ebp
  003e6	56		 push	 esi

; 678  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  003e7	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]
  003ea	8b 68 08	 mov	 ebp, DWORD PTR [eax+8]
  003ed	57		 push	 edi

; 679  : 	flag_mask = 0;
; 680  : 	for(i = 0; i < (int)pCmd_t->param_index; i++)

  003ee	33 ff		 xor	 edi, edi
  003f0	8b 83 d0 02 00
	00		 mov	 eax, DWORD PTR [ebx+720]
  003f6	85 c0		 test	 eax, eax
  003f8	7e 49		 jle	 SHORT $L71534

; 675  : 	int     i,value;
; 676  : 	unsigned int flag_mask;
; 677  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  003fa	8d b3 80 02 00
	00		 lea	 esi, DWORD PTR [ebx+640]
$L71532:

; 681  : 	{
; 682  : 		value = cm_util_string_match(log_options,pCmd_t->pString[i]);

  00400	8b 06		 mov	 eax, DWORD PTR [esi]
  00402	50		 push	 eax
  00403	68 00 00 00 00	 push	 OFFSET FLAT:_log_options
  00408	e8 00 00 00 00	 call	 _cm_util_string_match
  0040d	83 c4 08	 add	 esp, 8

; 683  : 		if(value == NO_STRING_MATCH)

  00410	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00415	74 33		 je	 SHORT $L72038

; 685  : 		switch(value)
; 686  : 		{

  00417	83 e8 00	 sub	 eax, 0
  0041a	74 0f		 je	 SHORT $L71540
  0041c	48		 dec	 eax
  0041d	75 16		 jne	 SHORT $L71533

; 690  : 				break;
; 691  : 
; 692  : 			case    1       :                               /* off */
; 693  : 
; 694  : 				pKsd_t->wbreak = FALSE;

  0041f	c7 85 14 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ebp+532], 0

; 695  : 				break;

  00429	eb 0a		 jmp	 SHORT $L71533
$L71540:

; 687  : 			case    0       :                               /* on */
; 688  : 
; 689  : 				pKsd_t->wbreak = TRUE;

  0042b	c7 85 14 02 00
	00 01 00 00 00	 mov	 DWORD PTR [ebp+532], 1
$L71533:

; 679  : 	flag_mask = 0;
; 680  : 	for(i = 0; i < (int)pCmd_t->param_index; i++)

  00435	8b 83 d0 02 00
	00		 mov	 eax, DWORD PTR [ebx+720]
  0043b	47		 inc	 edi
  0043c	83 c6 04	 add	 esi, 4
  0043f	3b f8		 cmp	 edi, eax
  00441	7c bd		 jl	 SHORT $L71532
$L71534:
  00443	5f		 pop	 edi
  00444	5e		 pop	 esi
  00445	5d		 pop	 ebp

; 696  : 	
; 697  : 		}
; 698  : 	}
; 699  : 	return(CMD_success);

  00446	33 c0		 xor	 eax, eax
  00448	5b		 pop	 ebx

; 700  : }

  00449	c3		 ret	 0
$L72038:
  0044a	5f		 pop	 edi
  0044b	5e		 pop	 esi
  0044c	5d		 pop	 ebp

; 684  : 			return(CMD_bad_string);

  0044d	b8 01 00 00 00	 mov	 eax, 1
  00452	5b		 pop	 ebx

; 700  : }

  00453	c3		 ret	 0
_cm_cmd_break ENDP
_phTTS$ = 8
_cm_cmd_say PROC NEAR

; 720  : {

  00460	56		 push	 esi

; 721  : 	int     value; 
; 722  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00461	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  00465	57		 push	 edi

; 723  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00466	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00469	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 724  : 
; 725  : 	value = cm_util_string_match(say_options,pCmd_t->pString[0]);

  0046c	8b 80 80 02 00
	00		 mov	 eax, DWORD PTR [eax+640]
  00472	50		 push	 eax
  00473	68 00 00 00 00	 push	 OFFSET FLAT:_say_options
  00478	e8 00 00 00 00	 call	 _cm_util_string_match
  0047d	83 c4 08	 add	 esp, 8

; 726  : 	if(value == NO_STRING_MATCH)

  00480	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00485	75 08		 jne	 SHORT $L71548
  00487	5f		 pop	 edi

; 727  : 		return(CMD_bad_string);

  00488	b8 01 00 00 00	 mov	 eax, 1
  0048d	5e		 pop	 esi

; 765  : }

  0048e	c3		 ret	 0
$L71548:

; 728  : 	switch(value)
; 729  : 	{

  0048f	83 f8 05	 cmp	 eax, 5
  00492	77 7e		 ja	 SHORT $L71550
  00494	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72041[eax*4]
$L71553:

; 730  : 		case    0       :                               /* clause */
; 731  : 
; 732  : 			pKsd_t->sayflag = SAY_CLAUSE;

  0049b	c7 87 08 02 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+520], 0
  004a5	5f		 pop	 edi

; 762  : 			break;
; 763  : 	}
; 764  : 	return(CMD_success);

  004a6	33 c0		 xor	 eax, eax
  004a8	5e		 pop	 esi

; 765  : }

  004a9	c3		 ret	 0
$L71554:

; 733  : 			break;
; 734  : 
; 735  : 		case    1       :                               /* word */
; 736  : 
; 737  : 			pKsd_t->sayflag = SAY_WORD;

  004aa	c7 87 08 02 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+520], 1
  004b4	5f		 pop	 edi

; 762  : 			break;
; 763  : 	}
; 764  : 	return(CMD_success);

  004b5	33 c0		 xor	 eax, eax
  004b7	5e		 pop	 esi

; 765  : }

  004b8	c3		 ret	 0
$L71555:

; 738  : 			break;
; 739  : 
; 740  : 		case    2       :                               /* letter */
; 741  : 
; 742  : 			if(cm_cmd_sync(phTTS) == CMD_flushing)

  004b9	56		 push	 esi
  004ba	e8 00 00 00 00	 call	 _cm_cmd_sync
  004bf	83 c4 04	 add	 esp, 4
  004c2	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  004c5	75 03		 jne	 SHORT $L71556
  004c7	5f		 pop	 edi
  004c8	5e		 pop	 esi

; 765  : }

  004c9	c3		 ret	 0
$L71556:

; 743  : 				return(CMD_flushing);
; 744  : 			pKsd_t->sayflag = SAY_LETTER;

  004ca	c7 87 08 02 00
	00 02 00 00 00	 mov	 DWORD PTR [edi+520], 2
  004d4	5f		 pop	 edi

; 762  : 			break;
; 763  : 	}
; 764  : 	return(CMD_success);

  004d5	33 c0		 xor	 eax, eax
  004d7	5e		 pop	 esi

; 765  : }

  004d8	c3		 ret	 0
$L71557:

; 745  : 			break;
; 746  : 
; 747  : 		case    3       :                               /* fletter */
; 748  : 
; 749  : 			if(cm_cmd_sync(phTTS) == CMD_flushing)

  004d9	56		 push	 esi
  004da	e8 00 00 00 00	 call	 _cm_cmd_sync
  004df	83 c4 04	 add	 esp, 4
  004e2	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  004e5	75 03		 jne	 SHORT $L71558
  004e7	5f		 pop	 edi
  004e8	5e		 pop	 esi

; 765  : }

  004e9	c3		 ret	 0
$L71558:

; 750  : 				return(CMD_flushing);
; 751  : 			pKsd_t->sayflag = SAY_FLETTER;

  004ea	c7 87 08 02 00
	00 10 00 00 00	 mov	 DWORD PTR [edi+520], 16	; 00000010H
  004f4	5f		 pop	 edi

; 762  : 			break;
; 763  : 	}
; 764  : 	return(CMD_success);

  004f5	33 c0		 xor	 eax, eax
  004f7	5e		 pop	 esi

; 765  : }

  004f8	c3		 ret	 0
$L71559:

; 752  : 			break;
; 753  : 
; 754  : 		case    4       :                               /* line */
; 755  : 
; 756  : 			pKsd_t->sayflag = SAY_LINE;

  004f9	c7 87 08 02 00
	00 04 00 00 00	 mov	 DWORD PTR [edi+520], 4
  00503	5f		 pop	 edi

; 762  : 			break;
; 763  : 	}
; 764  : 	return(CMD_success);

  00504	33 c0		 xor	 eax, eax
  00506	5e		 pop	 esi

; 765  : }

  00507	c3		 ret	 0
$L71560:

; 757  : 			break;
; 758  : 
; 759  : 		case    5       :                               /* syllables */
; 760  : 
; 761  : 			pKsd_t->sayflag = SAY_SYLLABLE;

  00508	c7 87 08 02 00
	00 08 00 00 00	 mov	 DWORD PTR [edi+520], 8
$L71550:
  00512	5f		 pop	 edi

; 762  : 			break;
; 763  : 	}
; 764  : 	return(CMD_success);

  00513	33 c0		 xor	 eax, eax
  00515	5e		 pop	 esi

; 765  : }

  00516	c3		 ret	 0
  00517	90		 npad	 1
$L72041:
  00518	00 00 00 00	 DD	 $L71553
  0051c	00 00 00 00	 DD	 $L71554
  00520	00 00 00 00	 DD	 $L71555
  00524	00 00 00 00	 DD	 $L71557
  00528	00 00 00 00	 DD	 $L71559
  0052c	00 00 00 00	 DD	 $L71560
_cm_cmd_say ENDP
_phTTS$ = 8
_cm_cmd_error PROC NEAR

; 787  : 	int     value;
; 788  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;
; 789  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00530	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00534	56		 push	 esi
  00535	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]

; 790  : 
; 791  : 	value = cm_util_string_match(error_options,pCmd_t->pString[0]);

  00538	8b 8e 80 02 00
	00		 mov	 ecx, DWORD PTR [esi+640]
  0053e	51		 push	 ecx
  0053f	68 00 00 00 00	 push	 OFFSET FLAT:_error_options
  00544	e8 00 00 00 00	 call	 _cm_util_string_match
  00549	83 c4 08	 add	 esp, 8

; 792  : 	if(value == NO_STRING_MATCH)

  0054c	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00551	75 07		 jne	 SHORT $L71567

; 793  : 		return(CMD_bad_string);

  00553	b8 01 00 00 00	 mov	 eax, 1
  00558	5e		 pop	 esi

; 822  : }

  00559	c3		 ret	 0
$L71567:

; 794  : 	switch(value)
; 795  : 	{

  0055a	83 f8 04	 cmp	 eax, 4
  0055d	77 49		 ja	 SHORT $L71569
  0055f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72043[eax*4]
$L71572:

; 796  : 		case    0       :                               /* ignore */
; 797  : 
; 798  : 			pCmd_t->error_mode = ERROR_ignore;

  00566	c7 86 fc 04 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1276], 0

; 819  : 			break;
; 820  : 	}
; 821  : 	return(CMD_success);

  00570	33 c0		 xor	 eax, eax
  00572	5e		 pop	 esi

; 822  : }

  00573	c3		 ret	 0
$L71573:

; 799  : 			break;
; 800  : 
; 801  : 		case    1       :                               /* text */
; 802  : 
; 803  : 			pCmd_t->error_mode = ERROR_text;

  00574	c7 86 fc 04 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+1276], 1

; 819  : 			break;
; 820  : 	}
; 821  : 	return(CMD_success);

  0057e	33 c0		 xor	 eax, eax
  00580	5e		 pop	 esi

; 822  : }

  00581	c3		 ret	 0
$L71574:

; 804  : 			break;
; 805  : 
; 806  : 		case    2       :                               /* escape */
; 807  : 
; 808  : 			pCmd_t->error_mode = ERROR_escape;

  00582	c7 86 fc 04 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+1276], 2

; 819  : 			break;
; 820  : 	}
; 821  : 	return(CMD_success);

  0058c	33 c0		 xor	 eax, eax
  0058e	5e		 pop	 esi

; 822  : }

  0058f	c3		 ret	 0
$L71575:

; 809  : 			break;
; 810  : 
; 811  : 		case    3       :                               /* speak */
; 812  : 
; 813  : 			pCmd_t->error_mode = ERROR_speak;

  00590	c7 86 fc 04 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+1276], 3

; 819  : 			break;
; 820  : 	}
; 821  : 	return(CMD_success);

  0059a	33 c0		 xor	 eax, eax
  0059c	5e		 pop	 esi

; 822  : }

  0059d	c3		 ret	 0
$L71576:

; 814  : 			break;
; 815  : 
; 816  : 		case    4       :                               /* tone */
; 817  : 
; 818  : 			pCmd_t->error_mode = ERROR_tone;

  0059e	c7 86 fc 04 00
	00 04 00 00 00	 mov	 DWORD PTR [esi+1276], 4
$L71569:

; 819  : 			break;
; 820  : 	}
; 821  : 	return(CMD_success);

  005a8	33 c0		 xor	 eax, eax
  005aa	5e		 pop	 esi

; 822  : }

  005ab	c3		 ret	 0
$L72043:
  005ac	00 00 00 00	 DD	 $L71572
  005b0	00 00 00 00	 DD	 $L71573
  005b4	00 00 00 00	 DD	 $L71574
  005b8	00 00 00 00	 DD	 $L71575
  005bc	00 00 00 00	 DD	 $L71576
_cm_cmd_error ENDP
_TEXT	ENDS
EXTRN	__imp__Sleep@4:NEAR
EXTRN	__imp__GetTickCount@0:NEAR
EXTRN	_TextToSpeechPause:NEAR
EXTRN	_TextToSpeechResume:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pKsd_t$ = 8
_cm_cmd_pause PROC NEAR

; 838  : {

  005c0	55		 push	 ebp

; 839  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  005c1	8b 6c 24 08	 mov	 ebp, DWORD PTR _phTTS$[esp]
  005c5	56		 push	 esi

; 840  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  005c6	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  005c9	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  005cc	89 44 24 0c	 mov	 DWORD PTR _pKsd_t$[esp+4], eax

; 841  : 	
; 842  : #ifdef MSDOS
; 843  : 	pKsd_t->pause = TRUE;
; 844  : 	STOP_SAMPCLK;
; 845  : 	if(pCmd_t->defaults[0] == FALSE)
; 846  : 	{
; 847  : 		sleep(pCmd_t->params[0]);
; 848  : 		pKsd_t->pause = FALSE;
; 849  : 		START_SAMPCLK;
; 850  : 	}
; 851  : 	return(CMD_success);
; 852  : #endif
; 853  : 
; 854  : /* GL 04/21/1997  change this for OSF build */
; 855  : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 856  :   /*LPTTS_HANDLE_T phTTS; */
; 857  :   DWORD dwDelay;
; 858  :   DWORD dwStartTime;
; 859  :   DWORD dwElapsedTime;
; 860  :   DWORD dwRemainingTime;
; 861  : 
; 862  : /* GL 10/30/1996, comment out this as V43 code
; 863  :   if( cm_cmd_sync(phTTS) == CMD_flushing )
; 864  : 	return(CMD_flushing);
; 865  : */
; 866  :   dwDelay = (DWORD)(pCmd_t->params[0]);

  005d0	8b 31		 mov	 esi, DWORD PTR [ecx]

; 867  : 
; 868  :   if ( dwDelay != 0 )

  005d2	85 f6		 test	 esi, esi
  005d4	74 57		 je	 SHORT $L72046
  005d6	53		 push	 ebx
  005d7	57		 push	 edi

; 869  :   {
; 870  : 	TextToSpeechPause( phTTS );

  005d8	55		 push	 ebp
  005d9	e8 00 00 00 00	 call	 _TextToSpeechPause

; 871  : 
; 872  : #ifdef WIN32
; 873  : 	dwStartTime = GetTickCount();

  005de	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  005e4	83 c4 04	 add	 esp, 4
  005e7	ff d7		 call	 edi
  005e9	8b d8		 mov	 ebx, eax

; 874  : 
; 875  : 	while ((( dwElapsedTime = GetTickCount() - dwStartTime ) < dwDelay )
; 876  : 		&& ( ! pKsd_t->halting ))

  005eb	ff d7		 call	 edi
  005ed	2b c3		 sub	 eax, ebx
  005ef	3b c6		 cmp	 eax, esi
  005f1	73 2a		 jae	 SHORT $L71590
$L71589:
  005f3	8b 54 24 14	 mov	 edx, DWORD PTR _pKsd_t$[esp+12]
  005f7	8b 8a 74 01 00
	00		 mov	 ecx, DWORD PTR [edx+372]
  005fd	85 c9		 test	 ecx, ecx
  005ff	75 1c		 jne	 SHORT $L71590

; 877  : 	{
; 878  : 	  dwRemainingTime = dwDelay - dwElapsedTime;

  00601	8b ce		 mov	 ecx, esi
  00603	2b c8		 sub	 ecx, eax

; 879  : 
; 880  : 	  if ( dwRemainingTime > 10 )

  00605	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00608	76 04		 jbe	 SHORT $L71591

; 881  : 	  {
; 882  : 			Sleep( 10 );

  0060a	6a 0a		 push	 10			; 0000000aH

; 883  : 	  }
; 884  : 	  else

  0060c	eb 01		 jmp	 SHORT $L72047
$L71591:

; 885  : 	  {
; 886  : 			Sleep( dwRemainingTime );

  0060e	51		 push	 ecx
$L72047:
  0060f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  00615	ff d7		 call	 edi
  00617	2b c3		 sub	 eax, ebx
  00619	3b c6		 cmp	 eax, esi
  0061b	72 d6		 jb	 SHORT $L71589
$L71590:

; 887  : 	  }
; 888  : 	}
; 889  : 	TextToSpeechResume( phTTS );

  0061d	55		 push	 ebp
  0061e	e8 00 00 00 00	 call	 _TextToSpeechResume
  00623	83 c4 04	 add	 esp, 4

; 890  : #endif
; 891  : /* GL 04/21/1997  add this for OSF build */
; 892  : #ifdef __osf__
; 893  :     while ((dwDelay > 0) && ( ! pKsd_t->halting))
; 894  :     {
; 895  : 	if ( dwDelay > 10)
; 896  : 	{
; 897  : 	    OP_Sleep(10);
; 898  : 	    dwDelay -= 10;
; 899  : 	}
; 900  : 	else
; 901  : 	{
; 902  : 	    OP_Sleep(dwDelay);
; 903  : 	    dwDelay = 0;
; 904  : 	}
; 905  :     }
; 906  :     TextToSpeechResume( phTTS );
; 907  : #endif
; 908  : #ifdef __linux__
; 909  :     while ((dwDelay > 0) && ( ! pKsd_t->halting))
; 910  :     {
; 911  :         if ( dwDelay > 10)
; 912  :         {
; 913  :             OP_Sleep(10);
; 914  :             dwDelay -= 10;
; 915  :         }
; 916  :         else
; 917  :         {
; 918  :             OP_Sleep(dwDelay);
; 919  :             dwDelay = 0;
; 920  :         }
; 921  :     }
; 922  :     TextToSpeechResume( phTTS );
; 923  : #endif
; 924  : 
; 925  : 	
; 926  :   }
; 927  :   return(CMD_success);

  00626	33 c0		 xor	 eax, eax
  00628	5f		 pop	 edi
  00629	5b		 pop	 ebx
  0062a	5e		 pop	 esi
  0062b	5d		 pop	 ebp

; 928  : #endif
; 929  : 
; 930  : }

  0062c	c3		 ret	 0
$L72046:
  0062d	5e		 pop	 esi

; 890  : #endif
; 891  : /* GL 04/21/1997  add this for OSF build */
; 892  : #ifdef __osf__
; 893  :     while ((dwDelay > 0) && ( ! pKsd_t->halting))
; 894  :     {
; 895  : 	if ( dwDelay > 10)
; 896  : 	{
; 897  : 	    OP_Sleep(10);
; 898  : 	    dwDelay -= 10;
; 899  : 	}
; 900  : 	else
; 901  : 	{
; 902  : 	    OP_Sleep(dwDelay);
; 903  : 	    dwDelay = 0;
; 904  : 	}
; 905  :     }
; 906  :     TextToSpeechResume( phTTS );
; 907  : #endif
; 908  : #ifdef __linux__
; 909  :     while ((dwDelay > 0) && ( ! pKsd_t->halting))
; 910  :     {
; 911  :         if ( dwDelay > 10)
; 912  :         {
; 913  :             OP_Sleep(10);
; 914  :             dwDelay -= 10;
; 915  :         }
; 916  :         else
; 917  :         {
; 918  :             OP_Sleep(dwDelay);
; 919  :             dwDelay = 0;
; 920  :         }
; 921  :     }
; 922  :     TextToSpeechResume( phTTS );
; 923  : #endif
; 924  : 
; 925  : 	
; 926  :   }
; 927  :   return(CMD_success);

  0062e	33 c0		 xor	 eax, eax
  00630	5d		 pop	 ebp

; 928  : #endif
; 929  : 
; 930  : }

  00631	c3		 ret	 0
_cm_cmd_pause ENDP
_phTTS$ = 8
_cm_cmd_resume PROC NEAR

; 948  : {

  00640	56		 push	 esi

; 949  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;
; 950  : #ifdef MSDOS
; 951  : 
; 952  : 	pKsd_t->pause = FALSE;
; 953  : 	START_SAMPCLK;
; 954  : #endif
; 955  : 
; 956  : /* GL 04/21/1997  change this for OSF build */
; 957  : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 958  :   if( cm_cmd_sync(phTTS) == CMD_flushing )

  00641	8b 74 24 08	 mov	 esi, DWORD PTR _phTTS$[esp]
  00645	56		 push	 esi
  00646	e8 00 00 00 00	 call	 _cm_cmd_sync
  0064b	83 c4 04	 add	 esp, 4
  0064e	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00651	75 02		 jne	 SHORT $L71597
  00653	5e		 pop	 esi

; 965  : }

  00654	c3		 ret	 0
$L71597:

; 959  : 	return(CMD_flushing);
; 960  : 
; 961  :   TextToSpeechResume( phTTS );

  00655	56		 push	 esi
  00656	e8 00 00 00 00	 call	 _TextToSpeechResume
  0065b	83 c4 04	 add	 esp, 4

; 962  : #endif
; 963  : 
; 964  :   return(CMD_success);          

  0065e	33 c0		 xor	 eax, eax
  00660	5e		 pop	 esi

; 965  : }

  00661	c3		 ret	 0
_cm_cmd_resume ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_flush
EXTRN	_start_flush:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_cm_cmd_flush PROC NEAR

; 984  : 	unsigned short int old_flags;                             
; 985  : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00670	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00674	53		 push	 ebx
  00675	56		 push	 esi
  00676	57		 push	 edi

; 986  : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00677	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  0067a	8b 70 08	 mov	 esi, DWORD PTR [eax+8]

; 987  : 
; 988  : 	if(pCmd_t->defaults[0] == TRUE || pCmd_t->defaults[1] == TRUE)

  0067d	bb 01 00 00 00	 mov	 ebx, 1
  00682	39 9f a8 02 00
	00		 cmp	 DWORD PTR [edi+680], ebx
  00688	0f 84 d9 00 00
	00		 je	 $L71612
  0068e	39 9f ac 02 00
	00		 cmp	 DWORD PTR [edi+684], ebx
  00694	0f 84 cd 00 00
	00		 je	 $L71612

; 989  : 	{
; 990  : #ifdef DTEX
; 991  : 		p_putc(XON);
; 992  : #endif /*DTEX*/
; 993  : 		return(CMD_success);
; 994  : 	}
; 995  : 	pCmd_t->params[0] = cm_util_string_match(flush_options, pCmd_t->pString[0]);

  0069a	8b 87 80 02 00
	00		 mov	 eax, DWORD PTR [edi+640]
  006a0	50		 push	 eax
  006a1	68 00 00 00 00	 push	 OFFSET FLAT:_flush_options
  006a6	e8 00 00 00 00	 call	 _cm_util_string_match
  006ab	83 c4 08	 add	 esp, 8

; 996  : 	if(pCmd_t->params[0] == NO_STRING_MATCH)

  006ae	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  006b3	89 07		 mov	 DWORD PTR [edi], eax
  006b5	75 06		 jne	 SHORT $L71606
  006b7	5f		 pop	 edi

; 997  : 		return(CMD_bad_string);

  006b8	8b c3		 mov	 eax, ebx
  006ba	5e		 pop	 esi
  006bb	5b		 pop	 ebx

; 1049 : 			break;
; 1050 : 
; 1051 : 	}
; 1052 : 	return(CMD_success);
; 1053 : }

  006bc	c3		 ret	 0
$L71606:

; 998  : 	if(pCmd_t->params[0] >= (sizeof(flush_options)/2))

  006bd	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  006c0	72 09		 jb	 SHORT $L71607
  006c2	5f		 pop	 edi
  006c3	5e		 pop	 esi

; 999  : 		return(CMD_bad_value);

  006c4	b8 02 00 00 00	 mov	 eax, 2
  006c9	5b		 pop	 ebx

; 1049 : 			break;
; 1050 : 
; 1051 : 	}
; 1052 : 	return(CMD_success);
; 1053 : }

  006ca	c3		 ret	 0
$L71607:

; 1000 : 	switch(pCmd_t->params[0])
; 1001 : 	{

  006cb	83 f8 04	 cmp	 eax, 4
  006ce	0f 87 93 00 00
	00		 ja	 $L71612
  006d4	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72050[eax*4]
$L71613:

; 1002 : 		case    0       :                               /* all */
; 1003 : 			return(CMD_success);
; 1004 : 			break;
; 1005 : 		
; 1006 : 		case    1       :                               /* until */
; 1007 : 
; 1008 : 			pKsd_t->spc_flush_type = SPC_flush_until;

  006db	89 9e ac 01 00
	00		 mov	 DWORD PTR [esi+428], ebx

; 1009 : 			pKsd_t->spc_flush_value = pCmd_t->params[1];

  006e1	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  006e4	89 8e a8 01 00
	00		 mov	 DWORD PTR [esi+424], ecx

; 1010 : 			pKsd_t->spc_flush = TRUE;

  006ea	89 9e a4 01 00
	00		 mov	 DWORD PTR [esi+420], ebx
  006f0	5f		 pop	 edi
  006f1	5e		 pop	 esi
  006f2	33 c0		 xor	 eax, eax
  006f4	5b		 pop	 ebx

; 1049 : 			break;
; 1050 : 
; 1051 : 	}
; 1052 : 	return(CMD_success);
; 1053 : }

  006f5	c3		 ret	 0
$L71614:

; 1011 : 			break;
; 1012 : 
; 1013 : 		case    2       :                               /* mask */
; 1014 : 
; 1015 : 			pKsd_t->spc_flush_type = SPC_flush_mask;

  006f6	c7 86 ac 01 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+428], 2

; 1016 : 			pKsd_t->spc_flush_value = pCmd_t->params[1];

  00700	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00703	89 96 a8 01 00
	00		 mov	 DWORD PTR [esi+424], edx

; 1017 : 			pKsd_t->spc_flush = TRUE;

  00709	89 9e a4 01 00
	00		 mov	 DWORD PTR [esi+420], ebx
  0070f	5f		 pop	 edi
  00710	5e		 pop	 esi
  00711	33 c0		 xor	 eax, eax
  00713	5b		 pop	 ebx

; 1049 : 			break;
; 1050 : 
; 1051 : 	}
; 1052 : 	return(CMD_success);
; 1053 : }

  00714	c3		 ret	 0
$L71615:

; 1018 : 			break;
; 1019 : 
; 1020 : 		case    3       :                               /* after */
; 1021 : 
; 1022 : #ifdef MSDOS                    
; 1023 : 			old_flags = kernel_disable();
; 1024 : #endif
; 1025 : 			if(pKsd_t->halting == FALSE)

  00715	8b 86 74 01 00
	00		 mov	 eax, DWORD PTR [esi+372]
  0071b	85 c0		 test	 eax, eax
  0071d	75 23		 jne	 SHORT $L71616

; 1026 : 			{
; 1027 : 				pKsd_t->spc_flush_type = SPC_flush_after;

  0071f	c7 86 ac 01 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+428], 3

; 1028 : 				pKsd_t->spc_flush_value = pCmd_t->params[1];

  00729	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0072c	89 86 a8 01 00
	00		 mov	 DWORD PTR [esi+424], eax

; 1029 : 				pKsd_t->spc_flush = TRUE;

  00732	89 9e a4 01 00
	00		 mov	 DWORD PTR [esi+420], ebx

; 1030 : 				pKsd_t->spc_sync.value = 0;

  00738	c7 86 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+480], 0
$L71616:

; 1031 : #ifdef MSDOS
; 1032 : 				wait_semaphore(&pKsd_t->spc_sync);
; 1033 : #endif
; 1034 : 			}
; 1035 : #ifdef MSDOS
; 1036 : 			else
; 1037 : 			{                    
; 1038 : 				kernel_enable(old_flags);
; 1039 : 			}
; 1040 : #endif
; 1041 : 			start_flush(TRUE);

  00742	53		 push	 ebx
  00743	e8 00 00 00 00	 call	 _start_flush
  00748	83 c4 04	 add	 esp, 4
  0074b	33 c0		 xor	 eax, eax
  0074d	5f		 pop	 edi
  0074e	5e		 pop	 esi
  0074f	5b		 pop	 ebx

; 1049 : 			break;
; 1050 : 
; 1051 : 	}
; 1052 : 	return(CMD_success);
; 1053 : }

  00750	c3		 ret	 0
$L71617:

; 1042 : 			break;
; 1043 : 
; 1044 : 		case    4       :                               /* text */
; 1045 : 
; 1046 : 			pKsd_t->spc_flush_type = SPC_flush_all;

  00751	c7 86 ac 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+428], 0

; 1047 : 			pKsd_t->spc_flush = TRUE;

  0075b	89 9e a4 01 00
	00		 mov	 DWORD PTR [esi+420], ebx

; 1048 : 			pKsd_t->text_flush = TRUE;

  00761	89 9e 70 01 00
	00		 mov	 DWORD PTR [esi+368], ebx
$L71612:
  00767	5f		 pop	 edi
  00768	5e		 pop	 esi
  00769	33 c0		 xor	 eax, eax
  0076b	5b		 pop	 ebx

; 1049 : 			break;
; 1050 : 
; 1051 : 	}
; 1052 : 	return(CMD_success);
; 1053 : }

  0076c	c3		 ret	 0
  0076d	8d 49 00	 npad	 3
$L72050:
  00770	00 00 00 00	 DD	 $L71612
  00774	00 00 00 00	 DD	 $L71613
  00778	00 00 00 00	 DD	 $L71614
  0077c	00 00 00 00	 DD	 $L71615
  00780	00 00 00 00	 DD	 $L71617
_cm_cmd_flush ENDP
_TEXT	ENDS
EXTRN	__imp__ResetEvent@4:NEAR
EXTRN	__imp__WaitForSingleObject@8:NEAR
EXTRN	_cm_util_write_pipe:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pipe_value$ = 8
_cm_cmd_sync PROC NEAR

; 1071 : {   

  00790	56		 push	 esi
  00791	57		 push	 edi

; 1072 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00792	8b 7c 24 0c	 mov	 edi, DWORD PTR _phTTS$[esp+4]
  00796	8b 77 08	 mov	 esi, DWORD PTR [edi+8]

; 1073 : 
; 1074 : #ifdef MSDOS
; 1075 : 	DT_PIPE_T pipe_value;
; 1076 : 	unsigned int old_flags;
; 1077 : 	
; 1078 : #ifdef DTEX
; 1079 : 	/* 
; 1080 : 	 * pKsd_t->idleflag is used to tell when we've been quiescent long
; 1081 : 	 * enough to fall asleep.. 
; 1082 : 	 */
; 1083 : 	pKsd_t->idleflag = 0;
; 1084 : #endif /*DTEX*/ 
; 1085 : 
; 1086 : 	old_flags = kernel_disable();
; 1087 : 	if(pKsd_t->halting == FALSE)
; 1088 : 	{
; 1089 : 		pKsd_t->spc_sync.value = 0;
; 1090 : 		pipe_value = (PFASCII<<PSFONT)+0xb;
; 1091 :                 cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,&pipe_value,1);
; 1092 : 		pipe_value = SYNC;
; 1093 :                 cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,&pipe_value,1);
; 1094 : 		kernel_enable(old_flags);
; 1095 : 		wait_semaphore(&(pKsd_t->spc_sync));
; 1096 : 	}
; 1097 : 	else
; 1098 : 	{
; 1099 : 		kernel_enable(old_flags);
; 1100 : 	}                 
; 1101 : 
; 1102 : 	
; 1103 : 	if(pKsd_t->cmd_flush)
; 1104 : 		return(CMD_flushing);
; 1105 : 	return(CMD_success);
; 1106 : #endif /* #ifdef MSDOS */       
; 1107 : 
; 1108 : /* GL 04/21/1997  add this for OSF build */
; 1109 : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 1110 :   DT_PIPE_T pipe_value;
; 1111 : 
; 1112 : /*  LPTTS_HANDLE_T phTTS; */    /* MVP MI earlier the value of phTTS used to get by
; 1113 : 									TextToSpeechGetHandle()
; 1114 : 								*/
; 1115 : 
; 1116 :   if(pKsd_t->halting == FALSE)

  00799	8b 86 74 01 00
	00		 mov	 eax, DWORD PTR [esi+372]
  0079f	85 c0		 test	 eax, eax
  007a1	75 5b		 jne	 SHORT $L71623

; 1117 :   {
; 1118 : 	/*phTTS = TextToSpeechGetHandle();*/   /*MVP MI */
; 1119 : 
; 1120 : #ifdef WIN32
; 1121 : 	  ResetEvent( phTTS->hSyncEvent );

  007a3	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  007a6	50		 push	 eax
  007a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResetEvent@4

; 1122 : #endif
; 1123 : /* GL 04/21/1997  add this for OSF build */
; 1124 : #ifdef __osf__
; 1125 :     OP_ResetEvent( phTTS->hSyncEvent );
; 1126 : #endif
; 1127 : #ifdef __linux__
; 1128 :     OP_ResetEvent( phTTS->hSyncEvent );
; 1129 : #endif
; 1130 : 
; 1131 : 	pKsd_t->spc_sync.value = 0;

  007ad	c7 86 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+480], 0

; 1132 : 	pipe_value = (PFASCII<<PSFONT)+0xb;

  007b7	c7 44 24 0c 0b
	00 00 00	 mov	 DWORD PTR _pipe_value$[esp+4], 11 ; 0000000bH

; 1133 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,&pipe_value,1);

  007bf	8b 96 d0 00 00
	00		 mov	 edx, DWORD PTR [esi+208]
  007c5	8d 4c 24 0c	 lea	 ecx, DWORD PTR _pipe_value$[esp+4]
  007c9	6a 01		 push	 1
  007cb	51		 push	 ecx
  007cc	52		 push	 edx
  007cd	56		 push	 esi
  007ce	e8 00 00 00 00	 call	 _cm_util_write_pipe

; 1134 : 	pipe_value = SYNC;

  007d3	c7 44 24 1c 0a
	1f 00 00	 mov	 DWORD PTR _pipe_value$[esp+20], 7946 ; 00001f0aH

; 1135 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,&pipe_value,1);

  007db	8b 8e d0 00 00
	00		 mov	 ecx, DWORD PTR [esi+208]
  007e1	8d 44 24 1c	 lea	 eax, DWORD PTR _pipe_value$[esp+20]
  007e5	6a 01		 push	 1
  007e7	50		 push	 eax
  007e8	51		 push	 ecx
  007e9	56		 push	 esi
  007ea	e8 00 00 00 00	 call	 _cm_util_write_pipe

; 1136 : 
; 1137 : #ifdef WIN32
; 1138 : 	WaitForSingleObject( phTTS->hSyncEvent, INFINITE );

  007ef	8b 57 38	 mov	 edx, DWORD PTR [edi+56]
  007f2	83 c4 20	 add	 esp, 32			; 00000020H
  007f5	6a ff		 push	 -1
  007f7	52		 push	 edx
  007f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
$L71623:

; 1139 : #endif
; 1140 : /* GL 04/21/1997  add this for OSF build */
; 1141 : #ifdef __osf__
; 1142 :     OP_WaitForEvent( phTTS->hSyncEvent, OP_INFINITE );
; 1143 : #endif
; 1144 : #ifdef __linux__
; 1145 :     OP_WaitForEvent( phTTS->hSyncEvent, OP_INFINITE );
; 1146 : #endif
; 1147 : 
; 1148 :   }
; 1149 : 
; 1150 :   if(pKsd_t->cmd_flush)

  007fe	8b 86 6c 01 00
	00		 mov	 eax, DWORD PTR [esi+364]
  00804	5f		 pop	 edi
  00805	f7 d8		 neg	 eax
  00807	1b c0		 sbb	 eax, eax
  00809	5e		 pop	 esi
  0080a	83 e0 0b	 and	 eax, 11			; 0000000bH

; 1151 : 	return(CMD_flushing);
; 1152 : 
; 1153 :   return(CMD_success);
; 1154 : 
; 1155 : #endif
; 1156 : }

  0080d	c3		 ret	 0
_cm_cmd_sync ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_enable
EXTRN	_reset_spc:NEAR
EXTRN	_wait_semaphore:NEAR
_TEXT	SEGMENT
_pKsd_t$ = 8
_pipe_value$ = 8
_cm_cmd_enable PROC NEAR

; 1172 : {

  00810	56		 push	 esi

; 1173 : 	DT_PIPE_T pipe_value;
; 1174 : #ifdef MSDOS
; 1175 : 	unsigned int old_flags; 
; 1176 : 	old_flags = kernel_disable();
; 1177 : #endif
; 1178 : 	if(pKsd_t->halting == FALSE)

  00811	8b 74 24 08	 mov	 esi, DWORD PTR _pKsd_t$[esp]
  00815	8b 86 74 01 00
	00		 mov	 eax, DWORD PTR [esi+372]
  0081b	85 c0		 test	 eax, eax
  0081d	75 4f		 jne	 SHORT $L71629

; 1179 : 	{
; 1180 : 		pKsd_t->spc_sync.value = 0;
; 1181 : 		pipe_value = (PFASCII<<PSFONT)+0xb;
; 1182 :                 cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,&pipe_value,1);

  0081f	8b 8e d0 00 00
	00		 mov	 ecx, DWORD PTR [esi+208]
  00825	57		 push	 edi
  00826	8d 44 24 0c	 lea	 eax, DWORD PTR _pipe_value$[esp+4]
  0082a	6a 01		 push	 1
  0082c	8d be e0 01 00
	00		 lea	 edi, DWORD PTR [esi+480]
  00832	50		 push	 eax
  00833	51		 push	 ecx
  00834	56		 push	 esi
  00835	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0083b	c7 44 24 1c 0b
	00 00 00	 mov	 DWORD PTR _pipe_value$[esp+20], 11 ; 0000000bH
  00843	e8 00 00 00 00	 call	 _cm_util_write_pipe

; 1183 : 		pipe_value = SYNC;
; 1184 :                 cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,&pipe_value,1);

  00848	8b 86 d0 00 00
	00		 mov	 eax, DWORD PTR [esi+208]
  0084e	8d 54 24 1c	 lea	 edx, DWORD PTR _pipe_value$[esp+20]
  00852	6a 01		 push	 1
  00854	52		 push	 edx
  00855	50		 push	 eax
  00856	56		 push	 esi
  00857	c7 44 24 2c 0a
	1f 00 00	 mov	 DWORD PTR _pipe_value$[esp+36], 7946 ; 00001f0aH
  0085f	e8 00 00 00 00	 call	 _cm_util_write_pipe

; 1185 : #ifdef MSDOS
; 1186 : 		kernel_enable(old_flags);
; 1187 : #endif          
; 1188 : #ifndef __linux__
; 1189 : 		wait_semaphore(&pKsd_t->spc_sync);

  00864	57		 push	 edi
  00865	e8 00 00 00 00	 call	 _wait_semaphore
  0086a	83 c4 24	 add	 esp, 36			; 00000024H
  0086d	5f		 pop	 edi
$L71629:

; 1190 : #endif
; 1191 : 	}
; 1192 : #ifdef MSDOS
; 1193 : 	else
; 1194 : 	{
; 1195 : 		kernel_enable(old_flags);
; 1196 : 	}
; 1197 : #endif
; 1198 : 	pKsd_t->spc_flush = FALSE;

  0086e	c7 86 a4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+420], 0

; 1199 : 	pKsd_t->text_flush = FALSE;

  00878	c7 86 70 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+368], 0

; 1200 : 	reset_spc();

  00882	e8 00 00 00 00	 call	 _reset_spc

; 1201 : 	return(CMD_success);

  00887	33 c0		 xor	 eax, eax
  00889	5e		 pop	 esi

; 1202 : }

  0088a	c3		 ret	 0
_cm_cmd_enable ENDP
_phTTS$ = 8
_cm_cmd_punct PROC NEAR

; 1221 : 	int     value;
; 1222 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00890	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00894	56		 push	 esi
  00895	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]

; 1223 : 	
; 1224 : 	value = cm_util_string_match(punct_options,pCmd_t->pString[0]);

  00898	8b 8e 80 02 00
	00		 mov	 ecx, DWORD PTR [esi+640]
  0089e	51		 push	 ecx
  0089f	68 00 00 00 00	 push	 OFFSET FLAT:_punct_options
  008a4	e8 00 00 00 00	 call	 _cm_util_string_match
  008a9	83 c4 08	 add	 esp, 8

; 1225 : 	if(value == NO_STRING_MATCH)

  008ac	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  008b1	75 07		 jne	 SHORT $L71636

; 1226 : 		return(CMD_bad_string);

  008b3	b8 01 00 00 00	 mov	 eax, 1
  008b8	5e		 pop	 esi

; 1255 : }

  008b9	c3		 ret	 0
$L71636:

; 1227 : 	switch(value)
; 1228 :     {

  008ba	83 f8 03	 cmp	 eax, 3
  008bd	77 3f		 ja	 SHORT $L71645
  008bf	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72054[eax*4]
$L71641:

; 1229 : 		case    PUNCT_none       :
; 1230 : 
; 1231 : 			pCmd_t->punct_mode = PUNCT_none;

  008c6	c7 86 00 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1280], 0

; 1251 : 			break;
; 1252 : 	}         
; 1253 : 		/* pCmd_t->punct_mode=value; duplicate code? cjl 26-sep-95 */
; 1254 : 		return(CMD_success);

  008d0	33 c0		 xor	 eax, eax
  008d2	5e		 pop	 esi

; 1255 : }

  008d3	c3		 ret	 0
$L71642:

; 1232 : 			break;
; 1233 : 
; 1234 : 		case    PUNCT_some       :
; 1235 : 
; 1236 : 			pCmd_t->punct_mode = PUNCT_some;

  008d4	c7 86 00 05 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+1280], 1

; 1251 : 			break;
; 1252 : 	}         
; 1253 : 		/* pCmd_t->punct_mode=value; duplicate code? cjl 26-sep-95 */
; 1254 : 		return(CMD_success);

  008de	33 c0		 xor	 eax, eax
  008e0	5e		 pop	 esi

; 1255 : }

  008e1	c3		 ret	 0
$L71643:

; 1237 : 			break;
; 1238 : 
; 1239 : 		case    PUNCT_all       :
; 1240 : 
; 1241 : 			pCmd_t->punct_mode = PUNCT_all;

  008e2	c7 86 00 05 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+1280], 2

; 1251 : 			break;
; 1252 : 	}         
; 1253 : 		/* pCmd_t->punct_mode=value; duplicate code? cjl 26-sep-95 */
; 1254 : 		return(CMD_success);

  008ec	33 c0		 xor	 eax, eax
  008ee	5e		 pop	 esi

; 1255 : }

  008ef	c3		 ret	 0
$L71644:

; 1242 : 			break;
; 1243 : 				
; 1244 : 		case    PUNCT_pass       :
; 1245 : 
; 1246 : 			pCmd_t->punct_mode = PUNCT_pass;

  008f0	c7 86 00 05 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+1280], 3

; 1251 : 			break;
; 1252 : 	}         
; 1253 : 		/* pCmd_t->punct_mode=value; duplicate code? cjl 26-sep-95 */
; 1254 : 		return(CMD_success);

  008fa	33 c0		 xor	 eax, eax
  008fc	5e		 pop	 esi

; 1255 : }

  008fd	c3		 ret	 0
$L71645:

; 1247 : 			break;
; 1248 : 				
; 1249 : 		default                  :
; 1250 : 			return(CMD_bad_value);

  008fe	b8 02 00 00 00	 mov	 eax, 2
  00903	5e		 pop	 esi

; 1255 : }

  00904	c3		 ret	 0
  00905	8d 49 00	 npad	 3
$L72054:
  00908	00 00 00 00	 DD	 $L71641
  0090c	00 00 00 00	 DD	 $L71642
  00910	00 00 00 00	 DD	 $L71643
  00914	00 00 00 00	 DD	 $L71644
_cm_cmd_punct ENDP
_phTTS$ = 8
_cm_cmd_skip PROC NEAR

; 1274 : 	int     value;
; 1275 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00920	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00924	56		 push	 esi
  00925	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]

; 1276 : 	
; 1277 : 	value = cm_util_string_match(skip_options,pCmd_t->pString[0]);

  00928	8b 8e 80 02 00
	00		 mov	 ecx, DWORD PTR [esi+640]
  0092e	51		 push	 ecx
  0092f	68 00 00 00 00	 push	 OFFSET FLAT:_skip_options
  00934	e8 00 00 00 00	 call	 _cm_util_string_match
  00939	83 c4 08	 add	 esp, 8

; 1278 : 	if(value == NO_STRING_MATCH)

  0093c	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00941	75 07		 jne	 SHORT $L71651

; 1279 : 		return(CMD_bad_string);

  00943	b8 01 00 00 00	 mov	 eax, 1
  00948	5e		 pop	 esi

; 1318 : }

  00949	c3		 ret	 0
$L71651:

; 1280 : 	switch(value)
; 1281 :     {

  0094a	83 f8 05	 cmp	 eax, 5
  0094d	77 5b		 ja	 SHORT $L71662
  0094f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72056[eax*4]
$L71656:

; 1282 : 		case    SKIP_none       :
; 1283 : 
; 1284 : 			pCmd_t->skip_mode = SKIP_none;

  00956	c7 86 04 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1284], 0

; 1314 : 			break;
; 1315 : 	}         
; 1316 : 
; 1317 : 		return(CMD_success);

  00960	33 c0		 xor	 eax, eax
  00962	5e		 pop	 esi

; 1318 : }

  00963	c3		 ret	 0
$L71657:

; 1285 : 			break;
; 1286 : 
; 1287 : 		case    SKIP_email       :
; 1288 : 
; 1289 : 			pCmd_t->skip_mode = SKIP_email;

  00964	c7 86 04 05 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+1284], 1

; 1314 : 			break;
; 1315 : 	}         
; 1316 : 
; 1317 : 		return(CMD_success);

  0096e	33 c0		 xor	 eax, eax
  00970	5e		 pop	 esi

; 1318 : }

  00971	c3		 ret	 0
$L71658:

; 1290 : 			break;
; 1291 : 
; 1292 : 		case    SKIP_punct       :
; 1293 : 
; 1294 : 			pCmd_t->skip_mode = SKIP_punct;

  00972	c7 86 04 05 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+1284], 2

; 1314 : 			break;
; 1315 : 	}         
; 1316 : 
; 1317 : 		return(CMD_success);

  0097c	33 c0		 xor	 eax, eax
  0097e	5e		 pop	 esi

; 1318 : }

  0097f	c3		 ret	 0
$L71659:

; 1295 : 			break;
; 1296 : 
; 1297 : 		case    SKIP_rule       :
; 1298 : 
; 1299 : 			pCmd_t->skip_mode = SKIP_rule;

  00980	c7 86 04 05 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+1284], 3

; 1314 : 			break;
; 1315 : 	}         
; 1316 : 
; 1317 : 		return(CMD_success);

  0098a	33 c0		 xor	 eax, eax
  0098c	5e		 pop	 esi

; 1318 : }

  0098d	c3		 ret	 0
$L71660:

; 1300 : 			break;
; 1301 : 				
; 1302 : 		case    SKIP_all       :
; 1303 : 
; 1304 : 			pCmd_t->skip_mode = SKIP_all;

  0098e	c7 86 04 05 00
	00 04 00 00 00	 mov	 DWORD PTR [esi+1284], 4

; 1314 : 			break;
; 1315 : 	}         
; 1316 : 
; 1317 : 		return(CMD_success);

  00998	33 c0		 xor	 eax, eax
  0099a	5e		 pop	 esi

; 1318 : }

  0099b	c3		 ret	 0
$L71661:

; 1305 : 			break;
; 1306 : 				
; 1307 : 		case    SKIP_cpg       :
; 1308 : 
; 1309 : 			pCmd_t->skip_mode = SKIP_cpg;

  0099c	c7 86 04 05 00
	00 05 00 00 00	 mov	 DWORD PTR [esi+1284], 5

; 1314 : 			break;
; 1315 : 	}         
; 1316 : 
; 1317 : 		return(CMD_success);

  009a6	33 c0		 xor	 eax, eax
  009a8	5e		 pop	 esi

; 1318 : }

  009a9	c3		 ret	 0
$L71662:

; 1310 : 			break;
; 1311 : 				
; 1312 : 		default                  :
; 1313 : 			return(CMD_bad_value);

  009aa	b8 02 00 00 00	 mov	 eax, 2
  009af	5e		 pop	 esi

; 1318 : }

  009b0	c3		 ret	 0
  009b1	8d 49 00	 npad	 3
$L72056:
  009b4	00 00 00 00	 DD	 $L71656
  009b8	00 00 00 00	 DD	 $L71657
  009bc	00 00 00 00	 DD	 $L71658
  009c0	00 00 00 00	 DD	 $L71659
  009c4	00 00 00 00	 DD	 $L71660
  009c8	00 00 00 00	 DD	 $L71661
_cm_cmd_skip ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_timeout
_TEXT	SEGMENT
_phTTS$ = 8
_cm_cmd_timeout PROC NEAR

; 1337 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  009d0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  009d4	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 1338 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  009d7	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 1339 : 	
; 1340 : 	if(pCmd_t->defaults[0] == TRUE)

  009da	83 b8 a8 02 00
	00 01		 cmp	 DWORD PTR [eax+680], 1
  009e1	75 06		 jne	 SHORT $L71668

; 1341 : 		pCmd_t->params[0] = 0;

  009e3	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L71668:

; 1342 : 
; 1343 : 	pCmd_t->timeout = pCmd_t->params[0];

  009e9	66 8b 08	 mov	 cx, WORD PTR [eax]
  009ec	66 89 88 88 57
	00 00		 mov	 WORD PTR [eax+22408], cx

; 1344 : 	pKsd_t->input_timeout = pCmd_t->timeout;

  009f3	0f bf c1	 movsx	 eax, cx
  009f6	89 82 18 02 00
	00		 mov	 DWORD PTR [edx+536], eax

; 1345 : 	return(CMD_success);

  009fc	33 c0		 xor	 eax, eax

; 1346 : }

  009fe	c3		 ret	 0
_cm_cmd_timeout ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_cpu_rate
_TEXT	SEGMENT
_cm_cmd_cpu_rate PROC NEAR

; 1364 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 1365 : #ifdef MSDOS    
; 1366 : 	if(pCmd_t->defaults[0] == TRUE)
; 1367 : 		pCmd_t->params[0] = 10;
; 1368 : 	if(pCmd_t->params[0] <= 0 || pCmd_t->params[0] > 25)
; 1369 : 		return(CMD_bad_value);
; 1370 : 	module_clocks(pCmd_t->params[0]);
; 1371 : #endif
; 1372 : 	return(CMD_success);

  00a00	33 c0		 xor	 eax, eax

; 1373 : }

  00a02	c3		 ret	 0
_cm_cmd_cpu_rate ENDP
_phTTS$ = 8
_cm_cmd_setv PROC NEAR

; 1391 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00a10	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00a14	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 1392 :     short cmd_number = pCmd_t->params[0]; /*MVP MI New*/
; 1393 : 	
; 1394 : 	if(pCmd_t->params[0] < 0 || pCmd_t->params[0] > 9)

  00a17	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a19	83 f9 09	 cmp	 ecx, 9
  00a1c	77 1c		 ja	 SHORT $L71679

; 1396 : 	pCmd_t->cmd_count=0;

  00a1e	66 c7 80 10 05
	00 00 00 00	 mov	 WORD PTR [eax+1296], 0

; 1397 : 	pCmd_t->cmd_number = pCmd_t->params[0];

  00a27	66 89 88 12 05
	00 00		 mov	 WORD PTR [eax+1298], cx

; 1398 : 	/* 
; 1399 :      * Tells command parser that its time to process                   
; 1400 : 	 * internally stored command string 
; 1401 : 	 */
; 1402 : 	// BATS#638 mfg 3/30/98 set insertflag equalto 2 on VOCAL build
; 1403 : #ifdef VOCAL
; 1404 : 	pCmd_t->insertflag=2;
; 1405 : #else
; 1406 : 	pCmd_t->insertflag=1;

  00a2e	66 c7 80 14 05
	00 00 01 00	 mov	 WORD PTR [eax+1300], 1

; 1407 : #endif	
; 1408 : 
; 1409 : 	return(CMD_success);

  00a37	33 c0		 xor	 eax, eax

; 1410 : }

  00a39	c3		 ret	 0
$L71679:

; 1395 : 		return(CMD_bad_value);

  00a3a	b8 02 00 00 00	 mov	 eax, 2

; 1410 : }

  00a3f	c3		 ret	 0
_cm_cmd_setv ENDP
_TEXT	ENDS
EXTRN	_read_pipe:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pKsd_t$ = 8
_temp$ = -60
_cm_cmd_loadv PROC NEAR

; 1426 : {   

  00a40	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 1427 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00a43	8b 44 24 40	 mov	 eax, DWORD PTR _phTTS$[esp+56]
  00a47	53		 push	 ebx
  00a48	55		 push	 ebp

; 1428 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;
; 1429 :    /* 
; 1430 :     *this will probably crash and burn if a flush happens 
; 1431 : 	* in the middle.. (tek 1/3/96)
; 1432 : 	*/
; 1433 :    unsigned char temp[60];
; 1434 :    int j=0;

  00a49	33 db		 xor	 ebx, ebx
  00a4b	8b 68 0c	 mov	 ebp, DWORD PTR [eax+12]
  00a4e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00a51	89 44 24 48	 mov	 DWORD PTR _pKsd_t$[esp+64], eax
  00a55	57		 push	 edi

; 1435 :    int flag=1;
; 1436 :    short cmd_number = pCmd_t->params[0];  /* MVP MI new */
; 1437 :    
; 1438 :    if(pCmd_t->params[0] < 0 || pCmd_t->params[0] > 9)

  00a56	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00a59	bf 01 00 00 00	 mov	 edi, 1
  00a5e	83 f8 09	 cmp	 eax, 9
  00a61	77 7b		 ja	 SHORT $L71690

; 1440 :    pCmd_t->cmd_count=0;
; 1441 :    pCmd_t->cmd_number = pCmd_t->params[0];

  00a63	66 8b c8	 mov	 cx, ax
  00a66	56		 push	 esi
  00a67	66 89 9d 10 05
	00 00		 mov	 WORD PTR [ebp+1296], bx
  00a6e	66 89 8d 12 05
	00 00		 mov	 WORD PTR [ebp+1298], cx
  00a75	8d 74 24 10	 lea	 esi, DWORD PTR _temp$[esp+76]
$L71692:

; 1442 :    while (flag) 
; 1443 :    {
; 1444 : /* GL 04/21/1997  change this for OSF build */
; 1445 : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 1446 :           read_pipe(pKsd_t->cmd_pipe, &temp[j], 1);

  00a79	8b 54 24 50	 mov	 edx, DWORD PTR _pKsd_t$[esp+72]
  00a7d	6a 01		 push	 1
  00a7f	56		 push	 esi
  00a80	8b 82 d8 00 00
	00		 mov	 eax, DWORD PTR [edx+216]
  00a86	50		 push	 eax
  00a87	e8 00 00 00 00	 call	 _read_pipe

; 1447 : #endif
; 1448 : 
; 1449 : #ifdef MSDOS
; 1450 : 	  temp[j] = getc();
; 1451 : #endif
; 1452 : 	  if (temp[j] == ']')

  00a8c	8a 06		 mov	 al, BYTE PTR [esi]
  00a8e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a91	3c 5d		 cmp	 al, 93			; 0000005dH
  00a93	75 02		 jne	 SHORT $L71694

; 1453 : 		flag = 0;

  00a95	33 ff		 xor	 edi, edi
$L71694:

; 1454 : 	  j++;

  00a97	43		 inc	 ebx
  00a98	46		 inc	 esi
  00a99	85 ff		 test	 edi, edi
  00a9b	75 dc		 jne	 SHORT $L71692

; 1455 :    }
; 1456 :    temp[j] = '\0';

  00a9d	c6 44 1c 10 00	 mov	 BYTE PTR _temp$[esp+ebx+76], 0

; 1457 :    strcpy(pCmd_t->setv[pCmd_t->cmd_number].cmd,temp); 

  00aa2	8d 7c 24 10	 lea	 edi, DWORD PTR _temp$[esp+76]
  00aa6	0f bf 85 12 05
	00 00		 movsx	 eax, WORD PTR [ebp+1298]
  00aad	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00ab0	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00ab3	33 c0		 xor	 eax, eax
  00ab5	8d 54 8d 28	 lea	 edx, DWORD PTR [ebp+ecx*4+40]
  00ab9	83 c9 ff	 or	 ecx, -1
  00abc	f2 ae		 repne scasb
  00abe	f7 d1		 not	 ecx
  00ac0	2b f9		 sub	 edi, ecx
  00ac2	8b c1		 mov	 eax, ecx
  00ac4	8b f7		 mov	 esi, edi
  00ac6	8b fa		 mov	 edi, edx
  00ac8	c1 e9 02	 shr	 ecx, 2
  00acb	f3 a5		 rep movsd
  00acd	8b c8		 mov	 ecx, eax
  00acf	83 e1 03	 and	 ecx, 3

; 1458 :    return(CMD_success);

  00ad2	33 c0		 xor	 eax, eax
  00ad4	f3 a4		 rep movsb
  00ad6	5e		 pop	 esi
  00ad7	5f		 pop	 edi
  00ad8	5d		 pop	 ebp
  00ad9	5b		 pop	 ebx

; 1459 : }

  00ada	83 c4 3c	 add	 esp, 60			; 0000003cH
  00add	c3		 ret	 0
$L71690:
  00ade	5f		 pop	 edi
  00adf	5d		 pop	 ebp

; 1439 : 		return(CMD_bad_value);

  00ae0	b8 02 00 00 00	 mov	 eax, 2
  00ae5	5b		 pop	 ebx

; 1459 : }

  00ae6	83 c4 3c	 add	 esp, 60			; 0000003cH
  00ae9	c3		 ret	 0
_cm_cmd_loadv ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_code_page
_TEXT	SEGMENT
_cm_cmd_code_page PROC NEAR

; 1478 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;
; 1479 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 1480 : 
; 1481 : #ifdef MSDOS    
; 1482 : 	volatile struct dtpc_code_pages _far *cp;
; 1483 : 	int     i;
; 1484 : 
; 1485 : 	if(pCmd_t->defaults[0] == TRUE || pCmd_t->params[0] == 0)
; 1486 : 	{
; 1487 : 		for(i=0;i<256;i++)
; 1488 : 			pKsd_t->code_page[i] = i;
; 1489 : 		return(CMD_success);
; 1490 : 	}
; 1491 : 
; 1492 : 
; 1493 : 	cp = pKsd_t->loaded_code_pages;
; 1494 : 	while(cp != NULL_CP)
; 1495 : 	{
; 1496 : 		if((*cp).dos_id == (int)pCmd_t->params[0])
; 1497 : 		{
; 1498 : 			for(i=0;i<256;i++)
; 1499 : 				pKsd_t->code_page[i] = (*cp).translation_page[i];
; 1500 : 			return(CMD_success);
; 1501 : 		}
; 1502 : 		cp = (*cp).link;
; 1503 : 	}
; 1504 : #endif /* MSDOS */              
; 1505 : 	return(CMD_bad_value);

  00af0	b8 02 00 00 00	 mov	 eax, 2

; 1506 : }

  00af5	c3		 ret	 0
_cm_cmd_code_page ENDP
_TEXT	ENDS
EXTRN	_StereoVolumeControl:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_cm_cmd_vs PROC NEAR

; 1525 : 	PCMD_T pCmd_t=phTTS->pCMDThreadData;

  00b00	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]

; 1526 : #ifdef MSDOS
; 1527 : 	vol_set(pCmd_t->params[0]);
; 1528 : #else                      
; 1529 : 			StereoVolumeControl( phTTS,
; 1530 : 						 		pCmd_t->params[0],
; 1531 : 						 		VOLUME_SET,
; 1532 : 						 		TRUE,
; 1533 : 						 		TRUE );

  00b04	6a 01		 push	 1
  00b06	6a 01		 push	 1
  00b08	6a 00		 push	 0
  00b0a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00b0d	8b 11		 mov	 edx, DWORD PTR [ecx]
  00b0f	52		 push	 edx
  00b10	50		 push	 eax
  00b11	e8 00 00 00 00	 call	 _StereoVolumeControl
  00b16	83 c4 14	 add	 esp, 20			; 00000014H

; 1534 : #endif
; 1535 : 	return(CMD_success);

  00b19	33 c0		 xor	 eax, eax

; 1536 : }                              

  00b1b	c3		 ret	 0
_cm_cmd_vs ENDP
_TEXT	ENDS
EXTRN	_SetStereoVolume:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_cm_cmd_volume PROC NEAR

; 1558 : {

  00b20	53		 push	 ebx
  00b21	55		 push	 ebp
  00b22	56		 push	 esi

; 1559 : 	int     cmd_type, cmd_value;
; 1560 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00b23	8b 74 24 10	 mov	 esi, DWORD PTR _phTTS$[esp+8]
  00b27	57		 push	 edi
  00b28	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]

; 1561 : 
; 1562 : 	cmd_type = cm_util_string_match(volume_options, pCmd_t->pString[0]);

  00b2b	8b 83 80 02 00
	00		 mov	 eax, DWORD PTR [ebx+640]
  00b31	50		 push	 eax
  00b32	68 00 00 00 00	 push	 OFFSET FLAT:_volume_options
  00b37	e8 00 00 00 00	 call	 _cm_util_string_match
  00b3c	8b e8		 mov	 ebp, eax
  00b3e	83 c4 08	 add	 esp, 8

; 1563 : 	if(cmd_type == NO_STRING_MATCH)

  00b41	81 fd ff ff 00
	00		 cmp	 ebp, 65535		; 0000ffffH
  00b47	75 0a		 jne	 SHORT $L71710
  00b49	5f		 pop	 edi
  00b4a	5e		 pop	 esi
  00b4b	5d		 pop	 ebp

; 1564 : 		return(CMD_bad_string);

  00b4c	b8 01 00 00 00	 mov	 eax, 1
  00b51	5b		 pop	 ebx

; 1665 : }

  00b52	c3		 ret	 0
$L71710:

; 1565 : 	cmd_type += DCS_VOLUME_SET;
; 1566 : 	cmd_value = pCmd_t->params[1];

  00b53	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]

; 1567 : 
; 1568 : 	if( cm_cmd_sync(phTTS) == CMD_flushing )

  00b56	56		 push	 esi
  00b57	e8 00 00 00 00	 call	 _cm_cmd_sync
  00b5c	83 c4 04	 add	 esp, 4
  00b5f	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00b62	75 05		 jne	 SHORT $L71711
  00b64	5f		 pop	 edi
  00b65	5e		 pop	 esi
  00b66	5d		 pop	 ebp
  00b67	5b		 pop	 ebx

; 1665 : }

  00b68	c3		 ret	 0
$L71711:

; 1569 : 		return(CMD_flushing);
; 1570 : 
; 1571 : 	switch(cmd_type)
; 1572 : 	{

  00b69	83 fd 09	 cmp	 ebp, 9
  00b6c	0f 87 eb 00 00
	00		 ja	 $L71726
  00b72	ff 24 ad 00 00
	00 00		 jmp	 DWORD PTR $L72068[ebp*4]
$L71716:

; 1573 : 
; 1574 : 		case    DCS_VOLUME_SET  :
; 1575 : 
; 1576 : 			StereoVolumeControl( phTTS,
; 1577 : 						 cmd_value,
; 1578 : 						 VOLUME_SET,
; 1579 : 						 TRUE,
; 1580 : 						 TRUE );

  00b79	6a 01		 push	 1
  00b7b	6a 01		 push	 1
  00b7d	6a 00		 push	 0
  00b7f	57		 push	 edi
  00b80	56		 push	 esi
  00b81	e8 00 00 00 00	 call	 _StereoVolumeControl
  00b86	83 c4 14	 add	 esp, 20			; 00000014H

; 1663 : 	};
; 1664 : 	return(CMD_success);

  00b89	33 c0		 xor	 eax, eax
  00b8b	5f		 pop	 edi
  00b8c	5e		 pop	 esi
  00b8d	5d		 pop	 ebp
  00b8e	5b		 pop	 ebx

; 1665 : }

  00b8f	c3		 ret	 0
$L71717:

; 1581 : 			break;
; 1582 : 
; 1583 : 		case    DCS_VOLUME_UP   :
; 1584 : 
; 1585 : 			StereoVolumeControl( phTTS,
; 1586 : 						 cmd_value,
; 1587 : 						 VOLUME_UP,
; 1588 : 						 TRUE,
; 1589 : 						 TRUE );

  00b90	6a 01		 push	 1
  00b92	6a 01		 push	 1
  00b94	6a 01		 push	 1
  00b96	57		 push	 edi
  00b97	56		 push	 esi
  00b98	e8 00 00 00 00	 call	 _StereoVolumeControl
  00b9d	83 c4 14	 add	 esp, 20			; 00000014H

; 1663 : 	};
; 1664 : 	return(CMD_success);

  00ba0	33 c0		 xor	 eax, eax
  00ba2	5f		 pop	 edi
  00ba3	5e		 pop	 esi
  00ba4	5d		 pop	 ebp
  00ba5	5b		 pop	 ebx

; 1665 : }

  00ba6	c3		 ret	 0
$L71718:

; 1590 : 			break;
; 1591 : 
; 1592 : 		case    DCS_VOLUME_DOWN :
; 1593 : 
; 1594 : 			StereoVolumeControl( phTTS,
; 1595 : 						 cmd_value,
; 1596 : 						 VOLUME_DOWN,
; 1597 : 						 TRUE,
; 1598 : 						 TRUE );

  00ba7	6a 01		 push	 1
  00ba9	6a 01		 push	 1
  00bab	6a 02		 push	 2
  00bad	57		 push	 edi
  00bae	56		 push	 esi
  00baf	e8 00 00 00 00	 call	 _StereoVolumeControl
  00bb4	83 c4 14	 add	 esp, 20			; 00000014H

; 1663 : 	};
; 1664 : 	return(CMD_success);

  00bb7	33 c0		 xor	 eax, eax
  00bb9	5f		 pop	 edi
  00bba	5e		 pop	 esi
  00bbb	5d		 pop	 ebp
  00bbc	5b		 pop	 ebx

; 1665 : }

  00bbd	c3		 ret	 0
$L71719:

; 1599 : 			break;
; 1600 : 
; 1601 : 		case    DCS_VOLUME_LSET  :
; 1602 : 
; 1603 : 			StereoVolumeControl( phTTS,
; 1604 : 						 cmd_value,
; 1605 : 						 VOLUME_SET,
; 1606 : 						 TRUE,
; 1607 : 						 FALSE );

  00bbe	6a 00		 push	 0
  00bc0	6a 01		 push	 1
  00bc2	6a 00		 push	 0
  00bc4	57		 push	 edi
  00bc5	56		 push	 esi
  00bc6	e8 00 00 00 00	 call	 _StereoVolumeControl
  00bcb	83 c4 14	 add	 esp, 20			; 00000014H

; 1663 : 	};
; 1664 : 	return(CMD_success);

  00bce	33 c0		 xor	 eax, eax
  00bd0	5f		 pop	 edi
  00bd1	5e		 pop	 esi
  00bd2	5d		 pop	 ebp
  00bd3	5b		 pop	 ebx

; 1665 : }

  00bd4	c3		 ret	 0
$L71720:

; 1608 : 			break;
; 1609 : 
; 1610 : 		case    DCS_VOLUME_LUP   :
; 1611 : 
; 1612 : 			StereoVolumeControl( phTTS,
; 1613 : 						 cmd_value,
; 1614 : 						 VOLUME_UP,
; 1615 : 						 TRUE,
; 1616 : 						 FALSE );

  00bd5	6a 00		 push	 0
  00bd7	6a 01		 push	 1
  00bd9	6a 01		 push	 1
  00bdb	57		 push	 edi
  00bdc	56		 push	 esi
  00bdd	e8 00 00 00 00	 call	 _StereoVolumeControl
  00be2	83 c4 14	 add	 esp, 20			; 00000014H

; 1663 : 	};
; 1664 : 	return(CMD_success);

  00be5	33 c0		 xor	 eax, eax
  00be7	5f		 pop	 edi
  00be8	5e		 pop	 esi
  00be9	5d		 pop	 ebp
  00bea	5b		 pop	 ebx

; 1665 : }

  00beb	c3		 ret	 0
$L71721:

; 1617 : 			break;
; 1618 : 
; 1619 : 		case    DCS_VOLUME_LDOWN :
; 1620 : 
; 1621 : 			StereoVolumeControl( phTTS,
; 1622 : 						 cmd_value,
; 1623 : 						 VOLUME_DOWN,
; 1624 : 						 TRUE,
; 1625 : 						 FALSE );

  00bec	6a 00		 push	 0
  00bee	6a 01		 push	 1
  00bf0	6a 02		 push	 2
  00bf2	57		 push	 edi
  00bf3	56		 push	 esi
  00bf4	e8 00 00 00 00	 call	 _StereoVolumeControl
  00bf9	83 c4 14	 add	 esp, 20			; 00000014H

; 1663 : 	};
; 1664 : 	return(CMD_success);

  00bfc	33 c0		 xor	 eax, eax
  00bfe	5f		 pop	 edi
  00bff	5e		 pop	 esi
  00c00	5d		 pop	 ebp
  00c01	5b		 pop	 ebx

; 1665 : }

  00c02	c3		 ret	 0
$L71722:

; 1626 : 			break;
; 1627 : 
; 1628 : 		case    DCS_VOLUME_RSET  :
; 1629 : 
; 1630 : 			StereoVolumeControl( phTTS,
; 1631 : 						 cmd_value,
; 1632 : 						 VOLUME_SET,
; 1633 : 						 FALSE,
; 1634 : 						 TRUE );

  00c03	6a 01		 push	 1
  00c05	6a 00		 push	 0
  00c07	6a 00		 push	 0
  00c09	57		 push	 edi
  00c0a	56		 push	 esi
  00c0b	e8 00 00 00 00	 call	 _StereoVolumeControl
  00c10	83 c4 14	 add	 esp, 20			; 00000014H

; 1663 : 	};
; 1664 : 	return(CMD_success);

  00c13	33 c0		 xor	 eax, eax
  00c15	5f		 pop	 edi
  00c16	5e		 pop	 esi
  00c17	5d		 pop	 ebp
  00c18	5b		 pop	 ebx

; 1665 : }

  00c19	c3		 ret	 0
$L71723:

; 1635 : 			break;
; 1636 : 
; 1637 : 		case    DCS_VOLUME_RUP   :
; 1638 : 
; 1639 : 			StereoVolumeControl( phTTS,
; 1640 : 						 cmd_value,
; 1641 : 						 VOLUME_UP,
; 1642 : 						 FALSE,
; 1643 : 						 TRUE );

  00c1a	6a 01		 push	 1
  00c1c	6a 00		 push	 0
  00c1e	6a 01		 push	 1
  00c20	57		 push	 edi
  00c21	56		 push	 esi
  00c22	e8 00 00 00 00	 call	 _StereoVolumeControl
  00c27	83 c4 14	 add	 esp, 20			; 00000014H

; 1663 : 	};
; 1664 : 	return(CMD_success);

  00c2a	33 c0		 xor	 eax, eax
  00c2c	5f		 pop	 edi
  00c2d	5e		 pop	 esi
  00c2e	5d		 pop	 ebp
  00c2f	5b		 pop	 ebx

; 1665 : }

  00c30	c3		 ret	 0
$L71724:

; 1644 : 			break;
; 1645 : 
; 1646 : 		case    DCS_VOLUME_RDOWN :
; 1647 : 
; 1648 : 			StereoVolumeControl( phTTS,
; 1649 : 						 cmd_value,
; 1650 : 						 VOLUME_DOWN,
; 1651 : 						 FALSE,
; 1652 : 						 TRUE );

  00c31	6a 01		 push	 1
  00c33	6a 00		 push	 0
  00c35	6a 02		 push	 2
  00c37	57		 push	 edi
  00c38	56		 push	 esi
  00c39	e8 00 00 00 00	 call	 _StereoVolumeControl
  00c3e	83 c4 14	 add	 esp, 20			; 00000014H

; 1663 : 	};
; 1664 : 	return(CMD_success);

  00c41	33 c0		 xor	 eax, eax
  00c43	5f		 pop	 edi
  00c44	5e		 pop	 esi
  00c45	5d		 pop	 ebp
  00c46	5b		 pop	 ebx

; 1665 : }

  00c47	c3		 ret	 0
$L71725:

; 1653 : 			break;
; 1654 : 
; 1655 : 		case    DCS_VOLUME_SSET :
; 1656 : 
; 1657 : 			SetStereoVolume( phTTS, cmd_value, pCmd_t->params[2] );

  00c48	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00c4b	51		 push	 ecx
  00c4c	57		 push	 edi
  00c4d	56		 push	 esi
  00c4e	e8 00 00 00 00	 call	 _SetStereoVolume
  00c53	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1663 : 	};
; 1664 : 	return(CMD_success);

  00c56	33 c0		 xor	 eax, eax
  00c58	5f		 pop	 edi
  00c59	5e		 pop	 esi
  00c5a	5d		 pop	 ebp
  00c5b	5b		 pop	 ebx

; 1665 : }

  00c5c	c3		 ret	 0
$L71726:
  00c5d	5f		 pop	 edi
  00c5e	5e		 pop	 esi
  00c5f	5d		 pop	 ebp

; 1658 : 
; 1659 : 			break;
; 1660 : 
; 1661 : 		default :
; 1662 : 			return(CMD_bad_value);

  00c60	b8 02 00 00 00	 mov	 eax, 2
  00c65	5b		 pop	 ebx

; 1665 : }

  00c66	c3		 ret	 0
  00c67	90		 npad	 1
$L72068:
  00c68	00 00 00 00	 DD	 $L71716
  00c6c	00 00 00 00	 DD	 $L71717
  00c70	00 00 00 00	 DD	 $L71718
  00c74	00 00 00 00	 DD	 $L71719
  00c78	00 00 00 00	 DD	 $L71720
  00c7c	00 00 00 00	 DD	 $L71721
  00c80	00 00 00 00	 DD	 $L71722
  00c84	00 00 00 00	 DD	 $L71723
  00c88	00 00 00 00	 DD	 $L71724
  00c8c	00 00 00 00	 DD	 $L71725
_cm_cmd_volume ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_language
EXTRN	_default_lang:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pipe_value$ = 8
_cm_cmd_language PROC NEAR

; 1745 : {   

  00c90	53		 push	 ebx

; 1746 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00c91	8b 5c 24 08	 mov	 ebx, DWORD PTR _phTTS$[esp]
  00c95	56		 push	 esi
  00c96	57		 push	 edi

; 1747 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00c97	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00c9a	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]

; 1748 : 	
; 1749 : 	int     cmd_type;
; 1750 : 	DT_PIPE_T pipe_value;
; 1751 : 
; 1752 : 	if(pCmd_t->esc_command == FALSE)

  00c9d	8b 88 0c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1292]
  00ca3	85 c9		 test	 ecx, ecx
  00ca5	75 27		 jne	 SHORT $L71734

; 1753 : 	{
; 1754 : 		cmd_type = cm_util_string_match(lang_options,pCmd_t->pString[0]);

  00ca7	8b 80 80 02 00
	00		 mov	 eax, DWORD PTR [eax+640]
  00cad	50		 push	 eax
  00cae	68 00 00 00 00	 push	 OFFSET FLAT:_lang_options
  00cb3	e8 00 00 00 00	 call	 _cm_util_string_match
  00cb8	8b f8		 mov	 edi, eax
  00cba	83 c4 08	 add	 esp, 8

; 1755 : 		if(cmd_type == NO_STRING_MATCH)

  00cbd	81 ff ff ff 00
	00		 cmp	 edi, 65535		; 0000ffffH
  00cc3	75 0b		 jne	 SHORT $L71736
  00cc5	5f		 pop	 edi
  00cc6	5e		 pop	 esi

; 1756 : 			return(CMD_bad_string);

  00cc7	b8 01 00 00 00	 mov	 eax, 1
  00ccc	5b		 pop	 ebx

; 1837 : }

  00ccd	c3		 ret	 0
$L71734:

; 1757 : 	}
; 1758 : 	else
; 1759 : 		cmd_type = pCmd_t->params[0];

  00cce	8b 38		 mov	 edi, DWORD PTR [eax]
$L71736:

; 1760 : 				  
; 1761 : 	if(cm_cmd_sync(phTTS) == CMD_flushing)

  00cd0	53		 push	 ebx
  00cd1	e8 00 00 00 00	 call	 _cm_cmd_sync
  00cd6	83 c4 04	 add	 esp, 4
  00cd9	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00cdc	75 04		 jne	 SHORT $L71737
  00cde	5f		 pop	 edi
  00cdf	5e		 pop	 esi
  00ce0	5b		 pop	 ebx

; 1837 : }

  00ce1	c3		 ret	 0
$L71737:

; 1762 : 		return(CMD_flushing);
; 1763 : 	switch(cmd_type)
; 1764 : 	{

  00ce2	83 ff 0b	 cmp	 edi, 11			; 0000000bH
  00ce5	0f 87 aa 00 00
	00		 ja	 $L71743
  00ceb	ff 24 bd 00 00
	00 00		 jmp	 DWORD PTR $L72070[edi*4]
$L71742:

; 1765 : 
; 1766 : 		/* GL 03/27/1997 for BATS#317 add "us" option */
; 1767 : 		/* GL 012/02/1998 for BATS#751 add more language option */
; 1768 : 		case    0       :                               /* english */
; 1769 : 		case    6       :                               /* us */
; 1770 : 
; 1771 : 			if(pKsd_t->lang_ready[LANG_english] == LANG_both_ready)

  00cf2	83 be fc 00 00
	00 07		 cmp	 DWORD PTR [esi+252], 7
  00cf9	0f 85 96 00 00
	00		 jne	 $L71743

; 1772 : 				cmd_type = LANG_english;

  00cff	33 ff		 xor	 edi, edi

; 1773 : 			else
; 1774 : 				return(CMD_bad_value);
; 1775 : 			break;

  00d01	eb 52		 jmp	 SHORT $L71759
$L71745:

; 1776 : 
; 1777 : 		case    1       :                               /* british */
; 1778 : 		case    7       :                               /* uk */
; 1779 : 
; 1780 : 			if(pKsd_t->lang_ready[LANG_british] == LANG_both_ready)

  00d03	83 be 10 01 00
	00 07		 cmp	 DWORD PTR [esi+272], 7
  00d0a	0f 85 85 00 00
	00		 jne	 $L71743

; 1781 : 				cmd_type = LANG_british;

  00d10	bf 05 00 00 00	 mov	 edi, 5

; 1782 : 			else
; 1783 : 				return(CMD_bad_value);
; 1784 : 			break;

  00d15	eb 3e		 jmp	 SHORT $L71759
$L71748:

; 1785 : 
; 1786 : 		case    2       :                               /* french */
; 1787 : 		case    8       :                               /* fr */
; 1788 : 
; 1789 : 			if(pKsd_t->lang_ready[LANG_french] == LANG_both_ready)

  00d17	83 be 00 01 00
	00 07		 cmp	 DWORD PTR [esi+256], 7
  00d1e	75 75		 jne	 SHORT $L71743

; 1790 : 				cmd_type = LANG_french;

  00d20	bf 01 00 00 00	 mov	 edi, 1

; 1791 : 			else
; 1792 : 				return(CMD_bad_value);
; 1793 : 			break;

  00d25	eb 2e		 jmp	 SHORT $L71759
$L71751:

; 1794 : 
; 1795 : 
; 1796 : 		case    3       :                               /* german */
; 1797 : 		case    9       :                               /* gr */
; 1798 : 
; 1799 : 			if(pKsd_t->lang_ready[LANG_german] == LANG_both_ready)

  00d27	83 be 04 01 00
	00 07		 cmp	 DWORD PTR [esi+260], 7
  00d2e	75 65		 jne	 SHORT $L71743

; 1800 : 				cmd_type = LANG_german;

  00d30	bf 02 00 00 00	 mov	 edi, 2

; 1801 : 			else
; 1802 : 				return(CMD_bad_value);
; 1803 : 			break;

  00d35	eb 1e		 jmp	 SHORT $L71759
$L71754:

; 1804 : 
; 1805 : 		case    4       :                               /* spanish */
; 1806 : 		case    10       :                               /* sp */
; 1807 : 
; 1808 : 			if(pKsd_t->lang_ready[LANG_spanish] == LANG_both_ready)

  00d37	83 be 08 01 00
	00 07		 cmp	 DWORD PTR [esi+264], 7
  00d3e	75 55		 jne	 SHORT $L71743

; 1809 : 				cmd_type = LANG_spanish;

  00d40	bf 03 00 00 00	 mov	 edi, 3

; 1810 : 			else
; 1811 : 				return(CMD_bad_value);
; 1812 : 			break;

  00d45	eb 0e		 jmp	 SHORT $L71759
$L71757:

; 1813 : 
; 1814 : 		case    5       :                               /* latin american */
; 1815 : 		case    11       :                               /* la */
; 1816 : 
; 1817 : 			if(pKsd_t->lang_ready[LANG_latin_american] == LANG_both_ready)

  00d47	83 be 14 01 00
	00 07		 cmp	 DWORD PTR [esi+276], 7
  00d4e	75 45		 jne	 SHORT $L71743

; 1818 : 				cmd_type = LANG_latin_american;

  00d50	bf 06 00 00 00	 mov	 edi, 6
$L71759:

; 1825 : 	};
; 1826 : 
; 1827 : 	if(cm_cmd_sync(phTTS) == CMD_flushing)

  00d55	53		 push	 ebx
  00d56	e8 00 00 00 00	 call	 _cm_cmd_sync
  00d5b	83 c4 04	 add	 esp, 4
  00d5e	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00d61	75 04		 jne	 SHORT $L71761
  00d63	5f		 pop	 edi
  00d64	5e		 pop	 esi
  00d65	5b		 pop	 ebx

; 1837 : }

  00d66	c3		 ret	 0
$L71761:

; 1828 : 		return(CMD_flushing);
; 1829 : #ifdef MSDOS    
; 1830 : 	default_lang(cmd_type,0);
; 1831 : #else
; 1832 : 	default_lang(pKsd_t,cmd_type,0);

  00d67	6a 00		 push	 0
  00d69	57		 push	 edi
  00d6a	56		 push	 esi
  00d6b	e8 00 00 00 00	 call	 _default_lang

; 1833 : #endif
; 1834 : 	pipe_value = LAST_VOICE;

  00d70	c7 44 24 1c 03
	1f 00 00	 mov	 DWORD PTR _pipe_value$[esp+20], 7939 ; 00001f03H

; 1835 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,&pipe_value,1);

  00d78	8b 96 d0 00 00
	00		 mov	 edx, DWORD PTR [esi+208]
  00d7e	8d 4c 24 1c	 lea	 ecx, DWORD PTR _pipe_value$[esp+20]
  00d82	6a 01		 push	 1
  00d84	51		 push	 ecx
  00d85	52		 push	 edx
  00d86	56		 push	 esi
  00d87	e8 00 00 00 00	 call	 _cm_util_write_pipe
  00d8c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1836 : 	return(CMD_success);

  00d8f	33 c0		 xor	 eax, eax
  00d91	5f		 pop	 edi
  00d92	5e		 pop	 esi
  00d93	5b		 pop	 ebx

; 1837 : }

  00d94	c3		 ret	 0
$L71743:
  00d95	5f		 pop	 edi
  00d96	5e		 pop	 esi

; 1819 : 			else
; 1820 : 				return(CMD_bad_value);
; 1821 : 			break;
; 1822 : 
; 1823 : 		default :
; 1824 : 			return(CMD_bad_value);

  00d97	b8 02 00 00 00	 mov	 eax, 2
  00d9c	5b		 pop	 ebx

; 1837 : }

  00d9d	c3		 ret	 0
  00d9e	8b ff		 npad	 2
$L72070:
  00da0	00 00 00 00	 DD	 $L71742
  00da4	00 00 00 00	 DD	 $L71745
  00da8	00 00 00 00	 DD	 $L71748
  00dac	00 00 00 00	 DD	 $L71751
  00db0	00 00 00 00	 DD	 $L71754
  00db4	00 00 00 00	 DD	 $L71757
  00db8	00 00 00 00	 DD	 $L71742
  00dbc	00 00 00 00	 DD	 $L71745
  00dc0	00 00 00 00	 DD	 $L71748
  00dc4	00 00 00 00	 DD	 $L71751
  00dc8	00 00 00 00	 DD	 $L71754
  00dcc	00 00 00 00	 DD	 $L71757
_cm_cmd_language ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_remove
_TEXT	SEGMENT
_pKsd_t$ = 8
_pipe_value$ = 8
_cm_cmd_remove PROC NEAR

; 1852 : {

  00dd0	56		 push	 esi

; 1853 : 	DT_PIPE_T pipe_value;
; 1854 : 
; 1855 : #ifdef MSDOS
; 1856 : 	pKsd_t->lang_ready[pKsd_t->lang_curr] = 0;
; 1857 : #else
; 1858 : 	pKsd_t->lang_ready[LANG_english] = 0;

  00dd1	8b 74 24 08	 mov	 esi, DWORD PTR _pKsd_t$[esp]

; 1859 : #endif
; 1860 : 	pipe_value = KILL_TASK;
; 1861 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,&pipe_value,1);

  00dd5	8d 44 24 08	 lea	 eax, DWORD PTR _pipe_value$[esp]
  00dd9	6a 01		 push	 1
  00ddb	8b 8e d0 00 00
	00		 mov	 ecx, DWORD PTR [esi+208]
  00de1	50		 push	 eax
  00de2	51		 push	 ecx
  00de3	56		 push	 esi
  00de4	c7 86 fc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+252], 0
  00dee	c7 44 24 18 0c
	1f 00 00	 mov	 DWORD PTR _pipe_value$[esp+16], 7948 ; 00001f0cH
  00df6	e8 00 00 00 00	 call	 _cm_util_write_pipe
  00dfb	83 c4 10	 add	 esp, 16			; 00000010H

; 1862 : 	pKsd_t->lts_pipe = NULL_PIPE;

  00dfe	c7 86 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+208], 0

; 1863 : 	pKsd_t->ph_pipe = NULL_PIPE;

  00e08	c7 86 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+212], 0

; 1864 : 	return(CMD_success);

  00e12	33 c0		 xor	 eax, eax
  00e14	5e		 pop	 esi

; 1865 : }

  00e15	c3		 ret	 0
_cm_cmd_remove ENDP
_phTTS$ = 8
_pipe_value$ = -8
_cm_cmd_mode PROC NEAR

; 2170 : {

  00e20	83 ec 08	 sub	 esp, 8

; 2171 : 	unsigned int    i, value;
; 2172 : 	DT_PIPE_T pipe_value[3];
; 2173 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00e23	8b 44 24 0c	 mov	 eax, DWORD PTR _phTTS$[esp+4]
  00e27	53		 push	 ebx
  00e28	55		 push	 ebp

; 2174 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 2175 : 
; 2176 : 	pipe_value[0] = (2<<PSNEXTRA)+LTS_SYNC;
; 2177 : 	pipe_value[1] = 0;

  00e29	33 ed		 xor	 ebp, ebp
  00e2b	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]
  00e2e	56		 push	 esi
  00e2f	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00e32	66 c7 44 24 0c
	04 5f		 mov	 WORD PTR _pipe_value$[esp+20], 24324 ; 00005f04H
  00e39	66 89 6c 24 0e	 mov	 WORD PTR _pipe_value$[esp+22], bp

; 2178 : 	pipe_value[2] = 0;

  00e3e	66 89 6c 24 10	 mov	 WORD PTR _pipe_value$[esp+24], bp

; 2179 : 	for(i=0; i < pCmd_t->param_index; i++)

  00e43	8b 83 d0 02 00
	00		 mov	 eax, DWORD PTR [ebx+720]
  00e49	57		 push	 edi
  00e4a	33 ff		 xor	 edi, edi
  00e4c	3b c5		 cmp	 eax, ebp
  00e4e	0f 86 ed 00 00
	00		 jbe	 $L71778
$L71776:

; 2180 : 	{
; 2181 : 		value = cm_util_string_match(mode_options,(unsigned char *)pCmd_t->pString[i]);

  00e54	8b 84 bb 80 02
	00 00		 mov	 eax, DWORD PTR [ebx+edi*4+640]
  00e5b	50		 push	 eax
  00e5c	68 00 00 00 00	 push	 OFFSET FLAT:_mode_options
  00e61	e8 00 00 00 00	 call	 _cm_util_string_match
  00e66	83 c4 08	 add	 esp, 8

; 2182 : 		if(value == NO_STRING_MATCH)

  00e69	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00e6e	0f 84 d7 00 00
	00		 je	 $L72074

; 2185 : 		}       
; 2186 : 		/*
; 2187 : 		 * 3/6/96 SIK This command only takes 2 parameters:  MATH, EUROPE, SPELL, NAME, 
; 2188 : 		 * HOMOGRAPH, CITATION or LATIN followed by ON, OFF or SET 
; 2189 : 		 */
; 2190 : 		switch(i)
; 2191 : 		{         

  00e74	8b cf		 mov	 ecx, edi
  00e76	2b cd		 sub	 ecx, ebp
  00e78	74 6f		 je	 SHORT $L71785
  00e7a	49		 dec	 ecx
  00e7b	0f 85 d7 00 00
	00		 jne	 $L71808

; 2221 : 						break;
; 2222 : 					default:
; 2223 : 						return(CMD_bad_param);
; 2224 : 				}
; 2225 : 				break;
; 2226 : 			case 1:    /* Second param */
; 2227 : 				switch(value)
; 2228 : 				{               

  00e81	83 e8 09	 sub	 eax, 9
  00e84	74 38		 je	 SHORT $L71805
  00e86	48		 dec	 eax
  00e87	74 1e		 je	 SHORT $L71806
  00e89	48		 dec	 eax
  00e8a	0f 85 c8 00 00
	00		 jne	 $L71808

; 2237 : 					case 11:                         /* set */
; 2238 : 						pipe_value[1] = LTS_MODE_ABS;

  00e90	66 c7 44 24 12
	02 00		 mov	 WORD PTR _pipe_value$[esp+26], 2

; 2239 :                         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,3);

  00e97	8b 96 d0 00 00
	00		 mov	 edx, DWORD PTR [esi+208]
  00e9d	8d 4c 24 10	 lea	 ecx, DWORD PTR _pipe_value$[esp+24]
  00ea1	6a 03		 push	 3
  00ea3	51		 push	 ecx
  00ea4	52		 push	 edx

; 2240 : 						break;

  00ea5	eb 2a		 jmp	 SHORT $L72079
$L71806:

; 2232 : 						break;
; 2233 : 					case 10:                         /* off */
; 2234 : 						pipe_value[1] = LTS_MODE_CLEAR;

  00ea7	66 c7 44 24 12
	01 00		 mov	 WORD PTR _pipe_value$[esp+26], 1

; 2235 :                         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,3);

  00eae	8b 8e d0 00 00
	00		 mov	 ecx, DWORD PTR [esi+208]
  00eb4	8d 44 24 10	 lea	 eax, DWORD PTR _pipe_value$[esp+24]
  00eb8	6a 03		 push	 3
  00eba	50		 push	 eax
  00ebb	51		 push	 ecx

; 2236 : 						break;

  00ebc	eb 13		 jmp	 SHORT $L72079
$L71805:

; 2229 : 					case 9:                         /* on */
; 2230 : 						pipe_value[1] = LTS_MODE_SET;

  00ebe	66 89 6c 24 12	 mov	 WORD PTR _pipe_value$[esp+26], bp

; 2231 :                         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,3);

  00ec3	8b 86 d0 00 00
	00		 mov	 eax, DWORD PTR [esi+208]
  00ec9	8d 54 24 10	 lea	 edx, DWORD PTR _pipe_value$[esp+24]
  00ecd	6a 03		 push	 3
  00ecf	52		 push	 edx
  00ed0	50		 push	 eax
$L72079:
  00ed1	56		 push	 esi
  00ed2	e8 00 00 00 00	 call	 _cm_util_write_pipe

; 2241 : 					default:
; 2242 : 						return(CMD_bad_param);    
; 2243 : 				}
; 2244 : 				/* 
; 2245 : 				   GL 01/28/1997, force SYNC here to fix the race condition in
; 2246 : 				   DECtalk software
; 2247 : 				*/
; 2248 : 				cm_cmd_sync(phTTS);

  00ed7	8b 4c 24 2c	 mov	 ecx, DWORD PTR _phTTS$[esp+36]
  00edb	83 c4 10	 add	 esp, 16			; 00000010H
  00ede	51		 push	 ecx
  00edf	e8 00 00 00 00	 call	 _cm_cmd_sync
  00ee4	83 c4 04	 add	 esp, 4

; 2249 : 				break;

  00ee7	eb 49		 jmp	 SHORT $L71777
$L71785:

; 2192 : 			case 0:    /* First param */
; 2193 : 				switch(value)
; 2194 : 				{                               

  00ee9	83 f8 08	 cmp	 eax, 8
  00eec	77 6a		 ja	 SHORT $L71808
  00eee	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72080[eax*4]
$L71790:

; 2195 : 					case 0: /* minus */
; 2196 : 						pipe_value[2] |= MODE_MATH;  

  00ef5	80 4c 24 14 04	 or	 BYTE PTR _pipe_value$[esp+28], 4

; 2197 : 						break;

  00efa	eb 36		 jmp	 SHORT $L71777
$L71791:

; 2198 : 					case 1: /* europe */
; 2199 : 						pipe_value[2] |= MODE_EUROPE; 

  00efc	80 4c 24 14 08	 or	 BYTE PTR _pipe_value$[esp+28], 8

; 2200 : 						break;

  00f01	eb 2f		 jmp	 SHORT $L71777
$L71792:

; 2201 : 					case 2: /* spell */
; 2202 : 						pipe_value[2] |= MODE_SPELL;       

  00f03	80 4c 24 14 10	 or	 BYTE PTR _pipe_value$[esp+28], 16 ; 00000010H

; 2203 : 						break;

  00f08	eb 28		 jmp	 SHORT $L71777
$L71793:

; 2204 : 					case 3: /* name determination */
; 2205 : 						pipe_value[2] |= MODE_NAME;       

  00f0a	80 4c 24 14 40	 or	 BYTE PTR _pipe_value$[esp+28], 64 ; 00000040H

; 2206 : 						break;

  00f0f	eb 21		 jmp	 SHORT $L71777
$L71794:

; 2207 : 					case 4: /* homograph determination */
; 2208 : 						pipe_value[2] |= MODE_HOMOGRAPH;

  00f11	80 4c 24 14 80	 or	 BYTE PTR _pipe_value$[esp+28], -128 ; ffffff80H

; 2209 : 						break;

  00f16	eb 1a		 jmp	 SHORT $L71777
$L71795:

; 2210 : 					case 5: /* citation mode */
; 2211 : 						pipe_value[2] |= MODE_CITATION;

  00f18	80 4c 24 15 01	 or	 BYTE PTR _pipe_value$[esp+29], 1

; 2212 : 						break;

  00f1d	eb 13		 jmp	 SHORT $L71777
$L71796:

; 2213 : 					case 6: /* latin mode */
; 2214 : 						pipe_value[2] |= MODE_LATIN;

  00f1f	80 4c 24 15 02	 or	 BYTE PTR _pipe_value$[esp+29], 2

; 2215 :                         break;

  00f24	eb 0c		 jmp	 SHORT $L71777
$L71797:

; 2216 : 					case 7: /* table reading mode */
; 2217 : 						pipe_value[2] |= MODE_TABLE;

  00f26	80 4c 24 15 04	 or	 BYTE PTR _pipe_value$[esp+29], 4

; 2218 : 						break;

  00f2b	eb 05		 jmp	 SHORT $L71777
$L71798:

; 2219 : 					case 8: /* email reading mode */
; 2220 : 						pipe_value[2] |= MODE_EMAIL;

  00f2d	80 4c 24 15 10	 or	 BYTE PTR _pipe_value$[esp+29], 16 ; 00000010H
$L71777:

; 2179 : 	for(i=0; i < pCmd_t->param_index; i++)

  00f32	8b 83 d0 02 00
	00		 mov	 eax, DWORD PTR [ebx+720]
  00f38	47		 inc	 edi
  00f39	3b f8		 cmp	 edi, eax
  00f3b	0f 82 13 ff ff
	ff		 jb	 $L71776
$L71778:
  00f41	5f		 pop	 edi
  00f42	5e		 pop	 esi
  00f43	5d		 pop	 ebp

; 2252 : 			}  /* Matches switch(i) */
; 2253 : 		}       /* Matches for(i=0; i < pCmd_t->param_index; i++) */
; 2254 : 	return(CMD_success);

  00f44	33 c0		 xor	 eax, eax
  00f46	5b		 pop	 ebx

; 2255 : }

  00f47	83 c4 08	 add	 esp, 8
  00f4a	c3		 ret	 0
$L72074:
  00f4b	5f		 pop	 edi
  00f4c	5e		 pop	 esi
  00f4d	5d		 pop	 ebp

; 2183 : 		{
; 2184 : 			return(CMD_bad_string);

  00f4e	b8 01 00 00 00	 mov	 eax, 1
  00f53	5b		 pop	 ebx

; 2255 : }

  00f54	83 c4 08	 add	 esp, 8
  00f57	c3		 ret	 0
$L71808:
  00f58	5f		 pop	 edi
  00f59	5e		 pop	 esi
  00f5a	5d		 pop	 ebp

; 2250 : 			default:
; 2251 : 				return(CMD_bad_param);

  00f5b	b8 04 00 00 00	 mov	 eax, 4
  00f60	5b		 pop	 ebx

; 2255 : }

  00f61	83 c4 08	 add	 esp, 8
  00f64	c3		 ret	 0
  00f65	8d 49 00	 npad	 3
$L72080:
  00f68	00 00 00 00	 DD	 $L71790
  00f6c	00 00 00 00	 DD	 $L71791
  00f70	00 00 00 00	 DD	 $L71792
  00f74	00 00 00 00	 DD	 $L71793
  00f78	00 00 00 00	 DD	 $L71794
  00f7c	00 00 00 00	 DD	 $L71795
  00f80	00 00 00 00	 DD	 $L71796
  00f84	00 00 00 00	 DD	 $L71797
  00f88	00 00 00 00	 DD	 $L71798
_cm_cmd_mode ENDP
_phTTS$ = 8
_pipe_value$ = 8
_cm_cmd_pronounce PROC NEAR

; 2273 : 	unsigned int i, value;
; 2274 : 	DT_PIPE_T pipe_value[2];
; 2275 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00f90	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  00f94	53		 push	 ebx
  00f95	55		 push	 ebp
  00f96	56		 push	 esi

; 2276 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  00f97	8b 68 0c	 mov	 ebp, DWORD PTR [eax+12]
  00f9a	57		 push	 edi
  00f9b	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 2277 : 
; 2278 : 	pipe_value[0] = (1<<PSNEXTRA)+LTS_SYNC;

  00f9e	66 c7 44 24 14
	04 3f		 mov	 WORD PTR _pipe_value$[esp+12], 16132 ; 00003f04H

; 2279 : 	for(i=0;i<pCmd_t->param_index;i++)

  00fa5	8b 85 d0 02 00
	00		 mov	 eax, DWORD PTR [ebp+720]
  00fab	33 f6		 xor	 esi, esi
  00fad	85 c0		 test	 eax, eax
  00faf	76 66		 jbe	 SHORT $L71820

; 2273 : 	unsigned int i, value;
; 2274 : 	DT_PIPE_T pipe_value[2];
; 2275 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  00fb1	8d 9d 80 02 00
	00		 lea	 ebx, DWORD PTR [ebp+640]
$L71818:

; 2280 : 	{
; 2281 : 		value = cm_util_string_match(pronounce_options, (unsigned char *)pCmd_t->pString[i]);

  00fb7	8b 03		 mov	 eax, DWORD PTR [ebx]
  00fb9	50		 push	 eax
  00fba	68 00 00 00 00	 push	 OFFSET FLAT:_pronounce_options
  00fbf	e8 00 00 00 00	 call	 _cm_util_string_match
  00fc4	83 c4 08	 add	 esp, 8

; 2282 : 		if(value == NO_STRING_MATCH)

  00fc7	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00fcc	74 50		 je	 SHORT $L72083

; 2284 : 		switch(value)
; 2285 : 		{

  00fce	83 e8 00	 sub	 eax, 0
  00fd1	74 18		 je	 SHORT $L71827
  00fd3	48		 dec	 eax
  00fd4	74 0c		 je	 SHORT $L71828
  00fd6	48		 dec	 eax
  00fd7	75 19		 jne	 SHORT $L71824

; 2295 : 
; 2296 : 			case    2       :                               /* primary */
; 2297 : 
; 2298 : 				pipe_value[1] = LTS_DIC_PRIMARY;

  00fd9	66 c7 44 24 16
	05 00		 mov	 WORD PTR _pipe_value$[esp+14], 5

; 2299 : 				break;

  00fe0	eb 10		 jmp	 SHORT $L71824
$L71828:

; 2289 : 				break;
; 2290 : 
; 2291 : 			case    1       :                               /* acna name */
; 2292 : 
; 2293 : 				pipe_value[1] = LTS_ACNA_NAME;

  00fe2	66 c7 44 24 16
	04 00		 mov	 WORD PTR _pipe_value$[esp+14], 4

; 2294 : 				break;

  00fe9	eb 07		 jmp	 SHORT $L71824
$L71827:

; 2286 : 			case    0       :                               /* alternate */
; 2287 : 
; 2288 : 				pipe_value[1] = LTS_DIC_ALTERNATE;

  00feb	66 c7 44 24 16
	03 00		 mov	 WORD PTR _pipe_value$[esp+14], 3
$L71824:

; 2300 : 		}
; 2301 :                 cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,2);

  00ff2	8b 97 d0 00 00
	00		 mov	 edx, DWORD PTR [edi+208]
  00ff8	8d 4c 24 14	 lea	 ecx, DWORD PTR _pipe_value$[esp+12]
  00ffc	6a 02		 push	 2
  00ffe	51		 push	 ecx
  00fff	52		 push	 edx
  01000	57		 push	 edi
  01001	e8 00 00 00 00	 call	 _cm_util_write_pipe
  01006	8b 85 d0 02 00
	00		 mov	 eax, DWORD PTR [ebp+720]
  0100c	83 c4 10	 add	 esp, 16			; 00000010H
  0100f	46		 inc	 esi
  01010	83 c3 04	 add	 ebx, 4
  01013	3b f0		 cmp	 esi, eax
  01015	72 a0		 jb	 SHORT $L71818
$L71820:
  01017	5f		 pop	 edi
  01018	5e		 pop	 esi
  01019	5d		 pop	 ebp

; 2302 : 	}
; 2303 : 	return(CMD_success);

  0101a	33 c0		 xor	 eax, eax
  0101c	5b		 pop	 ebx

; 2304 : }

  0101d	c3		 ret	 0
$L72083:
  0101e	5f		 pop	 edi
  0101f	5e		 pop	 esi
  01020	5d		 pop	 ebp

; 2283 : 			return(CMD_bad_string);

  01021	b8 01 00 00 00	 mov	 eax, 1
  01026	5b		 pop	 ebx

; 2304 : }

  01027	c3		 ret	 0
_cm_cmd_pronounce ENDP
_phTTS$ = 8
_pipe_value$ = 8
_cm_cmd_rate PROC NEAR

; 2322 : 	DT_PIPE_T pipe_value[2];
; 2323 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  01030	8b 4c 24 04	 mov	 ecx, DWORD PTR _phTTS$[esp-4]

; 2324 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 2325 : 	
; 2326 : 	pipe_value[0] = (1<<PSNEXTRA) + RATE;

  01034	66 c7 44 24 04
	00 3f		 mov	 WORD PTR _pipe_value$[esp-4], 16128 ; 00003f00H

; 2327 : 	pipe_value[1] = pCmd_t->params[0];
; 2328 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,2);

  0103b	6a 02		 push	 2
  0103d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  01040	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  01043	66 8b 11	 mov	 dx, WORD PTR [ecx]
  01046	8d 4c 24 08	 lea	 ecx, DWORD PTR _pipe_value$[esp]
  0104a	66 89 54 24 0a	 mov	 WORD PTR _pipe_value$[esp+2], dx
  0104f	8b 90 d0 00 00
	00		 mov	 edx, DWORD PTR [eax+208]
  01055	51		 push	 ecx
  01056	52		 push	 edx
  01057	50		 push	 eax
  01058	e8 00 00 00 00	 call	 _cm_util_write_pipe
  0105d	83 c4 10	 add	 esp, 16			; 00000010H

; 2329 : 	return(CMD_success);

  01060	33 c0		 xor	 eax, eax

; 2330 : 
; 2331 : }

  01062	c3		 ret	 0
_cm_cmd_rate ENDP
_phTTS$ = 8
_pipe_value$ = 8
_cm_cmd_name PROC NEAR

; 2348 : 	DT_PIPE_T pipe_value[2];
; 2349 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  01070	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  01074	56		 push	 esi

; 2350 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  01075	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01078	8b 70 08	 mov	 esi, DWORD PTR [eax+8]

; 2351 : 
; 2352 : 	if(CT[pCmd_t->cmd_index].esc_value == DCS_NAME)

  0107b	8b 81 e8 02 00
	00		 mov	 eax, DWORD PTR [ecx+744]
  01081	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  01084	81 3c 85 0c 00
	00 00 c9 00 00
	00		 cmp	 DWORD PTR _command_table[eax*4+12], 201 ; 000000c9H
  0108f	75 16		 jne	 SHORT $L71842

; 2353 : 	{
; 2354 : 		pipe_value[1] = cm_util_string_match(voice_names,pCmd_t->pString[0]);

  01091	8b 81 80 02 00
	00		 mov	 eax, DWORD PTR [ecx+640]
  01097	50		 push	 eax
  01098	68 00 00 00 00	 push	 OFFSET FLAT:_voice_names
  0109d	e8 00 00 00 00	 call	 _cm_util_string_match
  010a2	83 c4 08	 add	 esp, 8

; 2355 : 	}
; 2356 : 	else

  010a5	eb 0d		 jmp	 SHORT $L72087
$L71842:

; 2357 : 	{
; 2358 : 		pipe_value[1] = CT[pCmd_t->cmd_index].esc_value & ESCAPE_CODE;

  010a7	66 8b 04 85 0c
	00 00 00	 mov	 ax, WORD PTR _command_table[eax*4+12]
  010af	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
$L72087:

; 2359 : 	}	
; 2360 : 	if((pipe_value[1] >= 0) && (pipe_value[1] < MAX_VOICES))

  010b4	66 3d 0a 00	 cmp	 ax, 10			; 0000000aH
  010b8	66 89 44 24 0a	 mov	 WORD PTR _pipe_value$[esp+2], ax
  010bd	73 22		 jae	 SHORT $L71844

; 2361 : 	{
; 2362 : 		pipe_value[0] = (1<<PSNEXTRA) + NEW_SPEAKER;

  010bf	66 c7 44 24 08
	05 3f		 mov	 WORD PTR _pipe_value$[esp], 16133 ; 00003f05H

; 2363 :                 cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,2);

  010c6	8b 96 d0 00 00
	00		 mov	 edx, DWORD PTR [esi+208]
  010cc	8d 4c 24 08	 lea	 ecx, DWORD PTR _pipe_value$[esp]
  010d0	6a 02		 push	 2
  010d2	51		 push	 ecx
  010d3	52		 push	 edx
  010d4	56		 push	 esi
  010d5	e8 00 00 00 00	 call	 _cm_util_write_pipe
  010da	83 c4 10	 add	 esp, 16			; 00000010H

; 2364 : 		return(CMD_success);

  010dd	33 c0		 xor	 eax, eax
  010df	5e		 pop	 esi

; 2367 : }

  010e0	c3		 ret	 0
$L71844:

; 2365 : 	}
; 2366 : 	return(CMD_bad_string);

  010e1	b8 01 00 00 00	 mov	 eax, 1
  010e6	5e		 pop	 esi

; 2367 : }

  010e7	c3		 ret	 0
_cm_cmd_name ENDP
_phTTS$ = 8
_pipe_value$ = 8
_cm_cmd_latin PROC NEAR

; 2384 : 	DT_PIPE_T pipe_value[2]; 
; 2385 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  010f0	8b 4c 24 04	 mov	 ecx, DWORD PTR _phTTS$[esp-4]

; 2386 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 2387 : 
; 2388 : 	pipe_value[0] = (1<<PSNEXTRA) + LATIN;

  010f4	66 c7 44 24 04
	0f 3f		 mov	 WORD PTR _pipe_value$[esp-4], 16143 ; 00003f0fH

; 2389 : 	pipe_value[1] = pCmd_t->params[0];
; 2390 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,2);

  010fb	6a 02		 push	 2
  010fd	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  01100	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  01103	66 8b 11	 mov	 dx, WORD PTR [ecx]
  01106	8d 4c 24 08	 lea	 ecx, DWORD PTR _pipe_value$[esp]
  0110a	66 89 54 24 0a	 mov	 WORD PTR _pipe_value$[esp+2], dx
  0110f	8b 90 d0 00 00
	00		 mov	 edx, DWORD PTR [eax+208]
  01115	51		 push	 ecx
  01116	52		 push	 edx
  01117	50		 push	 eax
  01118	e8 00 00 00 00	 call	 _cm_util_write_pipe
  0111d	83 c4 10	 add	 esp, 16			; 00000010H

; 2391 : 	return(CMD_success);

  01120	33 c0		 xor	 eax, eax

; 2392 : }

  01122	c3		 ret	 0
_cm_cmd_latin ENDP
_phTTS$ = 8
_pipe_value$ = 8
_cm_cmd_comma PROC NEAR

; 2408 : 	DT_PIPE_T pipe_value[2];
; 2409 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  01130	8b 4c 24 04	 mov	 ecx, DWORD PTR _phTTS$[esp-4]

; 2410 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 2411 : 
; 2412 : 	pipe_value[0] = (1<<PSNEXTRA) + CPAUSE;

  01134	66 c7 44 24 04
	01 3f		 mov	 WORD PTR _pipe_value$[esp-4], 16129 ; 00003f01H

; 2413 : 	pipe_value[1] = pCmd_t->params[0];
; 2414 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,2);

  0113b	6a 02		 push	 2
  0113d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  01140	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  01143	66 8b 11	 mov	 dx, WORD PTR [ecx]
  01146	8d 4c 24 08	 lea	 ecx, DWORD PTR _pipe_value$[esp]
  0114a	66 89 54 24 0a	 mov	 WORD PTR _pipe_value$[esp+2], dx
  0114f	8b 90 d0 00 00
	00		 mov	 edx, DWORD PTR [eax+208]
  01155	51		 push	 ecx
  01156	52		 push	 edx
  01157	50		 push	 eax
  01158	e8 00 00 00 00	 call	 _cm_util_write_pipe
  0115d	83 c4 10	 add	 esp, 16			; 00000010H

; 2415 : 	return(CMD_success);

  01160	33 c0		 xor	 eax, eax

; 2416 : }

  01162	c3		 ret	 0
_cm_cmd_comma ENDP
_phTTS$ = 8
_pipe_value$ = 8
_cm_cmd_period PROC NEAR

; 2433 : 	DT_PIPE_T pipe_value[2];
; 2434 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  01170	8b 4c 24 04	 mov	 ecx, DWORD PTR _phTTS$[esp-4]

; 2435 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 2436 : 	
; 2437 : 	pipe_value[0] = (1<<PSNEXTRA) + PPAUSE;

  01174	66 c7 44 24 04
	02 3f		 mov	 WORD PTR _pipe_value$[esp-4], 16130 ; 00003f02H

; 2438 : 	pipe_value[1] = pCmd_t->params[0];
; 2439 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,2);

  0117b	6a 02		 push	 2
  0117d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  01180	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  01183	66 8b 11	 mov	 dx, WORD PTR [ecx]
  01186	8d 4c 24 08	 lea	 ecx, DWORD PTR _pipe_value$[esp]
  0118a	66 89 54 24 0a	 mov	 WORD PTR _pipe_value$[esp+2], dx
  0118f	8b 90 d0 00 00
	00		 mov	 edx, DWORD PTR [eax+208]
  01195	51		 push	 ecx
  01196	52		 push	 edx
  01197	50		 push	 eax
  01198	e8 00 00 00 00	 call	 _cm_util_write_pipe
  0119d	83 c4 10	 add	 esp, 16			; 00000010H

; 2440 : 	return(CMD_success);

  011a0	33 c0		 xor	 eax, eax

; 2441 : }

  011a2	c3		 ret	 0
_cm_cmd_period ENDP
_TEXT	ENDS
EXTRN	_cm_pars_proc_char:NEAR
EXTRN	_send_index:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pipe_value$ = -8
_pKsd_t$ = 8
_cm_cmd_mark PROC NEAR

; 2456 : {

  011b0	83 ec 08	 sub	 esp, 8
  011b3	53		 push	 ebx
  011b4	55		 push	 ebp
  011b5	56		 push	 esi
  011b6	57		 push	 edi

; 2457 : 	DT_PIPE_T pipe_value[3];
; 2458 : 	short cmd_type, cmd_value;
; 2459 : 	short temp;
; 2460 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  011b7	8b 7c 24 1c	 mov	 edi, DWORD PTR _phTTS$[esp+20]

; 2461 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  011bb	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
  011be	8b 6f 08	 mov	 ebp, DWORD PTR [edi+8]
  011c1	89 6c 24 1c	 mov	 DWORD PTR _pKsd_t$[esp+20], ebp

; 2462 : 	
; 2463 : 	cmd_type = cm_util_string_match(index_options,pCmd_t->pString[0]);

  011c5	8b 86 80 02 00
	00		 mov	 eax, DWORD PTR [esi+640]
  011cb	50		 push	 eax
  011cc	68 00 00 00 00	 push	 OFFSET FLAT:_index_options
  011d1	e8 00 00 00 00	 call	 _cm_util_string_match

; 2464 : 	if(cmd_type == NO_STRING_MATCH)

  011d6	0f bf c8	 movsx	 ecx, ax
  011d9	83 c4 08	 add	 esp, 8
  011dc	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH

; 2465 : 	{
; 2466 : 	    /* change for the parser index buffer */
; 2467 :     	/* force the parser buffer to be sent */
; 2468 : #ifdef NEW_INDEXING
; 2469 : 	 	temp=pCmd_t->ParseChar; 
; 2470 : 	 	pCmd_t->ParseChar=0x0fff;
; 2471 :  		cm_pars_proc_char(phTTS,' ');
; 2472 : 	 	pCmd_t->ParseChar=temp;
; 2473 : #endif
; 2474 : 		return(CMD_bad_string);

  011e2	0f 84 91 01 00
	00		 je	 $L71886

; 2475 : 	}		
; 2476 : 	if(cmd_type == 3)

  011e8	66 3d 03 00	 cmp	 ax, 3
  011ec	75 0e		 jne	 SHORT $L71873

; 2477 : 	{
; 2478 : 		cmd_type = DCS_INDEX;

  011ee	b8 14 00 00 00	 mov	 eax, 20			; 00000014H

; 2479 : 		pipe_value[2] = SPC_INDEX_PAUSE;

  011f3	66 c7 44 24 14
	02 00		 mov	 WORD PTR _pipe_value$[esp+28], 2

; 2480 : 	}
; 2481 : 	else

  011fa	eb 0a		 jmp	 SHORT $L71874
$L71873:

; 2482 : 	{
; 2483 : 		cmd_type += DCS_INDEX;

  011fc	83 c0 14	 add	 eax, 20			; 00000014H

; 2484 : 		pipe_value[2] = TEXT_OUTPUT;

  011ff	66 c7 44 24 14
	00 00		 mov	 WORD PTR _pipe_value$[esp+28], 0
$L71874:

; 2485 : 	}
; 2486 : 	cmd_value = pCmd_t->params[1];

  01206	66 8b 4e 04	 mov	 cx, WORD PTR [esi+4]

; 2487 : 
; 2488 : 	switch(cmd_type)
; 2489 : 	{

  0120a	0f bf c0	 movsx	 eax, ax
  0120d	83 c0 ec	 add	 eax, -20		; ffffffecH
  01210	83 f8 07	 cmp	 eax, 7
  01213	0f 87 60 01 00
	00		 ja	 $L71886
  01219	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72093[eax*4]
$L71879:

; 2490 : 		case    DCS_INDEX       :
; 2491 : 
; 2492 : 			pipe_value[0] = (2<<PSNEXTRA) + INDEX;

  01220	66 c7 44 24 10
	08 5f		 mov	 WORD PTR _pipe_value$[esp+24], 24328 ; 00005f08H

; 2493 : 			break;

  01227	e9 88 00 00 00	 jmp	 $L71876
$L71880:

; 2494 : 
; 2495 : 		case    DCS_INDEX_REPLY :
; 2496 : 
; 2497 : 			pipe_value[0] = (2<<PSNEXTRA) + INDEX_REPLY;

  0122c	66 c7 44 24 10
	09 5f		 mov	 WORD PTR _pipe_value$[esp+24], 24329 ; 00005f09H

; 2498 : 			break;

  01233	eb 7f		 jmp	 SHORT $L71876
$L71881:

; 2499 : 
; 2500 : 		case    DCS_INDEX_QUERY :
; 2501 : 	    /* change for the parser index buffer */
; 2502 :     	/* force the parser buffer to be sent */
; 2503 : #ifdef NEW_INDEXING
; 2504 : 		 	temp=pCmd_t->ParseChar; 

  01235	66 8b 9e 1c 05
	00 00		 mov	 bx, WORD PTR [esi+1308]

; 2505 : 		 	pCmd_t->ParseChar=0x0fff;
; 2506 : 			cm_pars_proc_char(phTTS,' ');

  0123c	6a 20		 push	 32			; 00000020H
  0123e	57		 push	 edi
  0123f	66 c7 86 1c 05
	00 00 ff 0f	 mov	 WORD PTR [esi+1308], 4095 ; 00000fffH
  01248	e8 00 00 00 00	 call	 _cm_pars_proc_char

; 2507 : 		 	pCmd_t->ParseChar=temp;

  0124d	66 89 9e 1c 05
	00 00		 mov	 WORD PTR [esi+1308], bx

; 2508 : #endif
; 2509 : #ifdef MSDOS
; 2510 :         	WAIT_PRINT;
; 2511 : 			printf("\n[:index %d]",pKsd_t->lastindex);
; 2512 :         	SIGNAL_PRINT;
; 2513 : #else
; 2514 : 			send_index(pipe_value[2],pKsd_t->lastindex);

  01254	8b 44 24 1c	 mov	 eax, DWORD PTR _pipe_value$[esp+36]
  01258	8b 95 9c 01 00
	00		 mov	 edx, DWORD PTR [ebp+412]
  0125e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  01263	52		 push	 edx
  01264	50		 push	 eax
  01265	e8 00 00 00 00	 call	 _send_index
  0126a	83 c4 10	 add	 esp, 16			; 00000010H

; 2515 : #endif
; 2516 : 			return(CMD_success);

  0126d	33 c0		 xor	 eax, eax
  0126f	5f		 pop	 edi
  01270	5e		 pop	 esi
  01271	5d		 pop	 ebp
  01272	5b		 pop	 ebx

; 2590 : }

  01273	83 c4 08	 add	 esp, 8
  01276	c3		 ret	 0
$L71882:

; 2517 : 		//tek 01aug97 bats 404
; 2518 : 		// handle these new index types.
; 2519 :                 //cjl 18nov97 Add ifdef for 32bit only.
; 2520 : #ifdef _WIN32
; 2521 : 
; 2522 : 		case DCS_INDEX_BOOKMARK:
; 2523 : 			pipe_value[0] = (2<<PSNEXTRA) | INDEX_BOOKMARK;

  01277	66 c7 44 24 10
	13 5f		 mov	 WORD PTR _pipe_value$[esp+24], 24339 ; 00005f13H

; 2524 : 			pipe_value[2] = pCmd_t->params[2];//NH

  0127e	66 8b 56 08	 mov	 dx, WORD PTR [esi+8]
  01282	66 89 54 24 14	 mov	 WORD PTR _pipe_value$[esp+28], dx

; 2525 : 			break;

  01287	eb 2b		 jmp	 SHORT $L71876
$L71883:

; 2526 : 
; 2527 : 		case DCS_INDEX_WORDPOS:
; 2528 : 			pipe_value[0] = (2<<PSNEXTRA) | INDEX_WORDPOS;

  01289	66 c7 44 24 10
	14 5f		 mov	 WORD PTR _pipe_value$[esp+24], 24340 ; 00005f14H

; 2529 : 			pipe_value[2] = pCmd_t->params[2];//Nl
; 2530 : 			break;

  01290	eb 19		 jmp	 SHORT $L72092
$L71884:

; 2531 : 
; 2532 : 		case DCS_INDEX_START:
; 2533 : 			pipe_value[0] = (2<<PSNEXTRA) | INDEX_START;

  01292	66 c7 44 24 10
	15 5f		 mov	 WORD PTR _pipe_value$[esp+24], 24341 ; 00005f15H

; 2534 : 			pipe_value[2] = pCmd_t->params[2];//N?

  01299	66 8b 56 08	 mov	 dx, WORD PTR [esi+8]
  0129d	66 89 54 24 14	 mov	 WORD PTR _pipe_value$[esp+28], dx

; 2535 : 			break;

  012a2	eb 10		 jmp	 SHORT $L71876
$L71885:

; 2536 : 
; 2537 : 		case DCS_INDEX_STOP:
; 2538 : 			pipe_value[0] = (2<<PSNEXTRA) | INDEX_STOP;

  012a4	66 c7 44 24 10
	16 5f		 mov	 WORD PTR _pipe_value$[esp+24], 24342 ; 00005f16H
$L72092:

; 2539 : 			pipe_value[2] = pCmd_t->params[2];//N?

  012ab	66 8b 46 08	 mov	 ax, WORD PTR [esi+8]
  012af	66 89 44 24 14	 mov	 WORD PTR _pipe_value$[esp+28], ax
$L71876:

; 2554 : 	}
; 2555 :     /* change for the parser index buffer */
; 2556 :     /* make it place the index command into the buffer and not write it to the output */
; 2557 : 	pipe_value[1] = cmd_value;

  012b4	66 89 4c 24 12	 mov	 WORD PTR _pipe_value$[esp+26], cx

; 2558 : #ifdef NEW_INDEXING
; 2559 : 	/* add the space to the clause buffer */
; 2560 :     if (pCmd_t->input_counter>=PAR_ROLLING_STOP_VALUE)

  012b9	66 81 be 28 05
	00 00 2c 01	 cmp	 WORD PTR [esi+1320], 300 ; 0000012cH
  012c2	7c 36		 jl	 SHORT $L71887

; 2561 :     {
; 2562 : 	 	temp=pCmd_t->ParseChar; 

  012c4	66 8b 9e 1c 05
	00 00		 mov	 bx, WORD PTR [esi+1308]

; 2563 : 	 	pCmd_t->ParseChar=' ';

  012cb	bd 20 00 00 00	 mov	 ebp, 32			; 00000020H

; 2564 : 		cm_pars_proc_char(phTTS,' ');

  012d0	55		 push	 ebp
  012d1	57		 push	 edi
  012d2	66 89 ae 1c 05
	00 00		 mov	 WORD PTR [esi+1308], bp
  012d9	e8 00 00 00 00	 call	 _cm_pars_proc_char

; 2565 : 	 	pCmd_t->ParseChar=' ';
; 2566 : 		cm_pars_proc_char(phTTS,' ');

  012de	55		 push	 ebp
  012df	57		 push	 edi
  012e0	66 89 ae 1c 05
	00 00		 mov	 WORD PTR [esi+1308], bp
  012e7	e8 00 00 00 00	 call	 _cm_pars_proc_char

; 2567 : 	 	pCmd_t->ParseChar=temp;                     

  012ec	8b 6c 24 2c	 mov	 ebp, DWORD PTR _pKsd_t$[esp+36]
  012f0	83 c4 10	 add	 esp, 16			; 00000010H
  012f3	66 89 9e 1c 05
	00 00		 mov	 WORD PTR [esi+1308], bx
$L71887:

; 2568 : 	}
; 2569 : 	if (pCmd_t->punct_mode==PUNCT_pass || pCmd_t->skip_mode==SKIP_all)

  012fa	83 be 00 05 00
	00 03		 cmp	 DWORD PTR [esi+1280], 3
  01301	74 55		 je	 SHORT $L71889
  01303	83 be 04 05 00
	00 04		 cmp	 DWORD PTR [esi+1284], 4
  0130a	74 4c		 je	 SHORT $L71889

; 2573 : 	}
; 2574 : 	/* GL 09/04/1996 insert a dummy space before the index marker */
; 2575 : 	/* MGS 10/14/1999 BATS #876 fix for UK phone numbers (part of it) */
; 2576 : 	/* comment out next line, it adds a second dummy space and breaks things */
; 2577 : 	//	pCmd_t->clausebuf[pCmd_t->input_counter++]=' ';
; 2578 : 	/* insert a dummy character for the index */
; 2579 : 	pCmd_t->clausebuf[pCmd_t->input_counter]=PAR_INDEX_DUMMY_CHAR;

  0130c	0f bf 8e 28 05
	00 00		 movsx	 ecx, WORD PTR [esi+1320]
  01313	5f		 pop	 edi
  01314	c6 84 31 30 05
	00 00 82	 mov	 BYTE PTR [ecx+esi+1328], 130 ; 00000082H

; 2580 : 	/* put the index into the index buffer */
; 2581 : 	memcpy(pCmd_t->input_indexes[pCmd_t->input_counter].index,pipe_value,sizeof(index_data_t));

  0131c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pipe_value$[esp+20]
  01320	0f bf 86 28 05
	00 00		 movsx	 eax, WORD PTR [esi+1320]
  01327	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0132a	8d 84 56 c4 16
	00 00		 lea	 eax, DWORD PTR [esi+edx*2+5828]
  01331	89 8c 56 c4 16
	00 00		 mov	 DWORD PTR [esi+edx*2+5828], ecx
  01338	66 8b 54 24 10	 mov	 dx, WORD PTR _pipe_value$[esp+24]
  0133d	66 89 50 04	 mov	 WORD PTR [eax+4], dx

; 2582 : 	/* add 1 for the counter updating */
; 2583 : 	pCmd_t->input_counter++;

  01341	66 ff 86 28 05
	00 00		 inc	 WORD PTR [esi+1320]

; 2584 : 	pCmd_t->index_counter++;

  01348	66 ff 86 2a 05
	00 00		 inc	 WORD PTR [esi+1322]
  0134f	5e		 pop	 esi
  01350	5d		 pop	 ebp

; 2585 : #endif
; 2586 : #ifndef NEW_INDEXING
; 2587 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,3);
; 2588 : #endif
; 2589 : 	return(CMD_success);

  01351	33 c0		 xor	 eax, eax
  01353	5b		 pop	 ebx

; 2590 : }

  01354	83 c4 08	 add	 esp, 8
  01357	c3		 ret	 0
$L71889:

; 2570 : 	{
; 2571 :                 cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,3);

  01358	8b 8d d0 00 00
	00		 mov	 ecx, DWORD PTR [ebp+208]
  0135e	8d 44 24 10	 lea	 eax, DWORD PTR _pipe_value$[esp+24]
  01362	6a 03		 push	 3
  01364	50		 push	 eax
  01365	51		 push	 ecx
  01366	55		 push	 ebp
  01367	e8 00 00 00 00	 call	 _cm_util_write_pipe
  0136c	83 c4 10	 add	 esp, 16			; 00000010H

; 2572 : 		return(CMD_success);

  0136f	33 c0		 xor	 eax, eax
  01371	5f		 pop	 edi
  01372	5e		 pop	 esi
  01373	5d		 pop	 ebp
  01374	5b		 pop	 ebx

; 2590 : }

  01375	83 c4 08	 add	 esp, 8
  01378	c3		 ret	 0
$L71886:

; 2540 : 			break;
; 2541 : #endif
; 2542 : 
; 2543 : 		default                 :
; 2544 : 	    /* change for the parser index buffer */
; 2545 :     	/* force the parser buffer to be sent */
; 2546 : #ifdef NEW_INDEXING
; 2547 : 		 	temp=pCmd_t->ParseChar; 

  01379	66 8b 9e 1c 05
	00 00		 mov	 bx, WORD PTR [esi+1308]

; 2548 : 		 	pCmd_t->ParseChar=0x0fff;
; 2549 : 	 		cm_pars_proc_char(phTTS,' ');

  01380	6a 20		 push	 32			; 00000020H
  01382	57		 push	 edi
  01383	66 c7 86 1c 05
	00 00 ff 0f	 mov	 WORD PTR [esi+1308], 4095 ; 00000fffH
  0138c	e8 00 00 00 00	 call	 _cm_pars_proc_char
  01391	83 c4 08	 add	 esp, 8

; 2550 : 		 	pCmd_t->ParseChar=temp;

  01394	66 89 9e 1c 05
	00 00		 mov	 WORD PTR [esi+1308], bx

; 2551 : #endif
; 2552 : 
; 2553 : 			return(CMD_bad_string);

  0139b	b8 01 00 00 00	 mov	 eax, 1
  013a0	5f		 pop	 edi
  013a1	5e		 pop	 esi
  013a2	5d		 pop	 ebp
  013a3	5b		 pop	 ebx

; 2590 : }

  013a4	83 c4 08	 add	 esp, 8
  013a7	c3		 ret	 0
$L72093:
  013a8	00 00 00 00	 DD	 $L71879
  013ac	00 00 00 00	 DD	 $L71880
  013b0	00 00 00 00	 DD	 $L71881
  013b4	00 00 00 00	 DD	 $L71886
  013b8	00 00 00 00	 DD	 $L71882
  013bc	00 00 00 00	 DD	 $L71883
  013c0	00 00 00 00	 DD	 $L71884
  013c4	00 00 00 00	 DD	 $L71885
_cm_cmd_mark ENDP
_phTTS$ = 8
_pipe_value$ = -8
_cm_cmd_define PROC NEAR

; 2609 : 	DT_PIPE_T pipe_value[3];
; 2610 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  013d0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  013d4	83 ec 08	 sub	 esp, 8
  013d7	56		 push	 esi

; 2611 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  013d8	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  013db	57		 push	 edi
  013dc	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 2612 : 	
; 2613 : 	if(pCmd_t->param_index == 0)

  013df	8b 86 d0 02 00
	00		 mov	 eax, DWORD PTR [esi+720]
  013e5	85 c0		 test	 eax, eax

; 2614 : 		return(CMD_success);

  013e7	0f 84 91 00 00
	00		 je	 $L71904

; 2615 : 	pipe_value[1] = cm_util_string_match(define_options,pCmd_t->pString[0]);

  013ed	8b 86 80 02 00
	00		 mov	 eax, DWORD PTR [esi+640]
  013f3	50		 push	 eax
  013f4	68 00 00 00 00	 push	 OFFSET FLAT:_define_options
  013f9	e8 00 00 00 00	 call	 _cm_util_string_match
  013fe	83 c4 08	 add	 esp, 8

; 2616 : 	
; 2617 : 	/* 09/09/1996 SIK Fix for this command */
; 2618 : 	if(pipe_value[1] == NO_STRING_MATCH)

  01401	66 3d ff ff	 cmp	 ax, 65535		; 0000ffffH
  01405	66 89 44 24 0a	 mov	 WORD PTR _pipe_value$[esp+18], ax
  0140a	75 0b		 jne	 SHORT $L71898
  0140c	5f		 pop	 edi

; 2619 : 		return(CMD_bad_string);

  0140d	b8 01 00 00 00	 mov	 eax, 1
  01412	5e		 pop	 esi

; 2647 : }

  01413	83 c4 08	 add	 esp, 8
  01416	c3		 ret	 0
$L71898:

; 2620 : 	/*
; 2621 :  	 *  do the save first ...
; 2622 :  	 */
; 2623 : 
; 2624 : 	if(pipe_value[1] == 0)

  01417	66 85 c0	 test	 ax, ax
  0141a	75 20		 jne	 SHORT $L71899

; 2625 : 	{
; 2626 : 		if(pCmd_t->defaults[1] == FALSE)

  0141c	8b 86 ac 02 00
	00		 mov	 eax, DWORD PTR [esi+684]
  01422	85 c0		 test	 eax, eax
  01424	75 0b		 jne	 SHORT $L71900
  01426	5f		 pop	 edi

; 2627 : 			return(CMD_bad_value);

  01427	b8 02 00 00 00	 mov	 eax, 2
  0142c	5e		 pop	 esi

; 2647 : }

  0142d	83 c4 08	 add	 esp, 8
  01430	c3		 ret	 0
$L71900:

; 2628 : 		else
; 2629 : 		{
; 2630 : 			pipe_value[0] = SAVE;

  01431	66 c7 44 24 08
	07 1f		 mov	 WORD PTR _pipe_value$[esp+16], 7943 ; 00001f07H

; 2631 :                         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,1);

  01438	6a 01		 push	 1

; 2632 : 		}
; 2633 : 	}
; 2634 : 	else

  0143a	eb 2d		 jmp	 SHORT $L72095
$L71899:

; 2635 : 	{
; 2636 : 		if(pCmd_t->defaults[1] == TRUE)

  0143c	83 be ac 02 00
	00 01		 cmp	 DWORD PTR [esi+684], 1
  01443	75 0b		 jne	 SHORT $L71903
  01445	5f		 pop	 edi

; 2637 : 			return(CMD_bad_value);

  01446	b8 02 00 00 00	 mov	 eax, 2
  0144b	5e		 pop	 esi

; 2647 : }

  0144c	83 c4 08	 add	 esp, 8
  0144f	c3		 ret	 0
$L71903:

; 2638 : 		else
; 2639 : 		{
; 2640 : 			pipe_value[0] = (2<<PSNEXTRA)+NEW_PARAM;
; 2641 : 			pipe_value[1] -= 1;

  01450	66 48		 dec	 ax
  01452	66 c7 44 24 08
	06 5f		 mov	 WORD PTR _pipe_value$[esp+16], 24326 ; 00005f06H
  01459	66 89 44 24 0a	 mov	 WORD PTR _pipe_value$[esp+18], ax

; 2642 : 			pipe_value[2] = pCmd_t->params[1];

  0145e	66 8b 46 04	 mov	 ax, WORD PTR [esi+4]
  01462	66 89 44 24 0c	 mov	 WORD PTR _pipe_value$[esp+20], ax

; 2643 :                         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,pipe_value,3);

  01467	6a 03		 push	 3
$L72095:
  01469	8b 97 d0 00 00
	00		 mov	 edx, DWORD PTR [edi+208]
  0146f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _pipe_value$[esp+20]
  01473	51		 push	 ecx
  01474	52		 push	 edx
  01475	57		 push	 edi
  01476	e8 00 00 00 00	 call	 _cm_util_write_pipe
  0147b	83 c4 10	 add	 esp, 16			; 00000010H
$L71904:
  0147e	5f		 pop	 edi

; 2644 : 		}
; 2645 : 	}
; 2646 : 	return(CMD_success);

  0147f	33 c0		 xor	 eax, eax
  01481	5e		 pop	 esi

; 2647 : }

  01482	83 c4 08	 add	 esp, 8
  01485	c3		 ret	 0
_cm_cmd_define ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_plang
EXTRN	__imp__printf:NEAR
_DATA	SEGMENT
$SG71919 DB	0aH, '  %d arpabet (%c%c)  asky (%c)', 00H
$SG71922 DB	0aH, '  %d arpabet (%c%c)  asky (%c)', 00H
_DATA	ENDS
_TEXT	SEGMENT
_phTTS$ = 8
_pipe_value$ = 8
_cm_cmd_plang PROC NEAR

; 2664 : 	DT_PIPE_T pipe_value;
; 2665 : 	int     i;
; 2666 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  01490	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  01494	53		 push	 ebx
  01495	56		 push	 esi

; 2667 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 2668 : 	
; 2669 : 	if(cm_cmd_sync(phTTS) == CMD_flushing)

  01496	50		 push	 eax
  01497	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0149a	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]
  0149d	e8 00 00 00 00	 call	 _cm_cmd_sync
  014a2	83 c4 04	 add	 esp, 4
  014a5	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  014a8	75 03		 jne	 SHORT $L71912
  014aa	5e		 pop	 esi
  014ab	5b		 pop	 ebx

; 2714 : }

  014ac	c3		 ret	 0
$L71912:
  014ad	57		 push	 edi

; 2670 : 		return(CMD_flushing);
; 2671 : 	if(pCmd_t->params[0] == 0 || pCmd_t->defaults[0] == TRUE)

  014ae	8b 3b		 mov	 edi, DWORD PTR [ebx]
  014b0	85 ff		 test	 edi, edi
  014b2	0f 84 81 00 00
	00		 je	 $L71914
  014b8	83 bb a8 02 00
	00 01		 cmp	 DWORD PTR [ebx+680], 1
  014bf	74 78		 je	 SHORT $L71914

; 2690 : #endif
; 2691 : #ifdef __osf__
; 2692 : 				OP_Sleep(100);
; 2693 : #endif
; 2694 : #ifdef __linux__
; 2695 : 				OP_Sleep(100);
; 2696 : #endif
; 2697 : 
; 2698 : 			}
; 2699 : 	}
; 2700 : 	else 
; 2701 : 	if(pCmd_t->params[0] < MAXI_PHONES)

  014c1	83 ff 39	 cmp	 edi, 57			; 00000039H
  014c4	0f 83 f6 00 00
	00		 jae	 $L71917

; 2702 : 	{
; 2703 : 		i = pCmd_t->params[0];
; 2704 : 		WAIT_PRINT;
; 2705 : 		printf("\n  %d arpabet (%c%c)  asky (%c)",
; 2706 : 				i,pKsd_t->arpabet[i*2],pKsd_t->arpabet[i*2+1],pKsd_t->ascky[i]);

  014ca	8b 8e 58 04 00
	00		 mov	 ecx, DWORD PTR [esi+1112]
  014d0	8b 86 64 04 00
	00		 mov	 eax, DWORD PTR [esi+1124]
  014d6	33 d2		 xor	 edx, edx
  014d8	8a 14 39	 mov	 dl, BYTE PTR [ecx+edi]
  014db	8d 04 78	 lea	 eax, DWORD PTR [eax+edi*2]
  014de	52		 push	 edx
  014df	33 c9		 xor	 ecx, ecx
  014e1	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  014e4	33 d2		 xor	 edx, edx
  014e6	8a 10		 mov	 dl, BYTE PTR [eax]
  014e8	51		 push	 ecx
  014e9	52		 push	 edx
  014ea	57		 push	 edi
  014eb	68 00 00 00 00	 push	 OFFSET FLAT:$SG71922
  014f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf

; 2707 : 		SIGNAL_PRINT;
; 2708 : 		pipe_value = (PFUSA<<PSFONT) | i;

  014f6	81 cf 00 1e 00
	00		 or	 edi, 7680		; 00001e00H

; 2709 :                 cm_util_write_pipe(pKsd_t,pKsd_t->ph_pipe,&pipe_value,1);

  014fc	8d 44 24 24	 lea	 eax, DWORD PTR _pipe_value$[esp+28]
  01500	89 7c 24 24	 mov	 DWORD PTR _pipe_value$[esp+28], edi
  01504	8b 8e d4 00 00
	00		 mov	 ecx, DWORD PTR [esi+212]
  0150a	6a 01		 push	 1
  0150c	50		 push	 eax
  0150d	51		 push	 ecx
  0150e	56		 push	 esi
  0150f	e8 00 00 00 00	 call	 _cm_util_write_pipe

; 2710 : 		pipe_value = (PFUSA<<PSFONT) | COMMA;

  01514	c7 44 24 34 73
	1e 00 00	 mov	 DWORD PTR _pipe_value$[esp+44], 7795 ; 00001e73H

; 2711 :                 cm_util_write_pipe(pKsd_t,pKsd_t->ph_pipe,&pipe_value,1);

  0151c	8b 86 d4 00 00
	00		 mov	 eax, DWORD PTR [esi+212]
  01522	8d 54 24 34	 lea	 edx, DWORD PTR _pipe_value$[esp+44]
  01526	6a 01		 push	 1
  01528	52		 push	 edx
  01529	50		 push	 eax
  0152a	56		 push	 esi
  0152b	e8 00 00 00 00	 call	 _cm_util_write_pipe
  01530	83 c4 34	 add	 esp, 52			; 00000034H

; 2712 : 	}
; 2713 : 	return(CMD_success);

  01533	33 c0		 xor	 eax, eax
  01535	5f		 pop	 edi
  01536	5e		 pop	 esi
  01537	5b		 pop	 ebx

; 2714 : }

  01538	c3		 ret	 0
$L71914:
  01539	55		 push	 ebp

; 2672 : 	{
; 2673 : 		for(i=1; i < MAXI_PHONES; i++)
; 2674 : 			if(pKsd_t->arpabet[i*2])

  0153a	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__printf
  01540	bf 01 00 00 00	 mov	 edi, 1
$L71915:
  01545	8b 8e 64 04 00
	00		 mov	 ecx, DWORD PTR [esi+1124]
  0154b	8a 04 79	 mov	 al, BYTE PTR [ecx+edi*2]
  0154e	8d 0c 79	 lea	 ecx, DWORD PTR [ecx+edi*2]
  01551	84 c0		 test	 al, al
  01553	74 64		 je	 SHORT $L71916

; 2675 : 			{
; 2676 : 				WAIT_PRINT;
; 2677 : 				printf("\n  %d arpabet (%c%c)  asky (%c)",
; 2678 : 					i,pKsd_t->arpabet[i*2],pKsd_t->arpabet[i*2+1],pKsd_t->ascky[i]);

  01555	8b 96 58 04 00
	00		 mov	 edx, DWORD PTR [esi+1112]
  0155b	33 db		 xor	 ebx, ebx
  0155d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01562	8a 1c 3a	 mov	 bl, BYTE PTR [edx+edi]
  01565	33 d2		 xor	 edx, edx
  01567	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0156a	53		 push	 ebx
  0156b	52		 push	 edx
  0156c	50		 push	 eax
  0156d	57		 push	 edi
  0156e	68 00 00 00 00	 push	 OFFSET FLAT:$SG71919
  01573	ff d5		 call	 ebp

; 2679 : 				SIGNAL_PRINT;
; 2680 : 				pipe_value = (PFUSA<<PSFONT) | i;

  01575	8b c7		 mov	 eax, edi

; 2681 :                                 cm_util_write_pipe(pKsd_t,pKsd_t->ph_pipe,&pipe_value,1);

  01577	8d 4c 24 28	 lea	 ecx, DWORD PTR _pipe_value$[esp+32]
  0157b	80 cc 1e	 or	 ah, 30			; 0000001eH
  0157e	6a 01		 push	 1
  01580	89 44 24 2c	 mov	 DWORD PTR _pipe_value$[esp+36], eax
  01584	8b 96 d4 00 00
	00		 mov	 edx, DWORD PTR [esi+212]
  0158a	51		 push	 ecx
  0158b	52		 push	 edx
  0158c	56		 push	 esi
  0158d	e8 00 00 00 00	 call	 _cm_util_write_pipe

; 2682 : 				pipe_value = (PFUSA<<PSFONT) | COMMA;

  01592	c7 44 24 38 73
	1e 00 00	 mov	 DWORD PTR _pipe_value$[esp+48], 7795 ; 00001e73H

; 2683 :                                 cm_util_write_pipe(pKsd_t,pKsd_t->ph_pipe,&pipe_value,1);

  0159a	8b 8e d4 00 00
	00		 mov	 ecx, DWORD PTR [esi+212]
  015a0	8d 44 24 38	 lea	 eax, DWORD PTR _pipe_value$[esp+48]
  015a4	6a 01		 push	 1
  015a6	50		 push	 eax
  015a7	51		 push	 ecx
  015a8	56		 push	 esi
  015a9	e8 00 00 00 00	 call	 _cm_util_write_pipe
  015ae	83 c4 34	 add	 esp, 52			; 00000034H

; 2684 : 				/* GL 04/21/1997  change this for OSF build */
; 2685 : #ifdef MSDOS
; 2686 : 				sleep(100);
; 2687 : #endif
; 2688 : #ifdef WIN32
; 2689 : 				Sleep(100);

  015b1	6a 64		 push	 100			; 00000064H
  015b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
$L71916:
  015b9	47		 inc	 edi
  015ba	83 ff 39	 cmp	 edi, 57			; 00000039H
  015bd	7c 86		 jl	 SHORT $L71915
  015bf	5d		 pop	 ebp
$L71917:
  015c0	5f		 pop	 edi
  015c1	5e		 pop	 esi

; 2712 : 	}
; 2713 : 	return(CMD_success);

  015c2	33 c0		 xor	 eax, eax
  015c4	5b		 pop	 ebx

; 2714 : }

  015c5	c3		 ret	 0
_cm_cmd_plang ENDP
_phTTS$ = 8
_cm_cmd_stress PROC NEAR

; 2733 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  015d0	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  015d4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 2734 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData; 

  015d7	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 2735 : 	
; 2736 : 	if(pCmd_t->defaults[0] == TRUE)

  015da	83 b8 a8 02 00
	00 01		 cmp	 DWORD PTR [eax+680], 1
  015e1	75 0d		 jne	 SHORT $L71928

; 2737 : 		pKsd_t->pitch_delta = 0;

  015e3	c7 81 50 02 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+592], 0

; 2740 : 	return(CMD_success);

  015ed	33 c0		 xor	 eax, eax

; 2741 : }

  015ef	c3		 ret	 0
$L71928:

; 2738 : 	else
; 2739 : 		pKsd_t->pitch_delta = (int)pCmd_t->params[0];

  015f0	8b 00		 mov	 eax, DWORD PTR [eax]
  015f2	89 81 50 02 00
	00		 mov	 DWORD PTR [ecx+592], eax

; 2740 : 	return(CMD_success);

  015f8	33 c0		 xor	 eax, eax

; 2741 : }

  015fa	c3		 ret	 0
_cm_cmd_stress ENDP
_TEXT	ENDS
EXTRN	_WaitForLtsFlush:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_pipe$ = -12
_cm_cmd_tone PROC NEAR

; 2763 : {

  01600	83 ec 0c	 sub	 esp, 12			; 0000000cH
  01603	53		 push	 ebx
  01604	56		 push	 esi

; 2764 :   DT_PIPE_T pipe[6];
; 2765 :   /*LPTTS_HANDLE_T phTTS;*/             /*MVP MI */
; 2766 :   PKSD_T pKsd_t = phTTS->pKernelShareData;

  01605	8b 74 24 18	 mov	 esi, DWORD PTR _phTTS$[esp+16]
  01609	57		 push	 edi

; 2767 :   PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 2768 : 
; 2769 : 
; 2770 :   /********************************************************************/
; 2771 :   /*  Get the text to speech handle.                                  */
; 2772 :   /********************************************************************/
; 2773 : 
; 2774 :   /*phTTS = TextToSpeechGetHandle();*/
; 2775 : 
; 2776 :   /********************************************************************/
; 2777 :   /*  Wait for all characters previously queued to LTS to be          */
; 2778 :   /*  processed.                                                      */
; 2779 :   /********************************************************************/
; 2780 : 
; 2781 :   if ( cm_cmd_sync(phTTS) == CMD_flushing )

  0160a	56		 push	 esi
  0160b	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0160e	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  01611	e8 00 00 00 00	 call	 _cm_cmd_sync
  01616	83 c4 04	 add	 esp, 4
  01619	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0161c	75 07		 jne	 SHORT $L71937
  0161e	5f		 pop	 edi
  0161f	5e		 pop	 esi
  01620	5b		 pop	 ebx

; 2829 : }

  01621	83 c4 0c	 add	 esp, 12			; 0000000cH
  01624	c3		 ret	 0
$L71937:

; 2782 : 	return( CMD_flushing );
; 2783 : 
; 2784 :   WaitForLtsFlush( phTTS, 0xFFFFFFFF );

  01625	6a ff		 push	 -1
  01627	56		 push	 esi
  01628	e8 00 00 00 00	 call	 _WaitForLtsFlush

; 2785 : 
; 2786 :   /********************************************************************/
; 2787 :   /*  The packet format here is different than the DTC07. The ramp    */
; 2788 :   /*  duration has been eliminated. The tone generation software      */
; 2789 :   /*  automatically provides 3 msec. cosine squared tapering for      */
; 2790 :   /*  the tone pulse rise and fall time.                              */
; 2791 :   /*                                                                  */
; 2792 :   /*  Packet Index     Packet Data                 Value              */
; 2793 :   /*                                                                  */
; 2794 :   /*      0            Command Word              SPC_type_tone        */
; 2795 :   /*      1            Tone Duration (msec.)     0 to ?               */
; 2796 :   /*      2            Tone 0 Frequency          0 to Fs/2            */
; 2797 :   /*      3            Tone 0 Amplitude          0 to 32767           */
; 2798 :   /*      4            Tone 1 Frequency          0 to Fs/2            */
; 2799 :   /*      5            Tone 1 Amplitude          0 to 32767           */
; 2800 :   /*                                                                  */
; 2801 :   /********************************************************************/
; 2802 : 
; 2803 :   /********************************************************************/
; 2804 :   /*  params[1] is a character pointer to the duration in msec.       */
; 2805 :   /*  params[0] is a character pointer to the frequency in Hertz.     */
; 2806 :   /********************************************************************/
; 2807 : 
; 2808 :   if ( pCmd_t->params[0] > ( pKsd_t->uiSampleRate >> 1 ))

  0162d	8b 87 2c 02 00
	00		 mov	 eax, DWORD PTR [edi+556]
  01633	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  01635	d1 e8		 shr	 eax, 1
  01637	83 c4 08	 add	 esp, 8
  0163a	3b c8		 cmp	 ecx, eax
  0163c	76 0c		 jbe	 SHORT $L71938
  0163e	5f		 pop	 edi
  0163f	5e		 pop	 esi

; 2809 : 	return( CMD_bad_value );

  01640	b8 02 00 00 00	 mov	 eax, 2
  01645	5b		 pop	 ebx

; 2829 : }

  01646	83 c4 0c	 add	 esp, 12			; 0000000cH
  01649	c3		 ret	 0
$L71938:

; 2810 : 
; 2811 :   pipe[0] = SPC_type_tone;

  0164a	66 c7 44 24 0c
	02 00		 mov	 WORD PTR _pipe$[esp+24], 2

; 2812 :   pipe[1] = pCmd_t->params[1];

  01651	66 8b 4b 04	 mov	 cx, WORD PTR [ebx+4]
  01655	66 89 4c 24 0e	 mov	 WORD PTR _pipe$[esp+26], cx

; 2813 :   pipe[2] = pCmd_t->params[0];

  0165a	66 8b 13	 mov	 dx, WORD PTR [ebx]
  0165d	66 89 54 24 10	 mov	 WORD PTR _pipe$[esp+28], dx

; 2814 : 
; 2815 :   /********************************************************************/
; 2816 :   /*  Disable the second tone.                                        */
; 2817 :   /********************************************************************/
; 2818 : 
; 2819 :   pipe[3] = TONE_AMPLITUDE;

  01662	66 c7 44 24 12
	ff 7f		 mov	 WORD PTR _pipe$[esp+30], 32767 ; 00007fffH

; 2820 :   pipe[4] = 1000;

  01669	66 c7 44 24 14
	e8 03		 mov	 WORD PTR _pipe$[esp+32], 1000 ; 000003e8H

; 2821 :   pipe[5] = 0;

  01670	66 c7 44 24 16
	00 00		 mov	 WORD PTR _pipe$[esp+34], 0

; 2822 : 
; 2823 : /* GL 04/21/1997  change this for OSF build */
; 2824 : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 2825 :   cm_util_write_pipe(pKsd_t,pKsd_t->vtm_pipe, pipe, 6 );

  01677	8b 8f dc 00 00
	00		 mov	 ecx, DWORD PTR [edi+220]
  0167d	8d 44 24 0c	 lea	 eax, DWORD PTR _pipe$[esp+24]
  01681	6a 06		 push	 6
  01683	50		 push	 eax
  01684	51		 push	 ecx
  01685	57		 push	 edi
  01686	e8 00 00 00 00	 call	 _cm_util_write_pipe
  0168b	83 c4 10	 add	 esp, 16			; 00000010H

; 2826 : #endif
; 2827 : 
; 2828 :   return( CMD_success );

  0168e	33 c0		 xor	 eax, eax
  01690	5f		 pop	 edi
  01691	5e		 pop	 esi
  01692	5b		 pop	 ebx

; 2829 : }

  01693	83 c4 0c	 add	 esp, 12			; 0000000cH
  01696	c3		 ret	 0
_cm_cmd_tone ENDP
_TEXT	ENDS
EXTRN	_tlitone0:BYTE
EXTRN	_tlitone1:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_pChar$ = 8
_szSingleDigit$ = -16
_pipe$ = -12
_cm_cmd_dial PROC NEAR

; 2900 : {

  016a0	83 ec 10	 sub	 esp, 16			; 00000010H
  016a3	53		 push	 ebx
  016a4	55		 push	 ebp
  016a5	56		 push	 esi
  016a6	57		 push	 edi

; 2901 :   int iIndex;
; 2902 :   unsigned char *pChar;
; 2903 :   unsigned char szSingleDigit[2];
; 2904 :   DT_PIPE_T pipe[6];
; 2905 :   PKSD_T pKsd_t = phTTS->pKernelShareData;      

  016a7	8b 7c 24 24	 mov	 edi, DWORD PTR _phTTS$[esp+28]

; 2906 :   PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 2907 :   /*
; 2908 :   LPTTS_HANDLE_T phTTS;
; 2909 :   */
; 2910 :   /********************************************************************/
; 2911 :   /*  Get the text to speech handle.                                  */
; 2912 :   /********************************************************************/
; 2913 :   /*
; 2914 :   phTTS = TextToSpeechGetHandle();
; 2915 :   */
; 2916 :   /********************************************************************/
; 2917 :   /*  Wait for all characters previously queued to LTS to be          */
; 2918 :   /*  processed.                                                      */
; 2919 :   /********************************************************************/
; 2920 : 
; 2921 :   if ( cm_cmd_sync(phTTS) == CMD_flushing )

  016ab	57		 push	 edi
  016ac	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  016af	8b 5f 0c	 mov	 ebx, DWORD PTR [edi+12]
  016b2	e8 00 00 00 00	 call	 _cm_cmd_sync
  016b7	83 c4 04	 add	 esp, 4
  016ba	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  016bd	75 08		 jne	 SHORT $L71948
  016bf	5f		 pop	 edi
  016c0	5e		 pop	 esi
  016c1	5d		 pop	 ebp
  016c2	5b		 pop	 ebx

; 3116 : }

  016c3	83 c4 10	 add	 esp, 16			; 00000010H
  016c6	c3		 ret	 0
$L71948:

; 2922 : 	return( CMD_flushing );
; 2923 : 
; 2924 :   WaitForLtsFlush( phTTS, 0xFFFFFFFF );

  016c7	6a ff		 push	 -1
  016c9	57		 push	 edi
  016ca	e8 00 00 00 00	 call	 _WaitForLtsFlush

; 2925 : 
; 2926 :   /********************************************************************/
; 2927 :   /*  Write a tone packet to the VTM thread for each character in the */
; 2928 :   /*  dial string.                                                    */
; 2929 :   /********************************************************************/
; 2930 : 
; 2931 :   pChar = pCmd_t->pString[0];

  016cf	8b 9b 80 02 00
	00		 mov	 ebx, DWORD PTR [ebx+640]
  016d5	83 c4 08	 add	 esp, 8
  016d8	89 5c 24 24	 mov	 DWORD PTR _pChar$[esp+28], ebx

; 2932 : 
; 2933 :   while ( *pChar != '\0' )

  016dc	8a 0b		 mov	 cl, BYTE PTR [ebx]
  016de	84 c9		 test	 cl, cl
  016e0	0f 84 be 01 00
	00		 je	 $L71951
  016e6	bd 02 00 00 00	 mov	 ebp, 2
  016eb	bb 64 00 00 00	 mov	 ebx, 100		; 00000064H
  016f0	bf e8 03 00 00	 mov	 edi, 1000		; 000003e8H
$L71950:

; 2934 :   {
; 2935 : 	/******************************************************************/
; 2936 : 	/*  Convert the character to an index.                            */
; 2937 : 	/******************************************************************/
; 2938 : 
; 2939 : 	szSingleDigit[0] = *pChar;

  016f5	88 4c 24 10	 mov	 BYTE PTR _szSingleDigit$[esp+32], cl

; 2940 : 	szSingleDigit[1] = '\0';
; 2941 : 
; 2942 : 	  switch ( szSingleDigit[0] )
; 2943 : 	  {

  016f9	8b 44 24 10	 mov	 eax, DWORD PTR _szSingleDigit$[esp+32]
  016fd	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01702	83 c0 dd	 add	 eax, -35		; ffffffddH
  01705	83 f8 41	 cmp	 eax, 65			; 00000041H
  01708	0f 87 3e 01 00
	00		 ja	 $L71972
  0170e	33 d2		 xor	 edx, edx
  01710	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $L72107[eax]
  01716	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L72108[edx*4]
$L71956:

; 2944 : 	  		case '0':
; 2945 : 				iIndex = 0;

  0171d	33 c0		 xor	 eax, eax
$L71976:

; 3070 : 	{
; 3071 : 	  /****************************************************************/
; 3072 : 	  /*  DTMF digit.                                                 */
; 3073 : 	  /****************************************************************/
; 3074 : 
; 3075 : 	  pipe[0] = SPC_type_tone;
; 3076 : 	  pipe[1] = DTMF_DIGIT_TIME_IN_MSEC;
; 3077 : 	  pipe[2] = tlitone0[iIndex];

  0171f	66 8b 14 45 00
	00 00 00	 mov	 dx, WORD PTR _tlitone0[eax*2]

; 3078 : 	  pipe[3] = DTMF_HIGH_TONE_AMPLITUDE;
; 3079 : 	  pipe[4] = tlitone1[iIndex];

  01727	66 8b 04 45 00
	00 00 00	 mov	 ax, WORD PTR _tlitone1[eax*2]
  0172f	66 89 6c 24 14	 mov	 WORD PTR _pipe$[esp+32], bp
  01734	66 89 5c 24 16	 mov	 WORD PTR _pipe$[esp+34], bx
  01739	66 89 54 24 18	 mov	 WORD PTR _pipe$[esp+36], dx
  0173e	66 c7 44 24 1a
	7a 4e		 mov	 WORD PTR _pipe$[esp+38], 20090 ; 00004e7aH
  01745	66 89 44 24 1c	 mov	 WORD PTR _pipe$[esp+40], ax

; 3080 : 	  pipe[5] = DTMF_LOW_TONE_AMPLITUDE;

  0174a	66 c7 44 24 1e
	84 31		 mov	 WORD PTR _pipe$[esp+42], 12676 ; 00003184H

; 3081 : 
; 3082 : /* GL 04/21/1997  change this for OSF build */
; 3083 : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 3084 :           cm_util_write_pipe(pKsd_t, pKsd_t->vtm_pipe, pipe, 6 );

  01751	8b 96 dc 00 00
	00		 mov	 edx, DWORD PTR [esi+220]
  01757	8d 4c 24 14	 lea	 ecx, DWORD PTR _pipe$[esp+32]
  0175b	6a 06		 push	 6
  0175d	51		 push	 ecx
  0175e	52		 push	 edx
  0175f	56		 push	 esi
  01760	e8 00 00 00 00	 call	 _cm_util_write_pipe

; 3085 : #endif
; 3086 : 
; 3087 : 
; 3088 : 	  /****************************************************************/
; 3089 : 	  /*  Interdigital space.                                         */
; 3090 : 	  /****************************************************************/
; 3091 : 
; 3092 : 	  pipe[0] = SPC_type_tone;
; 3093 : 	  pipe[1] = DTMF_INTER_DIGITAL_TIME_IN_MSEC;
; 3094 : 	  pipe[2] = 1000;
; 3095 : 	  pipe[3] = 0;

  01765	33 c0		 xor	 eax, eax
  01767	66 89 6c 24 24	 mov	 WORD PTR _pipe$[esp+48], bp
  0176c	66 89 44 24 2a	 mov	 WORD PTR _pipe$[esp+54], ax

; 3096 : 	  pipe[4] = 1000;
; 3097 : 	  pipe[5] = 0;

  01771	66 89 44 24 2e	 mov	 WORD PTR _pipe$[esp+58], ax
  01776	66 89 5c 24 26	 mov	 WORD PTR _pipe$[esp+50], bx
  0177b	66 89 7c 24 28	 mov	 WORD PTR _pipe$[esp+52], di
  01780	66 89 7c 24 2c	 mov	 WORD PTR _pipe$[esp+56], di

; 3098 : 
; 3099 : 
; 3100 : /* GL 04/21/1997  change this for OSF build */
; 3101 : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 3102 : 	  cm_util_write_pipe(pKsd_t, pKsd_t->vtm_pipe, pipe, 6 );

  01785	8b 8e dc 00 00
	00		 mov	 ecx, DWORD PTR [esi+220]
  0178b	8d 44 24 24	 lea	 eax, DWORD PTR _pipe$[esp+48]
  0178f	6a 06		 push	 6
  01791	50		 push	 eax
  01792	51		 push	 ecx
  01793	56		 push	 esi
  01794	e8 00 00 00 00	 call	 _cm_util_write_pipe
  01799	83 c4 20	 add	 esp, 32			; 00000020H
$L71977:

; 3103 : #endif
; 3104 : 
; 3105 : 
; 3106 : 	}
; 3107 : 
; 3108 : 	/******************************************************************/
; 3109 : 	/*  Increment to the next character.                              */
; 3110 : 	/******************************************************************/
; 3111 : 
; 3112 : 	pChar++;

  0179c	8b 44 24 24	 mov	 eax, DWORD PTR _pChar$[esp+28]
  017a0	40		 inc	 eax
  017a1	89 44 24 24	 mov	 DWORD PTR _pChar$[esp+28], eax
  017a5	8a 08		 mov	 cl, BYTE PTR [eax]
  017a7	84 c9		 test	 cl, cl
  017a9	0f 85 46 ff ff
	ff		 jne	 $L71950
  017af	5f		 pop	 edi
  017b0	5e		 pop	 esi
  017b1	5d		 pop	 ebp

; 3113 :   }
; 3114 : 
; 3115 :   return( CMD_success );

  017b2	33 c0		 xor	 eax, eax
  017b4	5b		 pop	 ebx

; 3116 : }

  017b5	83 c4 10	 add	 esp, 16			; 00000010H
  017b8	c3		 ret	 0
$L71957:

; 2946 : 				break;
; 2947 : 
; 2948 : 	  		case '1':
; 2949 : 				iIndex = 1;

  017b9	b8 01 00 00 00	 mov	 eax, 1

; 2950 : 				break;

  017be	e9 5c ff ff ff	 jmp	 $L71976
$L71958:

; 2951 : 
; 2952 : 	  		case '2':
; 2953 : 				iIndex = 2;

  017c3	8b c5		 mov	 eax, ebp

; 2954 : 				break;

  017c5	e9 55 ff ff ff	 jmp	 $L71976
$L71959:

; 2955 : 
; 2956 : 	  		case '3':
; 2957 : 				iIndex = 3;

  017ca	b8 03 00 00 00	 mov	 eax, 3

; 2958 : 				break;

  017cf	e9 4b ff ff ff	 jmp	 $L71976
$L71960:

; 2959 : 
; 2960 : 	  		case '4':
; 2961 : 				iIndex = 4;

  017d4	b8 04 00 00 00	 mov	 eax, 4

; 2962 : 				break;

  017d9	e9 41 ff ff ff	 jmp	 $L71976
$L71961:

; 2963 : 
; 2964 : 	  		case '5':
; 2965 : 				iIndex = 5;

  017de	b8 05 00 00 00	 mov	 eax, 5

; 2966 : 				break;

  017e3	e9 37 ff ff ff	 jmp	 $L71976
$L71962:

; 2967 : 
; 2968 : 	  		case '6':
; 2969 : 				iIndex = 6;

  017e8	b8 06 00 00 00	 mov	 eax, 6

; 2970 : 				break;

  017ed	e9 2d ff ff ff	 jmp	 $L71976
$L71963:

; 2971 : 
; 2972 : 	  		case '7':
; 2973 : 				iIndex = 7;

  017f2	b8 07 00 00 00	 mov	 eax, 7

; 2974 : 				break;

  017f7	e9 23 ff ff ff	 jmp	 $L71976
$L71964:

; 2975 : 
; 2976 : 			case '8':
; 2977 : 				iIndex = 8;

  017fc	b8 08 00 00 00	 mov	 eax, 8

; 2978 : 				break;

  01801	e9 19 ff ff ff	 jmp	 $L71976
$L71965:

; 2979 : 
; 2980 : 			case '9':
; 2981 : 				iIndex = 9;

  01806	b8 09 00 00 00	 mov	 eax, 9

; 2982 : 				break;

  0180b	e9 0f ff ff ff	 jmp	 $L71976
$L71966:

; 2983 : 	  	
; 2984 : 			case '*':
; 2985 : 				iIndex = 10;

  01810	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH

; 2986 : 				break;

  01815	e9 05 ff ff ff	 jmp	 $L71976
$L71967:

; 2987 : 
; 2988 : 			case '#':
; 2989 : 				iIndex = 11;

  0181a	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH

; 2990 : 				break;

  0181f	e9 fb fe ff ff	 jmp	 $L71976
$L71968:

; 2991 : 
; 2992 : 	  		case 'a':
; 2993 : 	  		case 'A':
; 2994 : 				iIndex = 12;

  01824	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH

; 2995 : 				break;

  01829	e9 f1 fe ff ff	 jmp	 $L71976
$L71969:

; 2996 : 
; 2997 : 			case 'b':
; 2998 : 	  		case 'B':
; 2999 : 				iIndex = 13;

  0182e	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH

; 3000 : 				break;

  01833	e9 e7 fe ff ff	 jmp	 $L71976
$L71970:

; 3001 : 
; 3002 : 	  		case 'c':
; 3003 : 	  		case 'C':
; 3004 : 				iIndex = 14;

  01838	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH

; 3005 : 				break;

  0183d	e9 dd fe ff ff	 jmp	 $L71976
$L71971:

; 3006 : 
; 3007 : 	  		case 'd':
; 3008 : 	  		case 'D':
; 3009 : 				iIndex = 15;

  01842	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH

; 3010 : 				break;

  01847	e9 d3 fe ff ff	 jmp	 $L71976
$L71972:

; 3011 : 
; 3012 : 	  		default:
; 3013 : 
; 3014 : 				if  (( szSingleDigit[0] == '-' )
; 3015 : 	  			|| ( szSingleDigit[0] == ',' )
; 3016 : 	  			|| ( szSingleDigit[0] == ' ' ))

  0184c	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  0184f	74 0a		 je	 SHORT $L71974
  01851	80 f9 2c	 cmp	 cl, 44			; 0000002cH
  01854	74 05		 je	 SHORT $L71974
  01856	80 f9 20	 cmp	 cl, 32			; 00000020H
  01859	75 3c		 jne	 SHORT $L71973
$L71974:

; 3023 : 				}
; 3024 : 
; 3025 : 			break;
; 3026 : 	  } /* switch ( szSingleDigit[0] ) */
; 3027 : 
; 3028 : 	/******************************************************************/
; 3029 : 	/*  If the index == 16 then send a tone packet with a duration of */
; 3030 : 	/*  DTMF_PAUSE_TIME_IN_MSEC and both tone amplitudes set to zero. */
; 3031 : 	/*  Otherwise send DTMF Tones with the default high tone and low  */
; 3032 : 	/*  tone amplitudes.                                              */
; 3033 : 	/*                                                                */
; 3034 : 	/*  The packet format here is different than the DTC07. The ramp  */
; 3035 : 	/*  duration has been eliminated. The tone generation software    */
; 3036 : 	/*  automatically provides 3 msec. cosine squared tapering for    */
; 3037 : 	/*  the tone pulse rise and fall time.                            */
; 3038 : 	/*                                                                */
; 3039 : 	/*  Packet Index     Packet Data                 Value            */
; 3040 : 	/*                                                                */
; 3041 : 	/*      0            Command Word              SPC_type_tone      */
; 3042 : 	/*      1            Tone Duration (msec.)     0 to ?             */
; 3043 : 	/*      2            Tone 0 Frequency          0 to Fs/2          */
; 3044 : 	/*      3            Tone 0 Amplitude          0 to 32767         */
; 3045 : 	/*      4            Tone 1 Frequency          0 to Fs/2          */
; 3046 : 	/*      5            Tone 1 Amplitude          0 to 32767         */
; 3047 : 	/*                                                                */
; 3048 : 	/******************************************************************/
; 3049 : 
; 3050 : 	if ( iIndex == 16 )
; 3051 : 	{
; 3052 : 	  /****************************************************************/
; 3053 : 	  /*  Silent interval.                                            */
; 3054 : 	  /****************************************************************/
; 3055 : 
; 3056 : 	  pipe[0] = SPC_type_tone;
; 3057 : 	  pipe[1] = DTMF_PAUSE_TIME_IN_MSEC;
; 3058 : 	  pipe[2] = 1000;
; 3059 : 	  pipe[3] = 0;

  0185b	33 c0		 xor	 eax, eax
  0185d	66 89 6c 24 14	 mov	 WORD PTR _pipe$[esp+32], bp
  01862	66 89 44 24 1a	 mov	 WORD PTR _pipe$[esp+38], ax

; 3060 : 	  pipe[4] = 1000;
; 3061 : 	  pipe[5] = 0;

  01867	66 89 44 24 1e	 mov	 WORD PTR _pipe$[esp+42], ax
  0186c	66 89 5c 24 16	 mov	 WORD PTR _pipe$[esp+34], bx
  01871	66 89 7c 24 18	 mov	 WORD PTR _pipe$[esp+36], di
  01876	66 89 7c 24 1c	 mov	 WORD PTR _pipe$[esp+40], di

; 3062 : 
; 3063 : /* GL 04/21/1997  change this for OSF build */
; 3064 : #if defined (WIN32) || defined (__osf__) || defined (__linux__)
; 3065 :       cm_util_write_pipe(pKsd_t, pKsd_t->vtm_pipe, pipe, 6 );

  0187b	8b 8e dc 00 00
	00		 mov	 ecx, DWORD PTR [esi+220]
  01881	8d 44 24 14	 lea	 eax, DWORD PTR _pipe$[esp+32]
  01885	6a 06		 push	 6
  01887	50		 push	 eax
  01888	51		 push	 ecx
  01889	56		 push	 esi
  0188a	e8 00 00 00 00	 call	 _cm_util_write_pipe
  0188f	83 c4 10	 add	 esp, 16			; 00000010H

; 3066 : #endif
; 3067 : 
; 3068 : 	}
; 3069 : 	else

  01892	e9 05 ff ff ff	 jmp	 $L71977
$L71973:
  01897	5f		 pop	 edi
  01898	5e		 pop	 esi
  01899	5d		 pop	 ebp

; 3017 : 				{
; 3018 : 	  				iIndex = 16;
; 3019 : 				}
; 3020 : 				else
; 3021 : 				{
; 3022 : 	  				return( CMD_bad_string );

  0189a	b8 01 00 00 00	 mov	 eax, 1
  0189f	5b		 pop	 ebx

; 3116 : }

  018a0	83 c4 10	 add	 esp, 16			; 00000010H
  018a3	c3		 ret	 0
$L71951:
  018a4	5f		 pop	 edi
  018a5	5e		 pop	 esi
  018a6	5d		 pop	 ebp

; 3113 :   }
; 3114 : 
; 3115 :   return( CMD_success );

  018a7	33 c0		 xor	 eax, eax
  018a9	5b		 pop	 ebx

; 3116 : }

  018aa	83 c4 10	 add	 esp, 16			; 00000010H
  018ad	c3		 ret	 0
  018ae	8b ff		 npad	 2
$L72108:
  018b0	00 00 00 00	 DD	 $L71967
  018b4	00 00 00 00	 DD	 $L71966
  018b8	00 00 00 00	 DD	 $L71956
  018bc	00 00 00 00	 DD	 $L71957
  018c0	00 00 00 00	 DD	 $L71958
  018c4	00 00 00 00	 DD	 $L71959
  018c8	00 00 00 00	 DD	 $L71960
  018cc	00 00 00 00	 DD	 $L71961
  018d0	00 00 00 00	 DD	 $L71962
  018d4	00 00 00 00	 DD	 $L71963
  018d8	00 00 00 00	 DD	 $L71964
  018dc	00 00 00 00	 DD	 $L71965
  018e0	00 00 00 00	 DD	 $L71968
  018e4	00 00 00 00	 DD	 $L71969
  018e8	00 00 00 00	 DD	 $L71970
  018ec	00 00 00 00	 DD	 $L71971
  018f0	00 00 00 00	 DD	 $L71972
$L72107:
  018f4	00		 DB	 0
  018f5	10		 DB	 16			; 00000010H
  018f6	10		 DB	 16			; 00000010H
  018f7	10		 DB	 16			; 00000010H
  018f8	10		 DB	 16			; 00000010H
  018f9	10		 DB	 16			; 00000010H
  018fa	10		 DB	 16			; 00000010H
  018fb	01		 DB	 1
  018fc	10		 DB	 16			; 00000010H
  018fd	10		 DB	 16			; 00000010H
  018fe	10		 DB	 16			; 00000010H
  018ff	10		 DB	 16			; 00000010H
  01900	10		 DB	 16			; 00000010H
  01901	02		 DB	 2
  01902	03		 DB	 3
  01903	04		 DB	 4
  01904	05		 DB	 5
  01905	06		 DB	 6
  01906	07		 DB	 7
  01907	08		 DB	 8
  01908	09		 DB	 9
  01909	0a		 DB	 10			; 0000000aH
  0190a	0b		 DB	 11			; 0000000bH
  0190b	10		 DB	 16			; 00000010H
  0190c	10		 DB	 16			; 00000010H
  0190d	10		 DB	 16			; 00000010H
  0190e	10		 DB	 16			; 00000010H
  0190f	10		 DB	 16			; 00000010H
  01910	10		 DB	 16			; 00000010H
  01911	10		 DB	 16			; 00000010H
  01912	0c		 DB	 12			; 0000000cH
  01913	0d		 DB	 13			; 0000000dH
  01914	0e		 DB	 14			; 0000000eH
  01915	0f		 DB	 15			; 0000000fH
  01916	10		 DB	 16			; 00000010H
  01917	10		 DB	 16			; 00000010H
  01918	10		 DB	 16			; 00000010H
  01919	10		 DB	 16			; 00000010H
  0191a	10		 DB	 16			; 00000010H
  0191b	10		 DB	 16			; 00000010H
  0191c	10		 DB	 16			; 00000010H
  0191d	10		 DB	 16			; 00000010H
  0191e	10		 DB	 16			; 00000010H
  0191f	10		 DB	 16			; 00000010H
  01920	10		 DB	 16			; 00000010H
  01921	10		 DB	 16			; 00000010H
  01922	10		 DB	 16			; 00000010H
  01923	10		 DB	 16			; 00000010H
  01924	10		 DB	 16			; 00000010H
  01925	10		 DB	 16			; 00000010H
  01926	10		 DB	 16			; 00000010H
  01927	10		 DB	 16			; 00000010H
  01928	10		 DB	 16			; 00000010H
  01929	10		 DB	 16			; 00000010H
  0192a	10		 DB	 16			; 00000010H
  0192b	10		 DB	 16			; 00000010H
  0192c	10		 DB	 16			; 00000010H
  0192d	10		 DB	 16			; 00000010H
  0192e	10		 DB	 16			; 00000010H
  0192f	10		 DB	 16			; 00000010H
  01930	10		 DB	 16			; 00000010H
  01931	10		 DB	 16			; 00000010H
  01932	0c		 DB	 12			; 0000000cH
  01933	0d		 DB	 13			; 0000000dH
  01934	0e		 DB	 14			; 0000000eH
  01935	0f		 DB	 15			; 0000000fH
_cm_cmd_dial ENDP
_TEXT	ENDS
PUBLIC	_cm_cmd_digitized
_TEXT	SEGMENT
_cm_cmd_digitized PROC NEAR

; 3189 : 	PKSD_T pKsd_t = phTTS->pKernelShareData; 
; 3190 : 	
; 3191 : #ifdef MSDOS
; 3192 : 	DT_PIPE_T pipe_value;
; 3193 : 
; 3194 : #ifndef DTEX
; 3195 : 	if(cm_cmd_sync(phTTS) == CMD_flushing)
; 3196 : 		return(CMD_flushing);
; 3197 : 	pKsd_t->spc_mode = SPC_mode_digital;
; 3198 : 	signal_semaphore(&pKsd_t->isa_sem);
; 3199 : 	wait_semaphore(&pKsd_t->text_sync);
; 3200 : 
; 3201 : 	pipe_value = LAST_VOICE;
; 3202 :         cm_util_write_pipe(pKsd_t,pKsd_t->lts_pipe,&pipe_value,1);
; 3203 : #endif /*DTEX*/
; 3204 : 
; 3205 : #endif /* MSDOS */
; 3206 : 	return(CMD_success);

  01940	33 c0		 xor	 eax, eax

; 3207 : }

  01942	c3		 ret	 0
_cm_cmd_digitized ENDP
_phTTS$ = 8
_cm_cmd_debug PROC NEAR

; 3224 : {

  01950	53		 push	 ebx
  01951	56		 push	 esi

; 3225 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  01952	8b 74 24 0c	 mov	 esi, DWORD PTR _phTTS$[esp+4]
  01956	57		 push	 edi

; 3226 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;
; 3227 : 
; 3228 : 	cm_cmd_sync(phTTS);				/* mfg 04/27/1998 added 2 cm_cmd_sync*/

  01957	56		 push	 esi
  01958	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0195b	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  0195e	e8 00 00 00 00	 call	 _cm_cmd_sync

; 3229 : 	pKsd_t->debug_switch = pCmd_t->params[0];

  01963	66 8b 03	 mov	 ax, WORD PTR [ebx]

; 3230 : 	cm_cmd_sync(phTTS);

  01966	56		 push	 esi
  01967	66 89 87 78 04
	00 00		 mov	 WORD PTR [edi+1144], ax
  0196e	e8 00 00 00 00	 call	 _cm_cmd_sync
  01973	83 c4 08	 add	 esp, 8

; 3231 : 
; 3232 : 	return(CMD_success);

  01976	33 c0		 xor	 eax, eax
  01978	5f		 pop	 edi
  01979	5e		 pop	 esi
  0197a	5b		 pop	 ebx

; 3233 : }

  0197b	c3		 ret	 0
_cm_cmd_debug ENDP
_phTTS$ = 8
_cm_cmd_gender PROC NEAR

; 3250 : 	int cmd_type, cmd_value;
; 3251 : 	DT_PIPE_T pipe_value[2];
; 3252 : 
; 3253 : 	PKSD_T pKsd_t = phTTS->pKernelShareData;

  01980	8b 44 24 04	 mov	 eax, DWORD PTR _phTTS$[esp-4]
  01984	56		 push	 esi
  01985	8b 70 08	 mov	 esi, DWORD PTR [eax+8]

; 3254 : 	PCMD_T pCmd_t = phTTS->pCMDThreadData;

  01988	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 3255 : 
; 3256 : 	cmd_type =  cm_util_string_match(gender_options,pCmd_t->pString[0]);

  0198b	8b 80 80 02 00
	00		 mov	 eax, DWORD PTR [eax+640]
  01991	50		 push	 eax
  01992	68 00 00 00 00	 push	 OFFSET FLAT:_gender_options
  01997	e8 00 00 00 00	 call	 _cm_util_string_match
  0199c	83 c4 08	 add	 esp, 8

; 3257 : 	if (cmd_type == NO_STRING_MATCH)

  0199f	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  019a4	75 07		 jne	 SHORT $L71995

; 3258 : 		return(CMD_bad_string);

  019a6	b8 01 00 00 00	 mov	 eax, 1
  019ab	5e		 pop	 esi

; 3279 : 	}
; 3280 : 	return(CMD_success);
; 3281 : }

  019ac	c3		 ret	 0
$L71995:

; 3259 : 
; 3260 : 	switch (cmd_type)
; 3261 : 	{

  019ad	83 e8 00	 sub	 eax, 0
  019b0	74 27		 je	 SHORT $L72000
  019b2	48		 dec	 eax
  019b3	74 17		 je	 SHORT $L72001
  019b5	48		 dec	 eax
  019b6	74 07		 je	 SHORT $L72002

; 3274 : 			return(CMD_success);
; 3275 : 			break;
; 3276 : 
; 3277 : 		default:
; 3278 : 			return(CMD_bad_string);

  019b8	b8 01 00 00 00	 mov	 eax, 1
  019bd	5e		 pop	 esi

; 3279 : 	}
; 3280 : 	return(CMD_success);
; 3281 : }

  019be	c3		 ret	 0
$L72002:

; 3269 : 			return(CMD_success);
; 3270 : 			break;
; 3271 : 
; 3272 : 		case 2: /* feminine */
; 3273 : 			pKsd_t->gender_switch = 3;

  019bf	66 c7 86 7a 04
	00 00 03 00	 mov	 WORD PTR [esi+1146], 3
  019c8	33 c0		 xor	 eax, eax
  019ca	5e		 pop	 esi

; 3279 : 	}
; 3280 : 	return(CMD_success);
; 3281 : }

  019cb	c3		 ret	 0
$L72001:

; 3265 : 			break;
; 3266 : 
; 3267 : 		case 1: /* neuter */
; 3268 : 			pKsd_t->gender_switch = 2;

  019cc	66 c7 86 7a 04
	00 00 02 00	 mov	 WORD PTR [esi+1146], 2
  019d5	33 c0		 xor	 eax, eax
  019d7	5e		 pop	 esi

; 3279 : 	}
; 3280 : 	return(CMD_success);
; 3281 : }

  019d8	c3		 ret	 0
$L72000:

; 3262 : 		case 0: /* masculine */
; 3263 : 			pKsd_t->gender_switch = 1;

  019d9	66 c7 86 7a 04
	00 00 01 00	 mov	 WORD PTR [esi+1146], 1

; 3264 : 			return(CMD_success);

  019e2	33 c0		 xor	 eax, eax
  019e4	5e		 pop	 esi

; 3279 : 	}
; 3280 : 	return(CMD_success);
; 3281 : }

  019e5	c3		 ret	 0
_cm_cmd_gender ENDP
_TEXT	ENDS
END
