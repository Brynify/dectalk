	TITLE	D:\work\product\dapi\src\Lts\lsa_adju.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_ls_adju_cluster
_TEXT	SEGMENT
_f$ = 8
_s$ = 12
_ls_adju_cluster PROC NEAR

; 67   : 	switch (f) 
; 68   : 	{

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _f$[esp-4]
  00004	83 c0 db	 add	 eax, -37		; ffffffdbH
  00007	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  0000a	0f 87 f8 00 00
	00		 ja	 $L71692
  00010	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72099[eax*4]
$L71695:

; 69   : 		case P:
; 70   : 			if (s==LL || s==R)

  00017	8b 44 24 08	 mov	 eax, DWORD PTR _s$[esp-4]

; 71   : 				return (TRYS);

  0001b	eb 63		 jmp	 SHORT $L72098
$L71698:

; 72   : 			break;
; 73   : 	
; 74   : 		case B:
; 75   : 			if (s==LL || s==R)

  0001d	8b 44 24 08	 mov	 eax, DWORD PTR _s$[esp-4]

; 76   : 				return (OK);

  00021	eb 76		 jmp	 SHORT $L72097
$L71701:

; 77   : 			break;
; 78   : 
; 79   : 		case F:
; 80   : 			if (s ==R)

  00023	8b 44 24 08	 mov	 eax, DWORD PTR _s$[esp-4]
  00027	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  0002a	75 06		 jne	 SHORT $L71702

; 81   : 				return (TRYS);

  0002c	b8 02 00 00 00	 mov	 eax, 2

; 121  : } 

  00031	c3		 ret	 0
$L71702:

; 82   : 			if (s ==LL)

  00032	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  00035	0f 85 cd 00 00
	00		 jne	 $L71692

; 83   : 				return (OK);

  0003b	b8 01 00 00 00	 mov	 eax, 1

; 121  : } 

  00040	c3		 ret	 0
$L71704:

; 84   : 			break;
; 85   : 	
; 86   : 		case T:
; 87   : 			if (s ==R)

  00041	8b 44 24 08	 mov	 eax, DWORD PTR _s$[esp-4]
  00045	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  00048	75 06		 jne	 SHORT $L71705

; 88   : 				return (TRYS);

  0004a	b8 02 00 00 00	 mov	 eax, 2

; 121  : } 

  0004f	c3		 ret	 0
$L71705:

; 89   : 			if (s ==W)

  00050	83 f8 18	 cmp	 eax, 24			; 00000018H
  00053	0f 85 af 00 00
	00		 jne	 $L71692

; 90   : 				return (OK);

  00059	b8 01 00 00 00	 mov	 eax, 1

; 121  : } 

  0005e	c3		 ret	 0
$L71707:

; 91   : 			break;
; 92   : 
; 93   : 		case D:
; 94   : 		case TH:
; 95   : 			if (s==W || s==R)

  0005f	8b 44 24 08	 mov	 eax, DWORD PTR _s$[esp-4]
  00063	83 f8 18	 cmp	 eax, 24			; 00000018H
  00066	74 3b		 je	 SHORT $L71709
  00068	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  0006b	0f 85 97 00 00
	00		 jne	 $L71692

; 96   : 				return (OK);

  00071	b8 01 00 00 00	 mov	 eax, 1

; 121  : } 

  00076	c3		 ret	 0
$L71710:

; 97   : 			break;
; 98   : 	
; 99   : 		case K:
; 100  : 			if (s==W || s==LL || s==R)

  00077	8b 44 24 08	 mov	 eax, DWORD PTR _s$[esp-4]
  0007b	83 f8 18	 cmp	 eax, 24			; 00000018H
  0007e	74 0a		 je	 SHORT $L71697
$L72098:
  00080	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  00083	74 05		 je	 SHORT $L71697
  00085	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  00088	75 7e		 jne	 SHORT $L71692
$L71697:

; 101  : 				return (TRYS);

  0008a	b8 02 00 00 00	 mov	 eax, 2

; 121  : } 

  0008f	c3		 ret	 0
$L71713:

; 102  : 			break;
; 103  : 	
; 104  : 		case G:
; 105  : 			if (s==W || s==LL || s==R)

  00090	8b 44 24 08	 mov	 eax, DWORD PTR _s$[esp-4]
  00094	83 f8 18	 cmp	 eax, 24			; 00000018H
  00097	74 0a		 je	 SHORT $L71709
$L72097:
  00099	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  0009c	74 05		 je	 SHORT $L71709
  0009e	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  000a1	75 65		 jne	 SHORT $L71692
$L71709:

; 106  : 				return (OK);

  000a3	b8 01 00 00 00	 mov	 eax, 1

; 121  : } 

  000a8	c3		 ret	 0
$L71716:

; 107  : 			break;
; 108  : 	
; 109  : 		case S:
; 110  : 			if (s==W || s==LL || s==P || s==T || s==K
; 111  : 			||  s==M || s==N  || s==F)

  000a9	8b 44 24 08	 mov	 eax, DWORD PTR _s$[esp-4]
  000ad	83 f8 18	 cmp	 eax, 24			; 00000018H
  000b0	74 23		 je	 SHORT $L71718
  000b2	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  000b5	74 1e		 je	 SHORT $L71718
  000b7	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  000ba	74 19		 je	 SHORT $L71718
  000bc	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  000bf	74 14		 je	 SHORT $L71718
  000c1	83 f8 31	 cmp	 eax, 49			; 00000031H
  000c4	74 0f		 je	 SHORT $L71718
  000c6	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000c9	74 0a		 je	 SHORT $L71718
  000cb	83 f8 20	 cmp	 eax, 32			; 00000020H
  000ce	74 05		 je	 SHORT $L71718
  000d0	83 f8 25	 cmp	 eax, 37			; 00000025H
  000d3	75 33		 jne	 SHORT $L71692
$L71718:

; 112  : 				return (OK);

  000d5	b8 01 00 00 00	 mov	 eax, 1

; 121  : } 

  000da	c3		 ret	 0
$L71719:

; 113  : 			break;
; 114  : 
; 115  : 		case SH:
; 116  : 			if (s==W || s==LL || s==R || s==P || s==T
; 117  : 			||  s==M || s==N)

  000db	8b 44 24 08	 mov	 eax, DWORD PTR _s$[esp-4]
  000df	83 f8 18	 cmp	 eax, 24			; 00000018H
  000e2	74 1e		 je	 SHORT $L71721
  000e4	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  000e7	74 19		 je	 SHORT $L71721
  000e9	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  000ec	74 14		 je	 SHORT $L71721
  000ee	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  000f1	74 0f		 je	 SHORT $L71721
  000f3	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  000f6	74 0a		 je	 SHORT $L71721
  000f8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000fb	74 05		 je	 SHORT $L71721
  000fd	83 f8 20	 cmp	 eax, 32			; 00000020H
  00100	75 06		 jne	 SHORT $L71692
$L71721:

; 118  : 				return (OK);

  00102	b8 01 00 00 00	 mov	 eax, 1

; 121  : } 

  00107	c3		 ret	 0
$L71692:

; 119  : 	} /* 	switch (f) */
; 120  : 	return (ILLEGAL);

  00108	33 c0		 xor	 eax, eax

; 121  : } 

  0010a	c3		 ret	 0
  0010b	90		 npad	 1
$L72099:
  0010c	00 00 00 00	 DD	 $L71701
  00110	00 00 00 00	 DD	 $L71692
  00114	00 00 00 00	 DD	 $L71707
  00118	00 00 00 00	 DD	 $L71692
  0011c	00 00 00 00	 DD	 $L71716
  00120	00 00 00 00	 DD	 $L71692
  00124	00 00 00 00	 DD	 $L71719
  00128	00 00 00 00	 DD	 $L71692
  0012c	00 00 00 00	 DD	 $L71695
  00130	00 00 00 00	 DD	 $L71698
  00134	00 00 00 00	 DD	 $L71704
  00138	00 00 00 00	 DD	 $L71707
  0013c	00 00 00 00	 DD	 $L71710
  00140	00 00 00 00	 DD	 $L71713
_ls_adju_cluster ENDP
_TEXT	ENDS
PUBLIC	_ls_adju_is_voc
PUBLIC	_ls_adju_is_obs
PUBLIC	_ls_adju_ins_phone
PUBLIC	_ls_adju_allo2
PUBLIC	_ls_adju_del_phone
_TEXT	SEGMENT
_pLts_t$ = 8
_sleft$ = -4
_sthis$ = 8
_ls_adju_allo2 PROC NEAR

; 146  : {

  00150	51		 push	 ecx
  00151	53		 push	 ebx
  00152	55		 push	 ebp

; 147  : 	 PHONE	*pp1;
; 148  : 	 PHONE	*pp2;
; 149  : 	 PHONE	*pp3;
; 150  : 	 PHONE	*pp4;
; 151  : 	 int	ph1;
; 152  : 	 int	sleft;
; 153  : 	 int	sthis;
; 154  : 	 int	fthis;
; 155  : 
; 156  : 	/*
; 157  : 	 * Sweep the phoneme string
; 158  : 	 * left to right, performing the vowel
; 159  : 	 * reductions. This has to be done in a
; 160  : 	 * prepass, to make sure all IX or
; 161  : 	 * AX vowels are correct before the main
; 162  : 	 * body of the allophonic rules are
; 163  : 	 * run. The "bflag" conditionally blocks
; 164  : 	 * this pass on VMS.
; 165  : 	 */
; 166  : #if defined	(VMS) || defined (LDS_BUILD)
; 167  : 	if (bflag == FALSE) 
; 168  : 	{
; 169  : #endif
; 170  : 
; 171  : 	sthis = SNONE;
; 172  : 	fthis = 0;
; 173  : 	pp1 = pLts_t->phead.p_fp;

  00153	8b 6c 24 10	 mov	 ebp, DWORD PTR _pLts_t$[esp+8]
  00157	56		 push	 esi
  00158	57		 push	 edi
  00159	33 f6		 xor	 esi, esi
  0015b	8b 85 c8 08 00
	00		 mov	 eax, DWORD PTR [ebp+2248]
  00161	8d bd c8 08 00
	00		 lea	 edi, DWORD PTR [ebp+2248]
  00167	33 db		 xor	 ebx, ebx

; 174  : 
; 175  : 	while (pp1 != &pLts_t->phead) 

  00169	3b c7		 cmp	 eax, edi
  0016b	ba 79 00 00 00	 mov	 edx, 121		; 00000079H
  00170	74 2a		 je	 SHORT $L71735
$L71734:

; 176  : 	{
; 177  : 		if ((pp1->p_flag&PFSYLAB) != 0) 

  00172	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00175	f6 c1 10	 test	 cl, 16			; 00000010H
  00178	74 05		 je	 SHORT $L71736

; 178  : 		{
; 179  : 			sthis = pp1->p_stress;

  0017a	8b 50 10	 mov	 edx, DWORD PTR [eax+16]

; 180  : 			fthis = pp1->p_flag;

  0017d	8b d9		 mov	 ebx, ecx
$L71736:

; 181  : 		}
; 182  : 		if ((fthis&PFBLOCK) == 0
; 183  : 		&& (pp1->p_uphone!=SIL && sthis==SUN)) 

  0017f	f6 c3 80	 test	 bl, -128		; ffffff80H
  00182	75 12		 jne	 SHORT $L71737
  00184	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00187	3b ce		 cmp	 ecx, esi
  00189	74 0b		 je	 SHORT $L71737
  0018b	83 fa 7a	 cmp	 edx, 122		; 0000007aH
  0018e	75 06		 jne	 SHORT $L71737

; 184  : 		{
; 185  : 
; 186  : 			pp1->p_sphone = pp1->p_uphone;

  00190	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 187  : 			pp1->p_uphone = SIL;

  00193	89 70 18	 mov	 DWORD PTR [eax+24], esi
$L71737:

; 188  : 		} 
; 189  : 		pp1 = pp1->p_fp;

  00196	8b 00		 mov	 eax, DWORD PTR [eax]
  00198	3b c7		 cmp	 eax, edi
  0019a	75 d6		 jne	 SHORT $L71734
$L71735:

; 190  : 	}
; 191  : 
; 192  : #if defined	(VMS) || defined (LDS_BUILD)
; 193  : 	}
; 194  : #endif
; 195  : 	/*
; 196  : 	 * Main allophonic sweep.
; 197  : 	 */
; 198  : 
; 199  : 	pp1 = pLts_t->phead.p_fp;
; 200  : 
; 201  : 	pLts_t->phead.p_sphone = SIL;			/* Make this look like	*/

  0019c	89 b5 dc 08 00
	00		 mov	 DWORD PTR [ebp+2268], esi

; 202  : 	pLts_t->phead.p_uphone = SIL;			/* silence, morpheme	*/

  001a2	89 b5 e0 08 00
	00		 mov	 DWORD PTR [ebp+2272], esi

; 203  : 	pLts_t->phead.p_flag = PFMORPH;			/* boundry.		*/
; 204  : 	sthis = SNONE;
; 205  : 	sleft = SNONE;
; 206  : 	pp1 = pLts_t->phead.p_fp;

  001a8	8b 37		 mov	 esi, DWORD PTR [edi]
  001aa	bb 0f 00 00 00	 mov	 ebx, 15			; 0000000fH
  001af	b8 79 00 00 00	 mov	 eax, 121		; 00000079H

; 207  : 	while (pp1 != &pLts_t->phead) 

  001b4	3b f7		 cmp	 esi, edi
  001b6	89 9d d4 08 00
	00		 mov	 DWORD PTR [ebp+2260], ebx
  001bc	89 44 24 18	 mov	 DWORD PTR _sthis$[esp+16], eax
  001c0	89 44 24 10	 mov	 DWORD PTR _sleft$[esp+20], eax
  001c4	0f 84 65 03 00
	00		 je	 $L72103
  001ca	eb 04		 jmp	 SHORT $L71739
$L72113:
  001cc	8b 44 24 18	 mov	 eax, DWORD PTR _sthis$[esp+16]
$L71739:

; 208  : 	{
; 209  : 		ph1 = pp1->p_sphone;
; 210  : 		if ((pp1->p_flag&PFSYLAB) != 0) 

  001d0	8a 4e 0c	 mov	 cl, BYTE PTR [esi+12]
  001d3	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  001d6	f6 c1 10	 test	 cl, 16			; 00000010H
  001d9	74 0b		 je	 SHORT $L71741

; 211  : 		{
; 212  : 			sleft = sthis;

  001db	89 44 24 10	 mov	 DWORD PTR _sleft$[esp+20], eax

; 213  : 			sthis = pp1->p_stress;

  001df	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  001e2	89 44 24 18	 mov	 DWORD PTR _sthis$[esp+16], eax
$L71741:

; 214  : 		}
; 215  : 		/*
; 216  : 		 * [x][l] => [L] / - +, [-Stress]
; 217  : 		 * [|][l] => [L] / - +, [-Stress]
; 218  : 		 */
; 219  : 		if (sthis==SUN && (ph1==AX || ph1==IX)) 

  001e6	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  001e9	75 35		 jne	 SHORT $L72109
  001eb	83 ff 11	 cmp	 edi, 17			; 00000011H
  001ee	74 05		 je	 SHORT $L71743
  001f0	83 ff 12	 cmp	 edi, 18			; 00000012H
  001f3	75 64		 jne	 SHORT $L71745
$L71743:

; 220  : 		{
; 221  : 			pp2 = pp1->p_fp;

  001f5	8b 06		 mov	 eax, DWORD PTR [esi]

; 222  : 			if (pp2->p_sphone == LL
; 223  : 			&& (pp2->p_flag&PFSYLAB) == 0
; 224  : 			&& (pp2->p_fp->p_flag&PFMORPH) != 0) 

  001f7	83 78 14 1b	 cmp	 DWORD PTR [eax+20], 27	; 0000001bH
  001fb	75 5c		 jne	 SHORT $L71745
  001fd	f6 40 0c 10	 test	 BYTE PTR [eax+12], 16	; 00000010H
  00201	75 56		 jne	 SHORT $L71745
  00203	8b 10		 mov	 edx, DWORD PTR [eax]
  00205	84 5a 0c	 test	 BYTE PTR [edx+12], bl
  00208	74 4f		 je	 SHORT $L71745

; 225  : 			{
; 226  : 				ls_adju_del_phone(pLts_t,pp2);

  0020a	50		 push	 eax
  0020b	55		 push	 ebp
  0020c	e8 00 00 00 00	 call	 _ls_adju_del_phone
  00211	83 c4 08	 add	 esp, 8

; 227  : 				pp1->p_sphone = EL;

  00214	c7 46 14 22 00
	00 00		 mov	 DWORD PTR [esi+20], 34	; 00000022H

; 228  : 				pp1 = pp1->p_fp;
; 229  : 				continue;

  0021b	e9 ff 02 00 00	 jmp	 $L71747
$L72109:

; 230  : 			}
; 231  : 		}
; 232  : 
; 233  : 		/*
; 234  : 		 * [l] => [L] / [+Obs] - +, [-Stress]
; 235  : 		 * [r] => [R] / [+Obs] - +, [-Stress]
; 236  : 		 */
; 237  : 
; 238  : 		if (sthis != SUN
; 239  : 		&& (ph1==LL || ph1==R)
; 240  : 		&& ls_adju_is_obs(pp1->p_bp) != FALSE
; 241  : 		&& (pp1->p_fp->p_flag&PFMORPH) != 0) 

  00220	83 ff 1b	 cmp	 edi, 27			; 0000001bH
  00223	74 05		 je	 SHORT $L71746
  00225	83 ff 1a	 cmp	 edi, 26			; 0000001aH
  00228	75 2f		 jne	 SHORT $L71745
$L71746:
  0022a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0022d	50		 push	 eax
  0022e	e8 00 00 00 00	 call	 _ls_adju_is_obs
  00233	83 c4 04	 add	 esp, 4
  00236	85 c0		 test	 eax, eax
  00238	74 1f		 je	 SHORT $L71745
  0023a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0023c	84 59 0c	 test	 BYTE PTR [ecx+12], bl
  0023f	74 18		 je	 SHORT $L71745

; 242  : 		{
; 243  : 			pp1->p_sphone = RR;
; 244  : 			if (ph1 == LL)

  00241	83 ff 1b	 cmp	 edi, 27			; 0000001bH
  00244	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00247	0f 85 d2 02 00
	00		 jne	 $L71747

; 245  : 				pp1->p_sphone = EL;

  0024d	c7 46 14 22 00
	00 00		 mov	 DWORD PTR [esi+20], 34	; 00000022H

; 246  : 			pp1 = pp1->p_fp;
; 247  : 			continue;

  00254	e9 c6 02 00 00	 jmp	 $L71747
$L71745:

; 248  : 		}
; 249  : 		/*
; 250  : 		 * [x][r] => [R]		(urge)
; 251  : 		 * [x][r][r] => [R]		(berry)
; 252  : 		 * [x][=][r] => [x][=][r]	(around)
; 253  : 		 * [x][r][=][r] => [x][=][r]	(arrange)
; 254  : 		 */
; 255  : 		if (ph1 == AX
; 256  : 		&& (pp2=pp1->p_fp)->p_sphone == R
; 257  : 		&& (pp2->p_flag&PFSYLAB) == 0)

  00259	83 ff 11	 cmp	 edi, 17			; 00000011H
  0025c	75 44		 jne	 SHORT $L71748
  0025e	8b 06		 mov	 eax, DWORD PTR [esi]
  00260	83 78 14 1a	 cmp	 DWORD PTR [eax+20], 26	; 0000001aH
  00264	0f 85 b5 02 00
	00		 jne	 $L71747
  0026a	f6 40 0c 10	 test	 BYTE PTR [eax+12], 16	; 00000010H
  0026e	0f 85 ab 02 00
	00		 jne	 $L71747

; 258  : 		{
; 259  : 			ls_adju_del_phone(pLts_t,pp2);

  00274	50		 push	 eax
  00275	55		 push	 ebp
  00276	e8 00 00 00 00	 call	 _ls_adju_del_phone

; 260  : 			if ((pp2=pp1->p_fp)->p_sphone == R)

  0027b	8b 06		 mov	 eax, DWORD PTR [esi]
  0027d	83 c4 08	 add	 esp, 8
  00280	83 78 14 1a	 cmp	 DWORD PTR [eax+20], 26	; 0000001aH
  00284	75 14		 jne	 SHORT $L71749

; 261  : 			{
; 262  : 				if ((pp2->p_flag&PFSYLAB) == 0)

  00286	f6 40 0c 10	 test	 BYTE PTR [eax+12], 16	; 00000010H
  0028a	0f 85 8f 02 00
	00		 jne	 $L71747

; 263  : 				{
; 264  : 					ls_adju_del_phone(pLts_t,pp2);

  00290	50		 push	 eax
  00291	55		 push	 ebp
  00292	e8 00 00 00 00	 call	 _ls_adju_del_phone
  00297	83 c4 08	 add	 esp, 8
$L71749:

; 265  : 					pp1->p_sphone = RR;
; 266  : 				}
; 267  : 
; 268  : 			} 
; 269  : 			else
; 270  : 			{
; 271  : 				pp1->p_sphone = RR;

  0029a	89 5e 14	 mov	 DWORD PTR [esi+20], ebx

; 272  : 			}
; 273  : 				pp1 = pp1->p_fp;
; 274  : 				continue;

  0029d	e9 7d 02 00 00	 jmp	 $L71747
$L71748:

; 275  : 		}
; 276  : 
; 277  : 		/*
; 278  : 		 * [n] => [n][y] / - [u][L] +
; 279  : 		 */
; 280  : 		/* 06 Hack.						*/
; 281  : 		if (ph1 == N) 

  002a2	83 ff 20	 cmp	 edi, 32			; 00000020H
  002a5	75 5d		 jne	 SHORT $L71757

; 282  : 		{
; 283  : 		 	if ((pp2=pp1->p_fp)->p_sphone == UW) 

  002a7	8b 3e		 mov	 edi, DWORD PTR [esi]
  002a9	83 7f 14 0e	 cmp	 DWORD PTR [edi+20], 14	; 0000000eH
  002ad	75 2e		 jne	 SHORT $L72111

; 284  : 		 	{
; 285  : 		  		if ((pp3=pp2->p_fp)->p_sphone == EL) 

  002af	8b 07		 mov	 eax, DWORD PTR [edi]
  002b1	83 78 14 22	 cmp	 DWORD PTR [eax+20], 34	; 00000022H
  002b5	75 26		 jne	 SHORT $L72111

; 286  : 		  		{
; 287  : 		   			if ((pp3->p_fp->p_flag&PFMORPH) != 0) 

  002b7	8b 10		 mov	 edx, DWORD PTR [eax]
  002b9	84 5a 0c	 test	 BYTE PTR [edx+12], bl
  002bc	74 1f		 je	 SHORT $L72111

; 288  : 		   			{
; 289  : 						if (ls_adju_ins_phone(pLts_t,pp2, Y, SIL, SNONE) == FALSE)

  002be	6a 79		 push	 121			; 00000079H
  002c0	6a 00		 push	 0
  002c2	6a 19		 push	 25			; 00000019H
  002c4	57		 push	 edi
  002c5	55		 push	 ebp
  002c6	e8 00 00 00 00	 call	 _ls_adju_ins_phone
  002cb	83 c4 14	 add	 esp, 20			; 00000014H
  002ce	85 c0		 test	 eax, eax
  002d0	0f 84 59 02 00
	00		 je	 $L72103

; 290  : 							return;
; 291  : 						pp1 = pp2;

  002d6	8b f7		 mov	 esi, edi

; 292  : 						continue;

  002d8	e9 44 02 00 00	 jmp	 $L72108
$L72111:

; 293  : 		   			}
; 294  : 		  		}
; 295  : 		 	}
; 296  : 		}
; 297  : 		/*
; 298  : 		 * [n] => [G] / - {[k],[g]}
; 299  : 		 */
; 300  : 		if (ph1 == N
; 301  : 		&& ((pp2=pp1->p_fp)->p_sphone==K || pp2->p_sphone==G)
; 302  : 		&& (pp2->p_flag&PFSYLAB) == 0) 

  002dd	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  002e0	83 f8 31	 cmp	 eax, 49			; 00000031H
  002e3	74 09		 je	 SHORT $L71758
  002e5	83 f8 32	 cmp	 eax, 50			; 00000032H
  002e8	0f 85 31 02 00
	00		 jne	 $L71747
$L71758:
  002ee	f6 47 0c 10	 test	 BYTE PTR [edi+12], 16	; 00000010H
  002f2	0f 85 27 02 00
	00		 jne	 $L71747

; 303  : 		{
; 304  : 			pp1->p_sphone = NX;

  002f8	c7 46 14 21 00
	00 00		 mov	 DWORD PTR [esi+20], 33	; 00000021H

; 305  : 			pp1 = pp1->p_fp;
; 306  : 			continue;	

  002ff	e9 1b 02 00 00	 jmp	 $L71747
$L71757:

; 307  : 		}
; 308  : 		/*
; 309  : 		 * More palatalization.
; 310  : 		 * [g] => [J] / - [|][z][x][m] +
; 311  : 		 *	      / - [A][z] +
; 312  : 		 *	      / - [|][s][t] +
; 313  : 		 *	      / - [|][d] +
; 314  : 		 * [k] => [s] / - [|][z][x][m] +
; 315  : 		 *	      / - [A][z] +
; 316  : 		 *	      / - [|][s][t] +
; 317  : 		 *	      / - [|][d] +
; 318  : 		 */
; 319  : 		if (ph1==G || ph1==K) 

  00304	83 ff 32	 cmp	 edi, 50			; 00000032H
  00307	74 31		 je	 SHORT $L72112
  00309	83 ff 31	 cmp	 edi, 49			; 00000031H
  0030c	0f 85 8d 00 00
	00		 jne	 $L71773

; 324  : 				ph1 = S;

  00312	bf 29 00 00 00	 mov	 edi, 41			; 00000029H
$L71762:

; 325  : 			pp2 = pp1->p_fp;

  00317	8b 06		 mov	 eax, DWORD PTR [esi]

; 326  : 			if (pp2->p_sphone == AY
; 327  : 			&& (pp2=pp2->p_fp)->p_sphone == Z
; 328  : 			&& (pp2->p_fp->p_flag&PFMORPH) != 0) 

  00319	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0031c	83 f9 07	 cmp	 ecx, 7
  0031f	75 20		 jne	 SHORT $L71763
  00321	8b 00		 mov	 eax, DWORD PTR [eax]
  00323	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00326	83 f9 2a	 cmp	 ecx, 42			; 0000002aH
  00329	75 16		 jne	 SHORT $L71763
  0032b	8b 10		 mov	 edx, DWORD PTR [eax]
  0032d	84 5a 0c	 test	 BYTE PTR [edx+12], bl
  00330	74 0f		 je	 SHORT $L71763

; 329  : 			{
; 330  : 				pp1->p_sphone = ph1;

  00332	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 331  : 				pp1 = pp1->p_fp;
; 332  : 				continue;

  00335	e9 e5 01 00 00	 jmp	 $L71747
$L72112:

; 320  : 		{
; 321  : 			if (ph1 == G)		/* [g] => [J]		*/
; 322  : 				ph1 = JH;

  0033a	bf 37 00 00 00	 mov	 edi, 55			; 00000037H

; 323  : 			else				/* [k] => [s]		*/

  0033f	eb d6		 jmp	 SHORT $L71762
$L71763:

; 333  : 			} /*if (pp2->p_sphone == AY */
; 334  : 			else
; 335  : 			{ 
; 336  : 				if (pp2->p_sphone == IX) 

  00341	83 f9 12	 cmp	 ecx, 18			; 00000012H
  00344	75 59		 jne	 SHORT $L71773

; 337  : 				{
; 338  : 					pp2 = pp2->p_fp;

  00346	8b 00		 mov	 eax, DWORD PTR [eax]

; 339  : 					if (pp2->p_sphone == D
; 340  : 					&& (pp2->p_fp->p_flag&PFMORPH) != 0) 

  00348	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0034b	83 fa 30	 cmp	 edx, 48			; 00000030H
  0034e	75 0f		 jne	 SHORT $L71766
  00350	8b 08		 mov	 ecx, DWORD PTR [eax]
  00352	84 59 0c	 test	 BYTE PTR [ecx+12], bl
  00355	74 08		 je	 SHORT $L71766

; 341  : 					{
; 342  : 						pp1->p_sphone = ph1;

  00357	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 343  : 						pp1 = pp1->p_fp;
; 344  : 						continue;

  0035a	e9 c0 01 00 00	 jmp	 $L71747
$L71766:

; 345  : 					}
; 346  : 					/* 06 Hack.				*/
; 347  : 					if (pp2->p_sphone == Z) {

  0035f	83 fa 2a	 cmp	 edx, 42			; 0000002aH
  00362	75 1f		 jne	 SHORT $L71770

; 348  : 				 		if ((pp3=pp2->p_fp)->p_sphone == AX) 

  00364	8b 08		 mov	 ecx, DWORD PTR [eax]
  00366	83 79 14 11	 cmp	 DWORD PTR [ecx+20], 17	; 00000011H
  0036a	75 17		 jne	 SHORT $L71770

; 349  : 				 		{
; 350  : 				  			if ((pp3=pp3->p_fp)->p_sphone == M) 

  0036c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0036e	83 79 14 1f	 cmp	 DWORD PTR [ecx+20], 31	; 0000001fH
  00372	75 0f		 jne	 SHORT $L71770

; 351  : 				  			{
; 352  : 				   				if ((pp3->p_fp->p_flag&PFMORPH) != 0) 

  00374	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00376	84 59 0c	 test	 BYTE PTR [ecx+12], bl
  00379	74 08		 je	 SHORT $L71770

; 353  : 				   				{
; 354  : 									pp1->p_sphone = ph1;

  0037b	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 355  : 									pp1 = pp1->p_fp;
; 356  : 									continue;

  0037e	e9 9c 01 00 00	 jmp	 $L71747
$L71770:

; 357  : 				   				}
; 358  : 				  			}
; 359  : 				 		}
; 360  : 					}
; 361  : 					/* 06 Hack.				*/
; 362  : 					if (pp2->p_sphone == S) 

  00383	83 fa 29	 cmp	 edx, 41			; 00000029H
  00386	75 17		 jne	 SHORT $L71773

; 363  : 					{
; 364  : 				 		if ((pp3=pp2->p_fp)->p_sphone == T) 

  00388	8b 00		 mov	 eax, DWORD PTR [eax]
  0038a	83 78 14 2f	 cmp	 DWORD PTR [eax+20], 47	; 0000002fH
  0038e	75 0f		 jne	 SHORT $L71773

; 365  : 				 		{
; 366  : 				  			if ((pp3->p_fp->p_flag&PFMORPH) != 0) 

  00390	8b 10		 mov	 edx, DWORD PTR [eax]
  00392	84 5a 0c	 test	 BYTE PTR [edx+12], bl
  00395	74 08		 je	 SHORT $L71773

; 367  : 				  			{
; 368  : 								pp1->p_sphone = ph1;

  00397	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 369  : 								pp1 = pp1->p_fp;
; 370  : 								continue;

  0039a	e9 80 01 00 00	 jmp	 $L71747
$L71773:

; 371  : 				  			}
; 372  : 				 		}
; 373  : 					}
; 374  : 				}		/*	if (pp2->p_sphone == IX)  */
; 375  : 			}/* if (pp2->p_sphone == AY */
; 376  : 		}/* 		if (ph1==G || ph1==K) */
; 377  : 		/*
; 378  : 		 * D rules.
; 379  : 		 */
; 380  : 		if (ph1 == D) 

  0039f	83 ff 30	 cmp	 edi, 48			; 00000030H
  003a2	75 36		 jne	 SHORT $L71775

; 381  : 		{
; 382  : 			/*
; 383  : 			 * [d] => [J] / - [u][l] +
; 384  : 			 * [d] => [J] / - [u][L] +
; 385  : 			 */
; 386  : 			if ((pp2=pp1->p_fp)->p_sphone == UW
; 387  : 			&& ((pp2=pp2->p_fp)->p_sphone == LL
; 388  : 			|| pp2->p_sphone == EL)
; 389  : 			&& (pp2->p_fp->p_flag&PFMORPH) != 0) 

  003a4	8b 06		 mov	 eax, DWORD PTR [esi]
  003a6	83 78 14 0e	 cmp	 DWORD PTR [eax+20], 14	; 0000000eH
  003aa	0f 85 6f 01 00
	00		 jne	 $L71747
  003b0	8b 08		 mov	 ecx, DWORD PTR [eax]
  003b2	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  003b5	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  003b8	74 09		 je	 SHORT $L71776
  003ba	83 f8 22	 cmp	 eax, 34			; 00000022H
  003bd	0f 85 5c 01 00
	00		 jne	 $L71747
$L71776:
  003c3	8b 01		 mov	 eax, DWORD PTR [ecx]
  003c5	84 58 0c	 test	 BYTE PTR [eax+12], bl
  003c8	0f 84 51 01 00
	00		 je	 $L71747

; 390  : 			{
; 391  : 				pp1->p_sphone = JH;

  003ce	c7 46 14 37 00
	00 00		 mov	 DWORD PTR [esi+20], 55	; 00000037H

; 392  : 				pp1 = pp1->p_fp;
; 393  : 				continue;

  003d5	e9 45 01 00 00	 jmp	 $L71747
$L71775:

; 394  : 			}
; 395  : 		}
; 396  : 		/*
; 397  : 		 * S rules.
; 398  : 		 */
; 399  : 		if (ph1 == S) 

  003da	83 ff 29	 cmp	 edi, 41			; 00000029H
  003dd	0f 85 8f 00 00
	00		 jne	 $L71786

; 400  : 		{
; 401  : 			/*
; 402  : 			 * [k][s] => [g][z] / [|] - [+Voc,+Stress]
; 403  : 			 */
; 404  : 			if ((pp2=pp1->p_bp)->p_sphone == K
; 405  : 			&& pp2->p_bp->p_sphone == IX
; 406  : 			&& sleft == SUN
; 407  : 			&& ls_adju_is_voc(pp1->p_fp) != FALSE
; 408  : 			&& sthis != SUN) 

  003e3	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  003e6	83 7f 14 31	 cmp	 DWORD PTR [edi+20], 49	; 00000031H
  003ea	75 39		 jne	 SHORT $L71778
  003ec	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  003ef	83 79 14 12	 cmp	 DWORD PTR [ecx+20], 18	; 00000012H
  003f3	75 30		 jne	 SHORT $L71778
  003f5	83 7c 24 10 7a	 cmp	 DWORD PTR _sleft$[esp+20], 122 ; 0000007aH
  003fa	75 29		 jne	 SHORT $L71778
  003fc	8b 16		 mov	 edx, DWORD PTR [esi]
  003fe	52		 push	 edx
  003ff	e8 00 00 00 00	 call	 _ls_adju_is_voc
  00404	83 c4 04	 add	 esp, 4
  00407	85 c0		 test	 eax, eax
  00409	74 1a		 je	 SHORT $L71778
  0040b	83 7c 24 18 7a	 cmp	 DWORD PTR _sthis$[esp+16], 122 ; 0000007aH
  00410	74 13		 je	 SHORT $L71778

; 409  : 			{
; 410  : 				pp2->p_sphone = G;

  00412	c7 47 14 32 00
	00 00		 mov	 DWORD PTR [edi+20], 50	; 00000032H

; 411  : 				pp1->p_sphone = Z;

  00419	c7 46 14 2a 00
	00 00		 mov	 DWORD PTR [esi+20], 42	; 0000002aH

; 412  : 				continue;

  00420	e9 fc 00 00 00	 jmp	 $L72108
$L71778:

; 413  : 			}
; 414  : 			/*
; 415  : 			 * [s][s] => [S] / - [u] +
; 416  : 			 */
; 417  : 			/* 06 Hack.					*/
; 418  : 			if ((pp2=pp1->p_bp)->p_sphone == S) 

  00425	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00428	83 78 14 29	 cmp	 DWORD PTR [eax+20], 41	; 00000029H
  0042c	75 13		 jne	 SHORT $L71781

; 419  : 			{
; 420  : 			 	if ((pp3=pp1->p_fp)->p_sphone == UW) 

  0042e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00430	83 79 14 0e	 cmp	 DWORD PTR [ecx+20], 14	; 0000000eH
  00434	75 0b		 jne	 SHORT $L71781

; 421  : 			 	{
; 422  : 			  		if ((pp3->p_fp->p_flag&PFMORPH) != 0) 

  00436	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00438	84 59 0c	 test	 BYTE PTR [ecx+12], bl

; 423  : 			  		{
; 424  : 						if ((pp2->p_flag&PFSYLAB) != 0)
; 425  : 							return;
; 426  : 						ls_adju_del_phone(pLts_t,pp2);
; 427  : 						pp1->p_sphone = SH;
; 428  : 						pp1 = pp1->p_fp;
; 429  : 						continue;

  0043b	0f 85 aa 00 00
	00		 jne	 $L72114
$L71781:

; 430  : 			  		}
; 431  : 			 	}
; 432  : 			}
; 433  : 			/*
; 434  : 			 * [s][i] => [S] / - [x][s] +
; 435  : 			 */
; 436  : 			/* 06 Hack.					*/
; 437  : 			if ((pp2=pp1->p_fp)->p_sphone == IY) 

  00441	8b 06		 mov	 eax, DWORD PTR [esi]
  00443	83 78 14 01	 cmp	 DWORD PTR [eax+20], 1
  00447	0f 85 d2 00 00
	00		 jne	 $L71747

; 438  : 			{
; 439  : 			 	if ((pp3=pp2->p_fp)->p_sphone == AX) 

  0044d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0044f	83 79 14 11	 cmp	 DWORD PTR [ecx+20], 17	; 00000011H
  00453	0f 85 c6 00 00
	00		 jne	 $L71747

; 440  : 			 	{
; 441  : 			 		if ((pp4=pp3->p_fp)->p_sphone == S) 

  00459	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0045b	83 79 14 29	 cmp	 DWORD PTR [ecx+20], 41	; 00000029H
  0045f	0f 85 ba 00 00
	00		 jne	 $L71747

; 442  : 			 		{
; 443  : 					   	if ((pp4->p_fp->p_flag&PFMORPH) != 0) 

  00465	8b 11		 mov	 edx, DWORD PTR [ecx]
  00467	84 5a 0c	 test	 BYTE PTR [edx+12], bl
  0046a	0f 84 af 00 00
	00		 je	 $L71747

; 444  : 					   	{
; 445  : 							if ((pp2->p_flag&PFSYLAB) != 0)
; 446  : 								return;
; 447  : 							ls_adju_del_phone(pLts_t,pp2);
; 448  : 							pp1->p_sphone = SH;
; 449  : 							pp1 = pp1->p_fp;
; 450  : 							continue;

  00470	eb 79		 jmp	 SHORT $L72114
$L71786:

; 451  : 			 		  	}
; 452  : 			 		}
; 453  : 			 	}
; 454  : 			}
; 455  : 		}/* 		if (ph1 == S) */
; 456  : 
; 457  : 		/*
; 458  : 		 * T rules.
; 459  : 		 */
; 460  : 		if (ph1 == T) 

  00472	83 ff 2f	 cmp	 edi, 47			; 0000002fH
  00475	0f 85 a4 00 00
	00		 jne	 $L71747

; 461  : 		{
; 462  : 			pp2 = pp1->p_fp;

  0047b	8b 06		 mov	 eax, DWORD PTR [esi]

; 463  : 			/*
; 464  : 			 * [t] => [C] / - [u][e][r][i] +
; 465  : 			 * [t] => [C] / - [u][L] +
; 466  : 			 * [t] => [C] / - [u] +
; 467  : 			 */
; 468  : 			if (pp2->p_sphone == UW) 

  0047d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00480	83 f9 0e	 cmp	 ecx, 14			; 0000000eH
  00483	75 50		 jne	 SHORT $L71789

; 469  : 			{
; 470  : 				pp3 = pp2->p_fp;

  00485	8b 00		 mov	 eax, DWORD PTR [eax]

; 471  : 				if ((pp3->p_flag&PFMORPH) != 0) 

  00487	84 58 0c	 test	 BYTE PTR [eax+12], bl
  0048a	74 0c		 je	 SHORT $L71790

; 472  : 				{
; 473  : 					pp1->p_sphone = CH;

  0048c	c7 46 14 36 00
	00 00		 mov	 DWORD PTR [esi+20], 54	; 00000036H

; 474  : 					pp1 = pp1->p_fp;
; 475  : 					continue;

  00493	e9 87 00 00 00	 jmp	 $L71747
$L71790:

; 476  : 				}
; 477  : 				/* 06 Hack.				*/
; 478  : 				if (pp3->p_sphone == EL) 

  00498	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0049b	83 f9 22	 cmp	 ecx, 34			; 00000022H
  0049e	75 10		 jne	 SHORT $L71792

; 479  : 				{
; 480  : 				 	if ((pp3->p_fp->p_flag&PFMORPH) != 0) 

  004a0	8b 10		 mov	 edx, DWORD PTR [eax]
  004a2	84 5a 0c	 test	 BYTE PTR [edx+12], bl
  004a5	74 09		 je	 SHORT $L71792

; 481  : 				 	{
; 482  : 						pp1->p_sphone = CH;

  004a7	c7 46 14 36 00
	00 00		 mov	 DWORD PTR [esi+20], 54	; 00000036H

; 483  : 						pp1 = pp1->p_fp;
; 484  : 						continue;

  004ae	eb 6f		 jmp	 SHORT $L71747
$L71792:

; 485  : 				 	}
; 486  : 				}
; 487  : 				/* 06 Hack.				*/
; 488  : 				if (pp3->p_sphone == EY) 

  004b0	83 f9 03	 cmp	 ecx, 3
  004b3	75 6a		 jne	 SHORT $L71747

; 489  : 				{
; 490  : 				 	if ((pp4=pp3->p_fp)->p_sphone == R) 

  004b5	8b 00		 mov	 eax, DWORD PTR [eax]
  004b7	83 78 14 1a	 cmp	 DWORD PTR [eax+20], 26	; 0000001aH
  004bb	75 62		 jne	 SHORT $L71747

; 491  : 				 	{
; 492  : 				  		if ((pp4=pp4->p_fp)->p_sphone == IY) 

  004bd	8b 00		 mov	 eax, DWORD PTR [eax]
  004bf	83 78 14 01	 cmp	 DWORD PTR [eax+20], 1
  004c3	75 5a		 jne	 SHORT $L71747

; 493  : 				  		{
; 494  : 				   			if ((pp4->p_fp->p_flag&PFMORPH) != 0) 

  004c5	8b 00		 mov	 eax, DWORD PTR [eax]
  004c7	84 58 0c	 test	 BYTE PTR [eax+12], bl
  004ca	74 53		 je	 SHORT $L71747

; 495  : 				   			{
; 496  : 								pp1->p_sphone = CH;

  004cc	c7 46 14 36 00
	00 00		 mov	 DWORD PTR [esi+20], 54	; 00000036H

; 497  : 								pp1 = pp1->p_fp;
; 498  : 								continue;

  004d3	eb 4a		 jmp	 SHORT $L71747
$L71789:

; 499  : 				   			}
; 500  : 				  		}
; 501  : 				 	}
; 502  : 				}
; 503  : 			/*
; 504  : 			 * [t][i] => [S] / - [x] +
; 505  : 			 * [t] => [S] / - [i][e][t][R] +
; 506  : 			 */
; 507  : 			}	/* if (pp2->p_sphone == UW)*/ 
; 508  : 			else 
; 509  : 			{
; 510  : 				if (pp2->p_sphone == IY) 

  004d5	83 f9 01	 cmp	 ecx, 1
  004d8	75 45		 jne	 SHORT $L71747

; 511  : 				{
; 512  : 					pp3 = pp2->p_fp;

  004da	8b 08		 mov	 ecx, DWORD PTR [eax]

; 513  : 					if (pp3->p_sphone == AX
; 514  : 					&& (pp3->p_fp->p_flag&PFMORPH) != 0) 

  004dc	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  004df	83 fa 11	 cmp	 edx, 17			; 00000011H
  004e2	75 19		 jne	 SHORT $L71799
  004e4	8b 39		 mov	 edi, DWORD PTR [ecx]
  004e6	84 5f 0c	 test	 BYTE PTR [edi+12], bl
  004e9	74 12		 je	 SHORT $L71799
$L72114:

; 515  : 					{
; 516  : 						if ((pp2->p_flag&PFSYLAB) != 0)

  004eb	f6 40 0c 10	 test	 BYTE PTR [eax+12], 16	; 00000010H
  004ef	75 3e		 jne	 SHORT $L72103

; 517  : 							return;
; 518  : 						ls_adju_del_phone(pLts_t,pp2);

  004f1	50		 push	 eax
  004f2	55		 push	 ebp
  004f3	e8 00 00 00 00	 call	 _ls_adju_del_phone
  004f8	83 c4 08	 add	 esp, 8

; 519  : 						pp1->p_sphone = SH;
; 520  : 						pp1 = pp1->p_fp;
; 521  : 						continue;

  004fb	eb 1b		 jmp	 SHORT $L72115
$L71799:

; 522  : 					}
; 523  : 					/* 06 Hack.				*/
; 524  : 					if (pp3->p_sphone == EY) {

  004fd	83 fa 03	 cmp	 edx, 3
  00500	75 1d		 jne	 SHORT $L71747

; 525  : 				 	if ((pp4=pp3->p_fp)->p_sphone == T) {

  00502	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00504	83 79 14 2f	 cmp	 DWORD PTR [ecx+20], 47	; 0000002fH
  00508	75 15		 jne	 SHORT $L71747

; 526  : 				  	if ((pp4=pp4->p_fp)->p_sphone == RR) {

  0050a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0050c	39 59 14	 cmp	 DWORD PTR [ecx+20], ebx
  0050f	75 0e		 jne	 SHORT $L71747

; 527  : 				   	if ((pp4->p_fp->p_flag&PFMORPH) != 0) {

  00511	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00513	84 59 0c	 test	 BYTE PTR [ecx+12], bl
  00516	74 07		 je	 SHORT $L71747
$L72115:

; 528  : 						pp1->p_sphone = SH;

  00518	c7 46 14 2b 00
	00 00		 mov	 DWORD PTR [esi+20], 43	; 0000002bH
$L71747:

; 529  : 						pp1 = pp1->p_fp;
; 530  : 						continue;
; 531  : 				   	}
; 532  : 				  	}
; 533  : 				 	}
; 534  : 					}
; 535  : 				}/*	if (pp2->p_sphone == IY) */
; 536  : 			}	/* if (pp2->p_sphone == UW)*/ 
; 537  : 		}	/*	if (ph1 == T)*/
; 538  : 		pp1 = pp1->p_fp;

  0051f	8b 36		 mov	 esi, DWORD PTR [esi]
$L72108:

; 207  : 	while (pp1 != &pLts_t->phead) 

  00521	8d 85 c8 08 00
	00		 lea	 eax, DWORD PTR [ebp+2248]
  00527	3b f0		 cmp	 esi, eax
  00529	0f 85 9d fc ff
	ff		 jne	 $L72113
$L72103:
  0052f	5f		 pop	 edi
  00530	5e		 pop	 esi
  00531	5d		 pop	 ebp
  00532	5b		 pop	 ebx

; 539  : 	}/* 	while ((int)pp1 != (int)&pLts_t->phead) */
; 540  : 	
; 541  : }

  00533	59		 pop	 ecx
  00534	c3		 ret	 0
_ls_adju_allo2 ENDP
_TEXT	ENDS
PUBLIC	_ls_adju_sylables
PUBLIC	_ls_adju_is_cons
_TEXT	SEGMENT
_fpp$ = 8
_lpp$ = 12
_lsp$ = -4
_stype$ = 12
_ls_adju_sylables PROC NEAR

; 131  : {

  00540	51		 push	 ecx

; 132  : 	 PHONE	*pp1;
; 133  : 	 PHONE	*pp2;
; 134  : 	 PHONE	*lsp;
; 135  : 	 int	type;
; 136  : 	 int	stype;
; 137  : 
; 138  : 	lsp = NULL;				/* Last sylable pointer	*/
; 139  : 	pp1 = fpp;				/* Start of word.	*/
; 140  : 	while (pp1 != lpp) 

  00541	8b 44 24 0c	 mov	 eax, DWORD PTR _lpp$[esp]
  00545	53		 push	 ebx
  00546	8b 5c 24 0c	 mov	 ebx, DWORD PTR _fpp$[esp+4]
  0054a	55		 push	 ebp
  0054b	56		 push	 esi
  0054c	57		 push	 edi
  0054d	3b d8		 cmp	 ebx, eax
  0054f	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _lsp$[esp+20], 0
  00557	8b fb		 mov	 edi, ebx
  00559	0f 84 c0 01 00
	00		 je	 $L71822
$L71817:

; 141  : 	{
; 142  : 		if ((pp1->p_flag&PFSYLAB) != 0) 

  0055f	f6 47 0c 10	 test	 BYTE PTR [edi+12], 16	; 00000010H
  00563	75 08		 jne	 SHORT $L72120

; 145  : 			break;
; 146  : 		}
; 147  : 		pp1 = pp1->p_fp;

  00565	8b 3f		 mov	 edi, DWORD PTR [edi]
  00567	3b f8		 cmp	 edi, eax
  00569	75 f4		 jne	 SHORT $L71817

; 164  : 		if (pp1 == fpp) 

  0056b	eb 04		 jmp	 SHORT $L72118
$L72120:

; 143  : 		{
; 144  : 			lsp = pp1;

  0056d	89 7c 24 10	 mov	 DWORD PTR _lsp$[esp+20], edi
$L72118:

; 148  : 	}
; 149  : 	while (pp1 != fpp) 

  00571	3b fb		 cmp	 edi, ebx
  00573	0f 84 a6 01 00
	00		 je	 $L71822
$L71821:

; 150  : 	{						/* Until start of word.	*/
; 151  : 		stype = SNONE;		/* Not set.		*/
; 152  : 		do 
; 153  : 		{					/* Backup to vowel	*/
; 154  : 			pp2 = pp1->p_bp;

  00579	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0057c	bd 79 00 00 00	 mov	 ebp, 121		; 00000079H

; 155  : 			if (ls_adju_is_cons(pp2) == FALSE)

  00581	56		 push	 esi
  00582	89 6c 24 20	 mov	 DWORD PTR _stype$[esp+20], ebp
  00586	e8 00 00 00 00	 call	 _ls_adju_is_cons
  0058b	83 c4 04	 add	 esp, 4
  0058e	85 c0		 test	 eax, eax
  00590	74 28		 je	 SHORT $L71825
$L71823:

; 156  : 				break;
; 157  : 			pp1 = pp2;
; 158  : 			if (pp1->p_stress != SNONE) 

  00592	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00595	8b fe		 mov	 edi, esi
  00597	3b c5		 cmp	 eax, ebp
  00599	74 07		 je	 SHORT $L71824

; 159  : 			{
; 160  : 				stype = pp1->p_stress;

  0059b	89 44 24 1c	 mov	 DWORD PTR _stype$[esp+16], eax

; 161  : 				pp1->p_stress = SNONE;

  0059f	89 6e 10	 mov	 DWORD PTR [esi+16], ebp
$L71824:

; 162  : 			}
; 163  : 		} while (pp1 != fpp);

  005a2	3b f3		 cmp	 esi, ebx
  005a4	0f 84 4b 01 00
	00		 je	 $L72122
  005aa	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  005ad	56		 push	 esi
  005ae	e8 00 00 00 00	 call	 _ls_adju_is_cons
  005b3	83 c4 04	 add	 esp, 4
  005b6	85 c0		 test	 eax, eax
  005b8	75 d8		 jne	 SHORT $L71823
$L71825:

; 164  : 		if (pp1 == fpp) 

  005ba	3b fb		 cmp	 edi, ebx
  005bc	0f 84 33 01 00
	00		 je	 $L72122

; 174  : 			break;
; 175  : 		} 
; 176  : 		pp1 = pp1->p_bp;			/* Point at vowel	*/

  005c2	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]

; 177  : 		pp1->p_flag |= PFLEFTC;		/* In left cluster.	*/

  005c5	8b 6f 0c	 mov	 ebp, DWORD PTR [edi+12]
  005c8	8d 77 0c	 lea	 esi, DWORD PTR [edi+12]

; 178  : 		if (pp1->p_stress != SNONE) 

  005cb	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  005ce	83 cd 40	 or	 ebp, 64			; 00000040H
  005d1	89 2e		 mov	 DWORD PTR [esi], ebp
  005d3	8b cd		 mov	 ecx, ebp
  005d5	8d 6f 10	 lea	 ebp, DWORD PTR [edi+16]
  005d8	83 f8 79	 cmp	 eax, 121		; 00000079H
  005db	74 0b		 je	 SHORT $L71831

; 179  : 		{
; 180  : 			stype = pp1->p_stress;

  005dd	89 44 24 1c	 mov	 DWORD PTR _stype$[esp+16], eax

; 181  : 			pp1->p_stress = SNONE;

  005e1	c7 45 00 79 00
	00 00		 mov	 DWORD PTR [ebp], 121	; 00000079H
$L71831:

; 182  : 		}
; 183  : 		if ((pp1->p_flag&PFMORPH) != 0	/* Explicit morpheme	*/
; 184  : 		|| pp1 == fpp					/* or start of word	*/
; 185  : 		|| ls_adju_is_cons(pp2=pp1->p_bp) == FALSE)

  005e8	f6 c1 0f	 test	 cl, 15			; 0000000fH
  005eb	0f 85 e4 00 00
	00		 jne	 $out$71834
  005f1	3b fb		 cmp	 edi, ebx
  005f3	0f 84 dc 00 00
	00		 je	 $out$71834
  005f9	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  005fc	53		 push	 ebx
  005fd	e8 00 00 00 00	 call	 _ls_adju_is_cons
  00602	83 c4 04	 add	 esp, 4
  00605	85 c0		 test	 eax, eax
  00607	0f 84 c4 00 00
	00		 je	 $L72126

; 186  : 		{
; 187  : 			goto out;
; 188  : 		}
; 189  : 		pp1 = pp2;					/* One consonant	*/
; 190  : 
; 191  : 		pp1->p_flag |= PFLEFTC;		/* In left cluster.	*/

  0060d	8b 6b 0c	 mov	 ebp, DWORD PTR [ebx+12]
  00610	8d 73 0c	 lea	 esi, DWORD PTR [ebx+12]

; 192  : 		if (pp1->p_stress != SNONE) 

  00613	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00616	83 cd 40	 or	 ebp, 64			; 00000040H
  00619	89 2e		 mov	 DWORD PTR [esi], ebp
  0061b	8b cd		 mov	 ecx, ebp
  0061d	8d 6b 10	 lea	 ebp, DWORD PTR [ebx+16]
  00620	83 f8 79	 cmp	 eax, 121		; 00000079H
  00623	8b fb		 mov	 edi, ebx
  00625	74 0b		 je	 SHORT $L71835

; 193  : 		{
; 194  : 			stype = pp1->p_stress;

  00627	89 44 24 1c	 mov	 DWORD PTR _stype$[esp+16], eax

; 195  : 			pp1->p_stress = SNONE;

  0062b	c7 45 00 79 00
	00 00		 mov	 DWORD PTR [ebp], 121	; 00000079H
$L71835:

; 196  : 		}
; 197  : 		if ((pp1->p_flag&PFMORPH) != 0	/* Explicit morpheme	*/
; 198  : 		|| pp1 == fpp					/* or start of word.	*/
; 199  : 		|| ls_adju_is_cons(pp2=pp1->p_bp) == FALSE)

  00632	f6 c1 0f	 test	 cl, 15			; 0000000fH
  00635	0f 85 96 00 00
	00		 jne	 $L72126
  0063b	3b 5c 24 18	 cmp	 ebx, DWORD PTR _fpp$[esp+16]
  0063f	0f 84 8c 00 00
	00		 je	 $L72126
  00645	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  00648	53		 push	 ebx
  00649	e8 00 00 00 00	 call	 _ls_adju_is_cons
  0064e	83 c4 04	 add	 esp, 4
  00651	85 c0		 test	 eax, eax
  00653	74 7c		 je	 SHORT $L72126

; 200  : 		{
; 201  : 			goto out;
; 202  : 		}
; 203  : 		type = ls_adju_cluster(pp2->p_sphone, pp1->p_sphone);

  00655	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00658	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  0065b	50		 push	 eax
  0065c	51		 push	 ecx
  0065d	e8 00 00 00 00	 call	 _ls_adju_cluster
  00662	83 c4 08	 add	 esp, 8

; 204  : 		if (type == ILLEGAL)			/* Not allowed		*/

  00665	85 c0		 test	 eax, eax
  00667	74 68		 je	 SHORT $L72126

; 205  : 		{
; 206  : 			goto out;
; 207  : 		}
; 208  : 		pp1 = pp2;					/* Two consonants	*/
; 209  : 
; 210  : 		pp1->p_flag |= PFLEFTC;		/* In left cluster.	*/

  00669	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0066c	8d 73 0c	 lea	 esi, DWORD PTR [ebx+12]
  0066f	83 c9 40	 or	 ecx, 64			; 00000040H

; 211  : 		if (pp1->p_stress != SNONE) 

  00672	8d 6b 10	 lea	 ebp, DWORD PTR [ebx+16]
  00675	89 0e		 mov	 DWORD PTR [esi], ecx
  00677	8b d1		 mov	 edx, ecx
  00679	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  0067c	8b fb		 mov	 edi, ebx
  0067e	83 f9 79	 cmp	 ecx, 121		; 00000079H
  00681	74 0b		 je	 SHORT $L71839

; 212  : 		{
; 213  : 			stype = pp1->p_stress;

  00683	89 4c 24 1c	 mov	 DWORD PTR _stype$[esp+16], ecx

; 214  : 			pp1->p_stress = SNONE;

  00687	c7 45 00 79 00
	00 00		 mov	 DWORD PTR [ebp], 121	; 00000079H
$L71839:

; 215  : 		}
; 216  : 		if (type == TRYS				/* If "s" or "S" good	*/
; 217  : 		&& (pp1->p_flag&PFMORPH) == 0	/* check for it.	*/
; 218  : 		&& pp1 != fpp
; 219  : 		&& ((pp2=pp1->p_bp)->p_sphone==S || pp2->p_sphone==SH)) 

  0068e	83 f8 02	 cmp	 eax, 2
  00691	75 3e		 jne	 SHORT $L72126
  00693	f6 c2 0f	 test	 dl, 15			; 0000000fH
  00696	75 39		 jne	 SHORT $L72126
  00698	3b 5c 24 18	 cmp	 ebx, DWORD PTR _fpp$[esp+16]
  0069c	74 33		 je	 SHORT $L72126
  0069e	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  006a1	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  006a4	83 f8 29	 cmp	 eax, 41			; 00000029H
  006a7	74 05		 je	 SHORT $L71841
  006a9	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  006ac	75 23		 jne	 SHORT $L72126
$L71841:

; 220  : 		{
; 221  : 			pp1 = pp2;					/* Include it.		*/
; 222  : 			pp1->p_flag |= PFLEFTC;

  006ae	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]

; 223  : 			if (pp1->p_stress != SNONE) 

  006b1	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  006b4	8d 73 0c	 lea	 esi, DWORD PTR [ebx+12]
  006b7	8d 6b 10	 lea	 ebp, DWORD PTR [ebx+16]
  006ba	83 ca 40	 or	 edx, 64			; 00000040H
  006bd	83 f8 79	 cmp	 eax, 121		; 00000079H
  006c0	8b fb		 mov	 edi, ebx
  006c2	89 16		 mov	 DWORD PTR [esi], edx
  006c4	74 0b		 je	 SHORT $L72126

; 224  : 			{
; 225  : 				stype = pp1->p_stress;

  006c6	89 44 24 1c	 mov	 DWORD PTR _stype$[esp+16], eax

; 226  : 				pp1->p_stress = SNONE;

  006ca	c7 45 00 79 00
	00 00		 mov	 DWORD PTR [ebp], 121	; 00000079H
$L72126:
  006d1	8b 5c 24 18	 mov	 ebx, DWORD PTR _fpp$[esp+16]
$out$71834:

; 227  : 			}
; 228  : 		}
; 229  : 	out:
; 230  : 
; 231  : 		pp1->p_flag |= PFSYLAB;		/* Mark sylable		*/

  006d5	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 232  : 		pp1->p_stress = stype;		/* (may set stress)	*/

  006d7	8b 54 24 1c	 mov	 edx, DWORD PTR _stype$[esp+16]
  006db	83 c9 10	 or	 ecx, 16			; 00000010H
  006de	3b fb		 cmp	 edi, ebx
  006e0	89 0e		 mov	 DWORD PTR [esi], ecx
  006e2	89 55 00	 mov	 DWORD PTR [ebp], edx

; 233  : 		lsp = pp1;					/* Remember last one	*/

  006e5	89 7c 24 10	 mov	 DWORD PTR _lsp$[esp+20], edi
  006e9	0f 85 8a fe ff
	ff		 jne	 $L71821
  006ef	5f		 pop	 edi
  006f0	5e		 pop	 esi
  006f1	5d		 pop	 ebp
  006f2	5b		 pop	 ebx

; 234  : 	}
; 235  : 	return;
; 236  : }

  006f3	59		 pop	 ecx
  006f4	c3		 ret	 0
$L72122:

; 165  : 		{					/* "gdansk", "gxx"	*/
; 166  : 			if (lsp != NULL) 

  006f5	8b 44 24 10	 mov	 eax, DWORD PTR _lsp$[esp+20]
  006f9	85 c0		 test	 eax, eax
  006fb	74 13		 je	 SHORT $L71830

; 167  : 			{
; 168  : 				lsp->p_flag &= ~PFSYLAB;

  006fd	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00700	83 e1 ef	 and	 ecx, -17		; ffffffefH
  00703	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 169  : 				stype = lsp->p_stress;

  00706	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00709	89 4c 24 1c	 mov	 DWORD PTR _stype$[esp+16], ecx

; 170  : 				lsp->p_stress = SNONE;

  0070d	89 68 10	 mov	 DWORD PTR [eax+16], ebp
$L71830:

; 171  : 			}
; 172  : 			pp1->p_flag |= PFSYLAB;

  00710	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]

; 173  : 			pp1->p_stress = stype;

  00713	8b 54 24 1c	 mov	 edx, DWORD PTR _stype$[esp+16]
  00717	0c 10		 or	 al, 16			; 00000010H
  00719	89 57 10	 mov	 DWORD PTR [edi+16], edx
  0071c	89 47 0c	 mov	 DWORD PTR [edi+12], eax
$L71822:
  0071f	5f		 pop	 edi
  00720	5e		 pop	 esi
  00721	5d		 pop	 ebp
  00722	5b		 pop	 ebx

; 234  : 	}
; 235  : 	return;
; 236  : }

  00723	59		 pop	 ecx
  00724	c3		 ret	 0
_ls_adju_sylables ENDP
_TEXT	ENDS
EXTRN	_pfeat:BYTE
_TEXT	SEGMENT
_pp$ = 8
_ls_adju_is_cons PROC NEAR

; 256  : 	if ((pfeat[pp->p_sphone]&PCONS) != 0)

  00730	8b 44 24 04	 mov	 eax, DWORD PTR _pp$[esp-4]
  00734	33 d2		 xor	 edx, edx
  00736	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00739	8a 14 4d 00 00
	00 00		 mov	 dl, BYTE PTR _pfeat[ecx*2]
  00740	8b c2		 mov	 eax, edx
  00742	83 e0 01	 and	 eax, 1

; 257  : 		return (TRUE);
; 258  : 	return (FALSE);
; 259  : }                

  00745	c3		 ret	 0
_ls_adju_is_cons ENDP
_pp$ = 8
_ls_adju_is_voc PROC NEAR

; 279  : 	if ((pfeat[pp->p_sphone]&PVOC) != 0)

  00750	8b 44 24 04	 mov	 eax, DWORD PTR _pp$[esp-4]
  00754	33 d2		 xor	 edx, edx
  00756	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00759	8a 14 4d 00 00
	00 00		 mov	 dl, BYTE PTR _pfeat[ecx*2]
  00760	8b c2		 mov	 eax, edx
  00762	d1 e8		 shr	 eax, 1
  00764	83 e0 01	 and	 eax, 1

; 280  : 		return (TRUE);
; 281  : 	return (FALSE);
; 282  : }                

  00767	c3		 ret	 0
_ls_adju_is_voc ENDP
_TEXT	ENDS
PUBLIC	_ls_adju_stress
PUBLIC	_ls_adju_unstressed
PUBLIC	_ls_adju_suffixscan
PUBLIC	_ls_adju_prefixscan
PUBLIC	_ls_adju_bestdefault
PUBLIC	_ls_adju_final_fixes
EXTRN	_lsa_util_stress_sp:NEAR
EXTRN	_lsa_util_stress_sl:NEAR
EXTRN	_lsa_util_stress_ja:NEAR
EXTRN	_lsa_util_stress_it:NEAR
EXTRN	_lsa_util_stress_gr:NEAR
EXTRN	_lsa_util_stress_fr:NEAR
_TEXT	SEGMENT
_phTTS$ = 8
_fpp$ = 12
_lpp$ = 16
_pstype$ = 20
_sel_lang$ = 24
_ls_adju_stress PROC NEAR

; 311  : {

  00770	53		 push	 ebx

; 312  : 	 int	csyl;
; 313  : 	 int	type;
; 314  : 	 int	isreduced;
; 315  : 	 PLTS_T pLts_t;               
; 316  : 	 PKSD_T pKsd_t;
; 317  : 	 pLts_t=phTTS->pLTSThreadData;
; 318  : 	 pKsd_t=phTTS->pKernelShareData;
; 319  : 
; 320  : 	if (ls_adju_suffixscan(pLts_t,fpp, lpp) == FALSE)

  00771	8b 5c 24 0c	 mov	 ebx, DWORD PTR _fpp$[esp]
  00775	55		 push	 ebp
  00776	8b 6c 24 0c	 mov	 ebp, DWORD PTR _phTTS$[esp+4]
  0077a	56		 push	 esi
  0077b	57		 push	 edi
  0077c	8b 7c 24 1c	 mov	 edi, DWORD PTR _lpp$[esp+12]
  00780	8b 75 10	 mov	 esi, DWORD PTR [ebp+16]
  00783	57		 push	 edi
  00784	53		 push	 ebx
  00785	56		 push	 esi
  00786	e8 00 00 00 00	 call	 _ls_adju_suffixscan
  0078b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0078e	85 c0		 test	 eax, eax
  00790	0f 84 06 04 00
	00		 je	 $L71861

; 321  : 		return;
; 322  : 	if (ls_adju_prefixscan(phTTS,fpp, lpp,sel_lang) == FALSE)

  00796	8b 44 24 24	 mov	 eax, DWORD PTR _sel_lang$[esp+12]
  0079a	50		 push	 eax
  0079b	57		 push	 edi
  0079c	53		 push	 ebx
  0079d	55		 push	 ebp
  0079e	e8 00 00 00 00	 call	 _ls_adju_prefixscan
  007a3	83 c4 10	 add	 esp, 16			; 00000010H
  007a6	85 c0		 test	 eax, eax
  007a8	0f 84 ee 03 00
	00		 je	 $L71861

; 323  : 		return;
; 324  : #ifdef ACNA
; 325  : 	/*
; 326  : 	 * PRG	23-NOV-1988
; 327  : 	 * BEGINNING OF MODIFICATION - this code segment looks at the
; 328  : 	 * language tag associated with the word being analyzed and
; 329  : 	 * dispatches the word out to different analysis routines for
; 330  : 	 * languages other than English.  English words are processed
; 331  : 	 * as words always have been.
; 332  : 	 */
; 333  : 
; 334  : 		if (sel_lang != NAME_ENGLISH && sel_lang != NAME_IRISH)

  007ae	8b 54 24 24	 mov	 edx, DWORD PTR _sel_lang$[esp+12]
  007b2	85 d2		 test	 edx, edx
  007b4	0f 84 c3 00 00
	00		 je	 $L71874
  007ba	83 fa 03	 cmp	 edx, 3
  007bd	0f 84 ba 00 00
	00		 je	 $L71874

; 335  : 		{
; 336  : 	   	   /*
; 337  : 		    * Stress placed on the word by English rules (which are the
; 338  : 	    	* default rules) must be removed.
; 339  : 	    	*/
; 340  : 
; 341  : 
; 342  : 	   		for (csyl=0; csyl<pLts_t->nsyl; csyl++)

  007c3	33 c0		 xor	 eax, eax
  007c5	66 39 86 30 04
	00 00		 cmp	 WORD PTR [esi+1072], ax
  007cc	7e 1e		 jle	 SHORT $L71872
  007ce	8d 8e 08 04 00
	00		 lea	 ecx, DWORD PTR [esi+1032]
$L71870:

; 343  : 	      		pLts_t->sylp[csyl]->p_stress = SUN;

  007d4	8b 29		 mov	 ebp, DWORD PTR [ecx]
  007d6	40		 inc	 eax
  007d7	83 c1 04	 add	 ecx, 4
  007da	c7 45 10 7a 00
	00 00		 mov	 DWORD PTR [ebp+16], 122	; 0000007aH
  007e1	0f bf ae 30 04
	00 00		 movsx	 ebp, WORD PTR [esi+1072]
  007e8	3b c5		 cmp	 eax, ebp
  007ea	7c e8		 jl	 SHORT $L71870
$L71872:

; 344  : 
; 345  : 	   		/*
; 346  : 	    	 * Execute language specific analysis.
; 347  : 	    	 */
; 348  : 
; 349  : 	   		switch (sel_lang)
; 350  : 	   		{

  007ec	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  007ef	83 f8 06	 cmp	 eax, 6
  007f2	0f 87 85 00 00
	00		 ja	 $L71874
  007f8	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72151[eax*4]
$L71877:

; 351  : 				case NAME_FRENCH :
; 352  : 		 			lsa_util_stress_fr (pLts_t,fpp, lpp, pstype);

  007ff	8b 4c 24 20	 mov	 ecx, DWORD PTR _pstype$[esp+12]
  00803	51		 push	 ecx
  00804	57		 push	 edi
  00805	53		 push	 ebx
  00806	56		 push	 esi
  00807	e8 00 00 00 00	 call	 _lsa_util_stress_fr
  0080c	83 c4 10	 add	 esp, 16			; 00000010H
  0080f	5f		 pop	 edi
  00810	5e		 pop	 esi
  00811	5d		 pop	 ebp
  00812	5b		 pop	 ebx

; 517  : }

  00813	c3		 ret	 0
$L71878:

; 353  : 		 			return;
; 354  : 
; 355  : 	      		case NAME_GERMANIC :
; 356  : 			 		lsa_util_stress_gr (pLts_t,fpp, lpp, pstype);

  00814	8b 54 24 20	 mov	 edx, DWORD PTR _pstype$[esp+12]
  00818	52		 push	 edx
  00819	57		 push	 edi
  0081a	53		 push	 ebx
  0081b	56		 push	 esi
  0081c	e8 00 00 00 00	 call	 _lsa_util_stress_gr
  00821	83 c4 10	 add	 esp, 16			; 00000010H
  00824	5f		 pop	 edi
  00825	5e		 pop	 esi
  00826	5d		 pop	 ebp
  00827	5b		 pop	 ebx

; 517  : }

  00828	c3		 ret	 0
$L71879:

; 357  : 		 			return;
; 358  : 
; 359  : 	      		case NAME_ITALIAN :
; 360  : 		 			lsa_util_stress_it (pLts_t,fpp, lpp, pstype);

  00829	8b 44 24 20	 mov	 eax, DWORD PTR _pstype$[esp+12]
  0082d	50		 push	 eax
  0082e	57		 push	 edi
  0082f	53		 push	 ebx
  00830	56		 push	 esi
  00831	e8 00 00 00 00	 call	 _lsa_util_stress_it
  00836	83 c4 10	 add	 esp, 16			; 00000010H
  00839	5f		 pop	 edi
  0083a	5e		 pop	 esi
  0083b	5d		 pop	 ebp
  0083c	5b		 pop	 ebx

; 517  : }

  0083d	c3		 ret	 0
$L71880:

; 361  : 		 			return;
; 362  : 
; 363  : 		      	case NAME_JAPANESE :
; 364  : 				 	lsa_util_stress_ja (pLts_t,fpp, lpp, pstype);

  0083e	8b 4c 24 20	 mov	 ecx, DWORD PTR _pstype$[esp+12]
  00842	51		 push	 ecx
  00843	57		 push	 edi
  00844	53		 push	 ebx
  00845	56		 push	 esi
  00846	e8 00 00 00 00	 call	 _lsa_util_stress_ja
  0084b	83 c4 10	 add	 esp, 16			; 00000010H
  0084e	5f		 pop	 edi
  0084f	5e		 pop	 esi
  00850	5d		 pop	 ebp
  00851	5b		 pop	 ebx

; 517  : }

  00852	c3		 ret	 0
$L71881:

; 365  : 		 			return;
; 366  : 
; 367  : 	      		case NAME_SPANISH :
; 368  : 					lsa_util_stress_sp (pLts_t,fpp, lpp, pstype);

  00853	8b 54 24 20	 mov	 edx, DWORD PTR _pstype$[esp+12]
  00857	52		 push	 edx
  00858	57		 push	 edi
  00859	53		 push	 ebx
  0085a	56		 push	 esi
  0085b	e8 00 00 00 00	 call	 _lsa_util_stress_sp
  00860	83 c4 10	 add	 esp, 16			; 00000010H
  00863	5f		 pop	 edi
  00864	5e		 pop	 esi
  00865	5d		 pop	 ebp
  00866	5b		 pop	 ebx

; 517  : }

  00867	c3		 ret	 0
$L71882:

; 369  : 			 		return;
; 370  : 
; 371  : 	      		case NAME_SLAVIC :
; 372  : 					lsa_util_stress_sl (pLts_t,fpp, lpp, pstype);

  00868	8b 44 24 20	 mov	 eax, DWORD PTR _pstype$[esp+12]
  0086c	50		 push	 eax
  0086d	57		 push	 edi
  0086e	53		 push	 ebx
  0086f	56		 push	 esi
  00870	e8 00 00 00 00	 call	 _lsa_util_stress_sl
  00875	83 c4 10	 add	 esp, 16			; 00000010H
  00878	5f		 pop	 edi
  00879	5e		 pop	 esi
  0087a	5d		 pop	 ebp
  0087b	5b		 pop	 ebx

; 517  : }

  0087c	c3		 ret	 0
$L71874:

; 373  : 			 		return;
; 374  : 	   		};
; 375  : 		}
; 376  : 
; 377  : 	/*
; 378  : 	 * END OF MODIFICATION.
; 379  : 	 */
; 380  : 
; 381  : #endif /* #ifdef ACNA */
; 382  : 
; 383  : 	/* Suffix is providing primary stress placement information.	*/
; 384  : 	/* Place it. Shift left if impossible. Let prefix flags and bad	*/
; 385  : 	/* vowels push it back toward the suffix.			*/
; 386  : 
; 387  : 	if (pLts_t->psyl >= 0) 

  0087d	66 8b 96 34 04
	00 00		 mov	 dx, WORD PTR [esi+1076]
  00884	66 85 d2	 test	 dx, dx
  00887	0f 8c 7d 01 00
	00		 jl	 $L71883

; 388  : 	{
; 389  : 		type = pLts_t->sylp[pLts_t->psyl]->p_stress;

  0088d	0f bf ca	 movsx	 ecx, dx
  00890	8b 8c 8e 08 04
	00 00		 mov	 ecx, DWORD PTR [esi+ecx*4+1032]
  00897	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 390  : 		if (type==S1LEFT || type==S2LEFT) 

  0089a	83 f8 7d	 cmp	 eax, 125		; 0000007dH
  0089d	74 05		 je	 SHORT $L71885
  0089f	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  008a2	75 39		 jne	 SHORT $L72133
$L71885:

; 391  : 		{
; 392  : 			if (pLts_t->psyl != 0) 

  008a4	66 85 d2	 test	 dx, dx
  008a7	74 34		 je	 SHORT $L72133

; 393  : 			{
; 394  : 				pLts_t->sylp[pLts_t->psyl]->p_stress = SUN;

  008a9	ba 7a 00 00 00	 mov	 edx, 122		; 0000007aH
  008ae	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 395  : 				--pLts_t->psyl;

  008b1	66 ff 8e 34 04
	00 00		 dec	 WORD PTR [esi+1076]
  008b8	66 8b 8e 34 04
	00 00		 mov	 cx, WORD PTR [esi+1076]

; 396  : 				if (type==S2LEFT && pLts_t->psyl!=0) 

  008bf	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  008c2	75 19		 jne	 SHORT $L72133
  008c4	66 85 c9	 test	 cx, cx
  008c7	74 14		 je	 SHORT $L72133

; 397  : 				{
; 398  : 					pLts_t->sylp[pLts_t->psyl]->p_stress = SUN;

  008c9	0f bf c1	 movsx	 eax, cx
  008cc	8b 8c 86 08 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax*4+1032]
  008d3	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 399  : 					--pLts_t->psyl;

  008d6	66 ff 8e 34 04
	00 00		 dec	 WORD PTR [esi+1076]
$L72133:

; 400  : 				}
; 401  : 			}
; 402  : 		}
; 403  : 		while (pLts_t->psyl!=0 && ls_adju_unstressed(pLts_t,pLts_t->psyl)!=FALSE) 

  008dd	66 83 be 34 04
	00 00 00	 cmp	 WORD PTR [esi+1076], 0
  008e5	74 26		 je	 SHORT $L72134
$L71889:
  008e7	0f bf 96 34 04
	00 00		 movsx	 edx, WORD PTR [esi+1076]
  008ee	52		 push	 edx
  008ef	56		 push	 esi
  008f0	e8 00 00 00 00	 call	 _ls_adju_unstressed
  008f5	83 c4 08	 add	 esp, 8
  008f8	85 c0		 test	 eax, eax
  008fa	74 11		 je	 SHORT $L72134

; 404  : 		{
; 405  : 			--pLts_t->psyl;

  008fc	66 ff 8e 34 04
	00 00		 dec	 WORD PTR [esi+1076]
  00903	66 83 be 34 04
	00 00 00	 cmp	 WORD PTR [esi+1076], 0
  0090b	75 da		 jne	 SHORT $L71889
$L72134:

; 406  : 		}
; 407  : 		while (pLts_t->psyl<pLts_t->nsyl-1 && (pLts_t->sylp[pLts_t->psyl]->p_flag&PFRFUSE)!=0) 

  0090d	0f bf 86 30 04
	00 00		 movsx	 eax, WORD PTR [esi+1072]
  00914	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00917	0f bf 86 34 04
	00 00		 movsx	 eax, WORD PTR [esi+1076]
  0091e	3b c1		 cmp	 eax, ecx
  00920	7d 27		 jge	 SHORT $L72135
  00922	b2 20		 mov	 dl, 32			; 00000020H
$L71892:
  00924	66 8b 86 34 04
	00 00		 mov	 ax, WORD PTR [esi+1076]
  0092b	0f bf f8	 movsx	 edi, ax
  0092e	8b bc be 08 04
	00 00		 mov	 edi, DWORD PTR [esi+edi*4+1032]
  00935	84 57 0c	 test	 BYTE PTR [edi+12], dl
  00938	74 0f		 je	 SHORT $L72135

; 408  : 		{
; 409  : 			++pLts_t->psyl;

  0093a	40		 inc	 eax
  0093b	66 89 86 34 04
	00 00		 mov	 WORD PTR [esi+1076], ax
  00942	0f bf c0	 movsx	 eax, ax
  00945	3b c1		 cmp	 eax, ecx
  00947	7c db		 jl	 SHORT $L71892
$L72135:

; 410  : 		}
; 411  : 		while (pLts_t->psyl<pLts_t->nsyl-1 && ls_adju_unstressed(pLts_t,pLts_t->psyl)!=FALSE) 

  00949	0f bf 96 34 04
	00 00		 movsx	 edx, WORD PTR [esi+1076]
  00950	3b d1		 cmp	 edx, ecx
  00952	7d 32		 jge	 SHORT $L71896
$L71895:
  00954	0f bf 86 34 04
	00 00		 movsx	 eax, WORD PTR [esi+1076]
  0095b	50		 push	 eax
  0095c	56		 push	 esi
  0095d	e8 00 00 00 00	 call	 _ls_adju_unstressed
  00962	83 c4 08	 add	 esp, 8
  00965	85 c0		 test	 eax, eax
  00967	74 1d		 je	 SHORT $L71896

; 412  : 		{
; 413  : 			++pLts_t->psyl;

  00969	66 ff 86 34 04
	00 00		 inc	 WORD PTR [esi+1076]
  00970	66 8b 86 34 04
	00 00		 mov	 ax, WORD PTR [esi+1076]
  00977	0f bf 8e 30 04
	00 00		 movsx	 ecx, WORD PTR [esi+1072]
  0097e	0f bf d0	 movsx	 edx, ax
  00981	49		 dec	 ecx
  00982	3b d1		 cmp	 edx, ecx
  00984	7c ce		 jl	 SHORT $L71895
$L71896:

; 414  : 		}
; 415  : 		pLts_t->sylp[pLts_t->psyl]->p_stress = pstype;

  00986	0f bf 86 34 04
	00 00		 movsx	 eax, WORD PTR [esi+1076]
  0098d	8b 54 24 20	 mov	 edx, DWORD PTR _pstype$[esp+12]

; 416  : 		csyl = pLts_t->psyl+1;
; 417  : 		isreduced = TRUE;

  00991	bf 01 00 00 00	 mov	 edi, 1
  00996	8b 8c 86 08 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax*4+1032]
  0099d	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  009a0	0f bf 8e 34 04
	00 00		 movsx	 ecx, WORD PTR [esi+1076]

; 418  : 		while (csyl < pLts_t->nsyl) 

  009a7	0f bf 86 30 04
	00 00		 movsx	 eax, WORD PTR [esi+1072]
  009ae	41		 inc	 ecx
  009af	3b c8		 cmp	 ecx, eax
  009b1	0f 8d dc 01 00
	00		 jge	 $L71899
  009b7	8d 94 8e 08 04
	00 00		 lea	 edx, DWORD PTR [esi+ecx*4+1032]
  009be	bb 79 00 00 00	 mov	 ebx, 121		; 00000079H
  009c3	bd 80 00 00 00	 mov	 ebp, 128		; 00000080H
$L71898:

; 419  : 		{
; 420  : 			if (isreduced == FALSE) 

  009c8	85 ff		 test	 edi, edi
  009ca	75 11		 jne	 SHORT $L71900

; 421  : 			{
; 422  : 				if (pLts_t->sylp[csyl]->p_stress == SNONE)

  009cc	8b 02		 mov	 eax, DWORD PTR [edx]
  009ce	39 58 10	 cmp	 DWORD PTR [eax+16], ebx
  009d1	75 03		 jne	 SHORT $L71901

; 423  : 					pLts_t->sylp[csyl]->p_flag |= PFBLOCK;

  009d3	09 68 0c	 or	 DWORD PTR [eax+12], ebp
$L71901:

; 424  : 				isreduced = TRUE;

  009d6	bf 01 00 00 00	 mov	 edi, 1

; 425  : 			} 
; 426  : 			else

  009db	eb 02		 jmp	 SHORT $L71902
$L71900:

; 427  : 			{
; 428  : 				isreduced = FALSE;

  009dd	33 ff		 xor	 edi, edi
$L71902:

; 429  : 			}
; 430  : 			if (pLts_t->sylp[csyl]->p_stress == SNONE)

  009df	8b 02		 mov	 eax, DWORD PTR [edx]
  009e1	39 58 10	 cmp	 DWORD PTR [eax+16], ebx
  009e4	75 07		 jne	 SHORT $L71903

; 431  : 			{
; 432  : 				pLts_t->sylp[csyl]->p_stress = SUN;

  009e6	c7 40 10 7a 00
	00 00		 mov	 DWORD PTR [eax+16], 122	; 0000007aH
$L71903:

; 418  : 		while (csyl < pLts_t->nsyl) 

  009ed	0f bf 86 30 04
	00 00		 movsx	 eax, WORD PTR [esi+1072]

; 433  : 			}
; 434  : 			++csyl;

  009f4	41		 inc	 ecx
  009f5	83 c2 04	 add	 edx, 4
  009f8	3b c8		 cmp	 ecx, eax
  009fa	7c cc		 jl	 SHORT $L71898

; 515  : 	}
; 516  : 	ls_adju_final_fixes(pLts_t);

  009fc	56		 push	 esi
  009fd	e8 00 00 00 00	 call	 _ls_adju_final_fixes
  00a02	83 c4 04	 add	 esp, 4
  00a05	5f		 pop	 edi
  00a06	5e		 pop	 esi
  00a07	5d		 pop	 ebp
  00a08	5b		 pop	 ebx

; 517  : }

  00a09	c3		 ret	 0
$L71883:

; 435  : 		}
; 436  : 		ls_adju_final_fixes(pLts_t);
; 437  : 		return;
; 438  : 	}
; 439  : 	/* No suffix, but prefix is refusing the stress.		*/
; 440  : 	if ((pLts_t->sylp[0]->p_flag&PFRFUSE) != 0) 

  00a0a	8b 8e 08 04 00
	00		 mov	 ecx, DWORD PTR [esi+1032]
  00a10	b2 20		 mov	 dl, 32			; 00000020H
  00a12	84 51 0c	 test	 BYTE PTR [ecx+12], dl
  00a15	0f 84 fd 00 00
	00		 je	 $L71904

; 441  : 	{
; 442  : 		pLts_t->psyl = 0;
; 443  : #if defined (VMS) || defined (LDS_BUILD)
; 444  : 		if (rflag != FALSE)
; 445  : 			printf("Begin at sylable 1\n");
; 446  : #endif
; 447  : 		while (pLts_t->psyl<pLts_t->nsyl-1 && (pLts_t->sylp[pLts_t->psyl]->p_flag&PFRFUSE)!=0) 

  00a1b	0f bf 86 30 04
	00 00		 movsx	 eax, WORD PTR [esi+1072]
  00a22	66 c7 86 34 04
	00 00 00 00	 mov	 WORD PTR [esi+1076], 0
  00a2b	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00a2e	85 c9		 test	 ecx, ecx
  00a30	7e 25		 jle	 SHORT $L72138
$L71906:
  00a32	66 8b 86 34 04
	00 00		 mov	 ax, WORD PTR [esi+1076]
  00a39	0f bf f8	 movsx	 edi, ax
  00a3c	8b bc be 08 04
	00 00		 mov	 edi, DWORD PTR [esi+edi*4+1032]
  00a43	84 57 0c	 test	 BYTE PTR [edi+12], dl
  00a46	74 0f		 je	 SHORT $L72138

; 448  : 		{
; 449  : 			++pLts_t->psyl;

  00a48	40		 inc	 eax
  00a49	66 89 86 34 04
	00 00		 mov	 WORD PTR [esi+1076], ax
  00a50	0f bf c0	 movsx	 eax, ax
  00a53	3b c1		 cmp	 eax, ecx
  00a55	7c db		 jl	 SHORT $L71906
$L72138:

; 450  : #if defined (VMS) || defined (LDS_BUILD)
; 451  : 			if (rflag != FALSE)
; 452  : 				printf("Prefix, shift right\n");
; 453  : #endif
; 454  : 		}
; 455  : 		while (pLts_t->psyl<pLts_t->nsyl-1 && ls_adju_unstressed(pLts_t,pLts_t->psyl)!=FALSE) 

  00a57	0f bf 96 34 04
	00 00		 movsx	 edx, WORD PTR [esi+1076]
  00a5e	3b d1		 cmp	 edx, ecx
  00a60	7d 32		 jge	 SHORT $L71910
$L71909:
  00a62	0f bf 86 34 04
	00 00		 movsx	 eax, WORD PTR [esi+1076]
  00a69	50		 push	 eax
  00a6a	56		 push	 esi
  00a6b	e8 00 00 00 00	 call	 _ls_adju_unstressed
  00a70	83 c4 08	 add	 esp, 8
  00a73	85 c0		 test	 eax, eax
  00a75	74 1d		 je	 SHORT $L71910

; 456  : 		{
; 457  : 			++pLts_t->psyl;

  00a77	66 ff 86 34 04
	00 00		 inc	 WORD PTR [esi+1076]
  00a7e	66 8b 86 34 04
	00 00		 mov	 ax, WORD PTR [esi+1076]
  00a85	0f bf 8e 30 04
	00 00		 movsx	 ecx, WORD PTR [esi+1072]
  00a8c	0f bf d0	 movsx	 edx, ax
  00a8f	49		 dec	 ecx
  00a90	3b d1		 cmp	 edx, ecx
  00a92	7c ce		 jl	 SHORT $L71909
$L71910:

; 458  : #if defined (VMS) || defined (LDS_BUILD)
; 459  : 			if (rflag != FALSE)
; 460  : 				printf("Impossible, shift right\n");
; 461  : #endif
; 462  : 		}
; 463  : #if defined (VMS) || defined (LDS_BUILD)
; 464  : 		if (rflag != FALSE)
; 465  : 			printf("Primary on sylable %d\n", pLts_t->psyl+1);
; 466  : #endif
; 467  : 		pLts_t->sylp[pLts_t->psyl]->p_stress = pstype;

  00a94	0f bf 86 34 04
	00 00		 movsx	 eax, WORD PTR [esi+1076]
  00a9b	8b 54 24 20	 mov	 edx, DWORD PTR _pstype$[esp+12]

; 468  : 		csyl = pLts_t->psyl+1;
; 469  : 		isreduced = TRUE;

  00a9f	bf 01 00 00 00	 mov	 edi, 1
  00aa4	8b 8c 86 08 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax*4+1032]
  00aab	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00aae	0f bf 8e 34 04
	00 00		 movsx	 ecx, WORD PTR [esi+1076]

; 470  : 		while (csyl < pLts_t->nsyl) 

  00ab5	0f bf 86 30 04
	00 00		 movsx	 eax, WORD PTR [esi+1072]
  00abc	41		 inc	 ecx
  00abd	3b c8		 cmp	 ecx, eax
  00abf	0f 8d ce 00 00
	00		 jge	 $L71899
  00ac5	8d 94 8e 08 04
	00 00		 lea	 edx, DWORD PTR [esi+ecx*4+1032]
  00acc	bb 79 00 00 00	 mov	 ebx, 121		; 00000079H
  00ad1	bd 80 00 00 00	 mov	 ebp, 128		; 00000080H
$L71912:

; 471  : 		{
; 472  : 			if (isreduced == FALSE) 

  00ad6	85 ff		 test	 edi, edi
  00ad8	75 11		 jne	 SHORT $L71914

; 473  : 			{
; 474  : 				if (pLts_t->sylp[csyl]->p_stress == SNONE)

  00ada	8b 02		 mov	 eax, DWORD PTR [edx]
  00adc	39 58 10	 cmp	 DWORD PTR [eax+16], ebx
  00adf	75 03		 jne	 SHORT $L71915

; 475  : 					pLts_t->sylp[csyl]->p_flag |= PFBLOCK;

  00ae1	09 68 0c	 or	 DWORD PTR [eax+12], ebp
$L71915:

; 476  : 				isreduced = TRUE;

  00ae4	bf 01 00 00 00	 mov	 edi, 1

; 477  : 			} 
; 478  : 			else

  00ae9	eb 02		 jmp	 SHORT $L71916
$L71914:

; 479  : 			{
; 480  : 				isreduced = FALSE;

  00aeb	33 ff		 xor	 edi, edi
$L71916:

; 481  : 			}
; 482  : 			if (pLts_t->sylp[csyl]->p_stress == SNONE)

  00aed	8b 02		 mov	 eax, DWORD PTR [edx]
  00aef	39 58 10	 cmp	 DWORD PTR [eax+16], ebx
  00af2	75 07		 jne	 SHORT $L71917

; 483  : 				pLts_t->sylp[csyl]->p_stress = SUN;

  00af4	c7 40 10 7a 00
	00 00		 mov	 DWORD PTR [eax+16], 122	; 0000007aH
$L71917:

; 470  : 		while (csyl < pLts_t->nsyl) 

  00afb	0f bf 86 30 04
	00 00		 movsx	 eax, WORD PTR [esi+1072]

; 484  : 			++csyl;

  00b02	41		 inc	 ecx
  00b03	83 c2 04	 add	 edx, 4
  00b06	3b c8		 cmp	 ecx, eax
  00b08	7c cc		 jl	 SHORT $L71912

; 515  : 	}
; 516  : 	ls_adju_final_fixes(pLts_t);

  00b0a	56		 push	 esi
  00b0b	e8 00 00 00 00	 call	 _ls_adju_final_fixes
  00b10	83 c4 04	 add	 esp, 4
  00b13	5f		 pop	 edi
  00b14	5e		 pop	 esi
  00b15	5d		 pop	 ebp
  00b16	5b		 pop	 ebx

; 517  : }

  00b17	c3		 ret	 0
$L71904:

; 485  : 		}
; 486  : 		ls_adju_final_fixes(pLts_t);
; 487  : 		return;
; 488  : 	}
; 489  : 	/* Revert to default rules. No or all refusing suffix.		*/
; 490  : 	ls_adju_bestdefault(pLts_t);

  00b18	56		 push	 esi
  00b19	e8 00 00 00 00	 call	 _ls_adju_bestdefault

; 491  : #if defined (VMS) || defined (LDS_BUILD)
; 492  : 	if (rflag != FALSE)
; 493  : 		printf("Best default on sylable %d\n", pLts_t->psyl+1);
; 494  : #endif
; 495  : 	pLts_t->sylp[pLts_t->psyl]->p_stress = pstype;

  00b1e	0f bf 8e 34 04
	00 00		 movsx	 ecx, WORD PTR [esi+1076]
  00b25	8b 44 24 24	 mov	 eax, DWORD PTR _pstype$[esp+16]
  00b29	83 c4 04	 add	 esp, 4
  00b2c	8b 94 8e 08 04
	00 00		 mov	 edx, DWORD PTR [esi+ecx*4+1032]

; 496  : 	csyl = pLts_t->psyl+1;
; 497  : 	isreduced = TRUE;

  00b33	bf 01 00 00 00	 mov	 edi, 1
  00b38	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00b3b	0f bf 8e 34 04
	00 00		 movsx	 ecx, WORD PTR [esi+1076]

; 498  : 	while (csyl < pLts_t->nsyl) 

  00b42	0f bf 96 30 04
	00 00		 movsx	 edx, WORD PTR [esi+1072]
  00b49	41		 inc	 ecx
  00b4a	3b ca		 cmp	 ecx, edx
  00b4c	7d 45		 jge	 SHORT $L71899
  00b4e	8d 94 8e 08 04
	00 00		 lea	 edx, DWORD PTR [esi+ecx*4+1032]
  00b55	bb 79 00 00 00	 mov	 ebx, 121		; 00000079H
  00b5a	bd 80 00 00 00	 mov	 ebp, 128		; 00000080H
$L71919:

; 499  : 	{
; 500  : 		if (isreduced == FALSE) 

  00b5f	85 ff		 test	 edi, edi
  00b61	75 11		 jne	 SHORT $L71921

; 501  : 		{
; 502  : 			if (pLts_t->sylp[csyl]->p_stress == SNONE)

  00b63	8b 02		 mov	 eax, DWORD PTR [edx]
  00b65	39 58 10	 cmp	 DWORD PTR [eax+16], ebx
  00b68	75 03		 jne	 SHORT $L71922

; 503  : 				pLts_t->sylp[csyl]->p_flag |= PFBLOCK;

  00b6a	09 68 0c	 or	 DWORD PTR [eax+12], ebp
$L71922:

; 504  : 			isreduced = TRUE;

  00b6d	bf 01 00 00 00	 mov	 edi, 1

; 505  : 		} 
; 506  : 		else

  00b72	eb 02		 jmp	 SHORT $L71923
$L71921:

; 507  : 		{
; 508  : 			isreduced = FALSE;

  00b74	33 ff		 xor	 edi, edi
$L71923:

; 509  : 		}
; 510  : 		if (pLts_t->sylp[csyl]->p_stress == SNONE)

  00b76	8b 02		 mov	 eax, DWORD PTR [edx]
  00b78	39 58 10	 cmp	 DWORD PTR [eax+16], ebx
  00b7b	75 07		 jne	 SHORT $L71924

; 511  : 		{
; 512  : 			pLts_t->sylp[csyl]->p_stress = SUN;

  00b7d	c7 40 10 7a 00
	00 00		 mov	 DWORD PTR [eax+16], 122	; 0000007aH
$L71924:

; 498  : 	while (csyl < pLts_t->nsyl) 

  00b84	0f bf 86 30 04
	00 00		 movsx	 eax, WORD PTR [esi+1072]

; 513  : 		}
; 514  : 		++csyl;

  00b8b	41		 inc	 ecx
  00b8c	83 c2 04	 add	 edx, 4
  00b8f	3b c8		 cmp	 ecx, eax
  00b91	7c cc		 jl	 SHORT $L71919
$L71899:

; 515  : 	}
; 516  : 	ls_adju_final_fixes(pLts_t);

  00b93	56		 push	 esi
  00b94	e8 00 00 00 00	 call	 _ls_adju_final_fixes
  00b99	83 c4 04	 add	 esp, 4
$L71861:
  00b9c	5f		 pop	 edi
  00b9d	5e		 pop	 esi
  00b9e	5d		 pop	 ebp
  00b9f	5b		 pop	 ebx

; 517  : }

  00ba0	c3		 ret	 0
  00ba1	8d 49 00	 npad	 3
$L72151:
  00ba4	00 00 00 00	 DD	 $L71877
  00ba8	00 00 00 00	 DD	 $L71878
  00bac	00 00 00 00	 DD	 $L71874
  00bb0	00 00 00 00	 DD	 $L71879
  00bb4	00 00 00 00	 DD	 $L71880
  00bb8	00 00 00 00	 DD	 $L71882
  00bbc	00 00 00 00	 DD	 $L71881
_ls_adju_stress ENDP
_pLts_t$ = 8
_n$ = 12
_ls_adju_unstressed PROC NEAR

; 541  : 	 PHONE	*pp;
; 542  : 	 int	sphone;
; 543  : 
; 544  : 	pp = pLts_t->sylp[n];

  00bc0	8b 44 24 08	 mov	 eax, DWORD PTR _n$[esp-4]
  00bc4	8b 4c 24 04	 mov	 ecx, DWORD PTR _pLts_t$[esp-4]
  00bc8	56		 push	 esi
  00bc9	8b b4 81 08 04
	00 00		 mov	 esi, DWORD PTR [ecx+eax*4+1032]

; 545  : 	while (ls_adju_is_cons(pp) != FALSE)

  00bd0	56		 push	 esi
  00bd1	e8 00 00 00 00	 call	 _ls_adju_is_cons
  00bd6	83 c4 04	 add	 esp, 4
  00bd9	85 c0		 test	 eax, eax
  00bdb	74 0f		 je	 SHORT $L71934
$L71933:

; 546  : 		pp = pp->p_fp;

  00bdd	8b 36		 mov	 esi, DWORD PTR [esi]
  00bdf	56		 push	 esi
  00be0	e8 00 00 00 00	 call	 _ls_adju_is_cons
  00be5	83 c4 04	 add	 esp, 4
  00be8	85 c0		 test	 eax, eax
  00bea	75 f1		 jne	 SHORT $L71933
$L71934:

; 547  : 	sphone = pp->p_sphone;
; 548  : #ifdef ENGLISH
; 549  : 	if (sphone ==EL)

  00bec	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00bef	33 c0		 xor	 eax, eax
  00bf1	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00bf4	5e		 pop	 esi
  00bf5	0f 94 c0	 sete	 al

; 550  : #endif
; 551  : #ifdef GERMAN
; 552  :         if (sphone ==L)
; 553  : #endif	
; 554  : 		return (TRUE);
; 555  : 	return (FALSE);
; 556  : }

  00bf8	c3		 ret	 0
_ls_adju_unstressed ENDP
_pLts_t$ = 8
_fpp$ = 12
_lpp$ = 16
_ls_adju_suffixscan PROC NEAR

; 584  : 	 PHONE	*pp;
; 585  : 
; 586  : 	pLts_t->nsyl =  0;

  00c00	8b 44 24 04	 mov	 eax, DWORD PTR _pLts_t$[esp-4]

; 587  : 	pLts_t->rsyl = -1;

  00c04	83 c9 ff	 or	 ecx, -1
  00c07	56		 push	 esi

; 588  : 	pLts_t->psyl = -1;
; 589  : 	pp = fpp;
; 590  : 	while (pp != lpp) 

  00c08	8b 74 24 10	 mov	 esi, DWORD PTR _lpp$[esp]
  00c0c	66 89 88 32 04
	00 00		 mov	 WORD PTR [eax+1074], cx
  00c13	66 89 88 34 04
	00 00		 mov	 WORD PTR [eax+1076], cx
  00c1a	8b 4c 24 0c	 mov	 ecx, DWORD PTR _fpp$[esp]
  00c1e	66 c7 80 30 04
	00 00 00 00	 mov	 WORD PTR [eax+1072], 0
  00c27	3b ce		 cmp	 ecx, esi
  00c29	74 58		 je	 SHORT $L71946
$L71945:

; 591  : 	{
; 592  : 		if ((pp->p_flag&PFSYLAB) != 0) 

  00c2b	f6 41 0c 10	 test	 BYTE PTR [ecx+12], 16	; 00000010H
  00c2f	74 4c		 je	 SHORT $L71947

; 593  : 		{
; 594  : 			if (pLts_t->nsyl >= NSYL)

  00c31	66 8b 90 30 04
	00 00		 mov	 dx, WORD PTR [eax+1072]
  00c38	66 83 fa 0a	 cmp	 dx, 10			; 0000000aH
  00c3c	7d 64		 jge	 SHORT $L72157

; 596  : 			if (pp->p_stress != SNONE) 

  00c3e	83 79 10 79	 cmp	 DWORD PTR [ecx+16], 121	; 00000079H
  00c42	74 28		 je	 SHORT $L71951

; 597  : 			{
; 598  : 				if (pLts_t->rsyl < 0)

  00c44	66 83 b8 32 04
	00 00 00	 cmp	 WORD PTR [eax+1074], 0
  00c4c	7d 07		 jge	 SHORT $L71950

; 599  : 					pLts_t->rsyl = pLts_t->nsyl;

  00c4e	66 89 90 32 04
	00 00		 mov	 WORD PTR [eax+1074], dx
$L71950:

; 600  : 				if (pLts_t->psyl<0 && pp->p_stress>=SPRI)

  00c55	66 83 b8 34 04
	00 00 00	 cmp	 WORD PTR [eax+1076], 0
  00c5d	7d 0d		 jge	 SHORT $L71951
  00c5f	83 79 10 7c	 cmp	 DWORD PTR [ecx+16], 124	; 0000007cH
  00c63	7c 07		 jl	 SHORT $L71951

; 601  : 					pLts_t->psyl = pLts_t->nsyl;

  00c65	66 89 90 34 04
	00 00		 mov	 WORD PTR [eax+1076], dx
$L71951:

; 602  : 			}
; 603  : 			pLts_t->sylp[pLts_t->nsyl++] = pp;

  00c6c	0f bf d2	 movsx	 edx, dx
  00c6f	89 8c 90 08 04
	00 00		 mov	 DWORD PTR [eax+edx*4+1032], ecx
  00c76	66 ff 80 30 04
	00 00		 inc	 WORD PTR [eax+1072]
$L71947:

; 604  : 		}
; 605  : 		pp = pp->p_fp;

  00c7d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00c7f	3b ce		 cmp	 ecx, esi
  00c81	75 a8		 jne	 SHORT $L71945
$L71946:

; 606  : 	}
; 607  : 	if (pLts_t->rsyl < 0)

  00c83	66 83 b8 32 04
	00 00 00	 cmp	 WORD PTR [eax+1074], 0
  00c8b	7d 0e		 jge	 SHORT $L71952

; 608  : 		pLts_t->rsyl = pLts_t->nsyl;

  00c8d	66 8b 88 30 04
	00 00		 mov	 cx, WORD PTR [eax+1072]
  00c94	66 89 88 32 04
	00 00		 mov	 WORD PTR [eax+1074], cx
$L71952:

; 609  : 	return (TRUE);

  00c9b	b8 01 00 00 00	 mov	 eax, 1
  00ca0	5e		 pop	 esi

; 610  : }

  00ca1	c3		 ret	 0
$L72157:

; 595  : 				return (FALSE);

  00ca2	33 c0		 xor	 eax, eax
  00ca4	5e		 pop	 esi

; 610  : }

  00ca5	c3		 ret	 0
_ls_adju_suffixscan ENDP
_TEXT	ENDS
EXTRN	_preftab:BYTE
_TEXT	SEGMENT
_phTTS$ = 8
_fpp$ = 12
_lpp$ = 16
_lang_tag$ = 20
_pp1$ = 12
_csyl$ = 8
_pLts_t$ = -8
_ls_adju_prefixscan PROC NEAR

; 635  : {

  00cb0	83 ec 08	 sub	 esp, 8

; 636  : 
; 637  : 	 PHONE	*pp1;
; 638  : 	 PHONE	*pp2;
; 639  : 	 int	i;
; 640  : 	 int	len;
; 641  : 	 int	csyl;
; 642  : 	char	*ptp;
; 643  : 	PLTS_T	pLts_t;
; 644  : 	PKSD_T  pKsd_t;
; 645  : 	pKsd_t = phTTS->pKernelShareData;
; 646  : 	pLts_t=phTTS->pLTSThreadData;

  00cb3	8b 44 24 0c	 mov	 eax, DWORD PTR _phTTS$[esp+4]

; 647  : 
; 648  : 	pp1  = fpp;					/* Start of the word.	*/

  00cb7	8b 4c 24 10	 mov	 ecx, DWORD PTR _fpp$[esp+4]
  00cbb	53		 push	 ebx
  00cbc	55		 push	 ebp
  00cbd	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00cc0	56		 push	 esi
  00cc1	57		 push	 edi
  00cc2	89 44 24 10	 mov	 DWORD PTR _pLts_t$[esp+24], eax

; 649  : 	csyl = 0;					/* Sylable count.		*/
; 650  : loop:
; 651  : 	if (csyl >= pLts_t->nsyl-1)	/* No sylables.			*/

  00cc6	0f bf 90 30 04
	00 00		 movsx	 edx, WORD PTR [eax+1072]
  00ccd	4a		 dec	 edx
  00cce	89 4c 24 20	 mov	 DWORD PTR _pp1$[esp+20], ecx
  00cd2	85 d2		 test	 edx, edx
  00cd4	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _csyl$[esp+20], 0
  00cdc	0f 8e 8e 01 00
	00		 jle	 $L72164
  00ce2	8b 5c 24 24	 mov	 ebx, DWORD PTR _lpp$[esp+20]
  00ce6	05 08 04 00 00	 add	 eax, 1032		; 00000408H
  00ceb	89 44 24 14	 mov	 DWORD PTR -4+[esp+24], eax
$loop$71970:

; 652  : 		return (TRUE);
; 653  : 	ptp = &preftab[0];

  00cef	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_preftab
$L71973:

; 654  : #ifdef ACNA      
; 655  : 	while ((len = ptp[1]&PLENGTH) != 0) 

  00cf4	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00cf7	83 e0 0f	 and	 eax, 15			; 0000000fH
  00cfa	8b e8		 mov	 ebp, eax
  00cfc	0f 84 05 01 00
	00		 je	 $L71974

; 656  : #else
; 657  : 	while ((len = ptp[0]&PLENGTH) != 0) 
; 658  : #endif
; 659  : 	{
; 660  : #ifdef ACNA
; 661  : 		/*
; 662  : 		 * PRG	23-NOV-1988
; 663  : 		 * BEGINNING OF MODIFICATION - skip the prefix if it is
; 664  : 		 * marked IRISH and the scan is not being done for an
; 665  : 		 * IRISH word (i.e. the IRISH flag is not set).
; 666  : 		 *
; 667  : 		 * PRG	15-DEC-1988
; 668  : 		 * Modified the following to handle arbitrary names, not
; 669  : 		 * just IRISH ones.
; 670  : 		 */
; 671  : 
; 672  : 		if (ptp[0] != -1)

  00d02	8a 07		 mov	 al, BYTE PTR [edi]
  00d04	3c ff		 cmp	 al, -1
  00d06	74 0f		 je	 SHORT $L71976

; 673  : 		{
; 674  : 			if (ptp[0] != lang_tag)

  00d08	0f be c8	 movsx	 ecx, al
  00d0b	3b 4c 24 28	 cmp	 ecx, DWORD PTR _lang_tag$[esp+20]
  00d0f	74 06		 je	 SHORT $L71976

; 675  : 		   	{
; 676  : 		   		ptp += len+2;

  00d11	8d 7c 2f 02	 lea	 edi, DWORD PTR [edi+ebp+2]

; 677  : 		  		continue;

  00d15	eb dd		 jmp	 SHORT $L71973
$L71976:

; 678  : 		   	}
; 679  : 		}
; 680  : 		ptp++;
; 681  : 
; 682  : 		/*
; 683  : 		 * END OF MODIFICATION.
; 684  : 		 */
; 685  : 
; 686  : #endif /* #ifdef ACNA */
; 687  : 		pp2 = pp1;

  00d17	8b 74 24 20	 mov	 esi, DWORD PTR _pp1$[esp+20]

; 688  : 		for (i=0; i<len; ++i) 

  00d1b	33 c0		 xor	 eax, eax
  00d1d	85 ed		 test	 ebp, ebp
  00d1f	7e 15		 jle	 SHORT $L72163
$L71977:

; 689  : 		{		/* Compare loop.	*/
; 690  : 			if (pp2==lpp || pp2->p_sphone!=ptp[i+1])

  00d21	3b f3		 cmp	 esi, ebx
  00d23	74 11		 je	 SHORT $L72163
  00d25	0f be 54 38 02	 movsx	 edx, BYTE PTR [eax+edi+2]
  00d2a	39 56 14	 cmp	 DWORD PTR [esi+20], edx
  00d2d	75 07		 jne	 SHORT $L72163

; 691  : 				break;
; 692  : 			pp2 = pp2->p_fp;

  00d2f	8b 36		 mov	 esi, DWORD PTR [esi]
  00d31	40		 inc	 eax
  00d32	3b c5		 cmp	 eax, ebp
  00d34	7c eb		 jl	 SHORT $L71977
$L72163:

; 693  : 		}
; 694  : 		if (i != len) 

  00d36	3b c5		 cmp	 eax, ebp
  00d38	74 06		 je	 SHORT $L71982

; 695  : 		{			/* Failed.		*/
; 696  : 			ptp += len+1;

  00d3a	8d 7c 2f 02	 lea	 edi, DWORD PTR [edi+ebp+2]

; 697  : 			continue;

  00d3e	eb b4		 jmp	 SHORT $L71973
$L71982:

; 698  : 		}
; 699  : #ifdef ENGLISH
; 700  : 		/* The "pp2" is pointing beyond the match. You cannot	*/
; 701  : 		/* bite off a prefix and create an illegal cluster at	*/
; 702  : 		/* the start of the sylable. An example of a word that	*/
; 703  : 		/* is blocked by this rule is "rectilinear".			*/
; 704  : 		if (pp2!=lpp && (pp2->p_flag&PFLEFTC)==0) 

  00d40	3b f3		 cmp	 esi, ebx
  00d42	74 0c		 je	 SHORT $L71983
  00d44	f6 46 0c 40	 test	 BYTE PTR [esi+12], 64	; 00000040H
  00d48	75 06		 jne	 SHORT $L71983

; 705  : 		{
; 706  : 			ptp += len+1;

  00d4a	8d 7c 2f 02	 lea	 edi, DWORD PTR [edi+ebp+2]

; 707  : 			continue;

  00d4e	eb a4		 jmp	 SHORT $L71973
$L71983:

; 708  : 		}
; 709  : 		if ((ptp[0]&PRCON)!=0 && (pp2==lpp || ls_adju_is_cons(pp2)==FALSE)) 

  00d50	f6 47 01 20	 test	 BYTE PTR [edi+1], 32	; 00000020H
  00d54	74 17		 je	 SHORT $L71984
  00d56	3b f3		 cmp	 esi, ebx
  00d58	74 0d		 je	 SHORT $L71985
  00d5a	56		 push	 esi
  00d5b	e8 00 00 00 00	 call	 _ls_adju_is_cons
  00d60	83 c4 04	 add	 esp, 4
  00d63	85 c0		 test	 eax, eax
  00d65	75 06		 jne	 SHORT $L71984
$L71985:

; 710  : 		{
; 711  : 			ptp += len+1;

  00d67	8d 7c 2f 02	 lea	 edi, DWORD PTR [edi+ebp+2]

; 712  : 			continue;

  00d6b	eb 87		 jmp	 SHORT $L71973
$L71984:

; 713  : 		}
; 714  : 		if ((ptp[0]&PRVOC)!=0 && (pp2==lpp ||  ls_adju_is_voc(pp2)==FALSE)) 

  00d6d	f6 47 01 40	 test	 BYTE PTR [edi+1], 64	; 00000040H
  00d71	74 1a		 je	 SHORT $L71986
  00d73	3b f3		 cmp	 esi, ebx
  00d75	74 0d		 je	 SHORT $L71987
  00d77	56		 push	 esi
  00d78	e8 00 00 00 00	 call	 _ls_adju_is_voc
  00d7d	83 c4 04	 add	 esp, 4
  00d80	85 c0		 test	 eax, eax
  00d82	75 09		 jne	 SHORT $L71986
$L71987:

; 715  : 		{
; 716  : 			ptp += len+1;

  00d84	8d 7c 2f 02	 lea	 edi, DWORD PTR [edi+ebp+2]

; 717  : 			continue;

  00d88	e9 67 ff ff ff	 jmp	 $L71973
$L71986:

; 718  : 		}
; 719  : #endif
; 720  : 		pLts_t->sylp[csyl]->p_flag |= PFRFUSE;	/* Mark refuse.		*/

  00d8d	8b 54 24 14	 mov	 edx, DWORD PTR -4+[esp+24]
  00d91	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00d96	8b 02		 mov	 eax, DWORD PTR [edx]

; 721  : 		++csyl;

  00d98	83 c2 04	 add	 edx, 4
  00d9b	89 54 24 14	 mov	 DWORD PTR -4+[esp+24], edx
  00d9f	8b 68 0c	 mov	 ebp, DWORD PTR [eax+12]
  00da2	0b e9		 or	 ebp, ecx
  00da4	89 68 0c	 mov	 DWORD PTR [eax+12], ebp
  00da7	8b 6c 24 1c	 mov	 ebp, DWORD PTR _csyl$[esp+20]

; 722  : 		if ((ptp[0]&P2SYL) != 0		/* If 2 syl. prefix and	*/
; 723  : 		&& csyl < pLts_t->nsyl-1) 

  00dab	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00dae	45		 inc	 ebp
  00daf	a8 80		 test	 al, 128			; 00000080H
  00db1	89 6c 24 1c	 mov	 DWORD PTR _csyl$[esp+20], ebp
  00db5	74 21		 je	 SHORT $L71988
  00db7	8b 44 24 10	 mov	 eax, DWORD PTR _pLts_t$[esp+24]
  00dbb	0f bf 80 30 04
	00 00		 movsx	 eax, WORD PTR [eax+1072]
  00dc2	48		 dec	 eax
  00dc3	3b e8		 cmp	 ebp, eax
  00dc5	7d 11		 jge	 SHORT $L71988

; 724  : 		{							/* some root remains.	*/
; 725  : 			pLts_t->sylp[csyl]->p_flag |= PFRFUSE;

  00dc7	8b 02		 mov	 eax, DWORD PTR [edx]
  00dc9	09 48 0c	 or	 DWORD PTR [eax+12], ecx

; 726  : 			++csyl;

  00dcc	45		 inc	 ebp
  00dcd	83 c2 04	 add	 edx, 4
  00dd0	89 6c 24 1c	 mov	 DWORD PTR _csyl$[esp+20], ebp
  00dd4	89 54 24 14	 mov	 DWORD PTR -4+[esp+24], edx
$L71988:

; 727  : 		}
; 728  : 		if ((ptp[0]&PCONT) == 0)	/* Stop the scan.	*/

  00dd8	f6 47 01 10	 test	 BYTE PTR [edi+1], 16	; 00000010H
  00ddc	0f 84 8e 00 00
	00		 je	 $L72164
  00de2	8b 4c 24 10	 mov	 ecx, DWORD PTR _pLts_t$[esp+24]

; 729  : 			return (TRUE);
; 730  : 		pp1 = pp2;					/* Advance.			*/

  00de6	89 74 24 20	 mov	 DWORD PTR _pp1$[esp+20], esi
  00dea	0f bf 91 30 04
	00 00		 movsx	 edx, WORD PTR [ecx+1072]
  00df1	4a		 dec	 edx
  00df2	3b ea		 cmp	 ebp, edx
  00df4	0f 8c f5 fe ff
	ff		 jl	 $loop$71970
  00dfa	5f		 pop	 edi
  00dfb	5e		 pop	 esi
  00dfc	5d		 pop	 ebp

; 745  : 	}        
; 746  : #endif	
; 747  : 	return (TRUE);

  00dfd	b8 01 00 00 00	 mov	 eax, 1
  00e02	5b		 pop	 ebx

; 748  : }

  00e03	83 c4 08	 add	 esp, 8
  00e06	c3		 ret	 0
$L71974:

; 731  : 		goto loop;		
; 732  : 	}
; 733  : 	if (csyl >= pLts_t->nsyl-1)		/* No sylables.		*/

  00e07	8b 44 24 10	 mov	 eax, DWORD PTR _pLts_t$[esp+24]
  00e0b	0f bf 88 30 04
	00 00		 movsx	 ecx, WORD PTR [eax+1072]
  00e12	8b 44 24 1c	 mov	 eax, DWORD PTR _csyl$[esp+20]
  00e16	49		 dec	 ecx
  00e17	3b c1		 cmp	 eax, ecx

; 734  : 		return (TRUE);

  00e19	7d 55		 jge	 SHORT $L72164

; 735  : #ifdef ENGLISH		
; 736  : 	if (pp1 != lpp					/* V-C1-C2 case.	*/
; 737  : 	&& ls_adju_is_voc(pp1) != FALSE
; 738  : 	&& (pp1=pp1->p_fp) != lpp
; 739  : 	&& ls_adju_is_cons(pp1) != FALSE
; 740  : 	&& (pp2=pp1->p_fp) != lpp
; 741  : 	&& (pp2->p_flag&PFSYLAB) != 0
; 742  : 	&& pp1->p_sphone == pp2->p_sphone)

  00e1b	8b 44 24 20	 mov	 eax, DWORD PTR _pp1$[esp+20]
  00e1f	3b c3		 cmp	 eax, ebx
  00e21	74 4d		 je	 SHORT $L72164
  00e23	50		 push	 eax
  00e24	e8 00 00 00 00	 call	 _ls_adju_is_voc
  00e29	83 c4 04	 add	 esp, 4
  00e2c	85 c0		 test	 eax, eax
  00e2e	74 40		 je	 SHORT $L72164
  00e30	8b 54 24 20	 mov	 edx, DWORD PTR _pp1$[esp+20]
  00e34	8b 32		 mov	 esi, DWORD PTR [edx]
  00e36	3b f3		 cmp	 esi, ebx
  00e38	74 36		 je	 SHORT $L72164
  00e3a	56		 push	 esi
  00e3b	e8 00 00 00 00	 call	 _ls_adju_is_cons
  00e40	83 c4 04	 add	 esp, 4
  00e43	85 c0		 test	 eax, eax
  00e45	74 29		 je	 SHORT $L72164
  00e47	8b 06		 mov	 eax, DWORD PTR [esi]
  00e49	3b c3		 cmp	 eax, ebx
  00e4b	74 23		 je	 SHORT $L72164
  00e4d	f6 40 0c 10	 test	 BYTE PTR [eax+12], 16	; 00000010H
  00e51	74 1d		 je	 SHORT $L72164
  00e53	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00e56	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00e59	3b ca		 cmp	 ecx, edx
  00e5b	75 13		 jne	 SHORT $L72164

; 743  : 	{	
; 744  : 		pLts_t->sylp[csyl]->p_flag |= PFRFUSE;

  00e5d	8b 54 24 10	 mov	 edx, DWORD PTR _pLts_t$[esp+24]
  00e61	8b 44 24 1c	 mov	 eax, DWORD PTR _csyl$[esp+20]
  00e65	8b 84 82 08 04
	00 00		 mov	 eax, DWORD PTR [edx+eax*4+1032]
  00e6c	83 48 0c 20	 or	 DWORD PTR [eax+12], 32	; 00000020H
$L72164:
  00e70	5f		 pop	 edi
  00e71	5e		 pop	 esi
  00e72	5d		 pop	 ebp

; 745  : 	}        
; 746  : #endif	
; 747  : 	return (TRUE);

  00e73	b8 01 00 00 00	 mov	 eax, 1
  00e78	5b		 pop	 ebx

; 748  : }

  00e79	83 c4 08	 add	 esp, 8
  00e7c	c3		 ret	 0
_ls_adju_prefixscan ENDP
_TEXT	ENDS
PUBLIC	_ls_adju_best2syl
_TEXT	SEGMENT
_pLts_t$ = 8
_ls_adju_bestdefault PROC NEAR

; 773  : {                       

  00e80	56		 push	 esi

; 774  : #ifdef ENGLISH
; 775  : 	switch (pLts_t->rsyl) 
; 776  : 	{

  00e81	8b 74 24 08	 mov	 esi, DWORD PTR _pLts_t$[esp]
  00e85	66 8b 8e 32 04
	00 00		 mov	 cx, WORD PTR [esi+1074]
  00e8c	0f bf c1	 movsx	 eax, cx
  00e8f	83 f8 03	 cmp	 eax, 3
  00e92	77 47		 ja	 SHORT $L72003
  00e94	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L72174[eax*4]
$L71999:

; 777  : 		case 0:					/* Crap.		*/
; 778  : 		case 1:					/* 1 sylables.		*/
; 779  : 			pLts_t->psyl = 0;

  00e9b	66 c7 86 34 04
	00 00 00 00	 mov	 WORD PTR [esi+1076], 0
  00ea4	5e		 pop	 esi

; 812  : 			break;
; 813  : 	}       
; 814  : #endif
; 815  : #ifdef GERMAN
; 816  :         pLts_t->psyl = 0;
; 817  : #endif	
; 818  : 	/* return (0); */	/* return value not used */
; 819  : }

  00ea5	c3		 ret	 0
$L72000:

; 780  : 			break;
; 781  : 
; 782  : 		case 2:					/* 2 sylables.		*/
; 783  : 			ls_adju_best2syl(pLts_t);

  00ea6	56		 push	 esi
  00ea7	e8 00 00 00 00	 call	 _ls_adju_best2syl
  00eac	83 c4 04	 add	 esp, 4
  00eaf	5e		 pop	 esi

; 812  : 			break;
; 813  : 	}       
; 814  : #endif
; 815  : #ifdef GERMAN
; 816  :         pLts_t->psyl = 0;
; 817  : #endif	
; 818  : 	/* return (0); */	/* return value not used */
; 819  : }

  00eb0	c3		 ret	 0
$L72001:

; 784  : 			break;
; 785  : 
; 786  : 		case 3:					/* 3 sylables.		*/
; 787  : 			pLts_t->psyl = 0;
; 788  : 			if (ls_adju_is_cons(pLts_t->sylp[2]->p_bp) != FALSE)

  00eb1	8b 86 10 04 00
	00		 mov	 eax, DWORD PTR [esi+1040]
  00eb7	66 c7 86 34 04
	00 00 00 00	 mov	 WORD PTR [esi+1076], 0
  00ec0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00ec3	51		 push	 ecx
  00ec4	e8 00 00 00 00	 call	 _ls_adju_is_cons
  00ec9	83 c4 04	 add	 esp, 4
  00ecc	85 c0		 test	 eax, eax
  00ece	74 3b		 je	 SHORT $L72005

; 789  : 				pLts_t->psyl = 1;

  00ed0	66 c7 86 34 04
	00 00 01 00	 mov	 WORD PTR [esi+1076], 1
  00ed9	5e		 pop	 esi

; 812  : 			break;
; 813  : 	}       
; 814  : #endif
; 815  : #ifdef GERMAN
; 816  :         pLts_t->psyl = 0;
; 817  : #endif	
; 818  : 	/* return (0); */	/* return value not used */
; 819  : }

  00eda	c3		 ret	 0
$L72003:

; 790  : 			break;
; 791  : 
; 792  : 		default:				/* 4 or more sylables.	*/
; 793  : 			/* NCS    01/30/1997
; 794  : 			 * This is a little patch to fix the problem of the misplacement of the stress
; 795  : 			 * marker.  Words ending in "ia" would have the stress on the end in stead of
; 796  : 			 * the proper location.
; 797  : 			 *
; 798  : 			 * You can see in the following if statement that the phoneme are checked for
; 799  : 			 * "ia".  And if this is true, the stress is placed BEFORE this spot.
; 800  : 			 * That is why this check is placed in the "4 or more sylables" section.
; 801  : 			 *
; 802  : 			 * But, the first check statement in the if check
; 803  : 			 * you should see that the pointers used p_bp which checks
; 804  : 			 * for the second to last phoneme.  This is the only way to properly find out if
; 805  : 			 * the word ends in "ia" (IYAX).
; 806  : 			 */
; 807  : 			if ((pLts_t->sylp[pLts_t->rsyl-1])->p_bp->p_sphone == IY &&
; 808  : 				pLts_t->sylp[pLts_t->rsyl-1]->p_sphone == AX)

  00edb	8b 84 86 04 04
	00 00		 mov	 eax, DWORD PTR [esi+eax*4+1028]
  00ee2	57		 push	 edi
  00ee3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00ee6	8b 7a 14	 mov	 edi, DWORD PTR [edx+20]
  00ee9	83 ff 01	 cmp	 edi, 1
  00eec	5f		 pop	 edi
  00eed	75 12		 jne	 SHORT $L72004
  00eef	83 78 14 11	 cmp	 DWORD PTR [eax+20], 17	; 00000011H
  00ef3	75 0c		 jne	 SHORT $L72004

; 809  : 				pLts_t->psyl = pLts_t->rsyl-3;

  00ef5	83 c1 fd	 add	 ecx, -3			; fffffffdH

; 810  : 			else
; 811  : 				pLts_t->psyl = pLts_t->rsyl-2;

  00ef8	66 89 8e 34 04
	00 00		 mov	 WORD PTR [esi+1076], cx
  00eff	5e		 pop	 esi

; 812  : 			break;
; 813  : 	}       
; 814  : #endif
; 815  : #ifdef GERMAN
; 816  :         pLts_t->psyl = 0;
; 817  : #endif	
; 818  : 	/* return (0); */	/* return value not used */
; 819  : }

  00f00	c3		 ret	 0
$L72004:

; 810  : 			else
; 811  : 				pLts_t->psyl = pLts_t->rsyl-2;

  00f01	83 c1 fe	 add	 ecx, -2			; fffffffeH
  00f04	66 89 8e 34 04
	00 00		 mov	 WORD PTR [esi+1076], cx
$L72005:
  00f0b	5e		 pop	 esi

; 812  : 			break;
; 813  : 	}       
; 814  : #endif
; 815  : #ifdef GERMAN
; 816  :         pLts_t->psyl = 0;
; 817  : #endif	
; 818  : 	/* return (0); */	/* return value not used */
; 819  : }

  00f0c	c3		 ret	 0
  00f0d	8d 49 00	 npad	 3
$L72174:
  00f10	00 00 00 00	 DD	 $L71999
  00f14	00 00 00 00	 DD	 $L71999
  00f18	00 00 00 00	 DD	 $L72000
  00f1c	00 00 00 00	 DD	 $L72001
_ls_adju_bestdefault ENDP
_pLts_t$ = 8
_ls_adju_best2syl PROC NEAR

; 840  : {

  00f20	53		 push	 ebx

; 841  : 	 PHONE	*pp;
; 842  : 	 int	ph;
; 843  : 
; 844  : 	pp = pLts_t->sylp[0];

  00f21	8b 5c 24 08	 mov	 ebx, DWORD PTR _pLts_t$[esp]
  00f25	56		 push	 esi
  00f26	57		 push	 edi
  00f27	8b b3 08 04 00
	00		 mov	 esi, DWORD PTR [ebx+1032]

; 845  : 	ph = pp->p_sphone;

  00f2d	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]

; 846  : 	/* Never stress [@] if initial sylable, like "abridge".		*/
; 847  : 	if (ph==AE && (pp->p_fp->p_flag&PFSYLAB)!=0) 

  00f30	83 ff 05	 cmp	 edi, 5
  00f33	75 15		 jne	 SHORT $L72011
  00f35	8b 06		 mov	 eax, DWORD PTR [esi]
  00f37	f6 40 0c 10	 test	 BYTE PTR [eax+12], 16	; 00000010H
  00f3b	74 0d		 je	 SHORT $L72011
  00f3d	5f		 pop	 edi

; 848  : 	{
; 849  : 		pLts_t->psyl = 1;

  00f3e	66 c7 83 34 04
	00 00 01 00	 mov	 WORD PTR [ebx+1076], 1
  00f47	5e		 pop	 esi
  00f48	5b		 pop	 ebx

; 865  : }

  00f49	c3		 ret	 0
$L72011:

; 850  : 		return;
; 851  : 	}
; 852  : 	/* Never stress [@], [E], [I], [^] in initial VCC sylable.	*/
; 853  : 	if (ls_adju_is_voc(pp) != FALSE
; 854  : 	&& ls_adju_is_cons(pp->p_fp) != FALSE
; 855  : 	&& ls_adju_is_cons(pp->p_fp->p_fp) != FALSE) 

  00f4a	56		 push	 esi
  00f4b	e8 00 00 00 00	 call	 _ls_adju_is_voc
  00f50	83 c4 04	 add	 esp, 4
  00f53	85 c0		 test	 eax, eax
  00f55	74 41		 je	 SHORT $L72013
  00f57	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00f59	51		 push	 ecx
  00f5a	e8 00 00 00 00	 call	 _ls_adju_is_cons
  00f5f	83 c4 04	 add	 esp, 4
  00f62	85 c0		 test	 eax, eax
  00f64	74 32		 je	 SHORT $L72013
  00f66	8b 16		 mov	 edx, DWORD PTR [esi]
  00f68	8b 02		 mov	 eax, DWORD PTR [edx]
  00f6a	50		 push	 eax
  00f6b	e8 00 00 00 00	 call	 _ls_adju_is_cons
  00f70	83 c4 04	 add	 esp, 4
  00f73	85 c0		 test	 eax, eax
  00f75	74 21		 je	 SHORT $L72013

; 856  : 	{
; 857  : 		if (ph==AE || ph==EH || ph==IH || ph==AH) 

  00f77	83 ff 05	 cmp	 edi, 5
  00f7a	74 0f		 je	 SHORT $L72014
  00f7c	83 ff 04	 cmp	 edi, 4
  00f7f	74 0a		 je	 SHORT $L72014
  00f81	83 ff 02	 cmp	 edi, 2
  00f84	74 05		 je	 SHORT $L72014
  00f86	83 ff 09	 cmp	 edi, 9
  00f89	75 0d		 jne	 SHORT $L72013
$L72014:
  00f8b	5f		 pop	 edi

; 858  : 		{
; 859  : 			pLts_t->psyl = 1;

  00f8c	66 c7 83 34 04
	00 00 01 00	 mov	 WORD PTR [ebx+1076], 1
  00f95	5e		 pop	 esi
  00f96	5b		 pop	 ebx

; 865  : }

  00f97	c3		 ret	 0
$L72013:
  00f98	5f		 pop	 edi

; 860  : 			return;
; 861  : 		}		
; 862  : 	}
; 863  : 	/* Best default is stress first sylable.			*/
; 864  : 	pLts_t->psyl = 0;

  00f99	66 c7 83 34 04
	00 00 00 00	 mov	 WORD PTR [ebx+1076], 0
  00fa2	5e		 pop	 esi
  00fa3	5b		 pop	 ebx

; 865  : }

  00fa4	c3		 ret	 0
_ls_adju_best2syl ENDP
_pLts_t$ = 8
_ls_adju_final_fixes PROC NEAR

; 889  : 	PHONE	*pp;
; 890  : 	int	last;
; 891  : 
; 892  : 	last = SPRI;
; 893  : 	while (pLts_t->psyl!=0 && pLts_t->sylp[pLts_t->psyl-1]->p_stress!=SNONE) 

  00fb0	8b 44 24 04	 mov	 eax, DWORD PTR _pLts_t$[esp-4]
  00fb4	56		 push	 esi
  00fb5	57		 push	 edi
  00fb6	66 83 b8 34 04
	00 00 00	 cmp	 WORD PTR [eax+1076], 0
  00fbe	ba 7c 00 00 00	 mov	 edx, 124		; 0000007cH
  00fc3	bf 79 00 00 00	 mov	 edi, 121		; 00000079H
  00fc8	74 30		 je	 SHORT $L72178
$L72021:
  00fca	66 8b 88 34 04
	00 00		 mov	 cx, WORD PTR [eax+1076]
  00fd1	0f bf f1	 movsx	 esi, cx
  00fd4	8b b4 b0 04 04
	00 00		 mov	 esi, DWORD PTR [eax+esi*4+1028]
  00fdb	39 7e 10	 cmp	 DWORD PTR [esi+16], edi
  00fde	74 1a		 je	 SHORT $L72178

; 894  : 	{
; 895  : 		--pLts_t->psyl;

  00fe0	49		 dec	 ecx

; 896  : 		last = pLts_t->sylp[pLts_t->psyl]->p_stress;

  00fe1	0f bf d1	 movsx	 edx, cx
  00fe4	66 89 88 34 04
	00 00		 mov	 WORD PTR [eax+1076], cx
  00feb	8b 94 90 08 04
	00 00		 mov	 edx, DWORD PTR [eax+edx*4+1032]
  00ff2	66 85 c9	 test	 cx, cx
  00ff5	8b 52 10	 mov	 edx, DWORD PTR [edx+16]
  00ff8	75 d0		 jne	 SHORT $L72021
$L72178:

; 897  : 	}
; 898  : 	while (pLts_t->psyl != 0) 

  00ffa	66 8b 88 34 04
	00 00		 mov	 cx, WORD PTR [eax+1076]
  01001	66 85 c9	 test	 cx, cx
  01004	74 54		 je	 SHORT $L72025
  01006	be 7a 00 00 00	 mov	 esi, 122		; 0000007aH
$L72024:

; 899  : 	{
; 900  : 		--pLts_t->psyl;

  0100b	49		 dec	 ecx

; 901  : 		if (last == SUN) 

  0100c	3b d6		 cmp	 edx, esi
  0100e	66 89 88 34 04
	00 00		 mov	 WORD PTR [eax+1076], cx
  01015	75 1f		 jne	 SHORT $L72026

; 902  : 		{		/* Block reduction.	*/
; 903  : 			if (pLts_t->sylp[pLts_t->psyl]->p_stress == SNONE)

  01017	0f bf c9	 movsx	 ecx, cx
  0101a	8b 8c 88 08 04
	00 00		 mov	 ecx, DWORD PTR [eax+ecx*4+1032]
  01021	39 79 10	 cmp	 DWORD PTR [ecx+16], edi
  01024	75 09		 jne	 SHORT $L72027

; 904  : 				pLts_t->sylp[pLts_t->psyl]->p_flag |= PFBLOCK;

  01026	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  01029	80 ca 80	 or	 dl, -128		; ffffff80H
  0102c	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L72027:

; 905  : 			last = SSEC;

  0102f	ba 7b 00 00 00	 mov	 edx, 123		; 0000007bH

; 906  : 		} 
; 907  : 		else

  01034	eb 02		 jmp	 SHORT $L72028
$L72026:

; 908  : 		{
; 909  : 			last = SUN;

  01036	8b d6		 mov	 edx, esi
$L72028:

; 910  : 		}
; 911  : 		if (pLts_t->sylp[pLts_t->psyl]->p_stress == SNONE)

  01038	0f bf 88 34 04
	00 00		 movsx	 ecx, WORD PTR [eax+1076]
  0103f	8b 8c 88 08 04
	00 00		 mov	 ecx, DWORD PTR [eax+ecx*4+1032]
  01046	39 79 10	 cmp	 DWORD PTR [ecx+16], edi
  01049	75 03		 jne	 SHORT $L72029

; 912  : 			pLts_t->sylp[pLts_t->psyl]->p_stress = SUN;

  0104b	89 71 10	 mov	 DWORD PTR [ecx+16], esi
$L72029:

; 897  : 	}
; 898  : 	while (pLts_t->psyl != 0) 

  0104e	66 8b 88 34 04
	00 00		 mov	 cx, WORD PTR [eax+1076]
  01055	66 85 c9	 test	 cx, cx
  01058	75 b1		 jne	 SHORT $L72024
$L72025:

; 913  : 	}
; 914  : #ifdef ENGLISH
; 915  : 	pp = pLts_t->phead.p_fp;			/* [xn] => [^n].	*/

  0105a	8b 88 c8 08 00
	00		 mov	 ecx, DWORD PTR [eax+2248]
  01060	8d 90 c8 08 00
	00		 lea	 edx, DWORD PTR [eax+2248]

; 916  : 	if (pp->p_sphone ==AX
; 917  : 	&& (pp=pp->p_fp) != &pLts_t->phead
; 918  : 	&&  pp->p_sphone ==N
; 919  : 	&& (pp=pp->p_fp) != &pLts_t->phead
; 920  : 	&& (pp->p_flag&PFSYLAB) != 0) 

  01066	bf 11 00 00 00	 mov	 edi, 17			; 00000011H
  0106b	39 79 14	 cmp	 DWORD PTR [ecx+20], edi
  0106e	75 2d		 jne	 SHORT $L72030
  01070	8b 31		 mov	 esi, DWORD PTR [ecx]
  01072	3b f2		 cmp	 esi, edx
  01074	74 27		 je	 SHORT $L72030
  01076	83 7e 14 20	 cmp	 DWORD PTR [esi+20], 32	; 00000020H
  0107a	75 21		 jne	 SHORT $L72030
  0107c	8b 36		 mov	 esi, DWORD PTR [esi]
  0107e	3b f2		 cmp	 esi, edx
  01080	74 1b		 je	 SHORT $L72030
  01082	f6 46 0c 10	 test	 BYTE PTR [esi+12], 16	; 00000010H
  01086	74 15		 je	 SHORT $L72030

; 921  : 	{
; 922  : 		pp = pLts_t->phead.p_fp;
; 923  : 		pp->p_sphone = AH;

  01088	c7 41 14 09 00
	00 00		 mov	 DWORD PTR [ecx+20], 9

; 924  : 		pp->p_uphone = SIL;

  0108f	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 925  : 		pp->p_stress = SPRI;

  01096	c7 41 10 7c 00
	00 00		 mov	 DWORD PTR [ecx+16], 124	; 0000007cH
$L72030:

; 926  : 	}
; 927  : 	if (pLts_t->nsyl == 3) 

  0109d	66 83 b8 30 04
	00 00 03	 cmp	 WORD PTR [eax+1072], 3
  010a5	75 2d		 jne	 SHORT $L72033

; 928  : 	{	/* "camera" rule.	*/
; 929  : 		pp = pLts_t->phead.p_bp;

  010a7	8b 88 cc 08 00
	00		 mov	 ecx, DWORD PTR [eax+2252]

; 930  : 
; 931  : #ifdef DGC
; 932  : 		if (pp->p_sphone ==Z)		/* "cameras".		*/

  010ad	83 79 14 2a	 cmp	 DWORD PTR [ecx+20], 42	; 0000002aH
  010b1	75 03		 jne	 SHORT $L72032

; 933  : 			pp = pp->p_bp;

  010b3	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
$L72032:

; 934  : 		if (pp!=&pLts_t->phead && pp->p_sphone==AA && pp->p_uphone==AX)

  010b6	3b ca		 cmp	 ecx, edx
  010b8	74 1a		 je	 SHORT $L72033
  010ba	83 79 14 06	 cmp	 DWORD PTR [ecx+20], 6
  010be	75 14		 jne	 SHORT $L72033
  010c0	39 79 18	 cmp	 DWORD PTR [ecx+24], edi
  010c3	75 0f		 jne	 SHORT $L72033

; 935  : 			pLts_t->sylp[2]->p_flag &= ~PFBLOCK;

  010c5	8b 80 10 04 00
	00		 mov	 eax, DWORD PTR [eax+1040]
  010cb	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  010ce	80 e1 7f	 and	 cl, 127			; 0000007fH
  010d1	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$L72033:
  010d4	5f		 pop	 edi
  010d5	5e		 pop	 esi

; 936  : #else
; 937  : 		if (pp->p_sphone==AA && pp->p_uphone==AX)
; 938  : 			pLts_t->sylp[2]->p_flag &= ~PFBLOCK;
; 939  : #endif
; 940  : 	}       
; 941  : #endif   
; 942  : }

  010d6	c3		 ret	 0
_ls_adju_final_fixes ENDP
_TEXT	ENDS
PUBLIC	_ls_adju_allo1
_TEXT	SEGMENT
_pLts_t$ = 8
_fpp$ = 12
_lpp$ = 16
_ls_adju_allo1 PROC NEAR

; 966  : {

  010e0	53		 push	 ebx

; 967  : 	PHONE	*pp1;
; 968  : 	PHONE	*pp2;
; 969  : 	int	i;
; 970  : 
; 971  : 	pp1 = fpp;				/* Left end.		*/

  010e1	8b 5c 24 0c	 mov	 ebx, DWORD PTR _fpp$[esp]
  010e5	55		 push	 ebp

; 972  : 	while (pp1 != lpp) 

  010e6	8b 6c 24 14	 mov	 ebp, DWORD PTR _lpp$[esp+4]
  010ea	56		 push	 esi
  010eb	3b dd		 cmp	 ebx, ebp
  010ed	57		 push	 edi
  010ee	8b f3		 mov	 esi, ebx
  010f0	0f 84 b2 00 00
	00		 je	 $L72182
  010f6	8b 7c 24 14	 mov	 edi, DWORD PTR _pLts_t$[esp+12]
$L72045:

; 973  : 	{			/* Until right end.	*/
; 974  : 		/*
; 975  : 		 * [z] > [|][z] / [+Cons,+Sib] + - #
; 976  : 		 * [z] > [s]    / [+Cons,-Voice] + - #
; 977  : 		 */
; 978  : 		if (pp1->p_sphone == Z		/* Phoneme is "z"	*/
; 979  : 		&& (pp1->p_flag&PFMORPH) != 0	/* at left end of morph	*/
; 980  : 		&& pp1->p_fp == lpp		/* and right is "#"	*/
; 981  : 		&& pp1 != fpp) 

  010fa	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  010fd	83 f9 2a	 cmp	 ecx, 42			; 0000002aH
  01100	75 4e		 jne	 SHORT $L72050
  01102	f6 46 0c 0f	 test	 BYTE PTR [esi+12], 15	; 0000000fH
  01106	74 48		 je	 SHORT $L72050
  01108	39 2e		 cmp	 DWORD PTR [esi], ebp
  0110a	75 44		 jne	 SHORT $L72050
  0110c	3b f3		 cmp	 esi, ebx
  0110e	74 40		 je	 SHORT $L72050

; 982  : 		{		/* and stuff on left.	*/
; 983  : 			pp2 = pp1->p_bp;
; 984  : 			i = pfeat[pp2->p_sphone];

  01110	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  01113	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  01116	33 c0		 xor	 eax, eax
  01118	66 8b 04 55 00
	00 00 00	 mov	 ax, WORD PTR _pfeat[edx*2]

; 985  : 			if ((i&(PCONS|PSIB)) == (PCONS|PSIB)) 

  01120	8b d0		 mov	 edx, eax
  01122	83 e2 11	 and	 edx, 17			; 00000011H
  01125	80 fa 11	 cmp	 dl, 17			; 00000011H
  01128	75 16		 jne	 SHORT $L72048

; 986  : 			{
; 987  : 				if (ls_adju_ins_phone(pLts_t,pp1, IX, SIL, SUN) == FALSE)

  0112a	6a 7a		 push	 122			; 0000007aH
  0112c	6a 00		 push	 0
  0112e	6a 12		 push	 18			; 00000012H
  01130	56		 push	 esi
  01131	57		 push	 edi
  01132	e8 00 00 00 00	 call	 _ls_adju_ins_phone
  01137	83 c4 14	 add	 esp, 20			; 00000014H
  0113a	85 c0		 test	 eax, eax
  0113c	74 6a		 je	 SHORT $L72182

; 988  : 					return;
; 989  : 				pp1 = pp1->p_fp;
; 990  : 				continue;

  0113e	eb 5e		 jmp	 SHORT $L72055
$L72048:

; 991  : 			}
; 992  : 			if ((i&(PCONS|PVOICE)) == PCONS) 

  01140	83 e0 09	 and	 eax, 9
  01143	3c 01		 cmp	 al, 1
  01145	75 09		 jne	 SHORT $L72050

; 993  : 			{
; 994  : 				pp1->p_sphone = S;

  01147	c7 46 14 29 00
	00 00		 mov	 DWORD PTR [esi+20], 41	; 00000029H

; 995  : 				pp1 = pp1->p_fp;
; 996  : 				continue;

  0114e	eb 4e		 jmp	 SHORT $L72055
$L72050:

; 997  : 			}
; 998  : 		}
; 999  : 		/*
; 1000 : 		 * [d] > [|][d] / {[t],[d]} + - #
; 1001 : 		 * [d] > [t]    / [+Cons,-Voice] + - #
; 1002 : 		 */
; 1003 : 		if (pp1->p_sphone == D			/* Phoneme is "d"	*/
; 1004 : 		&& (pp1->p_flag&PFMORPH) != 0	/* at left end of morph	*/
; 1005 : 		&& pp1->p_fp == lpp				/* and right is "#"	*/
; 1006 : 		&& pp1 != fpp) 

  01150	83 f9 30	 cmp	 ecx, 48			; 00000030H
  01153	75 49		 jne	 SHORT $L72055
  01155	f6 46 0c 0f	 test	 BYTE PTR [esi+12], 15	; 0000000fH
  01159	74 43		 je	 SHORT $L72055
  0115b	39 2e		 cmp	 DWORD PTR [esi], ebp
  0115d	75 3f		 jne	 SHORT $L72055
  0115f	3b f3		 cmp	 esi, ebx
  01161	74 3b		 je	 SHORT $L72055

; 1007 : 		{		
; 1008 : 			/* and stuff on left.	*/
; 1009 : 			pp2 = pp1->p_bp;
; 1010 : 			i = pp2->p_sphone;

  01163	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  01166	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 1011 : 			if (i==T || i==D) 

  01169	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0116c	74 1c		 je	 SHORT $L72053
  0116e	3b c1		 cmp	 eax, ecx
  01170	74 18		 je	 SHORT $L72053

; 1014 : 					return;
; 1015 : 				pp1 = pp1->p_fp;
; 1016 : 				continue;
; 1017 : 			}
; 1018 : 			if ((pfeat[i]&(PCONS|PVOICE)) == PCONS) 

  01172	8a 0c 45 00 00
	00 00		 mov	 cl, BYTE PTR _pfeat[eax*2]
  01179	80 e1 09	 and	 cl, 9
  0117c	80 f9 01	 cmp	 cl, 1
  0117f	75 1d		 jne	 SHORT $L72055

; 1019 : 			{
; 1020 : 				pp1->p_sphone = T;

  01181	c7 46 14 2f 00
	00 00		 mov	 DWORD PTR [esi+20], 47	; 0000002fH

; 1021 : 				pp1 = pp1->p_fp;
; 1022 : 				continue;

  01188	eb 14		 jmp	 SHORT $L72055
$L72053:

; 1012 : 			{
; 1013 : 				if (ls_adju_ins_phone(pLts_t,pp1, IX, SIL, SUN) == FALSE)

  0118a	6a 7a		 push	 122			; 0000007aH
  0118c	6a 00		 push	 0
  0118e	6a 12		 push	 18			; 00000012H
  01190	56		 push	 esi
  01191	57		 push	 edi
  01192	e8 00 00 00 00	 call	 _ls_adju_ins_phone
  01197	83 c4 14	 add	 esp, 20			; 00000014H
  0119a	85 c0		 test	 eax, eax
  0119c	74 0a		 je	 SHORT $L72182
$L72055:

; 1023 : 			}
; 1024 : 		}
; 1025 : 		pp1 = pp1->p_fp;

  0119e	8b 36		 mov	 esi, DWORD PTR [esi]
  011a0	3b f5		 cmp	 esi, ebp
  011a2	0f 85 52 ff ff
	ff		 jne	 $L72045
$L72182:
  011a8	5f		 pop	 edi
  011a9	5e		 pop	 esi
  011aa	5d		 pop	 ebp
  011ab	5b		 pop	 ebx

; 1026 : 	}
; 1027 : }

  011ac	c3		 ret	 0
_ls_adju_allo1 ENDP
_TEXT	ENDS
PUBLIC	_ls_adju_delgemphone
_TEXT	SEGMENT
_pLts_t$ = 8
_pp$ = 12
_ph$ = 16
_ls_adju_delgemphone PROC NEAR

; 1053 : 	PHONE *bp;
; 1054 : 
; 1055 : 	bp = pp->p_bp;					/* Point at first.	*/

  011b0	8b 44 24 08	 mov	 eax, DWORD PTR _pp$[esp-4]

; 1056 : 	pp->p_sphone = ph;				/* Zap phoneme.		*/

  011b4	8b 54 24 0c	 mov	 edx, DWORD PTR _ph$[esp-4]
  011b8	56		 push	 esi
  011b9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1057 : 	pp->p_flag |= bp->p_flag;		/* Move flags forward.	*/

  011bc	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  011bf	89 50 14	 mov	 DWORD PTR [eax+20], edx
  011c2	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  011c5	0b f2		 or	 esi, edx
  011c7	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 1058 : 	if (bp->p_stress > pp->p_stress)/* Keep strongest.	*/

  011ca	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  011cd	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  011d0	3b d6		 cmp	 edx, esi
  011d2	5e		 pop	 esi
  011d3	7e 03		 jle	 SHORT $L72064

; 1059 : 		pp->p_stress = bp->p_stress;

  011d5	89 50 10	 mov	 DWORD PTR [eax+16], edx
$L72064:

; 1060 : 	ls_adju_del_phone(pLts_t,bp);	/* Delete first one.	*/ 

  011d8	8b 44 24 04	 mov	 eax, DWORD PTR _pLts_t$[esp-4]
  011dc	51		 push	 ecx
  011dd	50		 push	 eax
  011de	e8 00 00 00 00	 call	 _ls_adju_del_phone
  011e3	83 c4 08	 add	 esp, 8

; 1061 : }

  011e6	c3		 ret	 0
_ls_adju_delgemphone ENDP
_pp$ = 8
_ls_adju_is_obs PROC NEAR

; 1082 : 	if ((pfeat[pp->p_sphone]&POBS) != 0)

  011f0	8b 44 24 04	 mov	 eax, DWORD PTR _pp$[esp-4]
  011f4	33 d2		 xor	 edx, edx
  011f6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  011f9	8a 14 4d 00 00
	00 00		 mov	 dl, BYTE PTR _pfeat[ecx*2]
  01200	8b c2		 mov	 eax, edx
  01202	c1 e8 05	 shr	 eax, 5
  01205	83 e0 01	 and	 eax, 1

; 1083 : 	return (TRUE);
; 1084 : 	return (FALSE);
; 1085 : }

  01208	c3		 ret	 0
_ls_adju_is_obs ENDP
_TEXT	ENDS
EXTRN	_ls_rule_phone_alloc:NEAR
_TEXT	SEGMENT
_pLts_t$ = 8
_fpp$ = 12
_sph$ = 16
_uph$ = 20
_stress$ = 24
_ls_adju_ins_phone PROC NEAR

; 1115 : 	PHONE	*ipp;
; 1116 : 	PHONE	*bpp;
; 1117 : 
; 1118 : 	if ((ipp=ls_rule_phone_alloc(pLts_t)) == (PHONE *)NULL)		/* Get new node		*/

  01210	8b 44 24 04	 mov	 eax, DWORD PTR _pLts_t$[esp-4]
  01214	50		 push	 eax
  01215	e8 00 00 00 00	 call	 _ls_rule_phone_alloc
  0121a	83 c4 04	 add	 esp, 4
  0121d	85 c0		 test	 eax, eax
  0121f	75 01		 jne	 SHORT $L72084

; 1133 : }

  01221	c3		 ret	 0
$L72084:

; 1119 : 		return (FALSE);
; 1120 : 	bpp = fpp->p_bp;			/* Get previous		*/

  01222	8b 4c 24 08	 mov	 ecx, DWORD PTR _fpp$[esp-4]
  01226	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 1121 : 	bpp->p_fp = ipp;			/* Link in			*/

  01229	89 02		 mov	 DWORD PTR [edx], eax

; 1122 : 	ipp->p_fp = fpp;

  0122b	89 08		 mov	 DWORD PTR [eax], ecx

; 1123 : 	fpp->p_bp = ipp;

  0122d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1124 : 	ipp->p_bp = bpp;

  01230	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1125 : 	ipp->p_ip = NULL;			/* No index chain	*/
; 1126 : 	ipp->p_sphone = sph;		/* Phonemes			*/

  01233	8b 54 24 0c	 mov	 edx, DWORD PTR _sph$[esp-4]
  01237	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0123e	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 1127 : 	ipp->p_uphone = uph;

  01241	8b 54 24 10	 mov	 edx, DWORD PTR _uph$[esp-4]
  01245	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 1128 : 	ipp->p_flag = fpp->p_flag;	/* Move flags forward	*/

  01248	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0124b	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 1129 : 	fpp->p_flag = 0;
; 1130 : 	ipp->p_stress = stress;		/* Set stress			*/

  0124e	8b 54 24 14	 mov	 edx, DWORD PTR _stress$[esp-4]
  01252	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  01259	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 1131 : 	fpp->p_stress = SNONE;

  0125c	c7 41 10 79 00
	00 00		 mov	 DWORD PTR [ecx+16], 121	; 00000079H

; 1132 : 	return (TRUE);

  01263	b8 01 00 00 00	 mov	 eax, 1

; 1133 : }

  01268	c3		 ret	 0
_ls_adju_ins_phone ENDP
_TEXT	ENDS
EXTRN	_ls_rule_phone_free:NEAR
_TEXT	SEGMENT
_pLts_t$ = 8
_dpp$ = 12
_ls_adju_del_phone PROC NEAR

; 1158 : 	PHONE	*bpp;
; 1159 : 	PHONE	*fpp;
; 1160 : 
; 1161 : 	bpp = dpp->p_bp;				/* Get previous, next	*/

  01270	8b 44 24 08	 mov	 eax, DWORD PTR _dpp$[esp-4]

; 1162 : 	fpp = dpp->p_fp;
; 1163 : 	bpp->p_fp = fpp;				/* Break links			*/
; 1164 : 	fpp->p_bp = bpp;
; 1165 : 
; 1166 : /* GL 10/23/1996, remove unused index handling code */
; 1167 : #if 0
; 1168 : 	if (dpp->p_ip != NULL) 
; 1169 : 	{	/* Update index marks	*/
; 1170 : 		while (bpp->p_ip != NULL)
; 1171 : 			bpp = bpp->p_ip;
; 1172 : 		bpp->p_ip = dpp->p_ip;
; 1173 : 	}
; 1174 : #endif
; 1175 : 	ls_rule_phone_free(pLts_t,dpp);	/* Free the node		*/

  01274	50		 push	 eax
  01275	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01278	8b 10		 mov	 edx, DWORD PTR [eax]
  0127a	8b 44 24 08	 mov	 eax, DWORD PTR _pLts_t$[esp]
  0127e	89 11		 mov	 DWORD PTR [ecx], edx
  01280	50		 push	 eax
  01281	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  01284	e8 00 00 00 00	 call	 _ls_rule_phone_free
  01289	83 c4 08	 add	 esp, 8

; 1176 : }       

  0128c	c3		 ret	 0
_ls_adju_del_phone ENDP
_TEXT	ENDS
END
