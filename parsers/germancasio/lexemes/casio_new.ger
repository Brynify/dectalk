# This grammar attempts to assing some stresses. It is however rather restrictive
# It is based on some new ideas of assigning the stress after a simple sllabification method.lson
# That still needs a lot of improvement.

word  =>  stopword
        | solo
        | article
        | diction
	| article + betont + flexornot
	| name
	| name+"s/s/"
	| angli
	| freepref
	| konjbar + flexornot
	| Mroot + flexornot 
	| boundpref + Mroot + flexornot
	| <:> + rootblock
	| freepref + <:> + rootblock
        | verblock
	| freepref + verblock
	| freepref + "zu/T5/" + root + "en/@n/"
	| irgend + irgenddings
        | trysimple
	| lesloany
	| <:> + rootblock + rootblock
	| *longer(13)* + blocktrip
	| *longer(11)* + blocktwo
	| block + fugeornot + block + fugeornot + block
	| syll
        | sonderfall
#	| bitloany
#	| loany
#	| blocktwo
#	| blockthree
#        | <:> + syll + suff
#        | <:> + syll + <:> + syll + suff


rootblock=>  rootel + flexornot
	| rooten + flexornot
	| rooter + flexornot
	| roote + flexornot
	| root + flexornot
	| irrverb + flexornot


verblock=> verba
	| verbb
	| verbc
	| verb1
	| verb2
	| verb3
	| verb4
	| verb5
	| verb6
	| verb7

verba =>  "ge/.g@/" + <:> + rootel + flexornot
verbb =>  "ge/.g@/" + <:> + rooter + flexornot
verbc =>  "ge/.g@/" + <:> + rooten + flexornot
verb1 =>  "ge/.g@/" + <:> + root + flexornot
verb2 =>  "ge/.g@/" + <:> + geverb + flexornot
verb3 =>  "be/.b@/" + <:> + beverb + flexornot
verb4 =>  "er/.@R/" + <:> + erverb + flexornot
verb5 =>  "em/.Em/" + <:> + emverb + flexornot
verb6 =>  "ge/.g@/" + <:> + irrverb + flexornot
verb7 =>  "be/.b@/" + <:> + irrverb + flexornot

rootpos =>  rootel
          | rooten
          | rooter
          | root


trysimple=>    Mroot + suff + flexornot  
	    |  Mroot + Mroot + flexornot 
	    |  Mroot + <:> + root + flexornot
            |  Mroot + suff + Mroot + flexornot
	    |  Mroot + fugeornot + Mroot + flexornot
	    |  Mroot + fugeornot + pref + root + flexornot
	    |  Mroot + suff + <:> + root + flexornot
            |  Mroot + fugeornot + <:> + root + flexornot
            |  Mroot + suff + flexornot
            |  pref + <:> + rooter + suff
	    |  pref + <:> + rootel + suff
	    |  pref + <:> + rooten + suff
	    |  pref + Mroot + suff
	    |  pref + <:> + root + suff
	    |  <:> + root + <:> + root + flexornot
	    |  <:> + root + <:> + root + suff
	    |  <:> + root + fugeornot + <:> + root + flexornot
            |  <:> + root + fugeornot + Mroot + flexornot
	    |  Mroot + Mroot + suff + flexornot 
            |  Mroot  + <:> + root + root + flexornot 
            |  Mroot  + <:> + Mroot + root + flexornot
            |  Mroot  + <:> + root + Mroot + flexornot
            |  Mroot  + <:> + Mroot + Mroot + flexornot
            |  Mroot  + <:> + root + root + suff + flexornot 
            |  Mroot  + <:> + Mroot + root + suff + flexornot
            |  Mroot  + <:> + root + Mroot + suff + flexornot
            |  Mroot  + <:> + Mroot + Mroot + suff + flexornot
            |  Mroot + fugeornot + <:> + root + fugeornot + root + flexornot
            |  Mroot + fugeornot + <:> + Mroot + fugeornot + root + flexornot
            |  Mroot + fugeornot + <:> + root + fugeornot + Mroot + flexornot
            |  Mroot + fugeornot + <:> + Mroot + fugeornot + Mroot + flexornot
	
fugeornot=> EMPTY | "e/@/" | "en/N/" | "er/B/" | "es/@s/" | "n/n/" | "s/s/" | "t/t/"

blocktrip =>   <:> + root + root + Mroot + suff
           | pref + <:> + root + root + Mroot + suff
           | <:> + rootpos + fugeornot +  <:> + rootpos + fugeornot + <:>+  rootpos + flexornot

blocktwo =>  block  + block

block =>   pref + <:> + rooter + suff
	 | pref + <:> + rootel + suff
	 | pref + <:> + rooten + suff
	 | pref + Mroot + suff
	 | pref + <:> + root + suff



lesloany => pref + <:> + Mroot + interfix + suff


interfix=>  EMPTY | "i/i/" | "o/o/" | "a/a/" | "u/u/" 


#rootel=>Grootel+"el/.@L/2/"
#rooter=>Grooter+"er/.@R/2/"
#rooten=>Grooten+"en/.@n/"


pref => freepref
      | boundpref
      | freepref + boundpref
      | boundpref + boundpref
      | freepref + freepref 
      | boundpref + freepref
      | freepref + freepref + boundpref
      | EMPTY      


suff => EMPTY 
     | suffix
     | flex 
     | suffix + flexornot
     | interfix + suffix + flexornot

trailer=> suffix
        | flex

suffix =>  longsuff
         | shortsuff

flexornot=> EMPTY 
	| flex

multisyll=> syll
          | syll + multisyll

syll =>  <:> + root
	|<:> + onset + rhyme
	|<.> + flex
        |<:> + <|>+rhyme
        

rhyme => elongvowel + scoda 
      | diph + scoda
      | svowel + geminy
      | svowel + lcoda
      | elongvowel+"h//"+scoda
      | "ie/3/" + scoda
      | diph 
      | elongvowel
      | elongvowel+"h//"



sfix =>  "s/z/1/"  | "t/t/" | "st/st/" | "ts/ts/"

lightV => "e/e/" | "i/I/" | "ü/Y/" | "ue/Y/" | "ö/Q/" | "oe/Q/" | "ä/V/" | "ae/V/" | "ei/A/" | "eu/H/" | "aeu/H/" | "äu/H/" | "y/y/"
darkV  => "a/a/" | "o/c/" | "u/u/" | "au/W/"

# lightV => "e" | "i" | "ü" | "ue" | "ö" | "oe" | "ä" | "ae" | "*"
# darkV  => "a" | "o" | "u"




shvow => "i/I/" | "o/c/" | "u/U/" | "a/a/" | "e/E/" | "y/Y/"
shuml => "ae/V/" | "ä/V/" | "oe/Q/" | "ö/Q/" | "ue/Y/" | "ü/Y/"

midvow => "i/i/" | "o/o/" | "u/u/" | "a/a/" | "e/e/" | "y/y/" | "ü/y/" | "ö/Q/" | "oe/Q/" | "ue/y/"

#sonderfall => *special(1)* + capital
#	| *special(2)* + abrev 
#	| *special(4)* + signed
#	| *special(8)* + apost

sonderfall =>  abrev 
	| signed
	| apost



# numbers in this form .I. mean
#               root type are 1: have no stress in them
#               prefix type are 2
#               postfix type are 3
#               trivial 4: onsets, offsets, single letters and such
#               additional roots with stress markers. e.g., Mroots.pho
#      
#  Note: Numbers greater equal 10 are actually used modulo 10.
#  the 10 is added to indicated that they should be in memory
#  This trick was built in for Casio
#  

ltrie .0. name = "Names.pho"  
ltrie .0. root= "syllroots.pho"
ltrie .0. Mroot= "Mroots.pho"

ltrie .0. freepref= "freeprefixes.pho"
ltrie .0. boundpref= "boundprefixes.pho"
ltrie .0. latbound= "latboundpref.pho"
ltrie .0. stressp= "stresspref.pho"

ltrie .0. longsuff= "longsuffixes.pho"
ltrie .0. shortsuff= "shortsuffix.pho"
ltrie .0. flex = "Flex.pho"

trie svowel = "gshortnucleus.pho"
trie latvow = "latvowels.pho"
ltrie .14. diph = "diphthongs.pho"

ltrie .0. lcoda = "longcoda.pho"
ltrie .0. geminy = "geminycoda.pho"
ltrie .0. onset = "onsets.pho"
ltrie .14. elongvowel = "elongatednuclei.pho"

ltrie .0. rootel= "rootels.pho"     // roots ending in el
ltrie .0. rooten= "rootens.pho"     // roots with en
ltrie .0. rooter= "rooters.pho"     // roots ending in er
ltrie .0. roote= "rootes.pho"       // roots ending in e
ltrie .0. irrverb= "irregVerbStemms.pho"
ltrie .0. beverb= "beverbs.pho"
ltrie .0. geverb= "geverbs.pho"
ltrie .0. erverb= "erverbs.pho"
ltrie .0. emverb= "emverbs.pho"

trie solo= "solo.pho"
ltrie .0. stopword= "particular.pho"

ltrie .0. article= "articles.pho"
ltrie .0. diction= "diction.pho"

ltrie  .10. fuge= "Fugen.pho"
# ltrie  .6. specfix= "interfix.pho"
trie  specfix= "interfix.pho"
ltrie  .0. lathead = "loanonset.pho"
ltrie  .0. goodcoda = "rulecodas.pho"
ltrie  .0. scoda = "shortcodas.pho"
ltrie  .13. specrhyme= "trailers.pho"
ltrie  .14. umlaut = "shortumlaut.pho"
ltrie  .14. goodnuk= "goodnuclei.pho"
ltrie  .13. erhyme= "erhyme.pho"
trie  trunkfix= "truncatedfixes.pho"
trie  apost = "apostroph.pho"
trie  abrev = "abkuerzung.pho"
trie  signed = "signature.pho"
ltrie .0. triv= "trivial.pho"
ltrie .0. angli = "anglizis.pho"
ltrie .0. konjbar = "konjugierbar.pho"
ltrie .0. irgend = "irgend.pho"
ltrie .0. irgenddings = "irgenddings.pho"
trie  betont = "betont.pho"
ltrie .1. ones = "ones.pho"
ltrie .2. twos = "twos.pho"
ltrie .3. threes = "threes.pho"
ltrie .4. fours = "fours.pho"
ltrie .5. fives = "fives.pho"

$eof